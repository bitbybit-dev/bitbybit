"use strict";
exports.__esModule = true;
exports.baseDeclarations = void 0;
exports.baseDeclarations = "declare class Asset {\n    readonly assetManager: AssetManager;\n    constructor();\n    /**\n     * Gets the asset file\n     * @param inputs file name to get from project assets\n     * @returns Blob of asset\n     */\n    getFile(inputs: Inputs.Asset.GetAssetDto): Promise<File>;\n    /**\n     * Gets the local asset file stored in your browser.\n     * @param inputs asset name to get from local assets\n     * @returns Blob of asset\n     */\n    getLocalFile(inputs: Inputs.Asset.GetAssetDto): Promise<File | File[]>;\n}/**\n * Contains various functions that expose BABYLONJS objects\n */\ndeclare class Babylon {\n    mesh: BabylonMesh;\n    camera: BabylonCamera;\n    webxr: BabylonWebXR;\n    node: BabylonNode;\n    scene: BabylonScene;\n    transforms: BabylonTransforms;\n    io: BabylonIO;\n    ray: BabylonRay;\n    pick: BabylonPick;\n    material: BabylonMaterial;\n    constructor(context: Context, geometryHelper: GeometryHelper, color: Color);\n}declare class BabylonArcRotateCamera {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates a arc rotate camera\n     * @param inputs Describes the arc rotate camera\n     * @returns BabylonJS arc rotate camera\n     */\n    create(inputs: Inputs.BabylonCamera.ArcRotateCameraDto): ArcRotateCamera;\n}declare class BabylonCamera {\n    private readonly context;\n    free: BabylonFreeCamera;\n    arcRotate: BabylonArcRotateCamera;\n    target: BabylonTargetCamera;\n    constructor(context: Context);\n    /**\n     * Freeze projection matrix of the camera\n     * @param inputs Camera to freeze\n     */\n    freezeProjectionMatrix(inputs: Inputs.BabylonCamera.CameraDto): void;\n    /**\n     * Unfreeze projection matrix of the camera\n     * @param inputs Camera to freeze\n     */\n    unfreezeProjectionMatrix(inputs: Inputs.BabylonCamera.CameraDto): void;\n    /**\n     * Changes the position of a camera\n     * @param inputs Changes the camera position\n     */\n    setPosition(inputs: Inputs.BabylonCamera.PositionDto): void;\n    /**\n     * Gets the position of a camera\n     * @param inputs Gets the camera position\n     */\n    getPosition(inputs: Inputs.BabylonCamera.PositionDto): Base.Point3;\n    /**\n     * Changes the target of a camera\n     * @param inputs Changes the camera target\n     */\n    setTarget(inputs: Inputs.BabylonCamera.TargetDto): void;\n    /**\n     * Gets the target of a camera\n     * @param inputs Gets the camera position\n     */\n    getTarget(inputs: Inputs.BabylonCamera.PositionDto): Base.Point3;\n    /**\n     * Changes the speed of a camera\n     * @param inputs Changes the camera target\n     */\n    setSpeed(inputs: Inputs.BabylonCamera.SpeedDto): void;\n    /**\n     * Gets the speed of a camera\n     * @param inputs Gets the camera position\n     */\n    getSpeed(inputs: Inputs.BabylonCamera.PositionDto): Base.Point3;\n    /**\n     * Changes the minZ of a camera\n     * @param inputs Changes the camera minZ\n     */\n    setMinZ(inputs: Inputs.BabylonCamera.MinZDto): void;\n    /**\n     * Changes the maxZ of a camera\n     * @param inputs Changes the camera maxZ\n     */\n    setMaxZ(inputs: Inputs.BabylonCamera.MaxZDto): void;\n}declare class BabylonFreeCamera {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates a free camera\n     * @param inputs Describes the free camera\n     * @returns BabylonJS free camera\n     */\n    create(inputs: Inputs.BabylonCamera.FreeCameraDto): FreeCamera;\n}declare class BabylonTargetCamera {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates a target camera\n     * @param inputs Describes the target camera\n     * @returns BabylonJS target camera\n     */\n    create(inputs: Inputs.BabylonCamera.TargetCameraDto): TargetCamera;\n}declare class BabylonIO {\n    private readonly context;\n    private supportedFileFormats;\n    private objectUrl;\n    constructor(context: Context);\n    /**\n     * Imports mesh from the asset that you have uploaded for the project.\n     * You must upload your assets to your project via project management page.\n     * @returns scene loaded mesh\n     * @group load\n     * @shortname asset\n     */\n    loadAssetIntoScene(inputs: Inputs.Asset.AssetFileDto): Promise<Mesh>;\n    /**\n     * Imports mesh from the asset url that you have uploaded to an accessible web storage.\n     * Keep in mind that files need to be publically accessible for this to work, be sure that CORS access is enabled for the assets.\n     * @returns scene loaded mesh\n     * @group load\n     * @shortname asset from url\n     */\n    loadAssetIntoSceneFromRootUrl(inputs: Inputs.Asset.AssetFileByUrlDto): Promise<Mesh>;\n    /**\n     * Exports the whole scene to .babylon scene format. You can then edit it further in babylonjs editors.\n     * @param inputs filename\n     * @group export\n     * @shortname babylon scene\n     */\n    exportBabylon(inputs: Inputs.BabylonIO.ExportSceneDto): void;\n    /**\n     * Exports the whole scene to .glb format. This file format has become industry standard for web models.\n     * @param inputs filename\n     * @group export\n     * @shortname gltf scene\n     */\n    exportGLB(inputs: Inputs.BabylonIO.ExportSceneDto): void;\n    /**\n     * Exports the mesh or meshes to stl\n     * @param inputs filename and the mesh\n     * @group export\n     * @shortname babylon mesh to stl\n     */\n    exportMeshToStl(inputs: Inputs.BabylonIO.ExportMeshToStlDto): Promise<any>;\n    private loadAsset;\n}declare class BabylonMaterial {\n    private readonly context;\n    private readonly color;\n    pbrMetallicRoughness: BabylonMaterialPbrMetallicRoughness;\n    constructor(context: Context, color: Color);\n}declare class BabylonMaterialPbrMetallicRoughness {\n    private readonly context;\n    private readonly color;\n    constructor(context: Context, color: Color);\n    /**\n     * Create PBR metallic roughnes material.\n     * @param inputs required to set up metallic roughness material\n     * @returns PBR metallic roughness material\n     * @group create\n     * @shortname material\n     * @disposableOutput true\n     */\n    create(inputs: Inputs.BabylonMaterial.PBRMetallicRoughnessDto): PBRMetallicRoughnessMaterial;\n    /**\n     * Sets the base color of material\n     * @param inputs base color and material\n     * @group set\n     * @shortname base color\n     */\n    setBaseColor(inputs: Inputs.BabylonMaterial.BaseColorDto): void;\n    /**\n     * Sets the metallic property of material\n     * @param inputs metallic value\n     * @group set\n     * @shortname metallic\n     */\n    setMetallic(inputs: Inputs.BabylonMaterial.MetallicDto): void;\n    /**\n     * Sets the roughness of material\n     * @param inputs roughness value\n     * @group set\n     * @shortname roughness\n     */\n    setRoughness(inputs: Inputs.BabylonMaterial.RoughnessDto): void;\n    /**\n     * Sets the alpha of material\n     * @param inputs alpha value\n     * @group set\n     * @shortname alpha\n     */\n    setAlpha(inputs: Inputs.BabylonMaterial.AlphaDto): void;\n    /**\n     * Sets the back face culling of material\n     * @param inputs back face culling boolean\n     * @group set\n     * @shortname back face culling\n     */\n    setBackFaceCulling(inputs: Inputs.BabylonMaterial.BackFaceCullingDto): void;\n    /**\n     * Gets the base color of material\n     * @param inputs base color and material\n     * @return base color\n     * @group get\n     * @shortname base color\n     */\n    getBaseColor(inputs: Inputs.BabylonMaterial.MaterialPropDto): string;\n    /**\n     * Gets the metallic property of material\n     * @param inputs metallic value\n     * @return metallic value\n     * @group get\n     * @shortname metallic\n     */\n    getMetallic(inputs: Inputs.BabylonMaterial.MaterialPropDto): number;\n    /**\n     * Gets the roughness of material\n     * @param inputs roughness value\n     * @return roughness value\n     * @group get\n     * @shortname roughness\n     */\n    getRoughness(inputs: Inputs.BabylonMaterial.MaterialPropDto): number;\n    /**\n     * Gets the alpha of material\n     * @param inputs alpha value\n     * @return alpha value\n     * @group get\n     * @shortname alpha\n     */\n    getAlpha(inputs: Inputs.BabylonMaterial.MaterialPropDto): number;\n    /**\n     * Gets the back face culling of material\n     * @param inputs back face culling boolean\n     * @return backfaceculling boolean\n     * @group get\n     * @shortname back face culling\n     */\n    getBackFaceCulling(inputs: Inputs.BabylonMaterial.MaterialPropDto): boolean;\n}declare class BabylonMesh {\n    private readonly context;\n    constructor(context: Context);\n    /** Disposes drawn mesh object from the scene\n     * @param inputs Contains BabylonJS mesh that should be disposed\n     * @group memory\n     * @shortname dispose\n     */\n    dispose(inputs: Inputs.BabylonMesh.BabylonMeshDto): void;\n    /** Udates drawn BabylonJS mesh object without disposing it\n     * @param inputs Contains BabylonJS mesh that should be updated, together with position, rotation, scaling and colour info\n     * @returns BabylonJS Mesh\n     * @group movement\n     * @shortname update drawn\n     * @ignore true\n     */\n    updateDrawn(inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMesh): void;\n    /**\n     * Change the visibility of a drawn BabylonJS mesh\n     * @param inputs BabylonJS mesh and parent mesh\n     * @group visibility\n     * @shortname set visibility\n     */\n    setVisibility(inputs: Inputs.BabylonMesh.SetMeshVisibilityDto): void;\n    /**\n     * Hides the mesh\n     * @param inputs BabylonJS mesh to hide\n     * @group visibility\n     * @shortname hide\n     */\n    hide(inputs: Inputs.BabylonMesh.ShowHideMeshDto): void;\n    /**\n     * Show the mesh\n     * @param inputs BabylonJS mesh to hide\n     * @group visibility\n     * @shortname show\n     */\n    show(inputs: Inputs.BabylonMesh.ShowHideMeshDto): void;\n    /**\n     * Change the parent of the drawn mesh\n     * @param inputs BabylonJS mesh and parent mesh\n     * @group set\n     * @shortname parent\n     */\n    setParent(inputs: Inputs.BabylonMesh.SetParentDto): void;\n    /**\n     * Get the parent of the drawn mesh\n     * @param inputs BabylonJS mesh\n     * @returns Parent mesh\n     * @group get\n     * @shortname parent\n     */\n    /**\n     * Change the check collisions property of the drawn mesh\n     * @param inputs BabylonJS mesh and check collisions\n     * @group set\n     * @shortname check collisions\n     */\n    setCheckCollisions(inputs: Inputs.BabylonMesh.CheckCollisionsBabylonMeshDto): void;\n    /**\n     * Get the check collisions property of the drawn mesh\n     * @param inputs BabylonJS mesh and check collisions\n     * @group get\n     * @shortname check collisions\n     */\n    getCheckCollisions(inputs: Inputs.BabylonMesh.CheckCollisionsBabylonMeshDto): boolean;\n    /**\n     * Change the pickable property of the drawn mesh\n     * @param inputs BabylonJS mesh and pickable\n     * @group get\n     * @shortname check collisions\n     */\n    setPickable(inputs: Inputs.BabylonMesh.PickableBabylonMeshDto): void;\n    /**\n     * Change the pickable property of the drawn mesh\n     * @param inputs BabylonJS mesh and pickable\n     * @group get\n     * @shortname pickable\n     */\n    getPickable(inputs: Inputs.BabylonMesh.BabylonMeshDto): boolean;\n    /**\n     * Gets meshes that have names which contain a given text\n     * @param inputs BabylonJS mesh and name\n     * @group get\n     * @shortname meshes where name contains\n     */\n    getMeshesWhereNameContains(inputs: Inputs.BabylonMesh.NameBabylonMeshDto): AbstractMesh[];\n    /**\n     * Gets child meshes\n     * @param inputs BabylonJS mesh and whether to include only direct descendants\n     * @group get\n     * @shortname child meshes\n     */\n    getChildMeshes(inputs: Inputs.BabylonMesh.ChildMeshesBabylonMeshDto): AbstractMesh[];\n    /**\n     * Gets meshes of id\n     * @param inputs BabylonJS mesh and name\n     * @group get\n     * @shortname meshes by id\n     */\n    getMeshesOfId(inputs: Inputs.BabylonMesh.IdBabylonMeshDto): AbstractMesh[];\n    /**\n     * Gets mesh of id\n     * @param inputs BabylonJS mesh and name\n     * @group get\n     * @shortname mesh by id\n     */\n    getMeshOfId(inputs: Inputs.BabylonMesh.IdBabylonMeshDto): AbstractMesh;\n    /**\n     * Gets mesh of unique id\n     * @param inputs BabylonJS mesh and name\n     * @group get\n     * @shortname mesh by unique id\n     */\n    getMeshOfUniqueId(inputs: Inputs.BabylonMesh.UniqueIdBabylonMeshDto): AbstractMesh;\n    /**\n     * Clones the mesh\n     * @param inputs BabylonJS mesh to clone\n     * @returns a new mesh\n     * @group edit\n     * @shortname clone\n     * @disposableOutput true\n     */\n    clone(inputs: Inputs.BabylonMesh.BabylonMeshDto): Mesh;\n    /**\n     * Change the id of the drawn mesh\n     * @param inputs BabylonJS mesh and name\n     * @group set\n     * @shortname id\n     */\n    setId(inputs: Inputs.BabylonMesh.IdBabylonMeshDto): void;\n    /**\n     * Get the id of the drawn mesh\n     * @param inputs BabylonJS mesh and id\n     * @group get\n     * @shortname id\n     */\n    getId(inputs: Inputs.BabylonMesh.IdBabylonMeshDto): string;\n    /**\n     * Get the unique id of the drawn mesh\n     * @param inputs BabylonJS mesh and id\n     * @returns unique id number\n     * @group get\n     * @shortname unique id\n     */\n    getUniqueId(inputs: Inputs.BabylonMesh.BabylonMeshDto): number;\n    /**\n     * Change the name of the drawn mesh\n     * @param inputs BabylonJS mesh and name\n     * @group set\n     * @shortname name\n     */\n    setName(inputs: Inputs.BabylonMesh.NameBabylonMeshDto): void;\n    /**\n     * Gets the name of babylon mesh\n     * @param inputs BabylonJS mesh and name\n     * @group get\n     * @shortname name\n     */\n    getName(inputs: Inputs.BabylonMesh.BabylonMeshDto): string;\n    /**\n     * Change the material of the drawn mesh\n     * @param inputs BabylonJS mesh and material\n     * @group set\n     * @shortname material\n     */\n    setMaterial(inputs: Inputs.BabylonMesh.MaterialBabylonMeshDto): void;\n    /**\n     * Gets the material of babylon mesh\n     * @param inputs BabylonJS mesh\n     * @group get\n     * @shortname material\n     */\n    getMaterial(inputs: Inputs.BabylonMesh.BabylonMeshDto): Material;\n    /**\n     * Gets the position as point of babylonjs mesh\n     * @param inputs BabylonJS mesh\n     * @returns point\n     * @group get\n     * @shortname position\n     */\n    getPosition(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;\n    /**\n     * Gets the absolute position in the world as point of babylonjs mesh\n     * @param inputs BabylonJS mesh\n     * @returns point\n     * @group get\n     * @shortname absolute position\n     */\n    getAbsolutePosition(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;\n    /**\n     * Gets the rotation vector of babylonjs mesh\n     * @param inputs BabylonJS mesh\n     * @group get\n     * @shortname rotation\n     */\n    getRotation(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;\n    /**\n     * Gets the scale vector of babylonjs mesh\n     * @param inputs BabylonJS mesh\n     * @group get\n     * @shortname scale\n     */\n    getScale(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;\n    /**\n     * Moves babylonjs mesh forward in local space\n     * @param inputs BabylonJS mesh and distance\n     * @group move\n     * @shortname forward\n     */\n    moveForward(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;\n    /**\n     * Moves babylonjs mesh backward in local space\n     * @param inputs BabylonJS mesh and distance\n     * @group move\n     * @shortname backward\n     */\n    moveBackward(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;\n    /**\n     * Moves babylonjs mesh up in local space\n     * @param inputs BabylonJS mesh and distance\n     * @group move\n     * @shortname up\n     */\n    moveUp(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;\n    /**\n     * Moves babylonjs mesh down in local space\n     * @param inputs BabylonJS mesh and distance\n     * @group move\n     * @shortname down\n     */\n    moveDown(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;\n    /**\n     * Moves babylonjs mesh right in local space\n     * @param inputs BabylonJS mesh and distance\n     * @group move\n     * @shortname right\n     */\n    moveRight(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;\n    /**\n     * Moves babylonjs mesh left in local space\n     * @param inputs BabylonJS mesh and distance\n     * @group move\n     * @shortname left\n     */\n    moveLeft(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;\n    /**\n     * Rotates babylonjs mesh around local y axis\n     * @param inputs BabylonJS mesh and rotation in degrees\n     * @group move\n     * @shortname yaw\n     */\n    yaw(inputs: Inputs.BabylonMesh.RotateBabylonMeshDto): void;\n    /**\n     * Rotates babylonjs mesh around local x axis\n     * @param inputs BabylonJS mesh and rotation in degrees\n     * @group move\n     * @shortname pitch\n     */\n    pitch(inputs: Inputs.BabylonMesh.RotateBabylonMeshDto): void;\n    /**\n     * Rotates babylonjs mesh around local z axis\n     * @param inputs BabylonJS mesh and rotation in degrees\n     * @group move\n     * @shortname roll\n     */\n    roll(inputs: Inputs.BabylonMesh.RotateBabylonMeshDto): void;\n    /**\n     * Updates the position of the BabylonJS mesh or instanced mesh\n     * @param inputs BabylonJS mesh and position point\n     * @group set\n     * @shortname position\n     */\n    setPosition(inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMeshPositionDto): void;\n    /**\n     * Updates the rotation of the BabylonJS mesh or instanced mesh\n     * @param inputs BabylonJS mesh and rotation along x, y and z axis in degrees\n     * @group set\n     * @shortname rotation\n     */\n    setRotation(inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMeshRotationDto): void;\n    /**\n     * Updates the scale of the BabylonJS mesh or instanced mesh\n     * @param inputs BabylonJS mesh and scale vector\n     * @group set\n     * @shortname scale\n     */\n    setScale(inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMeshScaleDto): void;\n    /**\n     * Checks wether mesh intersects another mesh mesh\n     * @param inputs Two BabylonJS meshes\n     * @group intersects\n     * @shortname mesh\n     */\n    intersectsMesh(inputs: Inputs.BabylonMesh.IntersectsMeshDto): boolean;\n    /**\n     * Checks wether mesh intersects point\n     * @param inputs BabylonJS mesh and point\n     * @group intersects\n     * @shortname point\n     */\n    intersectsPoint(inputs: Inputs.BabylonMesh.IntersectsPointDto): boolean;\n    /**\n     * Creates mesh instance and transforms it for optimised rendering. These are optimised for max performance\n     * when rendering many similar objects in the scene. If the mesh has children, then every child ges a mesh instance.\n     * @group instance\n     * @shortname create and transform\n     * @disposableOutput true\n     */\n    createMeshInstanceAndTransform(inputs: Inputs.BabylonMesh.MeshInstanceAndTransformDto): Promise<any>;\n    /**\n     * Creates mesh instance. These are optimised for max performance\n     * when rendering many similar objects in the scene. If the mesh has children, then every child gets a mesh instance.\n     * @group instance\n     * @shortname create\n     * @disposableOutput true\n     */\n    createMeshInstance(inputs: Inputs.BabylonMesh.MeshInstanceDto): InstancedMesh;\n    private assignColorToMesh;\n}/**\n * Nodes help understand the space and construct more complicated space structures. Nodes can be nested together\n * into child parent relationships to simplify the creation of 3D objects.\n */\ndeclare class BabylonNode {\n    private readonly context;\n    private readonly geometryHelper;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Draws a node of given size with given colours for every axis\n     * @param inputs Contains node data that includes size and colour information\n     */\n    drawNode(inputs: Inputs.BabylonNode.DrawNodeDto): void;\n    /**\n     * Draws a nodes of given size with given colours for every axis\n     * @param inputs Contains node data that includes size and colour information\n     */\n    drawNodes(inputs: Inputs.BabylonNode.DrawNodesDto): void;\n    /**\n     * Creates a node on the origin with the given rotations in the parent coordinate system\n     * @param inputs Contains information for origin, rotation and parent node\n     * @returns A new node\n     */\n    createNodeFromRotation(inputs: Inputs.BabylonNode.CreateNodeFromRotationDto): TransformNode;\n    /**\n     * Creates a world node which has root node as his parent\n     * @returns A new node whos parent is the root node of the scene\n     */\n    createWorldNode(): TransformNode;\n    /**\n     * Gets the absolute forward facing vector in world space\n     * @param inputs Node from which to get the forward vector\n     * @returns Vector as an array of numbers\n     */\n    getAbsoluteForwardVector(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets the absolute right facing vector in world space\n     * @param inputs Node from which to get the right vector\n     * @returns Vector as an array of numbers\n     */\n    getAbsoluteRightVector(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets the absolute up facing vector in world space\n     * @param inputs Node from which to get the up vector\n     * @returns Vector as an array of numbers\n     */\n    getAbsoluteUpVector(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets the absolute position of the node as origin vector in world space\n     * @param inputs Node from which to get the absolute position\n     * @returns Vector as an array of numbers indicating location of origin in world space\n     */\n    getAbsolutePosition(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets the absolute rotation of the node as a transformation matrix encoded in array of 16 numbers\n     * @param inputs Node from which to get the rotation transformation\n     * @returns Transformation as an array of 16 numbers\n     */\n    getAbsoluteRotationTransformation(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets the rotation of the node in local parent coordinate space as a transformation matrix encoded in array of 16 numbers\n     * @param inputs Node from which to get the rotation transformation\n     * @returns Transformation as an array of 16 numbers\n     */\n    getRotationTransformation(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets children of the node\n     * @param inputs Node from which to get the children\n     * @returns List of children nodes in the array\n     */\n    getChildren(inputs: Inputs.BabylonNode.NodeDto): Node[];\n    /**\n     * Gets parent of the node\n     * @param inputs Node from which to get a parent\n     * @returns Parent node\n     */\n    getParent(inputs: Inputs.BabylonNode.NodeDto): Node;\n    /**\n     * Gets the position of the node expressed in local space\n     * @param inputs Node from which to get the position in local space\n     * @returns Position vector\n     */\n    getPositionExpressedInLocalSpace(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Gets the root node\n     * @returns Root node\n     */\n    getRootNode(): TransformNode;\n    /**\n     * Gets the euler rotations\n     * @param inputs Node from which to get rotation\n     * @returns Euler rotations of x, y and z angles in the number array\n     */\n    getRotation(inputs: Inputs.BabylonNode.NodeDto): number[];\n    /**\n     * Rotates the node around axis and given position by a given angle\n     * @param inputs Rotation around axis information\n     */\n    rotateAroundAxisWithPosition(inputs: Inputs.BabylonNode.RotateAroundAxisNodeDto): void;\n    /**\n     * Rotates the node around the origin and given axis\n     * @param inputs Rotation information\n     */\n    rotate(inputs: Inputs.BabylonNode.RotateNodeDto): void;\n    /**\n     * Sets the absolute position of the node\n     * @param inputs Node absolute position information\n     */\n    setAbsolutePosition(inputs: Inputs.BabylonNode.NodePositionDto): void;\n    /**\n     * Sets the direction of the node\n     * @param inputs Direction information\n     */\n    setDirection(inputs: Inputs.BabylonNode.NodeDirectionDto): void;\n    /**\n     * Sets the new parent to the node\n     * @param inputs Node parent information\n     */\n    setParent(inputs: Inputs.BabylonNode.NodeParentDto): void;\n    /**\n     * Translates the node by a given direction vector and a distance\n     * @param inputs Node translation information\n     */\n    translate(inputs: Inputs.BabylonNode.NodeTranslationDto): void;\n}declare class BabylonPick {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Get a hit result of picking with ray\n     * @param inputs ray to use for picking\n     * @returns Picking info\n     */\n    pickWithRay(inputs: Inputs.BabylonPick.RayDto): PickingInfo;\n    /**\n     * Pick with picking ray of the current mouse position in the active camera\n     * @returns Picking info\n     */\n    pickWithPickingRay(): PickingInfo;\n    /**\n     * Get the distance to the object if picking result exists\n     * @param inputs picking result\n     * @returns Distance\n     */\n    getDistance(inputs: Inputs.BabylonPick.PickInfo): number;\n    /**\n     * Get the picked mesh\n     * @param inputs picking result\n     * @returns Picked mesh\n     */\n    getPickedMesh(inputs: Inputs.BabylonPick.PickInfo): AbstractMesh;\n    /**\n     * Get the picked point\n     * @param inputs picking result\n     * @returns Picked point\n     */\n    getPickedPoint(inputs: Inputs.BabylonPick.PickInfo): Base.Point3;\n    /**\n     * Check if pick ray hit something in the scene or not\n     * @param inputs picking result\n     * @returns Indication of a hit\n     */\n    hit(inputs: Inputs.BabylonPick.PickInfo): boolean;\n    /**\n     * Gets the unique submesh id if it was picked\n     * @param inputs picking result\n     * @returns Submesh id\n     */\n    getSubMeshId(inputs: Inputs.BabylonPick.PickInfo): number;\n    /**\n     * Gets the unique submesh face id if it was picked\n     * @param inputs picking result\n     * @returns Submesh face id\n     */\n    getSubMeshFaceId(inputs: Inputs.BabylonPick.PickInfo): number;\n    /**\n     * Gets the the barycentric U coordinate that is used when calculating the texture coordinates of the collision\n     * @param inputs picking result\n     * @returns U coordinate\n     */\n    getBU(inputs: Inputs.BabylonPick.PickInfo): number;\n    /**\n     * Gets the the barycentric V coordinate that is used when calculating the texture coordinates of the collision\n     * @param inputs picking result\n     * @returns V coordinate\n     */\n    getBV(inputs: Inputs.BabylonPick.PickInfo): number;\n    /**\n     * Get the picked sprite\n     * @param inputs picking result\n     * @returns Picked sprite\n     */\n    getPickedSprite(inputs: Inputs.BabylonPick.PickInfo): Sprite;\n}declare class BabylonRay {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates a picking ray of the current mouse position in the active camera\n     * @returns Ray\n     */\n    createPickingRay(): Ray;\n    /**\n     * Create a ray that start at origin, has direction vector and optionally length\n     * @param inputs origin, direction and length\n     * @returns ray\n     */\n    createRay(inputs: Inputs.BabylonRay.BaseRayDto): Ray;\n    /**\n     * Create a ray from one point to another\n     * @param inputs origin, direction and length\n     * @returns ray\n     */\n    createRayFromTo(inputs: Inputs.BabylonRay.FromToDto): Ray;\n    /**\n     * Get the origin of the ray\n     * @param inputs ray\n     * @returns origin point\n     */\n    getOrigin(inputs: Inputs.BabylonRay.RayDto): Base.Point3;\n    /**\n     * Get the direction of the ray\n     * @param inputs ray\n     * @returns direction vector\n     */\n    getDirection(inputs: Inputs.BabylonRay.RayDto): Base.Vector3;\n    /**\n     * Get the length of the ray\n     * @param inputs ray\n     * @returns length\n     */\n    getLength(inputs: Inputs.BabylonRay.RayDto): number;\n}declare class BabylonScene {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Changes the scene background colour for 3D space\n     * @param inputs Describes the colour of the scene background\n     * @group environment\n     * @shortname colour\n     */\n    backgroundColour(inputs: Inputs.BabylonScene.SceneBackgroundColourDto): void;\n    /**\n     * Activate camera\n     * @param inputs Activates the camera\n     * @group camera\n     * @shortname activate\n     */\n    activateCamera(inputs: Inputs.BabylonScene.ActiveCameraDto): void;\n    /**\n     * Use right handed system\n     * @param inputs Activates the camera\n     * @group system\n     * @shortname hand right\n     */\n    useRightHandedSystem(inputs: Inputs.BabylonScene.UseRightHandedSystemDto): void;\n    /**\n     * Creates and draws a point light in the scene\n     * @param inputs Describes the light source\n     * @returns BabylonJS point light\n     * @group lights\n     * @shortname point\n     * @disposableOutput true\n     */\n    drawPointLight(inputs: Inputs.BabylonScene.PointLightDto): PointLight;\n    /**\n     * Creates and draws a directional light in the scene\n     * @param inputs Describes the light source\n     * @returns BabylonJS directional light\n     * @group lights\n     * @shortname directional\n     * @disposableOutput true\n     */\n    drawDirectionalLight(inputs: Inputs.BabylonScene.DirectionalLightDto): DirectionalLight;\n    /**\n     * Adjusts the active arc rotate camera with configuration parameters\n     * @group camera\n     * @shortname adjust active\n     */\n    adjustActiveArcRotateCamera(inputs: Inputs.BabylonScene.CameraConfigurationDto): void;\n    /**\n     * Clears all of the drawn objects in the 3D scene\n     * @group environment\n     * @shortname clear all drawn\n     */\n    clearAllDrawn(): void;\n    /**\n     * Enables skybox\n     * @param inputs Skybox configuration\n     * @group environment\n     * @shortname skybox\n     */\n    enableSkybox(inputs: Inputs.BabylonScene.SkyboxDto): void;\n    /**\n     * Registers code to run when pointer is down\n     * @param inputs pointer statement\n     * @ignore true\n     */\n    onPointerDown(inputs: Inputs.BabylonScene.PointerDto): void;\n    /**\n     * Registers code to run when pointer is up\n     * @param inputs pointer statement\n     * @ignore true\n     */\n    onPointerUp(inputs: Inputs.BabylonScene.PointerDto): void;\n    /**\n     * Registers code to run when pointer is moving\n     * @param inputs pointer statement\n     * @ignore true\n     */\n    onPointerMove(inputs: Inputs.BabylonScene.PointerDto): void;\n    /**\n     * Enables fog mode\n     * @param inputs fog options\n     * @group environment\n     * @shortname fog\n     */\n    fog(inputs: Inputs.BabylonScene.FogDto): void;\n}/**\n * Transformations help to move, scale, rotate and mirror objects. You can combine multiple transformations\n * for object to be placed exactly into position and orientation that you want.\n * Contains various methods for transformations that represent 4x4 matrixes in flat 16 number arrays.\n */\ndeclare class BabylonTransforms {\n    /**\n     * Creates a rotation transformations around the center and an axis\n     * @param inputs Rotation around center with an axis information\n     * @returns array of transformations\n     * @group rotation\n     * @shortname center axis\n     * @drawable false\n     */\n    rotationCenterAxis(inputs: Inputs.Transforms.RotationCenterAxisDto): number[][];\n    /**\n     * Creates a rotation transformations around the center and an X axis\n     * @param inputs Rotation around center with an X axis information\n     * @returns array of transformations\n     * @group rotation\n     * @shortname center x\n     * @drawable false\n     */\n    rotationCenterX(inputs: Inputs.Transforms.RotationCenterDto): number[][];\n    /**\n     * Creates a rotation transformations around the center and an Y axis\n     * @param inputs Rotation around center with an Y axis information\n     * @returns array of transformations\n     * @group rotation\n     * @shortname center y\n     * @drawable false\n     */\n    rotationCenterY(inputs: Inputs.Transforms.RotationCenterDto): number[][];\n    /**\n     * Creates a rotation transformations around the center and an Z axis\n     * @param inputs Rotation around center with an Z axis information\n     * @returns array of transformations\n     * @group rotation\n     * @shortname center z\n     * @drawable false\n     */\n    rotationCenterZ(inputs: Inputs.Transforms.RotationCenterDto): number[][];\n    /**\n     * Creates a rotation transformations with yaw pitch and roll\n     * @param inputs Yaw pitch roll rotation information\n     * @returns array of transformations\n     * @group rotation\n     * @shortname yaw pitch roll\n     * @drawable false\n     */\n    rotationCenterYawPitchRoll(inputs: Inputs.Transforms.RotationCenterYawPitchRollDto): number[][];\n    /**\n     * Scale transformation around center and xyz directions\n     * @param inputs Scale center xyz trnansformation\n     * @returns array of transformations\n     * @group rotation\n     * @shortname center xyz\n     * @drawable false\n     */\n    scaleCenterXYZ(inputs: Inputs.Transforms.ScaleCenterXYZDto): number[][];\n    /**\n     * Creates the scale transformation in x, y and z directions\n     * @param inputs Scale XYZ number array information\n     * @returns transformation\n     * @group scale\n     * @shortname xyz\n     * @drawable false\n     */\n    scaleXYZ(inputs: Inputs.Transforms.ScaleXYZDto): number[][];\n    /**\n     * Creates uniform scale transformation\n     * @param inputs Scale Dto\n     * @returns transformation\n     * @group scale\n     * @shortname uniform\n     * @drawable false\n     */\n    uniformScale(inputs: Inputs.Transforms.UniformScaleDto): number[][];\n    /**\n     * Creates uniform scale transformation from the center\n     * @param inputs Scale Dto with center point information\n     * @returns array of transformations\n     * @group scale\n     * @shortname uniform from center\n     * @drawable false\n     */\n    uniformScaleFromCenter(inputs: Inputs.Transforms.UniformScaleFromCenterDto): number[][];\n    /**\n     * Creates the translation transformation\n     * @param inputs Translation information\n     * @returns transformation\n     * @group translation\n     * @shortname xyz\n     * @drawable false\n     */\n    translationXYZ(inputs: Inputs.Transforms.TranslationXYZDto): number[][];\n    /**\n    * Creates the translation transformation\n    * @param inputs Translation information\n    * @returns transformation\n     * @group translations\n     * @shortname xyz\n     * @drawable false\n    */\n    translationsXYZ(inputs: Inputs.Transforms.TranslationsXYZDto): number[][][];\n}declare class BabylonWebXR {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates default XR experience with teleportation\n     * @param inputs Creates default XR experience with teleportation\n     */\n    createDefaultXRExperienceWithTeleportation(inputs: Inputs.BabylonWebXR.DefaultWebXRWithTeleportationDto): Promise<void>;\n}declare namespace BaseTypes {\n    /**\n     * Interval represents an object that has two properties - min and max.\n     */\n    class IntervalDto {\n        /**\n         * Minimum value of the interval\n         */\n        min: number;\n        /**\n         * Maximum value of the interval\n         */\n        max: number;\n    }\n    /**\n     * UV usually represents 2D coordinates on 3D or 2D surfaces. It is similar to XY coordinates in planes.\n     */\n    class UVDto {\n        /**\n         * U coordinate of the surface\n         */\n        u: number;\n        /**\n         * V coordinate of the surface\n         */\n        v: number;\n    }\n    /**\n     * Intersection result of curve curve\n     */\n    class CurveCurveIntersection {\n        /**\n         * Point of intersection on the first curve\n         */\n        point0: number[];\n        /**\n         * Point of intersection on the second curve\n         */\n        point1: number[];\n        /**\n         * Parameter of intersection on the first curve\n         */\n        u0: number;\n        /**\n         * Parameter of intersection on the second curve\n         */\n        u1: number;\n    }\n    /**\n     * Intersection result of curve and surface\n     */\n    class CurveSurfaceIntersection {\n        /**\n         * Parameter of intersection on the curve\n         */\n        u: number;\n        /**\n         * UV Parameters of intersection on the surface\n         */\n        uv: UVDto;\n        /**\n         * Point of intersection on the curve\n         */\n        curvePoint: number[];\n        /**\n         * Point of intersection on the surface\n         */\n        surfacePoint: number[];\n    }\n    /**\n     * Intersection point between two surfaces\n     */\n    class SurfaceSurfaceIntersectionPoint {\n        /**\n         * UV parameters of intersection on first surface\n         */\n        uv0: UVDto;\n        /**\n         * UV parameters of intersection on second surface\n         */\n        uv1: UVDto;\n        /**\n         * Point of intersection\n         */\n        point: number[];\n        /**\n         * Distance\n         */\n        dist: number;\n    }\n}declare class Color {\n    /**\n     * Creates a hex color\n     * @param inputs Color hex\n     * @returns color string\n     * @group create\n     * @shortname color\n     * @drawable false\n     */\n    hexColor(inputs: Inputs.Color.HexDto): Inputs.Base.Color;\n    /**\n     * Creates rgb color from hex\n     * @param inputs Color hex\n     * @returns rgb color\n     * @group convert\n     * @shortname hex to rgb\n     * @drawable false\n     */\n    hexToRgb(inputs: Inputs.Color.HexDto): Inputs.Color.RGBDto;\n    /**\n     * Creates hex color from rgb\n     * @param inputs Color hext\n     * @returns rgb color\n     * @group convert\n     * @shortname rgb to hex\n     * @drawable false\n     */\n    rgbToHex(inputs: Inputs.Color.RGBDto): Inputs.Base.Color;\n    /**\n     * Creates rgb color from hex and maps to 0 - 100 value\n     * @param inputs Color hext\n     * @returns rgb color\n     * @group convert\n     * @shortname hex to rgb mapped\n     * @drawable false\n     */\n    hexToRgbMapped(inputs: Inputs.Color.HexDtoMapped): Inputs.Color.RGBDto;\n    /**\n     * Get red param\n     * @param inputs Color hext\n     * @returns rgb color\n     * @group hex to\n     * @shortname red\n     * @drawable false\n     */\n    getRedParam(inputs: Inputs.Color.HexDtoMapped): number;\n    /**\n     * Get green param\n     * @param inputs Color hext\n     * @returns rgb color\n     * @group hex to\n     * @shortname green\n     * @drawable false\n     */\n    getGreenParam(inputs: Inputs.Color.HexDtoMapped): number;\n    /**\n     * Get blue param\n     * @param inputs Color hext\n     * @returns blue param\n     * @group hex to\n     * @shortname blue\n     * @drawable false\n     */\n    getBlueParam(inputs: Inputs.Color.HexDtoMapped): number;\n    /**\n     * RGB to red\n     * @param inputs Color rgb\n     * @returns red param\n     * @group  rgb to\n     * @shortname red\n     * @drawable false\n     */\n    rgbToRed(inputs: Inputs.Color.RGBObjectDto): number;\n    /**\n     * RGB to green\n     * @param inputs Color rgb\n     * @returns green param\n     * @group rgb to\n     * @shortname green\n     * @drawable false\n     */\n    rgbToGreen(inputs: Inputs.Color.RGBObjectDto): number;\n    /**\n     * RGB to blue\n     * @param inputs Color rgb\n     * @returns blue param\n     * @group rgb to\n     * @shortname blue\n     * @drawable false\n     */\n    rgbToBlue(inputs: Inputs.Color.RGBObjectDto): number;\n}declare class Draw {\n    private readonly point;\n    private readonly line;\n    private readonly polyline;\n    private readonly node;\n    private readonly verbCurve;\n    private readonly verbSurface;\n    private readonly jscad;\n    private readonly occt;\n    private readonly tag;\n    private readonly context;\n    private defaultBasicOptions;\n    private defaultNodeOptions;\n    constructor(point: Point, line: Line, polyline: Polyline, node: BabylonNode, verbCurve: VerbCurve, verbSurface: VerbSurface, jscad: JSCAD, occt: OCCTW, tag: Tag, context: Context);\n    /**\n     * Draws any kind of geometry after all input promises are resolved. Inputs can also be non-promise like.\n     * @param inputs Contains options and entities to be drawn\n     * @returns BabylonJS Mesh Promise\n     * @group draw\n     * @shortname draw anything\n     * @disposableOutput true\n     */\n    drawAnyAsync(inputs: Inputs.Draw.DrawAny): Promise<Mesh>;\n    private updateAny;\n    /**\n     * Draws a grid mesh on the ground plane in 3D space. This helps to orient yourself in the world.\n     * @param inputs Describes various parameters of the grid mesh like size, colour, etc.\n     * @group draw\n     * @shortname draw grid\n     * @disposableOutput true\n     */\n    drawGridMesh(inputs: Inputs.Draw.SceneDrawGridMeshDto): Mesh;\n    /**\n     * Draws any kind of geometry. Inputs can not be promises.\n     * @param inputs Contains options and entities to be drawn\n     * @returns BabylonJS Mesh\n     */\n    private drawAny;\n    /**\n     * Creates draw options for basic geometry types like points, lines, polylines, surfaces and jscad meshes\n     * @param inputs option definition\n     * @returns options\n     * @group options\n     * @shortname simple\n     */\n    optionsSimple(inputs: Inputs.Draw.DrawBasicGeometryOptions): Inputs.Draw.DrawBasicGeometryOptions;\n    /**\n     * Creates draw options for occt shape geometry like edges, wires, faces, shells, solids and compounds\n     * @param inputs option definition\n     * @returns options\n     * @group options\n     * @shortname occt shape\n     */\n    optionsOcctShape(inputs: Inputs.Draw.DrawOcctShapeOptions): Inputs.Draw.DrawOcctShapeOptions;\n    /**\n     * Creates draw options for babylon js nodes\n     * @param inputs option definition\n     * @returns options\n     * @group options\n     * @shortname babylon node\n     */\n    optionsBabylonNode(inputs: Inputs.Draw.DrawNodeOptions): Inputs.Draw.DrawNodeOptions;\n    private assignColorToMesh;\n    private handleTags;\n    private handleTag;\n    private handleVerbSurfaces;\n    private handleVerbCurves;\n    private handleNodes;\n    private handlePoints;\n    private handleLines;\n    private handlePolylines;\n    private handleVerbSurface;\n    private handleVerbCurve;\n    private handleNode;\n    private handlePolyline;\n    private handlePoint;\n    private handleLine;\n    private handleJscadMeshes;\n    private handleOcctShape;\n    private handleJscadMesh;\n    private applyGlobalSettingsAndMetadataAndShadowCasting;\n    private detectPoint;\n    private detectPoints;\n    private detectLine;\n    private detectLines;\n    private detectPolyline;\n    private detectPolylines;\n    private detectNode;\n    private detectNodes;\n    private detectVerbCurve;\n    private detectVerbSurface;\n    private detectVerbCurves;\n    private detectVerbSurfaces;\n    private detectJscadMesh;\n    private detectJscadMeshes;\n    private detectOcctShape;\n    private detectTag;\n    private detectTags;\n    private checkIfElementsInArrayAreNumbers;\n    private checkIfElementsInArrayAreArrays;\n    private arraysInChildrenArraysContainNumbers;\n    private arraysInChildrenArraysAreOfLength3;\n}/**\n * Contains various functions for Solid booleans from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADBooleans {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Intersect multiple solid mesh objects\n     * @param inputs Contains multiple solids for intersection\n     * @returns Solid mesh\n     * @group boolean\n     * @shortname intersect\n     * @drawable true\n     */\n    intersect(inputs: Inputs.JSCAD.BooleanObjectsDto): Promise<any>;\n    /**\n     * Subtract multiple solid mesh objects\n     * @param inputs Contains multiple solids for subtraction\n     * @returns Solid mesh\n     * @group boolean\n     * @shortname intersect\n     * @drawable true\n     */\n    subtract(inputs: Inputs.JSCAD.BooleanObjectsDto): Promise<any>;\n    /**\n     * Union multiple solid mesh objects\n     * @param inputs Contains multiple solids for union\n     * @returns Solid mesh\n     * @group boolean\n     * @shortname union\n     * @drawable true\n     */\n    union(inputs: Inputs.JSCAD.BooleanObjectsDto): Promise<any>;\n}/**\n * Contains various functions for Solid expansions from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADExpansions {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Expand geometries of solid category\n     * @param inputs Contains options and geometries for expansion\n     * @returns Expanded geometry\n     * @group expansion\n     * @shortname expand\n     * @drawable true\n     */\n    expand(inputs: Inputs.JSCAD.ExpansionDto): Promise<any>;\n    /**\n     * Offset 2d geometries of solid category\n     * @param inputs Contains options and geometries for offset\n     * @returns Expanded geometry\n     * @group expansion\n     * @shortname offset\n     * @drawable true\n     */\n    offset(inputs: Inputs.JSCAD.ExpansionDto): Promise<any>;\n}/**\n * Contains various functions for Solid extrusions from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADExtrusions {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Linear extrude 2D geometries of solid category\n     * @param inputs Contains options and geometries for linear extrude\n     * @returns Extruded geometry\n     * @group extrude\n     * @shortname linear\n     * @drawable true\n     */\n    extrudeLinear(inputs: Inputs.JSCAD.ExtrudeLinearDto): Promise<any>;\n    /**\n     * Rectangular extrude 2D geometries of solid category. Creates a wall-type extrusion of certain height and size.\n     * @param inputs Contains options and geometries for rectangular extrude\n     * @returns Extruded geometry\n     * @group extrude\n     * @shortname rectangular\n     * @drawable true\n     */\n    extrudeRectangular(inputs: Inputs.JSCAD.ExtrudeRectangularDto): Promise<any>;\n    /**\n     * Rectangular extrude a list of 2D points. Creates a wall-type extrusion of certain height and size.\n     * @param inputs Contains options and points for extrusion\n     * @returns Extruded geometry\n     * @group extrude\n     * @shortname rectangular points\n     * @drawable true\n     */\n    extrudeRectangularPoints(inputs: Inputs.JSCAD.ExtrudeRectangularPointsDto): Promise<any>;\n    /**\n     * Rectangular extrude a list of 2D points. Creates a wall-type extrusion of certain height and size.\n     * @param inputs Contains options and points for extrusion\n     * @returns Extruded geometry\n     * @group extrude\n     * @shortname rotational\n     * @drawable true\n     */\n    extrudeRotate(inputs: Inputs.JSCAD.ExtrudeRotateDto): Promise<any>;\n}/**\n * Contains various functions for Solid hulls from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADHulls {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Hull chain connects solids or 2d geometries by filling an empty space in between objects in order.\n     * Geometries need to be of the same type.\n     * @param inputs Geometries\n     * @returns Chain hulled geometry\n     * @group hulls\n     * @shortname hull chain\n     * @drawable true\n     */\n    hullChain(inputs: Inputs.JSCAD.HullDto): Promise<any>;\n    /**\n     * Convex hull connects solids or 2d geometries by filling an empty space in between without following order.\n     * Geometries need to be of the same type.\n     * @param inputs Geometries\n     * @returns Hulled geometry\n     * @group hulls\n     * @shortname hull\n     * @drawable true\n     */\n    hull(inputs: Inputs.JSCAD.HullDto): Promise<any>;\n}/**\n * Contains various functions for Solid meshes from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCAD {\n    private readonly jscadWorkerManager;\n    private readonly context;\n    private readonly geometryHelper;\n    readonly booleans: JSCADBooleans;\n    readonly expansions: JSCADExpansions;\n    readonly extrusions: JSCADExtrusions;\n    readonly hulls: JSCADHulls;\n    readonly path: JSCADPath;\n    readonly polygon: JSCADPolygon;\n    readonly shapes: JSCADShapes;\n    readonly text: JSCADText;\n    constructor(jscadWorkerManager: JSCADWorkerManager, context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Draws a single solids\n     * @param inputs Contains a solid or polygon and information for drawing\n     * @returns Mesh that is being drawn by Babylon\n     * @group jscad\n     * @shortname draw solid\n     * @ignore true\n     */\n    drawSolidOrPolygonMesh(inputs: Inputs.JSCAD.DrawSolidMeshDto): Promise<Mesh>;\n    private makeMesh;\n    /**\n     * Draws multiple solids\n     * @param inputs Contains solids or polygons and information for drawing\n     * @returns Mesh that is being drawn by Babylon\n     * @group jscad\n     * @shortname draw solid\n     * @ignore true\n     */\n    drawSolidOrPolygonMeshes(inputs: Inputs.JSCAD.DrawSolidMeshesDto): Promise<Mesh>;\n    /**\n     * Draws a 2D path\n     * @param inputs Contains a path and information for drawing\n     * @returns Mesh that is being drawn by Babylon\n     * @group jscad\n     * @shortname draw solid\n     * @ignore true\n     */\n    drawPath(inputs: Inputs.JSCAD.DrawPathDto): Promise<LinesMesh>;\n    /**\n     * Transforms the Jscad solid meshes with a given list of transformations.\n     * @param inputs Solids with the transformation matrixes\n     * @returns Solids with a transformation\n     * @group transforms\n     * @shortname transform solids\n     * @drawable true\n     */\n    transformSolids(inputs: Inputs.JSCAD.TransformSolidsDto): Promise<Inputs.JSCAD.JSCADEntity[]>;\n    /**\n     * Transforms the Jscad solid mesh with a given list of transformations.\n     * @param inputs Solid with the transformation matrixes\n     * @returns Solid with a transformation\n     * @group transforms\n     * @shortname transform solid\n     * @drawable true\n     */\n    transformSolid(inputs: Inputs.JSCAD.TransformSolidDto): Promise<Inputs.JSCAD.JSCADEntity>;\n    /**\n     * Downloads the binary STL file from a 3D solid\n     * @param inputs 3D Solid\n     * @group io\n     * @shortname solid to stl\n     */\n    downloadSolidSTL(inputs: Inputs.JSCAD.DownloadSolidDto): Promise<void>;\n    /**\n     * Downloads the binary STL file from a 3D solids\n     * @param inputs 3D Solid\n     * @group io\n     * @shortname solids to stl\n     */\n    downloadSolidsSTL(inputs: Inputs.JSCAD.DownloadSolidsDto): Promise<void>;\n    private downloadSTL;\n    private createMesh;\n}/**\n * Contains various functions for Path from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADPath {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Create a 2D path from a list of points\n     * @param inputs Points and indication if we want a closed path or not\n     * @returns Path\n     * @group from\n     * @shortname points\n     * @drawable true\n     */\n    createFromPoints(inputs: Inputs.JSCAD.PathFromPointsDto): Promise<any>;\n    /**\n     * Create a 2D path from a polyline\n     * @param inputs Polyline and indication if we want a closed path or not\n     * @returns Path\n     * @group from\n     * @shortname polyline\n     * @drawable true\n     */\n    createFromPolyline(inputs: Inputs.JSCAD.PathFromPolylineDto): Promise<any>;\n    /**\n     * Create a 2D path from a curve\n     * @param inputs Curve and indication if we want a closed path or not\n     * @returns Path\n     * @group from\n     * @shortname curve\n     * @drawable true\n     */\n    createFromCurve(inputs: Inputs.JSCAD.PathFromCurveDto): Promise<any>;\n    /**\n     * Create empty 2D path\n     * @returns Empty path\n     * @group create\n     * @shortname empty\n     * @drawable false\n     */\n    createEmpty(): Promise<any>;\n    /**\n     * Closes an open 2D path\n     * @param inputs Path\n     * @returns Closed path\n     * @group edit\n     * @shortname close\n     * @drawable true\n     */\n    close(inputs: Inputs.JSCAD.PathDto): Promise<any>;\n    /**\n     * Append the path with 2D points\n     * @param inputs Path to append and points\n     * @returns Appended path\n     * @group append\n     * @shortname points\n     * @drawable true\n     */\n    appendPoints(inputs: Inputs.JSCAD.PathAppendPointsDto): Promise<any>;\n    /**\n     * Append the path with polyline\n     * @param inputs Path to append and polyline\n     * @returns Appended path\n     * @group append\n     * @shortname polyline\n     * @drawable true\n     */\n    appendPolyline(inputs: Inputs.JSCAD.PathAppendPolylineDto): Promise<any>;\n    /**\n     * Append the path with the curve\n     * @param inputs Path to append and a curve\n     * @returns Appended path\n     * @group append\n     * @shortname curve\n     * @drawable true\n     */\n    appendCurve(inputs: Inputs.JSCAD.PathAppendCurveDto): Promise<any>;\n    /**\n     * Append the arc to the path\n     * @param inputs Path and arc parameters\n     * @returns Appended path\n     * @group append\n     * @shortname arc\n     * @drawable true\n     */\n    appendArc(inputs: Inputs.JSCAD.PathAppendArcDto): Promise<any>;\n}/**\n * Contains various functions for Polygon from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADPolygon {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Create a 2D polygon from a list of points\n     * @param inputs Points\n     * @returns Path\n     * @group from\n     * @shortname points\n     * @drawable true\n     */\n    createFromPoints(inputs: Inputs.Point.PointsDto): Promise<any>;\n    /**\n     * Create a 2D polygon from a polyline\n     * @param inputs Polyline\n     * @returns Polygon\n     * @group from\n     * @shortname polyline\n     * @drawable true\n     */\n    createFromPolyline(inputs: Inputs.Polyline.PolylineDto): Promise<any>;\n    /**\n     * Create a 2D polygon from a curve\n     * @param inputs Nurbs curve\n     * @returns Polygon\n     * @group from\n     * @shortname curve\n     * @drawable true\n     */\n    createFromCurve(inputs: Inputs.Verb.CurveDto): Promise<any>;\n    /**\n     * Create a 2D polygon from a path\n     * @param inputs Path\n     * @returns Polygon\n     * @group from\n     * @shortname path\n     * @drawable true\n     */\n    createFromPath(inputs: Inputs.JSCAD.PathDto): Promise<any>;\n    /**\n     * Create a 2D polygon circle\n     * @param inputs Circle parameters\n     * @returns Circle polygon\n     * @group primitives\n     * @shortname circle\n     * @drawable true\n     */\n    circle(inputs: Inputs.JSCAD.CircleDto): Promise<any>;\n    /**\n     * Create a 2D polygon ellipse\n     * @param inputs Ellipse parameters\n     * @returns Ellipse polygon\n     * @group primitives\n     * @shortname ellipse\n     * @drawable true\n     */\n    ellipse(inputs: Inputs.JSCAD.EllipseDto): Promise<any>;\n    /**\n     * Create a 2D polygon rectangle\n     * @param inputs Rectangle parameters\n     * @returns Rectangle polygon\n     * @group primitives\n     * @shortname rectangle\n     * @drawable true\n     */\n    rectangle(inputs: Inputs.JSCAD.RectangleDto): Promise<any>;\n    /**\n     * Create a 2D rounded rectangle\n     * @param inputs Rounded rectangle parameters\n     * @returns Rounded rectangle polygon\n     * @group primitives\n     * @shortname rounded rectangle\n     * @drawable true\n     */\n    roundedRectangle(inputs: Inputs.JSCAD.RoundedRectangleDto): Promise<any>;\n    /**\n     * Create a 2D polygon square\n     * @param inputs Square parameters\n     * @returns Square polygon\n     * @group primitives\n     * @shortname square\n     * @drawable true\n     */\n    square(inputs: Inputs.JSCAD.SquareDto): Promise<any>;\n    /**\n     * Create a 2D polygon star\n     * @param inputs Star parameters\n     * @returns Star polygon\n     * @group primitives\n     * @shortname star\n     * @drawable true\n     */\n    star(inputs: Inputs.JSCAD.StarDto): Promise<any>;\n}/**\n * Contains various functions for solid 3D shapes from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADShapes {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Create a 3D cube shape\n     * @param inputs Cube parameters\n     * @returns Cube solid\n     * @group primitives\n     * @shortname cube\n     * @drawable true\n     */\n    cube(inputs: Inputs.JSCAD.CubeDto): Promise<any>;\n    /**\n     * Create a 3D cubes on multiple center points\n     * @param inputs Cube with multiple center points parameters\n     * @returns List of cube solids\n     * @group primitives on centers\n     * @shortname cubes\n     * @drawable true\n     */\n    cubesOnCenterPoints(inputs: Inputs.JSCAD.CubeCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D cuboid shape\n     * @param inputs Cuboid parameters\n     * @returns Cuboid solid\n     * @group primitives\n     * @shortname cuboid\n     * @drawable true\n     */\n    cuboid(inputs: Inputs.JSCAD.CuboidDto): Promise<any>;\n    /**\n     * Create a 3D cuboids on multiple center points\n     * @param inputs Cuboids with multiple center point parameters\n     * @returns List of cuboid solids\n     * @group primitives on centers\n     * @shortname cuboids\n     * @drawable true\n     */\n    cuboidsOnCenterPoints(inputs: Inputs.JSCAD.CuboidCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D elliptic cylinder solid\n     * @param inputs Elliptic cylinder parameters\n     * @returns Elliptic cylinder solid\n     * @group primitives\n     * @shortname cylinder elliptic\n     * @drawable true\n     */\n    cylinderElliptic(inputs: Inputs.JSCAD.CylidnerEllipticDto): Promise<any>;\n    /**\n     * Create a 3D elliptic cylinders on multiple center points\n     * @param inputs Elliptic cylinders with multiple center point parameters\n     * @returns List of elliptic cylinders solids\n     * @group primitives on centers\n     * @shortname cylinder elliptic\n     * @drawable true\n     */\n    cylinderEllipticOnCenterPoints(inputs: Inputs.JSCAD.CylidnerCentersEllipticDto): Promise<any[]>;\n    /**\n     * Create a 3D cylinder solid\n     * @param inputs Cylinder parameters\n     * @returns Cylinder solid\n     * @group primitives\n     * @shortname cylinder\n     * @drawable true\n     */\n    cylinder(inputs: Inputs.JSCAD.CylidnerDto): Promise<any>;\n    /**\n     * Create a 3D cylinders on multiple center points\n     * @param inputs Cylinders with multiple center point parameters\n     * @returns List of cylinder solids\n     * @group primitives on centers\n     * @shortname cylinder\n     * @drawable true\n     */\n    cylindersOnCenterPoints(inputs: Inputs.JSCAD.CylidnerCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D ellipsoid solid\n     * @param inputs Ellipsoid parameters\n     * @returns Ellipsoid solid\n     * @group primitives\n     * @shortname ellipsoid\n     * @drawable true\n     */\n    ellipsoid(inputs: Inputs.JSCAD.EllipsoidDto): Promise<any>;\n    /**\n     * Create a 3D ellipsoids on multiple center points\n     * @param inputs Ellipsoid parameters with multiple center points\n     * @returns List of ellipsoid solids\n     * @group primitives on centers\n     * @shortname ellipsoid\n     * @drawable true\n     */\n    ellipsoidsOnCenterPoints(inputs: Inputs.JSCAD.EllipsoidCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D geodesic sphere solid\n     * @param inputs Geodesic sphere parameters\n     * @returns Geodesic sphere solid\n     * @group primitives\n     * @shortname geodesic sphere\n     * @drawable true\n     */\n    geodesicSphere(inputs: Inputs.JSCAD.GeodesicSphereDto): Promise<any>;\n    /**\n     * Create a 3D geodesic spheres on multiple center points\n     * @param inputs Geodesic sphere parameters with multiple center points\n     * @returns List of geodesic spheres\n     * @group primitives on centers\n     * @shortname geodesic sphere\n     * @drawable true\n     */\n    geodesicSpheresOnCenterPoints(inputs: Inputs.JSCAD.GeodesicSphereCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D rounded cuboid solid\n     * @param inputs Rounded cuboid parameters\n     * @returns Rounded cuboid solid\n     * @group primitives\n     * @shortname rounded cuboid\n     * @drawable true\n     */\n    roundedCuboid(inputs: Inputs.JSCAD.RoundedCuboidDto): Promise<any>;\n    /**\n     * Create a 3D rounded cuboids on multiple center points\n     * @param inputs Rounded cuboids parameters with multiple center points\n     * @returns List of rounded cuboids\n     * @group primitives on centers\n     * @shortname rounded cuboid\n     * @drawable true\n     */\n    roundedCuboidsOnCenterPoints(inputs: Inputs.JSCAD.RoundedCuboidCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D rounded cylinder solid\n     * @param inputs Rounded cylinder parameters\n     * @returns Rounded cylinder solid\n     * @group primitives\n     * @shortname rounded cylinder\n     * @drawable true\n     */\n    roundedCylinder(inputs: Inputs.JSCAD.RoundedCylidnerDto): Promise<any>;\n    /**\n     * Create a 3D rounded cylinders on multiple center points\n     * @param inputs Rounded cylinders parameters with multiple center points\n     * @returns List of rounded cylinders\n     * @group primitives on centers\n     * @shortname rounded cylinder\n     * @drawable true\n     */\n    roundedCylindersOnCenterPoints(inputs: Inputs.JSCAD.RoundedCylidnerCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D sphere solid\n     * @param inputs Sphere parameters\n     * @returns Sphere solid\n     * @group primitives\n     * @shortname sphere\n     * @drawable true\n     */\n    sphere(inputs: Inputs.JSCAD.SphereDto): Promise<any>;\n    /**\n     * Create a 3D sphere on multiple center points\n     * @param inputs Sphere parameters with multiple center points\n     * @returns List of spheres\n     * @group primitives on centers\n     * @shortname sphere\n     * @drawable true\n     */\n    spheresOnCenterPoints(inputs: Inputs.JSCAD.SphereCentersDto): Promise<any[]>;\n    /**\n     * Create a 3D torus solid\n     * @param inputs Torus parameters\n     * @returns Torus solid\n     * @group primitives\n     * @shortname torus\n     * @drawable true\n     */\n    torus(inputs: Inputs.JSCAD.TorusDto): Promise<any>;\n}/**\n * Contains various functions for solid 3D texts from JSCAD library https://github.com/jscad/OpenJSCAD.org\n * Thanks JSCAD community for developing this kernel\n */\ndeclare class JSCADText {\n    private readonly jscadWorkerManager;\n    constructor(jscadWorkerManager: JSCADWorkerManager);\n    /**\n     * Creates a text that is based on chain hulling cylinders\n     * @param inputs Cylindrical text parameters\n     * @returns List of solids for text\n     * @group text\n     * @shortname cylindrical\n     * @drawable true\n     */\n    cylindricalText(inputs: Inputs.JSCAD.CylinderTextDto): Promise<any[]>;\n    /**\n     * Creates a text that is based on chain hulling spheres\n     * @param inputs Spherical text parameters\n     * @returns List of solids for text\n     * @group text\n     * @shortname spherical\n     * @drawable true\n     */\n    sphericalText(inputs: Inputs.JSCAD.SphereTextDto): Promise<any[]>;\n    /**\n     * Creates a vector text\n     * @param inputs Vector text parameters\n     * @returns List of polygons\n     * @group text\n     * @shortname vector\n     * @drawable true\n     * @ignore true\n     */\n    createVectorText(inputs: Inputs.JSCAD.TextDto): Promise<number[][]>;\n}/**\n * Contains various json path methods.\n */\ndeclare class JSONBitByBit {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Stringifies the input value\n     * @param inputs a value to be stringified\n     * @returns string\n     * @group transform\n     * @shortname stringify\n     * @drawable false\n     */\n    stringify(inputs: Inputs.JSON.StringifyDto): string;\n    /**\n     * Parses the input value\n     * @param inputs a value to be parsed\n     * @returns any\n     * @group transform\n     * @shortname parse\n     * @drawable false\n     */\n    parse(inputs: Inputs.JSON.ParseDto): any;\n    /**\n     * Queries the input value\n     * @param inputs a value to be queried\n     * @returns any\n     * @group jsonpath\n     * @shortname query\n     * @drawable false\n     */\n    query(inputs: Inputs.JSON.QueryDto): any;\n    /**\n     * Sets value to the json by providing a path\n     * @param inputs a value to be added, json and a path\n     * @returns any\n     * @group jsonpath\n     * @shortname set value\n     * @drawable false\n     */\n    setValue(inputs: Inputs.JSON.SetValueDto): any;\n    /**\n     * Find paths to elements in object matching path expression\n     * @param inputs a json value and a query\n     * @returns any\n     * @group jsonpath\n     * @shortname paths\n     * @drawable false\n     */\n    paths(inputs: Inputs.JSON.PathsDto): any;\n    /**\n     * Find paths to elements in object matching path expression as strings\n     * @param inputs a json value and a query\n     * @returns any\n     * @group jsonpath\n     * @shortname paths as strings\n     * @drawable false\n     */\n    pathsAsStrings(inputs: Inputs.JSON.PathsDto): any;\n}{};/**\n * Contains various methods for lines. Line in bitbybit is a simple object that has star and end point properties.\n * { start: [ x, y, z ], end: [ x, y, z ] }\n */\ndeclare class Line {\n    private readonly context;\n    private readonly geometryHelper;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Draws multiple lines\n     * @param inputs Contains a line to be drawn\n     * @returns Lines mesh that is being drawn by Babylon\n     */\n    drawLines(inputs: Inputs.Line.DrawLinesDto): LinesMesh;\n    /**\n     * Converts a line to a NURBS line curve\n     * Returns the verbnurbs Line object\n     * @param inputs Line to be transformed to curve\n     * @returns Verb nurbs curve\n     */\n    convertToNurbsCurve(inputs: Inputs.Line.LineDto): any;\n    /**\n     * Converts lines to a NURBS curves\n     * Returns array of the verbnurbs Line objects\n     * @param inputs Lines to be transformed to curves\n     * @returns Verb nurbs curves\n     */\n    convertLinesToNurbsCurves(inputs: Inputs.Line.LinesDto): any[];\n    /**\n     * Gets the start point of the line\n     * @param inputs Line to be queried\n     * @returns Start point\n     */\n    getStartPoint(inputs: Inputs.Line.LineDto): number[];\n    /**\n     * Gets the end point of the line\n     * @param inputs Line to be queried\n     * @returns End point\n     */\n    getEndPoint(inputs: Inputs.Line.LineDto): Inputs.Base.Point3;\n    /**\n     * Gets the length of the line\n     * @param inputs Line to be queried\n     * @returns Length of the line\n     */\n    length(inputs: Inputs.Line.LineDto): number;\n    /**\n     * Reverse the endpoints of the line\n     * @param inputs Line to be reversed\n     * @returns Reversed line\n     */\n    reverse(inputs: Inputs.Line.LineDto): Inputs.Line.LinePointsDto;\n    /**\n     * Transform the line\n     * @param inputs Line to be transformed\n     * @returns Transformed line\n     */\n    transformLine(inputs: Inputs.Line.TransformLineDto): Inputs.Line.LinePointsDto;\n    /**\n     * Transforms the lines with multiple transform for each line\n     * @param inputs Lines to be transformed and transformations\n     * @returns Transformed lines\n     */\n    transformsForLines(inputs: Inputs.Line.TransformsLinesDto): Inputs.Line.LinePointsDto[];\n    /**\n     * Create the line\n     * @param inputs Endpoints of the line\n     * @returns Line\n     */\n    create(inputs: Inputs.Line.LinePointsDto): Inputs.Line.LinePointsDto;\n    /**\n     * Create the line from possibly async inputs of points\n     * @param inputs Endpoints of the line\n     * @returns Line\n     */\n    createAsync(inputs: Inputs.Line.LinePointsDto): Promise<Inputs.Line.LinePointsDto>;\n    /**\n     * Gets the point on the line segment at a given param\n     * @param inputs Line and parameter\n     * @returns Point on line\n     */\n    getPointOnLine(inputs: Inputs.Line.PointOnLineDto): Inputs.Base.Point3;\n    /**\n     * Create the line segments between all of the points in a list\n     * @param inputs Lines in a list\n     * @returns Lines\n     */\n    linesBetweenPoints(inputs: Inputs.Line.PointsLinesDto): Inputs.Line.LinePointsDto[];\n    /**\n     * Create the lines between two lists of start and end points of equal length\n     * @param inputs Two lists of start and end points\n     * @returns Lines\n     */\n    linesBetweenStartAndEndPoints(inputs: Inputs.Line.LineStartEndPointsDto): Inputs.Line.LinePointsDto[];\n    /**\n     * Create the lines between two lists of start and end points of equal length with potential async inputs\n     * @param inputs Two lists of start and end points\n     * @returns Lines\n     */\n    linesBetweenStartAndEndPointsAsync(inputs: Inputs.Line.LineStartEndPointsDto): Promise<Inputs.Line.LinePointsDto[]>;\n    private createLineSystemMesh;\n}/**\n * Contains various list methods.\n */\ndeclare class Lists {\n    constructor();\n    /**\n     * Gets an item from the list by using a 0 based index\n     * @param inputs a list and an index\n     * @returns item\n     * @group get\n     * @shortname item by index\n     * @drawable false\n     */\n    getItem(inputs: Inputs.Lists.ListItemDto): any;\n    /**\n       * Gets a sub list between start and end indexes\n       * @param inputs a list and start and end indexes\n       * @returns sub list\n       * @group get\n       * @shortname sublist\n       * @drawable false\n       */\n    getSubList(inputs: Inputs.Lists.SubListDto): any;\n    /**\n     * Reverse the list\n     * @param inputs a list and an index\n     * @returns item\n     * @group edit\n     * @shortname reverse\n     * @drawable false\n     */\n    reverse(inputs: Inputs.Lists.ListDto): any;\n    /**\n     * Flip 2d lists - every nth element of each list will form a separate list\n     * @param inputs a list of lists to flip\n     * @returns item\n     * @group edit\n     * @shortname flip lists\n     * @drawable false\n     */\n    flipLists(inputs: Inputs.Lists.ListDto): any;\n    /**\n     * Gets the length of the list\n     * @param inputs a length list\n     * @returns a number\n     * @group get\n     * @shortname list length\n     * @drawable false\n     */\n    listLength(inputs: Inputs.Lists.ListDto): number;\n    /**\n     * Add item to the list\n     * @param inputs a list, item and an index\n     * @returns list with added item\n     * @group add\n     * @shortname item at index\n     * @drawable false\n     */\n    addItemAtIndex(inputs: Inputs.Lists.AddItemAtIndexDto): any;\n    /**\n     * Remove item from the list\n     * @param inputs a list and index\n     * @returns list with removed item\n     * @group remove\n     * @shortname item at index\n     * @drawable false\n     */\n    removeItemAtIndex(inputs: Inputs.Lists.RemoveItemAtIndexDto): any;\n    /**\n     * Add item to the beginning or the end of the list\n     * @param inputs a list, item and an option for first or last position\n     * @returns list with added item\n     * @group add\n     * @shortname item at first or last\n     * @drawable false\n     */\n    addItemFirstLast(inputs: Inputs.Lists.AddItemFirstLastDto): any;\n    /**\n     * Creates an empty list\n     * @returns an empty array list\n     * @group create\n     * @shortname empty list\n     * @drawable false\n     */\n    createEmptyList(): [];\n    /**\n     * Repeat the item and add it in the new list\n     * @param inputs an item to multiply\n     * @returns list\n     * @group create\n     * @shortname repeat\n     * @drawable false\n     */\n    repeat(inputs: Inputs.Lists.MultiplyItemDto): any;\n}{};/**\n * Contains various logic methods.\n */\ndeclare class Logic {\n    constructor();\n    /**\n     * Creates a boolean value - true or false\n     * @param inputs a true or false boolean\n     * @returns boolean\n     * @group create\n     * @shortname boolean\n     * @drawable false\n     */\n    boolean(inputs: Inputs.Logic.BooleanDto): boolean;\n    /**\n     * Does comparison between first and second values\n     * @param inputs two values to be compared\n     * @returns Result of the comparison\n     * @group operations\n     * @shortname compare\n     * @drawable false\n     */\n    compare(inputs: Inputs.Logic.ComparisonDto): boolean;\n    /**\n     * Transmits a value if boolean provided is true and undefined if boolean provided is false\n     * @param inputs a value and a boolean value\n     * @returns value or undefined\n     * @group operations\n     * @shortname value gate\n     * @drawable false\n     */\n    valueGate(inputs: Inputs.Logic.ValueGateDto): any;\n}/**\n * Contains various math methods.\n */\ndeclare class MathBitByBit {\n    constructor();\n    /**\n     * Creates a number\n     * @param inputs a number to be created\n     * @returns number\n     * @group create\n     * @shortname number\n     * @drawable false\n     */\n    number(inputs: Inputs.Math.NumberDto): number;\n    /**\n     * Does basic math operations\n     * @param inputs two numbers and operator\n     * @returns Result of math operation action\n     * @group operations\n     * @shortname two numbers\n     * @drawable false\n     */\n    twoNrOperation(inputs: Inputs.Math.ActionOnTwoNumbersDto): number;\n    /**\n     * Does basic math operations on one number\n     * @param inputs one number and operator action\n     * @returns Result of math operation\n     * @group operations\n     * @shortname one number\n     * @drawable false\n     */\n    oneNrOperation(inputs: Inputs.Math.ActionOnOneNumberDto): number;\n    /**\n    * Remaps a number from one range to another\n    * @param inputs one number and operator action\n    * @returns Result of mapping\n    * @group operations\n    * @shortname remap\n    * @drawable false\n    */\n    remap(inputs: Inputs.Math.RemapNumberDto): number;\n}{};declare class OCCTWIO extends OCCTIO {\n    readonly occWorkerManager: OCCTWorkerManager;\n    private readonly geometryHelper;\n    constructor(occWorkerManager: OCCTWorkerManager, geometryHelper: GeometryHelper);\n    /**\n     * Imports the step or iges asset file\n     * @group io\n     * @shortname load step | iges\n     * @returns OCCT Shape\n     */\n    loadSTEPorIGES(inputs: Inputs.OCCT.ImportStepIgesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Saves the stl file\n     * @param inputs STL filename and shape to be saved\n     * @group io\n     * @shortname save stl\n     * @returns String of a stl file\n     */\n    saveShapeStl(inputs: Inputs.OCCT.SaveStlDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.DecomposedMeshDto>;\n}/**\n * Contains various methods for OpenCascade implementation\n */\ndeclare class OCCTW extends OCCT {\n    private readonly context;\n    readonly occWorkerManager: OCCTWorkerManager;\n    private readonly geometryHelper;\n    private readonly solidText;\n    private readonly vector;\n    readonly io: OCCTWIO;\n    constructor(context: Context, occWorkerManager: OCCTWorkerManager, geometryHelper: GeometryHelper, solidText: JSCADText, vector: Vector);\n    /**\n     * Draws OpenCascade shape by going through faces and edges\n     * @param inputs Contains a shape to be drawn and additional information\n     * @returns BabylonJS Mesh\n     * @group drawing\n     * @shortname draw shape\n     * @drawable false\n     * @ignore true\n     */\n    drawShape(inputs: Inputs.OCCT.DrawShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Mesh>;\n    private computeFaceMiddlePos;\n    private computeEdgeMiddlePos;\n}/**\n * Contains various methods for points. Point in bitbybit is simply an array containing 3 numbers for [x, y, z].\n * Because of this form Point can be interchanged with Vector, which also is an array in [x, y, z] form.\n * When creating 2D points, z coordinate is simply set to 0 - [x, y, 0].\n */\ndeclare class Point {\n    private readonly context;\n    private readonly geometryHelper;\n    private readonly line;\n    constructor(context: Context, geometryHelper: GeometryHelper, line: Line);\n    /**\n     * Draws a single point\n     * @param inputs Contains a point to be drawn\n     * @returns Mesh that is being drawn by Babylon\n     * @group draw\n     * @shortname point\n     * @drawable false\n     * @ignore true\n     */\n    drawPoint(inputs: Inputs.Point.DrawPointDto): Mesh;\n    /**\n     * Draws multiple points\n     * @param inputs Contains a point array to be drawn\n     * @returns Mesh that is being drawn by Babylon\n     * @group draw\n     * @shortname points sync\n     * @drawable false\n     * @ignore true\n     */\n    drawPoints(inputs: Inputs.Point.DrawPointsDto): Mesh;\n    /**\n     * Draws multiple points async\n     * @param inputs Contains a point array to be drawn\n     * @returns Promise of a Mesh that will being drawn by Babylon\n     * @group draw\n     * @shortname points\n     * @drawable false\n     * @ignore true\n     */\n    drawPointsAsync(inputs: Inputs.Point.DrawPointsDto): Promise<Mesh>;\n    /**\n     * Transforms the single point\n     * @param inputs Contains a point and the transformations to apply\n     * @returns Transformed point\n     * @group transforms\n     * @shortname transform point\n     * @drawable true\n     */\n    transformPoint(inputs: Inputs.Point.TransformPointDto): Inputs.Base.Point3;\n    /**\n     * Transforms multiple points\n     * @param inputs Contains points and the transformations to apply\n     * @returns Transformed points\n     * @group transforms\n     * @shortname transform points\n     * @drawable true\n     */\n    transformPoints(inputs: Inputs.Point.TransformPointsDto): Inputs.Base.Point3[];\n    /**\n     * Transforms multiple points by multiple transformations\n     * @param inputs Contains points and the transformations to apply\n     * @returns Transformed points\n     * @group transforms\n     * @shortname transforms for points\n     * @drawable true\n     */\n    transformsForPoints(inputs: Inputs.Point.TransformsForPointsDto): Inputs.Base.Point3[];\n    /**\n     * Measures the closest distance between a point and a collection of points\n     * @param inputs Point from which to measure and points to measure the distance against\n     * @returns Distance to closest point\n     * @group extract\n     * @shortname distance to closest pt\n     * @drawable false\n     */\n    closestPointFromPointsDistance(inputs: Inputs.Point.ClosestPointFromPointsDto): number;\n    /**\n     * Finds the closest point index between a point and a collection of points. Caution, index is not 0 based, it starts with 1.\n     * @param inputs Point from which to find the index in a collection of points\n     * @returns Closest point index\n     * @group extract\n     * @shortname index of closest pt\n     * @drawable false\n     */\n    closestPointFromPointsIndex(inputs: Inputs.Point.ClosestPointFromPointsDto): number;\n    /**\n     * Finds the closest point in a collection\n     * @param inputs Point and points collection to find the closest point in\n     * @returns Closest point\n     * @group extract\n     * @shortname closest pt\n     * @drawable true\n     */\n    closestPointFromPoints(inputs: Inputs.Point.ClosestPointFromPointsDto): Inputs.Base.Point3;\n    /**\n     * Finds the distance between two points\n     * @param inputs Coordinates of start and end points\n     * @returns Distance\n     * @group measure\n     * @shortname distance\n     * @drawable false\n     */\n    distance(inputs: Inputs.Point.StartEndPointsDto): number;\n    /**\n     * Multiply point by a specified amount\n     * @param inputs The point to be multiplied and the amount of points to create\n     * @returns Distance\n     * @group transforms\n     * @shortname multiply point\n     * @drawable true\n     */\n    multiplyPoint(inputs: Inputs.Point.MultiplyPointDto): Inputs.Base.Point3[];\n    /**\n     * Get x coordinate of the point\n     * @param inputs The point\n     * @returns X coordinate\n     * @group get\n     * @shortname x coord\n     * @drawable false\n     */\n    getX(inputs: Inputs.Point.PointDto): number;\n    /**\n     * Get y coordinate of the point\n     * @param inputs The point\n     * @returns Y coordinate\n     * @group get\n     * @shortname y coord\n     * @drawable false\n     */\n    getY(inputs: Inputs.Point.PointDto): number;\n    /**\n     * Get z coordinate of the point\n     * @param inputs The point\n     * @returns Z coordinate\n     * @group get\n     * @shortname z coord\n     * @drawable false\n     */\n    getZ(inputs: Inputs.Point.PointDto): number;\n    /**\n     * Get average point of points\n     * @param inputs The points\n     * @returns point\n     * @group extract\n     * @shortname average point\n     * @drawable true\n     */\n    averagePoint(inputs: Inputs.Point.PointsDto): Base.Point3;\n    /**\n     * Creates the xyz point\n     * @param inputs xyz information\n     * @returns point 3d\n     * @group create\n     * @shortname point xyz\n     * @drawable true\n     */\n    pointXYZ(inputs: Inputs.Point.PointXYZDto): Inputs.Base.Point3;\n    /**\n     * Creates the xy point\n     * @param inputs xy information\n     * @returns point 3d\n     * @group create\n     * @shortname point xy\n     * @drawable false\n     */\n    pointXY(inputs: Inputs.Point.PointXYDto): Inputs.Base.Point2;\n    /**\n     * Creates the spiral out of multiple points\n     * @param inputs Spiral information\n     * @returns Specified number of points in the array along the spiral\n     * @group create\n     * @shortname spiral\n     * @drawable true\n     */\n    spiral(inputs: Inputs.Point.SpiralDto): Inputs.Base.Point3[];\n    /**\n     * Creates a flat point grid on XY plane. This grid contains center points for hexagons of the given radius.\n     * Be aware that we control only the nr of hexagons to be made and not the length and width of the grid.\n     * @param inputs Information about hexagon and the grid\n     * @returns Points in the array on the grid\n     * @group create\n     * @shortname hex grid\n     * @drawable true\n     */\n    hexGrid(inputs: Inputs.Point.HexGridCentersDto): Inputs.Base.Point3[];\n    private closestPointFromPointData;\n    private createNewMesh;\n    private updatePoints;\n    private setUpPositionsAndColours;\n}/**\n * Contains various methods for polyline. Polyline in bitbybit is a simple object that has points property containing an array of points.\n * { points: number[][] }\n */\ndeclare class Polyline {\n    private readonly context;\n    private readonly geometryHelper;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Draws a single polyline\n     * @param inputs Contains a polyline to be drawn\n     * @returns Lines mesh that is being drawn by Babylon\n     */\n    drawPolyline(inputs: Inputs.Polyline.DrawPolylineDto): LinesMesh;\n    /**\n     * Draws multiple polylines\n     * @param inputs Contains a polyline to be drawn\n     * @returns Lines mesh that is being drawn by Babylon\n     */\n    drawPolylines(inputs: Inputs.Polyline.DrawPolylinesDto): LinesMesh;\n    /**\n     * Converts a polyline to a NURBS curve\n     * Returns the verbnurbs NurbsCurve object\n     * @param inputs Polyline to be transformed to curve\n     * @returns Verb nurbs curve\n     */\n    convertToNurbsCurve(inputs: Inputs.Polyline.PolylineDto): any;\n    /**\n     * Gets the length of the polyline\n     * @param inputs Polyline to be queried\n     * @returns Length of the polyline\n     */\n    length(inputs: Inputs.Polyline.PolylineDto): number;\n    /**\n     * Gets the number of points in the polyline\n     * @param inputs Polyline to be queried\n     * @returns Number of points in polyline\n     */\n    countPoints(inputs: Inputs.Polyline.PolylineDto): number;\n    /**\n     * Gets the points of the polyline\n     * @param inputs Polyline to be queried\n     * @returns Points of the polyline\n     */\n    getPoints(inputs: Inputs.Polyline.PolylineDto): number[][];\n    /**\n     * Reverse the points of the polyline\n     * @param inputs Polyline to be reversed\n     * @returns Reversed polyline\n     */\n    reverse(inputs: Inputs.Polyline.PolylineDto): Inputs.Polyline.PolylinePropertiesDto;\n    /**\n     * Transform the polyline\n     * @param inputs Polyline to be transformed\n     * @returns Transformed polyline\n     */\n    transformPolyline(inputs: Inputs.Polyline.TransformPolylineDto): Inputs.Polyline.PolylinePropertiesDto;\n    /**\n     * Create the polyline\n     * @param inputs Points of the polyline\n     * @returns Polyline\n     */\n    create(inputs: Inputs.Polyline.PolylinePropertiesDto): Inputs.Polyline.PolylinePropertiesDto;\n}/**\n * Tags help you to put text on top of your 3D objects. Tags are heavily used in data visualization scenarios\n * where you need to convery additional textual information.\n */\ndeclare class Tag {\n    /**\n     * Creates a tag dto\n     * @param inputs Tag description\n     * @returns A tag\n     */\n    create(inputs: Inputs.Tag.TagDto): Inputs.Tag.TagDto;\n    /**\n     * Draws a single tag\n     * @param inputs Information to draw the tag\n     * @returns A tag\n     */\n    drawTag(inputs: Inputs.Tag.DrawTagDto): Inputs.Tag.TagDto;\n    /**\n     * Draws multiple tags\n     * @param inputs Information to draw the tags\n     * @returns Tags\n     */\n    drawTags(inputs: Inputs.Tag.DrawTagsDto): Inputs.Tag.TagDto[];\n}/**\n * Contains various text methods.\n */\ndeclare class TextBitByBit {\n    constructor();\n    /**\n     * Creates a text\n     * @param inputs a text\n     * @returns text\n     * @group create\n     * @shortname text\n     * @drawable false\n     */\n    create(inputs: Inputs.Text.TextDto): string;\n    /**\n    * Split the text to multiple pieces by a separator\n    * @param inputs a text\n    * @returns text\n    * @group transform\n    * @shortname split\n    * @drawable false\n    */\n    split(inputs: Inputs.Text.TextSplitDto): string[];\n    /**\n    * Replace all occurrences of a text by another text\n    * @param inputs a text\n    * @returns text\n    * @group transform\n    * @shortname replaceAll\n    * @drawable false\n    */\n    replaceAll(inputs: Inputs.Text.TextReplaceDto): string;\n    /**\n    * Join multiple items by a separator into text\n    * @param inputs a list of items\n    * @returns text\n    * @group transform\n    * @shortname join\n    * @drawable false\n    */\n    join(inputs: Inputs.Text.TextJoinDto): string;\n    /**\n    * Transform any item to text\n    * @param inputs any item\n    * @returns text\n    * @group transform\n    * @shortname to string\n    * @drawable false\n    */\n    toString(inputs: Inputs.Text.ToStringDto): string;\n    /**\n    * Transform each item in list to text\n    * @param inputs list of items\n    * @returns texts\n    * @group transform\n    * @shortname to string each\n    * @drawable false\n    */\n    toStringEach(inputs: Inputs.Text.ToStringEachDto): string[];\n}{};/**\n * Time functions help to create various interactions which happen in time\n */\ndeclare class Time {\n    /**\n     * Registers a function to render loop\n     * @param update The function to call in render loop\n     */\n    registerRenderFunction(update: (timePassedMs: number) => void): void;\n}/**\n * Contains various methods for vector mathematics. Vector in bitbybit is simply an array, usually containing numbers.\n * In 3D [x, y, z] form describes space, where y is the up vector.\n * Because of this form Vector can be interchanged with Point, which also is an array in [x, y, z] form.\n */\ndeclare class Vector {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Measures the angle between two vectors in degrees\n     * @param inputs Contains two vectors represented as number arrays\n     * @group angles\n     * @shortname angle\n     * @returns Number in degrees\n     * @drawable false\n     */\n    angleBetween(inputs: Inputs.Vector.TwoVectorsDto): number;\n    /**\n     * Measures the normalized 2d angle between two vectors in degrees\n     * @param inputs Contains two vectors represented as number arrays\n     * @returns Number in degrees\n     * @group angles\n     * @shortname angle normalized 2d\n     * @drawable false\n     */\n    angleBetweenNormalized2d(inputs: Inputs.Vector.TwoVectorsDto): number;\n    /**\n     * Measures a positive angle between two vectors given the reference vector in degrees\n     * @param inputs Contains information of two vectors and a reference vector\n     * @returns Number in degrees\n     * @group angles\n     * @shortname positive angle\n     * @drawable false\n     */\n    positiveAngleBetween(inputs: Inputs.Vector.TwoVectorsReferenceDto): number;\n    /**\n     * Adds all vector xyz values together and create a new vector\n     * @param inputs Vectors to be added\n     * @returns New vector that has xyz values as sums of all the vectors\n     * @group sum\n     * @shortname add all\n     * @drawable false\n     */\n    addAll(inputs: Inputs.Vector.VectorsDto): number[];\n    /**\n     * Adds two vectors together\n     * @param inputs Two vectors to be added\n     * @returns Number array representing vector\n     * @group sum\n     * @shortname add\n     * @drawable false\n     */\n    add(inputs: Inputs.Vector.TwoVectorsDto): number[];\n    /**\n     * Checks if the boolean array contains only true values, if there's a single false it will return false.\n     * @param inputs Vectors to be checked\n     * @returns Boolean indicating if vector contains only true values\n     * @group sum\n     * @shortname all\n     * @drawable false\n     */\n    all(inputs: Inputs.Vector.VectorBoolDto): boolean;\n    /**\n     * Cross two vectors\n     * @param inputs Two vectors to be crossed\n     * @group base\n     * @shortname all\n     * @returns Crossed vector\n     * @drawable false\n     */\n    cross(inputs: Inputs.Vector.TwoVectorsDto): number[];\n    /**\n     * Squared distance between two vectors\n     * @param inputs Two vectors\n     * @returns Number representing squared distance between two vectors\n     * @group distance\n     * @shortname dist squared\n     * @drawable false\n     */\n    distSquared(inputs: Inputs.Vector.TwoVectorsDto): number;\n    /**\n     * Distance between two vectors\n     * @param inputs Two vectors\n     * @returns Number representing distance between two vectors\n     * @group distance\n     * @shortname dist\n     * @drawable false\n     */\n    dist(inputs: Inputs.Vector.TwoVectorsDto): number;\n    /**\n     * Divide the vector by a scalar value\n     * @param inputs Contains vector and a scalar\n     * @returns Vector that is a result of division by a scalar\n     * @group base\n     * @shortname div\n     * @drawable false\n     */\n    div(inputs: Inputs.Vector.VectorScalarDto): number[];\n    /**\n     * Computes the domain between minimum and maximum values of the vector\n     * @param inputs Vector information\n     * @returns Number representing distance between two vectors\n     * @group base\n     * @shortname domain\n     * @drawable false\n     */\n    domain(inputs: Inputs.Vector.VectorDto): number;\n    /**\n     * Dot product between two vectors\n     * @param inputs Two vectors\n     * @returns Number representing dot product of the vector\n     * @group base\n     * @shortname dot\n     * @drawable false\n     */\n    dot(inputs: Inputs.Vector.TwoVectorsDto): number;\n    /**\n     * Checks if vector is finite for each number and returns a boolean array\n     * @param inputs Vector with possibly infinite values\n     * @returns Vector array that contains boolean values for each number in the input\n     * vector that identifies if value is finite (true) or infinite (false)\n     * @group validate\n     * @shortname finite\n     * @drawable false\n     */\n    finite(inputs: Inputs.Vector.VectorDto): boolean[];\n    /**\n     * Checks if the vector is zero length\n     * @param inputs Vector to be checked\n     * @returns Boolean that identifies if vector is zero length\n     * @group validate\n     * @shortname isZero\n     * @drawable false\n     */\n    isZero(inputs: Inputs.Vector.VectorDto): boolean;\n    /**\n     * Finds in between vector between two vectors by providing a fracture\n     * @param inputs Information for finding vector between two vectors using a fraction\n     * @returns Vector that is in between two vectors\n     * @group distance\n     * @shortname lerp\n     * @drawable false\n     */\n    lerp(inputs: Inputs.Vector.FractionTwoVectorsDto): number[];\n    /**\n     * Finds the maximum value in the vector\n     * @param inputs Vector to be checked\n     * @returns Largest number in the vector\n     * @group extract\n     * @shortname max\n     * @drawable false\n     */\n    max(inputs: Inputs.Vector.VectorDto): number;\n    /**\n     * Finds the minimum value in the vector\n     * @param inputs Vector to be checked\n     * @returns Lowest number in the vector\n     * @group extract\n     * @shortname min\n     * @drawable false\n     */\n    min(inputs: Inputs.Vector.VectorDto): number;\n    /**\n     * Multiple vector with the scalar\n     * @param inputs Vector with a scalar\n     * @returns Vector that results from multiplication\n     * @group base\n     * @shortname mul\n     * @drawable false\n     */\n    mul(inputs: Inputs.Vector.VectorScalarDto): number[];\n    /**\n     * Negates the vector\n     * @param inputs Vector to negate\n     * @returns Negative vector\n     * @group base\n     * @shortname neg\n     * @drawable false\n     */\n    neg(inputs: Inputs.Vector.VectorDto): number[];\n    /**\n     * Compute squared norm\n     * @param inputs Vector for squared norm\n     * @returns Number that is squared norm\n     * @group base\n     * @shortname norm squared\n     * @drawable false\n     */\n    normSquared(inputs: Inputs.Vector.VectorDto): number;\n    /**\n     * Norm of the vector\n     * @param inputs Vector to compute the norm\n     * @returns Number that is norm of the vector\n     * @group base\n     * @shortname norm\n     * @drawable false\n     */\n    norm(inputs: Inputs.Vector.VectorDto): number;\n    /**\n     * Normalize the vector into a unit vector, that has a length of 1\n     * @param inputs Vector to normalize\n     * @returns Unit vector that has length of 1\n     * @group base\n     * @shortname normalized\n     * @drawable false\n     */\n    normalized(inputs: Inputs.Vector.VectorDto): number[];\n    /**\n     * Finds a point coordinates on the given distance ray that spans between the point along the direction vector\n     * @param inputs Provide a point, vector and a distance for finding a point\n     * @returns Vector representing point on the ray\n     * @group base\n     * @shortname on ray\n     * @drawable false\n     */\n    onRay(inputs: Inputs.Vector.RayPointDto): number[];\n    /**\n     * Create a xyz vector\n     * @param inputs Max value for the range\n     * @returns Create a vector of xyz values\n     * @group create\n     * @shortname vector XYZ\n     * @drawable true\n     */\n    vectorXYZ(inputs: Inputs.Vector.VectorXYZDto): Inputs.Base.Vector3;\n    /**\n     * Creates a vector of integers between 0 and maximum ceiling integer\n     * @param inputs Max value for the range\n     * @returns Vector containing items from 0 to max\n     * @group create\n     * @shortname range\n     * @drawable false\n     */\n    range(inputs: Inputs.Vector.RangeMaxDto): number[];\n    /**\n     * Computes signed angle between two vectors and a reference. This will always return a smaller angle between two possible angles.\n     * @param inputs Contains information of two vectors and a reference vector\n     * @returns Signed angle in degrees\n     * @group angles\n     * @shortname signed angle\n     * @drawable false\n     */\n    signedAngleBetween(inputs: Inputs.Vector.TwoVectorsReferenceDto): number;\n    /**\n     * Creates a vector that contains numbers spanning between minimum and maximum values at a given step\n     * @param inputs Span information containing min, max and step values\n     * @returns Vector containing number between min, max and increasing at a given step\n     * @group create\n     * @shortname span\n     * @drawable false\n     */\n    span(inputs: Inputs.Vector.SpanDto): number[];\n    /**\n     * Subtract two vectors\n     * @param inputs Two vectors\n     * @returns Vector that result by subtraction two vectors\n     * @group base\n     * @shortname sub\n     * @drawable false\n     */\n    sub(inputs: Inputs.Vector.TwoVectorsDto): number[];\n    /**\n     * Sums the values of the vector\n     * @param inputs Vector to sum\n     * @returns Number that results by adding up all values in the vector\n     * @group base\n     * @shortname sum\n     * @drawable false\n     */\n    sum(inputs: Inputs.Vector.VectorDto): number;\n}/**\n * Contains various methods for nurbs circle.\n * These methods wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbCurveCircle {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the circle Nurbs curve\n     * @param inputs Circle parameters\n     * @returns Circle Nurbs curve\n     */\n    createCircle(inputs: Inputs.Verb.CircleParametersDto): any;\n    /**\n     * Creates the arc Nurbs curve\n     * @param inputs Arc parameters\n     * @returns Arc Nurbs curve\n     */\n    createArc(inputs: Inputs.Verb.ArcParametersDto): any;\n    /**\n     * Gets the center point of the circle or an arc\n     * @param inputs An arc or a circle Nurbs curve\n     * @returns Point\n     */\n    center(inputs: Inputs.Verb.CircleDto): number[];\n    /**\n     * Gets the radius of the circle or an arc\n     * @param inputs An arc or a circle Nurbs curve\n     * @returns Radius\n     */\n    radius(inputs: Inputs.Verb.CircleDto): number;\n    /**\n     * Gets the max angle of the arc in degrees\n     * @param inputs Arc\n     * @returns Max angle in degrees\n     */\n    maxAngle(inputs: Inputs.Verb.CircleDto): number;\n    /**\n     * Gets the min angle of the arc in degrees\n     * @param inputs Arc\n     * @returns Min angle in degrees\n     */\n    minAngle(inputs: Inputs.Verb.CircleDto): number;\n    /**\n     * Gets the x angle of the arc\n     * @param inputs Circle\n     * @returns X axis vector\n     */\n    xAxis(inputs: Inputs.Verb.CircleDto): number[];\n    /**\n     * Gets the y angle of the arc\n     * @param inputs Circle\n     * @returns Y axis vector\n     */\n    yAxis(inputs: Inputs.Verb.CircleDto): number[];\n}/**\n * Contains various methods for nurbs ellipse.\n * These methods wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbCurveEllipse {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the ellipse Nurbs curve\n     * @param inputs Ellipse parameters\n     * @returns Ellipse Nurbs curve\n     */\n    createEllipse(inputs: Inputs.Verb.EllipseParametersDto): any;\n    /**\n     * Creates the ellipse arc Nurbs curve\n     * @param inputs Ellipse arc parameters\n     * @returns Ellipse arc Nurbs curve\n     */\n    createArc(inputs: Inputs.Verb.EllipseArcParametersDto): any;\n    /**\n     * Gets the center point of the ellipse or an arc\n     * @param inputs The arc or the ellipse Nurbs curve\n     * @returns Point\n     */\n    center(inputs: Inputs.Verb.EllipseDto): number[];\n    /**\n     * Gets the max angle of the arc in degrees\n     * @param inputs Arc\n     * @returns Max angle in degrees\n     */\n    maxAngle(inputs: Inputs.Verb.EllipseDto): number;\n    /**\n     * Gets the min angle of the arc in degrees\n     * @param inputs Arc\n     * @returns Min angle in degrees\n     */\n    minAngle(inputs: Inputs.Verb.EllipseDto): number;\n    /**\n     * Gets the x angle of the arc or an ellipse\n     * @param inputs Ellipse or an arc\n     * @returns X axis vector\n     */\n    xAxis(inputs: Inputs.Verb.EllipseDto): number[];\n    /**\n     * Gets the y angle of the arc or an ellipse\n     * @param inputs Ellipse or an arc\n     * @returns Y axis vector\n     */\n    yAxis(inputs: Inputs.Verb.EllipseDto): number[];\n}/**\n * Contains various methods for nurbs curves.\n * These methods wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbCurve {\n    private readonly context;\n    private readonly geometryHelper;\n    readonly circle: VerbCurveCircle;\n    readonly ellipse: VerbCurveEllipse;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Draws a single curve\n     * @param inputs Contains a curve to be drawn\n     * @returns Lines mesh that is being drawn by Babylon\n     */\n    drawCurve(inputs: Inputs.Verb.DrawCurveDto): LinesMesh;\n    /**\n     * Draws multiple curves\n     * @param inputs Contains curves to be drawn\n     * @returns Lines mesh that is being drawn by Babylon\n     */\n    drawCurves(inputs: Inputs.Verb.DrawCurvesDto): LinesMesh;\n    /**\n     * Creates a Nurbs curve by providing knots, control points & weights\n     * @param inputs Contains knots, control points and weights\n     * @returns Nurbs curve\n     */\n    createCurveByKnotsControlPointsWeights(inputs: Inputs.Verb.CurveNurbsDataDto): any;\n    /**\n     * Creates a Nurbs curve by providing control points\n     * @param inputs Control points\n     * @returns Nurbs curve\n     */\n    createCurveByPoints(inputs: Inputs.Verb.CurvePathDataDto): any;\n    /**\n     * Creates a Bezier Nurbs curve by providing control points and weights\n     * @param inputs Control points\n     * @returns Bezier Nurbs curve\n     */\n    createBezierCurve(inputs: Inputs.Verb.BezierCurveDto): any;\n    /**\n     * Clone the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Nurbs curve\n     */\n    clone(inputs: Inputs.Verb.CurveDto): any;\n    /**\n     * Finds the closest param on the Nurbs curve from the point\n     * @param inputs Nurbs curve with point\n     * @returns Param number\n     */\n    closestParam(inputs: Inputs.Verb.ClosestPointDto): number;\n    /**\n     * Finds the closest params on the Nurbs curve from the points\n     * @param inputs Nurbs curve with points\n     * @returns Param numbers\n     */\n    closestParams(inputs: Inputs.Verb.ClosestPointsDto): number[];\n    /**\n     * Finds the closest point on the Nurbs curve from the point\n     * @param inputs Nurbs curve with point\n     * @returns Point\n     */\n    closestPoint(inputs: Inputs.Verb.ClosestPointDto): Inputs.Base.Point3;\n    /**\n     * Finds the closest points on the Nurbs curve from the list of points\n     * @param inputs Nurbs curve with points\n     * @returns Points\n     */\n    closestPoints(inputs: Inputs.Verb.ClosestPointsDto): Inputs.Base.Point3[];\n    /**\n     * Finds the control points of the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Points\n     */\n    controlPoints(inputs: Inputs.Verb.CurveDto): Inputs.Base.Point3[];\n    /**\n     * Finds the degree of the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Degree number\n     */\n    degree(inputs: Inputs.Verb.CurveDto): number;\n    /**\n     * Finds the derivatives of the Nurbs curve at parameter\n     * @param inputs Nurbs curve with specified derivative number and parameter\n     * @returns Derivatives\n     */\n    derivatives(inputs: Inputs.Verb.CurveDerivativesDto): number[];\n    /**\n     * Divides the curve by equal arc length to parameters\n     * @param inputs Nurbs curve\n     * @returns Parameters\n     */\n    divideByEqualArcLengthToParams(inputs: Inputs.Verb.CurveSubdivisionsDto): number[];\n    /**\n     * Divides the curve by equal arc length to points\n     * @param inputs Nurbs curve\n     * @returns Points\n     */\n    divideByEqualArcLengthToPoints(inputs: Inputs.Verb.CurveSubdivisionsDto): Inputs.Base.Point3[];\n    /**\n     * Divides the curve by arc length to parameters\n     * @param inputs Nurbs curve\n     * @returns Parameters\n     */\n    divideByArcLengthToParams(inputs: Inputs.Verb.CurveDivideLengthDto): number[];\n    /**\n     * Divides the curve by arc length to points\n     * @param inputs Nurbs curve\n     * @returns Points\n     */\n    divideByArcLengthToPoints(inputs: Inputs.Verb.CurveDivideLengthDto): Inputs.Base.Point3[];\n    /**\n     * Divides multiple curves by equal arc length to points\n     * @param inputs Nurbs curves\n     * @returns Points placed for each curve in separate arrays\n     */\n    divideCurvesByEqualArcLengthToPoints(inputs: Inputs.Verb.CurvesSubdivisionsDto): Inputs.Base.Point3[][];\n    /**\n     * Divides multiple curves by arc length to points\n     * @param inputs Nurbs curves\n     * @returns Points placed for each curve in separate arrays\n     */\n    divideCurvesByArcLengthToPoints(inputs: Inputs.Verb.CurvesDivideLengthDto): Inputs.Base.Point3[][];\n    /**\n     * Finds the domain interval of the curve parameters\n     * @param inputs Nurbs curve\n     * @returns Interval domain\n     */\n    domain(inputs: Inputs.Verb.CurveDto): BaseTypes.IntervalDto;\n    /**\n     * Start point of the curve\n     * @param inputs Nurbs curve\n     * @returns Start point\n     */\n    startPoint(inputs: Inputs.Verb.CurveDto): Inputs.Base.Point3;\n    /**\n     * End point of the curve\n     * @param inputs Nurbs curve\n     * @returns End point\n     */\n    endPoint(inputs: Inputs.Verb.CurveDto): Inputs.Base.Point3;\n    /**\n     * Start points of the curves\n     * @param inputs Nurbs curves\n     * @returns Start points\n     */\n    startPoints(inputs: Inputs.Verb.CurvesDto): Inputs.Base.Point3[];\n    /**\n     * End points of the curves\n     * @param inputs Nurbs curves\n     * @returns End points\n     */\n    endPoints(inputs: Inputs.Verb.CurvesDto): Inputs.Base.Point3[];\n    /**\n     * Finds the knots of the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Knots\n     */\n    knots(inputs: Inputs.Verb.CurveDto): number[];\n    /**\n     * Gets the length of the Nurbs curve at specific parameter\n     * @param inputs Nurbs curve and parameter\n     * @returns Length\n     */\n    lengthAtParam(inputs: Inputs.Verb.CurveParameterDto): number;\n    /**\n     * Gets the length of the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Length\n     */\n    length(inputs: Inputs.Verb.CurveDto): number;\n    /**\n     * Gets the param at specified length on the Nurbs curve\n     * @param inputs Nurbs curve, length and tolerance\n     * @returns Parameter\n     */\n    paramAtLength(inputs: Inputs.Verb.CurveLengthToleranceDto): number;\n    /**\n     * Gets the point at specified parameter on the Nurbs curve\n     * @param inputs Nurbs curve and a parameter\n     * @returns Point\n     */\n    pointAtParam(inputs: Inputs.Verb.CurveParameterDto): Inputs.Base.Point3;\n    /**\n     * Gets the points at specified parameter on the Nurbs curves\n     * @param inputs Nurbs curves and a parameter\n     * @returns Points in arrays for each curve\n     */\n    pointsAtParam(inputs: Inputs.Verb.CurvesParameterDto): Inputs.Base.Point3[];\n    /**\n     * Reverses the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Reversed Nurbs curve\n     */\n    reverse(inputs: Inputs.Verb.CurveDto): any;\n    /**\n     * Splits the Nurbs curve in two at a given parameter\n     * @param inputs Nurbs curve with parameter\n     * @returns Nurbs curves\n     */\n    split(inputs: Inputs.Verb.CurveParameterDto): any[];\n    /**\n     * Tangent of the Nurbs curve at a given parameter\n     * @param inputs Nurbs curve with parameter\n     * @returns Tangent vector\n     */\n    tangent(inputs: Inputs.Verb.CurveParameterDto): Inputs.Base.Vector3;\n    /**\n     * Tessellates the Nurbs curve into a list of points\n     * @param inputs Nurbs curve with tolerance\n     * @returns Points\n     */\n    tessellate(inputs: Inputs.Verb.CurveToleranceDto): Inputs.Base.Point3[];\n    /**\n     * Transforms the Nurbs curve\n     * @param inputs Nurbs curve with transformation matrixes\n     * @returns Transformed curve\n     */\n    transform(inputs: Inputs.Verb.CurveTransformDto): any;\n    /**\n     * Transforms the Nurbs curves\n     * @param inputs Nurbs curves with transformation matrixes\n     * @returns Transformed curves\n     */\n    transformCurves(inputs: Inputs.Verb.CurvesTransformDto): any[];\n    /**\n     * Weights of the Nurbs curve\n     * @param inputs Nurbs curve\n     * @returns Weights\n     */\n    weights(inputs: Inputs.Verb.CurveDto): number[];\n}/**\n * Functions that allow to intersect various geometric entities and get the results\n */\ndeclare class VerbIntersect {\n    private readonly context;\n    private readonly geometryHelper;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Intersects two verb Nurbs curves together and returns intersection results\n     * @param inputs Two Nurbs curves\n     * @returns Intersection results\n     */\n    curves(inputs: Inputs.Verb.CurveCurveDto): BaseTypes.CurveCurveIntersection[];\n    /**\n     * Intersects curve and surface\n     * @param inputs Nurbs curve and a Nurbs surface\n     * @returns Intersection results\n     */\n    curveAndSurface(inputs: Inputs.Verb.CurveSurfaceDto): BaseTypes.CurveSurfaceIntersection[];\n    /**\n     * Intersects two surfaces\n     * @param inputs Nurbs curve and a Nurbs surface\n     * @returns Nurbs curves along the intersection\n     */\n    surfaces(inputs: Inputs.Verb.SurfaceSurfaceDto): any[];\n    /**\n     * Gets intersection parameters on the first curve from curve-curve intersection\n     * @param inputs Intersections data\n     * @returns Parameters on first curve\n     */\n    curveCurveFirstParams(inputs: Inputs.Verb.CurveCurveIntersectionsDto): number[];\n    /**\n     * Gets intersection parameters on the second curve from curve-curve intersection\n     * @param inputs Intersections data\n     * @returns Parameters on second curve\n     */\n    curveCurveSecondParams(inputs: Inputs.Verb.CurveCurveIntersectionsDto): number[];\n    /**\n     * Gets intersection points on the first curve from curve-curve intersection\n     * @param inputs Intersections data\n     * @returns Points on first curve\n     */\n    curveCurveFirstPoints(inputs: Inputs.Verb.CurveCurveIntersectionsDto): number[][];\n    /**\n     * Gets intersection points on the second curve from curve-curve intersection\n     * @param inputs Intersections data\n     * @returns Points on second curve\n     */\n    curveCurveSecondPoints(inputs: Inputs.Verb.CurveCurveIntersectionsDto): number[][];\n    /**\n     * Gets intersection parameters on the curve from curve-surface intersection\n     * @param inputs Intersections data\n     * @returns Parameters on the curve\n     */\n    curveSurfaceCurveParams(inputs: Inputs.Verb.CurveSurfaceIntersectionsDto): number[];\n    /**\n     * Gets intersection parameters on the surface from curve-surface intersection\n     * @param inputs Intersections data\n     * @returns Parameters on the surface\n     */\n    curveSurfaceSurfaceParams(inputs: Inputs.Verb.CurveSurfaceIntersectionsDto): BaseTypes.UVDto[];\n    /**\n     * Gets intersection points on the curve from curve-surface intersection\n     * @param inputs Intersections data\n     * @returns Points on the curve\n     */\n    curveSurfaceCurvePoints(inputs: Inputs.Verb.CurveSurfaceIntersectionsDto): number[][];\n    /**\n     * Gets intersection points on the surface from curve-surface intersection\n     * @param inputs Intersections data\n     * @returns Points on the surface\n     */\n    curveSurfaceSurfacePoints(inputs: Inputs.Verb.CurveSurfaceIntersectionsDto): number[][];\n}/**\n * Conical surface functions.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurfaceConical {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the conical Nurbs surface\n     * @param inputs Parameters for Nurbs conical surface\n     * @returns Conical Nurbs surface\n     */\n    create(inputs: Inputs.Verb.ConeAndCylinderParametersDto): any;\n    /**\n     * Get cone axis\n     * @param inputs Nurbs conical surface\n     * @returns Axis vector\n     */\n    axis(inputs: Inputs.Verb.ConeDto): number[];\n    /**\n     * Get cone base\n     * @param inputs Nurbs conical surface\n     * @returns Base point\n     */\n    base(inputs: Inputs.Verb.ConeDto): number[];\n    /**\n     * Get cone height\n     * @param inputs Nurbs conical surface\n     * @returns Height\n     */\n    height(inputs: Inputs.Verb.ConeDto): number;\n    /**\n     * Get cone radius\n     * @param inputs Nurbs conical surface\n     * @returns Radius\n     */\n    radius(inputs: Inputs.Verb.ConeDto): number;\n    /**\n     * Get cone x axis\n     * @param inputs Nurbs conical surface\n     * @returns X axis vector\n     */\n    xAxis(inputs: Inputs.Verb.ConeDto): number[];\n}/**\n * Cylindrical surface functions.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurfaceCylindrical {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the cylindrical Nurbs surface\n     * @param inputs Parameters for cylindrical Nurbs surface\n     * @returns Cylindrical Nurbs surface\n     */\n    create(inputs: Inputs.Verb.ConeAndCylinderParametersDto): any;\n    /**\n     * Get cylinder axis\n     * @param inputs Nurbs cylindrical surface\n     * @returns Axis vector\n     */\n    axis(inputs: Inputs.Verb.CylinderDto): number[];\n    /**\n     * Get cylinder base\n     * @param inputs Nurbs cylindrical surface\n     * @returns Base point\n     */\n    base(inputs: Inputs.Verb.CylinderDto): number[];\n    /**\n     * Get cylinder height\n     * @param inputs Nurbs cylindrical surface\n     * @returns Height\n     */\n    height(inputs: Inputs.Verb.CylinderDto): number;\n    /**\n     * Get cylinder radius\n     * @param inputs Nurbs cylindrical surface\n     * @returns Radius\n     */\n    radius(inputs: Inputs.Verb.CylinderDto): number;\n    /**\n     * Get cylinder x axis\n     * @param inputs Nurbs cylindrical surface\n     * @returns X axis vector\n     */\n    xAxis(inputs: Inputs.Verb.CylinderDto): number[];\n}/**\n * Extrusion surface functions.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurfaceExtrusion {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the Nurbs surface extrusion from the curve\n     * @param inputs Nurbs profile curve and direction vector\n     * @returns Nurbs surface\n     */\n    create(inputs: Inputs.Verb.ExtrusionParametersDto): any;\n    /**\n     * Gets the direction vector of the extrusion\n     * @param inputs Extruded Nurbs surface\n     * @returns Vector\n     */\n    direction(inputs: Inputs.Verb.ExtrusionDto): number[];\n    /**\n     * Gets the profile Nurbs curve of the extrusion\n     * @param inputs Extruded Nurbs surface\n     * @returns Profile Nurbs curve\n     */\n    profile(inputs: Inputs.Verb.ExtrusionDto): number[];\n}/**\n * Revolved surface functions.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurfaceRevolved {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the revolved Nurbs surface\n     * @param inputs Parameters for Nurbs revolved surface\n     * @returns Revolved Nurbs surface\n     */\n    create(inputs: Inputs.Verb.RevolutionParametersDto): any;\n    /**\n     * Get the profile Nurbs curve of the revolved Nurbs surface\n     * @param inputs Revolved Nurbs surface\n     * @returns Nurbs curve\n     */\n    profile(inputs: Inputs.Verb.RevolutionDto): any;\n    /**\n     * Get the center Nurbs curve of the revolved Nurbs surface\n     * @param inputs Revolved Nurbs surface\n     * @returns Center point\n     */\n    center(inputs: Inputs.Verb.RevolutionDto): number[];\n    /**\n     * Get the rotation axis of the revolved Nurbs surface\n     * @param inputs Revolved Nurbs surface\n     * @returns Axis vector of rotation\n     */\n    axis(inputs: Inputs.Verb.RevolutionDto): number[];\n    /**\n     * Get the angle of rotation from revolved Nurbs surface\n     * @param inputs Revolved Nurbs surface\n     * @returns Angle in degrees\n     */\n    angle(inputs: Inputs.Verb.RevolutionDto): number;\n}/**\n * Spherical surface functions.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurfaceSpherical {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the spherical Nurbs surface\n     * @param inputs Parameters for Nurbs spherical surface\n     * @returns Spherical Nurbs surface\n     */\n    create(inputs: Inputs.Verb.SphericalParametersDto): any;\n    /**\n     * Get the radius of the spherical Nurbs surface\n     * @param inputs Spherical Nurbs surface\n     * @returns Radius\n     */\n    radius(inputs: Inputs.Verb.SphereDto): number;\n    /**\n     * Get the center of the spherical Nurbs surface\n     * @param inputs Spherical Nurbs surface\n     * @returns Center point\n     */\n    center(inputs: Inputs.Verb.SphereDto): number[];\n}/**\n * Sweep surface functions.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurfaceSweep {\n    private readonly context;\n    constructor(context: Context);\n    /**\n     * Creates the sweep Nurbs surface\n     * @param inputs Parameters for Nurbs sweep surface\n     * @returns Sweep Nurbs surface\n     */\n    create(inputs: Inputs.Verb.SweepParametersDto): any;\n    /**\n     * Get the profile Nurbs curve of the swept Nurbs surface\n     * @param inputs Sweep Nurbs surface\n     * @returns Profile Nurbs curve\n     */\n    profile(inputs: Inputs.Verb.SweepDto): any;\n    /**\n     * Get the rail Nurbs curve of the swept Nurbs surface\n     * @param inputs Sweep Nurbs surface\n     * @returns Rail Nurbs curve\n     */\n    rail(inputs: Inputs.Verb.SweepDto): any;\n}/**\n * Contains various functions for Nurbs surfaces.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class VerbSurface {\n    private readonly context;\n    private readonly geometryHelper;\n    readonly cone: VerbSurfaceConical;\n    readonly cylinder: VerbSurfaceCylindrical;\n    readonly extrusion: VerbSurfaceExtrusion;\n    readonly sphere: VerbSurfaceSpherical;\n    readonly revolved: VerbSurfaceRevolved;\n    readonly sweep: VerbSurfaceSweep;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n    /**\n     * Draws a single surface\n     * @param inputs Contains a surface and information for drawing\n     * @returns Mesh that is being drawn by Babylon\n     */\n    drawSurface(inputs: Inputs.Verb.DrawSurfaceDto): Mesh;\n    /**\n     * Draws multiple surfaces\n     * @param inputs Contains the Nurbs surfaces and information for drawing\n     * @returns Mesh that is being drawn by Babylon\n     */\n    drawSurfaces(inputs: Inputs.Verb.DrawSurfacesDto): Mesh;\n    /**\n     * Draws multiple surfaces with multiple colours. Number of colours has to be equal to number of surfaces\n     * @param inputs Contains the Nurbs surfaces, colours and other information for drawing\n     * @returns Mesh that is being drawn by Babylon\n     */\n    drawSurfacesMultiColour(inputs: Inputs.Verb.DrawSurfacesColoursDto): Mesh;\n    /**\n     * Gets the boundary edge Nurbs curves of the surface in a list\n     * @param inputs Nurbs surface\n     * @returns Array of curves\n     */\n    boundaries(inputs: Inputs.Verb.SurfaceDto): any[];\n    /**\n     * Creates the surface by providing 4 points as corners\n     * @param inputs 4 points\n     * @returns Nurbs surface\n     */\n    createSurfaceByCorners(inputs: Inputs.Verb.CornersDto): any;\n    /**\n     * Creates the Nurbs surface by providing uv knots, uv degrees, points and weights\n     * @param inputs Surface creation information\n     * @returns Nurbs surface\n     */\n    createSurfaceByKnotsControlPointsWeights(inputs: Inputs.Verb.KnotsControlPointsWeightsDto): any;\n    /**\n     * Creates the Nurbs surface by lofting curves\n     * @param inputs Curves to loft through\n     * @returns Nurbs surface\n     */\n    createSurfaceByLoftingCurves(inputs: Inputs.Verb.LoftCurvesDto): any;\n    /**\n     * Clone the Nurbs surface\n     * @param inputs Nurbs surface\n     * @returns Nurbs surface\n     */\n    clone(inputs: Inputs.Verb.SurfaceDto): any;\n    /**\n     * Finds the closest parameter on the surface from the point\n     * @param inputs Nurbs surface with a point\n     * @returns UV parameters\n     */\n    closestParam(inputs: Inputs.Verb.SurfaceParamDto): BaseTypes.UVDto;\n    /**\n     * Finds the closest point on the surface from the point\n     * @param inputs Nurbs surface with a point\n     * @returns Point\n     */\n    closestPoint(inputs: Inputs.Verb.SurfaceParamDto): number[];\n    /**\n     * Gets the control points on the surface\n     * @param inputs Nurbs surface\n     * @returns Two dimensional array of points\n     */\n    controlPoints(inputs: Inputs.Verb.SurfaceDto): number[][][];\n    /**\n     * Gets the U degree of the surface\n     * @param inputs Nurbs surface\n     * @returns U degree\n     */\n    degreeU(inputs: Inputs.Verb.SurfaceDto): number;\n    /**\n     * Gets the V degree of the surface\n     * @param inputs Nurbs surface\n     * @returns V degree\n     */\n    degreeV(inputs: Inputs.Verb.SurfaceDto): number;\n    /**\n     * Gets the derivatives of the surface at specified uv coordinate\n     * @param inputs Nurbs surface\n     * @returns Two dimensional array of vectors\n     */\n    derivatives(inputs: Inputs.Verb.DerivativesDto): number[][][];\n    /**\n     * Gets the U domain of the surface\n     * @param inputs Nurbs surface\n     * @returns U domain as interval\n     */\n    domainU(inputs: Inputs.Verb.SurfaceDto): BaseTypes.IntervalDto;\n    /**\n     * Gets the V domain of the surface\n     * @param inputs Nurbs surface\n     * @returns V domain as interval\n     */\n    domainV(inputs: Inputs.Verb.SurfaceDto): BaseTypes.IntervalDto;\n    /**\n     * Gets the Nurbs isocurve on the surface\n     * @param inputs Nurbs surface\n     * @returns Nurbs curve\n     */\n    isocurve(inputs: Inputs.Verb.SurfaceParameterDto): any;\n    /**\n     * Subdivides surface into preferred number of isocurves\n     * @param inputs Nurbs surface\n     * @returns Nurbs curves\n     */\n    isocurvesSubdivision(inputs: Inputs.Verb.IsocurveSubdivisionDto): any[];\n    /**\n     * Subdivides surface into isocurves on specified array of parameters\n     * @param inputs Nurbs surface\n     * @returns Nurbs curves\n     */\n    isocurvesAtParams(inputs: Inputs.Verb.IsocurvesParametersDto): any[];\n    /**\n     * Gets the U knots of the surface\n     * @param inputs Nurbs surface\n     * @returns Knots on u direction\n     */\n    knotsU(inputs: Inputs.Verb.SurfaceDto): number[];\n    /**\n     * Gets the V knots of the surface\n     * @param inputs Nurbs surface\n     * @returns Knots on v direction\n     */\n    knotsV(inputs: Inputs.Verb.SurfaceDto): number[];\n    /**\n     * Gets the normal on the surface at uv coordinate\n     * @param inputs Nurbs surface\n     * @returns Normal vector\n     */\n    normal(inputs: Inputs.Verb.SurfaceLocationDto): number[];\n    /**\n     * Gets the point on the surface at uv coordinate\n     * @param inputs Nurbs surface\n     * @returns Point\n     */\n    point(inputs: Inputs.Verb.SurfaceLocationDto): number[];\n    /**\n     * Reverse the Nurbs surface. This will reverse the UV origin and isocurve directions\n     * @param inputs Nurbs surface\n     * @returns Nurbs surface\n     */\n    reverse(inputs: Inputs.Verb.SurfaceDto): any;\n    /**\n     * Splits the Nurbs surface in two halfs.\n     * @param inputs Nurbs surface\n     * @returns Two Nurbs surfaces\n     */\n    split(inputs: Inputs.Verb.SurfaceParameterDto): any[];\n    /**\n     * Transforms the Nurbs surface with a given list of transformations.\n     * @param inputs Nurbs surface with transforms\n     * @returns Nurbs surface\n     */\n    transformSurface(inputs: Inputs.Verb.SurfaceTransformDto): any;\n    /**\n     * Gets the weights of the surface\n     * @param inputs Nurbs surface\n     * @returns Two dimensional array of weights\n     */\n    weights(inputs: Inputs.Verb.SurfaceDto): number[][];\n    private parseFaces;\n}/**\n * Contains various functions for Nurbs curves and surfaces.\n * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.\n * Thanks Peter Boyer for his work.\n */\ndeclare class Verb {\n    readonly curve: VerbCurve;\n    readonly surface: VerbSurface;\n    readonly intersect: VerbIntersect;\n    constructor(context: Context, geometryHelper: GeometryHelper);\n}";
