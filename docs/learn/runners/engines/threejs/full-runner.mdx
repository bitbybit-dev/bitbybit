---
sidebar_position: 1
title: ThreeJS Full Runner
description: Learn how to use the full version of the Bitbybit ThreeJS runner for CAD operations
---

import BitByBitRenderCanvas from '@site/src/components/BitByBitRenderCanvas';

# ThreeJS Full Runner

The **full runner** bundles Three.js together with Bitbybit, so you don't need to load Three.js separately. This makes setup simpler but results in a larger bundle size.

## Live Example

<BitByBitRenderCanvas
  requireManualStart={true}
  iframeUrl="https://stackblitz.com/edit/bitbybit-threejs-full-runner?embed=1&file=index.html&theme=dark"
  title="StackBlitz - Three.js Full Runner Example"
/>

## Complete Example

Below is a complete example that creates a parametric lofted surface with rectangle holes using OCCT:

```html
<!doctype html>
<html lang="en">

<head>
    <title>Bitbybit Runner ThreeJS Full Example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Load the full ThreeJS runner (includes ThreeJS) -->
    <script
        src="https://cdn.jsdelivr.net/gh/bitbybit-dev/bitbybit-assets@latest/runner/bitbybit-runner-threejs.js"></script>
    <script type="module">

        const runnerOptions = {
            canvasId: 'myCanvas',
            canvasZoneClass: 'myCanvasZone',
            enableOCCT: true,
            enableJSCAD: false,
            enableManifold: false,
            cameraPosition: [20, 10, 20],
            cameraTarget: [10, 5, 0],
            backgroundColor: "#1a1c1f",
            loadFonts: ['Roboto'],
        };

        const runner = window.bitbybitRunner.getRunnerInstance();
        const { bitbybit, Bit, camera, scene, renderer, THREEJS } = await runner.run(
            runnerOptions
        );

        // Create a directional light with shadows
        const dirLight = new THREEJS.DirectionalLight(0xffffff, 50);
        dirLight.position.set(60, 70, -30);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Model parameters
        const model = {
            uRec: 16,
            vRec: 16,
            rounding: 0.5,
            drawEdges: true,
            drawFaces: true,
            color: '#6600ff'
        }

        // Create curve points for lofting
        const curvePts = [
            [[-10, 0, -10], [0, 3, -10], [10, -1, -10], [20, 2, -10]],
            [[-10, -5, 0], [0, -3, 0], [10, 1, 0], [20, -2, 0]],
            [[-10, 0, 10], [0, 3, 10], [10, -1, 10], [20, 2, 10]]
        ];

        // Create wires from interpolated points
        const wirePromises = curvePts.map((pts) => {
            return bitbybit.occt.shapes.wire.interpolatePoints({
                points: pts, periodic: false, tolerance: 1e-7
            });
        });

        const wires = await Promise.all(wirePromises);
        const loft = await bitbybit.occt.operations.loft({ shapes: wires, makeSolid: false });
        const translated = await bitbybit.occt.transforms.translate({ shape: loft, translation: [0, 10, 0] });
        const faces = await bitbybit.occt.shapes.face.getFaces({ shape: translated });

        // Subdivide face with rectangle holes
        const subdivideOptions = new Bit.Inputs.OCCT.FaceSubdivideToRectangleHolesDto(faces[0]);
        subdivideOptions.nrRectanglesU = model.vRec;
        subdivideOptions.nrRectanglesV = model.uRec;
        subdivideOptions.scalePatternU = [0.9, 0.5, 0.7];
        subdivideOptions.scalePatternV = [0.9, 0.5, 0.7];
        subdivideOptions.filletPattern = [model.rounding];
        subdivideOptions.inclusionPattern = [false, true, true, true, true];
        subdivideOptions.offsetFromBorderU = 0.01;
        subdivideOptions.offsetFromBorderV = 0.01;

        const withHoles = await bitbybit.occt.shapes.face.subdivideToRectangleHoles(subdivideOptions);
        const finalShape = await bitbybit.occt.operations.makeThickSolidSimple({
            shape: withHoles[0], offset: 0.5
        });

        // Draw options with custom material
        const options = new Bit.Inputs.Draw.DrawOcctShapeOptions();
        options.precision = 0.02;
        options.drawEdges = model.drawEdges;
        options.drawFaces = model.drawFaces;
        options.drawVertices = false;
        options.edgeWidth = 20;
        options.edgeColour = "#000000";

        // Create custom ThreeJS material
        const mat = new THREEJS.MeshPhongMaterial({ color: new THREEJS.Color(model.color) });
        mat.polygonOffset = true;
        mat.polygonOffsetFactor = 1;
        options.faceMaterial = mat;

        const group = await bitbybit.draw.drawAnyAsync({ entity: finalShape, options });

        // Enable shadows on mesh children
        group.children[0].children.forEach((child) => {
            child.castShadow = true;
            child.receiveShadow = true;
        });

    </script>
    <style>
        body {
            margin: 0;
            background-color: #1a1c1f;
        }
        #myCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        .myCanvasZone {
            width: 100%;
            height: 100vh;
        }
    </style>
</head>

<body>
    <div class="myCanvasZone">
        <canvas id="myCanvas"></canvas>
    </div>
</body>

</html>
```

## Key Points

### Runner Script
```html
<script src="https://cdn.jsdelivr.net/gh/bitbybit-dev/bitbybit-assets@latest/runner/bitbybit-runner-threejs.js"></script>
```

The full runner includes ThreeJS, so you don't need to load it separately.

### Initialization
```javascript
const runner = window.bitbybitRunner.getRunnerInstance();
const { bitbybit, Bit, camera, scene, renderer, THREEJS } = await runner.run(runnerOptions);
```

The `run()` method returns:
- `bitbybit` - The main Bitbybit API object
- `Bit` - Helper classes including input DTOs
- `camera` - The ThreeJS PerspectiveCamera
- `scene` - The ThreeJS Scene
- `renderer` - The ThreeJS WebGLRenderer
- `THREEJS` - The ThreeJS library itself

### Custom Materials

ThreeJS allows you to create custom materials for your CAD geometry:

```javascript
const mat = new THREEJS.MeshPhongMaterial({ color: new THREEJS.Color('#6600ff') });
mat.polygonOffset = true;
mat.polygonOffsetFactor = 1;
options.faceMaterial = mat;
```

### Runner Options

| Option | Type | Description |
|--------|------|-------------|
| `canvasId` | string | The ID of your canvas element |
| `canvasZoneClass` | string | CSS class for the canvas container |
| `enableOCCT` | boolean | Enable OpenCASCADE kernel |
| `enableJSCAD` | boolean | Enable JSCAD kernel |
| `enableManifold` | boolean | Enable Manifold kernel |
| `cameraPosition` | number[] | Initial camera position [x, y, z] |
| `cameraTarget` | number[] | Camera look-at target [x, y, z] |
| `backgroundColor` | string | Scene background color (hex) |
| `loadFonts` | string[] | Fonts to load for text operations |

## GitHub Source

View the full source code on GitHub: [ThreeJS Full Runner Examples](https://github.com/bitbybit-dev/bitbybit/tree/master/examples/runner/threejs/full)
