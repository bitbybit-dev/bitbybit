---
sidebar_position: 1
title: Simple Flower
sidebar_label: Simple Flower
description: Create simple flower
tags: [code, occt, rete, blockly, typescript]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import BitByBitRenderCanvas from '@site/src/components/BitByBitRenderCanvas';

<img 
  class="category-icon-small" 
  src="https://s.bitbybit.dev/assets/icons/white/occt-icon.svg" 
  alt="OCCT category icon with a stylized logo representation" 
  title="OCCT category icon" />

Creating organic, flower-like forms demonstrates the power of parametric design in generating natural-looking geometry through mathematical operations. This tutorial explores how to build a simple flower using curve interpolation, mirroring, and rotational patterns—fundamental techniques that can be applied to create complex botanical forms, decorative elements, and artistic sculptures.

The flower design process combines several key concepts: defining control points for smooth curves, using symmetry operations to create balanced shapes, and employing rotational arrays to generate repetitive patterns. These techniques are essential for parametric art, architectural ornamentation, and procedural modeling applications.

## Understanding the Flower Construction Process

Our approach breaks down flower creation into logical steps that mirror how natural flowers develop. We start with a single petal defined by a curved path, create symmetry through mirroring, add thickness to make it solid, then rotate copies around a central axis to form the complete flower.

This method is highly parametric—by adjusting the control points, rotation angles, or thickness values, you can quickly generate different flower variations. The same principles apply to creating other organic forms like leaves, shells, or abstract sculptural elements.

<Tabs groupId="simple-flower-live-example">
<TabItem value="rete" label="Rete">
    <BitByBitRenderCanvas
    requireManualStart={true}
    script={{"script":"{\"id\":\"rete-v2-json\",\"nodes\":{\"8faa0c5fb9823237\":{\"id\":\"8faa0c5fb9823237\",\"name\":\"bitbybit.occt.shapes.wire.interpolatePoints\",\"customName\":\"interpolate points\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"periodic\":false,\"tolerance\":1e-7},\"inputs\":{\"points\":{\"connections\":[{\"node\":\"e2e3d3aed9655ab6\",\"output\":\"list\",\"data\":{}}]}},\"position\":[1287.0687813345048,884.939567373176]},\"97cab9b66d410996\":{\"id\":\"97cab9b66d410996\",\"name\":\"bitbybit.vector.vectorXYZ\",\"customName\":\"vector xyz\",\"async\":false,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"x\":0,\"y\":0,\"z\":0},\"inputs\":{},\"position\":[424.1404203359041,394.04416440848064]},\"e2e3d3aed9655ab6\":{\"id\":\"e2e3d3aed9655ab6\",\"name\":\"bitbybit.lists.createList\",\"customName\":\"create list\",\"data\":{},\"inputs\":{\"listElements\":{\"connections\":[{\"node\":\"97cab9b66d410996\",\"output\":\"result\",\"data\":{}},{\"node\":\"4382c18392c59a98\",\"output\":\"result\",\"data\":{}},{\"node\":\"cf14d0a8051dabea\",\"output\":\"result\",\"data\":{}},{\"node\":\"745a0565f9beb72a\",\"output\":\"result\",\"data\":{}}]}},\"position\":[874.9262222684938,923.4840379184922]},\"4382c18392c59a98\":{\"id\":\"4382c18392c59a98\",\"name\":\"bitbybit.vector.vectorXYZ\",\"customName\":\"vector xyz\",\"async\":false,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"x\":2,\"y\":0.5,\"z\":3},\"inputs\":{},\"position\":[423.3145944258628,724.8011906965236]},\"cf14d0a8051dabea\":{\"id\":\"cf14d0a8051dabea\",\"name\":\"bitbybit.vector.vectorXYZ\",\"customName\":\"vector xyz\",\"async\":false,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"x\":1.1,\"y\":-0.5,\"z\":7},\"inputs\":{},\"position\":[422.44718765175037,1061.248952488166]},\"745a0565f9beb72a\":{\"id\":\"745a0565f9beb72a\",\"name\":\"bitbybit.vector.vectorXYZ\",\"customName\":\"vector xyz\",\"async\":false,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"x\":0,\"y\":0,\"z\":10},\"inputs\":{},\"position\":[422.8305905803102,1394.5807382128428]},\"de9b5212dc1c2b72\":{\"id\":\"de9b5212dc1c2b72\",\"name\":\"bitbybit.vector.vectorXYZ\",\"customName\":\"vector xyz\",\"async\":false,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"x\":1,\"y\":0,\"z\":0},\"inputs\":{},\"position\":[1287.765098594874,1388.7927624811502]},\"7988f97ff6647362\":{\"id\":\"7988f97ff6647362\",\"name\":\"bitbybit.occt.transforms.mirrorAlongNormal\",\"customName\":\"mirror along normal\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"origin\":[0,0,0],\"normal\":[0,0,1]},\"inputs\":{\"shape\":{\"connections\":[{\"node\":\"8faa0c5fb9823237\",\"output\":\"result\",\"data\":{}}]},\"normal\":{\"connections\":[{\"node\":\"de9b5212dc1c2b72\",\"output\":\"result\",\"data\":{}}]}},\"position\":[1731.6327597720638,1082.62186661138]},\"a0d1cd554f66bf6d\":{\"id\":\"a0d1cd554f66bf6d\",\"name\":\"bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire\",\"customName\":\"combine edges and wires into a wire\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false}},\"inputs\":{\"shapes\":{\"connections\":[{\"node\":\"2f9a1265ead7733c\",\"output\":\"list\",\"data\":{}}]}},\"position\":[2506.2324269417245,883.6264712168129]},\"2f9a1265ead7733c\":{\"id\":\"2f9a1265ead7733c\",\"name\":\"bitbybit.lists.createList\",\"customName\":\"create list\",\"data\":{},\"inputs\":{\"listElements\":{\"connections\":[{\"node\":\"8faa0c5fb9823237\",\"output\":\"result\",\"data\":{}},{\"node\":\"7988f97ff6647362\",\"output\":\"result\",\"data\":{}}]}},\"position\":[2130.2179761064363,924.030122309714]},\"ef3231701a568119\":{\"id\":\"ef3231701a568119\",\"name\":\"bitbybit.occt.shapes.face.createFaceFromWire\",\"customName\":\"face from wire\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"planar\":false},\"inputs\":{\"shape\":{\"connections\":[{\"node\":\"a0d1cd554f66bf6d\",\"output\":\"result\",\"data\":{}}]}},\"position\":[2883.5180269634725,884.2787678537645]},\"87dc506a4f7281a0\":{\"id\":\"87dc506a4f7281a0\",\"name\":\"bitbybit.occt.operations.makeThickSolidSimple\",\"customName\":\"make thick solid simple\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"offset\":0.1},\"inputs\":{\"shape\":{\"connections\":[{\"node\":\"ef3231701a568119\",\"output\":\"result\",\"data\":{}}]}},\"position\":[3249.36708265849,883.5998482581062]},\"e8b98529014f2c04\":{\"id\":\"e8b98529014f2c04\",\"name\":\"bitbybit.occt.transforms.rotate\",\"customName\":\"rotate\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"axis\":[0,0,1],\"angle\":0},\"inputs\":{\"shape\":{\"connections\":[{\"node\":\"87dc506a4f7281a0\",\"output\":\"result\",\"data\":{}}]},\"axis\":{\"connections\":[{\"node\":\"98e745a3a45c3a36\",\"output\":\"result\",\"data\":{}}]},\"angle\":{\"connections\":[{\"node\":\"7df432707a86eea8\",\"output\":\"result\",\"data\":{}}]}},\"position\":[3956.179691345161,1530.280959502406]},\"98e745a3a45c3a36\":{\"id\":\"98e745a3a45c3a36\",\"name\":\"bitbybit.vector.vectorXYZ\",\"customName\":\"vector xyz\",\"async\":false,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"x\":2,\"y\":2,\"z\":0},\"inputs\":{},\"position\":[3115.161410801174,1416.7869359779625]},\"3403bfdce4eb8b84\":{\"id\":\"3403bfdce4eb8b84\",\"name\":\"bitbybit.vector.span\",\"customName\":\"span\",\"async\":false,\"drawable\":false,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"step\":30,\"min\":0,\"max\":360},\"inputs\":{},\"position\":[3051.5172324998534,1747.8824123854959]},\"7df432707a86eea8\":{\"id\":\"7df432707a86eea8\",\"name\":\"bitbybit.lists.flatten\",\"customName\":\"flatten\",\"data\":{\"nrLevels\":1},\"inputs\":{\"list\":{\"connections\":[{\"node\":\"3403bfdce4eb8b84\",\"output\":\"result\",\"data\":{}}]}},\"position\":[3427.2646774866294,1781.382012022833]},\"15c360f697b19def\":{\"id\":\"15c360f697b19def\",\"name\":\"bitbybit.babylon.scene.drawDirectionalLight\",\"customName\":\"draw directional light\",\"async\":false,\"drawable\":false,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"direction\":[-100,-100,-100],\"intensity\":3,\"diffuse\":\"#ffffff\",\"specular\":\"#ffffff\",\"shadowGeneratorMapSize\":1024,\"enableShadows\":true,\"shadowDarkness\":0,\"shadowUsePercentageCloserFiltering\":true,\"shadowContactHardeningLightSizeUVRatio\":0.2,\"shadowBias\":0.0001,\"shadowNormalBias\":0.002,\"shadowMaxZ\":1000,\"shadowMinZ\":0},\"inputs\":{},\"position\":[2466.096861954312,2128.5288188674936]},\"f851cdb292b8669c\":{\"id\":\"f851cdb292b8669c\",\"name\":\"bitbybit.babylon.scene.enableSkybox\",\"customName\":\"enable skybox\",\"async\":false,\"drawable\":false,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"skybox\":\"city\",\"size\":1000,\"blur\":0.1,\"environmentIntensity\":0.7,\"hideSkybox\":true},\"inputs\":{},\"position\":[2016.1735647375663,2241.8369412610614]},\"bf2c2c89c14729af\":{\"id\":\"bf2c2c89c14729af\",\"name\":\"bitbybit.babylon.scene.twoColorLinearGradient\",\"customName\":\"two color linear gradient\",\"async\":false,\"drawable\":false,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"colorFrom\":\"#090a0b\",\"colorTo\":\"#a4f9ef\",\"direction\":\"to top\",\"stopFrom\":0,\"stopTo\":100},\"inputs\":{},\"position\":[1665.8642745313932,2241.0512080018066]},\"73cff4b3dac9ba74\":{\"id\":\"73cff4b3dac9ba74\",\"name\":\"bitbybit.occt.shapes.compound.makeCompound\",\"customName\":\"make compound\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":true,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false}},\"inputs\":{\"shapes\":{\"connections\":[{\"node\":\"3f7da96395d0cc0a\",\"output\":\"list\",\"data\":{}}]}},\"position\":[4723.317347193844,1529.5584313727202]},\"3f7da96395d0cc0a\":{\"id\":\"3f7da96395d0cc0a\",\"name\":\"bitbybit.lists.createList\",\"customName\":\"create list\",\"data\":{},\"inputs\":{\"listElements\":{\"connections\":[{\"node\":\"e8b98529014f2c04\",\"output\":\"result\",\"data\":{}}]}},\"position\":[4336.374658712047,1569.7875970111186]},\"82dc30294f5ac9bf\":{\"id\":\"82dc30294f5ac9bf\",\"name\":\"bitbybit.draw.drawAnyAsync\",\"customName\":\"draw any async\",\"async\":true,\"drawable\":true,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false}},\"inputs\":{\"entity\":{\"connections\":[{\"node\":\"73cff4b3dac9ba74\",\"output\":\"result\",\"data\":{}}]},\"options\":{\"connections\":[{\"node\":\"b23a7af9c08392c7\",\"output\":\"result\",\"data\":{}}]}},\"position\":[5349.600277496398,1822.4770208653674]},\"b23a7af9c08392c7\":{\"id\":\"b23a7af9c08392c7\",\"name\":\"bitbybit.draw.optionsOcctShapeMaterial\",\"customName\":\"options occt shape material\",\"async\":false,\"drawable\":false,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"precision\":0.01,\"drawEdges\":true,\"edgeColour\":\"#000000\",\"edgeWidth\":2},\"inputs\":{\"faceMaterial\":{\"connections\":[{\"node\":\"65dacf9cbbadd3c8\",\"output\":\"result\",\"data\":{}}]}},\"position\":[4845.401993283481,2112.9450605638203]},\"65dacf9cbbadd3c8\":{\"id\":\"65dacf9cbbadd3c8\",\"name\":\"bitbybit.babylon.material.pbrMetallicRoughness.create\",\"customName\":\"pbr metallic roughness\",\"async\":false,\"drawable\":false,\"data\":{\"genericNodeData\":{\"hide\":false,\"oneOnOne\":false,\"flatten\":0,\"forceExecution\":false},\"name\":\"Custom Material\",\"baseColor\":\"#14ffa5\",\"emissiveColor\":\"#000000\",\"metallic\":0.6,\"roughness\":0.6,\"alpha\":1,\"backFaceCulling\":false,\"zOffset\":2},\"inputs\":{},\"position\":[4481.373113348705,2151.144219076012]}}}","version":"0.20.13","type":"rete"}}
    title="Simple flower"
    />
</TabItem>
<TabItem value="blockly" label="Blockly">
  <BitByBitRenderCanvas
    requireManualStart={true}
    script={{"script":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"controlPoints\">controlPoints</variable><variable id=\"curve\">curve</variable><variable id=\"mirrorNormal\">mirrorNormal</variable><variable id=\"mirroredCurve\">mirroredCurve</variable><variable id=\"combinedWires\">combinedWires</variable><variable id=\"flowerFace\">flowerFace</variable><variable id=\"thickFlower\">thickFlower</variable><variable id=\"rotationAxis\">rotationAxis</variable><variable id=\"rotationAngles\">rotationAngles</variable><variable id=\"flowerPetals\">flowerPetals</variable><variable id=\"angle\">angle</variable><variable id=\"rotatedPetal\">rotatedPetal</variable><variable id=\"finalFlower\">finalFlower</variable></variables><block type=\"variables_set\" id=\"createControlPoints\" x=\"-173\" y=\"-152\"><field name=\"VAR\" id=\"controlPoints\">controlPoints</field><value name=\"VALUE\"><block type=\"lists_create_with\" id=\"controlPointsList\"><mutation items=\"4\"></mutation><value name=\"ADD0\"><block type=\"bitbybit.point.pointXYZ\" id=\"point1\"><value name=\"X\"><block type=\"math_number\" id=\"x1\"><field name=\"NUM\">0</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"y1\"><field name=\"NUM\">0</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"z1\"><field name=\"NUM\">0</field></block></value></block></value><value name=\"ADD1\"><block type=\"bitbybit.point.pointXYZ\" id=\"point2\"><value name=\"X\"><block type=\"math_number\" id=\"x2\"><field name=\"NUM\">2</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"y2\"><field name=\"NUM\">0.5</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"z2\"><field name=\"NUM\">3</field></block></value></block></value><value name=\"ADD2\"><block type=\"bitbybit.point.pointXYZ\" id=\"point3\"><value name=\"X\"><block type=\"math_number\" id=\"x3\"><field name=\"NUM\">1.1</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"y3\"><field name=\"NUM\">-0.5</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"z3\"><field name=\"NUM\">7</field></block></value></block></value><value name=\"ADD3\"><block type=\"bitbybit.point.pointXYZ\" id=\"point4\"><value name=\"X\"><block type=\"math_number\" id=\"x4\"><field name=\"NUM\">0</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"y4\"><field name=\"NUM\">0</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"z4\"><field name=\"NUM\">10</field></block></value></block></value></block></value><next><block type=\"variables_set\" id=\"createCurve\"><field name=\"VAR\" id=\"curve\">curve</field><value name=\"VALUE\"><block type=\"bitbybit.occt.shapes.wire.interpolatePoints\" id=\"interpolate\"><value name=\"Points\"><block type=\"variables_get\" id=\"getCurvePoints\"><field name=\"VAR\" id=\"controlPoints\">controlPoints</field></block></value><value name=\"Periodic\"><block type=\"logic_boolean\" id=\"periodicFalse\"><field name=\"BOOL\">FALSE</field></block></value><value name=\"Tolerance\"><block type=\"math_number\" id=\"tolerance\"><field name=\"NUM\">1e-7</field></block></value></block></value><next><block type=\"variables_set\" id=\"setMirrorNormal\"><field name=\"VAR\" id=\"mirrorNormal\">mirrorNormal</field><value name=\"VALUE\"><block type=\"bitbybit.vector.vectorXYZ\" id=\"normalVector\"><value name=\"X\"><block type=\"math_number\" id=\"normalX\"><field name=\"NUM\">1</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"normalY\"><field name=\"NUM\">0</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"normalZ\"><field name=\"NUM\">0</field></block></value></block></value><next><block type=\"variables_set\" id=\"mirrorCurve\"><field name=\"VAR\" id=\"mirroredCurve\">mirroredCurve</field><value name=\"VALUE\"><block type=\"bitbybit.occt.transforms.mirrorAlongNormal\" id=\"mirror\"><value name=\"Shape\"><block type=\"variables_get\" id=\"getCurve\"><field name=\"VAR\" id=\"curve\">curve</field></block></value><value name=\"Origin\"><block type=\"bitbybit.point.pointXYZ\" id=\"mirrorOrigin\"><value name=\"X\"><block type=\"math_number\" id=\"originX\"><field name=\"NUM\">0</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"originY\"><field name=\"NUM\">0</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"originZ\"><field name=\"NUM\">0</field></block></value></block></value><value name=\"Normal\"><block type=\"variables_get\" id=\"getMirrorNormal\"><field name=\"VAR\" id=\"mirrorNormal\">mirrorNormal</field></block></value></block></value><next><block type=\"variables_set\" id=\"combineWires\"><field name=\"VAR\" id=\"combinedWires\">combinedWires</field><value name=\"VALUE\"><block type=\"bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire\" id=\"combine\"><value name=\"Shapes\"><block type=\"lists_create_with\" id=\"wiresList\"><mutation items=\"2\"></mutation><value name=\"ADD0\"><block type=\"variables_get\" id=\"getOriginalCurve\"><field name=\"VAR\" id=\"curve\">curve</field></block></value><value name=\"ADD1\"><block type=\"variables_get\" id=\"getMirroredCurve\"><field name=\"VAR\" id=\"mirroredCurve\">mirroredCurve</field></block></value></block></value></block></value><next><block type=\"variables_set\" id=\"createFace\"><field name=\"VAR\" id=\"flowerFace\">flowerFace</field><value name=\"VALUE\"><block type=\"bitbybit.occt.shapes.face.createFaceFromWire\" id=\"faceFromWire\"><value name=\"Shape\"><block type=\"variables_get\" id=\"getCombinedWires\"><field name=\"VAR\" id=\"combinedWires\">combinedWires</field></block></value><value name=\"Planar\"><block type=\"logic_boolean\" id=\"planarFalse\"><field name=\"BOOL\">FALSE</field></block></value></block></value><next><block type=\"variables_set\" id=\"makeThick\"><field name=\"VAR\" id=\"thickFlower\">thickFlower</field><value name=\"VALUE\"><block type=\"bitbybit.occt.operations.makeThickSolidSimple\" id=\"thickSolid\"><value name=\"Shape\"><block type=\"variables_get\" id=\"getFlowerFace\"><field name=\"VAR\" id=\"flowerFace\">flowerFace</field></block></value><value name=\"Offset\"><block type=\"math_number\" id=\"thickness\"><field name=\"NUM\">0.1</field></block></value></block></value><next><block type=\"variables_set\" id=\"setRotationAxis\"><field name=\"VAR\" id=\"rotationAxis\">rotationAxis</field><value name=\"VALUE\"><block type=\"bitbybit.vector.vectorXYZ\" id=\"rotAxis\"><value name=\"X\"><block type=\"math_number\" id=\"axisX\"><field name=\"NUM\">2</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"axisY\"><field name=\"NUM\">2</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"axisZ\"><field name=\"NUM\">0</field></block></value></block></value><next><block type=\"variables_set\" id=\"setRotationAngles\"><field name=\"VAR\" id=\"rotationAngles\">rotationAngles</field><value name=\"VALUE\"><block type=\"bitbybit.vector.span\" id=\"angleSpan\"><value name=\"Step\"><block type=\"math_number\" id=\"angleStep\"><field name=\"NUM\">30</field></block></value><value name=\"Min\"><block type=\"math_number\" id=\"angleMin\"><field name=\"NUM\">0</field></block></value><value name=\"Max\"><block type=\"math_number\" id=\"angleMax\"><field name=\"NUM\">360</field></block></value></block></value><next><block type=\"variables_set\" id=\"initPetalsList\"><field name=\"VAR\" id=\"flowerPetals\">flowerPetals</field><value name=\"VALUE\"><block type=\"lists_create_with\" id=\"emptyPetalsList\"><mutation items=\"0\"></mutation></block></value><next><block type=\"controls_for\" id=\"rotateLoop\"><field name=\"VAR\" id=\"angle\">angle</field><value name=\"FROM\"><block type=\"math_number\" id=\"loopStart\"><field name=\"NUM\">1</field></block></value><value name=\"TO\"><block type=\"lists_length\" id=\"angleListLength\"><value name=\"VALUE\"><block type=\"variables_get\" id=\"getRotationAngles\"><field name=\"VAR\" id=\"rotationAngles\">rotationAngles</field></block></value></block></value><value name=\"BY\"><block type=\"math_number\" id=\"loopStep\"><field name=\"NUM\">1</field></block></value><statement name=\"DO\"><block type=\"variables_set\" id=\"rotatePetal\"><field name=\"VAR\" id=\"rotatedPetal\">rotatedPetal</field><value name=\"VALUE\"><block type=\"bitbybit.occt.transforms.rotate\" id=\"rotate\"><value name=\"Shape\"><block type=\"variables_get\" id=\"getThickFlower\"><field name=\"VAR\" id=\"thickFlower\">thickFlower</field></block></value><value name=\"Axis\"><block type=\"variables_get\" id=\"getRotationAxis\"><field name=\"VAR\" id=\"rotationAxis\">rotationAxis</field></block></value><value name=\"Angle\"><block type=\"lists_getIndex\" id=\"getCurrentAngle\"><mutation statement=\"false\" at=\"true\"></mutation><field name=\"MODE\">GET</field><field name=\"WHERE\">FROM_START</field><value name=\"VALUE\"><block type=\"variables_get\" id=\"getAnglesList\"><field name=\"VAR\" id=\"rotationAngles\">rotationAngles</field></block></value><value name=\"AT\"><block type=\"variables_get\" id=\"getCurrentAngleIndex\"><field name=\"VAR\" id=\"angle\">angle</field></block></value></block></value></block></value><next><block type=\"lists_setIndex\" id=\"addPetal\"><mutation at=\"false\"></mutation><field name=\"MODE\">INSERT</field><field name=\"WHERE\">LAST</field><value name=\"LIST\"><block type=\"variables_get\" id=\"getPetalsList\"><field name=\"VAR\" id=\"flowerPetals\">flowerPetals</field></block></value><value name=\"TO\"><block type=\"variables_get\" id=\"getRotatedPetal\"><field name=\"VAR\" id=\"rotatedPetal\">rotatedPetal</field></block></value></block></next></block></statement><next><block type=\"variables_set\" id=\"makeCompound\"><field name=\"VAR\" id=\"finalFlower\">finalFlower</field><value name=\"VALUE\"><block type=\"bitbybit.occt.shapes.compound.makeCompound\" id=\"compound\"><value name=\"Shapes\"><block type=\"variables_get\" id=\"getAllPetals\"><field name=\"VAR\" id=\"flowerPetals\">flowerPetals</field></block></value></block></value><next><block type=\"bitbybit.draw.drawAnyAsyncNoReturn\" id=\"drawFlower\"><value name=\"Entity\"><block type=\"variables_get\" id=\"getFinalFlower\"><field name=\"VAR\" id=\"finalFlower\">finalFlower</field></block></value><value name=\"Options\"><block type=\"bitbybit.draw.optionsOcctShapeMaterial\" id=\"FQFOM=lg8:LwCz^e|9TA\"><value name=\"Precision\"><block type=\"math_number\" id=\"2*`aNh4TIPLb2W$%#09)\"><field name=\"NUM\">0.01</field></block></value><value name=\"FaceMaterial\"><block type=\"bitbybit.babylon.material.pbrMetallicRoughness.create\" id=\"zs=8irzAsv?DQ300wiAZ\"><value name=\"Name\"><block type=\"text\" id=\"gs/$U5n!3W1`wg2j_(q-\"><field name=\"TEXT\">Custom Material</field></block></value><value name=\"BaseColor\"><block type=\"text\" id=\"G39CN5gCy6(GRuv=ugof\"><field name=\"TEXT\">#14ffa5</field></block></value><value name=\"EmissiveColor\"><block type=\"colour_picker\" id=\"ZaxMgGO-^B9}kiq{st!8\"><field name=\"COLOUR\">#000000</field></block></value><value name=\"Metallic\"><block type=\"math_number\" id=\"kLa]e~(_cW,/s;nK.+{i\"><field name=\"NUM\">0.6</field></block></value><value name=\"Roughness\"><block type=\"math_number\" id=\"TGUq1(W]`a-qD/Zk4WdL\"><field name=\"NUM\">0.5</field></block></value><value name=\"Alpha\"><block type=\"math_number\" id=\"qhxq_w_Oj+]^?U8p:p87\"><field name=\"NUM\">1</field></block></value><value name=\"BackFaceCulling\"><block type=\"logic_boolean\" id=\"OB9w`U+Qg_9N]jdoCTP]\"><field name=\"BOOL\">FALSE</field></block></value><value name=\"ZOffset\"><block type=\"math_number\" id=\"fiVnhkh$/y[jBwM@xe@p\"><field name=\"NUM\">2</field></block></value></block></value><value name=\"DrawEdges\"><block type=\"logic_boolean\" id=\"y~F_(b)-94cD{yb8~Z8u\"><field name=\"BOOL\">TRUE</field></block></value><value name=\"EdgeColour\"><block type=\"colour_picker\" id=\"cX84kyqlZ396~C0`56q$\"><field name=\"COLOUR\">#000000</field></block></value><value name=\"EdgeWidth\"><block type=\"math_number\" id=\"_gS~Wp;1`^MK4h?WiuuD\"><field name=\"NUM\">2</field></block></value></block></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block><block type=\"bitbybit.babylon.scene.drawDirectionalLightNoReturn\" id=\"oj{k8C)9b^iF3-sX6$_g\" x=\"1011\" y=\"1035\"><value name=\"Direction\"><block type=\"bitbybit.vector.vectorXYZ\" id=\"5N_}aQP^Mf_O6[fZ0(?U\"><value name=\"X\"><block type=\"math_number\" id=\"%n8o(aWAh!*gT9Ji@jDh\"><field name=\"NUM\">-100</field></block></value><value name=\"Y\"><block type=\"math_number\" id=\"*1dEV4JIh2-fQ.Z.VW7.\"><field name=\"NUM\">-100</field></block></value><value name=\"Z\"><block type=\"math_number\" id=\"5#WVv;@l,E{xSEz6w=cR\"><field name=\"NUM\">-100</field></block></value></block></value><value name=\"Intensity\"><block type=\"math_number\" id=\"_H+v|~8SvM}A2t3cqtEW\"><field name=\"NUM\">3</field></block></value><value name=\"Diffuse\"><block type=\"colour_picker\" id=\"TK`2JGy5`xrlP!U0sbUW\"><field name=\"COLOUR\">#ffffff</field></block></value><value name=\"Specular\"><block type=\"colour_picker\" id=\"F)UIL_zgO!A#sc)MbYsl\"><field name=\"COLOUR\">#ffffff</field></block></value><value name=\"ShadowGeneratorMapSize\"><block type=\"math_number\" id=\"{h-R4IL=Ox|I!l;.jb#p\"><field name=\"NUM\">1024</field></block></value><value name=\"EnableShadows\"><block type=\"logic_boolean\" id=\"$s2MAm=}T~;+]6=S+=o,\"><field name=\"BOOL\">TRUE</field></block></value><value name=\"ShadowDarkness\"><block type=\"math_number\" id=\"LkEdx4uf-ObRroDtc%ZA\"><field name=\"NUM\">0</field></block></value><value name=\"ShadowUsePercentageCloserFiltering\"><block type=\"logic_boolean\" id=\"e[0mA0|`90VnaH/(cmY{\"><field name=\"BOOL\">TRUE</field></block></value><value name=\"ShadowContactHardeningLightSizeUVRatio\"><block type=\"math_number\" id=\"h~95zx?MWg9mhLm?M@yD\"><field name=\"NUM\">0.2</field></block></value><value name=\"ShadowBias\"><block type=\"math_number\" id=\"E/X.Wr:Y0~y^t2*H?0y!\"><field name=\"NUM\">0.0001</field></block></value><value name=\"ShadowNormalBias\"><block type=\"math_number\" id=\"#VDBZ#8AU44#qv485JZS\"><field name=\"NUM\">0.002</field></block></value><value name=\"ShadowMaxZ\"><block type=\"math_number\" id=\"pZX[Rf7?AtR(?~q,:8OJ\"><field name=\"NUM\">1000</field></block></value><value name=\"ShadowMinZ\"><block type=\"math_number\" id=\"|yBIH9WjOTz/XuWW~]/o\"><field name=\"NUM\">0</field></block></value></block><block type=\"bitbybit.babylon.scene.twoColorLinearGradient\" id=\"L3|(zR3M}DM(;XTElCVy\" x=\"697\" y=\"1300\"><value name=\"ColorFrom\"><block type=\"text\" id=\"1%Zwy%OCBaVlLy/55st=\"><field name=\"TEXT\">#090a0b</field></block></value><value name=\"ColorTo\"><block type=\"text\" id=\",-d)S%oxpjm5Nw:!-9*g\"><field name=\"TEXT\">#a4f9ef</field></block></value><value name=\"Direction\"><block type=\"bitbybit.babylon.enums.gradientDirectionEnum\" id=\"C!VafmG7h4J=.7Vz!y}6\"><field name=\"bitbybit.babylon.enums.gradientDirectionEnum\">'to top'</field></block></value><value name=\"StopFrom\"><block type=\"math_number\" id=\"-+m=F2ktlQC(*xW}{8V7\"><field name=\"NUM\">0</field></block></value><value name=\"StopTo\"><block type=\"math_number\" id=\"(C],9FC3pljl4fSawh?5\"><field name=\"NUM\">100</field></block></value></block></xml>","version":"0.20.13","type":"blockly"}}
    title="Simple flower"
    />
  </TabItem>
<TabItem value="typescript" label="TypeScript">
<BitByBitRenderCanvas
    requireManualStart={true}
    script={{"script":"// Import required DTOs for creating curves, shapes, and operations\nconst { InterpolationDto, MirrorAlongNormalDto, ShapesDto, CompoundShapesDto,\n    FaceFromWireDto, ThisckSolidSimpleDto, RotateDto } = Bit.Inputs.OCCT;\nconst { SceneTwoColorLinearGradientDto, DirectionalLightDto } = Bit.Inputs.BabylonScene;\nconst { gradientDirectionEnum } = Bit.Inputs.Base;\n\n// Import type definitions for type safety\ntype Point3 = Bit.Inputs.Base.Point3;\ntype Vector3 = Bit.Inputs.Base.Vector3;\ntype TopoDSWirePointer = Bit.Inputs.OCCT.TopoDSWirePointer;\ntype TopoDSFacePointer = Bit.Inputs.OCCT.TopoDSFacePointer;\ntype TopoDSShapePointer = Bit.Inputs.OCCT.TopoDSShapePointer;\n\n// Get access to OCCT modules and utility functions\nconst { wire, face, compound } = bitbybit.occt.shapes;\nconst { operations, transforms } = bitbybit.occt;\nconst { vector } = bitbybit;\nconst { scene } = bitbybit.babylon;\nconst { pbrMetallicRoughness } = bitbybit.babylon.material;\n\n\nconst createEnvironment = async () => {\n    const backgroundOpt = new SceneTwoColorLinearGradientDto();\n    backgroundOpt.colorFrom = \"#090a0b\";\n    backgroundOpt.colorTo = \"#a4f9ef\";\n    backgroundOpt.direction = gradientDirectionEnum.toTop;\n    scene.twoColorLinearGradient(backgroundOpt);\n\n    const dirLightOpt = new DirectionalLightDto();\n    dirLightOpt.intensity = 3;\n    scene.drawDirectionalLight(dirLightOpt);\n}\n\n// Define the main function to create a parametric flower\nconst start = async () => {\n    createEnvironment();\n    // Flower parameters - easily adjustable for different designs\n    const thickness = 0.1;          // Thickness of the flower petals\n    const rotationStep = 30;         // Degrees between each petal (12 petals total)\n    const rotationAxis: Vector3 = [2, 2, 0];  // Axis for petal rotation\n\n    // Define control points for the flower petal curve\n    const controlPoints: Point3[] = [\n        [0, 0, 0],      // Start point (flower center)\n        [2, 0.5, 3],    // First control point (petal width)\n        [1.1, -0.5, 7], // Second control point (petal curve)\n        [0, 0, 10]      // End point (petal tip)\n    ];\n\n    // Create interpolated curve through control points\n    const curveOptions = new InterpolationDto();\n    curveOptions.points = controlPoints;\n    curveOptions.periodic = false;\n    curveOptions.tolerance = 1e-7;\n    const petalCurve = await wire.interpolatePoints(curveOptions);\n\n    // Mirror the curve to create symmetry for the petal\n    const mirrorOptions = new MirrorAlongNormalDto<TopoDSWirePointer>();\n    mirrorOptions.shape = petalCurve;\n    mirrorOptions.origin = [0, 0, 0];\n    mirrorOptions.normal = [1, 0, 0];  // Mirror along X-axis\n    const mirroredCurve = await transforms.mirrorAlongNormal(mirrorOptions);\n\n    // Combine the original and mirrored curves into a single wire\n    const combineOptions = new ShapesDto<TopoDSWirePointer>();\n    combineOptions.shapes = [petalCurve, mirroredCurve];\n    const combinedWire = await wire.combineEdgesAndWiresIntoAWire(combineOptions);\n\n    // Create a face from the combined wire\n    const faceOptions = new FaceFromWireDto<TopoDSWirePointer>();\n    faceOptions.shape = combinedWire;\n    faceOptions.planar = false;  // Allow non-planar surface\n    const petalFace = await face.createFaceFromWire(faceOptions);\n\n    // Create a thick solid from the face\n    const thickOptions = new ThisckSolidSimpleDto<TopoDSFacePointer>();\n    thickOptions.shape = petalFace;\n    thickOptions.offset = thickness;\n    const thickPetal = await operations.makeThickSolidSimple(thickOptions);\n\n    // Generate rotation angles for petals (0° to 360° in steps)\n    const rotationAngles = vector.span({\n        min: 0,\n        max: 360,\n        step: rotationStep\n    });\n\n    // Create all flower petals by rotating the base petal\n    const flowerPetalPromises: Promise<TopoDSShapePointer>[] = [];\n    for (const angle of rotationAngles) {\n        const rotateOptions = new RotateDto<TopoDSShapePointer>();\n        rotateOptions.shape = thickPetal;\n        rotateOptions.axis = rotationAxis;\n        rotateOptions.angle = angle;\n\n        const rotatedPetal = transforms.rotate(rotateOptions);\n        flowerPetalPromises.push(rotatedPetal);\n    }\n\n    const flowerPetals = await Promise.all(flowerPetalPromises);\n\n    // Combine all petals into a single compound shape\n    const compoundOptions = new CompoundShapesDto<TopoDSShapePointer>();\n    compoundOptions.shapes = flowerPetals;\n    const flower = await compound.makeCompound(compoundOptions);\n\n    const pbrOptions = new Bit.Inputs.BabylonMaterial.PBRMetallicRoughnessDto();\n    pbrOptions.baseColor = \"#14ffa5\";\n    pbrOptions.metallic = 0.6;\n    pbrOptions.roughness = 0.6;\n    pbrOptions.zOffset = 2;\n    const pbrMaterial = pbrMetallicRoughness.create(pbrOptions);\n\n    const drawOpt = new Bit.Inputs.Draw.DrawOcctShapeMaterialOptions();\n    drawOpt.faceMaterial = pbrMaterial;\n    drawOpt.edgeColour = \"#000000\";\n\n    // Draw the completed flower with material options\n    bitbybit.draw.drawAnyAsync({\n        entity: flower,\n        options: drawOpt\n    });\n}\n\n// Execute the flower creation function\nstart();","version":"0.20.13","type":"typescript"}}
    title="Simple flower"
    />
</TabItem>
</Tabs>

## Code Explanation

The flower creation process follows a systematic approach that demonstrates several important geometric modeling concepts:

### **Petal Shape Definition**
The flower begins with four carefully chosen control points that define the basic petal profile:
- Start point `[0, 0, 0]` at the flower center
- Intermediate points `[2, 0.5, 3]` and `[1.1, -0.5, 7]` that control petal width and curvature  
- End point `[0, 0, 10]` at the petal tip

These points are connected using `interpolatePoints`, which creates a smooth B-spline curve through the control points. The `periodic: false` setting ensures the curve doesn't loop back on itself, while the small tolerance value `1e-7` ensures high precision in the curve calculation.

### **Symmetry Through Mirroring**
To create a realistic petal shape, the curve is mirrored along the X-axis using `mirrorAlongNormal`. This creates a symmetrical petal with both sides having identical but opposite curvature. The mirroring operation is fundamental in creating balanced, natural-looking organic forms.

### **Wire Combination and Solid Creation**
The original and mirrored curves are combined using `combineEdgesAndWiresIntoAWire` to form a closed profile. This closed wire is then converted to a face using `createFaceFromWire`, and finally given thickness using `makeThickSolidSimple` with a 0.1 unit offset.

### **Rotational Pattern Generation**
The complete flower emerges through rotational multiplication. The `vector.span` function generates 12 evenly spaced angles from 0° to 360° in 30° increments. Each petal is rotated around the axis `[2, 2, 0]`, which creates a slight tilt that adds visual interest to the final form.

### **Implementation Differences**

**Rete Version**: Uses visual node connections and automatic list flattening to handle the rotation angles. The visual interface makes it easy to see data flow and adjust parameters through node properties.

**Blockly Version**: Employs standard programming loops since `flatten` operations aren't available. Variables and list management follow traditional programming patterns, making it accessible to users familiar with block-based coding.

**TypeScript Version**: Provides full type safety with proper DTO usage and async/await patterns. This version is most suitable for production environments and offers the best development experience with IntelliSense and error checking.

## Advanced Interactive Enhancement

The example below demonstrates how to extend static geometric models with dynamic visual effects. By combining the flower geometry with a sophisticated particle system, we create an immersive interactive experience where thousands of particles emit from the flower surface and respond to mouse movement with realistic physics.

This advanced implementation showcases several cutting-edge techniques:

### **Surface-Based Particle Emission**
Rather than emitting particles from simple points or volumes, this system calculates the surface area of each triangle in the flower mesh and distributes particles proportionally. This creates a natural, organic emission pattern that follows the flower's complex geometry perfectly.

### **Custom Physics Simulation**  
The particle system implements realistic physics including:
- **Gravity Effects**: Particles fall naturally with customizable gravitational pull
- **Drag Forces**: Air resistance slows particles over time for realistic motion
- **Mouse Repulsion**: Interactive forces push particles away from cursor position
- **Drift Behavior**: Some particles follow random drift patterns for organic movement

### **Multi-Layered Visual Design**
The flower uses multiple overlapping layers rotated at different angles to create depth and visual richness. Combined with translucent materials and additive blending, this produces an ethereal, luminous effect.

### **Performance Optimization**
Despite managing up to 25,000 particles simultaneously, the system maintains smooth performance through efficient update functions and memory management techniques.

**Move your mouse over the flower to interact with the particle field:**

<Tabs groupId="simple-flower-live-example-particles">
<TabItem value="typescript" label="TypeScript">
<BitByBitRenderCanvas
    requireManualStart={true}
    script={{"script":"// Import required DTOs for creating curves, shapes, and operations\nconst { InterpolationDto, MirrorAlongNormalDto, ShapesDto, CompoundShapesDto,\n    FaceFromWireDto, ThisckSolidSimpleDto, RotateDto } = Bit.Inputs.OCCT;\nconst { SceneTwoColorLinearGradientDto, DirectionalLightDto } = Bit.Inputs.BabylonScene;\nconst { gradientDirectionEnum } = Bit.Inputs.Base;\n\n// Import type definitions for type safety\ntype Point3 = Bit.Inputs.Base.Point3;\ntype Vector3 = Bit.Inputs.Base.Vector3;\ntype TopoDSWirePointer = Bit.Inputs.OCCT.TopoDSWirePointer;\ntype TopoDSFacePointer = Bit.Inputs.OCCT.TopoDSFacePointer;\ntype TopoDSShapePointer = Bit.Inputs.OCCT.TopoDSShapePointer;\n\ninterface Particle extends BABYLON.Particle {\n    isLarge: boolean,\n    isDrifter: boolean,\n    driftDirection: BABYLON.Vector3\n}\n\n// Get access to OCCT modules and utility functions\nconst { wire, face, compound } = bitbybit.occt.shapes;\nconst { operations, transforms } = bitbybit.occt;\nconst { vector } = bitbybit;\nconst { scene } = bitbybit.babylon;\nconst { pbrMetallicRoughness } = bitbybit.babylon.material;\n\n\nconst createEnvironment = async () => {\n    const dirLightOpt = new DirectionalLightDto();\n    dirLightOpt.intensity = 3;\n    scene.drawDirectionalLight(dirLightOpt);\n}\n\n// Define the main function to create a parametric flower\nconst start = async () => {\n    createEnvironment();\n    // Flower parameters - easily adjustable for different designs\n    const thickness = 0.1;          // Thickness of the flower petals\n    const rotationStep = 60;         // Degrees between each petal (12 petals total)\n    const rotationAxis: Vector3 = [2, 2, 0];  // Axis for petal rotation\n\n    // Define control points for the flower petal curve\n    const controlPoints: Point3[] = [\n        [0, 0, 0],      // Start point (flower center)\n        [5, 1.25, 7.5],    // First control point (petal width)\n        [2.75, -1.25, 17.5], // Second control point (petal curve)\n        [0, 0, 25]      // End point (petal tip)\n    ];\n\n    // Create interpolated curve through control points\n    const curveOptions = new InterpolationDto();\n    curveOptions.points = controlPoints;\n    curveOptions.periodic = false;\n    curveOptions.tolerance = 1e-7;\n    const petalCurve = await wire.interpolatePoints(curveOptions);\n\n    // Mirror the curve to create symmetry for the petal\n    const mirrorOptions = new MirrorAlongNormalDto<TopoDSWirePointer>();\n    mirrorOptions.shape = petalCurve;\n    mirrorOptions.origin = [0, 0, 0];\n    mirrorOptions.normal = [1, 0, 0];  // Mirror along X-axis\n    const mirroredCurve = await transforms.mirrorAlongNormal(mirrorOptions);\n\n    // Combine the original and mirrored curves into a single wire\n    const combineOptions = new ShapesDto<TopoDSWirePointer>();\n    combineOptions.shapes = [petalCurve, mirroredCurve];\n    const combinedWire = await wire.combineEdgesAndWiresIntoAWire(combineOptions);\n\n    // Create a face from the combined wire\n    const faceOptions = new FaceFromWireDto<TopoDSWirePointer>();\n    faceOptions.shape = combinedWire;\n    faceOptions.planar = false;  // Allow non-planar surface\n    const petalFace = await face.createFaceFromWire(faceOptions);\n\n    // Create a thick solid from the face\n    const thickOptions = new ThisckSolidSimpleDto<TopoDSFacePointer>();\n    thickOptions.shape = petalFace;\n    thickOptions.offset = thickness;\n    const thickPetal = await operations.makeThickSolidSimple(thickOptions);\n\n    // Generate rotation angles for petals (0° to 360° in steps)\n    const rotationAngles = vector.span({\n        min: 0,\n        max: 360,\n        step: rotationStep\n    });\n\n    const rotationAngles2 = vector.span({\n        min: 30,\n        max: 360,\n        step: rotationStep\n    });\n\n    // Create all flower petals by rotating the base petal\n    const flowerPetalPromises: Promise<TopoDSShapePointer>[] = [];\n    const flowerPetalPromises2: Promise<TopoDSShapePointer>[] = [];\n\n    for (const angle of rotationAngles) {\n        const rotateOptions = new RotateDto<TopoDSShapePointer>();\n        rotateOptions.shape = thickPetal;\n        rotateOptions.axis = rotationAxis;\n        rotateOptions.angle = angle;\n\n        const rotatedPetal = transforms.rotate(rotateOptions);\n        flowerPetalPromises.push(rotatedPetal);\n    }\n\n    for (const angle of rotationAngles2) {\n        const rotateOptions = new RotateDto<TopoDSShapePointer>();\n        rotateOptions.shape = thickPetal;\n        rotateOptions.axis = rotationAxis;\n        rotateOptions.angle = angle;\n\n        const rotatedPetal = transforms.rotate(rotateOptions);\n        flowerPetalPromises2.push(rotatedPetal);\n    }\n\n    const flowerPetals = await Promise.all(flowerPetalPromises);\n    const flowerPetals2 = await Promise.all(flowerPetalPromises2);\n\n    // Combine all petals into a single compound shape\n    const compoundOptions = new CompoundShapesDto<TopoDSShapePointer>();\n    compoundOptions.shapes = flowerPetals;\n    const flower = await compound.makeCompound(compoundOptions);\n    compoundOptions.shapes = flowerPetals2;\n    const flower2 = await compound.makeCompound(compoundOptions);\n\n    const pbrOptions = new Bit.Inputs.BabylonMaterial.PBRMetallicRoughnessDto();\n    pbrOptions.baseColor = \"#111111\";\n    pbrOptions.metallic = 0.6;\n    pbrOptions.roughness = 0.6;\n    pbrOptions.alpha = 0.4;\n    pbrOptions.zOffset = 2;\n    const pbrMaterial = pbrMetallicRoughness.create(pbrOptions);\n\n    const drawOpt = new Bit.Inputs.Draw.DrawOcctShapeMaterialOptions();\n    drawOpt.faceMaterial = pbrMaterial;\n    drawOpt.edgeColour = \"#ffffff\";\n    drawOpt.drawEdges = true;\n    drawOpt.precision = 0.1;\n\n    // Draw the completed flower with material options\n    const flowerMesh = await bitbybit.draw.drawAnyAsync({\n        entity: flower,\n        options: drawOpt\n    });\n\n    const flowerMesh2 = await bitbybit.draw.drawAnyAsync({\n        entity: flower2,\n        options: drawOpt\n    });\n\n    const emitterMesh = flowerMesh.getChildMeshes()[0] as BABYLON.Mesh;\n    emitterMesh.isPickable = false;\n\n    const emitterMesh2 = flowerMesh2.getChildMeshes()[0] as BABYLON.Mesh;\n    emitterMesh2.isPickable = false;\n\n    const scene = bitbybit.babylon.scene.getScene();\n\n    const purpleStartColor = new BABYLON.Color4(0.7, 0.3, 1.0, 1.0);\n    const purpleMidColor = new BABYLON.Color4(1.0, 0.4, 0.8, 1.0);\n\n    const blueStartColor = new BABYLON.Color4(0.2, 0.7, 1.0, 1.0);\n    const blueMidColor = new BABYLON.Color4(0.5, 0.8, 1.0, 1.0);\n\n    // This object will be shared with both particle systems to track the mouse.\n    const mouseTracker = { position: null as BABYLON.Vector3 | null };\n\n    // Create all the 3D assets: emitters, particle systems, and the interaction plane.\n\n    // Remove any old observable before adding a new one.\n    if (scene.metadata && scene.metadata.observable) {\n        scene.metadata.observable.remove();\n    }\n\n    // Centralized mouse interaction logic.\n    const resObs = scene.onPointerObservable.add((pointerInfo) => {\n        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {\n            // We only check for hits against our single, invisible interaction plane.\n            const pickInfo = scene.pick(scene.pointerX, scene.pointerY, (mesh) => mesh === emitterMesh);\n            if (pickInfo.hit) {\n                // If we hit the plane, update the shared tracker object's position.\n                mouseTracker.position = pickInfo.pickedPoint;\n            } else {\n                // If the mouse is not over the plane, clear the position.\n                mouseTracker.position = null;\n            }\n        }\n    });\n\n    if (scene.metadata) {\n        scene.metadata.observable = resObs;\n    } else {\n        scene.metadata = { observable: resObs };\n    }\n\n    createParticleSystemForMesh(emitterMesh, scene, purpleStartColor, purpleMidColor, mouseTracker);\n    createParticleSystemForMesh(emitterMesh2, scene, blueStartColor, blueMidColor, mouseTracker);\n\n}\n\n// Execute the flower creation function\nstart();\n\n\n// The core particle system definition.\nfunction createParticleSystemForMesh(\n    emitterMesh: BABYLON.Mesh,\n    scene: BABYLON.Scene,\n    animStartColor: BABYLON.Color4,\n    animMidColor: BABYLON.Color4,\n    mouseTracker: { position: BABYLON.Vector3 | null }\n): BABYLON.ParticleSystem {\n\n    const animEndColor = new BABYLON.Color4(0.1, 0.2, 0.8, 0.0);\n    const DRIFTER_CHANCE = 0.07;\n    const DRIFTER_SPEED = 0.4;\n\n    const particleSystem = new BABYLON.ParticleSystem(\"particles_\" + emitterMesh.name, 25000, scene);\n    particleSystem.particleTexture = new BABYLON.Texture(\"https://assets.babylonjs.com/textures/flare.png\", scene);\n    particleSystem.emitter = emitterMesh;\n    particleSystem.particleEmitterType = createUniformMeshParticleEmitter(emitterMesh);\n\n    particleSystem.color1 = animEndColor.clone();\n    particleSystem.color2 = animEndColor.clone();\n    particleSystem.colorDead = animEndColor.clone();\n    particleSystem.minSize = 0;\n    particleSystem.maxSize = 0;\n    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;\n    particleSystem.minLifeTime = 4.0;\n    particleSystem.maxLifeTime = 8.0;\n    particleSystem.emitRate = 2000;\n    particleSystem.minEmitPower = 0.1;\n    particleSystem.maxEmitPower = 0.5;\n    particleSystem.gravity = new BABYLON.Vector3(0, -1.0, 0);\n    (particleSystem as any).dragFactor = 0.97;\n\n    particleSystem.updateFunction = function (particles) {\n        const repulsionRadius = 20.0, repulsionStrength = 30;\n        const scaledUpdateSpeed = this._scaledUpdateSpeed;\n        const mousePickPosition = mouseTracker.position;\n        const regularStartSize = 0.35, regularEndSize = 0.1;\n        const largeStartSize = 0.8, largeEndSize = 0.2;\n\n        for (let index = 0; index < particles.length; index++) {\n            const particle = particles[index] as Particle;\n            particle.age += scaledUpdateSpeed;\n            if (particle.age >= particle.lifeTime) {\n                particles.splice(index, 1); this._stockParticles.push(particle); index--; continue;\n            }\n\n            if (particle.age === scaledUpdateSpeed) {\n                particle.isLarge = (Math.random() < 0.05);\n                particle.isDrifter = (Math.random() < DRIFTER_CHANCE);\n                if (particle.isDrifter) {\n                    const driftVector = new BABYLON.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n                    particle.driftDirection = driftVector.normalize();\n                }\n            }\n\n            particle.direction.scaleInPlace(this.dragFactor);\n            if (particle.isDrifter) {\n                const driftForce = particle.driftDirection.scale(DRIFTER_SPEED * scaledUpdateSpeed);\n                particle.direction.addInPlace(driftForce);\n            } else {\n                particle.direction.addInPlace(this.gravity.scale(scaledUpdateSpeed));\n            }\n\n            if (mousePickPosition) {\n                const distance = BABYLON.Vector3.Distance(particle.position, mousePickPosition);\n                if (distance < repulsionRadius) {\n                    const forceDirection = particle.position.subtract(mousePickPosition).normalize();\n                    const forceMagnitude = repulsionStrength * (1 - distance / repulsionRadius);\n                    const forceVector = forceDirection.scale(forceMagnitude * scaledUpdateSpeed);\n                    particle.direction.addInPlace(forceVector);\n                }\n            }\n\n            particle.position.addInPlace(particle.direction.scale(scaledUpdateSpeed));\n\n            const startSize = particle.isLarge ? largeStartSize : regularStartSize;\n            const endSize = particle.isLarge ? largeEndSize : regularEndSize;\n            const lifeRatio = particle.age / particle.lifeTime;\n            const fadeInDuration = 0.1;\n\n            if (lifeRatio < fadeInDuration) {\n                const fadeInRatio = lifeRatio / fadeInDuration;\n                particle.size = BABYLON.Scalar.Lerp(0, startSize, fadeInRatio);\n                BABYLON.Color4.LerpToRef(animEndColor, animStartColor, fadeInRatio, particle.color);\n            } else {\n                const mainLifeRatio = (lifeRatio - fadeInDuration) / (1 - fadeInDuration);\n                particle.size = BABYLON.Scalar.Lerp(startSize, endSize, mainLifeRatio);\n                if (mainLifeRatio < 0.5) {\n                    BABYLON.Color4.LerpToRef(animStartColor, animMidColor, mainLifeRatio * 2, particle.color);\n                } else {\n                    BABYLON.Color4.LerpToRef(animMidColor, animEndColor, (mainLifeRatio - 0.5) * 2, particle.color);\n                }\n            }\n        }\n    };\n\n    particleSystem.start();\n    return particleSystem;\n}\n\n// Creates a custom emitter to ensure particles are distributed evenly across a mesh surface.\nfunction createUniformMeshParticleEmitter(mesh: BABYLON.Mesh): BABYLON.CustomParticleEmitter {\n    const positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n    const indices = mesh.getIndices();\n    const totalFaces = indices.length / 3;\n    const cumulativeTriangleAreas: number[] = [];\n    let totalArea = 0;\n    const vA = new BABYLON.Vector3(), vB = new BABYLON.Vector3(), vC = new BABYLON.Vector3();\n    const edge1 = new BABYLON.Vector3(), edge2 = new BABYLON.Vector3();\n\n    for (let i = 0; i < totalFaces; i++) {\n        const indexA = indices[i * 3], indexB = indices[i * 3 + 1], indexC = indices[i * 3 + 2];\n        BABYLON.Vector3.FromArrayToRef(positions, indexA * 3, vA);\n        BABYLON.Vector3.FromArrayToRef(positions, indexB * 3, vB);\n        BABYLON.Vector3.FromArrayToRef(positions, indexC * 3, vC);\n        vB.subtractToRef(vA, edge1);\n        vC.subtractToRef(vA, edge2);\n        const area = BABYLON.Vector3.Cross(edge1, edge2).length() * 0.5;\n        totalArea += area;\n        cumulativeTriangleAreas.push(totalArea);\n    }\n\n    for (let i = 0; i < totalFaces; i++) cumulativeTriangleAreas[i] /= totalArea;\n\n    const customEmitter = new BABYLON.CustomParticleEmitter();\n    customEmitter.particlePositionGenerator = (index, particle, out) => {\n        const random = Math.random();\n        let triangleIndex = 0;\n        for (let i = 0; i < totalFaces; i++) if (random < cumulativeTriangleAreas[i]) { triangleIndex = i; break; }\n        const iA = indices[triangleIndex * 3], iB = indices[triangleIndex * 3 + 1], iC = indices[triangleIndex * 3 + 2];\n        BABYLON.Vector3.FromArrayToRef(positions, iA * 3, vA);\n        BABYLON.Vector3.FromArrayToRef(positions, iB * 3, vB);\n        BABYLON.Vector3.FromArrayToRef(positions, iC * 3, vC);\n        let r1 = Math.random(), r2 = Math.random();\n        if (r1 + r2 > 1) { r1 = 1 - r1; r2 = 1 - r2; }\n        vB.subtractToRef(vA, edge1);\n        vC.subtractToRef(vA, edge2);\n        out.copyFrom(vA).addInPlace(edge1.scaleInPlace(r1)).addInPlace(edge2.scaleInPlace(r2));\n    };\n    customEmitter.particleDestinationGenerator = (index, particle, out) => {\n        out.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n    };\n    return customEmitter;\n}\n","version":"0.20.13","type":"typescript"}}
    title="Simple flower"
    />
</TabItem>
</Tabs>