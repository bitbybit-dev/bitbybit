declare namespace Bit {
  declare namespace Inputs {
    declare namespace Base {
      type Color = string;
      type ColorRGB = {
        r: number;
        g: number;
        b: number;
      };
      type Point2 = [number, number];
      type Vector2 = [number, number];
      type Point3 = [number, number, number];
      type Vector3 = [number, number, number];
      type Axis3 = {
        origin: Base.Point3;
        direction: Base.Vector3;
      };
      type Axis2 = {
        origin: Base.Point2;
        direction: Base.Vector2;
      };
      type Segment2 = [Point2, Point2];
      type Segment3 = [Point3, Point3];
      type TrianglePlane3 = {
        normal: Vector3;
        d: number;
      };
      type Triangle3 = [Base.Point3, Base.Point3, Base.Point3];
      type Mesh3 = Triangle3[];
      type Plane3 = {
        origin: Base.Point3;
        normal: Base.Vector3;
        direction: Base.Vector3;
      };
      type BoundingBox = {
        min: Base.Point3;
        max: Base.Point3;
        center?: Base.Point3;
        width?: number;
        height?: number;
        length?: number;
      };
      type Line2 = {
        start: Base.Point2;
        end: Base.Point2;
      };
      type Line3 = {
        start: Base.Point3;
        end: Base.Point3;
      };
      type Polyline3 = {
        points: Base.Point3[];
        isClosed?: boolean;
      };
      type Polyline2 = {
        points: Base.Point2[];
        isClosed?: boolean;
      };
      type VerbCurve = {
        tessellate: (options: any) => any;
      };
      type VerbSurface = {
        tessellate: (options: any) => any;
      };
      type TransformMatrix3x3 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes3x3 = TransformMatrix3x3[];
      type TransformMatrix = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes = TransformMatrix[];
    }
    declare namespace JSCAD {
      type JSCADEntity = any;
      class PolylinePropertiesDto {
        /**
         * Provide options without default values
         */
        constructor(points?: Base.Point3[], isClosed?: boolean);
        /**
         * Points of the polyline
         */
        points: Base.Point3[];
        /**
         * Can contain is closed information
         */
        isClosed?: boolean;
        /**
         * Can contain color information
         */
        color?: string | number[];
      }
      enum solidCornerTypeEnum {
        /**
         * Edges will meet at a corner
         */
        edge = "edge",
        /**
         * Edges will be rounded on the corner
         */
        round = "round",
        /**
         * Edges will be chamfered on the corner
         */
        chamfer = "chamfer",
      }
      enum jscadTextAlignEnum {
        /**
         * Aligns text to the left
         */
        left = "left",
        /**
         * Aligns text to the center
         */
        center = "center",
        /**
         * Aligns text to the right
         */
        right = "right",
      }
      class MeshDto {
        constructor(mesh?: JSCADEntity);
        /**
         * Solid Jscad mesh
         */
        mesh: JSCADEntity;
      }
      class MeshesDto {
        constructor(meshes?: JSCADEntity[]);
        /**
         * Solid Jscad mesh
         */
        meshes: JSCADEntity[];
      }
      class DrawSolidMeshDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          mesh?: JSCADEntity,
          opacity?: number,
          colours?: string | string[],
          updatable?: boolean,
          hidden?: boolean,
          jscadMesh?: T,
          drawTwoSided?: boolean,
          backFaceColour?: string,
          backFaceOpacity?: number
        );
        /**
         * Solid Jscad mesh
         */
        mesh: JSCADEntity;
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours: string | string[];
        /**
         * Indicates wether this solid will be transformed in time
         * @default false
         */
        updatable: boolean;
        /**
         * Hidden
         * @default false
         */
        hidden: boolean;
        /**
         * Solid mesh variable in case it already exists and needs updating
         * @default undefined
         * @optional true
         * @ignore true
         */
        jscadMesh?: T;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: string;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawSolidMeshesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          meshes?: JSCADEntity[],
          opacity?: number,
          colours?: string | string[],
          updatable?: boolean,
          hidden?: boolean,
          jscadMesh?: T,
          drawTwoSided?: boolean,
          backFaceColour?: string,
          backFaceOpacity?: number
        );
        /**
         * Solid Jscad meshes
         * @default undefined
         * @optional true
         */
        meshes: JSCADEntity[];
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours: string | string[];
        /**
         * Indicates wether this solid will be transformed in time
         * @default false
         */
        updatable: boolean;
        /**
         * Should be hidden
         * @default false
         */
        hidden: boolean;
        /**
         * Solid mesh variable in case it already exists and needs updating
         * @default undefined
         * @optional true
         * @ignore true
         */
        jscadMesh?: T;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: string;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawPathDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          path?: JSCADEntity,
          colour?: string,
          opacity?: number,
          width?: number,
          updatable?: boolean,
          pathMesh?: T
        );
        /**
         * 2D Path to draw
         * @default undefined
         */
        path: JSCADEntity;
        /**
         * Colour of the path
         * @default #444444
         */
        colour: string;
        /**
         * Opacity of the path
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * Width of the path
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        width: number;
        /**
         * Indicates wether the path will change in time
         * @default false
         */
        updatable: boolean;
        /**
         * Path mesh variable that will be updated if updatable property is set to true
         * @default undefined
         * @optional true
         * @ignore true
         */
        pathMesh?: T;
      }
      class TransformSolidsDto {
        constructor(
          meshes?: JSCADEntity[],
          transformation?: Base.TransformMatrixes
        );
        /**
         * Solids to be transformed
         * @default undefined
         */
        meshes: JSCADEntity[];
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation: Base.TransformMatrixes;
      }
      class TransformSolidDto {
        constructor(
          mesh?: JSCADEntity,
          transformation?: Base.TransformMatrixes
        );
        /**
         * Solid to be transformed
         * @default undefined
         */
        mesh: JSCADEntity;
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation: Base.TransformMatrixes;
      }
      class DownloadSolidDto {
        constructor(mesh?: JSCADEntity, fileName?: string);
        /**
         * Solid to be downloaded
         * @default undefined
         */
        mesh: JSCADEntity;
        /**
         * File name
         * @default undefined
         */
        fileName: string;
      }
      class DownloadGeometryDto {
        constructor(
          geometry?: JSCADEntity | JSCADEntity[],
          fileName?: string,
          options?: any
        );
        /**
         * Solid or path to be downloaded, also supports multiple geometries in array
         * @default undefined
         */
        geometry: JSCADEntity | JSCADEntity[];
        /**
         * File name
         * @default jscad-geometry
         */
        fileName: string;
        /**
         * Options
         * @default undefined
         * @optional true
         */
        options: any;
      }
      class DownloadSolidsDto {
        constructor(meshes?: JSCADEntity[], fileName?: string);
        /**
         * Solids to be downloaded
         * @default undefined
         */
        meshes: JSCADEntity[];
        /**
         * File name
         * @default undefined
         */
        fileName: string;
      }
      class ColorizeDto {
        constructor(geometry?: JSCADEntity, color?: string);
        /**
         * Solid to be colorized
         * @default undefined
         */
        geometry: JSCADEntity | JSCADEntity[];
        /**
         * Hex color string
         * @default #0000ff
         */
        color: string;
      }
      class BooleanObjectsDto {
        constructor(meshes?: JSCADEntity[]);
        /**
         * Contains solid Jscad mesh objects that will be used to perform boolean operation
         * @default undefined
         */
        meshes: JSCADEntity[];
      }
      class BooleanTwoObjectsDto {
        constructor(first?: JSCADEntity, second?: JSCADEntity);
        /**
         * Contains Jscad Solid
         * @default undefined
         */
        first: JSCADEntity;
        /**
         * Contains Jscad Solid
         * @default undefined
         */
        second: JSCADEntity;
      }
      class BooleanObjectsFromDto {
        constructor(from?: JSCADEntity, meshes?: JSCADEntity[]);
        /**
         * Contains Jscad Solid
         * @default undefined
         */
        from: JSCADEntity;
        /**
         * Contains Jscad Solid
         * @default undefined
         */
        meshes: JSCADEntity[];
      }
      class ExpansionDto {
        constructor(
          geometry?: JSCADEntity,
          delta?: number,
          corners?: solidCornerTypeEnum,
          segments?: number
        );
        /**
         * Can contain various Jscad entities from Solid category
         * @default undefined
         */
        geometry: JSCADEntity;
        /**
         * Delta (+/-) of expansion
         * @default 0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        delta: number;
        /**
         * Type of corner to create during of expansion; edge, chamfer, round
         * @default edge
         */
        corners: solidCornerTypeEnum;
        /**
         * Integer number of segments when creating round corners
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class OffsetDto {
        constructor(
          geometry?: JSCADEntity,
          delta?: number,
          corners?: solidCornerTypeEnum,
          segments?: number
        );
        /**
         * Can contain various Jscad entities from Solid category
         * @default undefined
         */
        geometry: JSCADEntity;
        /**
         * Delta (+/-) of offset
         * @default 0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        delta: number;
        /**
         * Type of corner to create during the offset; edge, chamfer, round.
         * @default edge
         */
        corners: solidCornerTypeEnum;
        /**
         * Integer number of segments when creating round corners
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class ExtrudeLinearDto {
        constructor(
          geometry?: JSCADEntity,
          height?: number,
          twistAngle?: number,
          twistSteps?: number
        );
        /**
         * Geometry to extrude
         * @default undefined
         */
        geometry: JSCADEntity;
        /**
         * Height of linear extrude
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Twist angle in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        twistAngle: number;
        /**
         * Number of twist steps
         * @default 15
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        twistSteps: number;
      }
      class HullDto {
        constructor(meshes?: JSCADEntity[]);
        /**
         * Geometries to use in hull
         * @default undefined
         */
        meshes: JSCADEntity[];
      }
      class ExtrudeRectangularDto {
        constructor(geometry?: JSCADEntity, height?: number, size?: number);
        /**
         * Geometry to extrude
         * @default undefined
         */
        geometry: JSCADEntity;
        /**
         * Height of linear extrude
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Size of the rectangle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class ExtrudeRectangularPointsDto {
        constructor(points?: Base.Point3[], height?: number, size?: number);
        /**
         * Points for a path
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Height of linear extrude
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Size of the rectangle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class ExtrudeRotateDto {
        constructor(
          polygon?: JSCADEntity,
          angle?: number,
          startAngle?: number,
          segments?: number
        );
        /**
         * Polygon to extrude
         * @default undefined
         */
        polygon: JSCADEntity;
        /**
         * Angle in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
        /**
         * Start angle in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        startAngle: number;
        /**
         * Number of segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class PolylineDto {
        constructor(polyline?: PolylinePropertiesDto);
        /**
         * Polyline with points
         */
        polyline: PolylinePropertiesDto;
      }
      class CurveDto {
        constructor(curve?: any);
        /**
         * Nurbs curve
         */
        curve: any;
      }
      class PointsDto {
        constructor(points?: Base.Point3[]);
        /**
         * Points
         */
        points: Base.Point3[];
      }
      class PathDto {
        constructor(path?: JSCADEntity);
        /**
         * 2D path
         * @default undefined
         */
        path: JSCADEntity;
      }
      class PathFromPointsDto {
        constructor(points?: Base.Point2[], closed?: boolean);
        /**
         * Points through which to create a path
         * @default undefined
         */
        points: Base.Point2[];
        /**
         * Indicates wether we want to create a closed path
         * @default false
         */
        closed: boolean;
      }
      class PathsFromPointsDto {
        constructor(pointsLists?: Base.Point3[][] | Base.Point2[][]);
        /**
         * Points
         * @default undefined
         */
        pointsLists: Base.Point3[][] | Base.Point2[][];
      }
      class PathFromPolylineDto {
        constructor(polyline?: PolylinePropertiesDto, closed?: boolean);
        /**
         * Polyline
         * @default undefined
         */
        polyline: PolylinePropertiesDto;
        /**
         * Indicates wether we want to create a closed path
         * @default false
         */
        closed: boolean;
      }
      class PathAppendCurveDto {
        constructor(curve?: JSCADEntity, path?: JSCADEntity);
        /**
         * Verb Nurbs curve
         * @default undefined
         */
        curve: JSCADEntity;
        /**
         * Path to append the curve to
         * @default undefined
         */
        path: JSCADEntity;
      }
      class PathAppendPointsDto {
        constructor(points?: Base.Point2[], path?: JSCADEntity);
        /**
         * Points to append
         * @default undefined
         */
        points: Base.Point2[];
        /**
         * Path to append the points to
         * @default undefined
         */
        path: JSCADEntity;
      }
      class PathAppendPolylineDto {
        constructor(polyline?: PolylinePropertiesDto, path?: JSCADEntity);
        /**
         * Polyline to append
         * @default undefined
         */
        polyline: PolylinePropertiesDto;
        /**
         * Path to append the polyline to
         * @default undefined
         */
        path: JSCADEntity;
      }
      class PathAppendArcDto {
        constructor(
          path?: JSCADEntity,
          endPoint?: Base.Point2,
          xAxisRotation?: number,
          clockwise?: boolean,
          large?: boolean,
          segments?: number,
          radiusX?: number,
          radiusY?: number
        );
        /**
         * Path to append the arc to
         * @default undefined
         */
        path: JSCADEntity;
        /**
         * End point of an arc
         * @default [1, 1]
         */
        endPoint: Base.Point2;
        /**
         * Rotation (degrees) of the X axis of the arc with respect to the X axis of the coordinate system
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        xAxisRotation: number;
        /**
         * Draw an arc clockwise with respect to the center point
         * @default true
         */
        clockwise: boolean;
        /**
         * Draw an arc longer than PI radians
         * @default false
         */
        large: boolean;
        /**
         * Number of segments for the arc
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
        /**
         * X radius of an arc
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        radiusX: number;
        /**
         * Y radius of an arc
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        radiusY: number;
      }
      class CircleDto {
        constructor(center?: Base.Point2, radius?: number, segments?: number);
        /**
         * Center of the circle
         * @default [0, 0]
         */
        center: Base.Point2;
        /**
         * Radius of the circle
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Segment number
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class EllipseDto {
        constructor(
          center?: Base.Point2,
          radius?: Base.Point2,
          segments?: number
        );
        /**
         * Center of the circle
         * @default [0, 0]
         */
        center: Base.Point2;
        /**
         * Radius of the circle in [x, y] form
         * @default [1, 2]
         */
        radius: Base.Point2;
        /**
         * Segment number
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class SquareDto {
        constructor(center?: Base.Point2, size?: number);
        /**
         * Center of the 2D square
         * @default [0, 0]
         */
        center: Base.Point2;
        /**
         * Size of the square
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class RectangleDto {
        constructor(center?: Base.Point2, width?: number, length?: number);
        /**
         * Center of the 2D rectangle
         * @default [0, 0]
         */
        center: Base.Point2;
        /**
         * Width of the rectangle
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the rectangle
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
      }
      class RoundedRectangleDto {
        constructor(
          center?: Base.Point2,
          roundRadius?: number,
          segments?: number,
          width?: number,
          length?: number
        );
        /**
         * Center of the 2D rectangle
         * @default [0, 0]
         */
        center: Base.Point2;
        /**
         * The radius to round the rectangle edge
         * @default 0.2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        roundRadius: number;
        /**
         * Number of segments for corners
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
        /**
         * Width of the rectangle
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the rectangle
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
      }
      class StarDto {
        constructor(
          center?: Base.Point2,
          vertices?: number,
          density?: number,
          outerRadius?: number,
          innerRadius?: number,
          startAngle?: number
        );
        /**
         * Center of the 2D star
         * @default [0, 0]
         */
        center: Base.Point2;
        /**
         * Number of vertices on the star
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        vertices: number;
        /**
         * Density of the star
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        density: number;
        /**
         * Outer radius of the star
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        outerRadius: number;
        /**
         * Inner radius of the star
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        innerRadius: number;
        /**
         * Starting angle for first vertice, in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        startAngle: number;
      }
      class CubeDto {
        constructor(center?: Base.Point3, size?: number);
        /**
         * Center coordinates of the cube
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Size of the cube
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class CubeCentersDto {
        constructor(centers?: Base.Point3[], size?: number);
        /**
         * Center coordinates of the cubes
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Size of the cube
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class CuboidDto {
        constructor(
          center?: Base.Point3,
          width?: number,
          length?: number,
          height?: number
        );
        /**
         * Center coordinates of the cubod
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Width of the cuboid
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the cuboid
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the cuboid
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
      }
      class CuboidCentersDto {
        constructor(
          centers?: Base.Point3[],
          width?: number,
          length?: number,
          height?: number
        );
        /**
         * Center coordinates of the cuboids
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Width of the cuboids
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the cuboids
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the cuboids
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
      }
      class RoundedCuboidDto {
        constructor(
          center?: Base.Point3,
          roundRadius?: number,
          width?: number,
          length?: number,
          height?: number,
          segments?: number
        );
        /**
         * Center coordinates of the cubod
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Radius for rounding edges
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        roundRadius: number;
        /**
         * Width of the cuboid
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the cuboid
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the cuboid
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Segments of rounded edges
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class RoundedCuboidCentersDto {
        constructor(
          centers?: Base.Point3[],
          roundRadius?: number,
          width?: number,
          length?: number,
          height?: number,
          segments?: number
        );
        /**
         * Center coordinates of the cuboids
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Radius for rounding edges
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        roundRadius: number;
        /**
         * Width of the cuboids
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the cuboids
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the cuboids
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Segments of rounded edges
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class CylidnerEllipticDto {
        constructor(
          center?: Base.Point3,
          height?: number,
          startRadius?: Base.Point2,
          endRadius?: Base.Point2,
          segments?: number
        );
        /**
         * Center of the cylinder
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Height of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Start radius on X and Y directions
         * @default [1, 2]
         */
        startRadius: Base.Vector2;
        /**
         * End radius on X and Y directions
         * @default [2, 3]
         */
        endRadius: Base.Vector2;
        /**
         * Subdivision segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class CylidnerCentersEllipticDto {
        constructor(
          centers?: Base.Point3[],
          height?: number,
          startRadius?: Base.Point2,
          endRadius?: Base.Point2,
          segments?: number
        );
        /**
         * Centers of the cylinders
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Height of the cylinders
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Start radius on X and Y directions
         * @default [1, 2]
         */
        startRadius: Base.Point2;
        /**
         * End radius on X and Y directions
         * @default [2, 3]
         */
        endRadius: Base.Point2;
        /**
         * Subdivision segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class CylidnerDto {
        constructor(
          center?: Base.Point3,
          height?: number,
          radius?: number,
          segments?: number
        );
        /**
         * Center of the cylinder
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Height of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Subdivision segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class RoundedCylidnerDto {
        constructor(
          center?: Base.Point3,
          roundRadius?: number,
          height?: number,
          radius?: number,
          segments?: number
        );
        /**
         * Center of the cylinder
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Rounding radius
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        roundRadius: number;
        /**
         * Height of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Segment number
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class EllipsoidDto {
        constructor(
          center?: Base.Point3,
          radius?: Base.Point3,
          segments?: number
        );
        /**
         * Center coordinates
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Radius of the ellipsoid in [x, y, z] form
         * @default [1, 2, 3]
         */
        radius: Base.Point3;
        /**
         * Segment count for ellipsoid
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class EllipsoidCentersDto {
        constructor(
          centers?: Base.Point3[],
          radius?: Base.Point3,
          segments?: number
        );
        /**
         * Center coordinates
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Radius of the ellipsoid in [x, y, z] form
         * @default [1, 2, 3]
         */
        radius: Base.Point3;
        /**
         * Segment count for ellipsoid
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class GeodesicSphereDto {
        constructor(center?: Base.Point3, radius?: number, frequency?: number);
        /**
         * Center coordinate of the geodesic sphere
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Radius of the sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Subdivision count
         * @default 12
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        frequency: number;
      }
      class GeodesicSphereCentersDto {
        constructor(
          centers?: Base.Point3[],
          radius?: number,
          frequency?: number
        );
        /**
         * Center coordinates of the geodesic spheres
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Radius of the sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Subdivision count
         * @default 12
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        frequency: number;
      }
      class CylidnerCentersDto {
        constructor(
          centers?: Base.Point3[],
          height?: number,
          radius?: number,
          segments?: number
        );
        /**
         * Centers of the cylinders
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Height of the cylinders
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Radius of the cylinders
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Subdivision segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class RoundedCylidnerCentersDto {
        constructor(
          centers?: Base.Point3[],
          roundRadius?: number,
          height?: number,
          radius?: number,
          segments?: number
        );
        /**
         * Centers of the cylinders
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Rounding radius
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        roundRadius: number;
        /**
         * Height of the cylinders
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Radius of the cylinders
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Segment number
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class SphereDto {
        constructor(center?: Base.Point3, radius?: number, segments?: number);
        /**
         * Center point of the sphere
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Radius of the sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Segment count
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class SphereCentersDto {
        constructor(
          centers?: Base.Point3[],
          radius?: number,
          segments?: number
        );
        /**
         * Center points of the spheres
         * @default undefined
         */
        centers: Base.Point3[];
        /**
         * Radius of the spheres
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Segment count
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
      }
      class TorusDto {
        constructor(
          center?: Base.Point3,
          innerRadius?: number,
          outerRadius?: number,
          innerSegments?: number,
          outerSegments?: number,
          innerRotation?: number,
          outerRotation?: number,
          startAngle?: number
        );
        /**
         * Center coordinate
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Inner radius
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        innerRadius: number;
        /**
         * Outer radius
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        outerRadius: number;
        /**
         * Number of inner segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        innerSegments: number;
        /**
         * Number of outer segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        outerSegments: number;
        /**
         * Inner rotation in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        innerRotation: number;
        /**
         * Outer rotation in degrees
         * @default 360
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        outerRotation: number;
        /**
         * Start angle in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        startAngle: number;
      }
      class TextDto {
        constructor(
          text?: string,
          segments?: number,
          xOffset?: number,
          yOffset?: number,
          height?: number,
          lineSpacing?: number,
          letterSpacing?: number,
          align?: jscadTextAlignEnum,
          extrudeOffset?: number
        );
        /**
         * Text to write
         * @default Hello World
         */
        text: string;
        /**
         * Number of segments
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
        /**
         * X offset of the text
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        xOffset: number;
        /**
         * Y offset of the text
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        yOffset: number;
        /**
         * Height of the text
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Space between lines
         * @default 1.4
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        lineSpacing: number;
        /**
         * Space between letters
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        letterSpacing: number;
        /**
         * Align between left, center, right
         * @default center
         */
        align: jscadTextAlignEnum;
        /**
         * Offset the extrusion
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extrudeOffset: number;
      }
      class CylinderTextDto {
        constructor(
          text?: string,
          extrusionHeight?: number,
          extrusionSize?: number,
          segments?: number,
          xOffset?: number,
          yOffset?: number,
          height?: number,
          lineSpacing?: number,
          letterSpacing?: number,
          align?: jscadTextAlignEnum,
          extrudeOffset?: number
        );
        /**
         * Text to write
         * @default Hello World
         */
        text: string;
        /**
         * Height of the cylinder
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionHeight: number;
        /**
         * Radius of the cylinder
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionSize: number;
        /**
         * Segment subdivision for cylinder
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
        /**
         * X offset of the text
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        xOffset: number;
        /**
         * Y offset of the text
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        yOffset: number;
        /**
         * Height of the text
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Space between lines
         * @default 1.4
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        lineSpacing: number;
        /**
         * Space between letters
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        letterSpacing: number;
        /**
         * Align between left, center, right
         * @default center
         */
        align: jscadTextAlignEnum;
        /**
         * Offset the extrusion
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extrudeOffset: number;
      }
      class SphereTextDto {
        constructor(
          text?: string,
          radius?: number,
          segments?: number,
          xOffset?: number,
          yOffset?: number,
          height?: number,
          lineSpacing?: number,
          letterSpacing?: number,
          align?: jscadTextAlignEnum,
          extrudeOffset?: number
        );
        /**
         * Text to write
         * @default Hello World
         */
        text: string;
        /**
         * Radius of the spheres
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Segment subdivision for sphere
         * @default 24
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
        /**
         * X offset of the text
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        xOffset: number;
        /**
         * Y offset of the text
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        yOffset: number;
        /**
         * Height of the text
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Space between lines
         * @default 1.4
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        lineSpacing: number;
        /**
         * Space between letters
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        letterSpacing: number;
        /**
         * Align between left, center, right
         * @default center
         */
        align: jscadTextAlignEnum;
        /**
         * Offset the extrusion
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extrudeOffset: number;
      }
      class FromPolygonPoints {
        constructor(polygonPoints?: Base.Point3[][]);
        /**
         * Points describing polygons
         */
        polygonPoints?: Base.Point3[][];
      }
    }
    declare namespace Base {
      type Color = string;
      type ColorRGB = {
        r: number;
        g: number;
        b: number;
      };
      type Point2 = [number, number];
      type Vector2 = [number, number];
      type Point3 = [number, number, number];
      type Vector3 = [number, number, number];
      type Axis3 = {
        origin: Base.Point3;
        direction: Base.Vector3;
      };
      type Axis2 = {
        origin: Base.Point2;
        direction: Base.Vector2;
      };
      type Segment2 = [Point2, Point2];
      type Segment3 = [Point3, Point3];
      type TrianglePlane3 = {
        normal: Vector3;
        d: number;
      };
      type Triangle3 = [Base.Point3, Base.Point3, Base.Point3];
      type Mesh3 = Triangle3[];
      type Plane3 = {
        origin: Base.Point3;
        normal: Base.Vector3;
        direction: Base.Vector3;
      };
      type BoundingBox = {
        min: Base.Point3;
        max: Base.Point3;
        center?: Base.Point3;
        width?: number;
        height?: number;
        length?: number;
      };
      type Line2 = {
        start: Base.Point2;
        end: Base.Point2;
      };
      type Line3 = {
        start: Base.Point3;
        end: Base.Point3;
      };
      type Polyline3 = {
        points: Base.Point3[];
        isClosed?: boolean;
      };
      type Polyline2 = {
        points: Base.Point2[];
        isClosed?: boolean;
      };
      type VerbCurve = {
        tessellate: (options: any) => any;
      };
      type VerbSurface = {
        tessellate: (options: any) => any;
      };
      type TransformMatrix3x3 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes3x3 = TransformMatrix3x3[];
      type TransformMatrix = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes = TransformMatrix[];
    }
    declare namespace Manifold {
      type ManifoldPointer = {
        hash: number;
        type: string;
      };
      type CrossSectionPointer = {
        hash: number;
        type: string;
      };
      type MeshPointer = {
        hash: number;
        type: string;
      };
      enum fillRuleEnum {
        evenOdd = "EvenOdd",
        nonZero = "NonZero",
        positive = "Positive",
        negative = "Negative",
      }
      enum manifoldJoinTypeEnum {
        square = "Square",
        round = "Round",
        miter = "Miter",
        bevel = "Bevel",
      }
      class DecomposedManifoldMeshDto {
        numProp: number;
        vertProperties: Float32Array;
        triVerts: Uint32Array;
        mergeFromVert?: Uint32Array;
        mergeToVert?: Uint32Array;
        runIndex?: Uint32Array;
        runOriginalID?: Uint32Array;
        runTransform?: Float32Array;
        faceID?: Uint32Array;
        halfedgeTangent?: Float32Array;
      }
      class DrawManifoldOrCrossSectionDto<T, M> {
        /**
         * Provide options without default values
         */
        constructor(
          manifoldOrCrossSection?: T,
          faceOpacity?: number,
          faceMaterial?: M,
          faceColour?: Base.Color,
          crossSectionColour?: Base.Color,
          crossSectionWidth?: number,
          crossSectionOpacity?: number,
          computeNormals?: boolean,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number
        );
        /**
         * Manifold geometry
         * @default undefined
         */
        manifoldOrCrossSection?: T;
        /**
         * Face opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        faceOpacity: number;
        /**
         * Face material
         * @default undefined
         * @optional true
         */
        faceMaterial?: M;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour: Base.Color;
        /**
         * Hex colour string for cross section drawing
         * @default #ff00ff
         */
        crossSectionColour: Base.Color;
        /**
         * Width of cross section lines
         * @default 2
         */
        crossSectionWidth: number;
        /**
         * Cross section opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        crossSectionOpacity: number;
        /**
         * Compute normals for the shape
         * @default false
         */
        computeNormals: boolean;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawManifoldsOrCrossSectionsDto<T, M> {
        /**
         * Provide options without default values
         */
        constructor(
          manifoldsOrCrossSections?: T[],
          faceOpacity?: number,
          faceMaterial?: M,
          faceColour?: Base.Color,
          crossSectionColour?: Base.Color,
          crossSectionWidth?: number,
          crossSectionOpacity?: number,
          computeNormals?: boolean,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number
        );
        /**
         * Manifold geometry
         * @default undefined
         */
        manifoldsOrCrossSections?: T[];
        /**
         * Face material
         * @default undefined
         * @optional true
         */
        faceMaterial?: M;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour: Base.Color;
        /**
         * Face opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        faceOpacity: number;
        /**
         * Hex colour string for cross section drawing
         * @default #ff00ff
         */
        crossSectionColour: Base.Color;
        /**
         * Width of cross section lines
         * @default 2
         */
        crossSectionWidth: number;
        /**
         * Cross section opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        crossSectionOpacity: number;
        /**
         * Compute normals for the shape
         * @default false
         */
        computeNormals: boolean;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class CreateFromMeshDto {
        constructor(mesh?: DecomposedManifoldMeshDto);
        /**
         * Mesh definition
         */
        mesh: DecomposedManifoldMeshDto;
      }
      class FromPolygonPointsDto {
        constructor(polygonPoints?: Base.Point3[][]);
        /**
         * Points describing polygons
         */
        polygonPoints?: Base.Point3[][];
      }
      class CrossSectionFromPolygonPointsDto {
        constructor(
          points?: Base.Point3[],
          fillRule?: fillRuleEnum,
          removeDuplicates?: boolean,
          tolerance?: number
        );
        /**
         * Points describing a single polygon
         */
        points: Base.Point3[];
        /**
         * Fill rule for polygon interpretation
         * @default positive
         */
        fillRule?: fillRuleEnum;
        /**
         * Remove consecutive duplicate points before creating polygon
         * @default false
         */
        removeDuplicates?: boolean;
        /**
         * Tolerance for duplicate removal
         * @default 1e-7
         */
        tolerance?: number;
      }
      class CrossSectionFromPolygonsPointsDto {
        constructor(
          polygonPoints?: Base.Point3[][],
          fillRule?: fillRuleEnum,
          removeDuplicates?: boolean,
          tolerance?: number
        );
        /**
         * Points describing multiple polygons
         */
        polygonPoints: Base.Point3[][];
        /**
         * Fill rule for polygon interpretation
         * @default positive
         */
        fillRule?: fillRuleEnum;
        /**
         * Remove consecutive duplicate points before creating polygons
         * @default false
         */
        removeDuplicates?: boolean;
        /**
         * Tolerance for duplicate removal
         * @default 1e-7
         */
        tolerance?: number;
      }
      class CubeDto {
        constructor(center?: boolean, size?: number);
        /**
         * Place cube on the center
         * @default true
         */
        center: boolean;
        /**
         * Size of the cube
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class CreateContourSectionDto {
        constructor(polygons?: Base.Vector2[][], fillRule?: fillRuleEnum);
        /**
         * Polygons to use for the contour section
         * @default undefined
         */
        polygons: Base.Vector2[][];
        /**
         * Fill rule for the contour section
         * @default EvenOdd
         */
        fillRule: fillRuleEnum;
      }
      class SquareDto {
        constructor(center?: boolean, size?: number);
        /**
         * Place cube on the center
         * @default false
         */
        center: boolean;
        /**
         * Size of the cube
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
      }
      class SphereDto {
        constructor(radius?: number, circularSegments?: number);
        /**
         * Radius of the sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Circular segments of the sphere
         * @default 32
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        circularSegments: number;
      }
      class CylinderDto {
        constructor(
          height?: number,
          radiusLow?: number,
          radiusHigh?: number,
          circularSegments?: number,
          center?: boolean
        );
        /**
         * Height of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusLow: number;
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusHigh: number;
        /**
         * Circular segments of the cylinder
         * @default 32
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        circularSegments: number;
        /**
         * Place cylinder on the center
         * @default true
         */
        center: boolean;
      }
      class CircleDto {
        constructor(radius?: number, circularSegments?: number);
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Circular segments of the cylinder
         * @default 32
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        circularSegments: number;
      }
      class RectangleDto {
        constructor(length?: number, height?: number, center?: boolean);
        /**
         * Length of the rectangle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the rectangle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Place rectangle on the center
         * @default false
         */
        center: boolean;
      }
      class ManifoldDto<T> {
        constructor(manifold?: T);
        /**
         * Manifold shape
         */
        manifold: T;
      }
      class CalculateNormalsDto<T> {
        constructor(manifold?: T, normalIdx?: number, minSharpAngle?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The property channel in which to store the X
         * values of the normals. The X, Y, and Z channels will be sequential. The
         * property set will be automatically expanded to include up through normalIdx
         * + 2.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        normalIdx: number;
        /**
         * Any edges with angles greater than this value will
         * remain sharp, getting different normal vector properties on each side of
         * the edge. By default, no edges are sharp and all normals are shared. With a
         * value of zero, the model is faceted and all normals match their triangle
         * normals, but in this case it would be better not to calculate normals at
         * all. The value is in degrees.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minSharpAngle: number;
      }
      class CalculateCurvatureDto<T> {
        constructor(manifold?: T);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The property channel index in which to store the
         * Gaussian curvature. An index < 0 will be ignored (stores nothing). The
         * property set will be automatically expanded to include the channel
         * index specified.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        gaussianIdx: number;
        /**
         * The property channel index in which to store the mean
         * curvature. An index < 0 will be ignored (stores nothing). The property
         * set will be automatically expanded to include the channel index
         * specified. The mean curvature is a scalar value that describes the
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        meanIdx: number;
      }
      class CountDto {
        constructor(count?: number);
        /**
         * Nr to count
         */
        count: number;
      }
      class ManifoldsMinGapDto<T> {
        constructor(manifold1?: T, manifold2?: T, searchLength?: number);
        /**
         * Manifold shape
         */
        manifold1: T;
        /**
         * Manifold shape
         */
        manifold2: T;
        /**
         * Length of the search gap
         * @default 100
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        searchLength: number;
      }
      class ManifoldRefineToleranceDto<T> {
        constructor(manifold?: T, tolerance?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The desired maximum distance between the faceted mesh
         * produced and the exact smoothly curving surface. All vertices are exactly
         * on the surface, within rounding error.
         * @default 1e-6
         * @minimum 0
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance: number;
      }
      class ManifoldRefineLengthDto<T> {
        constructor(manifold?: T, length?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * Length of the manifold
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
      }
      class ManifoldRefineDto<T> {
        constructor(manifold?: T, number?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The number of pieces to split every edge into. Must be > 1.
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        number: number;
      }
      class ManifoldSmoothByNormalsDto<T> {
        constructor(manifold?: T, normalIdx?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The first property channel of the normals. NumProp must be
         * at least normalIdx + 3. Any vertex where multiple normals exist and don't
         * agree will result in a sharp edge.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        normalIdx: number;
      }
      class ManifoldSimplifyDto<T> {
        constructor(manifold?: T, tolerance?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The maximum distance between the original and simplified meshes.
         * If not given or is less than the current tolerance, the current tolerance is used.
         * The result will contain a subset of the original verts and all surfaces will have moved by less than tolerance.
         * @default undefined
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        tolerance?: number;
      }
      class ManifoldSetPropertiesDto<T> {
        constructor(
          manifold?: T,
          numProp?: number,
          propFunc?: (
            newProp: number[],
            position: Base.Vector3,
            oldProp: number[]
          ) => void
        );
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The new number of properties per vertex
         * @default 3
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        numProp: number;
        /**
         * A function that modifies the properties of a given vertex.
         * Note: undefined behavior will result if you read past the number of input properties or write past the number of output properties.
         * @default undefined
         */
        propFunc: (
          newProp: number[],
          position: Base.Vector3,
          oldProp: number[]
        ) => void;
      }
      class ManifoldSmoothOutDto<T> {
        constructor(
          manifold?: T,
          minSharpAngle?: number,
          minSmoothness?: number
        );
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * Any edges with angles greater
         * than this value will remain sharp. The rest will be smoothed to G1
         * continuity, with the caveat that flat faces of three or more triangles will
         * always remain flat. With a value of zero, the model is faceted, but in this
         * case there is no point in smoothing.
         * @default 60
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        minSharpAngle: number;
        /**
         * The smoothness applied to
         * sharp angles. The default gives a hard edge, while values > 0 will give a
         * small fillet on these sharp edges. A value of 1 is equivalent to a
         * minSharpAngle of 180 - all edges will be smooth.
         * @default 0
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        minSmoothness: number;
      }
      class HullPointsDto<T> {
        constructor(points?: T);
        /**
         * Points to hull
         */
        points: T;
      }
      class SliceDto<T> {
        constructor(manifold?: T);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * Height of the slice
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
      }
      class MeshDto<T> {
        constructor(mesh?: T);
        /**
         * Mesh
         */
        mesh: T;
      }
      class MeshVertexIndexDto<T> {
        constructor(mesh?: T, vertexIndex?: number);
        /**
         * Mesh
         */
        mesh: T;
        /**
         * Vertex index
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        vertexIndex: number;
      }
      class MeshTriangleRunIndexDto<T> {
        constructor(mesh?: T, triangleRunIndex?: number);
        /**
         * Mesh
         */
        mesh: T;
        /**
         * Triangle run index
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        triangleRunIndex: number;
      }
      class MeshHalfEdgeIndexDto<T> {
        constructor(mesh?: T, halfEdgeIndex?: number);
        /**
         * Mesh
         */
        mesh: T;
        /**
         * Half edge index
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        halfEdgeIndex: number;
      }
      class MeshTriangleIndexDto<T> {
        constructor(mesh?: T, triangleIndex?: number);
        /**
         * Mesh
         */
        mesh: T;
        /**
         * Triangle index
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        triangleIndex: number;
      }
      class CrossSectionDto<T> {
        constructor(crossSection?: T);
        /**
         * Cross section
         */
        crossSection: T;
      }
      class CrossSectionsDto<T> {
        constructor(crossSections?: T[]);
        /**
         * Cross sections
         */
        crossSections: T[];
      }
      class ExtrudeDto<T> {
        constructor(crossSection?: T);
        /**
         * Extrude cross section shape
         */
        crossSection: T;
        /**
         * Height of the extrusion
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Number of divisions
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nDivisions: number;
        /**
         * Twist degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        twistDegrees: number;
        /**
         * Scale top
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleTopX: number;
        /**
         * Scale top
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleTopY: number;
        /**
         * Center the extrusion
         * @default true
         */
        center: boolean;
      }
      class RevolveDto<T> {
        constructor(
          crossSection?: T,
          revolveDegrees?: number,
          matchProfile?: boolean,
          circularSegments?: number
        );
        /**
         * Revolve cross section shape
         */
        crossSection: T;
        /**
         * Extrude cross section shape
         * @default 360
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        revolveDegrees: number;
        /**
         * Default manifold library will adjust profile when generating revolved shape. We prefer it to be matching the profile by default. Set to false to use default manifold library behavior.
         * @default true
         */
        matchProfile: boolean;
        /**
         * Circular segments
         * @default 32
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        circularSegments: number;
      }
      class OffsetDto<T> {
        constructor(
          crossSection?: T,
          delta?: number,
          joinType?: manifoldJoinTypeEnum,
          miterLimit?: number,
          circularSegments?: number
        );
        /**
         * Revolve cross section shape
         */
        crossSection: T;
        /**
         * Positive deltas will cause the expansion of outlining contours
         * to expand, and retraction of inner (hole) contours. Negative deltas will
         * have the opposite effect.
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        delta: number;
        /**
         * The join type specifying the treatment of contour joins
         * (corners).
         * @default round
         */
        joinType: manifoldJoinTypeEnum;
        /**
         * The maximum distance in multiples of delta that vertices
         * can be offset from their original positions with before squaring is
         * applied, **when the join type is Miter** (default is 2, which is the
         * minimum allowed). See the [Clipper2
         * MiterLimit](http://www.angusj.com/clipper2/Docs/Units/Clipper.Offset/Classes/ClipperOffset/Properties/MiterLimit.htm)
         * page for a visual example.
         * @default 2
         * @minimum 2
         * @maximum Infinity
         * @step 0.1
         */
        miterLimit: number;
        /**
         * Number of segments per 360 degrees of
         * <B>JoinType::Round</B> corners (roughly, the number of vertices that
         * will be added to each contour). Default is calculated by the static Quality
         * defaults according to the radius.
         * @default 32
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        circularSegments: number;
      }
      class SimplifyDto<T> {
        constructor(crossSection?: T, epsilon?: number);
        /**
         * Revolve cross section shape
         */
        crossSection: T;
        /**
         * Extrude cross section shape
         * @default 1e-6
         * @minimum 0
         * @maximum Infinity
         * @step 1e-7
         */
        epsilon: number;
      }
      class ComposeDto<T> {
        constructor(polygons?: T);
        /**
         * Polygons to compose
         */
        polygons: T;
      }
      class MirrorCrossSectionDto<T> {
        constructor(crossSection?: T, normal?: Base.Vector2);
        /**
         * Manifold shape
         */
        crossSection: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [1,0]
         */
        normal: Base.Vector2;
      }
      class Scale2DCrossSectionDto<T> {
        constructor(crossSection?: T, vector?: Base.Vector2);
        /**
         * Manifold shape
         */
        crossSection: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [2,2]
         */
        vector: Base.Vector2;
      }
      class TranslateCrossSectionDto<T> {
        constructor(crossSection?: T, vector?: Base.Vector2);
        /**
         * Manifold shape
         */
        crossSection: T;
        /**
         * The translation vector
         * @default undefined
         */
        vector: Base.Vector2;
      }
      class RotateCrossSectionDto<T> {
        constructor(crossSection?: T, degrees?: number);
        /**
         * Manifold shape
         */
        crossSection: T;
        /**
         * The rotation vector in eulers
         * @default 45
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        degrees: number;
      }
      class ScaleCrossSectionDto<T> {
        constructor(crossSection?: T, factor?: number);
        /**
         * Manifold shape
         */
        crossSection: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default 2
         */
        factor: number;
      }
      class TranslateXYCrossSectionDto<T> {
        constructor(crossSection?: T, x?: number, y?: number);
        /**
         * Manifold shape
         */
        crossSection: T;
        /**
         * The translation X axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        x: number;
        /**
         * The translation Y axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        y: number;
      }
      class TransformCrossSectionDto<T> {
        constructor(crossSection?: T, transform?: Base.TransformMatrix3x3);
        /**
         * Cross section
         */
        crossSection: T;
        /**
         * The transform matrix to apply
         * @default undefined
         */
        transform: Base.TransformMatrix3x3;
      }
      class CrossSectionWarpDto<T> {
        constructor(crossSection?: T, warpFunc?: (vert: Base.Vector2) => void);
        /**
         * Cross section
         */
        crossSection: T;
        /**
         * A function that modifies a given vertex position
         * @default undefined
         */
        warpFunc: (vert: Base.Vector2) => void;
      }
      class MirrorDto<T> {
        constructor(manifold?: T, normal?: Base.Vector3);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [1,0,0]
         */
        normal: Base.Vector3;
      }
      class Scale3DDto<T> {
        constructor(manifold?: T, vector?: Base.Vector3);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [2,2,2]
         */
        vector: Base.Vector3;
      }
      class TranslateDto<T> {
        constructor(manifold?: T, vector?: Base.Vector3);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The translation vector
         * @default undefined
         */
        vector: Base.Vector3;
      }
      class TranslateByVectorsDto<T> {
        constructor(manifold?: T, vectors?: Base.Vector3[]);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The translation vector
         * @default undefined
         */
        vectors: Base.Vector3[];
      }
      class RotateDto<T> {
        constructor(manifold?: T, vector?: Base.Vector3);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The rotation vector in eulers
         * @default undefined
         */
        vector: Base.Vector3;
      }
      class RotateXYZDto<T> {
        constructor(manifold?: T, x?: number, y?: number, z?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The rotation vector in eulers on X axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        x: number;
        /**
         * The rotation vector in eulers on Y axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        y: number;
        /**
         * The rotation vector in eulers on Z axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        z: number;
      }
      class ScaleDto<T> {
        constructor(manifold?: T, factor?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default 2
         */
        factor: number;
      }
      class TranslateXYZDto<T> {
        constructor(manifold?: T, x?: number, y?: number, z?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The translation X axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        x: number;
        /**
         * The translation Y axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        y: number;
        /**
         * The translation Z axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        z: number;
      }
      class TransformDto<T> {
        constructor(manifold?: T, transform?: Base.TransformMatrix);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The transform matrix to apply
         * @default undefined
         */
        transform: Base.TransformMatrix;
      }
      class TransformsDto<T> {
        constructor(manifold?: T, transforms?: Base.TransformMatrixes);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * The transform matrixes to apply
         * @default undefined
         */
        transforms: Base.TransformMatrixes;
      }
      class ManifoldWarpDto<T> {
        constructor(manifold?: T, warpFunc?: (vert: Base.Vector3) => void);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * A function that modifies a given vertex position
         * @default undefined
         */
        warpFunc: (vert: Base.Vector3) => void;
      }
      class TwoCrossSectionsDto<T> {
        constructor(crossSection1?: T, crossSection2?: T);
        /**
         * Manifold shape
         */
        crossSection1: T;
        /**
         * Manifold shape
         */
        crossSection2: T;
      }
      class TwoManifoldsDto<T> {
        constructor(manifold1?: T, manifold2?: T);
        /**
         * Manifold shape
         */
        manifold1: T;
        /**
         * Manifold shape
         */
        manifold2: T;
      }
      class SplitManifoldsDto<T> {
        constructor(manifoldToSplit?: T, manifoldCutter?: T);
        /**
         * Manifold that will be split
         */
        manifoldToSplit: T;
        /**
         * Manifold cutter
         */
        manifoldCutter: T;
      }
      class TrimByPlaneDto<T> {
        constructor(manifold?: T, normal?: Base.Vector3, originOffset?: number);
        /**
         * Manifold that will be trimmed
         */
        manifold: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [1,0,0]
         */
        normal: Base.Vector3;
        /**
         * The offset from the origin
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        originOffset: number;
      }
      class SplitByPlaneDto<T> {
        constructor(manifold?: T, normal?: Base.Vector3, originOffset?: number);
        /**
         * Manifold that will be split
         */
        manifold: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [1,0,0]
         */
        normal: Base.Vector3;
        /**
         * The offset from the origin
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        originOffset: number;
      }
      class SplitByPlaneOnOffsetsDto<T> {
        constructor(
          manifold?: T,
          normal?: Base.Vector3,
          originOffsets?: number[]
        );
        /**
         * Manifold that will be split
         */
        manifold: T;
        /**
         * The normal vector of the plane to be mirrored over
         * @default [1,0,0]
         */
        normal: Base.Vector3;
        /**
         * The offsets from the origin
         * @default [0]
         */
        originOffsets: number[];
      }
      class ManifoldsDto<T> {
        constructor(manifolds?: T[]);
        /**
         * Manifolds
         */
        manifolds: T[];
      }
      class ManifoldToMeshDto<T> {
        constructor(manifold?: T, normalIdx?: number);
        /**
         * Manifold shape
         */
        manifold: T;
        /**
         * Optional normal index
         */
        normalIdx?: number;
      }
      class ManifoldsToMeshesDto<T> {
        constructor(manifolds?: T[], normalIdx?: number[]);
        /**
         * Manifold shape
         */
        manifolds: T[];
        /**
         * Optional normal indexes
         */
        normalIdx?: number[];
      }
      class DecomposeManifoldOrCrossSectionDto<T> {
        constructor(manifoldOrCrossSection?: T, normalIdx?: number);
        /**
         * Manifold shape
         */
        manifoldOrCrossSection: T;
        /**
         * Optional normal index
         */
        normalIdx?: number;
      }
      class ManifoldOrCrossSectionDto<T> {
        constructor(manifoldOrCrossSection?: T);
        /**
         * Manifold or cross section
         */
        manifoldOrCrossSection: T;
      }
      class ManifoldsOrCrossSectionsDto<T> {
        constructor(manifoldsOrCrossSections?: T[]);
        /**
         * Manifolds or cross sections
         */
        manifoldsOrCrossSections: T[];
      }
      class DecomposeManifoldsOrCrossSectionsDto<T> {
        constructor(manifoldsOrCrossSections?: T[], normalIdx?: number[]);
        /**
         * Manifold shape
         */
        manifoldsOrCrossSections: T[];
        /**
         * Optional normal indexes
         */
        normalIdx?: number[];
      }
    }
    declare namespace OCCT {
      type GeomCurvePointer = {
        hash: number;
        type: string;
      };
      type Geom2dCurvePointer = {
        hash: number;
        type: string;
      };
      type GeomSurfacePointer = {
        hash: number;
        type: string;
      };
      type TopoDSVertexPointer = {
        hash: number;
        type: string;
      };
      type TopoDSEdgePointer = {
        hash: number;
        type: string;
      };
      type TopoDSWirePointer = {
        hash: number;
        type: string;
      };
      type TopoDSFacePointer = {
        hash: number;
        type: string;
      };
      type TopoDSShellPointer = {
        hash: number;
        type: string;
      };
      type TopoDSSolidPointer = {
        hash: number;
        type: string;
      };
      type TopoDSCompSolidPointer = {
        hash: number;
        type: string;
      };
      type TopoDSCompoundPointer = {
        hash: number;
        type: string;
      };
      type TopoDSShapePointer =
        | TopoDSVertexPointer
        | TopoDSEdgePointer
        | TopoDSWirePointer
        | TopoDSFacePointer
        | TopoDSShellPointer
        | TopoDSSolidPointer
        | TopoDSCompoundPointer;
      enum joinTypeEnum {
        arc = "arc",
        intersection = "intersection",
        tangent = "tangent",
      }
      enum bRepOffsetModeEnum {
        skin = "skin",
        pipe = "pipe",
        rectoVerso = "rectoVerso",
      }
      enum approxParametrizationTypeEnum {
        approxChordLength = "approxChordLength",
        approxCentripetal = "approxCentripetal",
        approxIsoParametric = "approxIsoParametric",
      }
      enum directionEnum {
        outside = "outside",
        inside = "inside",
        middle = "middle",
      }
      enum fileTypeEnum {
        iges = "iges",
        step = "step",
      }
      enum topAbsOrientationEnum {
        forward = "forward",
        reversed = "reversed",
        internal = "internal",
        external = "external",
      }
      enum topAbsStateEnum {
        in = "in",
        out = "out",
        on = "on",
        unknown = "unknown",
      }
      enum shapeTypeEnum {
        unknown = "unknown",
        vertex = "vertex",
        edge = "edge",
        wire = "wire",
        face = "face",
        shell = "shell",
        solid = "solid",
        compSolid = "compSolid",
        compound = "compound",
        shape = "shape",
      }
      enum gccEntPositionEnum {
        unqualified = "unqualified",
        enclosing = "enclosing",
        enclosed = "enclosed",
        outside = "outside",
        noqualifier = "noqualifier",
      }
      enum positionResultEnum {
        keepSide1 = "keepSide1",
        keepSide2 = "keepSide2",
        all = "all",
      }
      enum circleInclusionEnum {
        none = "none",
        keepSide1 = "keepSide1",
        keepSide2 = "keepSide2",
      }
      enum twoCircleInclusionEnum {
        none = "none",
        outside = "outside",
        inside = "inside",
        outsideInside = "outsideInside",
        insideOutside = "insideOutside",
      }
      enum fourSidesStrictEnum {
        outside = "outside",
        inside = "inside",
        outsideInside = "outsideInside",
        insideOutside = "insideOutside",
      }
      enum twoSidesStrictEnum {
        outside = "outside",
        inside = "inside",
      }
      enum combinationCirclesForFaceEnum {
        allWithAll = "allWithAll",
        inOrder = "inOrder",
        inOrderClosed = "inOrderClosed",
      }
      enum typeSpecificityEnum {
        curve = 0,
        edge = 1,
        wire = 2,
        face = 3,
      }
      enum pointProjectionTypeEnum {
        all = "all",
        closest = "closest",
        furthest = "furthest",
        closestAndFurthest = "closestAndFurthest",
      }
      enum geomFillTrihedronEnum {
        isCorrectedFrenet = "isCorrectedFrenet",
        isFixed = "isFixed",
        isFrenet = "isFrenet",
        isConstantNormal = "isConstantNormal",
        isDarboux = "isDarboux",
        isGuideAC = "isGuideAC",
        isGuidePlan = "isGuidePlan",
        isGuideACWithContact = "isGuideACWithContact",
        isGuidePlanWithContact = "isGuidePlanWithContact",
        isDiscreteTrihedron = "isDiscreteTrihedron",
      }
      enum dxfColorFormatEnum {
        aci = "aci",
        truecolor = "truecolor",
      }
      enum dxfAcadVersionEnum {
        AC1009 = "AC1009",
        AC1015 = "AC1015",
      }
      enum dimensionEndTypeEnum {
        none = "none",
        arrow = "arrow",
      }
      class DecomposedMeshDto {
        constructor(
          faceList?: DecomposedFaceDto[],
          edgeList?: DecomposedEdgeDto[]
        );
        /**
         * Face list for decomposed faces
         */
        faceList: DecomposedFaceDto[];
        /**
         * Edge list for decomposed edges
         */
        edgeList: DecomposedEdgeDto[];
        /**
         * The points list in a shape that includes vertex shapes
         */
        pointsList: Base.Point3[];
      }
      class DecomposedFaceDto {
        face_index: number;
        normal_coord: number[];
        number_of_triangles: number;
        tri_indexes: number[];
        vertex_coord: number[];
        vertex_coord_vec: Base.Vector3[];
        center_point: Base.Point3;
        center_normal: Base.Vector3;
        uvs: number[];
      }
      class DecomposedEdgeDto {
        edge_index: number;
        middle_point: Base.Point3;
        vertex_coord: Base.Vector3[];
      }
      class ShapesDto<T> {
        constructor(shapes?: T[]);
        /**
         * The OCCT shapes
         * @default undefined
         */
        shapes: T[];
      }
      class PointDto {
        constructor(point?: Base.Point3);
        /**
         * The point
         * @default [0, 0, 0]
         */
        point: Base.Point3;
      }
      class XYZDto {
        constructor(x?: number, y?: number, z?: number);
        /**
         * X coord
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        x: number;
        /**
         * Y coord
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        y: number;
        /**
         * Z coord
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        z: number;
      }
      class PointsDto {
        constructor(points?: Base.Point3[]);
        /**
         * The point
         * @default undefined
         */
        points: Base.Point3[];
      }
      class ConstraintTanLinesFromPtToCircleDto<T> {
        constructor(
          circle?: T,
          point?: Base.Point3,
          tolerance?: number,
          positionResult?: positionResultEnum,
          circleRemainder?: circleInclusionEnum
        );
        /**
         * The circle for tangent points
         * @default undefined
         */
        circle: T;
        /**
         * The point from which to find the lines
         * @default undefined
         */
        point: Base.Point3;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
        /**
         * Filters resulting lines by position
         * @default all
         */
        positionResult: positionResultEnum;
        /**
         * Splits provided circle on tangent points and adds it to the solutions
         * This only works when number of solutions contains 2 lines, when solution involves more than 4 lines, this option will be ignored.
         * @default none
         */
        circleRemainder: circleInclusionEnum;
      }
      class ConstraintTanLinesFromTwoPtsToCircleDto<T> {
        constructor(
          circle?: T,
          point1?: Base.Point3,
          point2?: Base.Point3,
          tolerance?: number,
          positionResult?: positionResultEnum,
          circleRemainder?: circleInclusionEnum
        );
        /**
         * The circle for tangent points
         * @default undefined
         */
        circle: T;
        /**
         * The point from which to find the lines
         * @default undefined
         */
        point1: Base.Point3;
        /**
         * The point from which to find the lines
         * @default undefined
         */
        point2: Base.Point3;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
        /**
         * Filters resulting lines by position
         * @default all
         */
        positionResult: positionResultEnum;
        /**
         * Splits provided circle on tangent points and adds it to the solutions
         * This only works when number of solutions contains 2 lines, when solution involves more than 4 lines, this option will be ignored.
         * @default none
         */
        circleRemainder: circleInclusionEnum;
      }
      class ConstraintTanLinesOnTwoCirclesDto<T> {
        constructor(
          circle1?: T,
          circle2?: T,
          tolerance?: number,
          positionResult?: positionResultEnum,
          circleRemainders?: twoCircleInclusionEnum
        );
        /**
         * The first circle for tangential lines
         * @default undefined
         */
        circle1: T;
        /**
         * The second circle for tangential lines
         * @default undefined
         */
        circle2: T;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
        /**
         * Filters resulting lines by position relative to circles
         * @default all
         */
        positionResult: positionResultEnum;
        /**
         * Splits provided circles on tangent points and returns those as part of the solutions
         * This only works when number of solutions is limited to 2 lines, when solution involves more than 4 lines, this option will be ignored.
         * @default none
         */
        circleRemainders: twoCircleInclusionEnum;
      }
      class ConstraintTanCirclesOnTwoCirclesDto<T> {
        constructor(
          circle1?: T,
          circle2?: T,
          tolerance?: number,
          radius?: number
        );
        /**
         * The first circle for tangential lines
         * @default undefined
         */
        circle1: T;
        /**
         * The second circle for tangential lines
         * @default undefined
         */
        circle2: T;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
        /**
         * Radius of the circles being constructed
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
      }
      class ConstraintTanCirclesOnCircleAndPntDto<T> {
        constructor(
          circle?: T,
          point?: Base.Point3,
          tolerance?: number,
          radius?: number
        );
        /**
         * The first circle for tangential lines
         * @default undefined
         */
        circle: T;
        /**
         * The second circle for tangential lines
         * @default undefined
         */
        point: Base.Point3;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
        /**
         * Radius of the circles being constructed
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
      }
      class CurveAndSurfaceDto<T, U> {
        constructor(curve?: T, surface?: U);
        /**
         * Curve
         * @default undefined
         */
        curve: T;
        /**
         * Surface
         * @default undefined
         */
        surface: U;
      }
      class FilletTwoEdgesInPlaneDto<T> {
        constructor(
          edge1?: T,
          edge2?: T,
          planeOrigin?: Base.Point3,
          planeDirection?: Base.Vector3,
          radius?: number,
          solution?: number
        );
        /**
         * First OCCT edge to fillet
         * @default undefined
         */
        edge1: T;
        /**
         * Second OCCT edge to fillet
         * @default undefined
         */
        edge2: T;
        /**
         * Plane origin that is also used to find the closest solution if two solutions exist.
         * @default [0, 0, 0]
         */
        planeOrigin: Base.Point3;
        /**
         * Plane direction for fillet
         * @default [0, 1, 0]
         */
        planeDirection: Base.Vector3;
        /**
         * Radius of the fillet
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * if solution is -1 planeOrigin chooses a particular fillet in case of several fillets may be constructed (for example, a circle intersecting a segment in 2 points). Put the intersecting (or common) point of the edges
         * @default -1
         * @optional true
         */
        solution?: number;
      }
      class ClosestPointsOnShapeFromPointsDto<T> {
        constructor(shape?: T, points?: Base.Point3[]);
        /**
         * The OCCT shape
         * @default undefined
         */
        shape: T;
        /**
         * The list of points
         * @default undefined
         */
        points: Base.Point3[];
      }
      class BoundingBoxDto {
        constructor(bbox?: BoundingBoxPropsDto);
        /**
         * Bounding box
         * @default undefined
         */
        bbox?: BoundingBoxPropsDto;
      }
      class BoundingBoxPropsDto {
        constructor(
          min?: Base.Point3,
          max?: Base.Point3,
          center?: Base.Point3,
          size?: Base.Vector3
        );
        /**
         * Minimum point of the bounding box
         * @default [0, 0, 0]
         */
        min: Base.Point3;
        /**
         * Maximum point of the bounding box
         * @default [0, 0, 0]
         */
        max: Base.Point3;
        /**
         * Center point of the bounding box
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Size of the bounding box
         * @default [0, 0, 0]
         */
        size: Base.Vector3;
      }
      class BoundingSpherePropsDto {
        constructor(center?: Base.Point3, radius?: number);
        /**
         * Center point of the bounding box
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Radius of the bounding sphere
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
      }
      class SplitWireOnPointsDto<T> {
        constructor(shape?: T, points?: Base.Point3[]);
        /**
         * The OCCT wire shape
         * @default undefined
         */
        shape: T;
        /**
         * The list of points
         * @default undefined
         */
        points: Base.Point3[];
      }
      class ClosestPointsOnShapesFromPointsDto<T> {
        constructor(shapes?: T[], points?: Base.Point3[]);
        /**
         * The OCCT shapes
         * @default undefined
         */
        shapes: T[];
        /**
         * The list of points
         * @default undefined
         */
        points: Base.Point3[];
      }
      class ClosestPointsBetweenTwoShapesDto<T> {
        constructor(shape1?: T, shape2?: T);
        /**
         * First OCCT shape
         * @default undefined
         */
        shape1: T;
        /**
         * Second OCCT shape
         * @default undefined
         */
        shape2: T;
      }
      class FaceFromSurfaceAndWireDto<T, U> {
        constructor(surface?: T, wire?: U, inside?: boolean);
        /**
         * Surface from which to create a face
         * @default undefined
         */
        surface: T;
        /**
         * Wire that represents a boundary on the surface to delimit the face
         * @default undefined
         */
        wire: U;
        /**
         * Indicates wether face should be created inside or outside the wire
         * @default true
         */
        inside: boolean;
      }
      class WireOnFaceDto<T, U> {
        constructor(wire?: T, face?: U);
        /**
         * Wire to place on face
         * @default undefined
         */
        wire: T;
        /**
         * Face on which the wire will be placed
         * @default undefined
         */
        face: U;
      }
      class DrawShapeDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          faceOpacity?: number,
          edgeOpacity?: number,
          edgeColour?: Base.Color,
          faceMaterial?: Base.Material,
          faceColour?: Base.Color,
          edgeWidth?: number,
          drawEdges?: boolean,
          drawFaces?: boolean,
          drawVertices?: boolean,
          vertexColour?: Base.Color,
          vertexSize?: number,
          precision?: number,
          drawEdgeIndexes?: boolean,
          edgeIndexHeight?: number,
          edgeIndexColour?: Base.Color,
          drawFaceIndexes?: boolean,
          faceIndexHeight?: number,
          faceIndexColour?: Base.Color,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number
        );
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape?: T;
        /**
         * Face opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        faceOpacity: number;
        /**
         * Edge opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        edgeOpacity: number;
        /**
         * Hex colour string for the edges
         * @default #ffffff
         */
        edgeColour: Base.Color;
        /**
         * Face material
         * @default undefined
         * @optional true
         */
        faceMaterial?: Base.Material;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour: Base.Color;
        /**
         * Edge width
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        edgeWidth: number;
        /**
         * You can turn off drawing of edges via this property
         * @default true
         */
        drawEdges: boolean;
        /**
         * You can turn off drawing of faces via this property
         * @default true
         */
        drawFaces: boolean;
        /**
         * You can turn off drawing of vertexes via this property
         * @default false
         */
        drawVertices: boolean;
        /**
         * Color of the vertices that will be drawn
         * @default #ff00ff
         */
        vertexColour: string;
        /**
         * The size of a vertices that will be drawn
         * @default 0.03
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        vertexSize: number;
        /**
         * Precision of the mesh that will be generated for the shape, lower number will mean more triangles
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        precision: number;
        /**
         * Draw index of edges in space
         * @default false
         */
        drawEdgeIndexes: boolean;
        /**
         * Indicates the edge index height if they are drawn
         * @default 0.06
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        edgeIndexHeight: number;
        /**
         * Edge index colour if the edges are drawn
         * @default #ff00ff
         */
        edgeIndexColour: Base.Color;
        /**
         * Draw indexes of faces in space
         * @default false
         */
        drawFaceIndexes: boolean;
        /**
         * Indicates the edge index height if they are drawn
         * @default 0.06
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        faceIndexHeight: number;
        /**
         * Edge index colour if the edges are drawn
         * @default #0000ff
         */
        faceIndexColour: Base.Color;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawShapesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shapes?: T[],
          faceOpacity?: number,
          edgeOpacity?: number,
          edgeColour?: Base.Color,
          faceMaterial?: Base.Material,
          faceColour?: Base.Color,
          edgeWidth?: number,
          drawEdges?: boolean,
          drawFaces?: boolean,
          drawVertices?: boolean,
          vertexColour?: Base.Color,
          vertexSize?: number,
          precision?: number,
          drawEdgeIndexes?: boolean,
          edgeIndexHeight?: number,
          edgeIndexColour?: Base.Color,
          drawFaceIndexes?: boolean,
          faceIndexHeight?: number,
          faceIndexColour?: Base.Color,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number
        );
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shapes: T[];
        /**
         * Face opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        faceOpacity: number;
        /**
         * Edge opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        edgeOpacity: number;
        /**
         * Hex colour string for the edges
         * @default #ffffff
         */
        edgeColour: Base.Color;
        /**
         * Face material
         * @default undefined
         * @optional true
         */
        faceMaterial?: Base.Material;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour: Base.Color;
        /**
         * Edge width
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        edgeWidth: number;
        /**
         * You can turn off drawing of edges via this property
         * @default true
         */
        drawEdges: boolean;
        /**
         * You can turn off drawing of faces via this property
         * @default true
         */
        drawFaces: boolean;
        /**
         * You can turn off drawing of vertexes via this property
         * @default false
         */
        drawVertices: boolean;
        /**
         * Color of the vertices that will be drawn
         * @default #ff00ff
         */
        vertexColour: string;
        /**
         * The size of a vertices that will be drawn
         * @default 0.03
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        vertexSize: number;
        /**
         * Precision of the mesh that will be generated for the shape, lower number will mean more triangles
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        precision: number;
        /**
         * Draw index of edges in space
         * @default false
         */
        drawEdgeIndexes: boolean;
        /**
         * Indicates the edge index height if they are drawn
         * @default 0.06
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        edgeIndexHeight: number;
        /**
         * Edge index colour if the edges are drawn
         * @default #ff00ff
         */
        edgeIndexColour: Base.Color;
        /**
         * Draw indexes of faces in space
         * @default false
         */
        drawFaceIndexes: boolean;
        /**
         * Indicates the edge index height if they are drawn
         * @default 0.06
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        faceIndexHeight: number;
        /**
         * Edge index colour if the edges are drawn
         * @default #0000ff
         */
        faceIndexColour: Base.Color;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class FaceSubdivisionDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrDivisionsU?: number,
          nrDivisionsV?: number,
          shiftHalfStepU?: boolean,
          removeStartEdgeU?: boolean,
          removeEndEdgeU?: boolean,
          shiftHalfStepV?: boolean,
          removeStartEdgeV?: boolean,
          removeEndEdgeV?: boolean
        );
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Number of points that will be added on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrDivisionsU: number;
        /**
         * Number  of points that will be added on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrDivisionsV: number;
        /**
         * Sometimes you want to shift your points half way the step distance, especially on periodic surfaces
         * @default false
         */
        shiftHalfStepU: boolean;
        /**
         * Removes start edge points on U
         * @default false
         */
        removeStartEdgeU: boolean;
        /**
         * Removes end edge points on U
         * @default false
         */
        removeEndEdgeU: boolean;
        /**
         * Sometimes you want to shift your points half way the step distance, especially on periodic surfaces
         * @default false
         */
        shiftHalfStepV: boolean;
        /**
         * Removes start edge points on V
         * @default false
         */
        removeStartEdgeV: boolean;
        /**
         * Removes end edge points on V
         * @default false
         */
        removeEndEdgeV: boolean;
      }
      class FaceSubdivisionToWiresDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrDivisions?: number,
          isU?: boolean,
          shiftHalfStep?: boolean,
          removeStart?: boolean,
          removeEnd?: boolean
        );
        /**
         * Openascade Face
         * @default undefined
         */
        shape: T;
        /**
         * Number of points that will be added on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrDivisions: number;
        /**
         * Linear subdivision direction true - U, false - V
         * @default true
         */
        isU: boolean;
        /**
         * Sometimes you want to shift your wires half way the step distance, especially on periodic surfaces
         * @default false
         */
        shiftHalfStep: boolean;
        /**
         * Removes start wire
         * @default false
         */
        removeStart: boolean;
        /**
         * Removes end wire
         * @default false
         */
        removeEnd: boolean;
      }
      class FaceSubdivideToRectangleWiresDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrRectanglesU?: number,
          nrRectanglesV?: number,
          scalePatternU?: number[],
          scalePatternV?: number[],
          filletPattern?: number[],
          inclusionPattern?: boolean[],
          offsetFromBorderU?: number,
          offsetFromBorderV?: number
        );
        /**
         * Openascade Face
         * @default undefined
         */
        shape: T;
        /**
         * Number of rectangles on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrRectanglesU: number;
        /**
         * Number of rectangles on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrRectanglesV: number;
        /**
         * Rectangle scale pattern on u direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternU: number[];
        /**
         * Rectangle scale pattern on v direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternV: number[];
        /**
         * Rectangle fillet scale pattern - numbers between 0 and 1, if 0 is used, no fillet is applied,
         * if 1 is used, the fillet will be exactly half of the length of the shorter side of the rectangle
         * @default undefined
         * @optional true
         */
        filletPattern: number[];
        /**
         * Rectangle inclusion pattern - true means that the rectangle will be included,
         * false means that the rectangle will be removed from the face
         * @default undefined
         * @optional true
         */
        inclusionPattern: boolean[];
        /**
         * If offset on U is bigger then 0 we will use a smaller space for rectangles to be placed. This means that even rectangle of U param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderU: number;
        /**
         * If offset on V is bigger then 0 we will use a smaller space for rectangles to be placed. This means that even rectangle of V param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderV: number;
      }
      class FaceSubdivideToHexagonWiresDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrHexagonsU?: number,
          nrHexagonsV?: number,
          flatU?: boolean,
          scalePatternU?: number[],
          scalePatternV?: number[],
          filletPattern?: number[],
          inclusionPattern?: boolean[],
          offsetFromBorderU?: number,
          offsetFromBorderV?: number,
          extendUUp?: boolean,
          extendUBottom?: boolean,
          extendVUp?: boolean,
          extendVBottom?: boolean
        );
        /**
         * Openascade Face
         * @default undefined
         */
        shape?: T;
        /**
         * Number of hexagons on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsU?: number;
        /**
         * Number of hexagons on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsV?: number;
        flatU: boolean;
        /**
         * Hexagon scale pattern on u direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternU?: number[];
        /**
         * Hexagon scale pattern on v direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternV?: number[];
        /**
         * Hexagon fillet scale pattern - numbers between 0 and 1, if 0 is used, no fillet is applied,
         * if 1 is used, the fillet will be exactly half of the length of the shortest segment of the hexagon
         * @default undefined
         * @optional true
         */
        filletPattern?: number[];
        /**
         * Hexagon inclusion pattern - true means that the hexagon will be included,
         * false means that the hexagon will be removed from the face
         * @default undefined
         * @optional true
         */
        inclusionPattern?: boolean[];
        /**
         * If offset on U is bigger then 0 we will use a smaller space for hexagons to be placed. This means that even hexagon of U param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderU?: number;
        /**
         * If offset on V is bigger then 0 we will use a smaller space for hexagons to be placed. This means that even hexagon of V param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderV?: number;
        /**
         * If true, we will extend the hexagons beyond the face u up border by their pointy tops
         * @default false
         */
        extendUUp?: boolean;
        /**
         * If true, we will extend the hexagons beyond the face u bottom border by their pointy tops
         * @default false
         */
        extendUBottom?: boolean;
        /**
         * If true, we will extend the hexagons beyond the face v upper border by their half width
         * @default false
         */
        extendVUp?: boolean;
        /**
         * If true, we will extend the hexagons beyond the face v bottom border by their half width
         * @default false
         */
        extendVBottom?: boolean;
      }
      class FaceSubdivideToHexagonHolesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrHexagonsU?: number,
          nrHexagonsV?: number,
          flatU?: boolean,
          holesToFaces?: boolean,
          scalePatternU?: number[],
          scalePatternV?: number[],
          filletPattern?: number[],
          inclusionPattern?: boolean[],
          offsetFromBorderU?: number,
          offsetFromBorderV?: number
        );
        /**
         * Openascade Face
         * @default undefined
         */
        shape?: T;
        /**
         * Number of hexagons on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsU?: number;
        /**
         * Number of hexagons on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsV?: number;
        flatU: boolean;
        /**
         * If true, we will also create holes as faces
         * @default false
         */
        holesToFaces?: boolean;
        /**
         * Hexagon scale pattern on u direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternU?: number[];
        /**
         * Hexagon scale pattern on v direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternV?: number[];
        /**
         * Hexagon fillet scale pattern - numbers between 0 and 1, if 0 is used, no fillet is applied,
         * if 1 is used, the fillet will be exactly half of the length of the shortest segment of the hexagon
         * @default undefined
         * @optional true
         */
        filletPattern?: number[];
        /**
         * Hexagon inclusion pattern - true means that the hexagon will be included,
         * false means that the hexagon will be removed from the face
         * @default undefined
         * @optional true
         */
        inclusionPattern?: boolean[];
        /**
         * If offset on U is bigger then 0 we will use a smaller space for hexagons to be placed. This means that even hexagon of U param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderU?: number;
        /**
         * If offset on V is bigger then 0 we will use a smaller space for hexagons to be placed. This means that even hexagon of V param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderV?: number;
      }
      class FaceSubdivideToRectangleHolesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrRectanglesU?: number,
          nrRectanglesV?: number,
          scalePatternU?: number[],
          scalePatternV?: number[],
          filletPattern?: number[],
          inclusionPattern?: boolean[],
          holesToFaces?: boolean,
          offsetFromBorderU?: number,
          offsetFromBorderV?: number
        );
        /**
         * Openascade Face
         * @default undefined
         */
        shape: T;
        /**
         * Number of rectangles on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrRectanglesU: number;
        /**
         * Number of rectangles on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrRectanglesV: number;
        /**
         * Rectangle scale pattern on u direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternU: number[];
        /**
         * Rectangle scale pattern on v direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternV: number[];
        /**
         * Rectangle fillet scale pattern - numbers between 0 and 1, if 0 is used, no fillet is applied,
         * if 1 is used, the fillet will be exactly half of the length of the shorter side of the rectangle
         * @default undefined
         * @optional true
         */
        filletPattern: number[];
        /**
         * Rectangle inclusion pattern - true means that the rectangle will be included,
         * false means that the rectangle will be removed from the face
         * @default undefined
         * @optional true
         */
        inclusionPattern: boolean[];
        /**
         * If true, we will also output the faces for all the rectangles. The first face in the result will be the original face with holes punched, while the rest will be the rectangles
         * @default false
         */
        holesToFaces: boolean;
        /**
         * If offset on U is bigger then 0 we will use a smaller space for rectangles to be placed. This means that even rectangle of U param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderU: number;
        /**
         * If offset on V is bigger then 0 we will use a smaller space for rectangles to be placed. This means that even rectangle of V param 1 will be offset from the face border
         * That is often required to create a pattern that is not too close to the face border
         * It should not be bigger then half of the total width of the face as that will create problems
         * @default 0
         * @minimum 0
         * @maximum 0.5
         * @step 0.01
         */
        offsetFromBorderV: number;
      }
      class FaceSubdivisionControlledDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          nrDivisionsU?: number,
          nrDivisionsV?: number,
          shiftHalfStepNthU?: number,
          shiftHalfStepUOffsetN?: number,
          removeStartEdgeNthU?: number,
          removeStartEdgeUOffsetN?: number,
          removeEndEdgeNthU?: number,
          removeEndEdgeUOffsetN?: number,
          shiftHalfStepNthV?: number,
          shiftHalfStepVOffsetN?: number,
          removeStartEdgeNthV?: number,
          removeStartEdgeVOffsetN?: number,
          removeEndEdgeNthV?: number,
          removeEndEdgeVOffsetN?: number
        );
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Number of subdivisions on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrDivisionsU: number;
        /**
         * Number of subdivisions on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrDivisionsV: number;
        /**
         * Shift half step every nth U row
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shiftHalfStepNthU: number;
        /**
         * Offset for shift half step every nth U row
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shiftHalfStepUOffsetN: number;
        /**
         * Removes start edge points on U
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeStartEdgeNthU: number;
        /**
         * Offset for remove start edge points on U
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeStartEdgeUOffsetN: number;
        /**
         * Removes end edge points on U
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeEndEdgeNthU: number;
        /**
         * Offset for remove end edge points on U
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeEndEdgeUOffsetN: number;
        /**
         * Shift half step every nth V row
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shiftHalfStepNthV: number;
        /**
         * Offset for shift half step every nth V row
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shiftHalfStepVOffsetN: number;
        /**
         * Removes start edge points on V
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeStartEdgeNthV: number;
        /**
         * Offset for remove start edge points on V
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeStartEdgeVOffsetN: number;
        /**
         * Removes end edge points on V
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeEndEdgeNthV: number;
        /**
         * Offset for remove end edge points on V
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        removeEndEdgeVOffsetN: number;
      }
      class FaceLinearSubdivisionDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          shape?: T,
          isU?: boolean,
          param?: number,
          nrPoints?: number,
          shiftHalfStep?: boolean,
          removeStartPoint?: boolean,
          removeEndPoint?: boolean
        );
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Linear subdivision direction true - U, false - V
         * @default true
         */
        isU: boolean;
        /**
         * Param on direction 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        param: number;
        /**
         * Number of subdivisions on opposite direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrPoints: number;
        /**
         * Sometimes you want to shift your points half way the step distance, especially on periodic surfaces
         * @default false
         */
        shiftHalfStep: boolean;
        /**
         * Removes first point
         * @default false
         */
        removeStartPoint: boolean;
        /**
         * Removes last point
         * @default false
         */
        removeEndPoint: boolean;
      }
      class WireAlongParamDto<T> {
        /**
         * Provide options without default values
         */
        constructor(shape?: T, isU?: boolean, param?: number);
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Linear subdivision direction true - U, false - V
         * @default true
         */
        isU: boolean;
        /**
         * Param on direction 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        param: number;
      }
      class WiresAlongParamsDto<T> {
        /**
         * Provide options without default values
         */
        constructor(shape?: T, isU?: boolean, params?: number[]);
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Linear subdivision direction true - U, false - V
         * @default true
         */
        isU: boolean;
        /**
         * Params on direction 0 - 1
         * @default undefined
         */
        params: number[];
      }
      class DataOnUVDto<T> {
        /**
         * Provide options without default values
         */
        constructor(shape?: T, paramU?: number, paramV?: number);
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Param on U direction 0 to 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        paramU: number;
        /**
         * Param on V direction 0 to 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        paramV: number;
      }
      class DataOnUVsDto<T> {
        /**
         * Provide options without default values
         */
        constructor(shape?: T, paramsUV?: [number, number][]);
        /**
         * Brep OpenCascade geometry
         * @default undefined
         */
        shape: T;
        /**
         * Params uv
         * @default [[0.5, 0.5]]
         */
        paramsUV: [number, number][];
      }
      class PolygonDto {
        constructor(points?: Base.Point3[]);
        /**
         * Points points
         * @default undefined
         */
        points: Base.Point3[];
      }
      class PolygonsDto {
        constructor(polygons?: PolygonDto[], returnCompound?: boolean);
        /**
         * Polygons
         * @default undefined
         */
        polygons: PolygonDto[];
        /**
         * Indicates whether the shapes should be returned as a compound
         */
        returnCompound: boolean;
      }
      class PolylineDto {
        constructor(points?: Base.Point3[]);
        /**
         * Points points
         * @default undefined
         */
        points: Base.Point3[];
      }
      class PolylineBaseDto {
        constructor(polyline?: Base.Polyline3);
        /**
         * Polyline
         * @default undefined
         */
        polyline: Base.Polyline3;
      }
      class PolylinesBaseDto {
        constructor(polylines?: Base.Polyline3[]);
        /**
         * Polylines
         * @default undefined
         */
        polylines: Base.Polyline3[];
      }
      class LineBaseDto {
        constructor(line?: Base.Line3);
        /**
         * Line
         * @default undefined
         */
        line: Base.Line3;
      }
      class LinesBaseDto {
        constructor(lines?: Base.Line3[]);
        /**
         * Lines
         * @default undefined
         */
        lines: Base.Line3[];
      }
      class SegmentBaseDto {
        constructor(segment?: Base.Segment3);
        /**
         * Segment
         * @default undefined
         */
        segment: Base.Segment3;
      }
      class SegmentsBaseDto {
        constructor(segments?: Base.Segment3[]);
        /**
         * Segments
         * @default undefined
         */
        segments: Base.Segment3[];
      }
      class TriangleBaseDto {
        constructor(triangle?: Base.Triangle3);
        /**
         * Triangle
         * @default undefined
         */
        triangle: Base.Triangle3;
      }
      class MeshBaseDto {
        constructor(mesh?: Base.Mesh3);
        /**
         * Mesh
         * @default undefined
         */
        mesh: Base.Mesh3;
      }
      class PolylinesDto {
        constructor(polylines?: PolylineDto[], returnCompound?: boolean);
        /**
         * Polylines
         * @default undefined
         */
        polylines: PolylineDto[];
        /**
         * Indicates whether the shapes should be returned as a compound
         */
        returnCompound: boolean;
      }
      class SquareDto {
        constructor(
          size?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * size of square
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        size: number;
        /**
         * Center of the square
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the square
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class RectangleDto {
        constructor(
          width?: number,
          length?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * width of the rectangle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        width: number;
        /**
         * Height of the rectangle
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        length: number;
        /**
         * Center of the rectangle
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the rectangle
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class LPolygonDto {
        constructor(
          widthFirst?: number,
          lengthFirst?: number,
          widthSecond?: number,
          lengthSecond?: number,
          align?: directionEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Width of the first side of L polygon
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        widthFirst: number;
        /**
         * Length of the first side of L polygon
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        lengthFirst: number;
        /**
         * Width of the second side of L polygon
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        widthSecond: number;
        /**
         * Length of the second side of L polygon
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        lengthSecond: number;
        /**
         * Indicates if the L polygon should be aligned inside/outside or middle
         * @default outside
         */
        align: directionEnum;
        /**
         * Rotation of the L polygon
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Center of the L polygon
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the  L polygon
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class IBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Width of the I-beam (flange width)
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Height of the I-beam
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Thickness of the web (vertical part)
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        webThickness: number;
        /**
         * Thickness of the flanges (horizontal parts)
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        flangeThickness: number;
        /**
         * Alignment of the profile origin
         * @default midMid
         */
        alignment: Base.basicAlignmentEnum;
        /**
         * Rotation of the I-beam profile in degrees
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Center of the I-beam profile
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the I-beam profile
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class HBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Width of the H-beam (flange width)
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Height of the H-beam
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Thickness of the web (vertical part)
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        webThickness: number;
        /**
         * Thickness of the flanges (horizontal parts)
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        flangeThickness: number;
        /**
         * Alignment of the profile origin
         * @default midMid
         */
        alignment: Base.basicAlignmentEnum;
        /**
         * Rotation of the H-beam profile in degrees
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Center of the H-beam profile
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the H-beam profile
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class TBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Width of the T-beam (flange width)
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Height of the T-beam
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Thickness of the web (vertical part)
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        webThickness: number;
        /**
         * Thickness of the flange (horizontal part)
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        flangeThickness: number;
        /**
         * Alignment of the profile origin
         * @default midMid
         */
        alignment: Base.basicAlignmentEnum;
        /**
         * Rotation of the T-beam profile in degrees
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Center of the T-beam profile
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the T-beam profile
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class UBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          flangeWidth?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Overall width of the U-beam
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Height of the U-beam
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Thickness of the web (back part)
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        webThickness: number;
        /**
         * Thickness of the flanges (side parts)
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        flangeThickness: number;
        /**
         * Width of the flanges (how far they extend inward)
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        flangeWidth: number;
        /**
         * Alignment of the profile origin
         * @default midMid
         */
        alignment: Base.basicAlignmentEnum;
        /**
         * Rotation of the U-beam profile in degrees
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Center of the U-beam profile
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the U-beam profile
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class ExtrudedSolidDto {
        constructor(
          extrusionLengthFront?: number,
          extrusionLengthBack?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
        /**
         * Center of the solid
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of extrusion
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class IBeamProfileSolidDto extends IBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class HBeamProfileSolidDto extends HBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class TBeamProfileSolidDto extends TBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class UBeamProfileSolidDto extends UBeamProfileDto {
        constructor(
          width?: number,
          height?: number,
          webThickness?: number,
          flangeThickness?: number,
          flangeWidth?: number,
          alignment?: Base.basicAlignmentEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class BoxDto {
        constructor(
          width?: number,
          length?: number,
          height?: number,
          center?: Base.Point3,
          originOnCenter?: boolean
        );
        /**
         * Width of the box
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the box
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the box
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Center of the box
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Force origin to be on the center of the cube
         * @default true
         */
        originOnCenter?: boolean;
      }
      class CubeDto {
        constructor(
          size?: number,
          center?: Base.Point3,
          originOnCenter?: boolean
        );
        /**
         * Size of the cube
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Center of the box
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Force origin to be on the center of the cube
         * @default true
         */
        originOnCenter?: boolean;
      }
      class BoxFromCornerDto {
        constructor(
          width?: number,
          length?: number,
          height?: number,
          corner?: Base.Point3
        );
        /**
         * Width of the box
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Length of the box
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Height of the box
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Corner of the box
         * @default [0, 0, 0]
         */
        corner: Base.Point3;
      }
      class SphereDto {
        constructor(radius?: number, center?: Base.Point3);
        /**
         * Radius of the sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Center of the sphere
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class ConeDto {
        constructor(
          radius1?: number,
          radius2?: number,
          height?: number,
          angle?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * First radius of the cone
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius1: number;
        /**
         * Second radius of the cone
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius2: number;
        /**
         * Height of the cone
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Angle of the cone
         * @default 360
         * @minimum 0
         * @maximum 360
         * @step 1
         */
        angle: number;
        /**
         * Center of the cone
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the cone
         * @default [0, 1, 0]
         */
        direction: Base.Point3;
      }
      class LineDto {
        constructor(start?: Base.Point3, end?: Base.Point3);
        /**
         * Start of the line
         * @default [0, 0, 0]
         */
        start: Base.Point3;
        /**
         * End of the line
         * @default [0, 1, 0]
         */
        end: Base.Point3;
      }
      class LineWithExtensionsDto {
        constructor(
          start?: Base.Point3,
          end?: Base.Point3,
          extensionStart?: number,
          extensionEnd?: number
        );
        /**
         * Start of the line
         * @default [0, 0, 0]
         */
        start: Base.Point3;
        /**
         * End of the line
         * @default [0, 1, 0]
         */
        end: Base.Point3;
        /**
         * Extension of the line on the start
         * @default 0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extensionStart: number;
        /**
         * Extension of the line on the end
         * @default 0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extensionEnd: number;
      }
      class LinesDto {
        constructor(lines?: LineDto[], returnCompound?: boolean);
        /**
         * Lines
         * @default undefined
         */
        lines: LineDto[];
        /**
         * Indicates whether the shapes should be returned as a compound
         */
        returnCompound: boolean;
      }
      class ArcEdgeTwoPointsTangentDto {
        constructor(
          start?: Base.Point3,
          tangentVec?: Base.Vector3,
          end?: Base.Point3
        );
        /**
         * Start of the arc
         * @default [0, 0, 0]
         */
        start: Base.Point3;
        /**
         * Tangent vector on first point of the edge
         * @default [0, 1, 0]
         */
        tangentVec: Base.Vector3;
        /**
         * End of the arc
         * @default [0, 0, 1]
         */
        end: Base.Point3;
      }
      class ArcEdgeCircleTwoPointsDto<T> {
        constructor(
          circle?: T,
          start?: Base.Point3,
          end?: Base.Point3,
          sense?: boolean
        );
        /**
         * Circular edge
         * @default undefined
         */
        circle: T;
        /**
         * Start of the arc on the circle
         * @default [0, 0, 0]
         */
        start: Base.Point3;
        /**
         * End of the arc on the circle
         * @default [0, 0, 1]
         */
        end: Base.Point3;
        /**
         * If true will sense the direction
         * @default true
         */
        sense: boolean;
      }
      class ArcEdgeCircleTwoAnglesDto<T> {
        constructor(
          circle?: T,
          alphaAngle1?: number,
          alphaAngle2?: number,
          sense?: boolean
        );
        /**
         * Circular edge
         * @default undefined
         */
        circle: T;
        /**
         * First angle
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        alphaAngle1: number;
        /**
         * End angle
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        alphaAngle2: number;
        /**
         * If true will sense the direction
         * @default true
         */
        sense: boolean;
      }
      class ArcEdgeCirclePointAngleDto<T> {
        constructor(
          circle?: T,
          alphaAngle?: number,
          alphaAngle2?: number,
          sense?: boolean
        );
        /**
         * Circular edge
         * @default undefined
         */
        circle: T;
        /**
         * Point on the circle from where to start the arc
         * @default undefined
         */
        point: Base.Point3;
        /**
         * Angle from point
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        alphaAngle: number;
        /**
         * If true will sense the direction
         * @default true
         */
        sense: boolean;
      }
      class ArcEdgeThreePointsDto {
        constructor(
          start?: Base.Point3,
          middle?: Base.Point3,
          end?: Base.Point3
        );
        /**
         * Start of the arc
         * @default [0, 0, 0]
         */
        start: Base.Point3;
        /**
         * Middle of the arc
         * @default [0, 1, 0]
         */
        middle: Base.Point3;
        /**
         * End of the arc
         * @default [0, 0, 1]
         */
        end: Base.Point3;
      }
      class CylinderDto {
        constructor(
          radius?: number,
          height?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          angle?: number,
          originOnCenter?: boolean
        );
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Height of the cylinder
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Center of the cylinder
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction for the cylinder
         * @default [0, 1, 0]
         */
        direction?: Base.Vector3;
        /**
         * Angle of the cylinder pie
         * @default 360
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        angle?: number;
        /**
         * Force origin to be on the center of cylinder
         * @default false
         */
        originOnCenter?: boolean;
      }
      class CylindersOnLinesDto {
        constructor(radius?: number, lines?: Base.Line3[]);
        /**
         * Radius of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Lines between which to span cylinders
         * @default undefined
         */
        lines: Base.Line3[];
      }
      class FilletDto<T> {
        constructor(
          shape?: T,
          radius?: number,
          radiusList?: number[],
          indexes?: number[]
        );
        /**
         * Shape to apply the fillets
         * @default undefined
         */
        shape: T;
        /**
         * Radius of the fillets
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         * @optional true
         */
        radius?: number;
        /**
         * Radius list
         * @default undefined
         * @optional true
         */
        radiusList?: number[];
        /**
         * List of edge indexes to which apply the fillet, if left empty all edges will be rounded
         * @default undefined
         * @optional true
         */
        indexes?: number[];
      }
      class FilletShapesDto<T> {
        constructor(
          shapes?: T[],
          radius?: number,
          radiusList?: number[],
          indexes?: number[]
        );
        /**
         * Shapes to apply the fillets
         * @default undefined
         */
        shapes: T[];
        /**
         * Radius of the fillets
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         * @optional true
         */
        radius?: number;
        /**
         * Radius list
         * @default undefined
         * @optional true
         */
        radiusList?: number[];
        /**
         * List of edge indexes to which apply the fillet, if left empty all edges will be rounded
         * @default undefined
         * @optional true
         */
        indexes?: number[];
      }
      class FilletEdgesListDto<T, U> {
        constructor(shape?: T, edges?: U[], radiusList?: number[]);
        /**
         * Shape to apply the fillet
         * @default undefined
         */
        shape: T;
        /**
         * Edges to use for the fillet
         * @default undefined
         */
        edges: U[];
        /**
         * Radius list for the fillets. The length of this array must match the length of the edges array. Each index corresponds to fillet on the edge at the same index.
         * @default undefined
         */
        radiusList: number[];
      }
      class FilletEdgesListOneRadiusDto<T, U> {
        constructor(shape?: T, edges?: U[], radius?: number);
        /**
         * Shape to apply the fillet
         * @default undefined
         */
        shape: T;
        /**
         * Edges to use for the fillet
         * @default undefined
         */
        edges: U[];
        /**
         * Radius of the fillets
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         * @optional true
         */
        radius: number;
      }
      class FilletEdgeVariableRadiusDto<T, U> {
        constructor(
          shape?: T,
          edge?: U,
          radiusList?: number[],
          paramsU?: number[]
        );
        /**
         * Shape to apply the fillet
         * @default undefined
         */
        shape: T;
        /**
         * Edge to use for the fillet
         * @default undefined
         */
        edge: U;
        /**
         * Radius list for the fillets that has to match the paramsU list
         * @default undefined
         */
        radiusList: number[];
        /**
         * List of parameters on the edge to which apply the fillet. Each param must be between 0 and 1.
         * @default undefined
         */
        paramsU: number[];
      }
      class FilletEdgesVariableRadiusDto<T, U> {
        constructor(
          shape?: T,
          edges?: U[],
          radiusLists?: number[][],
          paramsULists?: number[][]
        );
        /**
         * Shape to apply the fillet
         * @default undefined
         */
        shape: T;
        /**
         * Edges to use for the fillet
         * @default undefined
         */
        edges: U[];
        /**
         * Lists of radius lists for the fillets. Top level array length needs to match the nr of edges used and each second level array needs to match paramsU length array at the same index.
         * @default undefined
         */
        radiusLists: number[][];
        /**
         * Lists of parameter lists on the edges to which apply the fillet. Each param must be between 0 and 1. Top level array length needs to match the nr of edges used and each second level array needs to match radius length array at the same index.
         * @default undefined
         */
        paramsULists: number[][];
      }
      class FilletEdgesSameVariableRadiusDto<T, U> {
        constructor(
          shape?: T,
          edges?: U[],
          radiusList?: number[],
          paramsU?: number[]
        );
        /**
         * Shape to apply the fillet
         * @default undefined
         */
        shape: T;
        /**
         * Edges to use for the fillet
         * @default undefined
         */
        edges: U[];
        /**
         * Radius list for the fillets that has to match the paramsU list
         * @default undefined
         */
        radiusList: number[];
        /**
         * List of parameters on the edges to which apply the fillet. Each param must be between 0 and 1.
         * @default undefined
         */
        paramsU: number[];
      }
      class Fillet3DWiresDto<T> {
        constructor(
          shapes?: T[],
          radius?: number,
          direction?: Base.Vector3,
          radiusList?: number[],
          indexes?: number[]
        );
        /**
         * Shapes to apply the fillets on
         * @default undefined
         */
        shapes: T[];
        /**
         * Radius of the fillets
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         * @optional true
         */
        radius?: number;
        /**
         * Radius list
         * @default undefined
         * @optional true
         */
        radiusList?: number[];
        /**
         * List of edge indexes to which apply the fillet, if left empty all edges will be rounded
         * @default undefined
         * @optional true
         */
        indexes?: number[];
        /**
         * Orientation direction for the fillet
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class Fillet3DWireDto<T> {
        constructor(
          shape?: T,
          radius?: number,
          direction?: Base.Vector3,
          radiusList?: number[],
          indexes?: number[]
        );
        /**
         * Shape to apply the fillets
         * @default undefined
         */
        shape: T;
        /**
         * Radius of the fillets
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         * @optional true
         */
        radius?: number;
        /**
         * Radius list
         * @default undefined
         * @optional true
         */
        radiusList?: number[];
        /**
         * List of edge indexes to which apply the fillet, if left empty all edges will be rounded
         * @default undefined
         * @optional true
         */
        indexes?: number[];
        /**
         * Orientation direction for the fillet
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class ChamferDto<T> {
        constructor(
          shape?: T,
          distance?: number,
          distanceList?: number[],
          indexes?: number[]
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Distance for the chamfer
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @optional true
         * @step 0.1
         */
        distance?: number;
        /**
         * Distance for the chamfer
         * @default undefined
         * @optional true
         */
        distanceList?: number[];
        /**
         * List of edge indexes to which apply the chamfer, if left empty all edges will be chamfered
         * @default undefined
         * @optional true
         */
        indexes?: number[];
      }
      class ChamferEdgesListDto<T, U> {
        constructor(shape?: T, edges?: U[], distanceList?: number[]);
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edges to apply the chamfer to
         * @default undefined
         */
        edges: U[];
        /**
         * Distance for the chamfer
         * @default undefined
         */
        distanceList: number[];
      }
      class ChamferEdgeDistAngleDto<T, U, F> {
        constructor(
          shape?: T,
          edge?: U,
          face?: F,
          distance?: number,
          angle?: number
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edge to apply the chamfer to
         * @default undefined
         */
        edge: U;
        /**
         * Face from which to apply the angle
         * @default undefined
         */
        face: F;
        /**
         * Distance for the chamfer
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        distance: number;
        /**
         * Angle for the chamfer
         * @default 45
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        angle: number;
      }
      class ChamferEdgeTwoDistancesDto<T, U, F> {
        constructor(
          shape?: T,
          edge?: U,
          face?: F,
          distance1?: number,
          distance2?: number
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edge to apply the chamfer to
         * @default undefined
         */
        edge: U;
        /**
         * Face from which to apply the first distance
         * @default undefined
         */
        face: F;
        /**
         * First distance from the face for the chamfer
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        distance1: number;
        /**
         * Second distance for the chamfer
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        distance2: number;
      }
      class ChamferEdgesTwoDistancesListsDto<T, U, F> {
        constructor(
          shape?: T,
          edges?: U[],
          faces?: F[],
          distances1?: number[],
          distances2?: number[]
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edges to apply the chamfers to
         * @default undefined
         */
        edges: U[];
        /**
         * Faces from which to apply the angle of the chamfers
         * @default undefined
         */
        faces: F[];
        /**
         * Distance 1 list for the chamfers
         * @default undefined
         */
        distances1: number[];
        /**
         * Distance 2 list for the chamfers
         * @default undefined
         */
        distances2: number[];
      }
      class ChamferEdgesTwoDistancesDto<T, U, F> {
        constructor(
          shape?: T,
          edges?: U[],
          faces?: F[],
          distance1?: number,
          distance2?: number
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edges to apply the chamfers to
         * @default undefined
         */
        edges: U[];
        /**
         * Faces from which to apply the angle of the chamfers
         * @default undefined
         */
        faces: F[];
        /**
         * First distance from the face for the chamfer
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        distance1: number;
        /**
         * Second distance for the chamfer
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        distance2: number;
      }
      class ChamferEdgesDistsAnglesDto<T, U, F> {
        constructor(
          shape?: T,
          edges?: U[],
          faces?: F[],
          distances?: number[],
          angles?: number[]
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edges to apply the chamfers to
         * @default undefined
         */
        edges: U[];
        /**
         * Faces from which to apply the angle of the chamfers
         * @default undefined
         */
        faces: F[];
        /**
         * Distance list for the chamfers
         * @default undefined
         */
        distances: number[];
        /**
         * Angles for the chamfers
         * @default undefined
         */
        angles: number[];
      }
      class ChamferEdgesDistAngleDto<T, U, F> {
        constructor(
          shape?: T,
          edges?: U[],
          faces?: F[],
          distance?: number,
          angle?: number
        );
        /**
         * Shape to apply the chamfer
         * @default undefined
         */
        shape: T;
        /**
         * Edges to apply the chamfers to
         * @default undefined
         */
        edges: U[];
        /**
         * Faces from which to apply the angle of the chamfers
         * @default undefined
         */
        faces: F[];
        /**
         * Distance from the face
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        distance: number;
        /**
         * Angle for the chamfers
         * @default 45
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        angle: number;
      }
      class BSplineDto {
        constructor(points?: Base.Point3[], closed?: boolean);
        /**
         * Points through which the BSpline will be created
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Indicates wether BSpline will be cloed
         * @default false
         */
        closed: boolean;
      }
      class BSplinesDto {
        constructor(bSplines?: BSplineDto[], returnCompound?: boolean);
        /**
         * BSpline definitions
         * @default undefined
         */
        bSplines: BSplineDto[];
        /**
         * Indicates whether the shapes should be returned as a compound
         */
        returnCompound: boolean;
      }
      class WireFromTwoCirclesTanDto<T> {
        constructor(
          circle1?: T,
          circle2?: T,
          keepLines?: twoSidesStrictEnum,
          circleRemainders?: fourSidesStrictEnum,
          tolerance?: number
        );
        /**
         * The first circle to be encloed with tangential lines
         * @default undefined
         */
        circle1: T;
        /**
         * The second circle to be encloed with tangential lines
         * @default undefined
         */
        circle2: T;
        /**
         * Choose which side to keep for the wire. Outside gives non-intersecting solution.
         * @default outside
         */
        keepLines: twoSidesStrictEnum;
        /**
         * Choose which side to keep for the wire. Outside gives non-intersecting solution.
         * @default outside
         */
        circleRemainders: fourSidesStrictEnum;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
      }
      class FaceFromMultipleCircleTanWiresDto<T> {
        constructor(
          circles?: T[],
          combination?: combinationCirclesForFaceEnum,
          unify?: boolean,
          tolerance?: number
        );
        /**
         * The circles that will all be joined into a single face through tangential lines
         * @default undefined
         */
        circles: T[];
        /**
         * Indicates how circles should be joined together. Users can choose to join all circles with each other. Alternatively it is possible to respect the order of circles and only join consecutive circles. It is also possible to respect order and close the shape with first circle in the list.
         * @default allWithAll
         */
        combination: combinationCirclesForFaceEnum;
        /**
         * Choose whether you want faces to be unifided into a single face or not. Sometimes if you want to get faster result you can set this to false, but in this case faces will be returned as compound.
         * @default true
         */
        unify: boolean;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
      }
      class FaceFromMultipleCircleTanWireCollectionsDto<T> {
        constructor(
          listsOfCircles?: T[][],
          combination?: combinationCirclesForFaceEnum,
          unify?: boolean,
          tolerance?: number
        );
        /**
         * The two dimensional circle array that can host multiple circle collections.
         * @default undefined
         */
        listsOfCircles: T[][];
        /**
         * Indicates how circles should be joined together. Users can choose to join all circles with each other. Alternatively it is possible to respect the order of circles and only join consecutive circles. It is also possible to respect order and close the shape with first circle in the list.
         * @default allWithAll
         */
        combination: combinationCirclesForFaceEnum;
        /**
         * Choose whether you want faces to be unifided into a single face or not. Sometimes if you want to get faster result you can set this to false, but in this case faces will be returned as compound.
         * @default true
         */
        unify: boolean;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
      }
      class ZigZagBetweenTwoWiresDto<T> {
        constructor(
          wire1?: T,
          wire2?: T,
          nrZigZags?: number,
          inverse?: boolean,
          divideByEqualDistance?: boolean,
          zigZagsPerEdge?: boolean
        );
        /**
         * The first wire for zig zag
         * @default undefined
         */
        wire1: T;
        /**
         * The second wire for zig zag
         * @default undefined
         */
        wire2: T;
        /**
         * How many zig zags to create between the two wires on each edge. The number of edges should match. Edges will be joined by zigzags in order. One zig zag means two edges forming a corner.
         * @default 20
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrZigZags: number;
        /**
         * Inverse the the zig zag to go from wire2 to wire1
         * @default false
         */
        inverse: boolean;
        /**
         * If true, the zig zags will be spaced equally on each edge. By default we follow parametric subdivision of the edges, which is not always equal to distance based subdivisions.
         * @default false
         */
        divideByEqualDistance: boolean;
        /**
         * By default the number of zig zags is applied to each edge. If this is set to false, the number of zig zags will be applied to the whole wire. This could then skip some corners where edges meet.
         * @default true
         */
        zigZagsPerEdge: boolean;
      }
      class InterpolationDto {
        constructor(
          points?: Base.Point3[],
          periodic?: boolean,
          tolerance?: number
        );
        /**
         * Points through which the BSpline will be created
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Indicates wether BSpline will be periodic
         * @default false
         */
        periodic: boolean;
        /**
         * tolerance
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
      }
      class InterpolateWiresDto {
        constructor(
          interpolations?: InterpolationDto[],
          returnCompound?: boolean
        );
        /**
         * Interpolation definitions
         * @default undefined
         */
        interpolations: InterpolationDto[];
        /**
         * Indicates whether the shapes should be returned as a compound
         */
        returnCompound: boolean;
      }
      class BezierDto {
        constructor(points?: Base.Point3[], closed?: boolean);
        /**
         * Points through which the Bezier curve will be created
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Indicates wether Bezier will be cloed
         * @default false
         */
        closed: boolean;
      }
      class BezierWeightsDto {
        constructor(
          points?: Base.Point3[],
          weights?: number[],
          closed?: boolean
        );
        /**
         * Points through which the Bezier curve will be created
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Weights for beziers that will be used, values should be between 0 and 1
         * @default undefined
         */
        weights: number[];
        /**
         * Indicates wether Bezier will be cloed
         * @default false
         */
        closed: boolean;
      }
      class BezierWiresDto {
        constructor(bezierWires?: BezierDto[], returnCompound?: boolean);
        /**
         * Bezier wires
         * @default undefined
         */
        bezierWires: BezierDto[];
        /**
         * Indicates whether the shapes should be returned as a compound
         */
        returnCompound: boolean;
      }
      class DivideDto<T> {
        constructor(
          shape?: T,
          nrOfDivisions?: number,
          removeStartPoint?: boolean,
          removeEndPoint?: boolean
        );
        /**
         * Shape representing a wire
         * @default undefined
         */
        shape?: T;
        /**
         * The number of divisions that will be performed on the curve
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrOfDivisions?: number;
        /**
         * Indicates if algorithm should remove start point
         * @default false
         */
        removeStartPoint?: boolean;
        /**
         * Indicates if algorithm should remove end point
         * @default false
         */
        removeEndPoint?: boolean;
      }
      class ProjectWireDto<T, U> {
        constructor(wire?: T, shape?: U, direction?: Base.Vector3);
        /**
         * Wire to project
         * @default undefined
         */
        wire: T;
        /**
         * Shape to use for projection
         * @default undefined
         */
        shape: U;
        /**
         * Direction vector for projection
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class ProjectPointsOnShapeDto<T> {
        constructor(
          points?: Base.Point3[],
          shape?: T,
          direction?: Base.Vector3,
          projectionType?: pointProjectionTypeEnum
        );
        /**
         * Points to project
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Shape to use for projection
         * @default undefined
         */
        shape: T;
        /**
         * Direction vector for projection - this must take the length into account as well, because algorithm looks for intresections with the shape in this direction. It will not find solutions outside the given length of this vector.
         * @default [0, 10, 0]
         */
        direction: Base.Vector3;
        /**
         * Allows user to choose what solutions are being returned by this operation.
         * @default all
         */
        projectionType: pointProjectionTypeEnum;
      }
      class WiresToPointsDto<T> {
        constructor(
          shape?: T,
          angularDeflection?: number,
          curvatureDeflection?: number,
          minimumOfPoints?: number,
          uTolerance?: number,
          minimumLength?: number
        );
        /**
         * Shape to use for parsing edges
         * @default undefined
         */
        shape: T;
        /**
         * The angular deflection
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        angularDeflection: number;
        /**
         * The curvature deflection
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        curvatureDeflection: number;
        /**
         * Minimum of points
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minimumOfPoints: number;
        /**
         * U tolerance
         * @default 1.0e-9
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-9
         */
        uTolerance: number;
        /**
         * Minimum length
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-7
         */
        minimumLength: number;
      }
      class EdgesToPointsDto<T> {
        constructor(
          shape?: T,
          angularDeflection?: number,
          curvatureDeflection?: number,
          minimumOfPoints?: number,
          uTolerance?: number,
          minimumLength?: number
        );
        /**
         * Shape to use for parsing edges
         * @default undefined
         */
        shape: T;
        /**
         * The angular deflection
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        angularDeflection: number;
        /**
         * The curvature deflection
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        curvatureDeflection: number;
        /**
         * Minimum of points
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minimumOfPoints: number;
        /**
         * U tolerance
         * @default 1.0e-9
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-9
         */
        uTolerance: number;
        /**
         * Minimum length
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-7
         */
        minimumLength: number;
      }
      class ProjectWiresDto<T, U> {
        constructor(wires?: T[], shape?: U, direction?: Base.Vector3);
        /**
         * Wire to project
         * @default undefined
         */
        wires: T[];
        /**
         * Shape to use for projection
         * @default undefined
         */
        shape: U;
        /**
         * Direction vector for projection
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class DivideShapesDto<T> {
        constructor(
          shapes: T[],
          nrOfDivisions?: number,
          removeStartPoint?: boolean,
          removeEndPoint?: boolean
        );
        /**
         * Shapes
         * @default undefined
         */
        shapes: T[];
        /**
         * The number of divisions that will be performed on the curve
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrOfDivisions: number;
        /**
         * Indicates if algorithm should remove start point
         * @default false
         */
        removeStartPoint: boolean;
        /**
         * Indicates if algorithm should remove end point
         * @default false
         */
        removeEndPoint: boolean;
      }
      class DataOnGeometryAtParamDto<T> {
        constructor(shape: T, param?: number);
        /**
         * Shape representing a geometry
         * @default undefined
         */
        shape: T;
        /**
         * 0 - 1 value
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        param: number;
      }
      class DataOnGeometryesAtParamDto<T> {
        constructor(shapes: T[], param?: number);
        /**
         * Shapes representing a geometry
         * @default undefined
         */
        shapes: T[];
        /**
         * 0 - 1 value
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        param: number;
      }
      class PointInFaceDto<T> {
        constructor(
          face: T,
          edge: T,
          tEdgeParam?: number,
          distance2DParam?: number
        );
        /**
         * OCCT face to be used for calculation
         * @default undefined
         */
        face: T;
        /**
         * OCCT edge to be used for calculation
         * @default undefined
         */
        edge: T;
        /**
         * 0 - 1 value
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        tEdgeParam: number;
        /**
         * The point will be distanced on <distance2DParam> from the 2d curve.
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        distance2DParam: number;
      }
      class PointsOnWireAtEqualLengthDto<T> {
        constructor(
          shape: T,
          length?: number,
          tryNext?: boolean,
          includeFirst?: boolean,
          includeLast?: boolean
        );
        /**
         * Shape representing a wire
         * @default undefined
         */
        shape: T;
        /**
         * length at which to evaluate the point
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
        /**
         * Try next point if the point is not found
         * @default false
         */
        tryNext: boolean;
        /**
         * Include first point
         * @default false
         */
        includeFirst: boolean;
        /**
         * Include last point
         * @default false
         */
        includeLast: boolean;
      }
      class PointsOnWireAtPatternOfLengthsDto<T> {
        constructor(
          shape: T,
          lengths?: number[],
          tryNext?: boolean,
          includeFirst?: boolean,
          includeLast?: boolean
        );
        /**
         * Shape representing a wire
         * @default undefined
         */
        shape: T;
        /**
         * length at which to evaluate the point
         * @default undefined
         */
        lengths: number[];
        /**
         * Try next point if the point is not found
         * @default false
         */
        tryNext: boolean;
        /**
         * Include first point
         * @default false
         */
        includeFirst: boolean;
        /**
         * Include last point
         * @default false
         */
        includeLast: boolean;
      }
      class DataOnGeometryAtLengthDto<T> {
        constructor(shape: T, length?: number);
        /**
         * Shape
         * @default undefined
         */
        shape: T;
        /**
         * length at which to evaluate the point
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
      }
      class DataOnGeometryesAtLengthDto<T> {
        constructor(shapes: T[], length?: number);
        /**
         * Shapes
         * @default undefined
         */
        shapes: T[];
        /**
         * length at which to evaluate the point
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
      }
      class DataOnGeometryAtLengthsDto<T> {
        constructor(shape: T, lengths?: number[]);
        /**
         * Shape representing a wire
         * @default undefined
         */
        shape: T;
        /**
         * lengths at which to evaluate the points
         * @default undefined
         */
        lengths: number[];
      }
      class CircleDto {
        constructor(
          radius?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Radius of the circle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Center of the circle
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction vector for circle
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class HexagonsInGridDto {
        constructor(
          wdith?: number,
          height?: number,
          nrHexagonsInHeight?: number,
          nrHexagonsInWidth?: number,
          flatTop?: boolean,
          extendTop?: boolean,
          extendBottom?: boolean,
          extendLeft?: boolean,
          extendRight?: boolean,
          scalePatternWidth?: number[],
          scalePatternHeight?: number[],
          filletPattern?: number[],
          inclusionPattern?: boolean[]
        );
        /** Total desired width for the grid area. The hexagon size will be derived from this and nrHexagonsU.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width?: number;
        /** Total desired height for the grid area. Note: due to hexagon geometry, the actual grid height might differ slightly if maintaining regular hexagons based on width.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height?: number;
        /** Number of hexagons desired in width.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsInWidth?: number;
        /** Number of hexagons desired in height.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsInHeight?: number;
        /** If true, the hexagons will be oriented with their flat sides facing up and down.
         * @default false
         */
        flatTop?: boolean;
        /** If true, shift the entire grid up by half hex height.
         * @default false
         */
        extendTop?: boolean;
        /** If true, shift the entire grid down by half hex height.
         * @default false
         */
        extendBottom?: boolean;
        /** If true, shift the entire grid left by half hex width.
         * @default false
         */
        extendLeft?: boolean;
        /** If true, shift the entire grid right by half hex width.
         * @default false
         */
        extendRight?: boolean;
        /**
         * Hex scale pattern on width direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternWidth?: number[];
        /**
         * Hex scale pattern on height direction - numbers between 0 and 1, if 1 or undefined is used, no scaling is applied
         * @default undefined
         * @optional true
         */
        scalePatternHeight?: number[];
        /**
         * Hex fillet scale pattern - numbers between 0 and 1, if 0 is used, no fillet is applied,
         * if 1 is used, the fillet will be exactly half of the length of the shorter side of the hex
         * @default undefined
         * @optional true
         */
        filletPattern?: number[];
        /**
         * Inclusion pattern - true means that the hex will be included,
         * false means that the hex will be removed
         * @default undefined
         * @optional true
         */
        inclusionPattern?: boolean[];
      }
      class LoftDto<T> {
        constructor(shapes?: T[], makeSolid?: boolean);
        /**
         * Wires through which the loft passes
         * @default undefined
         */
        shapes: T[];
        /**
         * Tries to make a solid when lofting
         * @default false
         */
        makeSolid: boolean;
      }
      class LoftAdvancedDto<T> {
        constructor(
          shapes?: T[],
          makeSolid?: boolean,
          closed?: boolean,
          periodic?: boolean,
          straight?: boolean,
          nrPeriodicSections?: number,
          useSmoothing?: boolean,
          maxUDegree?: number,
          tolerance?: number,
          parType?: approxParametrizationTypeEnum,
          startVertex?: Base.Point3,
          endVertex?: Base.Point3
        );
        /**
         * Wires through which the loft passes
         * @default undefined
         */
        shapes: T[];
        /**
         * Tries to make a solid when lofting
         * @default false
         */
        makeSolid: boolean;
        /**
         * Will make a closed loft.
         * @default false
         */
        closed: boolean;
        /**
         * Will make a periodic loft.
         * @default false
         */
        periodic: boolean;
        /**
         * Indicates whether straight sections should be made out of the loft
         * @default false
         */
        straight: boolean;
        /**
         * This number only is used when closed non straight lofting is used
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrPeriodicSections: number;
        /**
         * Tell algorithm to use smoothing
         * @default false
         */
        useSmoothing: boolean;
        /**
         * Maximum u degree
         * @default 3
         */
        maxUDegree: number;
        /**
         * Tolerance
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
        /**
         * Approximation parametrization type
         * @default approxCentripetal
         */
        parType: approxParametrizationTypeEnum;
        /**
         * Optional if loft should start with a vertex
         * @default undefined
         * @optional true
         */
        startVertex?: Base.Point3;
        /**
         * Optional if loft should end with a vertex
         * @default undefined
         * @optional true
         */
        endVertex?: Base.Point3;
      }
      class OffsetDto<T, U> {
        constructor(shape?: T, face?: U, distance?: number, tolerance?: number);
        /**
         * Shape to offset
         * @default undefined
         */
        shape: T;
        /**
         * Optionally provide face for the offset
         * @default undefined
         * @optional true
         */
        face?: U;
        /**
         * Distance of offset
         * @default 0.2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        distance: number;
        /**
         * Offset tolerance
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        tolerance: number;
      }
      class OffsetAdvancedDto<T, U> {
        constructor(
          shape?: T,
          face?: U,
          distance?: number,
          tolerance?: number,
          joinType?: joinTypeEnum,
          removeIntEdges?: boolean
        );
        /**
         * Shape to offset
         * @default undefined
         */
        shape: T;
        /**
         * Optionally provide face for the offset
         * @default undefined
         * @optional true
         */
        face?: U;
        /**
         * Distance of offset
         * @default 0.2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        distance: number;
        /**
         * Offset tolerance
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        tolerance: number;
        /**
         * Join defines how to fill the holes that may appear between parallels to the two adjacent faces. It may take values GeomAbs_Arc or GeomAbs_Intersection:
         * if Join is equal to GeomAbs_Arc, then pipes are generated between two free edges of two adjacent parallels, and spheres are generated on "images" of vertices; it is the default value
         * @default arc
         */
        joinType: joinTypeEnum;
        /**
         * Removes internal edges
         * @default false
         */
        removeIntEdges: boolean;
      }
      class RevolveDto<T> {
        constructor(
          shape?: T,
          angle?: number,
          direction?: Base.Vector3,
          copy?: boolean
        );
        /**
         * Shape to revolve
         * @default undefined
         */
        shape: T;
        /**
         * Angle degrees
         * @default 360
         * @minimum 0
         * @maximum 360
         * @step 1
         */
        angle: number;
        /**
         * Direction vector
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
        /**
         * Copy original shape
         * @default false
         */
        copy: boolean;
      }
      class ShapeShapesDto<T, U> {
        constructor(shape?: T, shapes?: U[]);
        /**
         * The wire path
         * @default undefined
         */
        shape: T;
        /**
         * Shapes along the path to be piped
         * @default undefined
         */
        shapes: U[];
      }
      class WiresOnFaceDto<T, U> {
        constructor(wires?: T[], face?: U);
        /**
         * The wires
         * @default undefined
         */
        wires: T[];
        /**
         * Face shape
         * @default undefined
         */
        face: U;
      }
      class PipeWiresCylindricalDto<T> {
        constructor(
          shapes?: T[],
          radius?: number,
          makeSolid?: boolean,
          trihedronEnum?: geomFillTrihedronEnum,
          forceApproxC1?: boolean
        );
        /**
         * Wire paths to pipe
         * @default undefined
         */
        shapes: T[];
        /**
         * Radius of the cylindrical pipe
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        radius: number;
        /**
         * Make solid result by closing start and end parts
         * @default true
         */
        makeSolid: boolean;
        /**
         * Goemetry Fill Trihedron Options
         * @default isConstantNormal
         */
        trihedronEnum: geomFillTrihedronEnum;
        /**
         * Attempt to approximate a C1-continuous surface if a swept surface proved to be C0
         * @default false
         */
        forceApproxC1: boolean;
      }
      class PipeWireCylindricalDto<T> {
        constructor(
          shape?: T,
          radius?: number,
          makeSolid?: boolean,
          trihedronEnum?: geomFillTrihedronEnum,
          forceApproxC1?: boolean
        );
        /**
         * Wire path to pipe
         * @default undefined
         */
        shape: T;
        /**
         * Radius of the cylindrical pipe
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        radius: number;
        /**
         * Make solid result by closing start and end parts
         * @default true
         */
        makeSolid: boolean;
        /**
         * Goemetry Fill Trihedron Options
         * @default isConstantNormal
         */
        trihedronEnum: geomFillTrihedronEnum;
        /**
         * Attempt to approximate a C1-continuous surface if a swept surface proved to be C0
         * @default false
         */
        forceApproxC1: boolean;
      }
      class PipePolygonWireNGonDto<T> {
        constructor(
          shapes?: T,
          radius?: number,
          nrCorners?: number,
          makeSolid?: boolean,
          trihedronEnum?: geomFillTrihedronEnum,
          forceApproxC1?: boolean
        );
        /**
         * Wire path to pipe
         * @default undefined
         */
        shape: T;
        /**
         * Radius of the cylindrical pipe
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        radius: number;
        /**
         * Nr of ngon corners to be used
         * @default 6
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        nrCorners: number;
        /**
         * Make solid result by closing start and end parts
         * @default true
         */
        makeSolid: boolean;
        /**
         * Goemetry Fill Trihedron Options
         * @default isConstantNormal
         */
        trihedronEnum: geomFillTrihedronEnum;
        /**
         * Attempt to approximate a C1-continuous surface if a swept surface proved to be C0
         * @default false
         */
        forceApproxC1: boolean;
      }
      class ExtrudeDto<T> {
        constructor(shape?: T, direction?: Base.Vector3);
        /**
         * Face to extrude
         * @default undefined
         */
        shape: T;
        /**
         * Direction vector for extrusion
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class ExtrudeShapesDto<T> {
        constructor(shapes?: T[], direction?: Base.Vector3);
        /**
         * Shapes to extrude
         * @default undefined
         */
        shapes: T[];
        /**
         * Direction vector for extrusion
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class SplitDto<T> {
        constructor(shape?: T, shapes?: T[]);
        /**
         * Shape to split
         * @default undefined
         */
        shape: T;
        /**
         * Shapes to split from main shape
         * @default undefined
         */
        shapes: T[];
        /**
         * Local fuzzy tolerance used for splitting
         * @default 1.0e-4
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        localFuzzyTolerance: number;
        /**
         * Set to true if you want to split the shape non-destructively
         * @default true
         */
        nonDestructive: boolean;
      }
      class UnionDto<T> {
        constructor(shapes?: T[], keepEdges?: boolean);
        /**
         * Objects to be joined together
         * @default undefined
         */
        shapes: T[];
        /**
         * Keeps edges
         * @default false
         */
        keepEdges: boolean;
      }
      class DifferenceDto<T> {
        constructor(shape?: T, shapes?: T[], keepEdges?: boolean);
        /**
         * Object to subtract from
         * @default undefined
         */
        shape: T;
        /**
         * Objects to subtract
         * @default undefined
         */
        shapes: T[];
        /**
         * Keeps edges unaffected
         * @default false
         */
        keepEdges: boolean;
      }
      class IntersectionDto<T> {
        constructor(shapes?: T[], keepEdges?: boolean);
        /**
         * Shapes to intersect
         * @default undefined
         */
        shapes: T[];
        /**
         * Keep the edges
         * @default false
         */
        keepEdges: boolean;
      }
      class ShapeDto<T> {
        constructor(shape?: T);
        /**
         * Shape on which action should be performed
         * @default undefined
         */
        shape: T;
      }
      class MeshMeshIntersectionTwoShapesDto<T> {
        constructor(
          shape1?: T,
          shape2?: T,
          precision1?: number,
          precision2?: number
        );
        /**
         * First shape to be used for intersection
         * @default undefined
         */
        shape1: T;
        /**
         * Precision of first shape to be used for meshing and computing intersection.
         * Keep in mind that the lower this value is, the more triangles will be produced and thus the slower the computation.
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        precision1?: number;
        /**
         * Second shape to be used for intersection
         * @default undefined
         */
        shape2: T;
        /**
         * Precision of second shape to be used for meshing and computing intersection.
         * Keep in mind that the lower this value is, the more triangles will be produced and thus the slower the computation.
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        precision2?: number;
      }
      class MeshMeshesIntersectionOfShapesDto<T> {
        constructor(
          shape?: T,
          shapes?: T[],
          precision?: number,
          precisionShapes?: number[]
        );
        /**
         * Shape to use for the base of computations
         * @default undefined
         */
        shape?: T;
        /**
         * Precision of first shape to be used for meshing and computing intersection.
         * Keep in mind that the lower this value is, the more triangles will be produced and thus the slower the computation.
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        precision?: number;
        /**
         * Second shape to be used for intersection
         * @default undefined
         */
        shapes?: T[];
        /**
         * Precision of shapes to be used, if undefined, a universal precision will be used of the first shape
         * @default undefined
         * @optional true
         */
        precisionShapes?: number[];
      }
      class CompareShapesDto<T> {
        constructor(shape?: T, otherShape?: T);
        /**
         * Shape to be compared
         * @default undefined
         */
        shape: T;
        /**
         * Shape to be compared against
         * @default undefined
         */
        otherShape: T;
      }
      class FixSmallEdgesInWireDto<T> {
        constructor(shape?: T, lockvtx?: boolean, precsmall?: number);
        /**
         * Shape on which action should be performed
         * @default undefined
         */
        shape: T;
        /**
         * Lock vertex. If true, the edge must be kept.
         * @default false
         */
        lockvtx: boolean;
        /**
         * Definition of the small distance edge
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.0000000001
         */
        precsmall: number;
      }
      class BasicShapeRepairDto<T> {
        constructor(
          shape?: T,
          precision?: number,
          maxTolerance?: number,
          minTolerance?: number
        );
        /**
         * Shape to repair
         * @default undefined
         */
        shape: T;
        /**
         * Basic precision
         * @default 0.001
         * @minimum 0
         * @maximum Infinity
         * @step 0.0000000001
         */
        precision: number;
        /**
         * maximum allowed tolerance. All problems will be detected for cases when a dimension of invalidity is larger than
         * the basic precision or a tolerance of sub-shape on that problem is detected. The maximum tolerance value limits
         * the increasing tolerance for fixing a problem such as fix of not connected and self-intersected wires. If a value
         * larger than the maximum allowed tolerance is necessary for correcting a detected problem the problem can not be fixed.
         * The maximal tolerance is not taking into account during computation of tolerance of edges
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.0000000001
         */
        maxTolerance: number;
        /**
         * minimal allowed tolerance. It defines the minimal allowed length of edges.
         * Detected edges having length less than the specified minimal tolerance will be removed.
         * @default 0.0001
         * @minimum 0
         * @maximum Infinity
         * @step 0.0000000001
         */
        minTolerance: number;
      }
      class FixClosedDto<T> {
        constructor(shape?: T, precision?: number);
        /**
         * Shape on which action should be performed
         * @default undefined
         */
        shape: T;
        /**
         * Precision for closed wire
         * @default -0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.0000000001
         */
        precision: number;
      }
      class ShapesWithToleranceDto<T> {
        constructor(shapes?: T[], tolerance?: number);
        /**
         * The shapes
         * @default undefined
         */
        shapes: T[];
        /**
         * Tolerance used for intersections
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
      }
      class ShapeWithToleranceDto<T> {
        constructor(shape?: T, tolerance?: number);
        /**
         * The shape
         * @default undefined
         */
        shape: T;
        /**
         * Tolerance used for intersections
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
      }
      class ShapeIndexDto<T> {
        constructor(shape?: T, index?: number);
        /**
         * Shape
         * @default undefined
         */
        shape: T;
        /**
         * Index of the entity
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        index: number;
      }
      class EdgeIndexDto<T> {
        constructor(shape?: T, index?: number);
        /**
         * Shape
         * @default undefined
         */
        shape: T;
        /**
         * Index of the entity
         * @default 1
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        index: number;
      }
      class RotationExtrudeDto<T> {
        constructor(
          shape?: T,
          height?: number,
          angle?: number,
          makeSolid?: boolean
        );
        /**
         * Wire to extrude by rotating
         * @default undefined
         */
        shape: T;
        /**
         * Height of rotation
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Rotation in degrees
         * @default 360
         * @minimum 0
         * @maximum 360
         * @step 1
         */
        angle: number;
        /**
         * Make solid of the result
         * @default true
         */
        makeSolid: boolean;
      }
      class ThickSolidByJoinDto<T> {
        constructor(
          shape?: T,
          shapes?: T[],
          offset?: number,
          tolerance?: number,
          intersection?: boolean,
          selfIntersection?: boolean,
          joinType?: joinTypeEnum,
          removeIntEdges?: boolean
        );
        /**
         * Shape to make thick
         * @default undefined
         */
        shape: T;
        /**
         * closing faces
         * @default undefined
         */
        shapes: T[];
        /**
         * Offset to apply
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        offset: number;
        /**
         * Tolerance defines the tolerance criterion for coincidence in generated shapes
         * @default 1.0e-3
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
        /**
         * if Intersection is false (default value), the intersection is calculated with the parallels to the two adjacent shapes
         * @default false
         */
        intersection: boolean;
        /**
         * SelfInter tells the algorithm whether a computation to eliminate self-intersections needs to be applied to the resulting shape. However, as this functionality is not yet implemented, you should use the default value (false)
         * @default false
         */
        selfIntersection: boolean;
        /**
         * Join defines how to fill the holes that may appear between parallels to the two adjacent faces. It may take values GeomAbs_Arc or GeomAbs_Intersection:
         * if Join is equal to GeomAbs_Arc, then pipes are generated between two free edges of two adjacent parallels, and spheres are generated on "images" of vertices; it is the default value
         * @default arc
         */
        joinType: joinTypeEnum;
        /**
         * if Join is equal to GeomAbs_Intersection, then the parallels to the two adjacent faces are enlarged and intersected, so that there are no free edges on parallels to faces. RemoveIntEdges flag defines whether to remove the INTERNAL edges from the result or not. Warnings Since the algorithm of MakeThickSolid is based on MakeOffsetShape algorithm, the warnings are the same as for MakeOffsetShape.
         * @default false
         */
        removeIntEdges: boolean;
      }
      class TransformDto<T> {
        constructor(
          shape?: T,
          translation?: Base.Vector3,
          rotationAxis?: Base.Vector3,
          rotationAngle?: number,
          scaleFactor?: number
        );
        /**
         * Shape to transform
         * @default undefined
         */
        shape: T;
        /**
         * Translation to apply
         * @default [0,0,0]
         */
        translation: Base.Vector3;
        /**
         * Rotation to apply
         * @default [0,1,0]
         */
        rotationAxis: Base.Vector3;
        /**
         * Rotation degrees
         * @default 0
         * @minimum 0
         * @maximum 360
         * @step 1
         */
        rotationAngle: number;
        /**
         * Scale factor to apply
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleFactor: number;
      }
      class TransformShapesDto<T> {
        constructor(
          shapes?: T[],
          translation?: Base.Vector3[],
          rotationAxes?: Base.Vector3[],
          rotationDegrees?: number[],
          scaleFactors?: number[]
        );
        /**
         * Shape to transform
         * @default undefined
         */
        shapes: T[];
        /**
         * Translation to apply
         * @default [[0,0,0]]
         */
        translations: Base.Vector3[];
        /**
         * Rotation to apply
         * @default [[0,1,0]]
         */
        rotationAxes: Base.Vector3[];
        /**
         * Rotation degrees
         * @default [0]
         */
        rotationAngles: number[];
        /**
         * Scale factor to apply
         * @default [1]
         */
        scaleFactors: number[];
      }
      class TranslateDto<T> {
        constructor(shape?: T, translation?: Base.Vector3);
        /**
         * Shape for translation
         * @default undefined
         */
        shape: T;
        /**
         * Translation vector
         * @default [0, 0, 0]
         */
        translation: Base.Vector3;
      }
      class TranslateShapesDto<T> {
        constructor(shapes?: T[], translations?: Base.Vector3[]);
        /**
         * Shape for translation
         * @default undefined
         */
        shapes: T[];
        /**
         * Translation vector
         * @default [[0, 0, 0]]
         */
        translations: Base.Vector3[];
      }
      class AlignNormAndAxisDto<T> {
        constructor(
          shape?: T,
          fromOrigin?: Base.Point3,
          fromNorm?: Base.Vector3,
          fromAx?: Base.Vector3,
          toOrigin?: Base.Point3,
          toNorm?: Base.Vector3,
          toAx?: Base.Vector3
        );
        /**
         * Shape for translation
         * @default undefined
         */
        shape: T;
        /**
         * @default [0, 0, 0]
         */
        fromOrigin: Base.Point3;
        /**
         * From direction 1
         * @default [0, 0, 1]
         */
        fromNorm: Base.Vector3;
        /**
         * From direction 2
         * @default [0, 0, 1]
         */
        fromAx: Base.Vector3;
        /**
         * To origin
         * @default [0, 1, 0]
         */
        toOrigin: Base.Point3;
        /**
         * To direction 1
         * @default [0, 1, 0]
         */
        toNorm: Base.Vector3;
        /**
         * To direction 2
         * @default [0, 0, 1]
         */
        toAx: Base.Vector3;
      }
      class AlignDto<T> {
        constructor(
          shape?: T,
          fromOrigin?: Base.Point3,
          fromDirection?: Base.Vector3,
          toOrigin?: Base.Point3,
          toDirection?: Base.Vector3
        );
        /**
         * Shape for translation
         * @default undefined
         */
        shape: T;
        /**
         * @default [0, 0, 0]
         */
        fromOrigin: Base.Point3;
        /**
         * From direction
         * @default [0, 0, 1]
         */
        fromDirection: Base.Vector3;
        /**
         * To origin
         * @default [0, 1, 0]
         */
        toOrigin: Base.Point3;
        /**
         * To direction
         * @default [0, 1, 0]
         */
        toDirection: Base.Vector3;
      }
      class AlignShapesDto<T> {
        constructor(
          shapes?: T[],
          fromOrigins?: Base.Vector3[],
          fromDirections?: Base.Vector3[],
          toOrigins?: Base.Vector3[],
          toDirections?: Base.Vector3[]
        );
        /**
         * Shape for translation
         * @default undefined
         */
        shapes: T[];
        /**
         * @default [[0, 0, 0]]
         */
        fromOrigins: Base.Point3[];
        /**
         * From direction
         * @default [[0, 0, 1]]
         */
        fromDirections: Base.Vector3[];
        /**
         * To origin
         * @default [[0, 1, 0]]
         */
        toOrigins: Base.Point3[];
        /**
         * To direction
         * @default [[0, 1, 0]]
         */
        toDirections: Base.Vector3[];
      }
      class MirrorDto<T> {
        constructor(shape?: T, origin?: Base.Point3, direction?: Base.Vector3);
        /**
         * Shape to mirror
         * @default undefined
         */
        shape: T;
        /**
         * Axis origin point
         * @default [0, 0, 0]
         */
        origin: Base.Point3;
        /**
         * Axis direction vector
         * @default [0, 0, 1]
         */
        direction: Base.Vector3;
      }
      class MirrorShapesDto<T> {
        constructor(
          shapes?: T[],
          origins?: Base.Point3[],
          directions?: Base.Vector3[]
        );
        /**
         * Shape to mirror
         * @default undefined
         */
        shapes: T[];
        /**
         * Axis origin point
         * @default [[0, 0, 0]]
         */
        origins: Base.Point3[];
        /**
         * Axis direction vector
         * @default [[0, 0, 1]]
         */
        directions: Base.Vector3[];
      }
      class MirrorAlongNormalDto<T> {
        constructor(shape?: T, origin?: Base.Point3, normal?: Base.Vector3);
        /**
         * Shape to mirror
         * @default undefined
         */
        shape: T;
        /**
         * Axis origin point
         * @default [0, 0, 0]
         */
        origin: Base.Point3;
        /**
         * First normal axis direction vector
         * @default [0, 0, 1]
         */
        normal: Base.Vector3;
      }
      class MirrorAlongNormalShapesDto<T> {
        constructor(
          shapes?: T[],
          origins?: Base.Point3[],
          normals?: Base.Vector3[]
        );
        /**
         * Shape to mirror
         * @default undefined
         */
        shapes: T[];
        /**
         * Axis origin point
         * @default [[0, 0, 0]]
         */
        origins: Base.Point3[];
        /**
         * First normal axis direction vector
         * @default [[0, 0, 1]]
         */
        normals: Base.Vector3[];
      }
      class AlignAndTranslateDto<T> {
        constructor(shape?: T, direction?: Base.Vector3, center?: Base.Vector3);
        /**
         * Shape to align and translate
         * @default undefined
         */
        shape: T;
        /**
         * Direction on which to align
         * @default [0, 0, 1]
         */
        direction: Base.Vector3;
        /**
         * Position to translate
         */
        center: Base.Vector3;
      }
      class UnifySameDomainDto<T> {
        constructor(
          shape?: T,
          unifyEdges?: boolean,
          unifyFaces?: boolean,
          concatBSplines?: boolean
        );
        /**
         * Shape on which action should be performed
         * @default undefined
         */
        shape: T;
        /**
         * If true, unifies the edges
         * @default true
         */
        unifyEdges: boolean;
        /**
         * If true, unifies the edges
         * @default true
         */
        unifyFaces: boolean;
        /**
         * If true, unifies the edges
         * @default true
         */
        concatBSplines: boolean;
      }
      class FilterFacesPointsDto<T> {
        constructor(
          shapes?: T[],
          points?: Base.Point3[],
          tolerance?: number,
          useBndBox?: boolean,
          gapTolerance?: number,
          keepIn?: boolean,
          keepOn?: boolean,
          keepOut?: boolean,
          keepUnknown?: boolean,
          flatPointsArray?: boolean
        );
        /**
         * Face that will be used to filter points
         * @default undefined
         */
        shapes: T[];
        /**
         * Points to filter
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Tolerance used for filter
         * @default 1.0e-4
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
        /**
         * If true, the bounding box will be used to prefilter the points so that there are less points to check on actual face.
         * Recommended to enable if face has more than 10 edges and geometry is mostly spline.
         * This might be faster, but if it is known that points are withing bounding box, this may not be faster.
         * @default false
         */
        useBndBox: boolean;
        /**
         * Gap tolerance
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        gapTolerance: number;
        /**
         * Return points that are inside the face
         * @default true
         */
        keepIn: boolean;
        /**
         * Return points that are on the border of the face
         * @default true
         */
        keepOn: boolean;
        /**
         * Return points that are outside the borders of the face
         * @default false
         */
        keepOut: boolean;
        /**
         * Return points that are classified as unknown
         * @default false
         */
        keepUnknown: boolean;
        /**
         * Returns flat points array by default, otherwise returns points for each face in order provided
         * @default true
         */
        flatPointsArray: boolean;
      }
      class FilterFacePointsDto<T> {
        constructor(
          shape?: T,
          points?: Base.Point3[],
          tolerance?: number,
          useBndBox?: boolean,
          gapTolerance?: number,
          keepIn?: boolean,
          keepOn?: boolean,
          keepOut?: boolean,
          keepUnknown?: boolean
        );
        /**
         * Face that will be used to filter points
         * @default undefined
         */
        shape: T;
        /**
         * Points to filter
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Tolerance used for filter
         * @default 1.0e-4
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
        /**
         * If true, the bounding box will be used to prefilter the points so that there are less points to check on actual face.
         * Recommended to enable if face has more than 10 edges and geometry is mostly spline.
         * This might be faster, but if it is known that points are withing bounding box, this may not be faster.
         * @default false
         */
        useBndBox: boolean;
        /**
         * Gap tolerance
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        gapTolerance: number;
        /**
         * Return points that are inside the face
         * @default true
         */
        keepIn: boolean;
        /**
         * Return points that are on the border of the face
         * @default true
         */
        keepOn: boolean;
        /**
         * Return points that are outside the borders of the face
         * @default false
         */
        keepOut: boolean;
        /**
         * Return points that are classified as unknown
         * @default false
         */
        keepUnknown: boolean;
      }
      class FilterSolidPointsDto<T> {
        constructor(
          shape?: T,
          points?: Base.Point3[],
          tolerance?: number,
          keepIn?: boolean,
          keepOn?: boolean,
          keepOut?: boolean,
          keepUnknown?: boolean
        );
        /**
         * Face that will be used to filter points
         * @default undefined
         */
        shape: T;
        /**
         * Points to filter
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Tolerance used for filter
         * @default 1.0e-4
         * @minimum 0
         * @maximum Infinity
         * @step 0.000001
         */
        tolerance: number;
        /**
         * Return points that are inside the face
         * @default true
         */
        keepIn: boolean;
        /**
         * Return points that are on the border of the face
         * @default true
         */
        keepOn: boolean;
        /**
         * Return points that are outside the borders of the face
         * @default false
         */
        keepOut: boolean;
        /**
         * Return points that are classified as unknown
         * @default false
         */
        keepUnknown: boolean;
      }
      class AlignAndTranslateShapesDto<T> {
        constructor(
          shapes?: T[],
          directions?: Base.Vector3[],
          centers?: Base.Vector3[]
        );
        /**
         * Shapes to align and translate
         * @default undefined
         */
        shapes: T[];
        /**
         * Directions on which to align
         * @default [0, 0, 1]
         */
        directions: Base.Vector3[];
        /**
         * Positions to translate
         */
        centers: Base.Vector3[];
      }
      class RotateDto<T> {
        constructor(shape?: T, axis?: Base.Vector3, angle?: number);
        /**
         * Shape to rotate
         * @default undefined
         */
        shape: T;
        /**
         * Axis on which to rotate
         * @default [0, 0, 1]
         */
        axis: Base.Vector3;
        /**
         * Rotation degrees
         * @default 0
         * @minimum 0
         * @maximum 360
         * @step 1
         */
        angle: number;
      }
      class RotateAroundCenterDto<T> {
        constructor(
          shape?: T,
          angle?: number,
          center?: Base.Point3,
          axis?: Base.Vector3
        );
        /**
         * Shape to rotate
         * @default undefined
         */
        shape: T;
        /**
         * Angle of rotation to apply
         * @default 0
         */
        angle: number;
        /**
         * Center of the rotation
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Axis around which to rotate
         * @default [0, 0, 1]
         */
        axis: Base.Vector3;
      }
      class RotateShapesDto<T> {
        constructor(shapes?: T[], axes?: Base.Vector3[], angles?: number[]);
        /**
         * Shape to rotate
         * @default undefined
         */
        shapes: T[];
        /**
         * Axis on which to rotate
         * @default [[0, 0, 1]]
         */
        axes: Base.Vector3[];
        /**
         * Rotation degrees
         * @default [0]
         */
        angles: number[];
      }
      class RotateAroundCenterShapesDto<T> {
        constructor(
          shapes?: T[],
          angles?: number[],
          centers?: Base.Point3[],
          axes?: Base.Vector3[]
        );
        /**
         * Shape to scale
         * @default undefined
         */
        shapes: T[];
        /**
         * Angles of rotation to apply
         * @default [0]
         */
        angles: number[];
        /**
         * Centers around which to rotate
         * @default [[0, 0, 0]]
         */
        centers: Base.Point3[];
        /**
         * Axes around which to rotate
         * @default [[0, 0, 1]]
         */
        axes: Base.Vector3[];
      }
      class ScaleDto<T> {
        constructor(shape?: T, factor?: number);
        /**
         * Shape to scale
         * @default undefined
         */
        shape: T;
        /**
         * Scale factor to apply
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        factor: number;
      }
      class ScaleShapesDto<T> {
        constructor(shapes?: T[], factors?: number[]);
        /**
         * Shape to scale
         * @default undefined
         */
        shapes: T[];
        /**
         * Scale factor to apply
         * @default [1]
         */
        factors: number[];
      }
      class Scale3DDto<T> {
        constructor(shape?: T, scale?: Base.Vector3, center?: Base.Point3);
        /**
         * Shape to scale
         * @default undefined
         */
        shape: T;
        /**
         * Scale factor to apply
         * @default [1, 1, 1]
         */
        scale: Base.Vector3;
        /**
         * Scale from the center
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class Scale3DShapesDto<T> {
        constructor(
          shapes?: T[],
          scales?: Base.Vector3[],
          centers?: Base.Point3[]
        );
        /**
         * Shape to scale
         * @default undefined
         */
        shapes: T[];
        /**
         * Scale factor to apply
         * @default [[1, 1, 1]]
         */
        scales: Base.Vector3[];
        /**
         * Scale from the center
         * @default [[0, 0, 0]]
         */
        centers: Base.Point3[];
      }
      class ShapeToMeshDto<T> {
        constructor(shape?: T, precision?: number, adjustYtoZ?: boolean);
        /**
         * Shape to save
         * @default undefined
         */
        shape: T;
        /**
         * Precision of the mesh
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        precision: number;
        /**
         * Adjust Y (up) coordinate system to Z (up) coordinate system
         * @default false
         */
        adjustYtoZ: boolean;
      }
      class ShapeFacesToPolygonPointsDto<T> {
        constructor(
          shape?: T,
          precision?: number,
          adjustYtoZ?: boolean,
          reversedPoints?: boolean
        );
        /**
         * Shape to save
         * @default undefined
         */
        shape: T;
        /**
         * Precision of the mesh
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        precision: number;
        /**
         * Adjust Y (up) coordinate system to Z (up) coordinate system
         * @default false
         */
        adjustYtoZ: boolean;
        /**
         * Reverse the order of the points describing the polygon because some CAD kernels use the opposite order
         * @default false
         */
        reversedPoints: boolean;
      }
      class ShapesToMeshesDto<T> {
        constructor(shapes?: T[], precision?: number, adjustYtoZ?: boolean);
        /**
         * Shapes to transform
         * @default undefined
         */
        shapes: T[];
        /**
         * Precision of the mesh
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        precision: number;
        /**
         * Adjust Y (up) coordinate system to Z (up) coordinate system
         * @default false
         */
        adjustYtoZ: boolean;
      }
      class SaveStepDto<T> {
        constructor(
          shape?: T,
          fileName?: string,
          adjustYtoZ?: boolean,
          tryDownload?: boolean
        );
        /**
         * Shape to save
         * @default undefined
         */
        shape: T;
        /**
         * File name
         * @default shape.step
         */
        fileName: string;
        /**
         * Adjust Y (up) coordinate system to Z (up) coordinate system
         * @default false
         */
        adjustYtoZ: boolean;
        /**
         * Will assume that the shape is created in right handed coordinate system environment
         * and will compensate by not mirroring the shape along z axis
         * @default false
         */
        fromRightHanded?: boolean;
        /**
         * Will attempt to download the file if that is possible, keep in mind that you might need to implement this yourself. In bitbybit this is handled by worker layers which only run in browsers.
         * @default true
         */
        tryDownload?: boolean;
      }
      class SaveStlDto<T> {
        constructor(
          shape?: T,
          fileName?: string,
          precision?: number,
          adjustYtoZ?: boolean,
          tryDownload?: boolean,
          binary?: boolean
        );
        /**
         * Shape to save
         * @default undefined
         */
        shape: T;
        /**
         * File name
         * @default shape.stl
         */
        fileName: string;
        /**
         * Precision of the mesh - lower means higher res
         * @default 0.01
         */
        precision: number;
        /**
         * Adjust Y (up) coordinate system to Z (up) coordinate system
         * @default false
         */
        adjustYtoZ: boolean;
        /**
         * Will attempt to download the file if that is possible, keep in mind that you might need to implement this yourself. In bitbybit this is handled by worker layers which only run in browsers.
         * @default true
         */
        tryDownload?: boolean;
        /**
         * Generate binary STL file
         * @default true
         */
        binary?: boolean;
      }
      class ShapeToDxfPathsDto<T> {
        constructor(
          shape?: T,
          angularDeflection?: number,
          curvatureDeflection?: number,
          minimumOfPoints?: number,
          uTolerance?: number,
          minimumLength?: number
        );
        /**
         * Shape to convert to DXF paths
         * @default undefined
         */
        shape: T;
        /**
         * The angular deflection for curve tessellation
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        angularDeflection: number;
        /**
         * The curvature deflection for curve tessellation
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        curvatureDeflection: number;
        /**
         * Minimum of points for curve tessellation
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minimumOfPoints: number;
        /**
         * U tolerance for curve tessellation
         * @default 1.0e-9
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-9
         */
        uTolerance: number;
        /**
         * Minimum length for curve tessellation
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-7
         */
        minimumLength: number;
      }
      class DxfPathsWithLayerDto {
        constructor(
          paths?: IO.DxfPathDto[],
          layer?: string,
          color?: Base.Color
        );
        /**
         * Array of DXF paths (output from shapeToDxfPaths)
         * @default undefined
         */
        paths: IO.DxfPathDto[];
        /**
         * Layer name for these paths
         * @default Default
         */
        layer: string;
        /**
         * Color for these paths
         * @default #000000
         */
        color: Base.Color;
      }
      class DxfPathsPartsListDto {
        constructor(
          pathsParts?: IO.DxfPathsPartDto[],
          colorFormat?: dxfColorFormatEnum,
          acadVersion?: dxfAcadVersionEnum,
          tryDownload?: boolean
        );
        /**
         * Array of DXF paths parts (output from dxfPathsWithLayer)
         * @default undefined
         */
        pathsParts: IO.DxfPathsPartDto[];
        /**
         * Color format to use in the DXF file
         * @default aci
         */
        colorFormat: dxfColorFormatEnum;
        /**
         * AutoCAD version format for DXF file
         * @default AC1009
         */
        acadVersion: dxfAcadVersionEnum;
        /**
         * File name
         * @default bitbybit-dev.dxf
         */
        fileName?: string;
        /**
         * Will attempt to download the file if that is possible, keep in mind that you might need to implement this yourself. In bitbybit this is handled by worker layers which only run in browsers.
         * @default true
         */
        tryDownload?: boolean;
      }
      class SaveDxfDto<T> {
        constructor(
          shape?: T,
          fileName?: string,
          tryDownload?: boolean,
          angularDeflection?: number,
          curvatureDeflection?: number,
          minimumOfPoints?: number,
          uTolerance?: number,
          minimumLength?: number
        );
        /**
         * Shape to save
         * @default undefined
         */
        shape: T;
        /**
         * File name
         * @default shape.dxf
         */
        fileName: string;
        /**
         * Will attempt to download the file if that is possible, keep in mind that you might need to implement this yourself. In bitbybit this is handled by worker layers which only run in browsers.
         * @default true
         */
        tryDownload?: boolean;
        /**
         * The angular deflection
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        angularDeflection: number;
        /**
         * The curvature deflection
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        curvatureDeflection: number;
        /**
         * Minimum of points
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minimumOfPoints: number;
        /**
         * U tolerance
         * @default 1.0e-9
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-9
         */
        uTolerance: number;
        /**
         * Minimum length
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 1.0e-7
         */
        minimumLength: number;
      }
      class ImportStepIgesFromTextDto {
        constructor(
          text?: string,
          fileType?: fileTypeEnum,
          adjustZtoY?: boolean
        );
        /**
         * The text that represents step or iges contents
         * @default undefined
         */
        text: string;
        /**
         */
        fileType: fileTypeEnum;
        /**
         * Adjusts models that use Z coordinate as up to Y up system.
         * @default true
         */
        adjustZtoY: boolean;
      }
      class ImportStepIgesDto {
        constructor(assetFile?: File, adjustZtoY?: boolean);
        /**
         * The name of the asset to store in the cache.
         * @default undefined
         */
        assetFile: File;
        /**
         * Adjusts models that use Z coordinate as up to Y up system.
         * @default true
         */
        adjustZtoY: boolean;
      }
      class LoadStepOrIgesDto {
        constructor(
          filetext?: string | ArrayBuffer,
          fileName?: string,
          adjustZtoY?: boolean
        );
        /**
         * File text
         * @default undefined
         */
        filetext: string | ArrayBuffer;
        /**
         * File name
         * @default shape.igs
         */
        fileName: string;
        /**
         * Adjusts models that use Z coordinate as up to Y up system.
         * @default true
         */
        adjustZtoY: boolean;
      }
      class CompoundShapesDto<T> {
        constructor(shapes?: T[]);
        /**
         * Shapes to add to compound
         * @default undefined
         */
        shapes: T[];
      }
      class ThisckSolidSimpleDto<T> {
        constructor(shape?: T, offset?: number);
        /**
         * Shape to make thick
         * @default undefined
         */
        shape: T;
        /**
         * Offset distance
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        offset: number;
      }
      class Offset3DWireDto<T> {
        constructor(shape?: T, offset?: number, direction?: Base.Vector3);
        /**
         * Shape to make thick
         * @default undefined
         */
        shape: T;
        /**
         * Offset distance
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        offset: number;
        /**
         * Direction normal of the plane for the offset
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class FaceFromWireDto<T> {
        constructor(shape?: T, planar?: boolean);
        /**
         * Wire shape to convert into a face
         * @default undefined
         */
        shape: T;
        /**
         * Should plane be planar
         * @default false
         */
        planar: boolean;
      }
      class FaceFromWireOnFaceDto<T, U> {
        constructor(wire?: T, face?: U, inside?: boolean);
        /**
         * Wire shape to convert into a face
         * @default undefined
         */
        wire: T;
        /**
         * Face to attach the wire to
         * @default undefined
         */
        face: U;
        /**
         * Indication if wire is inside the surface or outside
         * @default true
         */
        inside: boolean;
      }
      class FacesFromWiresOnFaceDto<T, U> {
        constructor(wires?: T[], face?: U, inside?: boolean);
        /**
         * Wire shape to convert into a face
         * @default undefined
         */
        wires: T[];
        /**
         * Face to attach the wires to
         * @default undefined
         */
        face: U;
        /**
         * Indication if wire is inside the surface or outside
         * @default true
         */
        inside: boolean;
      }
      class FaceFromWiresDto<T> {
        constructor(shapes?: T[], planar?: boolean);
        /**
         * Wire shapes to convert into a faces
         * @default undefined
         */
        shapes: T[];
        /**
         * Should plane be planar
         * @default false
         */
        planar: boolean;
      }
      class FacesFromWiresDto<T> {
        constructor(shapes?: T[], planar?: boolean);
        /**
         * Wire shapes to convert into a faces
         * @default undefined
         */
        shapes: T[];
        /**
         * Should plane be planar
         * @default false
         */
        planar: boolean;
      }
      class FaceFromWiresOnFaceDto<T, U> {
        constructor(wires?: T[], face?: U, inside?: boolean);
        /**
         * Wire shapes to convert into a faces
         * @default undefined
         */
        wires: T[];
        /**
         * Guide face to use as a base
         * @default undefined
         */
        face: U;
        /**
         * Indication if wire is inside the surface or outside
         * @default true
         */
        inside: boolean;
      }
      class SewDto<T> {
        constructor(shapes?: T[], tolerance?: number);
        /**
         * Faces to construct a shell from
         * @default undefined
         */
        shapes: T[];
        /**
         * Tolerance of sewing
         * @default 1.0e-7
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        tolerance: number;
      }
      class FaceIsoCurveAtParamDto<T> {
        constructor(shape?: T, param?: number, dir?: "u" | "v");
        /**
         * Face shape
         * @default undefined
         */
        shape: T;
        /**
         * Param at which to find isocurve
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        param: number;
        /**
         * Direction to find the isocurve
         * @default u
         */
        dir: "u" | "v";
      }
      class DivideFaceToUVPointsDto<T> {
        constructor(
          shape?: T,
          nrOfPointsU?: number,
          nrOfPointsV?: number,
          flat?: boolean
        );
        /**
         * Face shape
         * @default undefined
         */
        shape: T;
        /**
         * Number of points on U direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrOfPointsU: number;
        /**
         * Number of points on V direction
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrOfPointsV: number;
        /**
         * Flatten the output
         * @default false
         */
        flat: boolean;
      }
      class Geom2dEllipseDto {
        constructor(
          center?: Base.Point2,
          direction?: Base.Vector2,
          radiusMinor?: number,
          radiusMajor?: number,
          sense?: boolean
        );
        /**
         * Center of the ellipse
         * @default [0,0]
         */
        center: Base.Point2;
        /**
         * Direction of the vector
         * @default [1,0]
         */
        direction: Base.Vector2;
        /**
         * Minor radius of an ellipse
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusMinor: number;
        /**
         * Major radius of an ellipse
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusMajor: number;
        /**
         * If true will sense the direction
         * @default false
         */
        sense: boolean;
      }
      class Geom2dCircleDto {
        constructor(
          center?: Base.Point2,
          direction?: Base.Vector2,
          radius?: number,
          sense?: boolean
        );
        /**
         * Center of the circle
         * @default [0,0]
         */
        center: Base.Point2;
        /**
         * Direction of the vector
         * @default [1,0]
         */
        direction: Base.Vector2;
        /**
         * Radius of the circle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * If true will sense the direction
         * @default false
         */
        sense: boolean;
      }
      class ChristmasTreeDto {
        constructor(
          height?: number,
          innerDist?: number,
          outerDist?: number,
          nrSkirts?: number,
          trunkHeight?: number,
          trunkWidth?: number,
          half?: boolean,
          rotation?: number,
          origin?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Height of the tree
         * @default 6
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Inner distance of the branches on the bottom of the tree
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        innerDist: number;
        /**
         * Outer distance of the branches on the bottom of the tree
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        outerDist: number;
        /**
         * Number of skirts on the tree (triangle like shapes)
         * @default 5
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrSkirts: number;
        /**
         * Trunk height
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        trunkHeight: number;
        /**
         * Trunk width only applies if trunk height is more than 0
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        trunkWidth: number;
        /**
         * Indicates wether only a half of the tree should be created
         * @default false
         */
        half: boolean;
        /**
         * Rotation of the tree
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the tree
         * @default [0, 0, 0]
         */
        origin: Base.Point3;
        /**
         * Direction of the tree
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class StarDto {
        constructor(
          outerRadius?: number,
          innerRadius?: number,
          numRays?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          offsetOuterEdges?: number,
          half?: boolean
        );
        /**
         * Center of the circle
         * @default [0,0,0]
         */
        center: Base.Point3;
        /**
         * Direction
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
        /**
         * Direction of the vector
         * @default 7
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        numRays: number;
        /**
         * Angle of the rays
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        outerRadius: number;
        /**
         * Angle of the rays
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        innerRadius: number;
        /**
         * Offsets outer edge cornerners along the direction vector
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        offsetOuterEdges?: number;
        /**
         * Construct half of the star
         * @default false
         */
        half: boolean;
      }
      class ParallelogramDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          aroundCenter?: boolean,
          width?: number,
          height?: number,
          angle?: number
        );
        /**
         * Center of the circle
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
        /**
         * Indicates whether to draw the parallelogram around the center point or start from corner.
         * @default true
         */
        aroundCenter: boolean;
        /**
         * Width of bounding rectangle
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Height of bounding rectangle
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Sharp angle of the parallelogram
         * @default 15
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
      }
      class Heart2DDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          rotation?: number,
          sizeApprox?: number
        );
        /**
         * Center of the circle
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
        /**
         * Rotation of the hear
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Size of the bounding box within which the heart gets drawn
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeApprox: number;
      }
      class NGonWireDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          nrCorners?: number,
          radius?: number
        );
        /**
         * Center of the circle
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
        /**
         * How many corners to create.
         * @default 6
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        nrCorners: number;
        /**
         * Radius of nGon
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
      }
      class EllipseDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          radiusMinor?: number,
          radiusMajor?: number
        );
        /**
         * Center of the ellipse
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Direction of the vector
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
        /**
         * Minor radius of an ellipse
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusMinor: number;
        /**
         * Major radius of an ellipse
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusMajor: number;
      }
      class TextWiresDto {
        constructor(
          text?: string,
          xOffset?: number,
          yOffset?: number,
          height?: number,
          lineSpacing?: number,
          letterSpacing?: number,
          align?: Base.horizontalAlignEnum,
          extrudeOffset?: number,
          origin?: Base.Point3,
          rotation?: number,
          direction?: Base.Vector3,
          centerOnOrigin?: boolean
        );
        /**
         * The text
         * @default Hello World
         */
        text?: string;
        /**
         * The x offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        xOffset?: number;
        /**
         * The y offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        yOffset?: number;
        /**
         * The height of the text
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        height?: number;
        /**
         * The line spacing
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        lineSpacing?: number;
        /**
         * The letter spacing offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        letterSpacing?: number;
        /**
         * The extrude offset
         * @default left
         */
        align?: Base.horizontalAlignEnum;
        /**
         * The extrude offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extrudeOffset?: number;
        /**
         * Indicates whether to center text on origin
         * @default false
         */
        centerOnOrigin: boolean;
      }
      class GeomCylindricalSurfaceDto {
        constructor(
          radius?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /**
         * Radius of the cylindrical surface
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Center of the cylindrical surface
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Axis of direction for cylindrical surface
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class Geom2dTrimmedCurveDto<T> {
        constructor(
          shape?: T,
          u1?: number,
          u2?: number,
          sense?: boolean,
          adjustPeriodic?: boolean
        );
        /**
         * 2D Curve to trim
         * @default undefined
         */
        shape: T;
        /**
         * First param on the curve for trimming. U1 can be greater or lower than U2. The returned curve is oriented from U1 to U2.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        u1: number;
        /**
         * Second parameter on the curve for trimming
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        u2: number;
        /**
         *  If the basis curve C is periodic there is an ambiguity because two parts are available.
         *  In this case by default the trimmed curve has the same orientation as the basis curve (Sense = True).
         * If Sense = False then the orientation of the trimmed curve is opposite to the orientation of the basis curve C.
         * @default true
         */
        sense: boolean;
        /**
         * If the curve is closed but not periodic it is not possible to keep the part of the curve including the
         * junction point (except if the junction point is at the beginning or at the end of the trimmed curve)
         * because you could lose the fundamental characteristics of the basis curve which are used for example
         * to compute the derivatives of the trimmed curve. So for a closed curve the rules are the same as for a open curve.
         * @default true
         */
        adjustPeriodic: boolean;
      }
      class Geom2dSegmentDto {
        constructor(start?: Base.Point2, end?: Base.Point2);
        /**
         * Start 2d point for segment
         * @default [0, 0]
         */
        start: Base.Point2;
        /**
         * End 2d point for segment
         * @default [1, 0]
         */
        end: Base.Point2;
      }
      class SliceDto<T> {
        constructor(shape?: T, step?: number, direction?: Base.Vector3);
        /**
         * The shape to slice
         * @default undefined
         */
        shape: T;
        /**
         * Step at which to divide the shape
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        step: number;
        /**
         * Direction vector
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class SliceInStepPatternDto<T> {
        constructor(shape?: T, steps?: number[], direction?: Base.Vector3);
        /**
         * The shape to slice
         * @default undefined
         */
        shape: T;
        /**
         * Steps that should be used for slicing. This array is going to be treated as a pattern -
         * this menas that if the actual number of steps is lower than the number of steps in the pattern, the pattern will be repeated.
         * @default [0.1, 0.2]
         */
        steps: number[];
        /**
         * Direction vector
         * @default [0, 1, 0]
         */
        direction: Base.Vector3;
      }
      class SimpleLinearLengthDimensionDto {
        constructor(
          start?: Base.Point3,
          end?: Base.Point3,
          direction?: Base.Vector3,
          offsetFromPoints?: number,
          crossingSize?: number,
          labelSuffix?: string,
          labelSize?: number,
          labelOffset?: number,
          labelRotation?: number,
          arrowType?: dimensionEndTypeEnum,
          arrowSize?: number,
          arrowAngle?: number,
          arrowsFlipped?: boolean,
          labelFlipHorizontal?: boolean,
          labelFlipVertical?: boolean,
          labelOverwrite?: string,
          removeTrailingZeros?: boolean
        );
        /**
         * The start point for dimension
         * @default undefined
         */
        start: Base.Point3;
        /**
         * The end point for dimension
         * @default undefined
         */
        end?: Base.Point3;
        /**
         * The dimension direction (must include length)
         * @default undefined
         */
        direction?: Base.Vector3;
        /**
         * The dimension label
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        offsetFromPoints?: number;
        /**
         * The dimension crossing size
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        crossingSize?: number;
        /**
         * The dimension label decimal places
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        decimalPlaces?: number;
        /**
         * The dimension label suffix
         * @default (cm)
         */
        labelSuffix?: string;
        /**
         * The dimension label size
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelSize?: number;
        /**
         * The dimension label offset
         * @default 0.3
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset?: number;
        /**
         * The dimension label rotation
         * @default 0
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        labelRotation?: number;
        /**
         * End type for dimension
         * @default none
         */
        endType?: dimensionEndTypeEnum;
        /**
         * The size/length of dimension arrows
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        arrowSize?: number;
        /**
         * The total angle between arrow lines (max 90 degrees)
         * @default 30
         * @minimum 0
         * @maximum 90
         * @step 1
         */
        arrowAngle?: number;
        /**
         * Flip arrows to point outward instead of inward
         * @default false
         */
        arrowsFlipped?: boolean;
        /**
         * Flip label horizontally
         * @default false
         */
        labelFlipHorizontal?: boolean;
        /**
         * Flip label vertically
         * @default false
         */
        labelFlipVertical?: boolean;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', 'Length: val mm')
         * @default 1*val
         * @optional true
         */
        labelOverwrite?: string;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros?: boolean;
      }
      class SimpleAngularDimensionDto {
        constructor(
          direction1?: Base.Point3,
          direction2?: Base.Point3,
          center?: Base.Point3,
          radius?: number,
          offsetFromCenter?: number,
          crossingSize?: number,
          radians?: boolean,
          labelSuffix?: string,
          labelSize?: number,
          labelOffset?: number,
          endType?: dimensionEndTypeEnum,
          arrowSize?: number,
          arrowAngle?: number,
          arrowsFlipped?: boolean,
          labelRotation?: number,
          labelFlipHorizontal?: boolean,
          labelFlipVertical?: boolean,
          labelOverwrite?: string,
          removeTrailingZeros?: boolean
        );
        /**
         * The first direction for dimension
         * @default [1, 0, 0]
         */
        direction1: Base.Point3;
        /**
         * The second direction for dimension
         * @default [0, 0, 1]
         */
        direction2: Base.Point3;
        /**
         * The center point for dimension
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * The dimension radius
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Offset from center
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        offsetFromCenter: number;
        /**
         * The dimension crossing size
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extraSize: number;
        /**
         * The dimension label decimal places
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        decimalPlaces: number;
        /**
         * The dimension label suffix
         * @default (deg)
         */
        labelSuffix: string;
        /**
         * The dimension label size
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelSize: number;
        /**
         * The dimension label offset
         * @default 0.3
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset: number;
        /**
         * If true the angle is in radians
         * @default false
         */
        radians: boolean;
        /**
         * End type for dimension
         * @default none
         */
        endType?: dimensionEndTypeEnum;
        /**
         * The size/length of dimension arrows
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        arrowSize?: number;
        /**
         * The total angle between arrow lines (max 90 degrees)
         * @default 30
         * @minimum 0
         * @maximum 90
         * @step 1
         */
        arrowAngle?: number;
        /**
         * Flip arrows to point outward instead of inward
         * @default false
         */
        arrowsFlipped?: boolean;
        /**
         * Additional rotation angle for the label in degrees
         * @default 0
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        labelRotation?: number;
        /**
         * Flip label horizontally
         * @default false
         */
        labelFlipHorizontal?: boolean;
        /**
         * Flip label vertically
         * @default false
         */
        labelFlipVertical?: boolean;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', 'Angle: val deg')
         * @default 1*val
         * @optional true
         */
        labelOverwrite?: string;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros?: boolean;
      }
      class PinWithLabelDto {
        constructor(
          startPoint?: Base.Point3,
          endPoint?: Base.Point3,
          direction?: Base.Vector3,
          offsetFromStart?: number,
          label?: string,
          labelOffset?: number,
          labelSize?: number,
          endType?: dimensionEndTypeEnum,
          arrowSize?: number,
          arrowAngle?: number,
          arrowsFlipped?: boolean,
          labelRotation?: number,
          labelFlipHorizontal?: boolean,
          labelFlipVertical?: boolean
        );
        /**
         * The start point for dimension
         * @default [0, 0, 0]
         */
        startPoint: Base.Point3;
        /**
         * The end point for dimension
         * @default [0, 5, 2]
         */
        endPoint?: Base.Point3;
        /**
         * The dimension direction (must include length)
         * @default [0, 0, 1]
         */
        direction?: Base.Vector3;
        /**
         * Offset from the start point
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        offsetFromStart?: number;
        /**
         * The dimension label
         * @default Pin
         */
        label?: string;
        /**
         * The dimension label offset
         * @default 0.3
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset?: number;
        /**
         * The dimension label size
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelSize?: number;
        /**
         * End type for dimension
         * @default none
         */
        endType?: dimensionEndTypeEnum;
        /**
         * The size/length of dimension arrows
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        arrowSize?: number;
        /**
         * The total angle between arrow lines (max 90 degrees)
         * @default 30
         * @minimum 0
         * @maximum 90
         * @step 1
         */
        arrowAngle?: number;
        /**
         * Flip arrows to point outward instead of inward
         * @default false
         */
        arrowsFlipped?: boolean;
        /**
         * Additional rotation angle for the label in degrees
         * @default 0
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        labelRotation?: number;
        /**
         * Flip label horizontally
         * @default false
         */
        labelFlipHorizontal?: boolean;
        /**
         * Flip label vertically
         * @default false
         */
        labelFlipVertical?: boolean;
      }
      class StarSolidDto extends StarDto {
        constructor(
          outerRadius?: number,
          innerRadius?: number,
          numRays?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          offsetOuterEdges?: number,
          half?: boolean,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class NGonSolidDto extends NGonWireDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          nrCorners?: number,
          radius?: number,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class ParallelogramSolidDto extends ParallelogramDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          aroundCenter?: boolean,
          width?: number,
          height?: number,
          angle?: number,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class HeartSolidDto extends Heart2DDto {
        constructor(
          center?: Base.Point3,
          direction?: Base.Vector3,
          rotation?: number,
          sizeApprox?: number,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class ChristmasTreeSolidDto extends ChristmasTreeDto {
        constructor(
          height?: number,
          innerDist?: number,
          outerDist?: number,
          nrSkirts?: number,
          trunkHeight?: number,
          trunkWidth?: number,
          half?: boolean,
          rotation?: number,
          origin?: Base.Point3,
          direction?: Base.Vector3,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
      class LPolygonSolidDto extends LPolygonDto {
        constructor(
          widthFirst?: number,
          lengthFirst?: number,
          widthSecond?: number,
          lengthSecond?: number,
          align?: directionEnum,
          rotation?: number,
          center?: Base.Point3,
          direction?: Base.Vector3,
          extrusionLengthFront?: number,
          extrusionLengthBack?: number
        );
        /**
         * Extrusion length in the forward direction
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthFront: number;
        /**
         * Extrusion length in the backward direction
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extrusionLengthBack: number;
      }
    }
    declare namespace BabylonCamera {
      class ArcRotateCameraDto {
        constructor(
          radius?: number,
          alpha?: number,
          beta?: number,
          lowerRadiusLimit?: number,
          upperRadiusLimit?: number,
          lowerAlphaLimit?: number,
          upperAlphaLimit?: number,
          lowerBetaLimit?: number,
          upperBetaLimit?: number,
          angularSensibilityX?: number,
          angularSensibilityY?: number,
          panningSensibility?: number,
          wheelPrecision?: number,
          maxZ?: number
        );
        /**
         * Defines the camera distance from its target. This radius will be used to rotate the camera around the target as default.
         * @default 20
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        radius: number;
        /**
         * Target of the arc rotate camera. Camera will look at and rotate around this point by default.
         * @default [0, 0, 0]
         */
        target: Base.Point3;
        /**
         * Defines the camera rotation along the longitudinal (horizontal) axis in degrees
         * @default 45
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        alpha: number;
        /**
         * Defines the camera rotation along the latitudinal (vertical) axis in degrees. This is counted from top down, where 0 is looking from top straight down.
         * @default 70
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        beta: number;
        /**
         * Lower radius limit - how close can the camera be to the target
         * @default undefined
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         * @optional true
         */
        lowerRadiusLimit: any;
        /**
         * Upper radius limit - how far can the camera be from the target
         * @default undefined
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         * @optional true
         */
        upperRadiusLimit: any;
        /**
         * Lower alpha limit - camera rotation along the longitudinal (horizontal) axis in degrees.
         * @default undefined
         * @minimum -360
         * @maximum 360
         * @step 1
         * @optional true
         */
        lowerAlphaLimit: any;
        /**
         * Upper alpha limit - camera rotation along the longitudinal (horizontal) axis in degrees.
         * @default undefined
         * @minimum -360
         * @maximum 360
         * @step 1
         * @optional true
         */
        upperAlphaLimit: any;
        /**
         * Lower beta limit - camera rotation along the latitudinal (vertical) axis in degrees. This is counted from the top down, where 0 is looking from top straight down.
         * @default 1
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        lowerBetaLimit: number;
        /**
         * Upper beta limit - camera rotation along the longitudinal (vertical) axis in degrees. This is counted from the top down, where 180 is looking from bottom straight up.
         * @default 179
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        upperBetaLimit: number;
        /**
         * Angular sensibility along x (horizontal) axis of the camera
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        angularSensibilityX: number;
        /**
         * Angular sensibility along y (vertical) axis of the camera
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        angularSensibilityY: number;
        /**
         * Panning sensibility. The lower this number gets the faster camera will move when panning.
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 100
         */
        panningSensibility: number;
        /**
         * Wheel precision. The lower this number gets the faster camera will move when zooming.
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        wheelPrecision: number;
        /**
         * Maximum distance the camera can see. Objects that are further away from the camera than this value will not be rendered.
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        maxZ: number;
      }
      class FreeCameraDto {
        constructor(position?: Base.Point3, target?: Base.Point3);
        /**
         * Position of the free camera
         * @default [20, 20, 20]
         */
        position: Base.Point3;
        /**
         * Target of the free camera
         * @default [0, 0, 0]
         */
        target: Base.Point3;
      }
      class TargetCameraDto {
        constructor(position?: Base.Point3, target?: Base.Point3);
        /**
         * Position of the free camera
         * @default [20, 20, 20]
         */
        position: Base.Point3;
        /**
         * Target of the free camera
         * @default [0, 0, 0]
         */
        target: Base.Point3;
      }
      class PositionDto {
        constructor(camera?: BABYLON.TargetCamera, position?: Base.Point3);
        /**
         * Target camera
         */
        camera: BABYLON.TargetCamera;
        /**
         * Position of the free camera
         * @default [20, 20, 20]
         */
        position: Base.Point3;
      }
      class SpeedDto {
        constructor(camera?: BABYLON.TargetCamera, speed?: number);
        /**
         * Target camera
         */
        camera: BABYLON.TargetCamera;
        /**
         * speed of the camera
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        speed: number;
      }
      class TargetDto {
        constructor(camera?: BABYLON.TargetCamera, target?: Base.Point3);
        /**
         * Target camera
         */
        camera: BABYLON.TargetCamera;
        /**
         * target of the camera
         * @default [0, 0, 0]
         */
        target: Base.Point3;
      }
      class MinZDto {
        constructor(camera?: BABYLON.Camera, minZ?: number);
        /**
         * Free camera
         */
        camera: BABYLON.Camera;
        /**
         * minZ of the camera
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        minZ: number;
      }
      class MaxZDto {
        constructor(camera?: BABYLON.Camera, maxZ?: number);
        /**
         * Free camera
         */
        camera: BABYLON.Camera;
        /**
         * maxZ of the camera
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        maxZ: number;
      }
      class OrthographicDto {
        constructor(
          camera?: BABYLON.Camera,
          orthoLeft?: number,
          orthoRight?: number,
          orthoTop?: number,
          orthoBottom?: number
        );
        /**
         * Camera to adjust
         */
        camera: BABYLON.Camera;
        /**
         * Left side limit of the orthographic camera
         * @default -1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        orthoLeft: number;
        /**
         * Right side limit of the orthographic camera
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        orthoRight: number;
        /**
         * Bottom side limit of the orthographic camera
         * @default -1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        orthoBottom: number;
        /**
         * Top side limit of the orthographic camera
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        orthoTop: number;
      }
      class CameraDto {
        constructor(camera?: BABYLON.Camera);
        /**
         * Camera
         */
        camera: BABYLON.Camera;
      }
    }
    declare namespace BabylonGaussianSplatting {
      class CreateGaussianSplattingMeshDto {
        constructor(url?: string);
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        url: string;
      }
      class GaussianSplattingMeshDto {
        constructor(babylonMesh?: BABYLON.GaussianSplattingMesh);
        /**
         * Gaussian Splatting Mesh that needs to be updated
         */
        babylonMesh: BABYLON.GaussianSplattingMesh;
      }
    }
    declare namespace BabylonGizmo {
      enum positionGizmoObservableSelectorEnum {
        /** Fires an event when any of it's sub gizmos are dragged */
        onDragStartObservable = "onDragStartObservable",
        /** Fires an event when any of it's sub gizmos are being dragged */
        onDragObservable = "onDragObservable",
        /** Fires an event when any of it's sub gizmos are released from dragging */
        onDragEndObservable = "onDragEndObservable",
      }
      enum rotationGizmoObservableSelectorEnum {
        /** Fires an event when any of it's sub gizmos are dragged */
        onDragStartObservable = "onDragStartObservable",
        /** Fires an event when any of it's sub gizmos are being dragged */
        onDragObservable = "onDragObservable",
        /** Fires an event when any of it's sub gizmos are released from dragging */
        onDragEndObservable = "onDragEndObservable",
      }
      enum scaleGizmoObservableSelectorEnum {
        /** Fires an event when any of it's sub gizmos are dragged */
        onDragStartObservable = "onDragStartObservable",
        /** Fires an event when any of it's sub gizmos are being dragged */
        onDragObservable = "onDragObservable",
        /** Fires an event when any of it's sub gizmos are released from dragging */
        onDragEndObservable = "onDragEndObservable",
      }
      enum boundingBoxGizmoObservableSelectorEnum {
        /**
         * Fired when a rotation anchor or scale box is dragged
         */
        onDragStartObservable = "onDragStartObservable",
        /**
         * Fired when a scale box is dragged
         */
        onScaleBoxDragObservable = "onScaleBoxDragObservable",
        /**
         * Fired when a scale box drag is ended
         */
        onScaleBoxDragEndObservable = "onScaleBoxDragEndObservable",
        /**
         * Fired when a rotation anchor is dragged
         */
        onRotationSphereDragObservable = "onRotationSphereDragObservable",
        /**
         * Fired when a rotation anchor drag is ended
         */
        onRotationSphereDragEndObservable = "onRotationSphereDragEndObservable",
      }
      class CreateGizmoDto {
        constructor(
          positionGizmoEnabled?: boolean,
          rotationGizmoEnabled?: boolean,
          scaleGizmoEnabled?: boolean,
          boundingBoxGizmoEnabled?: boolean,
          attachableMeshes?: BABYLON.AbstractMesh[],
          clearGizmoOnEmptyPointerEvent?: boolean,
          scaleRatio?: number,
          usePointerToAttachGizmos?: boolean
        );
        /**
         * Enable position gizmo
         * @default true
         */
        positionGizmoEnabled: boolean;
        /**
         * Enable rotation gizmo
         * @default false
         */
        rotationGizmoEnabled: boolean;
        /**
         * Enable scale gizmo
         * @default false
         */
        scaleGizmoEnabled: boolean;
        /**
         * Enable bounding box gizmo
         * @default false
         */
        boundingBoxGizmoEnabled: boolean;
        /**
         * Use pointer to attach gizmos
         * @default true
         */
        usePointerToAttachGizmos: boolean;
        /**
         * Clear gizmo on empty pointer event
         * @default false
         */
        clearGizmoOnEmptyPointerEvent: boolean;
        /**
         * Scale ratio
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleRatio: number;
        /**
         * Attachable meshes
         * @default undefined
         */
        attachableMeshes: BABYLON.AbstractMesh[];
      }
      class GizmoDto {
        constructor(gizmo?: BABYLON.IGizmo);
        /**
         * Gizmo to use
         * @default undefined
         */
        gizmo: BABYLON.IGizmo;
      }
      class SetGizmoScaleRatioDto {
        constructor(gizmo?: BABYLON.IGizmo, scaleRatio?: number);
        /**
         * gizmo
         * @default undefined
         */
        gizmo: BABYLON.IGizmo;
        /**
         * Scale ratio
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleRatio: number;
      }
      class GizmoManagerDto {
        constructor(gizmoManager?: BABYLON.GizmoManager);
        /**
         * Gizmo manager to use
         * @default undefined
         */
        gizmoManager: BABYLON.GizmoManager;
      }
      class PositionGizmoDto {
        constructor(gizmoManager?: BABYLON.IPositionGizmo);
        /**
         * Gizmo manager to use
         * @default undefined
         */
        positionGizmo: BABYLON.IPositionGizmo;
      }
      class SetPlanarGizmoEnabled {
        constructor(
          positionGizmo?: BABYLON.IPositionGizmo,
          planarGizmoEnabled?: boolean
        );
        /**
         * Position gizmo
         * @default undefined
         */
        positionGizmo: BABYLON.IPositionGizmo;
        /**
         * Planar gizmo enabled
         * @default true
         */
        planarGizmoEnabled: boolean;
      }
      class SetScaleGizmoSnapDistanceDto {
        constructor(scaleGizmo?: BABYLON.IScaleGizmo, snapDistance?: number);
        /**
         * Scale gizmo
         * @default undefined
         */
        scaleGizmo: BABYLON.IScaleGizmo;
        /**
         * Snap distance
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        snapDistance: number;
      }
      class SetScaleGizmoIncrementalSnapDto {
        constructor(
          scaleGizmo?: BABYLON.IScaleGizmo,
          incrementalSnap?: boolean
        );
        /**
         * Scale gizmo
         * @default undefined
         */
        scaleGizmo: BABYLON.IScaleGizmo;
        /**
         * Incremental snap
         * @default false
         */
        incrementalSnap: boolean;
      }
      class SetScaleGizmoSensitivityDto {
        constructor(scaleGizmo?: BABYLON.IScaleGizmo, sensitivity?: number);
        /**
         * Scale gizmo
         * @default undefined
         */
        scaleGizmo: BABYLON.IScaleGizmo;
        /**
         * Sensitivity
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sensitivity: number;
      }
      class ScaleGizmoDto {
        constructor(scaleGizmo?: BABYLON.IScaleGizmo);
        /**
         * Scale gizmo
         * @default undefined
         */
        scaleGizmo: BABYLON.IScaleGizmo;
      }
      class BoundingBoxGizmoDto {
        constructor(boundingBoxGizmo?: BABYLON.BoundingBoxGizmo);
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
      }
      class SetBoundingBoxGizmoRotationSphereSizeDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          rotationSphereSize?: number
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * The size of the rotation anchors attached to the bounding box (Default: 0.1)
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        rotationSphereSize: number;
      }
      class SetBoundingBoxGizmoFixedDragMeshScreenSizeDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          fixedDragMeshScreenSize?: boolean
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * fiex drag mesh screen size
         * @default false
         */
        fixedDragMeshScreenSize: boolean;
      }
      class SetBoundingBoxGizmoFixedDragMeshBoundsSizeDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          fixedDragMeshBoundsSize?: boolean
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * fixed drag mesh bounds size
         * @default false
         */
        fixedDragMeshBoundsSize: boolean;
      }
      class SetBoundingBoxGizmoFixedDragMeshScreenSizeDistanceFactorDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          fixedDragMeshScreenSizeDistanceFactor?: number
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * fixed drag mesh screen size distance factor
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fixedDragMeshScreenSizeDistanceFactor: number;
      }
      class SetBoundingBoxGizmoScalingSnapDistanceDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          scalingSnapDistance?: number
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * Scaling snap distance
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scalingSnapDistance: number;
      }
      class SetBoundingBoxGizmoRotationSnapDistanceDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          rotationSnapDistance?: number
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * Rotation snap distance
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        rotationSnapDistance: number;
      }
      class SetBoundingBoxGizmoScaleBoxSizeDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          scaleBoxSize?: number
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * The size of the scale boxes attached to the bounding box (Default: 0.1)
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleBoxSize: number;
      }
      class SetBoundingBoxGizmoIncrementalSnapDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          incrementalSnap?: boolean
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * Incremental snap
         * @default false
         */
        incrementalSnap: boolean;
      }
      class SetBoundingBoxGizmoScalePivotDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          scalePivot?: Base.Vector3
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * Scale pivot
         * @default undefined
         */
        scalePivot: Base.Vector3;
      }
      class SetBoundingBoxGizmoAxisFactorDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          axisFactor?: Base.Vector3
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * Axis factor
         * @default undefined
         */
        axisFactor: Base.Vector3;
      }
      class SetBoundingBoxGizmoScaleDragSpeedDto {
        constructor(
          boundingBoxGizmo?: BABYLON.BoundingBoxGizmo,
          scaleDragSpeed?: number
        );
        /**
         * Bounding box gizmo
         * @default undefined
         */
        boundingBoxGizmo: BABYLON.BoundingBoxGizmo;
        /**
         * Scale drag speed
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scaleDragSpeed: number;
      }
      class SetPositionGizmoSnapDistanceDto {
        constructor(
          positionGizmo?: BABYLON.IPositionGizmo,
          snapDistance?: number
        );
        /**
         * Position gizmo
         * @default undefined
         */
        positionGizmo: BABYLON.IPositionGizmo;
        /**
         * Snap distance
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        snapDistance: number;
      }
      class SetRotationGizmoSnapDistanceDto {
        constructor(
          rotationGizmo?: BABYLON.IRotationGizmo,
          snapDistance?: number
        );
        /**
         * Position gizmo
         * @default undefined
         */
        rotationGizmo: BABYLON.IRotationGizmo;
        /**
         * Snap distance
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        snapDistance: number;
      }
      class SetRotationGizmoSensitivityDto {
        constructor(
          rotationGizmo?: BABYLON.IRotationGizmo,
          sensitivity?: number
        );
        /**
         * Position gizmo
         * @default undefined
         */
        rotationGizmo: BABYLON.IRotationGizmo;
        /**
         * Sensitivity
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sensitivity: number;
      }
      class RotationGizmoDto {
        constructor(rotationGizmo?: BABYLON.IRotationGizmo);
        /**
         * Rotation gizmo
         * @default undefined
         */
        rotationGizmo: BABYLON.IRotationGizmo;
      }
      class AxisScaleGizmoDto {
        constructor(axisScaleGizmo?: BABYLON.IAxisScaleGizmo);
        /**
         * axis scale gizmo
         * @default undefined
         */
        axisScaleGizmo: BABYLON.IAxisScaleGizmo;
      }
      class SetIsEnabledAxisScaleGizmoDto {
        constructor(
          gizmoManager?: BABYLON.IAxisScaleGizmo,
          isEnabled?: boolean
        );
        /**
         * axis scale gizmo
         * @default undefined
         */
        axisScaleGizmo: BABYLON.IAxisScaleGizmo;
        /**
         * Is enabled
         * @default true
         */
        isEnabled: boolean;
      }
      class AxisDragGizmoDto {
        constructor(axisDragGizmo?: BABYLON.IAxisDragGizmo);
        /**
         * axis drag gizmo
         * @default undefined
         */
        axisDragGizmo: BABYLON.IAxisDragGizmo;
      }
      class SetIsEnabledAxisDragGizmoDto {
        constructor(gizmoManager?: BABYLON.IAxisDragGizmo, isEnabled?: boolean);
        /**
         * axis drag gizmo
         * @default undefined
         */
        axisDragGizmo: BABYLON.IAxisDragGizmo;
        /**
         * Is enabled
         * @default true
         */
        isEnabled: boolean;
      }
      class SetIsEnabledPlaneRotationGizmoDto {
        constructor(
          planeRotationGizmo?: BABYLON.IPlaneRotationGizmo,
          isEnabled?: boolean
        );
        /**
         * plane drag gizmo
         * @default undefined
         */
        planeRotationGizmo: BABYLON.IPlaneRotationGizmo;
        /**
         * Is enabled
         * @default true
         */
        isEnabled: boolean;
      }
      class SetIsEnabledPlaneDragGizmoDto {
        constructor(
          planeDragGizmo?: BABYLON.IPlaneDragGizmo,
          isEnabled?: boolean
        );
        /**
         * plane drag gizmo
         * @default undefined
         */
        planeDragGizmo: BABYLON.IPlaneDragGizmo;
        /**
         * Is enabled
         * @default true
         */
        isEnabled: boolean;
      }
      class PlaneDragGizmoDto {
        constructor(planeDragGizmo?: BABYLON.IPlaneDragGizmo);
        /**
         * plane drag gizmo
         * @default undefined
         */
        planeDragGizmo: BABYLON.IPlaneDragGizmo;
      }
      class PlaneRotationGizmoDto {
        constructor(planeRotationGizmo?: BABYLON.IPlaneRotationGizmo);
        /**
         * plane drag gizmo
         * @default undefined
         */
        planeRotationGizmo: BABYLON.IPlaneRotationGizmo;
      }
      class AttachToMeshDto {
        constructor(
          mesh: BABYLON.AbstractMesh,
          gizmoManager: BABYLON.GizmoManager
        );
        /**
         * Mesh to attach gizmo manager to
         */
        mesh: BABYLON.AbstractMesh;
        /**
         * Gizmo manager to attach
         */
        gizmoManager: BABYLON.GizmoManager;
      }
      class PositionGizmoObservableSelectorDto {
        constructor(selector: positionGizmoObservableSelectorEnum);
        /**
         * Selector
         */
        selector: positionGizmoObservableSelectorEnum;
      }
      class BoundingBoxGizmoObservableSelectorDto {
        constructor(selector: boundingBoxGizmoObservableSelectorEnum);
        /**
         * Selector
         */
        selector: boundingBoxGizmoObservableSelectorEnum;
      }
      class RotationGizmoObservableSelectorDto {
        constructor(selector: rotationGizmoObservableSelectorEnum);
        /**
         * Selector
         */
        selector: rotationGizmoObservableSelectorEnum;
      }
      class ScaleGizmoObservableSelectorDto {
        constructor(selector: scaleGizmoObservableSelectorEnum);
        /**
         * Selector
         */
        selector: scaleGizmoObservableSelectorEnum;
      }
    }
    declare namespace BabylonGui {
      enum horizontalAlignmentEnum {
        left = "left",
        center = "center",
        right = "right",
      }
      enum verticalAlignmentEnum {
        top = "top",
        center = "center",
        bottom = "bottom",
      }
      enum inputTextObservableSelectorEnum {
        /** Observable raised when the text changes */
        onTextChangedObservable = "onTextChangedObservable",
        /** Observable raised just before an entered character is to be added */
        onBeforeKeyAddObservable = "onBeforeKeyAddObservable",
        /** Observable raised when the text is highlighted */
        onTextHighlightObservable = "onTextHighlightObservable",
        /** Observable raised when copy event is triggered */
        onTextCopyObservable = "onTextCopyObservable",
        /** Observable raised when cut event is triggered */
        onTextCutObservable = "onTextCutObservable",
        /** Observable raised when paste event is triggered */
        onTextPasteObservable = "onTextPasteObservable",
      }
      enum sliderObservableSelectorEnum {
        /**
         * Raised when the value has changed
         */
        onValueChangedObservable = "onValueChangedObservable",
      }
      enum colorPickerObservableSelectorEnum {
        /**
         * Raised when the value has changed
         */
        onValueChangedObservable = "onValueChangedObservable",
      }
      enum textBlockObservableSelectorEnum {
        /**
         * Raised when the text has changed
         */
        onTextChangedObservable = "onTextChangedObservable",
      }
      enum checkboxObservableSelectorEnum {
        /**
         * Raised when the checkbox is checked or unchecked
         */
        onIsCheckedChangedObservable = "onIsCheckedChangedObservable",
      }
      enum radioButtonObservableSelectorEnum {
        /**
         * Raised when the radio button is checked or unchecked
         */
        onIsCheckedChangedObservable = "onIsCheckedChangedObservable",
      }
      enum controlObservableSelectorEnum {
        onFocusObservable = "onFocusObservable",
        onBlurObservable = "onBlurObservable",
        /**
         * Observable that fires whenever the accessibility event of the control has changed
         */
        onAccessibilityTagChangedObservable = "onAccessibilityTagChangedObservable",
        /**
         * An event triggered when pointer wheel is scrolled
         */
        onWheelObservable = "onWheelObservable",
        /**
         * An event triggered when the pointer moves over the control.
         */
        onPointerMoveObservable = "onPointerMoveObservable",
        /**
         * An event triggered when the pointer moves out of the control.
         */
        onPointerOutObservable = "onPointerOutObservable",
        /**
         * An event triggered when the pointer taps the control
         */
        onPointerDownObservable = "onPointerDownObservable",
        /**
         * An event triggered when pointer up
         */
        onPointerUpObservable = "onPointerUpObservable",
        /**
         * An event triggered when a control is clicked on
         */
        onPointerClickObservable = "onPointerClickObservable",
        /**
         * An event triggered when a control receives an ENTER key down event
         */
        onEnterPressedObservable = "onEnterPressedObservable",
        /**
         * An event triggered when pointer enters the control
         */
        onPointerEnterObservable = "onPointerEnterObservable",
        /**
         * An event triggered when the control is marked as dirty
         */
        onDirtyObservable = "onDirtyObservable",
        /**
         * An event triggered before drawing the control
         */
        onBeforeDrawObservable = "onBeforeDrawObservable",
        /**
         * An event triggered after the control was drawn
         */
        onAfterDrawObservable = "onAfterDrawObservable",
        /**
         * An event triggered when the control has been disposed
         */
        onDisposeObservable = "onDisposeObservable",
        /**
         * An event triggered when the control isVisible is changed
         */
        onIsVisibleChangedObservable = "onIsVisibleChangedObservable",
      }
      class CreateFullScreenUIDto {
        constructor(
          name?: string,
          foreground?: boolean,
          adaptiveScaling?: boolean
        );
        /**
         * Name of advanced texture
         * @default fullscreen
         */
        name: string;
        /**
         * Foreground
         * @default true
         */
        foreground?: boolean;
        /**
         * Adaptive scaling
         * @default false
         */
        adaptiveScaling?: boolean;
      }
      class CreateForMeshDto {
        constructor(
          mesh?: BABYLON.AbstractMesh,
          width?: number,
          height?: number,
          supportPointerMove?: boolean,
          onlyAlphaTesting?: boolean,
          invertY?: boolean,
          sampling?: BabylonTexture.samplingModeEnum
        );
        /**
         * Mesh
         * @default undefined
         */
        mesh: BABYLON.AbstractMesh;
        /**
         * Width
         * @default undefined
         * @optional true
         */
        width?: number;
        /**
         * Height
         * @default undefined
         * @optional true
         */
        height?: number;
        /**
         * Support pointer move
         * @default true
         */
        supportPointerMove: boolean;
        /**
         * Only alpha testing
         * @default false
         */
        onlyAlphaTesting: boolean;
        /**
         * Invert Y
         * @default true
         */
        invertY: boolean;
        /**
         * Sampling
         * @default trilinear
         */
        sampling: BabylonTexture.samplingModeEnum;
      }
      class CreateStackPanelDto {
        constructor(
          name?: string,
          isVertical?: boolean,
          spacing?: number,
          width?: number | string,
          height?: number | string,
          color?: string,
          background?: string
        );
        /**
         * Name of stack panel
         * @default stackPanel
         */
        name: string;
        /**
         * Horizontal or vertical
         * @default true
         */
        isVertical: boolean;
        /**
         * Spacing between each child in pixels
         * @default 0
         */
        spacing: number;
        /**
         * Width of the stack panel. This value should not be set when in horizontal mode as it will be computed automatically.
         * @default undefined
         * @optional true
         */
        width: number | string;
        /**
         * Height of the stack panel. This value should not be set when in vertical mode as it will be computed automatically.
         * @default undefined
         * @optional true
         */
        height: number | string;
        /**
         * Color of the stack panel
         * @default #00000000
         */
        color: string;
        /**
         * Background of the stack panel. We give transparency to the background by default so that it would be visible
         * @default #00000055
         */
        background: string;
      }
      class SetStackPanelIsVerticalDto {
        constructor(stackPanel?: BABYLON.GUI.StackPanel, isVertical?: boolean);
        /**
         * Stack panel to update
         * @default undefined
         */
        stackPanel: BABYLON.GUI.StackPanel;
        /**
         * Is vertical
         * @default true
         */
        isVertical: boolean;
      }
      class SetStackPanelSpacingDto {
        constructor(stackPanel?: BABYLON.GUI.StackPanel, spacing?: number);
        /**
         * Stack panel to update
         * @default undefined
         */
        stackPanel: BABYLON.GUI.StackPanel;
        /**
         * Spacing between each child in pixels
         * @default 0
         */
        spacing: number;
      }
      class SetStackPanelWidthDto {
        constructor(
          stackPanel?: BABYLON.GUI.StackPanel,
          width?: number | string
        );
        /**
         * Stack panel to update
         * @default undefined
         */
        stackPanel: BABYLON.GUI.StackPanel;
        /**
         * Width of the stack panel
         * @default undefined
         * @optional true
         */
        width: number | string;
      }
      class SetStackPanelHeightDto {
        constructor(
          stackPanel?: BABYLON.GUI.StackPanel,
          height?: number | string
        );
        /**
         * Stack panel to update
         * @default undefined
         */
        stackPanel: BABYLON.GUI.StackPanel;
        /**
         * Height of the stack panel.
         * @default undefined
         * @optional true
         */
        height: number | string;
      }
      class StackPanelDto {
        constructor(stackPanel?: BABYLON.GUI.StackPanel);
        /**
         * Stack panel to update
         * @default undefined
         */
        stackPanel: BABYLON.GUI.StackPanel;
      }
      class SliderObservableSelectorDto {
        constructor(selector: sliderObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onValueChangedObservable
         */
        selector: sliderObservableSelectorEnum;
      }
      class ColorPickerObservableSelectorDto {
        constructor(selector: colorPickerObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onValueChangedObservable
         */
        selector: colorPickerObservableSelectorEnum;
      }
      class InputTextObservableSelectorDto {
        constructor(selector: inputTextObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onTextChangedObservable
         */
        selector: inputTextObservableSelectorEnum;
      }
      class RadioButtonObservableSelectorDto {
        constructor(selector: radioButtonObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onIsCheckedChangedObservable
         */
        selector: radioButtonObservableSelectorEnum;
      }
      class CheckboxObservableSelectorDto {
        constructor(selector: checkboxObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onIsCheckedChangedObservable
         */
        selector: checkboxObservableSelectorEnum;
      }
      class ControlObservableSelectorDto {
        constructor(selector: controlObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onPointerClickObservable
         */
        selector: controlObservableSelectorEnum;
      }
      class TextBlockObservableSelectorDto {
        constructor(selector: textBlockObservableSelectorEnum);
        /**
         * Selector for the observable
         * @default onTextChangedObservable
         */
        selector: textBlockObservableSelectorEnum;
      }
      class ContainerDto {
        constructor(container?: BABYLON.GUI.Container);
        /**
         * Container to update
         * @default undefined
         */
        container: BABYLON.GUI.Container;
      }
      class AddControlsToContainerDto {
        constructor(
          container?: BABYLON.GUI.StackPanel,
          controls?: BABYLON.GUI.Control[],
          clearControlsFirst?: boolean
        );
        /**
         * Container to add control to
         * @default undefined
         */
        container: BABYLON.GUI.Container;
        /**
         * Controls to add
         * @default undefined
         */
        controls: BABYLON.GUI.Control[];
        /**
         * Clear controls first. That will preserve the order of the controls.
         * @default true
         */
        clearControlsFirst: boolean;
      }
      class GetControlByNameDto {
        constructor(container?: BABYLON.GUI.Container, name?: string);
        /**
         * Container to get control from
         * @default undefined
         */
        container: BABYLON.GUI.Container;
        /**
         * Name of the control
         * @default controlName
         */
        name: string;
      }
      class SetControlIsVisibleDto {
        constructor(control?: BABYLON.GUI.Control, isVisible?: boolean);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Is visible
         * @default true
         */
        isVisible: boolean;
      }
      class SetControlIsReadonlyDto {
        constructor(control?: BABYLON.GUI.Control, isReadOnly?: boolean);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Is readonly
         * @default false
         */
        isReadOnly: boolean;
      }
      class SetControlIsEnabledDto {
        constructor(control?: BABYLON.GUI.Control, isEnabled?: boolean);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Is enabled
         * @default true
         */
        isEnabled: boolean;
      }
      class CreateImageDto {
        constructor(
          name?: string,
          url?: string,
          color?: string,
          width?: number | string,
          height?: number | string
        );
        /**
         * Name of the image
         * @default imageName
         */
        name: string;
        /**
         * Link to the image
         * @default undefined
         */
        url: string;
        /**
         * Color of the image
         * @default black
         */
        color: string;
        /**
         * Width of the image
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the image
         * @default undefined
         * @optional true
         */
        height?: number | string;
      }
      class SetImageUrlDto {
        constructor(image?: BABYLON.GUI.Image, url?: string);
        /**
         * Image to update
         * @default undefined
         */
        image: BABYLON.GUI.Image;
        /**
         * Link to the image
         * @default undefined
         */
        url: string;
      }
      class ImageDto {
        constructor(image?: BABYLON.GUI.Image);
        /**
         * Image to update
         * @default undefined
         */
        image: BABYLON.GUI.Image;
      }
      class CreateButtonDto {
        constructor(
          name?: string,
          label?: string,
          color?: string,
          background?: string,
          width?: number | string,
          height?: number | string,
          fontSize?: number
        );
        /**
         * Name of the button
         * @default buttonName
         */
        name: string;
        /**
         * Text of the button
         * @default Click me!
         */
        label: string;
        /**
         * Color of the button
         * @default black
         */
        color: string;
        /**
         * Background of the button
         * @default #f0cebb
         */
        background: string;
        /**
         * Width of the button
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the button
         * @default undefined
         * @optional true
         */
        height?: number | string;
        /**
         * Font size of the button
         * @default 24
         */
        fontSize: number;
      }
      class SetButtonTextDto {
        constructor(button?: BABYLON.GUI.Button, text?: string);
        /**
         * Button to update
         * @default undefined
         */
        button: BABYLON.GUI.Button;
        /**
         * Text of the button
         * @default Click me!
         */
        text: string;
      }
      class ButtonDto {
        constructor(button?: BABYLON.GUI.Button);
        /**
         * Button to update
         * @default undefined
         */
        button: BABYLON.GUI.Button;
      }
      class CreateColorPickerDto {
        constructor(
          name?: string,
          defaultColor?: string,
          color?: string,
          width?: number | string,
          height?: number | string,
          size?: number | string
        );
        /**
         * Name of the color picker
         * @default colorPickerName
         */
        name: string;
        /**
         * Default color of the color picker
         * @default #f0cebb
         */
        defaultColor: string;
        /**
         * Color of the color picker
         * @default #f0cebb
         */
        color: string;
        /**
         * Width of the color picker
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the color picker
         * @default undefined
         * @optional true
         */
        height?: number | string;
        /**
         * Size of the color picker
         * @default 300px
         * @optional true
         */
        size?: number | string;
      }
      class SetColorPickerValueDto {
        constructor(colorPicker?: BABYLON.GUI.ColorPicker, color?: string);
        /**
         * Color picker to update
         * @default undefined
         */
        colorPicker: BABYLON.GUI.ColorPicker;
        /**
         * Value of the color picker
         * @default undefined
         */
        color: string;
      }
      class SetColorPickerSizeDto {
        constructor(
          colorPicker?: BABYLON.GUI.ColorPicker,
          size?: number | string
        );
        /**
         * Color picker to update
         * @default undefined
         */
        colorPicker: BABYLON.GUI.ColorPicker;
        /**
         * Size of the color picker
         * @default 300px
         * @optional true
         */
        size?: number | string;
      }
      class ColorPickerDto {
        constructor(colorPicker?: BABYLON.GUI.ColorPicker);
        /**
         * Color picker to update
         * @default undefined
         */
        colorPicker: BABYLON.GUI.ColorPicker;
      }
      class CreateCheckboxDto {
        constructor(
          name?: string,
          isChecked?: boolean,
          checkSizeRatio?: number,
          color?: string,
          background?: string,
          width?: number | string,
          height?: number | string
        );
        /**
         * Name of the checkbox
         * @default checkboxName
         */
        name: string;
        /**
         * Is checked
         * @default false
         */
        isChecked: boolean;
        /**
         * Check size ratio
         * @default 0.8
         * @minimum 0
         * @maximum 1
         * @step 0.05
         */
        checkSizeRatio: number;
        /**
         * Color of the checkbox
         * @default #f0cebb
         */
        color: string;
        /**
         * Background of the checkbox
         * @default black
         */
        background: string;
        /**
         * Width of the checkbox
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the checkbox
         * @default undefined
         * @optional true
         */
        height?: number | string;
      }
      class SetControlFontSizeDto {
        constructor(control?: BABYLON.GUI.Control, fontSize?: number);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Font size of the button
         * @default 24
         */
        fontSize: number;
      }
      class SetControlHeightDto {
        constructor(control?: BABYLON.GUI.Control, height?: number | string);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Height of the checkbox
         * @default undefined
         */
        height: number | string;
      }
      class SetControlWidthDto {
        constructor(control?: BABYLON.GUI.Control, width?: number | string);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Width of the checkbox
         * @default undefined
         */
        width: number | string;
      }
      class SetControlColorDto {
        constructor(control?: BABYLON.GUI.Control, color?: string);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Color of the checkbox
         * @default #f0cebb
         */
        color: string;
      }
      class SetContainerBackgroundDto {
        constructor(container?: BABYLON.GUI.Container, background?: string);
        /**
         * Container to update
         * @default undefined
         */
        container: BABYLON.GUI.Container;
        /**
         * Background of the checkbox
         * @default black
         */
        background: string;
      }
      class SetContainerIsReadonlyDto {
        constructor(container?: BABYLON.GUI.Container, isReadOnly?: boolean);
        /**
         * Container to update
         * @default undefined
         */
        container: BABYLON.GUI.Container;
        /**
         * Is readonly
         * @default false
         */
        isReadOnly: boolean;
      }
      class SetCheckboxBackgroundDto {
        constructor(checkbox?: BABYLON.GUI.Checkbox, background?: string);
        /**
         * Checkbox to update
         * @default undefined
         */
        checkbox: BABYLON.GUI.Checkbox;
        /**
         * Background of the checkbox
         * @default black
         */
        background: string;
      }
      class SetCheckboxCheckSizeRatioDto {
        constructor(checkbox?: BABYLON.GUI.Checkbox, checkSizeRatio?: number);
        /**
         * Checkbox to update
         * @default undefined
         */
        checkbox: BABYLON.GUI.Checkbox;
        /**
         * Check size ratio
         * @default 0.8
         * @minimum 0
         * @maximum 1
         * @step 0.05
         */
        checkSizeRatio: number;
      }
      class CheckboxDto {
        constructor(checkbox?: BABYLON.GUI.Checkbox);
        /**
         * Checkbox to update
         * @default undefined
         */
        checkbox: BABYLON.GUI.Checkbox;
      }
      class ControlDto {
        constructor(control?: BABYLON.GUI.Control);
        /**
         * Control to update
         * @default undefined
         */
        control: BABYLON.GUI.Control;
      }
      class SetCheckboxIsCheckedDto {
        constructor(checkbox?: BABYLON.GUI.Checkbox, isChecked?: boolean);
        /**
         * Checkbox to update
         * @default undefined
         */
        checkbox: BABYLON.GUI.Checkbox;
        /**
         * Is checked
         * @default false
         */
        isChecked: boolean;
      }
      class CreateInputTextDto {
        constructor(
          name?: string,
          color?: string,
          background?: string,
          width?: number | string,
          height?: number | string
        );
        /**
         * Name of the button
         * @default inputName
         */
        name: string;
        /**
         * Text of the input
         * @default
         */
        text: string;
        /**
         * Placeholder of the input
         * @default
         */
        placeholder: string;
        /**
         * Color of the button
         * @default #f0cebb
         */
        color: string;
        /**
         * Background of the button
         * @default black
         */
        background: string;
        /**
         * Width of the button
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the button
         * @default undefined
         * @optional true
         */
        height?: number | string;
      }
      class SetInputTextBackgroundDto {
        constructor(inputText?: BABYLON.GUI.InputText, background?: string);
        /**
         * Input text to update
         * @default undefined
         */
        inputText: BABYLON.GUI.InputText;
        /**
         * Background of the input text
         * @default black
         */
        background: string;
      }
      class SetInputTextTextDto {
        constructor(inputText?: BABYLON.GUI.InputText, text?: string);
        /**
         * Input text to update
         * @default undefined
         */
        inputText: BABYLON.GUI.InputText;
        /**
         * Text of the input text
         * @default
         */
        text: string;
      }
      class SetInputTextPlaceholderDto {
        constructor(inputText?: BABYLON.GUI.InputText, placeholder?: string);
        /**
         * Input text to update
         * @default undefined
         */
        inputText: BABYLON.GUI.InputText;
        /**
         * Placeholder of the input text
         * @default
         */
        placeholder: string;
      }
      class InputTextDto {
        constructor(inputText?: BABYLON.GUI.InputText);
        /**
         * Input text to update
         * @default undefined
         */
        inputText: BABYLON.GUI.InputText;
      }
      class CreateRadioButtonDto {
        constructor(
          name?: string,
          group?: string,
          isChecked?: boolean,
          checkSizeRatio?: number,
          color?: string,
          background?: string,
          width?: number | string,
          height?: number | string
        );
        /**
         * Name of the button
         * @default radioBtnName
         */
        name: string;
        /**
         * Group of the radio button which is used when multiple radio buttons needs to be split into separate groups
         * @default
         * @optional true
         */
        group: string;
        /**
         * Is checked
         * @default false
         */
        isChecked: boolean;
        /**
         * Check size ratio
         * @default 0.8
         * @minimum 0
         * @maximum 1
         * @step 0.05
         */
        checkSizeRatio: number;
        /**
         * Color of the button
         * @default #f0cebb
         */
        color: string;
        /**
         * Background of the button
         * @default black
         */
        background: string;
        /**
         * Width of the button
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the button
         * @default undefined
         * @optional true
         */
        height?: number | string;
      }
      class SetRadioButtonCheckSizeRatioDto {
        constructor(
          radioButton?: BABYLON.GUI.RadioButton,
          checkSizeRatio?: number
        );
        /**
         * Radio button to update
         * @default undefined
         */
        radioButton: BABYLON.GUI.RadioButton;
        /**
         * Check size ratio
         * @default 0.8
         * @minimum 0
         * @maximum 1
         * @step 0.05
         */
        checkSizeRatio: number;
      }
      class SetRadioButtonGroupDto {
        constructor(radioButton?: BABYLON.GUI.RadioButton, group?: string);
        /**
         * Radio button to update
         * @default undefined
         */
        radioButton: BABYLON.GUI.RadioButton;
        /**
         * Group of the radio button
         * @default
         */
        group: string;
      }
      class SetRadioButtonBackgroundDto {
        constructor(radioButton?: BABYLON.GUI.RadioButton, background?: string);
        /**
         * Radio button to update
         * @default undefined
         */
        radioButton: BABYLON.GUI.RadioButton;
        /**
         * Background of the radio button
         * @default black
         */
        background: string;
      }
      class RadioButtonDto {
        constructor(radioButton?: BABYLON.GUI.RadioButton);
        /**
         * Radio button to update
         * @default undefined
         */
        radioButton: BABYLON.GUI.RadioButton;
      }
      class CreateSliderDto {
        constructor(
          name?: string,
          minimum?: number,
          maximum?: number,
          value?: number,
          step?: number,
          isVertical?: boolean,
          color?: string,
          background?: string,
          width?: number | string,
          height?: number | string,
          displayThumb?: boolean
        );
        /**
         * Name of the button
         * @default sliderName
         */
        name: string;
        /**
         * Minimum value of the slider
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        minimum: number;
        /**
         * Maximum value of the slider
         * @default 10
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        maximum: number;
        /**
         * Value of the slider
         * @default 5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        value: number;
        /**
         * Step of the slider
         * @default 0.01
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.01
         */
        step: number;
        /**
         * Is slider vertical
         * @default false
         */
        isVertical: boolean;
        /**
         * Color of the button
         * @default #f0cebb
         */
        color: string;
        /**
         * Background of the button
         * @default black
         */
        background: string;
        /**
         * Width of the button
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the button
         * @default undefined
         * @optional true
         */
        height?: number | string;
        /**
         * Should display thumb
         * @default true
         */
        displayThumb: boolean;
      }
      class CreateTextBlockDto {
        constructor(
          name?: string,
          text?: string,
          color?: string,
          width?: number | string,
          height?: number | string
        );
        /**
         * Name of the text block
         * @default textBlockName
         */
        name: string;
        /**
         * Text of the block
         * @default Hello World!
         */
        text: string;
        /**
         * Color of the  text block
         * @default #f0cebb
         */
        color: string;
        /**
         * Width of the  text block
         * @default undefined
         * @optional true
         */
        width?: number | string;
        /**
         * Height of the  text block
         * @default undefined
         * @optional true
         */
        height?: number | string;
        /**
         * Font size of the text block
         * @default 24
         */
        fontSize: number;
      }
      class SetTextBlockTextDto {
        constructor(textBlock?: BABYLON.GUI.TextBlock, text?: string);
        /**
         * Text block to update
         * @default undefined
         */
        textBlock: BABYLON.GUI.TextBlock;
        /**
         * Text of the block
         * @default undefined
         */
        text: string;
      }
      class SetTextBlockResizeToFitDto {
        constructor(textBlock?: BABYLON.GUI.TextBlock, resizeToFit?: boolean);
        /**
         * Text block to update
         * @default undefined
         */
        textBlock: BABYLON.GUI.TextBlock;
        /**
         * Resize to fit
         * @default false
         */
        resizeToFit: boolean;
      }
      class SetTextBlockTextWrappingDto {
        constructor(textBlock?: BABYLON.GUI.TextBlock, textWrapping?: boolean);
        /**
         * Text block to update
         * @default undefined
         */
        textBlock: BABYLON.GUI.TextBlock;
        /**
         * Text wrapping
         * @default undefined
         */
        textWrapping: boolean | BABYLON.GUI.TextWrapping;
      }
      class SetTextBlockLineSpacingDto {
        constructor(
          textBlock?: BABYLON.GUI.TextBlock,
          lineSpacing?: string | number
        );
        /**
         * Text block to update
         * @default undefined
         */
        textBlock: BABYLON.GUI.TextBlock;
        /**
         * Line spacing of the text
         * @default undefined
         */
        lineSpacing: string | number;
      }
      class TextBlockDto {
        constructor(textBlock?: BABYLON.GUI.TextBlock);
        /**
         * Text block to update
         * @default undefined
         */
        textBlock: BABYLON.GUI.TextBlock;
      }
      class SliderThumbDto {
        constructor(
          slider?: BABYLON.GUI.Slider,
          isThumbCircle?: boolean,
          thumbColor?: string,
          thumbWidth?: string | number,
          isThumbClamped?: boolean,
          displayThumb?: boolean
        );
        /**
         * Slider for which the thumb needs to be updated
         * @default undefined
         */
        slider: BABYLON.GUI.Slider;
        /**
         * Is thumb circle
         * @default false
         */
        isThumbCircle: boolean;
        /**
         * Color of the thumb
         * @default white
         */
        thumbColor: string;
        /**
         * Thumb width
         * @default undefined
         * @optional true
         */
        thumbWidth?: string | number;
        /**
         * Is thumb clamped
         * @default false
         */
        isThumbClamped: boolean;
        /**
         * Should display thumb
         * @default true
         */
        displayThumb: boolean;
      }
      class SliderDto {
        constructor(slider?: BABYLON.GUI.Slider);
        /**
         * Slider for which the thumb needs to be updated
         * @default undefined
         */
        slider: BABYLON.GUI.Slider;
      }
      class SliderBorderColorDto {
        constructor(slider?: BABYLON.GUI.Slider, borderColor?: string);
        /**
         * Slider for which the thumb needs to be updated
         * @default undefined
         */
        slider: BABYLON.GUI.Slider;
        /**
         * Border color of the slider
         * @default white
         */
        borderColor: string;
      }
      class SliderBackgroundColorDto {
        constructor(slider?: BABYLON.GUI.Slider, backgroundColor?: string);
        /**
         * Slider for which the thumb needs to be updated
         * @default undefined
         */
        slider: BABYLON.GUI.Slider;
        /**
         * Background color of the slider
         * @default black
         */
        backgroundColor: string;
      }
      class SetSliderValueDto {
        constructor(slider?: BABYLON.GUI.Slider, value?: number);
        /**
         * Slider for which the thumb needs to be updated
         * @default undefined
         */
        slider: BABYLON.GUI.Slider;
        /**
         * Value of the slider
         * @default 5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        value: number;
      }
      class PaddingLeftRightTopBottomDto {
        constructor(
          control?: BABYLON.GUI.Control,
          paddingLeft?: number | string,
          paddingRight?: number | string,
          paddingTop?: number | string,
          paddingBottom?: number | string
        );
        /**
         * Control to change the padding
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Padding left of the stack panel
         * @default undefined
         * @optional true
         */
        paddingLeft: number | string;
        /**
         * Padding right of the stack panel
         * @default undefined
         * @optional true
         */
        paddingRight: number | string;
        /**
         * Padding top of the stack panel
         * @default undefined
         * @optional true
         */
        paddingTop: number | string;
        /**
         * Padding bottom of the stack panel
         * @default undefined
         * @optional true
         */
        paddingBottom: number | string;
      }
      class CloneControlDto {
        constructor(
          control?: BABYLON.GUI.Control,
          container?: BABYLON.GUI.Container,
          name?: string,
          host?: BABYLON.GUI.AdvancedDynamicTexture
        );
        /**
         * Control to clone
         * @default undefined
         */
        control: BABYLON.GUI.Control;
        /**
         * Use container to which the cloned control will be added
         * @default undefined
         * @optional true
         */
        container?: BABYLON.GUI.Container;
        /**
         * Name of the cloned control
         * @default clonedControl
         */
        name: string;
        /**
         * Host of the cloned control
         * @default undefined
         * @optional true
         */
        host?: BABYLON.GUI.AdvancedDynamicTexture;
      }
      class AlignmentDto<T> {
        constructor(
          control?: T,
          horizontalAlignment?: horizontalAlignmentEnum,
          verticalAlignment?: verticalAlignmentEnum
        );
        /**
         * Control to change the padding
         * @default undefined
         */
        control: T;
        /**
         * Alignment horizontal
         * @default center
         */
        horizontalAlignment: horizontalAlignmentEnum;
        /**
         * Alignment horizontal
         * @default center
         */
        verticalAlignment: verticalAlignmentEnum;
      }
      class SetTextBlockTextOutlineDto {
        constructor(
          textBlock?: BABYLON.GUI.TextBlock,
          outlineWidth?: number,
          outlineColor?: string
        );
        /**
         * Control to change the padding
         * @default undefined
         */
        textBlock: BABYLON.GUI.TextBlock;
        /**
         * Alignment horizontal
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        outlineWidth: number;
        /**
         * Outline color
         * @default white
         */
        outlineColor: string;
      }
    }
    declare namespace BabylonIO {
      class ExportSceneGlbDto {
        constructor(fileName?: string, discardSkyboxAndGrid?: boolean);
        /**
         * File name that should be used for the scene.
         * @default bitbybit-scene
         */
        fileName: string;
        /**
         * Discard skybox and grid
         * @default false
         * @optional true
         */
        discardSkyboxAndGrid?: boolean;
      }
      class ExportSceneDto {
        constructor(fileName?: string);
        /**
         * File name that should be used for the scene.
         * @default bitbybit-scene
         */
        fileName: string;
      }
      class ExportMeshToStlDto {
        constructor(mesh?: BABYLON.Mesh, fileName?: string);
        /**
         * Mesh to export
         */
        mesh: BABYLON.Mesh;
        /**
         * File name that should be used for the scene.
         * @default bitbybit-mesh
         */
        fileName: string;
      }
      class ExportMeshesToStlDto {
        constructor(meshes?: BABYLON.Mesh[], fileName?: string);
        /**
         * Meshes to export
         */
        meshes: BABYLON.Mesh[];
        /**
         * File name that should be used for the scene.
         * @default bitbybit-mesh
         */
        fileName: string;
      }
    }
    declare namespace BabylonLight {
      class ShadowLightDirectionToTargetDto {
        constructor(shadowLight?: BABYLON.ShadowLight, target?: Base.Vector3);
        /**
         * Shadow light to update
         * @default undefined
         */
        shadowLight: BABYLON.ShadowLight;
        /**
         * The direction target
         * @default undefined
         */
        target?: Base.Vector3;
      }
      class ShadowLightPositionDto {
        constructor(shadowLight?: BABYLON.ShadowLight, position?: Base.Vector3);
        /**
         * Shadow light to update
         * @default undefined
         */
        shadowLight: BABYLON.ShadowLight;
        /**
         * The position
         * @default undefined
         */
        position?: Base.Vector3;
      }
    }
    declare namespace BabylonMaterial {
      class PBRMetallicRoughnessDto {
        constructor(
          name?: string,
          baseColor?: Base.Color,
          emissiveColor?: Base.Color,
          metallic?: number,
          roughness?: number,
          alpha?: number,
          backFaceCulling?: boolean,
          zOffset?: number
        );
        /**
         * Name of the material
         * @default Custom Material
         */
        name: string;
        /**
         * Base color of the material
         * @default #0000ff
         */
        baseColor: Base.Color;
        /**
         * Emissive color of the material
         * @default #000000
         */
        emissiveColor?: Base.Color;
        /**
         * Metallic value of the material
         * @default 0.6
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        metallic: number;
        /**
         * Roughness value of the material
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        roughness: number;
        /**
         * Defines the transparency of the material
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        alpha: number;
        /**
         * Identifies if both sides of the surface should have material applied
         * @default false
         */
        backFaceCulling: boolean;
        /**
         * Defines the z offset of the material
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        zOffset: number;
      }
      class BaseColorDto {
        constructor(
          material?: BABYLON.PBRMetallicRoughnessMaterial,
          baseColor?: Base.Color
        );
        /**
         * Material to update
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
        /**
         * Base color of the material
         * @default #0000ff
         */
        baseColor?: Base.Color;
      }
      class MaterialPropDto {
        constructor(material?: BABYLON.PBRMetallicRoughnessMaterial);
        /**
         * Material to investigate
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
      }
      class SkyMaterialPropDto {
        constructor(skyMaterial?: MATERIALS.SkyMaterial);
        /**
         * Material to investigate
         * @default undefined
         */
        skyMaterial: MATERIALS.SkyMaterial;
      }
      class MetallicDto {
        constructor(
          material?: BABYLON.PBRMetallicRoughnessMaterial,
          metallic?: number
        );
        /**
         * Material to update
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
        /**
         * Metallic value of the material
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        metallic?: number;
      }
      class RoughnessDto {
        constructor(
          material?: BABYLON.PBRMetallicRoughnessMaterial,
          roughness?: number
        );
        /**
         * Material to update
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
        /**
         * Roughness value of the material
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        roughness?: number;
      }
      class AlphaDto {
        constructor(
          material?: BABYLON.PBRMetallicRoughnessMaterial,
          alpha?: number
        );
        /**
         * Material to update
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
        /**
         * Alpha value of the material
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        alpha?: number;
      }
      class BackFaceCullingDto {
        constructor(
          material?: BABYLON.PBRMetallicRoughnessMaterial,
          backFaceCulling?: boolean
        );
        /**
         * Material to update
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
        /**
         * back face culling
         * @default true
         */
        backFaceCulling?: boolean;
      }
      class BaseTextureDto {
        constructor(
          material?: BABYLON.PBRMetallicRoughnessMaterial,
          baseTexture?: BABYLON.Texture
        );
        /**
         * Material to update
         * @default undefined
         */
        material: BABYLON.PBRMetallicRoughnessMaterial;
        /**
         * Base texture of the material
         * @default undefined
         */
        baseTexture: BABYLON.Texture;
      }
      class SkyMaterialDto {
        constructor(
          luminance?: number,
          turbidity?: number,
          rayleigh?: number,
          mieCoefficient?: number,
          mieDirectionalG?: number,
          distance?: number,
          inclination?: number,
          azimuth?: number,
          sunPosition?: Base.Vector3,
          useSunPosition?: boolean,
          cameraOffset?: Base.Vector3,
          up?: Base.Vector3,
          dithering?: boolean
        );
        /**
         * Defines the overall luminance of sky in interval ]0, 1[.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.01
         *
         */
        luminance: number;
        /**
         * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        turbidity: number;
        /**
         * Defines the sky appearance (light intensity).
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        rayleigh: number;
        /**
         * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.
         * @default 0.005
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        mieCoefficient: number;
        /**
         * Defines the amount of haze particles following the Mie scattering theory.
         * @default 0.8
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        mieDirectionalG: number;
        /**
         * Defines the distance of the sun according to the active scene camera.
         * @default 500
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        distance: number;
        /**
         * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said
         * "inclined".
         * @default 0.49
         * @minimum -0.5
         * @maximum 0.5
         * @step 0.01
         */
        inclination: number;
        /**
         * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between
         * an object direction and a reference direction.
         * @default 0.25
         * @minimum 0
         * @maximum 1
         * @step 0.01
         */
        azimuth: number;
        /**
         * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then
         * the property is overridden by the inclination and the azimuth and can be read at any moment.
         * @default undefined
         * @optional true
         */
        sunPosition: Base.Vector3;
        /**
         * Defines if the sun position should be computed (inclination and azimuth) according to the given
         * .sunPosition property.
         * @default false
         */
        useSunPosition: boolean;
        /**
         * Defines an offset vector used to get a horizon offset.
         * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis
         * @default undefined
         * @optional true
         */
        cameraOffset: Base.Vector3;
        /**
         * Defines the vector the skyMaterial should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
         * @default [0, 1, 0]
         */
        up: number[];
        /**
         * Defines if sky should be dithered.
         * @default false
         */
        dithering: boolean;
      }
      class LuminanceDto {
        constructor(material?: MATERIALS.SkyMaterial, luminance?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the overall luminance of sky in interval ]0, 1[.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.01
         */
        luminance?: number;
      }
      class TurbidityDto {
        constructor(material?: MATERIALS.SkyMaterial, turbidity?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the amount (scattering) of haze as opposed to molecules in atmosphere.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        turbidity?: number;
      }
      class RayleighDto {
        constructor(material?: MATERIALS.SkyMaterial, rayleigh?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the sky appearance (light intensity).
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        rayleigh?: number;
      }
      class MieCoefficientDto {
        constructor(material?: MATERIALS.SkyMaterial, mieCoefficient?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the mieCoefficient in interval [0, 0.1] which affects the property .mieDirectionalG.
         * @default 0.005
         * @minimum 0
         * @maximum Infinity
         * @step 0.001
         */
        mieCoefficient?: number;
      }
      class MieDirectionalGDto {
        constructor(material?: MATERIALS.SkyMaterial, mieDirectionalG?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the amount of haze particles following the Mie scattering theory.
         * @default 0.8
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        mieDirectionalG?: number;
      }
      class DistanceDto {
        constructor(material?: MATERIALS.SkyMaterial, distance?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the distance of the sun according to the active scene camera.
         * @default 500
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        distance?: number;
      }
      class InclinationDto {
        constructor(material?: MATERIALS.SkyMaterial, inclination?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the sun inclination, in interval [-0.5, 0.5]. When the inclination is not 0, the sun is said
         * "inclined".
         * @default 0.49
         * @minimum -0.5
         * @maximum 0.5
         * @step 0.01
         */
        inclination?: number;
      }
      class AzimuthDto {
        constructor(material?: MATERIALS.SkyMaterial, azimuth?: number);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the solar azimuth in interval [0, 1]. The azimuth is the angle in the horizontal plan between
         * an object direction and a reference direction.
         * @default 0.25
         * @minimum 0
         * @maximum 1
         * @step 0.01
         */
        azimuth?: number;
      }
      class SunPositionDto {
        constructor(
          material?: MATERIALS.SkyMaterial,
          sunPosition?: Base.Vector3
        );
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the sun position in the sky on (x,y,z). If the property .useSunPosition is set to false, then
         * the property is overridden by the inclination and the azimuth and can be read at any moment.
         * @default undefined
         */
        sunPosition?: Base.Vector3;
      }
      class UseSunPositionDto {
        constructor(material?: MATERIALS.SkyMaterial, useSunPosition?: boolean);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines if the sun position should be computed (inclination and azimuth) according to the given
         * .sunPosition property.
         * @default false
         */
        useSunPosition?: boolean;
      }
      class CameraOffsetDto {
        constructor(
          material?: MATERIALS.SkyMaterial,
          cameraOffset?: Base.Vector3
        );
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines an offset vector used to get a horizon offset.
         * @example skyMaterial.cameraOffset.y = camera.globalPosition.y // Set horizon relative to 0 on the Y axis
         * @default undefined
         */
        cameraOffset?: Base.Vector3;
      }
      class UpDto {
        constructor(material?: MATERIALS.SkyMaterial, up?: Base.Vector3);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines the vector the skyMaterial should consider as up. (default is Vector3(0, 1, 0) as returned by Vector3.Up())
         * @default undefined
         */
        up?: Base.Vector3;
      }
      class DitheringDto {
        constructor(material?: MATERIALS.SkyMaterial, dithering?: boolean);
        /**
         * Material to update
         * @default undefined
         */
        material: MATERIALS.SkyMaterial;
        /**
         * Defines if sky should be dithered.
         * @default false
         */
        dithering?: boolean;
      }
    }
    declare namespace BabylonMeshBuilder {
      class CreateBoxDto {
        constructor(
          width?: number,
          depth?: number,
          height?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Width of the box
         * @default 1
         */
        width: number;
        /**
         * Depth of the box
         * @default 1
         */
        depth: number;
        /**
         * Height of the box
         * @default 1
         */
        height: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateCubeDto {
        constructor(
          size?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Size of the cube
         * @default 1
         */
        size: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateSquarePlaneDto {
        constructor(
          size?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Size of the square plane
         * @default 1
         */
        size: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateSphereDto {
        constructor(
          diameter?: number,
          segments?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Diameter of the sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        diameter: number;
        /**
         * Segments of the sphere
         * @default 32
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        segments: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateIcoSphereDto {
        constructor(
          radius?: number,
          radiusX?: number,
          radiusY?: number,
          radiusZ?: number,
          flat?: boolean,
          subdivisions?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Radius of the ico sphere
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Radius X of the ico sphere
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusX: number;
        /**
         * Radius Y of the ico sphere
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusY: number;
        /**
         * Radius Z of the ico sphere
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusZ: number;
        /**
         * Flat of the ico sphere
         * @default false
         */
        flat: boolean;
        /**
         * Subdivisions of the ico sphere
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisions: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateDiscDto {
        constructor(
          radius?: number,
          tessellation?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Radius of the disc
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Tessellation of the disc
         * @default 32
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tessellation: number;
        /**
         * Arc between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        arc: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateRibbonDto {
        constructor(
          pathArray?: Base.Vector3[][],
          closeArray?: boolean,
          closePath?: boolean,
          offset?: number,
          updatable?: boolean,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Path array of the ribbon
         */
        pathArray: Base.Vector3[][];
        /**
         * Close array of the ribbon
         * @default false
         */
        closeArray: boolean;
        /**
         * Close path of the ribbon
         * @default false
         */
        closePath: boolean;
        /**
         * Offset of the ribbon
         * @default 0
         */
        offset: number;
        /**
         * Updateable
         * @default false
         */
        updatable: boolean;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateTorusDto {
        constructor(
          diameter?: number,
          thickness?: number,
          tessellation?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Diameter of the torus
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        diameter: number;
        /**
         * Thickness of the torus
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        thickness: number;
        /**
         * Tessellation of the torus
         * @default 32
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tessellation: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateTorusKnotDto {
        constructor(
          radius?: number,
          tube?: number,
          radialSegments?: number,
          tubularSegments?: number,
          p?: number,
          q?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Radius of the torus knot
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Tube of the torus knot
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        tube: number;
        /**
         * Radial segments of the torus knot
         * @default 128
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        radialSegments: number;
        /**
         * Tubular segments of the torus knot
         * @default 32
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tubularSegments: number;
        /**
         * P of the torus knot
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        p: number;
        /**
         * Q of the torus knot
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        q: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreatePolygonDto {
        constructor(
          shape?: Base.Vector3[],
          holes?: Base.Vector3[][],
          depth?: number,
          smoothingThreshold?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          wrap?: boolean,
          enableShadows?: boolean
        );
        /**
         * Shape of the polygon
         */
        shape: Base.Vector3[];
        /**
         * Holes of the polygon
         * @optional true
         */
        holes?: Base.Vector3[][];
        /**
         * Depth of the polygon
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        depth: number;
        /**
         * Smoothing threshold of the polygon
         * @default 0.01
         * @minimum 0
         * @maximum 1
         * @step 0.01
         */
        smoothingThreshold: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Wrap of the polygon
         * @default false
         */
        wrap: boolean;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class ExtrudePolygonDto {
        constructor(
          shape?: Base.Vector3[],
          holes?: Base.Vector3[][],
          depth?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          wrap?: boolean,
          enableShadows?: boolean
        );
        /**
         * Shape of the extrude
         */
        shape: Base.Vector3[];
        /**
         * Holes of the extrude
         * @optional true
         */
        holes?: Base.Vector3[][];
        /**
         * Depth of the extrude
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        depth: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Wrap of the extrude
         * @default false
         */
        wrap: boolean;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreatePolyhedronDto {
        constructor(
          size?: number,
          type?: number,
          sizeX?: number,
          sizeY?: number,
          sizeZ?: number,
          custom?: number[],
          flat?: boolean,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Size of the polyhedron
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Type of the polyhedron
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        type: number;
        /**
         * Size X of the polyhedron
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeX: number;
        /**
         * Size Y of the polyhedron
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeY: number;
        /**
         * Size Z of the polyhedron
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeZ: number;
        /**
         * Custom polyhedron
         * @optional true
         */
        custom?: number[];
        /**
         * Flat polyhedron
         * @default false
         */
        flat: boolean;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateGeodesicDto {
        constructor(
          m?: number,
          n?: number,
          size?: number,
          sizeX?: number,
          sizeY?: number,
          sizeZ?: number,
          flat?: boolean,
          subdivisions?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * M of the geodesic
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        m: number;
        /**
         * N of the geodesic
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        n: number;
        /**
         * Size of the geodesic
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Size X of the geodesic
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeX: number;
        /**
         * Size Y of the geodesic
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeY: number;
        /**
         * Size Z of the geodesic
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeZ: number;
        /**
         * Flat
         * @default false
         */
        flat: boolean;
        /**
         * Subdivisions of the geodesic
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisions: number;
        /**
         * Side orientation of the mesh
         * @default frontside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateCapsuleDto {
        constructor(
          orientation?: Base.Vector3,
          subdivisions?: number,
          tessellation?: number,
          height?: number,
          radius?: number,
          capSubdivisions?: number,
          radiusTop?: number,
          radiusBottom?: number,
          topCapSubdivisions?: number,
          bottomCapSubdivisions?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Orientation of the capsule
         */
        orientation: Base.Vector3;
        /**
         * Subdivisions of the capsule
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisions: number;
        /**
         * Tessellation of the capsule
         * @default 16
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tessellation: number;
        /**
         * Height of the capsule
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Radius of the capsule
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Cap subdivisions of the capsule
         * @default 6
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        capSubdivisions: number;
        /**
         * Radius top of the capsule
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusTop: number;
        /**
         * Radius bottom of the capsule
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusBottom: number;
        /**
         * Top cap subdivisions of the capsule
         * @default 6
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        topCapSubdivisions: number;
        /**
         * Bottom cap subdivisions of the capsule
         * @default 6
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        bottomCapSubdivisions: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateGoldbergDto {
        constructor(
          m?: number,
          n?: number,
          size?: number,
          sizeX?: number,
          sizeY?: number,
          sizeZ?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * M of the goldberg
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        m: number;
        /**
         * N of the goldberg
         * @default 4
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        n: number;
        /**
         * Size of the goldberg
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Size X of the goldberg
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeX: number;
        /**
         * Size Y of the goldberg
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeY: number;
        /**
         * Size Z of the goldberg
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        sizeZ: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateTubeDto {
        constructor(
          path?: Base.Vector3[],
          radius?: number,
          tessellation?: number,
          cap?: number,
          arc?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Path of the tube
         * @default undefined
         */
        path: Base.Vector3[];
        /**
         * Radius of the tube
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Tessellation of the tube
         * @default 32
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tessellation: number;
        /**
         * Cap of the tube
         * @default 0
         * @minimum 0
         * @maximum 3
         * @step 1
         */
        cap: number;
        /**
         * Arc of the tube
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        arc: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateExtrudedShapeDto {
        constructor(
          shape?: Base.Vector3[],
          path?: Base.Vector3[],
          scale?: number,
          rotation?: number,
          cap?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Shape of the extrude
         */
        shape: Base.Vector3[];
        /**
         * Path of the extrude
         */
        path: Base.Vector3[];
        /**
         * Scale of the extrude
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        scale: number;
        /**
         * Rotation of the extrude
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        rotation: number;
        /**
         * Close shape of the extrude
         * @default false
         */
        closeShape: boolean;
        /**
         * Close path of the extrude
         * @default false
         */
        closePath: boolean;
        /**
         * Cap of the extrude
         * @default 0
         * @minimum 0
         * @maximum 3
         * @step 1
         */
        cap: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateCylinderDto {
        constructor(
          height?: number,
          diameterTop?: number,
          diameterBottom?: number,
          tessellation?: number,
          subdivisions?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Height of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * Diameter top of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        diameterTop: number;
        /**
         * Diameter bottom of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        diameterBottom: number;
        /**
         * Tessellation of the cylinder
         * @default 64
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tessellation: number;
        /**
         * Subdivisions of the cylinder
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisions: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateLatheDto {
        constructor(
          shape?: Base.Vector3[],
          radius?: number,
          tessellation?: number,
          arc?: number,
          closed?: boolean,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Shape of the lathe
         */
        shape: Base.Vector3[];
        /**
         * Radius of the lathe
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Tessellation of the lathe
         * @default 64
         * @minimum 3
         * @maximum Infinity
         * @step 1
         */
        tessellation: number;
        /**
         * Arc of the lathe
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        arc: number;
        /**
         * Should lathe be closed
         * @default true
         */
        closed: boolean;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateGroundDto {
        constructor(
          width?: number,
          height?: number,
          subdivisionsX?: number,
          subdivisionsY?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Width of the ground
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        width: number;
        /**
         * Height of the ground
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        height: number;
        /**
         * Subdivisions X of the ground
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisionsX: number;
        /**
         * Subdivisions Y of the ground
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisionsY: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
      class CreateRectanglePlaneDto {
        constructor(
          width?: number,
          height?: number,
          sideOrientation?: BabylonMesh.sideOrientationEnum,
          enableShadows?: boolean
        );
        /**
         * Width of the rectangle plane
         * @default 1
         */
        width: number;
        /**
         * Height of the rectangle plane
         * @default 1
         */
        height: number;
        /**
         * Side orientation of the mesh
         * @default doubleside
         */
        sideOrientation: BabylonMesh.sideOrientationEnum;
        /**
         * Enables shadows for the mesh
         * @default true
         */
        enableShadows: boolean;
      }
    }
    declare namespace BabylonMesh {
      enum sideOrientationEnum {
        frontside = "frontside",
        backside = "backside",
        doubleside = "doubleside",
      }
      class UpdateDrawnBabylonMesh {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          position?: Base.Point3,
          rotation?: Base.Vector3,
          scaling?: Base.Vector3,
          colours?: string | string[]
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Position to place the mesh into
         * @default undefined
         */
        position: Base.Point3;
        /**
         * Rotation for the mesh
         * @default undefined
         */
        rotation: Base.Vector3;
        /**
         * Scale mesh to certain value
         * @default undefined
         */
        scaling: Base.Vector3;
        /**
         * Colours or a single colour to change
         * @default undefined
         */
        colours: string | string[];
      }
      class SetParentDto {
        constructor(
          babylonMesh?:
            | BABYLON.Mesh
            | BABYLON.InstancedMesh
            | BABYLON.AbstractMesh,
          parentMesh?:
            | BABYLON.Mesh
            | BABYLON.InstancedMesh
            | BABYLON.AbstractMesh
        );
        /**
         * BabylonJS Mesh that needs to change it's parent
         * @default undefined
         */
        babylonMesh:
          | BABYLON.Mesh
          | BABYLON.InstancedMesh
          | BABYLON.AbstractMesh;
        /**
         * BabylonJS Mesh to use as a parent
         * @default undefined
         */
        parentMesh: BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh;
      }
      class UpdateDrawnBabylonMeshPositionDto {
        constructor(
          babylonMesh?: BABYLON.Mesh | BABYLON.InstancedMesh,
          position?: Base.Point3
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * Position to place the mesh into
         * @default undefined
         */
        position: Base.Point3;
      }
      class UpdateDrawnBabylonMeshRotationDto {
        constructor(
          babylonMesh?: BABYLON.Mesh | BABYLON.InstancedMesh,
          rotation?: Base.Vector3
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * Rotation for the mesh
         * @default undefined
         */
        rotation: Base.Vector3;
      }
      class UpdateDrawnBabylonMeshScaleDto {
        constructor(
          babylonMesh?: BABYLON.Mesh | BABYLON.InstancedMesh,
          scale?: Base.Vector3
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * Scale for the mesh
         * @default undefined
         */
        scale: Base.Vector3;
      }
      class ScaleInPlaceDto {
        constructor(
          babylonMesh?: BABYLON.Mesh | BABYLON.InstancedMesh,
          scale?: number
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * factor for the scale
         * @default 1
         */
        scale: number;
      }
      class IntersectsMeshDto {
        constructor(
          babylonMesh?: BABYLON.Mesh | BABYLON.InstancedMesh,
          babylonMesh2?: BABYLON.Mesh | BABYLON.InstancedMesh,
          precise?: boolean,
          includeDescendants?: boolean
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh2: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * Should check precisely
         * @default false
         */
        precise: boolean;
        /**
         * Check descendant intersections as well
         * @default false
         */
        includeDescendants: boolean;
      }
      class IntersectsPointDto {
        constructor(
          babylonMesh?: BABYLON.Mesh | BABYLON.InstancedMesh,
          point?: Base.Point3
        );
        /**
         * Babylon Mesh that needs to be updated
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh | BABYLON.InstancedMesh;
        /**
         * point
         * @default undefined
         */
        point: Base.Point3;
      }
      class BabylonMeshDto {
        constructor(babylonMesh?: BABYLON.Mesh);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
      }
      class CloneToPositionsDto {
        constructor(babylonMesh?: BABYLON.Mesh, positions?: Base.Point3[]);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * positions to clone to
         * @default []
         */
        positions: Base.Point3[];
      }
      class MergeMeshesDto {
        constructor(
          arrayOfMeshes?: BABYLON.Mesh[],
          disposeSource?: boolean,
          allow32BitsIndices?: boolean,
          meshSubclass?: BABYLON.Mesh,
          subdivideWithSubMeshes?: boolean,
          multiMultiMaterials?: boolean
        );
        /**
         * meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.
         * @default undefined
         */
        arrayOfMeshes: BABYLON.Mesh[];
        /**
         * disposeSource when true (default), dispose of the vertices from the source meshes.
         * @default true
         */
        disposeSource: boolean;
        /**
         * allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.
         * @default false
         */
        allow32BitsIndices: boolean;
        /**
         * meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.
         * @default undefined
         * @optional true
         */
        meshSubclass?: BABYLON.Mesh;
        /**
         * subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.
         * @default false
         */
        subdivideWithSubMeshes: boolean;
        /**
         * multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.
         * @default false
         */
        multiMultiMaterials: boolean;
      }
      class BabylonMeshWithChildrenDto {
        constructor(babylonMesh?: BABYLON.Mesh);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Include children when performing action
         * @default true
         */
        includeChildren: boolean;
      }
      class ShowHideMeshDto {
        constructor(babylonMesh?: BABYLON.Mesh, includeChildren?: boolean);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Include children when showing hiding
         * @default true
         */
        includeChildren: boolean;
      }
      class CloneBabylonMeshDto {
        constructor(babylonMesh?: BABYLON.Mesh);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
      }
      class ChildMeshesBabylonMeshDto {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          directDescendantsOnly?: boolean
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Include only direct descendants
         * @default false
         */
        directDescendantsOnly: boolean;
      }
      class TranslateBabylonMeshDto {
        constructor(babylonMesh?: BABYLON.Mesh, distance?: number);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * distance to translate
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        distance: number;
      }
      class NameBabylonMeshDto {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          name?: string,
          includeChildren?: boolean
        );
        /**
         * BabylonJS mesh
         * @default undefined
         *
         */
        babylonMesh?: BABYLON.Mesh;
        /**
         * name of the mesh
         * @default undefined
         */
        name: string;
        /**
         * Set name also on children
         * @default false
         */
        includeChildren?: boolean;
      }
      class ByNameBabylonMeshDto {
        constructor(name?: string);
        /**
         * name of the mesh
         * @default undefined
         */
        name: string;
      }
      class MaterialBabylonMeshDto {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          material?: BABYLON.Material,
          includeChildren?: boolean
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh?: BABYLON.Mesh;
        /**
         * material of the mesh
         * @default undefined
         */
        material: BABYLON.Material;
        /**
         * Set material on children also
         * @default false
         */
        includeChildren: boolean;
      }
      class IdBabylonMeshDto {
        constructor(babylonMesh?: BABYLON.Mesh, id?: string);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh?: BABYLON.Mesh;
        /**
         * id of the mesh
         * @default undefined
         */
        id: string;
      }
      class ByIdBabylonMeshDto {
        constructor(id?: string);
        /**
         * id of the mesh
         * @default undefined
         */
        id: string;
      }
      class UniqueIdBabylonMeshDto {
        constructor(uniqueId?: number);
        /**
         * Unique id of the mesh
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        uniqueId: number;
      }
      class PickableBabylonMeshDto {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          pickable?: boolean,
          includeChildren?: boolean
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Pickable
         * @default false
         */
        pickable: boolean;
        /**
         * Apply set to children also
         * @default false
         */
        includeChildren: boolean;
      }
      class CheckCollisionsBabylonMeshDto {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          checkCollisions?: boolean,
          includeChildren?: boolean
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Check collisions
         * @default false
         */
        checkCollisions: boolean;
        /**
         * Apply set to children also
         * @default false
         */
        includeChildren: boolean;
      }
      class RotateBabylonMeshDto {
        constructor(babylonMesh?: BABYLON.Mesh, rotate?: number);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * rotate to translate
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        rotate: number;
      }
      class SetMeshVisibilityDto {
        constructor(
          babylonMesh?: BABYLON.Mesh,
          visibility?: number,
          includeChildren?: boolean
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        babylonMesh: BABYLON.Mesh;
        /**
         * Shows mesh if 0 and shows if 1
         * @default 0
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        visibility: number;
        /**
         * Include children
         * @default false
         */
        includeChildren: boolean;
      }
      class MeshInstanceAndTransformDto {
        constructor(
          mesh?: BABYLON.Mesh,
          position?: Base.Point3,
          rotation?: Base.Vector3,
          scaling?: Base.Vector3
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        mesh: BABYLON.Mesh;
        /**
         * Position
         * @default undefined
         */
        position: Base.Point3;
        /**
         * Rotation
         * @default undefined
         */
        rotation: Base.Vector3;
        /**
         * Scaling
         * @default undefined
         */
        scaling: Base.Vector3;
      }
      class MeshInstanceDto {
        constructor(mesh?: BABYLON.Mesh);
        /**
         * BabylonJS mesh
         * @default undefined
         */
        mesh: BABYLON.Mesh;
      }
      class RotateAroundAxisNodeDto {
        constructor(
          mesh?: BABYLON.Mesh,
          position?: Base.Point3,
          axis?: Base.Vector3,
          angle?: number
        );
        /**
         * BabylonJS mesh
         * @default undefined
         */
        mesh: BABYLON.Mesh;
        /**
         * Position vector expressed in [x, y, z] vector array
         */
        position: Base.Point3;
        /**
         * Rotate around the axis expressed in [x, y, z] vector array
         */
        axis: Base.Vector3;
        /**
         * The rotation angle expressed in degrees
         */
        angle: number;
      }
    }
    declare namespace BabylonPick {
      class RayDto {
        constructor(ray?: BABYLON.Ray);
        /**
         * Ray
         */
        ray: BABYLON.Ray;
      }
      class PickInfo {
        constructor(pickInfo?: BABYLON.PickingInfo);
        /**
         * Information about picking result
         */
        pickInfo: BABYLON.PickingInfo;
      }
    }
    declare namespace BabylonRay {
      class BaseRayDto {
        constructor(
          origin?: Base.Point3,
          direction?: Base.Vector3,
          length?: number
        );
        /**
         * Origin of the ray
         */
        origin: Base.Point3;
        /**
         * Direction of the ray
         */
        direction: Base.Vector3;
        /**
         * Length of the ray
         */
        length?: number;
      }
      class RayDto {
        constructor(ray?: BABYLON.Ray);
        /**
         * ray to analyze
         */
        ray: BABYLON.Ray;
      }
      class FromToDto {
        constructor(from?: Base.Point3, to?: Base.Point3);
        /**
         * From point
         */
        from: Base.Point3;
        /**
         * To point
         */
        to: Base.Point3;
      }
    }
    declare namespace BabylonTexture {
      enum samplingModeEnum {
        nearest = "nearest",
        bilinear = "bilinear",
        trilinear = "trilinear",
      }
      class TextureSimpleDto {
        constructor(
          name?: string,
          url?: string,
          invertY?: boolean,
          invertZ?: boolean,
          wAng?: number,
          uScale?: number,
          vScale?: number,
          uOffset?: number,
          vOffset?: number,
          samplingMode?: samplingModeEnum
        );
        /**
         * Name of the material
         * @default Custom Texture
         */
        name: string;
        /**
         * Url of the texture
         * @default undefined
         */
        url: string;
        /**
         * Invert texture on Y direction
         * @default false
         */
        invertY: boolean;
        /**
         * Invert texture on Z direction
         * @default false
         */
        invertZ: boolean;
        /**
         * W angle of the texture
         * @default 0
         */
        wAng: number;
        /**
         * U scale of the texture
         * @default 1
         */
        uScale: number;
        /**
         * V scale of the texture
         * @default 1
         */
        vScale: number;
        /**
         * U offset of the texture
         * @default 0
         */
        uOffset: number;
        /**
         * V offset of the texture
         * @default 0
         */
        vOffset: number;
        /**
         * The sampling mode of the texture
         * @default nearest
         */
        samplingMode: samplingModeEnum;
      }
    }
    declare namespace BabylonTools {
      class ScreenshotDto {
        constructor(
          camera?: BABYLON.Camera,
          width?: number,
          height?: number,
          mimeType?: string,
          quality?: number
        );
        /**
         * Camera to be used. If not set, active camera will be used
         * @default undefined
         */
        camera: BABYLON.Camera;
        /**
         * width of the screenshot
         * @default 1920
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        width: number;
        /**
         * height of the screenshot
         * @default 1080
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        height: number;
        /**
         * The mime type
         * @default image/png
         */
        mimeType: string;
        /**
         * quality of the screenshot
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        quality: number;
      }
    }
    declare namespace BabylonTransforms {
      class RotationCenterAxisDto {
        constructor(angle?: number, axis?: Base.Vector3, center?: Base.Point3);
        /**
         * Angle of rotation in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
        /**
         * Axis vector for rotation
         * @default [0, 1, 0]
         */
        axis: Base.Vector3;
        /**
         * The center from which the axis is pointing
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class TransformBabylonMeshDto {
        constructor(
          mesh?: BABYLON.Mesh,
          transformation?: Base.TransformMatrixes
        );
        /**
         * Mesh to transform
         * @default undefined
         */
        mesh: BABYLON.Mesh;
        /**
         * Transformation(s) to apply
         * @default undefined
         */
        transformation: Base.TransformMatrixes;
      }
      class RotationCenterDto {
        constructor(angle?: number, center?: Base.Point3);
        /**
         * Angle of rotation in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
        /**
         * The center from which the axis is pointing
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class RotationCenterYawPitchRollDto {
        constructor(
          yaw?: number,
          pitch?: number,
          roll?: number,
          center?: Base.Point3
        );
        /**
         * Yaw angle (Rotation around X) in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        yaw: number;
        /**
         * Pitch angle (Rotation around Y) in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        pitch: number;
        /**
         * Roll angle (Rotation around Z) in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        roll: number;
        /**
         * The center from which the rotations are applied
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class ScaleXYZDto {
        constructor(scaleXyz?: Base.Vector3);
        /**
         * Scaling factors for each axis [1, 2, 1] means that Y axis will be scaled 200% and both x and z axis will remain on 100%
         * @default [1, 1, 1]
         */
        scaleXyz: Base.Vector3;
      }
      class ScaleCenterXYZDto {
        constructor(center?: Base.Point3, scaleXyz?: Base.Vector3);
        /**
         * The center from which the scaling is applied
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Scaling factors for each axis [1, 2, 1] means that Y axis will be scaled 200% and both x and z axis will remain on 100%
         * @default [1, 1, 1]
         */
        scaleXyz: Base.Vector3;
      }
      class UniformScaleDto {
        constructor(scale?: number);
        /**
         * Uniform scale factor for all x, y, z directions. 1 will keep everything on original size, 2 will scale 200%;
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scale: number;
      }
      class UniformScaleFromCenterDto {
        constructor(scale?: number, center?: Base.Point3);
        /**
         * Scale factor for all x, y, z directions. 1 will keep everything on original size, 2 will scale 200%;
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scale: number;
        /**
         * Center position of the scaling
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class TranslationXYZDto {
        constructor(translation?: Base.Vector3);
        /**
         * Translation vector with [x, y, z] distances
         * @default [0, 0, 0]
         */
        translation: Base.Vector3;
      }
      class TranslationsXYZDto {
        constructor(translations?: Base.Vector3[]);
        /**
         * Translation vectors with [x, y, z] distances
         * @default undefined
         */
        translations: Base.Vector3[];
      }
    }
    declare namespace BabylonWebXR {
      class WebXRDefaultExperienceOptions {
        constructor(disableDefaultUI?: boolean);
        /**
         * Enable or disable default UI to enter XR
         * @optional true
         */
        disableDefaultUI?: boolean;
        /**
         * Should pointer selection not initialize.
         * Note that disabling pointer selection also disables teleportation.
         * Defaults to false.
         * @optional true
         */
        disablePointerSelection?: boolean;
        /**
         * Should teleportation not initialize. Defaults to false.
         * @optional true
         */
        disableTeleportation?: boolean;
        /**
         * Should nearInteraction not initialize. Defaults to false.
         * @optional true
         */
        disableNearInteraction?: boolean;
        /**
         * Should hand tracking be disabled. Defaults to false.
         * @optional true
         */
        disableHandTracking?: boolean;
        /**
         * Floor meshes that will be used for teleport
         * @optional true
         */
        floorMeshes?: BABYLON.AbstractMesh[];
        /**
         * If set to true, the first frame will not be used to reset position
         * The first frame is mainly used when copying transformation from the old camera
         * Mainly used in AR
         * @optional true
         */
        ignoreNativeCameraTransformation?: boolean;
        /**
         * Optional configuration for the XR input object
         * @optional true
         */
        inputOptions?: Partial<BABYLON.IWebXRInputOptions>;
        /**
         * optional configuration for pointer selection
         * @optional true
         */
        pointerSelectionOptions?: Partial<BABYLON.IWebXRControllerPointerSelectionOptions>;
        /**
         * optional configuration for near interaction
         * @optional true
         */
        nearInteractionOptions?: Partial<BABYLON.IWebXRNearInteractionOptions>;
        /**
         * optional configuration for hand tracking
         * @optional true
         */
        handSupportOptions?: Partial<BABYLON.IWebXRHandTrackingOptions>;
        /**
         * optional configuration for teleportation
         * @optional true
         */
        teleportationOptions?: Partial<BABYLON.IWebXRTeleportationOptions>;
        /**
         * optional configuration for the output canvas
         * @optional true
         */
        outputCanvasOptions?: BABYLON.WebXRManagedOutputCanvasOptions;
        /**
         * optional UI options. This can be used among other to change session mode and reference space type
         * @optional true
         */
        uiOptions?: Partial<BABYLON.WebXREnterExitUIOptions>;
        /**
         * When loading teleportation and pointer select, use stable versions instead of latest.
         * @optional true
         */
        useStablePlugins?: boolean;
        /**
         * An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes
         * @optional true
         */
        renderingGroupId?: number;
        /**
         * A list of optional features to init the session with
         * If set to true, all features we support will be added
         * @optional true
         */
        optionalFeatures?: boolean | string[];
      }
      class DefaultWebXRWithTeleportationDto {
        constructor(groundMeshes?: BABYLON.Mesh[]);
        /**
         * Create XR experience with ground meshes
         */
        groundMeshes: BABYLON.Mesh[];
      }
      class WebXRDefaultExperienceDto {
        constructor(webXRDefaultExperience?: BABYLON.WebXRDefaultExperience);
        /**
         * Web XR default experience
         */
        webXRDefaultExperience: BABYLON.WebXRDefaultExperience;
      }
      class WebXRExperienceHelperDto {
        constructor(baseExperience?: BABYLON.WebXRExperienceHelper);
        /**
         * Base experience
         */
        baseExperience: BABYLON.WebXRExperienceHelper;
      }
    }
    declare namespace Base {
      /**
       * Defines how colors are mapped to entities when there are more entities than colors.
       * - firstColorForAll: Uses the first color for all entities (legacy behavior)
       * - lastColorRemainder: Maps colors 1:1, then uses last color for remaining entities
       * - repeatColors: Cycles through colors in a repeating pattern
       * - reversedColors: After exhausting colors, reverses direction (ping-pong pattern)
       */
      enum colorMapStrategyEnum {
        /** Uses the first color for all entities (legacy behavior) */
        firstColorForAll = "firstColorForAll",
        /** Maps colors 1:1, then uses last color for remaining entities */
        lastColorRemainder = "lastColorRemainder",
        /** Cycles through colors in a repeating pattern */
        repeatColors = "repeatColors",
        /** After exhausting colors, reverses direction (ping-pong pattern) */
        reversedColors = "reversedColors",
      }
      enum skyboxEnum {
        default = "default",
        clearSky = "clearSky",
        city = "city",
        greyGradient = "greyGradient",
      }
      enum fogModeEnum {
        none = "none",
        exponential = "exponential",
        exponentialSquared = "exponentialSquared",
        linear = "linear",
      }
      enum gradientDirectionEnum {
        toTop = "to top",
        toTopRight = "to top right",
        toRight = "to right",
        toBottomRight = "to bottom right",
        toBottom = "to bottom",
        toBottomLeft = "to bottom left",
        toLeft = "to left",
        toTopLeft = "to top left",
        deg0 = "0deg",
        deg45 = "45deg",
        deg90 = "90deg",
        deg135 = "135deg",
        deg180 = "180deg",
        deg225 = "225deg",
        deg270 = "270deg",
        deg315 = "315deg",
      }
      enum gradientPositionEnum {
        center = "center",
        top = "top",
        topLeft = "top left",
        topRight = "top right",
        bottom = "bottom",
        bottomLeft = "bottom left",
        bottomRight = "bottom right",
        left = "left",
        right = "right",
        centerTop = "50% 0%",
        centerBottom = "50% 100%",
        leftCenter = "0% 50%",
        rightCenter = "100% 50%",
      }
      enum gradientShapeEnum {
        circle = "circle",
        ellipse = "ellipse",
      }
      enum backgroundRepeatEnum {
        repeat = "repeat",
        repeatX = "repeat-x",
        repeatY = "repeat-y",
        noRepeat = "no-repeat",
        space = "space",
        round = "round",
      }
      enum backgroundSizeEnum {
        auto = "auto",
        cover = "cover",
        contain = "contain",
      }
      enum backgroundAttachmentEnum {
        scroll = "scroll",
        fixed = "fixed",
        local = "local",
      }
      enum backgroundOriginClipEnum {
        paddingBox = "padding-box",
        borderBox = "border-box",
        contentBox = "content-box",
      }
      enum verticalAlignmentEnum {
        top = "top",
        middle = "middle",
        bottom = "bottom",
      }
      enum topBottomEnum {
        top = "top",
        bottom = "bottom",
      }
      type Color = string;
      type ColorRGB = {
        r: number;
        g: number;
        b: number;
      };
      type Material = any;
      type Texture = any;
      type Point2 = [number, number];
      type Vector2 = [number, number];
      type Point3 = [number, number, number];
      type Vector3 = [number, number, number];
      type Axis3 = {
        origin: Base.Point3;
        direction: Base.Vector3;
      };
      type Axis2 = {
        origin: Base.Point2;
        direction: Base.Vector2;
      };
      type Segment2 = [Point2, Point2];
      type Segment3 = [Point3, Point3];
      type TrianglePlane3 = {
        normal: Vector3;
        d: number;
      };
      type Triangle3 = [Base.Point3, Base.Point3, Base.Point3];
      type Mesh3 = Triangle3[];
      type Plane3 = {
        origin: Base.Point3;
        normal: Base.Vector3;
        direction: Base.Vector3;
      };
      type BoundingBox = {
        min: Base.Point3;
        max: Base.Point3;
        center?: Base.Point3;
        width?: number;
        height?: number;
        length?: number;
      };
      type Line2 = {
        start: Base.Point2;
        end: Base.Point2;
      };
      type Line3 = {
        start: Base.Point3;
        end: Base.Point3;
      };
      type Polyline3 = {
        points: Base.Point3[];
        isClosed?: boolean;
      };
      type Polyline2 = {
        points: Base.Point2[];
        isClosed?: boolean;
      };
      type VerbCurve = {
        tessellate: (options: any) => any;
      };
      type VerbSurface = {
        tessellate: (options: any) => any;
      };
      type TransformMatrix3x3 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes3x3 = TransformMatrix3x3[];
      type TransformMatrix = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes = TransformMatrix[];
    }
    declare namespace Draw {
      type DrawOptions =
        | DrawBasicGeometryOptions
        | DrawManifoldOrCrossSectionOptions
        | DrawOcctShapeOptions
        | DrawOcctShapeSimpleOptions
        | DrawOcctShapeMaterialOptions
        | DrawNodeOptions;
      type Entity =
        | Base.Point3
        | Base.Vector3
        | Base.Line3
        | Base.Polyline3
        | Base.VerbCurve
        | Base.VerbSurface
        | Inputs.OCCT.TopoDSShapePointer
        | Inputs.Tag.TagDto
        | {
            type: string;
            name?: string;
            entityName?: string;
          }
        | Base.Point3[]
        | Base.Vector3[]
        | Base.Line3[]
        | Base.Polyline3[]
        | Base.VerbCurve[]
        | Base.VerbSurface[]
        | Inputs.OCCT.TopoDSShapePointer[]
        | Inputs.Tag.TagDto[]
        | {
            type: string[];
            name?: string;
            entityName?: string;
          };
      class DrawAny {
        constructor(
          entity?: Entity,
          options?: DrawOptions,
          babylonMesh?: BABYLON.Mesh | BABYLON.LinesMesh
        );
        /**
         * Entity to be drawn - can be a single or multiple points, lines, polylines, verb curves, verb surfaces, jscad meshes, jscad polygons, jscad paths, occt shapes, tags, nodes
         * @default undefined
         */
        entity: Entity;
        /**
         * Options that help you control how your drawn objects look like. This property is optional. In order to pick the right option you need to know which entity you are going to draw. For example if you draw points, lines, polylines or jscad meshes you can use basic geometry options, but if you want to draw OCCT shapes, use OCCT options.
         * @default undefined
         * @optional true
         */
        options?: DrawOptions;
        /**
         * Entity to be used when updating already drawn mesh in the render loop
         * @default undefined
         * @optional true
         */
        babylonMesh?: BABYLON.Mesh | BABYLON.LinesMesh;
      }
      class SceneDrawGridMeshDto {
        constructor(
          width?: number,
          height?: number,
          subdivisions?: number,
          majorUnitFrequency?: number,
          minorUnitVisibility?: number,
          gridRatio?: number,
          opacity?: number,
          backFaceCulling?: boolean,
          mainColor?: Base.Color,
          secondaryColor?: Base.Color
        );
        /**
         * Width of the grid
         * @default 400
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        width: number;
        /**
         * Height of the ground
         * @default 400
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        height: number;
        /**
         * Ground subdivisions
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        subdivisions: number;
        /**
         * The frequency of thicker lines.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        majorUnitFrequency: number;
        /**
         * The visibility of minor units in the grid.
         * @default 0.45
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        minorUnitVisibility: number;
        /**
         * The scale of the grid compared to unit.
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        gridRatio: number;
        /**
         * The grid opacity outside of the lines.
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * Cull the back faces
         * @default false
         */
        backFaceCulling: boolean;
        /**
         * Main color of the grid (e.g. between lines)
         * @default #ffffff
         */
        mainColor: Base.Color;
        /**
         * Color of the grid lines.
         * @default #ffffff
         */
        secondaryColor: Base.Color;
      }
      /**
       * Draw options for basic geometry types like points, lines, polylines, surfaces and jscad meshes
       */
      class DrawBasicGeometryOptions {
        constructor(
          colours?: string | string[],
          size?: number,
          opacity?: number,
          updatable?: boolean,
          hidden?: boolean,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number,
          colorMapStrategy?: Base.colorMapStrategyEnum,
          arrowSize?: number,
          arrowAngle?: number
        );
        /**
         * Basic geometry colours to use for lines, points, polylines, surfaces, jscad meshes.
         * @default #ff0000
         */
        colours: string | string[];
        /**
         * Strategy for mapping colors to entities when there are more entities than colors.
         * - firstColorForAll: Uses the first color for all entities (legacy behavior)
         * - lastColorRemainder: Maps colors 1:1, then uses last color for remaining entities
         * - repeatColors: Cycles through colors in a repeating pattern
         * - reversedColors: After exhausting colors, reverses direction (ping-pong pattern)
         * @default lastColorRemainder
         */
        colorMapStrategy: Base.colorMapStrategyEnum;
        /**
         * Size affect how big the drawn points are and how wide lines are.
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Opacity of the point 0 to 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * If geometry needs to be updated later
         * @default false
         */
        updatable: boolean;
        /**
         * Hidden
         * @default false
         */
        hidden: boolean;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation. Only applies to surfaces.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true and drawing surfaces.
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true and drawing surfaces.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
        /**
         * Size of the arrow head at the end of lines and polylines. Set to 0 to disable arrows.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        arrowSize: number;
        /**
         * Angle of the arrow head in degrees. Controls how wide the arrow head spreads.
         * @default 15
         * @minimum 0
         * @maximum 90
         * @step 1
         */
        arrowAngle: number;
      }
      /**
       * Draw options for Nodes
       */
      class DrawNodeOptions {
        constructor(
          colourX?: Base.Color,
          colourY?: Base.Color,
          colourZ?: Base.Color,
          size?: number
        );
        /**
         * X Axis colour
         * @default #ff0000
         */
        colorX: Base.Color;
        /**
         * Y Axis colour
         * @default #00ff00
         */
        colorY: Base.Color;
        /**
         * Z Axis colour
         * @default #0000ff
         */
        colorZ: Base.Color;
        /**
         * Length of the node axis
         * @default 2
         * @minimum 0
         * @maximum Infinity
         */
        size: number;
      }
      class DrawManifoldOrCrossSectionOptions {
        /**
         * Provide options without default values
         */
        constructor(
          faceOpacity?: number,
          faceMaterial?: Base.Material,
          faceColour?: Base.Color,
          crossSectionColour?: Base.Color,
          crossSectionWidth?: number,
          crossSectionOpacity?: number,
          computeNormals?: boolean,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number
        );
        /**
         * Face opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        faceOpacity: number;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour: Base.Color;
        /**
         * Face material
         * @default undefined
         * @optional true
         */
        faceMaterial?: Base.Material;
        /**
         * Hex colour string for cross section drawing
         * @default #ff00ff
         */
        crossSectionColour: Base.Color;
        /**
         * Width of cross section lines
         * @default 2
         */
        crossSectionWidth: number;
        /**
         * Cross section opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        crossSectionOpacity: number;
        /**
         * Compute normals for the shape
         * @default false
         */
        computeNormals: boolean;
        /**
         * Whether to draw two-sided geometry with back face rendering
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for the back face when drawing two-sided geometry
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Opacity of the back face when drawing two-sided geometry
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      /**
       * Draw options for OCCT shapes
       */
      class DrawOcctShapeOptions {
        /**
         * Provide options without default values
         */
        constructor(
          faceOpacity?: number,
          edgeOpacity?: number,
          edgeColour?: Base.Color,
          faceMaterial?: Base.Material,
          faceColour?: Base.Color,
          edgeWidth?: number,
          drawEdges?: boolean,
          drawFaces?: boolean,
          drawVertices?: boolean,
          vertexColour?: Base.Color,
          vertexSize?: number,
          precision?: number,
          drawEdgeIndexes?: boolean,
          edgeIndexHeight?: number,
          edgeIndexColour?: Base.Color,
          drawFaceIndexes?: boolean,
          faceIndexHeight?: number,
          faceIndexColour?: Base.Color,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number,
          edgeArrowSize?: number,
          edgeArrowAngle?: number
        );
        /**
         * Face opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        faceOpacity: number;
        /**
         * Edge opacity value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        edgeOpacity: number;
        /**
         * Hex colour string for the edges
         * @default #ffffff
         */
        edgeColour: Base.Color;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour: Base.Color;
        /**
         * Color of the vertices that will be drawn
         * @default #ff00ff
         */
        vertexColour: Base.Color;
        /**
         * Face material
         * @default undefined
         * @optional true
         */
        faceMaterial?: Base.Material;
        /**
         * Edge width
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        edgeWidth: number;
        /**
         * The size of a vertices that will be drawn
         * @default 0.03
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        vertexSize: number;
        /**
         * You can turn off drawing of edges via this property
         * @default true
         */
        drawEdges: boolean;
        /**
         * You can turn off drawing of faces via this property
         * @default true
         */
        drawFaces: boolean;
        /**
         * You can turn off drawing of vertexes via this property
         * @default false
         */
        drawVertices: boolean;
        /**
         * Precision of the mesh that will be generated for the shape, lower number will mean more triangles
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        precision: number;
        /**
         * Draw index of edges in space
         * @default false
         */
        drawEdgeIndexes: boolean;
        /**
         * Indicates the edge index height if they are drawn
         * @default 0.06
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        edgeIndexHeight: number;
        /**
         * Edge index colour if the edges are drawn
         * @default #ff00ff
         */
        edgeIndexColour: Base.Color;
        /**
         * Draw indexes of faces in space
         * @default false
         */
        drawFaceIndexes: boolean;
        /**
         * Indicates the edge index height if they are drawn
         * @default 0.06
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        faceIndexHeight: number;
        /**
         * Edge index colour if the edges are drawn
         * @default #0000ff
         */
        faceIndexColour: Base.Color;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
        /**
         * Size of arrow heads at the end of edges to indicate edge/wire orientation. Set to 0 to disable arrows.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        edgeArrowSize: number;
        /**
         * Angle of the arrow head in degrees. Controls how wide the arrow head spreads.
         * @default 15
         * @minimum 0
         * @maximum 90
         * @step 1
         */
        edgeArrowAngle: number;
      }
      class DrawOcctShapeSimpleOptions {
        constructor(
          precision?: number,
          drawFaces?: boolean,
          faceColour?: Base.Color,
          drawEdges?: boolean,
          edgeColour?: Base.Color,
          edgeWidth?: number,
          drawTwoSided?: boolean,
          backFaceColour?: Base.Color,
          backFaceOpacity?: number
        );
        /**
         * Precision
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         */
        precision: number;
        /**
         * You can turn off drawing of faces via this property
         * @default true
         */
        drawFaces: boolean;
        /**
         * Hex colour string for face colour
         * @default #ff0000
         */
        faceColour?: Base.Color;
        /**
         * You can turn off drawing of edges via this property
         * @default true
         */
        drawEdges: boolean;
        /**
         * Hex colour string for the edges
         * @default #ffffff
         */
        edgeColour: Base.Color;
        /**
         * Edge width
         * @default 2
         * @minimum 0
         * @maximum Infinity
         */
        edgeWidth: number;
        /**
         * Whether to draw two-sided geometry with back face rendering
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for the back face when drawing two-sided geometry
         * @default #0000ff
         */
        backFaceColour: Base.Color;
        /**
         * Opacity of the back face when drawing two-sided geometry
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawOcctShapeMaterialOptions {
        constructor(
          precision?: number,
          faceMaterial?: any,
          drawEdges?: boolean,
          edgeColour?: Base.Color,
          edgeWidth?: number
        );
        /**
         * Precision
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         */
        precision: number;
        /**
         * Face material
         * @default undefined
         */
        faceMaterial: any;
        /**
         * You can turn off drawing of edges via this property
         * @default true
         */
        drawEdges: boolean;
        /**
         * Hex colour string for the edges
         * @default #ffffff
         */
        edgeColour: Base.Color;
        /**
         * Edge width
         * @default 2
         * @minimum 0
         * @maximum Infinity
         */
        edgeWidth: number;
      }
      /**
       * Texture filtering mode - how the texture is sampled when scaled
       */
      enum samplingModeEnum {
        nearest = "nearest",
        bilinear = "bilinear",
        trilinear = "trilinear",
      }
      /**
       * Generic texture creation options that work across all supported game engines.
       * These options are mapped to engine-specific texture properties.
       */
      class GenericTextureDto {
        constructor(
          url?: string,
          name?: string,
          uScale?: number,
          vScale?: number,
          uOffset?: number,
          vOffset?: number,
          wAng?: number,
          invertY?: boolean,
          invertZ?: boolean,
          samplingMode?: samplingModeEnum
        );
        /**
         * URL of the texture image. Can be a local path or remote URL.
         * @default undefined
         */
        url: string;
        /**
         * Name identifier for the texture
         * @default Texture
         */
        name: string;
        /**
         * Horizontal (U) scale/tiling of the texture
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        uScale: number;
        /**
         * Vertical (V) scale/tiling of the texture
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        vScale: number;
        /**
         * Horizontal (U) offset of the texture
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        uOffset: number;
        /**
         * Vertical (V) offset of the texture
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        vOffset: number;
        /**
         * Rotation angle of the texture in radians around the W axis
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        wAng: number;
        /**
         * Invert the texture on the Y axis
         * @default false
         */
        invertY: boolean;
        /**
         * Invert the texture on the Z axis
         * @default false
         */
        invertZ: boolean;
        /**
         * Texture sampling/filtering mode
         * @default nearest
         */
        samplingMode: samplingModeEnum;
      }
      /**
       * Alpha/blend modes that determine how transparent materials are rendered
       */
      enum alphaModeEnum {
        opaque = "opaque",
        mask = "mask",
        blend = "blend",
      }
      /**
       * Generic PBR (Physically Based Rendering) material creation options.
       * These properties represent the common subset available across BabylonJS, ThreeJS, and PlayCanvas.
       * Property names follow BabylonJS conventions and are mapped to equivalent properties in other engines.
       */
      class GenericPBRMaterialDto {
        constructor(
          name?: string,
          baseColor?: Base.Color,
          metallic?: number,
          roughness?: number,
          alpha?: number,
          emissiveColor?: Base.Color,
          emissiveIntensity?: number,
          zOffset?: number,
          zOffsetUnits?: number,
          baseColorTexture?: Base.Texture,
          metallicRoughnessTexture?: Base.Texture,
          normalTexture?: Base.Texture,
          emissiveTexture?: Base.Texture,
          occlusionTexture?: Base.Texture,
          alphaMode?: alphaModeEnum,
          alphaCutoff?: number,
          doubleSided?: boolean,
          wireframe?: boolean,
          unlit?: boolean
        );
        /**
         * Name identifier for the material
         * @default PBRMaterial
         */
        name: string;
        /**
         * Base/albedo color of the material in hex format
         * @default #0000ff
         */
        baseColor: Base.Color;
        /**
         * Metallic factor (0 = dielectric, 1 = metallic)
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        metallic: number;
        /**
         * Roughness factor (0 = smooth/mirror, 1 = rough/diffuse)
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        roughness: number;
        /**
         * Overall opacity/transparency of the material (0 = fully transparent, 1 = fully opaque)
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        alpha: number;
        /**
         * Emissive color - the color the material appears to emit (glow)
         * @default #000000
         */
        emissiveColor?: Base.Color;
        /**
         * Intensity multiplier for the emissive color
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        emissiveIntensity: number;
        /**
         * Z-buffer depth offset factor to help with z-fighting on coplanar surfaces
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        zOffset: number;
        /**
         * Z-buffer depth offset units for fine-tuned z-fighting control
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        zOffsetUnits: number;
        /**
         * Texture to use for base/albedo color
         * @default undefined
         * @optional true
         */
        baseColorTexture?: Base.Texture;
        /**
         * Combined metallic-roughness texture (metallic in B channel, roughness in G channel)
         * @default undefined
         * @optional true
         */
        metallicRoughnessTexture?: Base.Texture;
        /**
         * Normal/bump map texture for surface detail
         * @default undefined
         * @optional true
         */
        normalTexture?: Base.Texture;
        /**
         * Texture for emissive/glow areas
         * @default undefined
         * @optional true
         */
        emissiveTexture?: Base.Texture;
        /**
         * Ambient occlusion texture for soft shadows in crevices
         * @default undefined
         * @optional true
         */
        occlusionTexture?: Base.Texture;
        /**
         * Alpha/transparency mode: opaque, mask (cutout), or blend (translucent)
         * @default opaque
         */
        alphaMode: alphaModeEnum;
        /**
         * Alpha threshold for mask mode (pixels below this are fully transparent)
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.05
         */
        alphaCutoff: number;
        /**
         * Render both sides of faces (equivalent to disabling backFaceCulling)
         * @default false
         */
        doubleSided: boolean;
        /**
         * Render material as wireframe
         * @default false
         */
        wireframe: boolean;
        /**
         * Disable lighting calculations and render flat/unlit
         * @default false
         */
        unlit: boolean;
      }
      enum drawingTypes {
        point = 0,
        points = 1,
        line = 2,
        lines = 3,
        node = 4,
        nodes = 5,
        polyline = 6,
        polylines = 7,
        verbCurve = 8,
        verbCurves = 9,
        verbSurface = 10,
        verbSurfaces = 11,
        jscadMesh = 12,
        jscadMeshes = 13,
        occt = 14,
        manifold = 15,
        tag = 16,
        tags = 17,
      }
    }
    declare namespace BabylonNode {
      class NodeDto {
        constructor(node?: BABYLON.TransformNode);
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
      }
      class NodeTranslationDto {
        constructor(
          node?: BABYLON.TransformNode,
          direction?: Base.Vector3,
          distance?: number
        );
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Direction vector expressed in [x, y, z] vector array
         */
        direction: Base.Vector3;
        /**
         * Distance to translate
         */
        distance: number;
      }
      class NodeParentDto {
        constructor(
          node?: BABYLON.TransformNode,
          parentNode?: BABYLON.TransformNode
        );
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Parent node
         */
        parentNode: BABYLON.TransformNode;
      }
      class NodeDirectionDto {
        constructor(node?: BABYLON.TransformNode, direction?: Base.Vector3);
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Direction vector expressed in [x, y, z] vector array
         */
        direction: number[];
      }
      class NodePositionDto {
        constructor(node?: BABYLON.TransformNode, position?: Base.Point3);
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Position vector expressed in [x, y, z] vector array
         */
        position: Base.Point3;
      }
      class RotateNodeDto {
        constructor(
          node?: BABYLON.TransformNode,
          axis?: Base.Vector3,
          angle?: number
        );
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Rotate around the axis expressed in [x, y, z] vector array
         */
        axis: Base.Vector3;
        /**
         * The rotation angle expressed in degrees
         */
        angle: number;
      }
      class RotateAroundAxisNodeDto {
        constructor(
          node?: BABYLON.TransformNode,
          position?: Base.Point3,
          axis?: Base.Vector3,
          angle?: number
        );
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Position vector expressed in [x, y, z] vector array
         */
        position: Base.Point3;
        /**
         * Rotate around the axis expressed in [x, y, z] vector array
         */
        axis: Base.Vector3;
        /**
         * The rotation angle expressed in degrees
         */
        angle: number;
      }
      class CreateNodeFromRotationDto {
        constructor(
          parent?: BABYLON.TransformNode,
          origin?: Base.Point3,
          rotation?: Base.Vector3
        );
        /**
         * Optional parent node
         */
        parent: BABYLON.TransformNode | null;
        /**
         * Oirigin of the node
         */
        origin: Base.Point3;
        /**
         * Rotations of the node around x y z axis
         */
        rotation: Base.Vector3;
      }
      class DrawNodeDto {
        constructor(
          node?: BABYLON.TransformNode,
          colorX?: string,
          colorY?: string,
          colorZ?: string,
          size?: number
        );
        /**
         * Transformation node
         */
        node: BABYLON.TransformNode;
        /**
         * Hex encoded color string for X axis
         */
        colorX: string;
        /**
         * Hex encoded color string for Y axis
         */
        colorY: string;
        /**
         * Hex encoded color string for Z axis
         */
        colorZ: string;
        /**
         * Length of the node axis
         */
        size: number;
      }
      class DrawNodesDto {
        constructor(
          nodes?: BABYLON.TransformNode[],
          colorX?: string,
          colorY?: string,
          colorZ?: string,
          size?: number
        );
        /**
         * Nodes that will be drawn
         */
        nodes: BABYLON.TransformNode[];
        /**
         * Hex encoded color string for X axis
         */
        colorX: string;
        /**
         * Hex encoded color string for Y axis
         */
        colorY: string;
        /**
         * Hex encoded color string for Z axis
         */
        colorZ: string;
        /**
         * Length of the node axis
         */
        size: number;
      }
    }
    declare namespace BabylonScene {
      class SceneBackgroundColourDto {
        /**
         * Provide options without default values
         */
        constructor(colour?: string);
        /**
         * Hex colour string for the scene background colour
         * @default #ffffff
         */
        colour: Base.Color;
      }
      class SceneDto {
        /**
         * Provide scene
         */
        constructor(scene?: BABYLON.Scene);
        /**
         * The babylonjs scene
         * @default undefined
         */
        scene: BABYLON.Scene;
      }
      class EnablePhysicsDto {
        constructor(vector?: Base.Vector3);
        /**
         * The gravity vector
         * @default [0, -9.81, 0]
         */
        vector: Base.Vector3;
      }
      class PointLightDto {
        constructor(
          position?: Base.Point3,
          intensity?: number,
          diffuse?: Base.Color,
          specular?: Base.Color,
          radius?: number,
          shadowGeneratorMapSize?: number,
          enableShadows?: boolean,
          shadowDarkness?: number,
          transparencyShadow?: boolean,
          shadowUsePercentageCloserFiltering?: boolean,
          shadowContactHardeningLightSizeUVRatio?: number,
          shadowBias?: number,
          shadowNormalBias?: number,
          shadowMaxZ?: number,
          shadowMinZ?: number,
          shadowRefreshRate?: number
        );
        /**
         * Position of the point light
         * @default [0, 0, 0]
         */
        position: Base.Point3;
        /**
         * Intensity of the point light, value between 0 and 1
         * @default 2000
         * @minimum 0
         * @maximum Infinity
         * @step 500
         */
        intensity: number;
        /**
         * Diffuse colour of the point light
         * @default #ffffff
         */
        diffuse: Base.Color;
        /**
         * Specular colour of the point light
         * @default #ffffff
         */
        specular: Base.Color;
        /**
         * Radius of the sphere mesh representing the light bulb. If 0 light gets created without the mesh
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * The map size for shadow generator texture if shadows are enabled
         * @default 1024
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shadowGeneratorMapSize?: number;
        /**
         * Enables shadows
         * @default true
         */
        enableShadows?: boolean;
        /**
         * Shadow darkness
         * @default 0
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        shadowDarkness?: number;
        /**
         * Sets the ability to have transparent shadow (useful for Gaussian Splatting Meshes)
         * @default false
         */
        transparencyShadow: boolean;
        /**
         * Use percentage closer filtering
         * @default true
         */
        shadowUsePercentageCloserFiltering: boolean;
        /**
         * Shadow contact hardening light size UV ratio - only applies if usePercentageCloserFiltering is true
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        shadowContactHardeningLightSizeUVRatio: number;
        /**
         * Shadow bias
         * @default 0.0001
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        shadowBias: number;
        /**
         * Shadow normal bias
         * @default 0.002
         * @minimum 0
         * @maximum Infinity
         * @step 0.0001
         */
        shadowNormalBias: number;
        /**
         * Shadow max Z
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 50
         */
        shadowMaxZ: number;
        /**
         * Shadow min Z
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 50
         */
        shadowMinZ: number;
        /**
         * Shadow refresh rate
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shadowRefreshRate: number;
      }
      class ActiveCameraDto {
        constructor(camera?: BABYLON.Camera);
        /**
         * Camera to activate
         * @default undefined
         */
        camera: BABYLON.Camera;
      }
      class UseRightHandedSystemDto {
        constructor(use?: boolean);
        /** Indicates to use right handed system
         * @default true
         */
        use: boolean;
      }
      class DirectionalLightDto {
        constructor(
          direction?: Base.Vector3,
          intensity?: number,
          diffuse?: Base.Color,
          specular?: Base.Color,
          shadowGeneratorMapSize?: number,
          enableShadows?: boolean,
          shadowDarkness?: number,
          shadowUsePercentageCloserFiltering?: boolean,
          shadowContactHardeningLightSizeUVRatio?: number,
          shadowBias?: number,
          shadowNormalBias?: number,
          shadowMaxZ?: number,
          shadowMinZ?: number,
          shadowRefreshRate?: number
        );
        /**
         * Direction of the directional light
         * @default [-100, -100, -100]
         */
        direction: Base.Vector3;
        /**
         * Intensity of the point light, value between 0 and 1
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        intensity: number;
        /**
         * Diffuse colour of the point light
         * @default #ffffff
         */
        diffuse: Base.Color;
        /**
         * Specular colour of the point light
         * @default #ffffff
         */
        specular: Base.Color;
        /**
         * The map size for shadow generator texture if shadows are enabled
         * @default 1024
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shadowGeneratorMapSize?: number;
        /**
         * Enables shadows
         * @default true
         */
        enableShadows?: boolean;
        /**
         * Shadow darkness
         * @default 0
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        shadowDarkness?: number;
        /**
         * Use percentage closer filtering
         * @default true
         */
        shadowUsePercentageCloserFiltering: boolean;
        /**
         * Sets the ability to have transparent shadow (useful for Gaussian Splatting Meshes)
         * @default false
         */
        transparencyShadow: boolean;
        /**
         * Shadow contact hardening light size UV ratio - only applies if usePercentageCloserFiltering is true
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        shadowContactHardeningLightSizeUVRatio: number;
        /**
         * Shadow bias
         * @default 0.0001
         * @minimum 0
         * @maximum Infinity
         * @step 0.00001
         */
        shadowBias: number;
        /**
         * Shadow normal bias
         * @default 0.002
         * @minimum 0
         * @maximum Infinity
         * @step 0.0001
         */
        shadowNormalBias: number;
        /**
         * Shadow max Z
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 50
         */
        shadowMaxZ: number;
        /**
         * Shadow min Z
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 50
         */
        shadowMinZ: number;
        /**
         * Shadow refresh rate
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        shadowRefreshRate: number;
      }
      class CameraConfigurationDto {
        constructor(
          position?: Base.Point3,
          lookAt?: Base.Point3,
          lowerRadiusLimit?: number,
          upperRadiusLimit?: number,
          lowerAlphaLimit?: number,
          upperAlphaLimit?: number,
          lowerBetaLimit?: number,
          upperBetaLimit?: number,
          angularSensibilityX?: number,
          angularSensibilityY?: number,
          maxZ?: number,
          panningSensibility?: number,
          wheelPrecision?: number
        );
        /**
         * Position of the point light
         * @default [10, 10, 10]
         *
         */
        position: Base.Point3;
        /**
         * Look at
         */
        lookAt: Base.Point3;
        /**
         * Lower radius limit - how close can the camera be to the target
         * @default undefined
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         * @optional true
         */
        lowerRadiusLimit: any;
        /**
         * Upper radius limit - how far can the camera be from the target
         * @default undefined
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         * @optional true
         */
        upperRadiusLimit: any;
        /**
         * Lower alpha limit - camera rotation along the longitudinal (horizontal) axis in degrees.
         * @default undefined
         * @minimum -360
         * @maximum 360
         * @step 1
         * @optional true
         */
        lowerAlphaLimit: any;
        /**
         * Upper alpha limit - camera rotation along the longitudinal (horizontal) axis in degrees.
         * @default undefined
         * @minimum -360
         * @maximum 360
         * @step 1
         * @optional true
         */
        upperAlphaLimit: any;
        /**
         * Lower beta limit - camera rotation along the latitudinal (vertical) axis in degrees. This is counted from the top down, where 0 is looking from top straight down.
         * @default 1
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        lowerBetaLimit: number;
        /**
         * Upper beta limit - camera rotation along the longitudinal (vertical) axis in degrees. This is counted from the top down, where 180 is looking from bottom straight up.
         * @default 179
         * @minimum -360
         * @maximum 360
         * @step 1
         */
        upperBetaLimit: number;
        /**
         * Angular sensibility along x (horizontal) axis of the camera. The lower this number, the faster the camera will move.
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        angularSensibilityX: number;
        /**
         * Angular sensibility along y (vertical) axis of the camera. The lower this number, the faster the camera will move.
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        angularSensibilityY: number;
        /**
         * Change how far the camera can see
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        maxZ: number;
        /**
         * Panning sensibility. If large units are used for the model, this number needs to get smaller
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        panningSensibility: number;
        /**
         * Zoom precision of the wheel. If large units are used, this number needs to get smaller
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        wheelPrecision: number;
      }
      class SkyboxDto {
        constructor(
          skybox?: Base.skyboxEnum,
          size?: number,
          blur?: number,
          environmentIntensity?: number,
          hideSkybox?: boolean
        );
        /**
         * Skybox type
         * @default clearSky
         */
        skybox: Base.skyboxEnum;
        /**
         * Skybox size
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        size: number;
        /**
         * Identifies if skybox texture should affect scene environment
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        blur: number;
        /**
         * Identifies if skybox texture should affect scene environment
         * @default 0.7
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        environmentIntensity: number;
        /**
         * Hides the skybox mesh but keeps the environment texture
         * @default false
         */
        hideSkybox?: boolean;
      }
      class SkyboxCustomTextureDto {
        constructor(
          textureUrl?: string,
          textureSize?: number,
          size?: number,
          blur?: number,
          environmentIntensity?: number,
          hideSkybox?: boolean
        );
        /**
         * Skybox texture URL pointing to .hdr, .env or root of the cubemap images
         * @default undefined
         * @optional true
         */
        textureUrl?: string;
        /**
         * Skybox texture size (only applies to custom URL texture)
         * @default 512
         * @optional true
         */
        textureSize?: number;
        /**
         * Skybox size
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        size: number;
        /**
         * Identifies if skybox texture should affect scene environment
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        blur: number;
        /**
         * Identifies if skybox texture should affect scene environment
         * @default 0.7
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        environmentIntensity: number;
        /**
         * Hides the skybox mesh but keeps the environment texture
         * @default false
         */
        hideSkybox?: boolean;
      }
      class PointerDto {
        statement_update: () => void;
      }
      class FogDto {
        constructor(
          mode?: Base.fogModeEnum,
          color?: Base.Color,
          density?: number,
          start?: number,
          end?: number
        );
        /**
         * Fog mode
         * @default none
         */
        mode: Base.fogModeEnum;
        /**
         * Fog color
         * @default #ffffff
         */
        color: Base.Color;
        /**
         * Fog density
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        density: number;
        /**
         * Fog start
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        start: number;
        /**
         * Fog end
         * @default 1000
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        end: number;
      }
      class SceneCanvasCSSBackgroundImageDto {
        /**
         * Provide options without default values
         */
        constructor(cssBackgroundImage?: string);
        /**
         * CSS background image string
         * @default linear-gradient(to top, #1a1c1f 0%, #93aacd 100%)
         */
        cssBackgroundImage: string;
      }
      class SceneTwoColorLinearGradientDto {
        constructor(
          colorFrom?: Base.Color,
          colorTo?: Base.Color,
          direction?: Base.gradientDirectionEnum,
          stopFrom?: number,
          stopTo?: number
        );
        /**
         * Starting color in hex format
         * @default #1a1c1f
         */
        colorFrom: Base.Color;
        /**
         * Ending color in hex format
         * @default #93aacd
         */
        colorTo: Base.Color;
        /**
         * Gradient direction
         * @default toBottom
         */
        direction: Base.gradientDirectionEnum;
        /**
         * Starting color stop percentage
         * @default 0
         * @minimum 0
         * @maximum 100
         * @step 1
         */
        stopFrom: number;
        /**
         * Ending color stop percentage
         * @default 100
         * @minimum 0
         * @maximum 100
         * @step 1
         */
        stopTo: number;
      }
      class SceneTwoColorRadialGradientDto {
        constructor(
          colorFrom?: Base.Color,
          colorTo?: Base.Color,
          position?: Base.gradientPositionEnum,
          stopFrom?: number,
          stopTo?: number,
          shape?: Base.gradientShapeEnum
        );
        /**
         * Starting color in hex format
         * @default #1a1c1f
         */
        colorFrom: Base.Color;
        /**
         * Ending color in hex format
         * @default #93aacd
         */
        colorTo: Base.Color;
        /**
         * Gradient position
         * @default center
         */
        position: Base.gradientPositionEnum;
        /**
         * Starting color stop percentage
         * @default 0
         * @minimum 0
         * @maximum 100
         * @step 1
         */
        stopFrom: number;
        /**
         * Ending color stop percentage
         * @default 100
         * @minimum 0
         * @maximum 100
         * @step 1
         */
        stopTo: number;
        /**
         * Gradient shape
         * @default circle
         */
        shape: Base.gradientShapeEnum;
      }
      class SceneMultiColorLinearGradientDto {
        constructor(
          colors?: Base.Color[],
          stops?: number[],
          direction?: Base.gradientDirectionEnum
        );
        /**
         * Array of colors in hex format
         * @default ["#1a1c1f", "#93aacd"]
         */
        colors: Base.Color[];
        /**
         * Array of stop percentages for each color
         * @default [0, 100]
         */
        stops: number[];
        /**
         * Gradient direction
         * @default toTop
         */
        direction: Base.gradientDirectionEnum;
      }
      class SceneMultiColorRadialGradientDto {
        constructor(
          colors?: Base.Color[],
          stops?: number[],
          position?: Base.gradientPositionEnum,
          shape?: Base.gradientShapeEnum
        );
        /**
         * Array of colors in hex format
         * @default ["#1a1c1f", "#93aacd"]
         */
        colors: Base.Color[];
        /**
         * Array of stop percentages for each color
         * @default [0, 100]
         */
        stops: number[];
        /**
         * Gradient position
         * @default center
         */
        position: Base.gradientPositionEnum;
        /**
         * Gradient shape
         * @default circle
         */
        shape: Base.gradientShapeEnum;
      }
      class SceneCanvasBackgroundImageDto {
        constructor(
          imageUrl?: string,
          repeat?: Base.backgroundRepeatEnum,
          size?: Base.backgroundSizeEnum,
          position?: Base.gradientPositionEnum,
          attachment?: Base.backgroundAttachmentEnum,
          origin?: Base.backgroundOriginClipEnum,
          clip?: Base.backgroundOriginClipEnum
        );
        /**
         * URL of the background image
         * @default undefined
         */
        imageUrl?: string;
        /**
         * How the background image should repeat
         * @default noRepeat
         */
        repeat: Base.backgroundRepeatEnum;
        /**
         * Size of the background image (enum values or specific values like '100px 50px')
         * @default cover
         */
        size: Base.backgroundSizeEnum;
        /**
         * Position of the background image (enum values or specific values like '50% 50%')
         * @default center
         */
        position: Base.gradientPositionEnum;
        /**
         * Background attachment
         * @default scroll
         */
        attachment: Base.backgroundAttachmentEnum;
        /**
         * Background origin
         * @default paddingBox
         */
        origin: Base.backgroundOriginClipEnum;
        /**
         * Background clip
         * @default borderBox
         */
        clip: Base.backgroundOriginClipEnum;
      }
    }
    declare namespace Base {
      type Color = string;
      type ColorRGB = {
        r: number;
        g: number;
        b: number;
      };
      type Material = any;
      type Point2 = [number, number];
      type Vector2 = [number, number];
      type Point3 = [number, number, number];
      type Vector3 = [number, number, number];
      type Axis3 = {
        origin: Base.Point3;
        direction: Base.Vector3;
      };
      type Axis2 = {
        origin: Base.Point2;
        direction: Base.Vector2;
      };
      type Segment2 = [Point2, Point2];
      type Segment3 = [Point3, Point3];
      type TrianglePlane3 = {
        normal: Vector3;
        d: number;
      };
      type Triangle3 = [Base.Point3, Base.Point3, Base.Point3];
      type Mesh3 = Triangle3[];
      type Plane3 = {
        origin: Base.Point3;
        normal: Base.Vector3;
        direction: Base.Vector3;
      };
      type BoundingBox = {
        min: Base.Point3;
        max: Base.Point3;
        center?: Base.Point3;
        width?: number;
        height?: number;
        length?: number;
      };
      type Line2 = {
        start: Base.Point2;
        end: Base.Point2;
      };
      type Line3 = {
        start: Base.Point3;
        end: Base.Point3;
      };
      type Polyline3 = {
        points: Base.Point3[];
        isClosed?: boolean;
        color?: number[];
      };
      type Polyline2 = {
        points: Base.Point2[];
        isClosed?: boolean;
        color?: number[];
      };
      type TransformMatrix3x3 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes3x3 = TransformMatrix3x3[];
      type TransformMatrix = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes = TransformMatrix[];
      enum horizontalAlignEnum {
        left = "left",
        center = "center",
        right = "right",
      }
      enum verticalAlignmentEnum {
        top = "top",
        middle = "middle",
        bottom = "bottom",
      }
      enum topBottomEnum {
        top = "top",
        bottom = "bottom",
      }
      enum basicAlignmentEnum {
        topLeft = "topLeft",
        topMid = "topMid",
        topRight = "topRight",
        midLeft = "midLeft",
        midMid = "midMid",
        midRight = "midRight",
        bottomLeft = "bottomLeft",
        bottomMid = "bottomMid",
        bottomRight = "bottomRight",
      }
    }
    declare namespace Color {
      class HexDto {
        constructor(color?: Base.Color);
        /**
         * Color hex
         * @default #0000ff
         */
        color: Base.Color;
      }
      class InvertHexDto {
        constructor(color?: Base.Color);
        /**
         * Color hex
         * @default #0000ff
         */
        color: Base.Color;
        /**
         * Choose to invert the color to black and white (useful for text color)
         */
        blackAndWhite: boolean;
      }
      class HexDtoMapped {
        constructor(color?: Base.Color, from?: number, to?: number);
        /**
         * Color hex
         * @default #0000ff
         */
        color: Base.Color;
        /**
         * From min bound
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        from: number;
        /**
         * To max bound
         * @default 255
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        to: number;
      }
      class RGBObjectMaxDto {
        constructor(rgb?: Base.ColorRGB, max?: number);
        /**
         * Red value component
         * @default undefined
         */
        rgb: Base.ColorRGB;
        /**
         * Min value of the range
         * @default 0
         * @minimum 0
         * @maximum 255
         * @step 0.1
         */
        min: number;
        /**
         * Max value, it would automatically be remapped to whatever is needed if lower comes in
         * @default 255
         * @minimum 0
         * @maximum 255
         * @step 0.1
         */
        max: number;
      }
      class RGBMinMaxDto {
        constructor(
          r?: number,
          g?: number,
          b?: number,
          min?: number,
          max?: number
        );
        /**
         * Red value component
         * @default 255
         * @minimum 0
         * @maximum 255
         * @step 1
         */
        r: number;
        /**
         * Green value component
         * @default 255
         * @minimum 0
         * @maximum 255
         * @step 1
         */
        g: number;
        /**
         * Blue value component
         * @default 255
         * @minimum 0
         * @maximum 255
         * @step 1
         */
        b: number;
        /**
         * Min value of the range
         * @default 0
         * @minimum 0
         * @maximum 255
         * @step 0.1
         */
        min: number;
        /**
         * Max value of the range
         * @default 255
         * @minimum 0
         * @maximum 255
         * @step 0.1
         */
        max: number;
      }
      class RGBObjectDto {
        constructor(rgb?: Base.ColorRGB);
        /**
         * Red value component
         * @default undefined
         */
        rgb: Base.ColorRGB;
      }
    }
    declare namespace Dates {
      class DateDto {
        constructor(date?: Date);
        /**
         * The date
         * @default undefined
         */
        date: Date;
      }
      class DateStringDto {
        constructor(dateString?: string);
        /**
         * The date string
         * @default undefined
         */
        dateString: string;
      }
      class DateSecondsDto {
        constructor(date?: Date, seconds?: number);
        /**
         * The date to update the seconds for
         * @default undefined
         */
        date: Date;
        /**
         * The seconds of the date
         * @default 30
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        seconds: number;
      }
      class DateDayDto {
        constructor(date?: Date, day?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The day of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        day: number;
      }
      class DateYearDto {
        constructor(date?: Date, year?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The year of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        year: number;
      }
      class DateMonthDto {
        constructor(date?: Date, month?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The month of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        month: number;
      }
      class DateHoursDto {
        constructor(date?: Date, hours?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The hours of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        hours: number;
      }
      class DateMinutesDto {
        constructor(date?: Date, minutes?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The minutes of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minutes: number;
      }
      class DateMillisecondsDto {
        constructor(date?: Date, milliseconds?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The milliseconds of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        milliseconds: number;
      }
      class DateTimeDto {
        constructor(date?: Date, time?: number);
        /**
         * The date
         * @default undefined
         */
        date: Date;
        /**
         * The time of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        time: number;
      }
      class CreateFromUnixTimeStampDto {
        constructor(unixTimeStamp?: number);
        /**
         * The unix time stamp
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        unixTimeStamp: number;
      }
      class CreateDateDto {
        constructor(
          year?: number,
          month?: number,
          day?: number,
          hours?: number,
          minutes?: number,
          seconds?: number,
          milliseconds?: number
        );
        /**
         * The year of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        year: number;
        /**
         * The month of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        month: number;
        /**
         * The day of the month
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        day: number;
        /**
         * The hours of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        hours: number;
        /**
         * The minutes of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        minutes: number;
        /**
         * The seconds of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        seconds: number;
        /**
         * The milliseconds of the date
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        milliseconds: number;
      }
    }
    declare namespace IO {
      /**
       * Line segment defined by start and end points
       */
      class DxfLineSegmentDto {
        constructor(start?: Base.Point2, end?: Base.Point2);
        /**
         * Start point of the line
         * @default undefined
         */
        start: Base.Point2;
        /**
         * End point of the line
         * @default undefined
         */
        end: Base.Point2;
      }
      /**
       * Arc segment defined by center, radius, and start/end angles in degrees
       */
      class DxfArcSegmentDto {
        constructor(
          center?: Base.Point2,
          radius?: number,
          startAngle?: number,
          endAngle?: number
        );
        /**
         * Center point of the arc
         * @default undefined
         */
        center: Base.Point2;
        /**
         * Radius of the arc
         * @default undefined
         */
        radius: number;
        /**
         * Start angle in degrees
         * @default undefined
         */
        startAngle: number;
        /**
         * End angle in degrees (counter-clockwise from start angle)
         * @default undefined
         */
        endAngle: number;
      }
      /**
       * Circle defined by center and radius
       */
      class DxfCircleSegmentDto {
        constructor(center?: Base.Point2, radius?: number);
        /**
         * Center point of the circle
         * @default undefined
         */
        center: Base.Point2;
        /**
         * Radius of the circle
         * @default undefined
         */
        radius: number;
      }
      /**
       * Polyline segment defined by multiple points
       * Can include bulge values to create arc segments between vertices
       */
      class DxfPolylineSegmentDto {
        constructor(
          points?: Base.Point2[],
          closed?: boolean,
          bulges?: number[]
        );
        /**
         * Points defining the polyline vertices
         * @default undefined
         */
        points: Base.Point2[];
        /**
         * Whether the polyline is closed
         * @default false
         */
        closed?: boolean;
        /**
         * Bulge values for each vertex (optional)
         * Bulge = tan(angle/4) where angle is the arc angle in radians
         * Positive = counterclockwise, Negative = clockwise
         * 0 = straight line segment
         * Array length should match points length (or be undefined for all straight segments)
         * @default undefined
         */
        bulges?: number[];
      }
      /**
       * Spline/B-spline segment defined by control points and degree
       */
      class DxfSplineSegmentDto {
        constructor(
          controlPoints?: Base.Point2[],
          degree?: number,
          closed?: boolean
        );
        /**
         * Control points defining the spline
         * @default undefined
         */
        controlPoints: Base.Point2[];
        /**
         * Degree of the spline (typically 2 or 3)
         * @default 3
         */
        degree?: number;
        /**
         * Whether the spline is closed
         * @default false
         */
        closed?: boolean;
      }
      /**
       * A path can contain multiple segments of different types (lines, arcs, polylines, circles, splines)
       * Similar to OCCT wires that can combine different edge types
       */
      class DxfPathDto {
        constructor(
          segments?: (
            | DxfLineSegmentDto
            | DxfArcSegmentDto
            | DxfCircleSegmentDto
            | DxfPolylineSegmentDto
            | DxfSplineSegmentDto
          )[]
        );
        /**
         * Array of segments that make up this path
         * Can include lines, arcs, circles, polylines, and splines
         * @default undefined
         */
        segments: (
          | DxfLineSegmentDto
          | DxfArcSegmentDto
          | DxfCircleSegmentDto
          | DxfPolylineSegmentDto
          | DxfSplineSegmentDto
        )[];
      }
      /**
       * A part containing multiple paths on the same layer with the same color
       */
      class DxfPathsPartDto {
        constructor(layer?: string, color?: Base.Color, paths?: DxfPathDto[]);
        /**
         * Layer name for all paths in this part
         * @default Default
         */
        layer: string;
        /**
         * Color for all paths in this part
         * @default #000000
         */
        color: Base.Color;
        /**
         * Array of paths, each containing multiple segments
         * @default undefined
         */
        paths: DxfPathDto[];
      }
      /**
       * Main DXF model containing all path parts
       */
      class DxfModelDto {
        constructor(
          dxfPathsParts?: DxfPathsPartDto[],
          colorFormat?: "aci" | "truecolor",
          acadVersion?: "AC1009" | "AC1015"
        );
        /**
         * Array of path parts, each containing paths with segments
         * @default undefined
         */
        dxfPathsParts: DxfPathsPartDto[];
        /**
         * Color format to use in the DXF file
         * - "aci": AutoCAD Color Index (1-255) - Better compatibility with older CAD software like Design CAD 3D Max
         * - "truecolor": 24-bit RGB true color - Full color spectrum, requires newer CAD software
         * @default aci
         */
        colorFormat?: "aci" | "truecolor";
        /**
         * AutoCAD version format for DXF file
         * - "AC1009": AutoCAD R12/R11 - Maximum compatibility with older CAD software (e.g., Design CAD 3D Max)
         * - "AC1015": AutoCAD 2000 - Modern format with extended features
         * @default AC1009
         */
        acadVersion?: "AC1009" | "AC1015";
      }
    }
    declare namespace Line {
      class LinePointsDto {
        /**
         * Provide options without default values
         */
        constructor(start?: Base.Point3, end?: Base.Point3);
        /**
         * Start point
         * @default undefined
         */
        start?: Base.Point3;
        /**
         * End point
         * @default undefined
         */
        end?: Base.Point3;
      }
      class LineStartEndPointsDto {
        /**
         * Provide options without default values
         */
        constructor(startPoints?: Base.Point3[], endPoints?: Base.Point3[]);
        /**
         * Start points
         * @default undefined
         */
        startPoints: Base.Point3[];
        /**
         * End points
         * @default undefined
         */
        endPoints: Base.Point3[];
      }
      class DrawLineDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          line?: LinePointsDto,
          opacity?: number,
          colours?: string | string[],
          size?: number,
          updatable?: boolean,
          lineMesh?: T
        );
        /**
         * Line
         * @default undefined
         */
        line?: LinePointsDto;
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity?: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours?: string | string[];
        /**
         * Width of the line
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size?: number;
        /**
         * Indicates wether the position of this line will change in time
         * @default false
         */
        updatable?: boolean;
        /**
         * Line mesh variable in case it already exists and needs updating
         * @default undefined
         */
        lineMesh?: T;
      }
      class DrawLinesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          lines?: LinePointsDto[],
          opacity?: number,
          colours?: string | string[],
          size?: number,
          updatable?: boolean,
          linesMesh?: T
        );
        /**
         * Lines
         * @default undefined
         */
        lines?: LinePointsDto[];
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity?: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours?: string | string[];
        /**
         * Width of the line
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size?: number;
        /**
         * Indicates wether the position of these lines will change in time
         * @default false
         */
        updatable?: boolean;
        /**
         * Line mesh variable in case it already exists and needs updating
         * @default undefined
         */
        linesMesh?: T;
      }
      class PointsLinesDto {
        constructor(points?: Base.Point3[]);
        /**
         * Points
         * @default undefined
         */
        points?: Base.Point3[];
      }
      class LineDto {
        constructor(line?: LinePointsDto);
        /**
         * Line to convert
         * @default undefined
         */
        line?: LinePointsDto;
      }
      class SegmentDto {
        constructor(segment?: Base.Segment3);
        /**
         * Segment
         * @default undefined
         */
        segment?: Base.Segment3;
      }
      class SegmentsDto {
        constructor(segments?: Base.Segment3[]);
        /**
         * Segments
         * @default undefined
         */
        segments?: Base.Segment3[];
      }
      class LinesDto {
        constructor(lines?: LinePointsDto[]);
        /**
         * Lines to convert
         * @default undefined
         */
        lines?: LinePointsDto[];
      }
      class LineLineIntersectionDto {
        constructor(
          line1?: LinePointsDto,
          line2?: LinePointsDto,
          tolerance?: number
        );
        /**
         * First line
         * @default undefined
         */
        line1?: LinePointsDto;
        /**
         * Second line
         * @default undefined
         */
        line2?: LinePointsDto;
        /**
         * Set to false if you want to check for infinite lines
         * @default true
         */
        checkSegmentsOnly?: boolean;
        /**
         * Tolerance for intersection
         * @default 0.01
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        tolerance?: number;
      }
      class PointOnLineDto {
        constructor(line?: LinePointsDto, param?: number);
        /**
         * Line to get point on
         * @default undefined
         */
        line?: LinePointsDto;
        /**
         * Param to use for point on line
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        param?: number;
      }
      class TransformLineDto {
        constructor(
          line?: LinePointsDto,
          transformation?: Base.TransformMatrixes
        );
        /**
         * Line to transform
         * @default undefined
         */
        line?: LinePointsDto;
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation?: Base.TransformMatrixes;
      }
      class TransformsLinesDto {
        constructor(
          lines?: LinePointsDto[],
          transformation?: Base.TransformMatrixes[]
        );
        /**
         * Lines to transform
         * @default undefined
         */
        lines?: LinePointsDto[];
        /**
         * Transformations matrix or a list of transformations matrixes
         * @default undefined
         */
        transformation?: Base.TransformMatrixes[];
      }
      class TransformLinesDto {
        constructor(
          lines?: LinePointsDto[],
          transformation?: Base.TransformMatrixes
        );
        /**
         * Lines to transform
         * @default undefined
         */
        lines?: LinePointsDto[];
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation?: Base.TransformMatrixes;
      }
    }
    declare namespace Lists {
      enum firstLastEnum {
        first = "first",
        last = "last",
      }
      class ListItemDto<T> {
        constructor(list?: T[], index?: number, clone?: boolean);
        /**
         * The list to interrogate
         * @default undefined
         */
        list: T[];
        /**
         * Index of the item in the list - 0 means first.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        index: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class SubListDto<T> {
        constructor(
          list?: T[],
          indexStart?: number,
          indexEnd?: number,
          clone?: boolean
        );
        /**
         * The list to split into a sublist
         * @default undefined
         */
        list: T[];
        /**
         * Index from which to start the sublist - 0 means first.
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        indexStart: number;
        /**
         * Index to which to end the sublist - 0 means first.
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        indexEnd: number;
        /**
         * Tries to clone the data in the component, sometimes it may not be possible if structure is circular
         * @default true
         */
        clone?: boolean;
      }
      class ListCloneDto<T> {
        constructor(list?: T[], clone?: boolean);
        /**
         * The list to interrogate
         * @default undefined
         */
        list: T[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RepeatInPatternDto<T> {
        constructor(list?: T[]);
        /**
         * The list to interrogate
         * @default undefined
         */
        list: T[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
        /**
         * The limit of the length of the list
         * @default 100
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        lengthLimit: number;
      }
      class SortDto<T> {
        constructor(list?: T[], clone?: boolean, orderAsc?: boolean);
        /**
         * The list to interrogate
         * @default undefined
         */
        list: T[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
        /**
         * If true, the list will be sorted in ascending order, otherwise in descending order
         * @default true
         */
        orderAsc: boolean;
      }
      class SortJsonDto<T> {
        constructor(list?: T[], clone?: boolean, orderAsc?: boolean);
        /**
         * The list to interrogate
         * @default undefined
         */
        list: T[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
        /**
         * If true, the list will be sorted in ascending order, otherwise in descending order
         * @default true
         */
        orderAsc: boolean;
        /**
         * The property to sort by
         * @default propName
         */
        property: string;
      }
      class ListDto<T> {
        constructor(list?: T[]);
        /**
         * The list
         * @default undefined
         */
        list: T[];
      }
      class GroupListDto<T> {
        constructor(list?: T[], nrElements?: number, keepRemainder?: boolean);
        /**
         * The list of elements to group together
         * @default undefined
         */
        list: T[];
        /**
         * The number of elements in each group
         * @default 2
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrElements: number;
        /**
         * If true, the remainder of the list will be added as a separate group
         * @default false
         */
        keepRemainder: boolean;
      }
      class MultiplyItemDto<T> {
        constructor(item?: T, times?: number);
        /**
         * The item to multiply
         * @default undefined
         */
        item: T;
        /**
         * Times to multiply
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        times: number;
      }
      class AddItemAtIndexDto<T> {
        constructor(list?: T[], item?: T, index?: number, clone?: boolean);
        /**
         * The list to which item needs to be added
         * @default undefined
         */
        list: T[];
        /**
         * The item to add
         * @default undefined
         */
        item: T;
        /**
         * The index to add the item at
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        index: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class AddItemAtIndexesDto<T> {
        constructor(list?: T[], item?: T, indexes?: number[], clone?: boolean);
        /**
         * The list to which item needs to be added
         * @default undefined
         */
        list: T[];
        /**
         * The item to add
         * @default undefined
         */
        item: T;
        /**
         * The index to add the item at
         * @default [0]
         */
        indexes: number[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class AddItemsAtIndexesDto<T> {
        constructor(
          list?: T[],
          items?: T[],
          indexes?: number[],
          clone?: boolean
        );
        /**
         * The list to which item needs to be added
         * @default undefined
         */
        list: T[];
        /**
         * The item to add
         * @default undefined
         */
        items: T[];
        /**
         * The index to add the item at
         * @default [0]
         */
        indexes: number[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RemoveItemAtIndexDto<T> {
        constructor(list?: T[], index?: number, clone?: boolean);
        /**
         * The list from which item needs to be removed
         * @default undefined
         */
        list: T[];
        /**
         * The index to on which remove item
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        index: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RemoveItemsAtIndexesDto<T> {
        constructor(list?: T[], indexes?: number[], clone?: boolean);
        /**
         * The list from which item needs to be removed
         * @default undefined
         */
        list: T[];
        /**
         * The indexes that should be removed
         * @default undefined
         */
        indexes: number[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RemoveNthItemDto<T> {
        constructor(list?: T[], nth?: number, offset?: number, clone?: boolean);
        /**
         * The list from which item needs to be removed
         * @default undefined
         */
        list: T[];
        /**
         * The nth item to remove
         * @default 2
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nth: number;
        /**
         * The offset from which to start counting
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        offset: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RandomThresholdDto<T> {
        constructor(list?: T[], threshold?: number, clone?: boolean);
        /**
         * The list from which item needs to be updated
         * @default undefined
         */
        list: T[];
        /**
         * Threshold for items
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 1
         */
        threshold: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RemoveDuplicatesDto<T> {
        constructor(list?: T[], clone?: boolean);
        /**
         * The list from which item needs to be removed
         * @default undefined
         */
        list: T[];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class RemoveDuplicatesToleranceDto<T> {
        constructor(list?: T[], clone?: boolean, tolerance?: number);
        /**
         * The list from which item needs to be removed
         * @default undefined
         */
        list: T[];
        /**
         * The tolerance to apply
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class GetByPatternDto<T> {
        constructor(list?: T[], pattern?: boolean[]);
        /**
         * The list from which we need to get an item
         * @default undefined
         */
        list: T[];
        /**
         * The list of booleans to be used as a pattern (true means get, false means skip)
         * @default [true, true, false]
         */
        pattern: boolean[];
      }
      class GetNthItemDto<T> {
        constructor(list?: T[], nth?: number, offset?: number, clone?: boolean);
        /**
         * The list from which we need to get an item
         * @default undefined
         */
        list: T[];
        /**
         * The nth item to get
         * @default 2
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nth: number;
        /**
         * The offset from which to start counting
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        offset: number;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class GetLongestListLength<T> {
        constructor(lists?: T[]);
        /**
         * The list from which we need to get an item
         * @default undefined
         */
        lists: T[];
      }
      class MergeElementsOfLists<T> {
        constructor(lists?: T[], level?: number);
        /**
         * The list from which we need to get an item
         * @default undefined
         */
        lists: T[];
        /**
         * The level on which to merge the elements. 0 means first level
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        level: number;
      }
      class AddItemDto<T> {
        constructor(list?: T[], item?: T, clone?: boolean);
        /**
         * The list to which item needs to be added
         * @default undefined
         */
        list: T[];
        /**
         * The item to add
         * @default undefined
         */
        item: T;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class AddItemFirstLastDto<T> {
        constructor(
          list?: T[],
          item?: T,
          position?: firstLastEnum,
          clone?: boolean
        );
        /**
         * The list to which item needs to be added
         * @default undefined
         */
        list: T[];
        /**
         * The item to add
         * @default undefined
         */
        item: T;
        /**
         * The option if the item needs to be added at the beginning or the end of the list
         * @default last
         */
        position: firstLastEnum;
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class ConcatenateDto<T> {
        constructor(lists?: T[][], clone?: boolean);
        /**
         * The lists to concatenate
         * @default undefined
         */
        lists: T[][];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
      class IncludesDto<T> {
        constructor(list?: T[], item?: T);
        /**
         * The list to check
         * @default undefined
         */
        list: T[];
        /**
         * The item to look for
         * @default undefined
         */
        item: T;
      }
      class InterleaveDto<T> {
        constructor(lists?: T[][], clone?: boolean);
        /**
         * The lists to interleave
         * @default undefined
         */
        lists: T[][];
        /**
         * Tries to make structured clone of the incoming list data in the component, sometimes it may not be possible due to circular structures or other types of error
         * @default true
         */
        clone?: boolean;
      }
    }
    declare namespace Logic {
      enum BooleanOperatorsEnum {
        less = "<",
        lessOrEqual = "<=",
        greater = ">",
        greaterOrEqual = ">=",
        tripleEqual = "===",
        tripleNotEqual = "!==",
        equal = "==",
        notEqual = "!=",
      }
      class ComparisonDto<T> {
        constructor(first?: T, second?: T, operator?: BooleanOperatorsEnum);
        /**
         * First item
         * @default undefined
         */
        first: T;
        /**
         * Second item
         * @default undefined
         */
        second: T;
        /**
         * Operator
         * @default less
         */
        operator: BooleanOperatorsEnum;
      }
      class BooleanDto {
        constructor(boolean?: boolean);
        /**
         * Boolean value
         * @default false
         */
        boolean: boolean;
      }
      class BooleanListDto {
        constructor(booleans?: boolean);
        /**
         * Boolean value
         * @default undefined
         */
        booleans: any;
      }
      class ValueGateDto<T> {
        constructor(value?: T, boolean?: boolean);
        /**
         * Value to transmit when gate will be released. When value is not released we will transmit undefined value
         * @default undefined
         */
        value: T;
        /**
         * Boolean value to release the gate
         * @default false
         */
        boolean: boolean;
      }
      class TwoValueGateDto<T, U> {
        constructor(value1?: T, value2?: U);
        /**
         * First value to check
         * @default undefined
         * @optional true
         */
        value1?: T;
        /**
         * Second value to check
         * @default undefined
         * @optional true
         */
        value2?: U;
      }
      class RandomBooleansDto {
        constructor(length?: number);
        /**
         * Length of the list
         * @default 10
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        length: number;
        /**
         * Threshold for true value between 0 and 1. The closer the value is to 1 the more true values there will be in the list.
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        trueThreshold: number;
      }
      class TwoThresholdRandomGradientDto {
        /**
         * Numbers to remap to bools
         * @default undefined
         */
        numbers: number[];
        /**
         * Threshold for the numeric value until which the output will be true
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        thresholdTotalTrue: number;
        /**
         * Threshold for the numeric value until which the output will be true
         * @default 2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        thresholdTotalFalse: number;
        /**
         * Number of levels to go through in between thresholds for gradient
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrLevels: number;
      }
      class ThresholdBooleanListDto {
        /**
         * Numbers to remap to bools based on threshold
         * @default undefined
         */
        numbers: number[];
        /**
         * Threshold for the numeric value until which the output will be true.
         * If number in the list is larger than this threshold it will become false if inverse stays false.
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        threshold: number;
        /**
         * True values become false and false values become true
         * @default false
         */
        inverse: boolean;
      }
      class ThresholdGapsBooleanListDto {
        /**
         * Numbers to remap to bools based on threshold
         * @default undefined
         */
        numbers: number[];
        /**
         * 2D arrays representing gaps of the thresholds on which numbers should be flipped from false to true if inverse is false.
         * @default undefined
         */
        gapThresholds: Base.Vector2[];
        /**
         * True values become false and false values become true
         * @default false
         */
        inverse: boolean;
      }
    }
    declare namespace Math {
      enum mathTwoNrOperatorEnum {
        add = "add",
        subtract = "subtract",
        multiply = "multiply",
        divide = "divide",
        power = "power",
        modulus = "modulus",
      }
      enum mathOneNrOperatorEnum {
        absolute = "absolute",
        negate = "negate",
        ln = "ln",
        log10 = "log10",
        tenPow = "tenPow",
        round = "round",
        floor = "floor",
        ceil = "ceil",
        sqrt = "sqrt",
        sin = "sin",
        cos = "cos",
        tan = "tan",
        asin = "asin",
        acos = "acos",
        atan = "atan",
        log = "log",
        exp = "exp",
        radToDeg = "radToDeg",
        degToRad = "degToRad",
      }
      enum easeEnum {
        easeInSine = "easeInSine",
        easeOutSine = "easeOutSine",
        easeInOutSine = "easeInOutSine",
        easeInQuad = "easeInQuad",
        easeOutQuad = "easeOutQuad",
        easeInOutQuad = "easeInOutQuad",
        easeInCubic = "easeInCubic",
        easeOutCubic = "easeOutCubic",
        easeInOutCubic = "easeInOutCubic",
        easeInQuart = "easeInQuart",
        easeOutQuart = "easeOutQuart",
        easeInOutQuart = "easeInOutQuart",
        easeInQuint = "easeInQuint",
        easeOutQuint = "easeOutQuint",
        easeInOutQuint = "easeInOutQuint",
        easeInExpo = "easeInExpo",
        easeOutExpo = "easeOutExpo",
        easeInOutExpo = "easeInOutExpo",
        easeInCirc = "easeInCirc",
        easeOutCirc = "easeOutCirc",
        easeInOutCirc = "easeInOutCirc",
        easeInElastic = "easeInElastic",
        easeOutElastic = "easeOutElastic",
        easeInOutElastic = "easeInOutElastic",
        easeInBack = "easeInBack",
        easeOutBack = "easeOutBack",
        easeInOutBack = "easeInOutBack",
        easeInBounce = "easeInBounce",
        easeOutBounce = "easeOutBounce",
        easeInOutBounce = "easeInOutBounce",
      }
      class ModulusDto {
        constructor(number?: number, modulus?: number);
        /**
         * Number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * Modulus
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        modulus: number;
      }
      class NumberDto {
        constructor(number?: number);
        /**
         * Number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
      }
      class EaseDto {
        constructor(x?: number);
        /**
         * X value param between 0-1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        x: number;
        /**
         * Minimum value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        min: number;
        /**
         * Maximum value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        max: number;
        /**
         * Ease function
         * @default easeInSine
         */
        ease: easeEnum;
      }
      class RoundToDecimalsDto {
        constructor(number?: number, decimalPlaces?: number);
        /**
         * Number to round
         * @default 1.123456
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * Number of decimal places
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        decimalPlaces: number;
      }
      class ActionOnTwoNumbersDto {
        constructor(
          first?: number,
          second?: number,
          operation?: mathTwoNrOperatorEnum
        );
        /**
         * First number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        first: number;
        /**
         * Second number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        second: number;
        /**
         * Point
         * @default add
         */
        operation: mathTwoNrOperatorEnum;
      }
      class TwoNumbersDto {
        constructor(first?: number, second?: number);
        /**
         * First number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        first: number;
        /**
         * Second number
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        second: number;
      }
      class ActionOnOneNumberDto {
        constructor(number?: number, operation?: mathOneNrOperatorEnum);
        /**
         * First number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * Point
         * @default absolute
         */
        operation: mathOneNrOperatorEnum;
      }
      class RemapNumberDto {
        constructor(
          number?: number,
          fromLow?: number,
          fromHigh?: number,
          toLow?: number,
          toHigh?: number
        );
        /**
         * Number to remap
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * First number range min
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        fromLow: number;
        /**
         * Map to range min
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        fromHigh: number;
        /**
         * First number range max
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        toLow: number;
        /**
         * Map to range max
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        toHigh: number;
      }
      class RandomNumberDto {
        constructor(low?: number, high?: number);
        /**
         * Low range of random value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        low: number;
        /**
         * High range of random value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        high: number;
      }
      class RandomNumbersDto {
        constructor(low?: number, high?: number, count?: number);
        /**
         * Low range of random value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        low: number;
        /**
         * High range of random value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        high: number;
        /**
         * Number of produced random values
         * @default 10
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        count: number;
      }
      class ToFixedDto {
        constructor(number?: number, decimalPlaces?: number);
        /**
         * Number to round
         * @default undefined
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * Number of decimal places
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        decimalPlaces: number;
      }
      class ClampDto {
        constructor(number?: number, min?: number, max?: number);
        /**
         * Number to clamp
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * Minimum value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        min: number;
        /**
         * Maximum value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        max: number;
      }
      class LerpDto {
        constructor(start?: number, end?: number, t?: number);
        /**
         * Start value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        start: number;
        /**
         * End value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        end: number;
        /**
         * Interpolation value (0-1)
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.01
         */
        t: number;
      }
      class InverseLerpDto {
        constructor(start?: number, end?: number, value?: number);
        /**
         * Start value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        start: number;
        /**
         * End value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        end: number;
        /**
         * Value to find t for
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        value: number;
      }
      class WrapDto {
        constructor(number?: number, min?: number, max?: number);
        /**
         * Number to wrap
         * @default 1.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        number: number;
        /**
         * Minimum value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        min: number;
        /**
         * Maximum value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        max: number;
      }
      class PingPongDto {
        constructor(t?: number, length?: number);
        /**
         * Time value
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        t: number;
        /**
         * Length of ping pong
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        length: number;
      }
      class MoveTowardsDto {
        constructor(current?: number, target?: number, maxDelta?: number);
        /**
         * Current value
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        current: number;
        /**
         * Target value
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        target: number;
        /**
         * Maximum change amount
         * @default 0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.01
         */
        maxDelta: number;
      }
    }
    declare namespace Mesh {
      class SignedDistanceFromPlaneToPointDto {
        constructor(point?: Base.Point3, plane?: Base.TrianglePlane3);
        /**
         * Point from which to find the distance
         * @default undefined
         */
        point?: Base.Point3;
        /**
         * Triangle plane to which the distance is calculated
         * @default undefined
         */
        plane?: Base.TrianglePlane3;
      }
      class TriangleDto {
        constructor(triangle?: Base.Triangle3);
        /**
         * Triangle to be used
         * @default undefined
         */
        triangle?: Base.Triangle3;
      }
      class TriangleToleranceDto {
        constructor(triangle?: Base.Triangle3);
        /**
         * Triangle to be used
         * @default undefined
         */
        triangle?: Base.Triangle3;
        /**
         * Tolerance for the calculation
         * @default 1e-7
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance?: number;
      }
      class TriangleTriangleToleranceDto {
        constructor(
          triangle1?: Base.Triangle3,
          triangle2?: Base.Triangle3,
          tolerance?: number
        );
        /**
         * First triangle
         * @default undefined
         */
        triangle1?: Base.Triangle3;
        /**
         * Second triangle
         * @default undefined
         */
        triangle2?: Base.Triangle3;
        /**
         * Tolerance for the calculation
         * @default 1e-7
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance?: number;
      }
      class MeshMeshToleranceDto {
        constructor(mesh1?: Base.Mesh3, mesh2?: Base.Mesh3, tolerance?: number);
        /**
         * First mesh
         * @default undefined
         */
        mesh1?: Base.Mesh3;
        /**
         * Second mesh
         * @default undefined
         */
        mesh2?: Base.Mesh3;
        /**
         * Tolerance for the calculation
         * @default 1e-7
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance?: number;
      }
    }
    declare namespace Point {
      class PointDto {
        constructor(point?: Base.Point3);
        /**
         * Point
         * @default undefined
         */
        point: Base.Point3;
      }
      class PointXYZDto {
        constructor(x?: number, y?: number, z?: number);
        /**
         * Point
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        x: number;
        /**
         * Point
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        y: number;
        /**
         * Point
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        z: number;
      }
      class PointXYDto {
        constructor(x?: number, y?: number);
        /**
         * Point
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        x: number;
        /**
         * Point
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        y: number;
      }
      class PointsDto {
        constructor(points?: Base.Point3[]);
        /**
         * Points
         * @default undefined
         */
        points: Base.Point3[];
      }
      class TwoPointsDto {
        constructor(point1?: Base.Point3, point2?: Base.Point3);
        /**
         * Point 1
         * @default undefined
         */
        point1: Base.Point3;
        /**
         * Point 2
         * @default undefined
         */
        point2: Base.Point3;
      }
      class DrawPointDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          point?: Base.Point3,
          opacity?: number,
          size?: number,
          colours?: string | string[],
          updatable?: boolean,
          pointMesh?: T
        );
        /**
         * Point
         * @default undefined
         */
        point: Base.Point3;
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * Size of the point
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours: string | string[];
        /**
         * Indicates wether the position of this point will change in time
         * @default false
         */
        updatable: boolean;
        /**
         * Point mesh variable in case it already exists and needs updating
         * @default undefined
         */
        pointMesh?: T;
      }
      class DrawPointsDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          points?: Base.Point3[],
          opacity?: number,
          size?: number,
          colours?: string | string[],
          updatable?: boolean,
          pointsMesh?: T
        );
        /**
         * Point
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity: number;
        /**
         * Size of the points
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size: number;
        /**
         * Hex colour string or collection of strings
         * @default #444444
         */
        colours: string | string[];
        /**
         * Indicates wether the position of this point will change in time
         * @default false
         */
        updatable: boolean;
        /**
         * Points mesh variable in case it already exists and needs updating
         * @default undefined
         */
        pointsMesh?: T;
      }
      class TransformPointDto {
        constructor(
          point?: Base.Point3,
          transformation?: Base.TransformMatrixes
        );
        /**
         * Point to transform
         * @default undefined
         */
        point: Base.Point3;
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation: Base.TransformMatrixes;
      }
      class TransformPointsDto {
        constructor(
          points?: Base.Point3[],
          transformation?: Base.TransformMatrixes
        );
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation: Base.TransformMatrixes;
      }
      class TranslatePointsWithVectorsDto {
        constructor(points?: Base.Point3[], translations?: Base.Vector3[]);
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Translation vectors for each point
         * @default undefined
         */
        translations: Base.Vector3[];
      }
      class TranslatePointsDto {
        constructor(points?: Base.Point3[], translation?: Base.Vector3);
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Translation vector with x, y and z values
         * @default undefined
         */
        translation: Base.Vector3;
      }
      class TranslateXYZPointsDto {
        constructor(points?: Base.Point3[], x?: number, y?: number, z?: number);
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * X vector value
         * @default 0
         */
        x: number;
        /**
         * Y vector value
         * @default 1
         */
        y: number;
        /**
         * Z vector value
         * @default 0
         */
        z: number;
      }
      class ScalePointsCenterXYZDto {
        constructor(
          points?: Base.Point3[],
          center?: Base.Point3,
          scaleXyz?: Base.Vector3
        );
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * The center from which the scaling is applied
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Scaling factors for each axis [1, 2, 1] means that Y axis will be scaled 200% and both x and z axis will remain on 100%
         * @default [1, 1, 1]
         */
        scaleXyz: Base.Vector3;
      }
      class StretchPointsDirFromCenterDto {
        constructor(
          points?: Base.Point3[],
          center?: Base.Point3,
          direction?: Base.Vector3,
          scale?: number
        );
        /**
         * Points to transform
         * @default undefined
         */
        points?: Base.Point3[];
        /**
         * The center from which the scaling is applied
         * @default [0, 0, 0]
         */
        center?: Base.Point3;
        /**
         * Stretch direction vector
         * @default [0, 0, 1]
         */
        direction?: Base.Vector3;
        /**
         * The scale factor to apply along the direction vector. 1.0 means no change.
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scale?: number;
      }
      class RotatePointsCenterAxisDto {
        constructor(
          points?: Base.Point3[],
          angle?: number,
          axis?: Base.Vector3,
          center?: Base.Point3
        );
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Angle of rotation in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
        /**
         * Axis vector for rotation
         * @default [0, 1, 0]
         */
        axis: Base.Vector3;
        /**
         * The center from which the axis is pointing
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class TransformsForPointsDto {
        constructor(
          points?: Base.Point3[],
          transformation?: Base.TransformMatrixes[]
        );
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Transformations that have to match nr of points
         * @default undefined
         */
        transformation: Base.TransformMatrixes[];
      }
      class ThreePointsNormalDto {
        constructor(
          point1?: Base.Point3,
          point2?: Base.Point3,
          point3?: Base.Point3,
          reverseNormal?: boolean
        );
        /**
         * Point 1
         * @default undefined
         */
        point1: Base.Point3;
        /**
         * Point 2
         * @default undefined
         */
        point2: Base.Point3;
        /**
         * Point 3
         * @default undefined
         */
        point3: Base.Point3;
        /**
         * Reverse normal direction
         * @default false
         */
        reverseNormal: boolean;
      }
      class ThreePointsToleranceDto {
        constructor(
          start?: Base.Point3,
          center?: Base.Point3,
          end?: Base.Point3,
          tolerance?: number
        );
        /**
         * Start point
         * @default undefined
         */
        start?: Base.Point3;
        /**
         * Center point
         * @default undefined
         */
        center?: Base.Point3;
        /**
         * End point
         * @default undefined
         */
        end?: Base.Point3;
        /**
         * Tolerance for the calculation
         * @default 1e-7
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance: number;
      }
      class PointsMaxFilletsHalfLineDto {
        constructor(
          points?: Base.Point3[],
          checkLastWithFirst?: boolean,
          tolerance?: number
        );
        /**
         * Points to transform
         * @default undefined
         */
        points?: Base.Point3[];
        /**
         * Check first and last point for duplicates
         * @default false
         */
        checkLastWithFirst?: boolean;
        /**
         * Tolerance for the calculation
         * @default 1e-7
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance?: number;
      }
      class RemoveConsecutiveDuplicatesDto {
        constructor(
          points?: Base.Point3[],
          tolerance?: number,
          checkFirstAndLast?: boolean
        );
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Tolerance for removing duplicates
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance: number;
        /**
         * Check first and last point for duplicates
         */
        checkFirstAndLast: boolean;
      }
      class ClosestPointFromPointsDto {
        constructor(points?: Base.Point3[], point?: Base.Point3);
        /**
         * Points to transform
         * @default undefined
         */
        points: Base.Point3[];
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        point: Base.Point3;
      }
      class TwoPointsToleranceDto {
        constructor(
          point1?: Base.Point3,
          point2?: Base.Point3,
          tolerance?: number
        );
        /**
         * First point to compare
         * @default undefined
         */
        point1?: Base.Point3;
        /**
         * Second point to compare
         * @default undefined
         */
        point2?: Base.Point3;
        /**
         * Tolerance for the calculation
         * @default 1e-7
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-7
         */
        tolerance?: number;
      }
      class StartEndPointsDto {
        constructor(startPoint?: Base.Point3, endPoint?: Base.Point3);
        /**
         * Start point
         * @default undefined
         */
        startPoint: Base.Point3;
        /**
         * End point
         * @default undefined
         */
        endPoint: Base.Point3;
      }
      class StartEndPointsListDto {
        constructor(startPoint?: Base.Point3, endPoints?: Base.Point3[]);
        /**
         * Start point
         * @default undefined
         */
        startPoint: Base.Point3;
        /**
         * End point
         * @default undefined
         */
        endPoints: Base.Point3[];
      }
      class MultiplyPointDto {
        constructor(point?: Base.Point3, amountOfPoints?: number);
        /**
         * Point for multiplication
         * @default undefined
         */
        point: Base.Point3;
        /**
         * Number of points to create in the list
         * @default undefined
         */
        amountOfPoints: number;
      }
      class SpiralDto {
        constructor(
          radius?: number,
          numberPoints?: number,
          widening?: number,
          factor?: number,
          phi?: number
        );
        /**
         * Identifies phi angle
         * @default 0.9
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        phi: number;
        /**
         * Identifies how many points will be created
         * @default 200
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        numberPoints: number;
        /**
         * Widening factor of the spiral
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        widening: number;
        /**
         * Radius of the spiral
         * @default 6
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Factor of the spiral
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        factor: number;
      }
      class HexGridScaledToFitDto {
        constructor(
          wdith?: number,
          height?: number,
          nrHexagonsU?: number,
          nrHexagonsV?: number,
          centerGrid?: boolean,
          pointsOnGround?: boolean
        );
        /** Total desired width for the grid area. The hexagon size will be derived from this and nrHexagonsU.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        width?: number;
        /** Total desired height for the grid area. Note: due to hexagon geometry, the actual grid height might differ slightly if maintaining regular hexagons based on width.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height?: number;
        /** Number of hexagons desired in width.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsInWidth?: number;
        /** Number of hexagons desired in height.
         * @default 10
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsInHeight?: number;
        /** If true, the hexagons will be oriented with their flat sides facing up and down.
         * @default false
         */
        flatTop?: boolean;
        /** If true, shift the entire grid up by half hex height.
         * @default false
         */
        extendTop?: boolean;
        /** If true, shift the entire grid down by half hex height.
         * @default false
         */
        extendBottom?: boolean;
        /** If true, shift the entire grid left by half hex width.
         * @default false
         */
        extendLeft?: boolean;
        /** If true, shift the entire grid right by half hex width.
         * @default false
         */
        extendRight?: boolean;
        /** If true, the grid center (based on totalWidth/totalHeight) will be at [0,0,0].
         * @default false
         */
        centerGrid?: boolean;
        /** If true, swaps Y and Z coordinates and sets Y to 0, placing points on the XZ ground plane.
         * @default false
         */
        pointsOnGround?: boolean;
      }
      class HexGridCentersDto {
        constructor(
          nrHexagonsX?: number,
          nrHexagonsY?: number,
          radiusHexagon?: number,
          orientOnCenter?: boolean,
          pointsOnGround?: boolean
        );
        /**
         * Number of hexagons on Y direction
         * @default 21
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsY: number;
        /**
         * Number of Hexagons on Z direction
         * @default 21
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        nrHexagonsX: number;
        /**
         * radius of a single hexagon
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        radiusHexagon: number;
        /**
         * Orient hexagon points grid on center
         * @default false
         */
        orientOnCenter: boolean;
        /**
         * Orient points on the ground
         * @default false
         */
        pointsOnGround: boolean;
      }
    }
    declare namespace Polyline {
      class PolylineCreateDto {
        /**
         * Provide options without default values
         */
        constructor(points?: Base.Point3[], isClosed?: boolean);
        /**
         * Points of the polyline
         * @default undefined
         */
        points?: Base.Point3[];
        /**
         * Can contain is closed information
         * @default false
         */
        isClosed?: boolean;
      }
      class PolylinePropertiesDto {
        /**
         * Provide options without default values
         */
        constructor(points?: Base.Point3[], isClosed?: boolean);
        /**
         * Points of the polyline
         * @default undefined
         */
        points?: Base.Point3[];
        /**
         * Can contain is closed information
         * @default false
         */
        isClosed?: boolean;
        /**
         * Optional polyline color
         * @default #444444
         */
        color?: string | number[];
      }
      class PolylineDto {
        constructor(polyline?: PolylinePropertiesDto);
        /**
         * Polyline with points
         * @default undefined
         */
        polyline?: PolylinePropertiesDto;
      }
      class PolylinesDto {
        constructor(polylines?: PolylinePropertiesDto[]);
        /**
         * Polylines array
         * @default undefined
         */
        polylines?: PolylinePropertiesDto[];
      }
      class TransformPolylineDto {
        constructor(
          polyline?: PolylinePropertiesDto,
          transformation?: Base.TransformMatrixes
        );
        /**
         * Polyline to transform
         * @default undefined
         */
        polyline?: PolylinePropertiesDto;
        /**
         * Transformation matrix or a list of transformation matrixes
         * @default undefined
         */
        transformation?: Base.TransformMatrixes;
      }
      class DrawPolylineDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          polyline?: PolylinePropertiesDto,
          opacity?: number,
          colours?: string | string[],
          size?: number,
          updatable?: boolean,
          polylineMesh?: T
        );
        /**
         * Polyline
         * @default undefined
         */
        polyline?: PolylinePropertiesDto;
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity?: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours?: string | string[];
        /**
         * Width of the polyline
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size?: number;
        /**
         * Indicates wether the position of this polyline will change in time
         * @default false
         */
        updatable?: boolean;
        /**
         * Line mesh variable in case it already exists and needs updating
         * @default undefined
         */
        polylineMesh?: T;
      }
      class DrawPolylinesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          polylines?: PolylinePropertiesDto[],
          opacity?: number,
          colours?: string | string[],
          size?: number,
          updatable?: boolean,
          polylinesMesh?: T
        );
        /**
         * Polylines
         * @default undefined
         */
        polylines?: PolylinePropertiesDto[];
        /**
         * Value between 0 and 1
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        opacity?: number;
        /**
         * Hex colour string
         * @default #444444
         */
        colours?: string | string[];
        /**
         * Width of the polyline
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        size?: number;
        /**
         * Indicates wether the position of this polyline will change in time
         * @default false
         */
        updatable?: boolean;
        /**
         * Polyline mesh variable in case it already exists and needs updating
         * @default undefined
         */
        polylinesMesh?: T;
      }
      class SegmentsToleranceDto {
        constructor(segments?: Base.Segment3[]);
        /**
         * Segments array
         * @default undefined
         */
        segments?: Base.Segment3[];
        /**
         * Tolerance for the calculation
         * @default 1e-5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-5
         */
        tolerance?: number;
      }
      class PolylineToleranceDto {
        constructor(polyline?: PolylinePropertiesDto, tolerance?: number);
        /**
         * Polyline to check
         * @default undefined
         */
        polyline?: PolylinePropertiesDto;
        /**
         * Tolerance for the calculation
         * @default 1e-5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-5
         */
        tolerance?: number;
      }
      class TwoPolylinesToleranceDto {
        constructor(
          polyline1?: PolylinePropertiesDto,
          polyline2?: PolylinePropertiesDto,
          tolerance?: number
        );
        /**
         * First polyline to check
         * @default undefined
         */
        polyline1?: PolylinePropertiesDto;
        /**
         * Second polyline to check
         * @default undefined
         */
        polyline2?: PolylinePropertiesDto;
        /**
         * Tolerance for the calculation
         * @default 1e-5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1e-5
         */
        tolerance?: number;
      }
    }
    declare namespace Text {
      class TextDto {
        constructor(text?: string);
        /**
         * The text
         * @default Hello World
         */
        text: string;
      }
      class TextSplitDto {
        constructor(text?: string, separator?: string);
        /**
         * Text to split
         * @default a,b,c
         */
        text: string;
        /**
         * Text to split by
         * @default ,
         */
        separator: string;
      }
      class TextReplaceDto {
        constructor(text?: string, search?: string, replaceWith?: string);
        /**
         * Text to replace
         * @default a-c
         */
        text: string;
        /**
         * Text to search for
         * @default -
         */
        search: string;
        /**
         * Text to replace found occurences
         * @default b
         */
        replaceWith: string;
      }
      class TextJoinDto {
        constructor(list?: string[], separator?: string);
        /**
         * Text to join
         * @default undefined
         */
        list: string[];
        /**
         * Text to join by
         * @default ,
         */
        separator: string;
      }
      class ToStringDto<T> {
        constructor(item?: T);
        /**
         * Item to stringify
         * @default undefined
         */
        item: T;
      }
      class ToStringEachDto<T> {
        constructor(list?: T[]);
        /**
         * Item to stringify
         * @default undefined
         */
        list: T[];
      }
      class TextFormatDto {
        constructor(text?: string, values?: string[]);
        /**
         * Text to format
         * @default Hello {0}
         */
        text: string;
        /**
         * Values to format
         * @default ["World"]
         */
        values: string[];
      }
      class TextSearchDto {
        constructor(text?: string, search?: string);
        /**
         * Text to search in
         * @default hello world
         */
        text: string;
        /**
         * Text to search for
         * @default world
         */
        search: string;
      }
      class TextSubstringDto {
        constructor(text?: string, start?: number, end?: number);
        /**
         * Text to extract from
         * @default hello world
         */
        text: string;
        /**
         * Start index
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        start: number;
        /**
         * End index
         * @default 5
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        end?: number;
      }
      class TextIndexDto {
        constructor(text?: string, index?: number);
        /**
         * Text to get character from
         * @default hello
         */
        text: string;
        /**
         * Index of character
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        index: number;
      }
      class TextPadDto {
        constructor(text?: string, length?: number, padString?: string);
        /**
         * Text to pad
         * @default x
         */
        text: string;
        /**
         * Target length
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        length: number;
        /**
         * String to pad with
         * @default a
         */
        padString: string;
      }
      class TextRepeatDto {
        constructor(text?: string, count?: number);
        /**
         * Text to repeat
         * @default ha
         */
        text: string;
        /**
         * Number of repetitions
         * @default 3
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        count: number;
      }
      class TextConcatDto {
        constructor(texts?: string[]);
        /**
         * Texts to concatenate
         * @default ["hello", " ", "world"]
         */
        texts: string[];
      }
      class TextRegexDto {
        constructor(text?: string, pattern?: string, flags?: string);
        /**
         * Text to search in
         * @default hello123world
         */
        text: string;
        /**
         * Regular expression pattern
         * @default [0-9]+
         */
        pattern: string;
        /**
         * Regular expression flags (g, i, m, s, u, y)
         * @default g
         */
        flags: string;
      }
      class TextRegexReplaceDto {
        constructor(
          text?: string,
          pattern?: string,
          flags?: string,
          replaceWith?: string
        );
        /**
         * Text to search in
         * @default hello123world456
         */
        text: string;
        /**
         * Regular expression pattern
         * @default [0-9]+
         */
        pattern: string;
        /**
         * Regular expression flags (g, i, m, s, u, y)
         * @default g
         */
        flags: string;
        /**
         * Text to replace matches with
         * @default X
         */
        replaceWith: string;
      }
      class VectorCharDto {
        constructor(
          char?: string,
          xOffset?: number,
          yOffset?: number,
          height?: number,
          extrudeOffset?: number
        );
        /**
         * The text
         * @default A
         */
        char: string;
        /**
         * The x offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        xOffset?: number;
        /**
         * The y offset
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        yOffset?: number;
        /**
         * The height of the text
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        height?: number;
        /**
         * The extrude offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extrudeOffset?: number;
      }
      class VectorTextDto {
        constructor(
          text?: string,
          xOffset?: number,
          yOffset?: number,
          height?: number,
          lineSpacing?: number,
          letterSpacing?: number,
          align?: Base.horizontalAlignEnum,
          extrudeOffset?: number,
          centerOnOrigin?: boolean
        );
        /**
         * The text
         * @default Hello World
         */
        text?: string;
        /**
         * The x offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        xOffset?: number;
        /**
         * The y offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        yOffset?: number;
        /**
         * The height of the text
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        height?: number;
        /**
         * The line spacing
         * @default 1.4
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        lineSpacing?: number;
        /**
         * The letter spacing offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        letterSpacing?: number;
        /**
         * The extrude offset
         * @default left
         */
        align?: Base.horizontalAlignEnum;
        /**
         * The extrude offset
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        extrudeOffset?: number;
        /**
         * Will center text on 0, 0, 0
         * @default false
         */
        centerOnOrigin?: boolean;
      }
    }
    declare namespace Transforms {
      class RotationCenterAxisDto {
        constructor(angle?: number, axis?: Base.Vector3, center?: Base.Point3);
        /**
         * Angle of rotation in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
        /**
         * Axis vector for rotation
         * @default [0, 1, 0]
         */
        axis: Base.Vector3;
        /**
         * The center from which the axis is pointing
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class RotationCenterDto {
        constructor(angle?: number, center?: Base.Point3);
        /**
         * Angle of rotation in degrees
         * @default 90
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        angle: number;
        /**
         * The center from which the axis is pointing
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class RotationCenterYawPitchRollDto {
        constructor(
          yaw?: number,
          pitch?: number,
          roll?: number,
          center?: Base.Point3
        );
        /**
         * Yaw angle (Rotation around X) in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        yaw: number;
        /**
         * Pitch angle (Rotation around Y) in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        pitch: number;
        /**
         * Roll angle (Rotation around Z) in degrees
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        roll: number;
        /**
         * The center from which the rotations are applied
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class ScaleXYZDto {
        constructor(scaleXyz?: Base.Vector3);
        /**
         * Scaling factors for each axis [1, 2, 1] means that Y axis will be scaled 200% and both x and z axis will remain on 100%
         * @default [1, 1, 1]
         */
        scaleXyz: Base.Vector3;
      }
      class StretchDirCenterDto {
        constructor(
          scale?: number,
          center?: Base.Point3,
          direction?: Base.Vector3
        );
        /** The center point around which to stretch.
         * @default [0, 0, 0]
         */
        center?: Base.Point3;
        /** The direction vector along which to stretch. Does not need to be normalized initially.
         * @default [0, 0, 1]
         */
        direction?: Base.Vector3;
        /** The scale factor to apply along the direction vector. 1.0 means no change.
         * @default 2
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scale?: number;
      }
      class ScaleCenterXYZDto {
        constructor(center?: Base.Point3, scaleXyz?: Base.Vector3);
        /**
         * The center from which the scaling is applied
         * @default [0, 0, 0]
         */
        center: Base.Point3;
        /**
         * Scaling factors for each axis [1, 2, 1] means that Y axis will be scaled 200% and both x and z axis will remain on 100%
         * @default [1, 1, 1]
         */
        scaleXyz: Base.Vector3;
      }
      class UniformScaleDto {
        constructor(scale?: number);
        /**
         * Uniform scale factor for all x, y, z directions. 1 will keep everything on original size, 2 will scale 200%;
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scale: number;
      }
      class UniformScaleFromCenterDto {
        constructor(scale?: number, center?: Base.Point3);
        /**
         * Scale factor for all x, y, z directions. 1 will keep everything on original size, 2 will scale 200%;
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scale: number;
        /**
         * Center position of the scaling
         * @default [0, 0, 0]
         */
        center: Base.Point3;
      }
      class TranslationXYZDto {
        constructor(translation?: Base.Vector3);
        /**
         * Translation vector with [x, y, z] distances
         * @default [0, 0, 0]
         */
        translation: Base.Vector3;
      }
      class TranslationsXYZDto {
        constructor(translations?: Base.Vector3[]);
        /**
         * Translation vectors with [x, y, z] distances
         * @default undefined
         */
        translations: Base.Vector3[];
      }
    }
    declare namespace Vector {
      class TwoVectorsDto {
        constructor(first?: number[], second?: number[]);
        /**
         * First vector
         * @default undefined
         */
        first: number[];
        /**
         * Second vector
         * @default undefined
         */
        second: number[];
      }
      class VectorBoolDto {
        constructor(vector?: boolean[]);
        /**
         * Vector of booleans
         * @default undefined
         */
        vector: boolean[];
      }
      class RemoveAllDuplicateVectorsDto {
        constructor(vectors?: number[][], tolerance?: number);
        /**
         * Vectors array
         * @default undefined
         */
        vectors: number[][];
        /**
         * Tolerance value
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         */
        tolerance: number;
      }
      class RemoveConsecutiveDuplicateVectorsDto {
        constructor(
          vectors?: number[][],
          checkFirstAndLast?: boolean,
          tolerance?: number
        );
        /**
         * Vectors array
         * @default undefined
         */
        vectors: number[][];
        /**
         * Check first and last vectors
         * @default false
         */
        checkFirstAndLast: boolean;
        /**
         * Tolerance value
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         */
        tolerance: number;
      }
      class VectorsTheSameDto {
        constructor(vec1?: number[], vec2?: number[], tolerance?: number);
        /**
         * First vector
         * @default undefined
         */
        vec1: number[];
        /**
         * Second vector
         * @default undefined
         */
        vec2: number[];
        /**
         * Tolerance value
         * @default 1e-7
         * @minimum 0
         * @maximum Infinity
         */
        tolerance: number;
      }
      class VectorDto {
        constructor(vector?: number[]);
        /**
         * Vector array of numbers
         * @default undefined
         */
        vector: number[];
      }
      class VectorStringDto {
        constructor(vector?: string[]);
        /**
         * Vector array of stringified numbers
         * @default undefined
         */
        vector: string[];
      }
      class Vector3Dto {
        constructor(vector?: Base.Vector3);
        /**
         * Vector array of 3 numbers
         * @default undefined
         */
        vector: Base.Vector3;
      }
      class RangeMaxDto {
        constructor(max?: number);
        /**
         * Maximum range boundary
         * @default 10
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        max: number;
      }
      class VectorXYZDto {
        constructor(x?: number, y?: number, z?: number);
        /**
         * X value of vector
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.5
         */
        x: number;
        /**
         * Y value of vector
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.5
         */
        y: number;
        /**
         * Z value of vector
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.5
         */
        z: number;
      }
      class VectorXYDto {
        constructor(x?: number, y?: number);
        /**
         * X value of vector
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.5
         */
        x: number;
        /**
         * Y value of vector
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.5
         */
        y: number;
      }
      class SpanDto {
        constructor(step?: number, min?: number, max?: number);
        /**
         * Step of the span
         * @default 0.1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        step: number;
        /**
         * Min value of the span
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        min: number;
        /**
         * Max value of the span
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        max: number;
      }
      class SpanEaseItemsDto {
        constructor(
          nrItems?: number,
          min?: number,
          max?: number,
          ease?: Math.easeEnum
        );
        /**
         * Nr of items in the span
         * @default 100
         * @minimum 2
         * @maximum Infinity
         * @step 1
         */
        nrItems: number;
        /**
         * Min value of the span
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        min: number;
        /**
         * Max value of the span
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        max: number;
        /**
         * Ease type
         * @default easeInSine
         */
        ease: Math.easeEnum;
        /**
         * Indicates wether only intervals should be outputed. This will output step lengths between the values.
         * @default false
         */
        intervals: boolean;
      }
      class SpanLinearItemsDto {
        constructor(nrItems?: number, min?: number, max?: number);
        /**
         * Nr of items in the span
         * @default 100
         * @minimum 2
         * @maximum Infinity
         * @step 1
         */
        nrItems: number;
        /**
         * Min value of the span
         * @default 0
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        min: number;
        /**
         * Max value of the span
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        max: number;
      }
      class RayPointDto {
        constructor(point?: Base.Point3, distance?: number, vector?: number[]);
        /**
         * Origin location of the ray
         * @default undefined
         */
        point: Base.Point3;
        /**
         * Distance to the point on the ray
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 1
         */
        distance: number;
        /**
         * Vector array of numbers
         * @default undefined
         */
        vector: number[];
      }
      class VectorsDto {
        constructor(vectors?: number[][]);
        /**
         * Vectors array
         * @default undefined
         */
        vectors: number[][];
      }
      class FractionTwoVectorsDto {
        constructor(
          fraction?: number,
          first?: Base.Vector3,
          second?: Base.Vector3
        );
        /**
         * Fraction number
         * @default 0.5
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        fraction: number;
        /**
         * First vector
         * @default undefined
         */
        first: Base.Vector3;
        /**
         * Second vector
         * @default undefined
         */
        second: Base.Vector3;
      }
      class VectorScalarDto {
        constructor(scalar?: number, vector?: number[]);
        /**
         * Scalar number
         * @default 1
         * @minimum -Infinity
         * @maximum Infinity
         * @step 0.1
         */
        scalar: number;
        /**
         * Vector array of numbers
         * @default undefined
         */
        vector: number[];
      }
      class TwoVectorsReferenceDto {
        constructor(
          reference?: number[],
          first?: Base.Vector3,
          second?: Base.Vector3
        );
        /**
         * Reference vector
         * @default undefined
         */
        reference: number[];
        /**
         * First vector
         * @default undefined
         */
        first: Base.Vector3;
        /**
         * Second vector
         * @default undefined
         */
        second: Base.Vector3;
      }
    }
    declare namespace Asset {
      class GetAssetDto {
        constructor(fileName?: string);
        /**
         * The fileName associated with the projects asset
         * @default undefined
         */
        fileName: string;
      }
      class FetchDto {
        constructor(url?: string);
        /**
         * The url to fetch from
         * @default undefined
         */
        url: string;
      }
      class FileDto {
        constructor(file?: File | Blob);
        /**
         * Asset file that was loaded
         * @default undefined
         */
        file: File | Blob;
      }
      class FilesDto {
        constructor(files?: (File | Blob)[]);
        /**
         * Asset file that was loaded
         * @default undefined
         */
        files: (File | Blob)[];
      }
      class AssetFileDto {
        constructor(assetFile?: File, hidden?: boolean);
        /**
         * Asset file that was loaded
         * @default undefined
         */
        assetFile: File;
        /**
         * Import the asset hidden
         * @default false
         */
        hidden: boolean;
      }
      class AssetFileByUrlDto {
        constructor(assetFile?: string, rootUrl?: string, hidden?: boolean);
        /**
         * Asset file name
         * @default undefined
         */
        assetFile: string;
        /**
         * Root url
         * @default undefined
         */
        rootUrl: string;
        /**
         * Import the asset hidden
         * @default false
         */
        hidden: boolean;
      }
      class DownloadDto {
        constructor(
          fileName?: string,
          content?: string | Blob,
          extension?: string,
          contentType?: string
        );
        /**
         * The file name for the downloaded file
         * @default undefined
         */
        fileName: string;
        /**
         * The content to download (string or Blob)
         * @default undefined
         */
        content: string | Blob;
        /**
         * The file extension (without dot)
         * @default txt
         */
        extension: string;
        /**
         * The content type for the file
         * @default text/plain
         */
        contentType: string;
      }
    }
    declare namespace Base {
      /**
       * Defines how colors are mapped to entities when there are more entities than colors.
       * - firstColorForAll: Uses the first color for all entities (legacy behavior)
       * - lastColorRemainder: Maps colors 1:1, then uses last color for remaining entities
       * - repeatColors: Cycles through colors in a repeating pattern
       * - reversedColors: After exhausting colors, reverses direction (ping-pong pattern)
       */
      enum colorMapStrategyEnum {
        /** Uses the first color for all entities (legacy behavior) */
        firstColorForAll = "firstColorForAll",
        /** Maps colors 1:1, then uses last color for remaining entities */
        lastColorRemainder = "lastColorRemainder",
        /** Cycles through colors in a repeating pattern */
        repeatColors = "repeatColors",
        /** After exhausting colors, reverses direction (ping-pong pattern) */
        reversedColors = "reversedColors",
      }
      enum skyboxEnum {
        default = "default",
        clearSky = "clearSky",
        city = "city",
        greyGradient = "greyGradient",
      }
      enum fogModeEnum {
        none = "none",
        exponential = "exponential",
        exponentialSquared = "exponentialSquared",
        linear = "linear",
      }
      enum horizontalAlignEnum {
        left = "left",
        center = "center",
        right = "right",
      }
      enum verticalAlignmentEnum {
        top = "top",
        middle = "middle",
        bottom = "bottom",
      }
      enum topBottomEnum {
        top = "top",
        bottom = "bottom",
      }
      enum basicAlignmentEnum {
        topLeft = "topLeft",
        topMid = "topMid",
        topRight = "topRight",
        midLeft = "midLeft",
        midMid = "midMid",
        midRight = "midRight",
        bottomLeft = "bottomLeft",
        bottomMid = "bottomMid",
        bottomRight = "bottomRight",
      }
      type Color = string;
      type ColorRGB = {
        r: number;
        g: number;
        b: number;
      };
      type Point2 = [number, number];
      type Vector2 = [number, number];
      type Point3 = [number, number, number];
      type Vector3 = [number, number, number];
      type Axis3 = {
        origin: Base.Point3;
        direction: Base.Vector3;
      };
      type Axis2 = {
        origin: Base.Point2;
        direction: Base.Vector2;
      };
      type Segment2 = [Point2, Point2];
      type Segment3 = [Point3, Point3];
      type TrianglePlane3 = {
        normal: Vector3;
        d: number;
      };
      type Triangle3 = [Base.Point3, Base.Point3, Base.Point3];
      type Mesh3 = Triangle3[];
      type Plane3 = {
        origin: Base.Point3;
        normal: Base.Vector3;
        direction: Base.Vector3;
      };
      type BoundingBox = {
        min: Base.Point3;
        max: Base.Point3;
        center?: Base.Point3;
        width?: number;
        height?: number;
        length?: number;
      };
      type Line2 = {
        start: Base.Point2;
        end: Base.Point2;
      };
      type Line3 = {
        start: Base.Point3;
        end: Base.Point3;
      };
      type Polyline3 = {
        points: Base.Point3[];
        isClosed?: boolean;
      };
      type Polyline2 = {
        points: Base.Point2[];
        isClosed?: boolean;
      };
      type VerbCurve = {
        tessellate: (options: any) => any;
      };
      type VerbSurface = {
        tessellate: (options: any) => any;
      };
      type TransformMatrix3x3 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes3x3 = TransformMatrix3x3[];
      type TransformMatrix = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number
      ];
      type TransformMatrixes = TransformMatrix[];
    }
    declare namespace CSV {
      class ParseToArrayDto {
        constructor(
          csv?: string,
          rowSeparator?: string,
          columnSeparator?: string
        );
        /**
             * CSV text to parse
             * @default name,age
    John,30
             */
        csv: string;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
      }
      class ParseToJsonDto {
        constructor(
          csv?: string,
          headerRow?: number,
          dataStartRow?: number,
          rowSeparator?: string,
          columnSeparator?: string,
          numberColumns?: string[]
        );
        /**
             * CSV text to parse
             * @default name,age
    John,30
    Jane,25
             */
        csv: string;
        /**
         * Row index where headers are located
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        headerRow?: number;
        /**
         * Row index where data starts
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        dataStartRow?: number;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
        /**
         * Column names that should be converted to numbers
         * @default undefined
         * @optional true
         */
        numberColumns?: string[];
      }
      class ParseToJsonWithHeadersDto {
        constructor(
          csv?: string,
          headers?: string[],
          dataStartRow?: number,
          rowSeparator?: string,
          columnSeparator?: string,
          numberColumns?: string[]
        );
        /**
             * CSV text to parse
             * @default John,30
    Jane,25
             */
        csv: string;
        /**
         * Custom header names to use
         * @default ["name", "age"]
         */
        headers: string[];
        /**
         * Row index where data starts
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        dataStartRow?: number;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
        /**
         * Column names that should be converted to numbers
         * @default undefined
         * @optional true
         */
        numberColumns?: string[];
      }
      class QueryColumnDto {
        constructor(
          csv?: string,
          column?: string,
          headerRow?: number,
          dataStartRow?: number,
          rowSeparator?: string,
          columnSeparator?: string,
          asNumber?: boolean
        );
        /**
             * CSV text to query
             * @default name,age
    John,30
    Jane,25
             */
        csv: string;
        /**
         * Column name to query
         * @default name
         */
        column: string;
        /**
         * Row index where headers are located
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        headerRow?: number;
        /**
         * Row index where data starts
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        dataStartRow?: number;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
        /**
         * Convert column values to numbers
         * @default false
         */
        asNumber?: boolean;
      }
      class QueryRowsByValueDto {
        constructor(
          csv?: string,
          column?: string,
          value?: string,
          headerRow?: number,
          dataStartRow?: number,
          rowSeparator?: string,
          columnSeparator?: string,
          numberColumns?: string[]
        );
        /**
             * CSV text to query
             * @default name,age
    John,30
    Jane,25
             */
        csv: string;
        /**
         * Column name to filter by
         * @default age
         */
        column: string;
        /**
         * Value to match
         * @default 30
         */
        value: string;
        /**
         * Row index where headers are located
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        headerRow?: number;
        /**
         * Row index where data starts
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        dataStartRow?: number;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
        /**
         * Column names that should be converted to numbers
         * @default undefined
         * @optional true
         */
        numberColumns?: string[];
      }
      class ArrayToCsvDto {
        constructor(
          array?: (string | number | boolean | null | undefined)[][],
          rowSeparator?: string,
          columnSeparator?: string
        );
        /**
         * 2D array to convert
         * @default [["name", "age"], ["John", "30"]]
         */
        array: (string | number | boolean | null | undefined)[][];
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
      }
      class JsonToCsvDto<T = Record<string, unknown>> {
        constructor(
          json?: T[],
          headers?: string[],
          includeHeaders?: boolean,
          rowSeparator?: string,
          columnSeparator?: string
        );
        /**
         * Array of JSON objects to convert
         * @default [{"name": "John", "age": "30"}]
         */
        json: T[];
        /**
         * Headers to use (in order)
         * @default ["name", "age"]
         */
        headers: string[];
        /**
         * Whether to include headers in output
         * @default true
         */
        includeHeaders?: boolean;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
      }
      class JsonToCsvAutoDto<T = Record<string, unknown>> {
        constructor(
          json?: T[],
          includeHeaders?: boolean,
          rowSeparator?: string,
          columnSeparator?: string
        );
        /**
         * Array of JSON objects to convert
         * @default [{"name": "John", "age": "30"}]
         */
        json: T[];
        /**
         * Whether to include headers in output
         * @default true
         */
        includeHeaders?: boolean;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
      }
      class GetHeadersDto {
        constructor(
          csv?: string,
          headerRow?: number,
          rowSeparator?: string,
          columnSeparator?: string
        );
        /**
             * CSV text to get headers from
             * @default name,age
    John,30
             */
        csv: string;
        /**
         * Row index where headers are located
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        headerRow?: number;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
      }
      class GetRowCountDto {
        constructor(
          csv?: string,
          hasHeaders?: boolean,
          dataStartRow?: number,
          rowSeparator?: string,
          columnSeparator?: string
        );
        /**
             * CSV text to count rows
             * @default name,age
    John,30
    Jane,25
             */
        csv: string;
        /**
         * Whether CSV has headers
         * @default true
         */
        hasHeaders?: boolean;
        /**
         * Row index where data starts (overrides hasHeaders if set)
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        dataStartRow?: number;
        /**
             * Row separator (newline character)
             * @default 
    
             */
        rowSeparator?: string;
        /**
         * Column separator (delimiter)
         * @default ,
         */
        columnSeparator?: string;
      }
    }
    declare namespace JSON {
      class StringifyDto {
        constructor(json?: any);
        /**
         * Stringify value
         * @default undefined
         */
        json: any;
      }
      class ParseDto {
        constructor(text?: string);
        /**
         * Stringify value
         * @default "[0, 0, 0]"
         */
        text: string;
      }
      class QueryDto {
        constructor(json?: any, query?: string);
        /**
         * query json structure
         * @default undefined
         */
        json: any;
        /**
         * query path
         * @default undefined
         */
        query: string;
      }
      class SetValueOnPropDto {
        constructor(json?: any, value?: any, property?: string);
        /**
         * query json structure
         * @default undefined
         */
        json: any;
        /**
         * value to be set
         * @default undefined
         */
        value: any;
        /**
         * query json structure
         * @default propName
         */
        property: string;
      }
      class GetJsonFromArrayByFirstPropMatchDto {
        constructor(jsonArray?: any[], property?: string, match?: any);
        /**
         * Array
         * @default undefined
         */
        jsonArray: any[];
        /**
         * property to check
         * @default propName
         */
        property: string;
        /**
         * Value to match for the property
         * @default undefined
         */
        match: any;
      }
      class GetValueOnPropDto {
        constructor(json?: any, property?: string);
        /**
         * query json structure
         * @default undefined
         */
        json: any;
        /**
         * query json structure
         * @default propName
         */
        property: string;
      }
      class SetValueDto {
        constructor(json?: any, value?: any, path?: string, prop?: string);
        /**
         * query json structure
         * @default undefined
         */
        json: any;
        /**
         * value to be set
         * @default undefined
         */
        value: any;
        /**
         * query to json structure elements on which given prop has to be updated
         * @default $.pathToParent
         */
        path: string;
        /**
         * property to update
         * @default propertyName
         */
        prop: string;
      }
      class SetValuesOnPathsDto {
        constructor(json?: any, values?: any[], paths?: string[], props?: []);
        /**
         * query json structure
         * @default undefined
         */
        json: any;
        /**
         * values to be set
         * @default undefined
         */
        values: any[];
        /**
         * query json structures
         * @default undefined
         */
        paths: string[];
        /**
         * properties to update
         * @default undefined
         */
        props: string[];
      }
      class PathsDto {
        constructor(json?: any, query?: string);
        /**
         * query json structure
         * @default undefined
         */
        json: any;
        /**
         * query path
         * @default undefined
         */
        query: string;
      }
      class JsonDto {
        constructor(json?: any);
        /**
         * json value
         * @default undefined
         */
        json: any;
      }
    }
    declare namespace Tag {
      class DrawTagDto {
        constructor(tag?: TagDto, updatable?: boolean, tagVariable?: TagDto);
        /**
         * Text tag to draw
         */
        tag: TagDto;
        /**
         * Indicates that it is updatable tag
         */
        updatable: boolean;
        /**
         * Optional existing tag in case it needs updating
         */
        tagVariable?: TagDto;
      }
      class DrawTagsDto {
        constructor(
          tags?: TagDto[],
          updatable?: boolean,
          tagsVariable?: TagDto[]
        );
        /**
         * Text tag to draw
         */
        tags: TagDto[];
        /**
         * Indicates that it is updatable tag
         */
        updatable: boolean;
        /**
         * Optional existing tag in case it needs updating
         */
        tagsVariable?: TagDto[];
      }
      /**
       * Class representing a tag
       */
      class TagDto {
        constructor(
          text?: string,
          position?: Base.Point3,
          colour?: string,
          size?: number,
          adaptDepth?: boolean,
          needsUpdate?: boolean,
          id?: string
        );
        /**
         * Text of the tag
         */
        text: string;
        /**
         * Position of the tag
         */
        position: Base.Point3;
        /**
         * Colour of the tag
         */
        colour: string;
        /**
         * Text size
         */
        size: number;
        /**
         * Make tags that are further away smaller
         */
        adaptDepth: boolean;
        /**
         * Indicates if tag needs updating
         */
        needsUpdate?: boolean;
        /**
         * Unique id of the tag
         */
        id?: string;
      }
    }
    declare namespace Time {
      class PostFromIframe {
        constructor(data?: any, targetOrigin?: string);
        /**
         * The data object to post
         */
        data: any;
        /**
         * Thir party iframe origin url to which data should be posted
         */
        targetOrigin: string;
      }
    }
    declare namespace Verb {
      class CurveDto {
        constructor(curve?: any);
        /**
         * Nurbs curve
         */
        curve: any;
      }
      class LineDto {
        constructor(line?: Base.Line3);
        /**
         * Basic line
         */
        line: Base.Line3;
      }
      class LinesDto {
        constructor(lines?: Base.Line3[]);
        /**
         * Basic lines
         */
        lines: Base.Line3[];
      }
      class PolylineDto {
        constructor(polyline?: Base.Polyline3);
        /**
         * Basic polyline
         */
        polyline: Base.Polyline3;
      }
      class PolylinesDto {
        constructor(polylines?: Base.Polyline3[]);
        /**
         * Basic polyline
         */
        polylines: Base.Polyline3[];
      }
      class CurvesDto {
        constructor(curves?: any[]);
        /**
         * Nurbs curves
         */
        curves: any[];
      }
      class ClosestPointDto {
        constructor(curve?: any, point?: Base.Point3);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Point
         */
        point: Base.Point3;
      }
      class ClosestPointsDto {
        constructor(curve?: any, points?: Base.Point3[]);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Points
         */
        points: Base.Point3[];
      }
      class BezierCurveDto {
        constructor(points?: Base.Point3[], weights?: number[]);
        /**
         * Control points
         */
        points: Base.Point3[];
        /**
         * Weights
         */
        weights: number[];
      }
      class DrawCurveDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          curve?: any,
          opacity?: number,
          colours?: string | string[],
          size?: number,
          updatable?: boolean,
          curveMesh?: T
        );
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Value between 0 and 1
         */
        opacity: number;
        /**
         * Hex colour string
         */
        colours: string | string[];
        /**
         * Width of the polyline
         */
        size: number;
        /**
         * Indicates wether the position of this curve will change in time
         */
        updatable: boolean;
        /**
         * Curve mesh variable in case it already exists and needs updating
         */
        curveMesh?: T;
      }
      class CurveParameterDto {
        constructor(curve?: any, parameter?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Parameter on the curve
         */
        parameter: number;
      }
      class CurvesParameterDto {
        constructor(curves?: any[], parameter?: number);
        /**
         * Nurbs curve
         */
        curves: any;
        /**
         * Parameter on the curve
         */
        parameter: number;
      }
      class CurveTransformDto {
        constructor(curve?: any, transformation?: Base.TransformMatrixes);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Transformation matrixes
         */
        transformation: Base.TransformMatrixes;
      }
      class CurvesTransformDto {
        constructor(curves?: any[], transformation?: Base.TransformMatrixes);
        /**
         * Nurbs curve
         */
        curves: any[];
        /**
         * Transformation matrixes
         */
        transformation: Base.TransformMatrixes;
      }
      class CurveToleranceDto {
        constructor(curve?: any, tolerance?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Optional tolerance
         */
        tolerance: number;
      }
      class CurveLengthToleranceDto {
        constructor(curve?: any, length?: number, tolerance?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Length on the curve
         */
        length: number;
        /**
         * Tolerance
         */
        tolerance: number;
      }
      class CurveDerivativesDto {
        constructor(curve?: any, parameter?: number, numDerivatives?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Number of derivatives
         */
        numDerivatives: number;
        /**
         * Parameter on the curve
         */
        parameter: number;
      }
      class CurveSubdivisionsDto {
        constructor(curve?: any, subdivision?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Number of subdivisions
         */
        subdivision: number;
      }
      class CurvesSubdivisionsDto {
        constructor(curves?: any[], subdivision?: number);
        /**
         * Nurbs curves
         */
        curves: any[];
        /**
         * Number of subdivisions
         */
        subdivision: number;
      }
      class CurvesDivideLengthDto {
        constructor(curves?: any[], length?: number);
        /**
         * Nurbs curves
         */
        curves: any[];
        /**
         * Length of subdivisions
         */
        length: number;
      }
      class CurveDivideLengthDto {
        constructor(curve?: any, length?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Length of subdivisions
         */
        length: number;
      }
      class DrawCurvesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          curves?: any[],
          opacity?: number,
          colours?: string | string[],
          size?: number,
          updatable?: boolean,
          curvesMesh?: T
        );
        /**
         * Nurbs curves
         */
        curves: any[];
        /**
         * Value between 0 and 1
         */
        opacity: number;
        /**
         * Hex colour string
         */
        colours: string | string[];
        /**
         * Width of the polyline
         */
        size: number;
        /**
         * Indicates wether the position of this polyline will change in time
         */
        updatable: boolean;
        /**
         * Curve mesh variable in case it already exists and needs updating
         */
        curvesMesh?: T;
      }
      class CurveNurbsDataDto {
        constructor(
          degree?: number,
          weights?: number[],
          knots?: number[],
          points?: Base.Point3[]
        );
        /**
         * Nurbs curve degree
         */
        degree: number;
        /**
         * Weights that identify strength that attracts curve to control points
         */
        weights: number[];
        /**
         * Knots of the Nurbs curve
         */
        knots: number[];
        /**
         * Control points of the nurbs curve
         */
        points: Base.Point3[];
      }
      class CurvePathDataDto {
        constructor(degree?: number, points?: Base.Point3[]);
        /**
         * Nurbs curve degree
         */
        degree: number;
        /**
         * Control points of the nurbs curve
         */
        points: Base.Point3[];
      }
      class EllipseDto {
        constructor(ellipse?: any);
        /**
         * Nurbs ellipse
         */
        ellipse: any;
      }
      class CircleDto {
        constructor(circle?: any);
        /**
         * Nurbs circle
         */
        circle: any;
      }
      class ArcDto {
        constructor(arc?: any);
        /**
         * Nurbs arc
         */
        arc: any;
      }
      class EllipseParametersDto {
        constructor(
          xAxis?: Base.Vector3,
          yAxis?: Base.Vector3,
          center?: Base.Point3
        );
        /**
         * X axis of the circle
         */
        xAxis: Base.Vector3;
        /**
         * Y axis of the circle
         */
        yAxis: Base.Vector3;
        /**
         * Center of the circle
         */
        center: Base.Point3;
      }
      class CircleParametersDto {
        constructor(
          xAxis?: Base.Vector3,
          yAxis?: Base.Vector3,
          radius?: number,
          center?: Base.Point3
        );
        /**
         * X axis of the circle
         */
        xAxis: Base.Vector3;
        /**
         * Y axis of the circle
         */
        yAxis: Base.Vector3;
        /**
         * Radius of the circle
         */
        radius: number;
        /**
         * Center of the circle
         */
        center: Base.Point3;
      }
      class ArcParametersDto {
        constructor(
          minAngle?: number,
          maxAngle?: number,
          xAxis?: Base.Vector3,
          yAxis?: Base.Vector3,
          radius?: number,
          center?: Base.Point3
        );
        /**
         * Minimum angle in degrees
         */
        minAngle: number;
        /**
         * Maximum angle in degrees
         */
        maxAngle: number;
        /**
         * X axis of the circle
         */
        xAxis: Base.Vector3;
        /**
         * Y axis of the circle
         */
        yAxis: Base.Vector3;
        /**
         * Radius of the circle
         */
        radius: number;
        /**
         * Center of the circle
         */
        center: Base.Point3;
      }
      class EllipseArcParametersDto {
        constructor(
          minAngle?: number,
          maxAngle?: number,
          xAxis?: Base.Vector3,
          yAxis?: Base.Vector3,
          center?: Base.Point3
        );
        /**
         * Minimum angle in degrees
         */
        minAngle: number;
        /**
         * Maximum angle in degrees
         */
        maxAngle: number;
        /**
         * X axis of the circle
         */
        xAxis: Base.Vector3;
        /**
         * Y axis of the circle
         */
        yAxis: Base.Vector3;
        /**
         * Center of the circle
         */
        center: Base.Point3;
      }
      class SurfaceDto {
        constructor(surface?: any);
        /**
         * Nurbs surface
         */
        surface: any;
      }
      class SurfaceTransformDto {
        constructor(surface?: any, transformation?: Base.TransformMatrixes);
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Transformations
         */
        transformation: Base.TransformMatrixes;
      }
      class SurfaceParameterDto {
        constructor(surface?: any, parameter?: number, useV?: boolean);
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Parameter on the surface
         */
        parameter: number;
        /**
         * Default parameter is on U direction, use V to switch
         */
        useV: boolean;
      }
      class IsocurvesParametersDto {
        constructor(surface?: any, parameters?: number[], useV?: boolean);
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Parameter on the surface
         */
        parameters: number[];
        /**
         * Default parameter is on U direction, use V to switch
         */
        useV: boolean;
      }
      class IsocurveSubdivisionDto {
        /**
         * Provide undefined options
         */
        constructor(
          surface?: any,
          useV?: boolean,
          includeLast?: boolean,
          includeFirst?: boolean,
          isocurveSegments?: number
        );
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Default parameter is on U direction, use V to switch
         */
        useV: boolean;
        /**
         * Check to include the last isocurve
         */
        includeLast: boolean;
        /**
         * Check to include the first isocurve
         */
        includeFirst: boolean;
        /**
         * Number of segments including surface start and end
         */
        isocurveSegments: number;
      }
      class DerivativesDto {
        constructor(
          surface?: any,
          u?: number,
          v?: number,
          numDerivatives?: number
        );
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * U coordinate
         */
        u: number;
        /**
         * V coordinate
         */
        v: number;
        /**
         * Number of derivatives
         */
        numDerivatives: number;
      }
      class SurfaceLocationDto {
        constructor(surface?: any, u?: number, v?: number);
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * U coordinate
         */
        u: number;
        /**
         * V coordinate
         */
        v: number;
      }
      class CornersDto {
        constructor(
          point1?: Base.Point3,
          point2?: Base.Point3,
          point3?: Base.Point3,
          point4?: Base.Point3
        );
        /**
         * Corner 1
         */
        point1: Base.Point3;
        /**
         * Corner 2
         */
        point2: Base.Point3;
        /**
         * Corner 3
         */
        point3: Base.Point3;
        /**
         * Corner 4
         */
        point4: Base.Point3;
      }
      class SurfaceParamDto {
        constructor(surface?: any, point?: Base.Point3);
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Point
         */
        point: Base.Point3;
      }
      class KnotsControlPointsWeightsDto {
        constructor(
          degreeU?: number,
          degreeV?: number,
          knotsU?: number[],
          knotsV?: number[],
          points?: Base.Point3[],
          weights?: number[]
        );
        /**
         * U direction degree
         */
        degreeU: number;
        /**
         * V direction degree
         */
        degreeV: number;
        /**
         * U direction knots
         */
        knotsU: number[];
        /**
         * V direction knots
         */
        knotsV: number[];
        /**
         * Points
         */
        points: Base.Point3[];
        /**
         * Weights
         */
        weights: number[];
      }
      class LoftCurvesDto {
        constructor(degreeV?: number, curves?: any[]);
        /**
         * V direction degree
         */
        degreeV: number;
        /**
         * Nurbs curves
         */
        curves: any[];
      }
      class DrawSurfaceDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          surface?: any,
          opacity?: number,
          colours?: string | string[],
          updatable?: boolean,
          hidden?: boolean,
          surfaceMesh?: T,
          drawTwoSided?: boolean,
          backFaceColour?: string,
          backFaceOpacity?: number
        );
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Value between 0 and 1
         */
        opacity: number;
        /**
         * Hex colour string
         */
        colours: string | string[];
        /**
         * Indicates wether the position of this surface will change in time
         */
        updatable: boolean;
        /**
         * Should be hidden
         */
        hidden: boolean;
        /**
         * Surface mesh variable in case it already exists and needs updating
         */
        surfaceMesh?: T;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: string;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawSurfacesDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          surfaces?: any[],
          opacity?: number,
          colours?: string | string[],
          updatable?: boolean,
          hidden?: boolean,
          surfacesMesh?: T,
          drawTwoSided?: boolean,
          backFaceColour?: string,
          backFaceOpacity?: number
        );
        /**
         * Nurbs surfaces
         */
        surfaces: any[];
        /**
         * Value between 0 and 1
         */
        opacity: number;
        /**
         * Hex colour string
         */
        colours: string | string[];
        /**
         * Indicates wether the position of these surfaces will change in time
         */
        updatable: boolean;
        /**
         * Should be hidden
         */
        hidden: boolean;
        /**
         * Surfaces mesh variable in case it already exists and needs updating
         */
        surfacesMesh?: T;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: string;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class DrawSurfacesColoursDto<T> {
        /**
         * Provide options without default values
         */
        constructor(
          surfaces?: any[],
          colours?: string[],
          opacity?: number,
          updatable?: boolean,
          hidden?: boolean,
          surfacesMesh?: T,
          drawTwoSided?: boolean,
          backFaceColour?: string,
          backFaceOpacity?: number
        );
        /**
         * Nurbs surfaces
         */
        surfaces: any[];
        /**
         * Value between 0 and 1
         */
        opacity: number;
        /**
         * Hex colour strings, there has to be a colour for every single surface and lengths of arrays need to match
         */
        colours: string | string[];
        /**
         * Indicates wether the position of these surfaces will change in time
         */
        updatable: boolean;
        /**
         * Indicates if surface should be hidden
         */
        hidden: boolean;
        /**
         * Surfaces mesh variable in case it already exists and needs updating
         */
        surfacesMesh?: T;
        /**
         * Draw two-sided faces with different colors for front and back. This helps visualize face orientation.
         * @default true
         */
        drawTwoSided: boolean;
        /**
         * Hex colour string for back face colour (negative side of the face). Only used when drawTwoSided is true.
         * @default #0000ff
         */
        backFaceColour: string;
        /**
         * Back face opacity value between 0 and 1. Only used when drawTwoSided is true.
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        backFaceOpacity: number;
      }
      class ConeAndCylinderParametersDto {
        constructor(
          axis?: Base.Vector3,
          xAxis?: Base.Vector3,
          base?: Base.Point3,
          height?: number,
          radius?: number
        );
        /**
         * Defines main axis of the cone
         */
        axis: Base.Vector3;
        /**
         * X axis of the cone
         */
        xAxis: Base.Vector3;
        /**
         * Base point for the cone
         */
        base: Base.Point3;
        /**
         * Height of the cone
         */
        height: number;
        /**
         * Radius of the cone
         */
        radius: number;
      }
      class ConeDto {
        constructor(cone?: any);
        /**
         * Conical Nurbs surface
         */
        cone: any;
      }
      class CylinderDto {
        constructor(cylinder?: any);
        /**
         * Cylindrical Nurbs surface
         */
        cylinder: any;
      }
      class ExtrusionParametersDto {
        constructor(profile?: any, direction?: Base.Vector3);
        /**
         * Profile Nurbs curve
         */
        profile: any;
        /**
         * Direction vector
         */
        direction: Base.Vector3;
      }
      class ExtrusionDto {
        constructor(extrusion?: any);
        /**
         * Nurbs surface created through extrusion
         */
        extrusion: any;
      }
      class SphericalParametersDto {
        constructor(radius?: number, center?: number[]);
        /**
         * Radius of the sphere
         */
        radius: number;
        /**
         * Center point
         */
        center: number[];
      }
      class SphereDto {
        constructor(sphere?: any);
        /**
         * Spherical Nurbs surface
         */
        sphere: any;
      }
      class RevolutionParametersDto {
        constructor(
          profile?: any,
          center?: number[],
          axis?: number[],
          angle?: number
        );
        /**
         * Profile Nurbs curve
         */
        profile: any;
        /**
         * Center point
         */
        center: number[];
        /**
         * Axis around which rotation will happen
         */
        axis: number[];
        /**
         * Angle at which to rotate in degrees
         */
        angle: number;
      }
      class RevolutionDto {
        constructor(revolution?: any);
        /**
         * Revolved Nurbs surface
         */
        revolution: any;
      }
      class SweepParametersDto {
        constructor(profile?: any, rail?: any);
        /**
         * Profile Nurbs curve
         */
        profile: any;
        /**
         * Rail Nurbs curve
         */
        rail: any;
      }
      class SweepDto {
        constructor(sweep?: any);
        /**
         * Revolved Nurbs surface
         */
        sweep: any;
      }
      class CurveCurveDto {
        constructor(firstCurve?: any, secondCurve?: any, tolerance?: number);
        /**
         * First Nurbs curve
         */
        firstCurve: any;
        /**
         * Second Nurbs curve
         */
        secondCurve: number[];
        /**
         * Optional tolerance parameter
         */
        tolerance?: number;
      }
      class CurveSurfaceDto {
        constructor(curve?: any, surface?: any, tolerance?: number);
        /**
         * Nurbs curve
         */
        curve: any;
        /**
         * Nurbs surface
         */
        surface: any;
        /**
         * Optional tolerance parameter
         */
        tolerance?: number;
      }
      class SurfaceSurfaceDto {
        constructor(
          firstSurface?: any,
          secondSurface?: any,
          tolerance?: number
        );
        /**
         * Nurbs curve
         */
        firstSurface: any;
        /**
         * Nurbs surface
         */
        secondSurface: any;
        /**
         * Optional tolerance parameter
         */
        tolerance?: number;
      }
      class CurveCurveIntersectionsDto {
        constructor(intersections?: BaseTypes.CurveCurveIntersection[]);
        /**
         * Curve curve intersections
         */
        intersections: BaseTypes.CurveCurveIntersection[];
      }
      class CurveSurfaceIntersectionsDto {
        constructor(intersections?: BaseTypes.CurveSurfaceIntersection[]);
        /**
         * Curve curve intersections
         */
        intersections: BaseTypes.CurveSurfaceIntersection[];
      }
    }
  }

  declare namespace Models {
    declare namespace Point {
      declare class HexGridData {
        centers: Base.Point3[];
        hexagons: Base.Point3[][];
        shortestDistEdge: number;
        longestDistEdge: number;
        maxFilletRadius: number;
      }
    }
    declare namespace Text {
      declare class VectorCharData {
        constructor(width?: number, height?: number, paths?: Base.Point3[][]);
        /**
         * The width of the char
         * @default undefined
         */
        width?: number;
        /**
         * The height of the char
         * @default undefined
         */
        height?: number;
        /**
         * The segments of the char
         * @default undefined
         */
        paths?: Base.Point3[][];
      }
      declare class VectorTextData {
        constructor(width?: number, height?: number, chars?: VectorCharData[]);
        /**
         * The width of the char
         * @default undefined
         */
        width?: number;
        /**
         * The height of the char
         * @default undefined
         */
        height?: number;
        /**
         * The segments of the char
         * @default undefined
         */
        chars?: VectorCharData[];
      }
    }
    declare namespace OCCT {
      declare class ShapeWithId<U> {
        id: string;
        shape: U;
      }
      declare class ObjectDefinition<M, U> {
        compound?: U;
        shapes?: ShapeWithId<U>[];
        data?: M;
      }
      declare class TextWiresCharShapePart<T> {
        id?: string;
        shapes?: {
          compound?: T;
        };
      }
      declare class TextWiresDataDto<T> {
        type: string;
        name: string;
        compound?: T;
        characters?: TextWiresCharShapePart<T>[];
        width: number;
        height: number;
        center: Base.Point3;
      }
    }
  }

  declare namespace Things {
    declare namespace Enums {
      declare class LodDto {
        /**
         * Level of detail
         * @default low
         */
        lod: lodEnum;
      }
      declare enum lodEnum {
        low = "low",
        middle = "middle",
        high = "high",
      }
    }
    declare namespace Architecture {
      declare namespace Houses {
        declare namespace ZenHideout {
          declare class ZenHideoutData<T> {
            /**
             * Type of the object being configured
             */
            type: string;
            /**
             * Default name of the object
             */
            name: string;
            /**
             * Original inputs
             */
            originalInputs?: ZenHideoutDto;
            /**
             * Compounded shape representation of all of the geometric objects of the building
             */
            compound?: T;
            /**
             * All the shapes of the building
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
            /**
             * Representation of zen hideout parts that are useful for drawing the object efficiently
             */
            drawingPart?: ZenHideoutDrawingPart<T>;
            /**
             * Sandwitch parts that have inner and outer panels, can have windows and doors
             */
            sandwitchPartsBetweenColumns?: Things.Architecture.SandwitchPart<T>[];
            /**
             * Corner part panels forming 90 degree angle
             */
            cornerParts?: Things.Architecture.CornerPart<T>[];
            /**
             * Column parts of the building
             */
            columnParts?: Things.Architecture.ColumnPart<T>[];
            /**
             * Roof parts of the building. Contain all the upper geometry, together with beams and columns.
             */
            roofParts?: Things.Architecture.RoofPart<T>[];
            /**
             * Entrance corner part of the building, containing interior and exterior panels, staircase, and a corner window part
             */
            entranceCorner?: Things.Architecture.CornerEntrancePart<T>;
            /**
             * Terrace corner of the building, containing interior and exterior panels, staircase, and a corner window part
             */
            entranceTerrace?: Things.Architecture.CornerEntrancePart<T>;
            /**
             * Floor parts of the building
             */
            floors?: Things.Architecture.FloorPart<T>[];
            /**
             * Ceiling parts of the building
             */
            ceilings?: Things.Architecture.CeilingPart<T>[];
          }
          /**
           * This defines useful compounded objects for representing zen hideout in optimal and fast way.
           */
          declare class ZenHideoutDrawingPartShapes<T> {
            /**
             * The representation of all window glass objects in the building
             */
            windowGlassCompound?: T;
            /**
             * The representation of all glass frame objects in the building
             */
            glassFramesCompound?: T;
            /**
             * The representation of all window frame objects in the building
             */
            windowFrameCompound?: T;
            /**
             * The representation of all beam objects in the building
             */
            beamsCompound?: T;
            /**
             * The representation of all column objects in the building
             */
            columnsCompound?: T;
            /**
             * The representation of all exterior panels on the first floor
             * of the building
             */
            firstFloorExteriorPanelsCompound?: T;
            /**
             * The representation of all interior panels on the first floor
             * of the building
             */
            firstFloorInteriorPanelsCompound?: T;
            /**
             * The representation of all exterior panels on the roof
             * of the building
             */
            roofExteriorPanelsCompound?: T;
            /**
             * The representation of all interior panels on the roof
             * of the building
             */
            roofInteriorPanelsCompound?: T;
            /**
             * The representation of the first roof cover
             * of the building
             */
            roofCoverFirstCompound?: T;
            /**
             * The representation of the second roof cover
             * of the building
             */
            roofCoverSecondCompound?: T;
            /**
             * The representation of the floor
             * of the building
             */
            floorCompound?: T;
            /**
             * The representation of the ceiling
             * of the building
             */
            ceilingCompound?: T;
            /**
             * The representation of stairs
             */
            stairsCompound?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class ZenHideoutDrawingPart<T> {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?: ZenHideoutDrawingPartShapes<T>;
          }
          declare class ZenHideoutDtoBase<T, U, V> {
            widthFirstWing: T;
            lengthFirstWing: T;
            terraceWidth: T;
            widthSecondWing: T;
            lengthSecondWing: T;
            heightWalls: T;
            roofAngleFirstWing: T;
            roofAngleSecondWing: T;
            roofOffset: T;
            roofInsideOverhang: T;
            roofMaxDistAttachmentBeams: T;
            roofAttachmentBeamWidth: T;
            roofAttachmentBeamHeight: T;
            roofOutsideOverhang: T;
            columnSize: T;
            ceilingBeamHeight: T;
            ceilingBeamWidth: T;
            nrCeilingBeamsBetweenColumns: T;
            distBetweenColumns: T;
            floorHeight: T;
            groundLevel: T;
            facadePanelThickness: T;
            windowWidthOffset: T;
            windowHeightOffset: T;
            windowFrameThickness: T;
            windowGlassFrameThickness: T;
            lod: U;
            rotation?: T;
            origin?: V;
          }
          declare class ZenHideoutDto
            implements
              ZenHideoutDtoBase<
                number,
                Things.Enums.lodEnum,
                Inputs.Base.Point3
              >
          {
            constructor(
              widthFirstWing?: number,
              lengthFirstWing?: number,
              terraceWidth?: number,
              widthSecondWing?: number,
              lengthSecondWing?: number,
              heightWalls?: number,
              roofAngleFirstWing?: number,
              roofAngleSecondWing?: number,
              roofOffset?: number,
              roofInsideOverhang?: number,
              roofMaxDistAttachmentBeams?: number,
              roofAttachmentBeamWidth?: number,
              roofAttachmentBeamHeight?: number,
              roofOutsideOverhang?: number,
              columnSize?: number,
              ceilingBeamHeight?: number,
              ceilingBeamWidth?: number,
              nrCeilingBeamsBetweenColumns?: number,
              distBetweenColumns?: number,
              floorHeight?: number,
              groundLevel?: number,
              facadePanelThickness?: number,
              windowWidthOffset?: number,
              windowHeightOffset?: number,
              windowFrameThickness?: number,
              windowGlassFrameThickness?: number,
              lod?: Things.Enums.lodEnum,
              skinOpacity?: number,
              rotation?: number,
              origin?: Inputs.Base.Point3
            );
            /**
             * Width of the first wing of L shaped building
             * @default 4
             * @minimum 3
             * @maximum Infinity
             * @step 0.5
             */
            widthFirstWing: number;
            /**
             * Length of the first wing of L shaped building
             * @default 10
             * @minimum 3
             * @maximum Infinity
             * @step 0.5
             */
            lengthFirstWing: number;
            /**
             * Width of the terrace
             * @default 3
             * @minimum 1
             * @maximum Infinity
             * @step 0.25
             */
            terraceWidth: number;
            /**
             * Width of the second wing of L shaped building
             * @default 5
             * @minimum 3
             * @maximum Infinity
             * @step 0.5
             */
            widthSecondWing: number;
            /**
             * Length of the second wing of L shaped building
             * @default 10
             * @minimum 3
             * @maximum Infinity
             * @step 0.5
             */
            lengthSecondWing: number;
            /**
             * Height of the walls
             * @default 3
             * @minimum 3
             * @maximum Infinity
             * @step 0.1
             */
            heightWalls: number;
            /**
             * Height of the first wing end
             * @default 15
             * @minimum 5
             * @maximum Infinity
             * @step 5
             */
            roofAngleFirstWing: number;
            /**
             * Height of the first wing end
             * @default 25
             * @minimum 5
             * @maximum Infinity
             * @step 5
             */
            roofAngleSecondWing: number;
            /**
             * The offset to be applied to where the roof starts
             * @default 0.5
             * @minimum 0.2
             * @maximum Infinity
             * @step 0.25
             */
            roofOffset: number;
            /**
             * Roof overhang on the inside of the building (where the terrace is)
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.25
             */
            roofInsideOverhang: number;
            /**
             * Roof max distance between top attachment beams
             * @default 0.8
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.25
             */
            roofMaxDistAttachmentBeams: number;
            /**
             * Roof attachment beam width
             * @default 0.2
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.05
             */
            roofAttachmentBeamWidth: number;
            /**
             * Roof attachment beam height
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.05
             */
            roofAttachmentBeamHeight: number;
            /**
             * Roof overhang on the inside of the building
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.25
             */
            roofOutsideOverhang: number;
            /**
             * Column size
             * @default 0.3
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.1
             */
            columnSize: number;
            /** Ceiling beam height
             * @default 0.25
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.05
             */
            ceilingBeamHeight: number;
            /** Ceiling beam width
             * @default 0.1
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.05
             */
            ceilingBeamWidth: number;
            /** Nr ceiling beams between columns
             * @default 3
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrCeilingBeamsBetweenColumns: number;
            /** Distance between columns
             * @default 2
             * @minimum 0.5
             * @maximum Infinity
             * @step 0.25
             */
            distBetweenColumns: number;
            /** The height of the floor
             * @default 0.1
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.1
             */
            floorHeight: number;
            /** ground level from the floor
             * @default 0.6
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.1
             */
            groundLevel: number;
            /** Facade panel thickness
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            facadePanelThickness: number;
            /** Window width parameter
             * @default 0.1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            windowWidthOffset: number;
            /** Window bottom offset
             * @default 0.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            windowHeightOffset: number;
            /** Window frame thickness
             * @default 0.1
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            windowFrameThickness: number;
            /** Window glass frame thickness
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            windowGlassFrameThickness: number;
            /**
             * Level of detail to compute
             * @default high
             */
            lod: Things.Enums.lodEnum;
            /**
             * The opacity of the skin - only applied if lod is set to high
             * @default 1
             * @minimum 0
             * @maximum 1
             * @step 0.1
             */
            skinOpacity: number;
            /**
             * Rotation of the zen hideout
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Origin of the zen hideout
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
          }
        }
      }
      declare class BeamPart<T> {
        id?: string;
        name?: string;
        width?: number;
        length?: number;
        height?: number;
        shapes?: {
          beam?: T;
        };
      }
      declare class CeilingPart<T> {
        id?: string;
        name?: string;
        area?: number;
        thickness?: number;
        polygonPoints?: Inputs.Base.Point3[];
        shapes?: {
          compound?: T;
        };
      }
      declare class ColumnPart<T> {
        id?: string;
        name?: string;
        width?: number;
        length?: number;
        height?: number;
        shapes?: {
          column?: T;
        };
      }
      declare class CornerEntranceDto {
        /**
         * Width first wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        widthFirstWing: number;
        /**
         * Width second wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        widthSecondWing: number;
        /**
         * Length stair first wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        lengthStairFirstWing: number;
        /**
         * Length stair second wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        lengthStairSecondWing: number;
        /**
         * Length wall first wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        lengthWallFirstWing: number;
        /**
         * Length wall second wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        lengthWallSecondWing: number;
        /** Facade panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        facadePanelThickness: number;
        /** Wall thickness
         * @default 0.3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        wallThickness: number;
        /** Height of the walls on the exterior side
         * @default 3
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        wallHeightExterior: number;
        /** Height of the walls on the interior side
         * @default 3
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        wallHeightInterior: number;
        /** Window offset top
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        windowFrameOffsetTop: number;
        /** Window frame thickness
         * @default 0.1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        windowFrameThickness: number;
        /** Glass frame thickness
         * @default 0.1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        glassFrameThickness: number;
        /** Door width
         * @default 1
         * @minimum 0.7
         * @maximum Infinity
         * @step 0.1
         */
        doorWidth: number;
        /** Corner Window Width Offset
         * @default 0.3
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        windowWidthOffset: number;
        /** Stair total height
         * @default 1
         * @minimum 0.7
         * @maximum Infinity
         * @step 0.1
         */
        stairTotalHeight: number;
        /** Create stairs
         * @default false
         */
        createStair: boolean;
        /**
         * Flips the direction - outside things become inside and vice versa
         * @default false
         */
        flipDirection: boolean;
        /**
         * Rotation of the entrance
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the stairs
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Point3;
      }
      declare class CornerEntrancePart<T> {
        id?: string;
        name?: string;
        panelThickness?: number;
        widthPanelExteriorOne?: number;
        heightPanelsExterior?: number;
        stair?: CornerStairPart<T>;
        window?: WindowCornerPart<T>;
        shapes?: {
          compound?: T;
          panelExterior?: T;
          panelInterior?: T;
        };
      }
      declare class CornerPart<T> {
        /**
         * Unique id of the corner part
         */
        id?: string;
        /**
         * Name of the corner part
         */
        name?: string;
        /**
         * Width of the panel
         */
        widthPanel?: number;
        /**
         * Height of the panel
         */
        heightPanel?: number;
        /**
         * Thickness of the panel
         */
        thicknessPanel?: number;
        /**
         * Corner shapes
         */
        shapes?: {
          corner?: T;
        };
      }
      declare class CornerStairDto {
        /**
         * Inverts the side of the stair from going out to going inside of the L shape. This kind of stair can produce self intersecting result.
         * @default false
         */
        invert: boolean;
        /**
         * Width first wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        widthFirstLanding: number;
        /**
         * Width second wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        widthSecondLanding: number;
        /**
         * Length first wing
         * @default 2
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        lengthFirstWing: number;
        /**
         * Length second wing
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        lengthSecondWing: number;
        /**
         * Max wished step height
         * @default 0.25
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        maxWishedStepHeight: number;
        /**
         * Max wished step height
         * @default 0.25
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        stepHeightWidthProportion: number;
        /**
         * Total height of the corner stairs
         * @default 1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        totalHeight: number;
        /**
         * Rotation of the stairs
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the stairs
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Point3;
      }
      declare class CornerStairPart<T> extends CornerStairDto {
        id?: string;
        name?: string;
        steps?: number;
        stepWidth?: number;
        stepHeight?: number;
        shapes?: {
          stair?: T;
        };
      }
      declare class FloorPart<T> {
        id?: string;
        name?: string;
        area?: number;
        thickness?: number;
        polygonPoints?: Inputs.Base.Point3[];
        shapes?: {
          compound?: T;
        };
      }
      declare class ZenHideoutData<T> {
        /**
         * Type of the object being configured
         */
        type: string;
        /**
         * Default name of the object
         */
        name: string;
        /**
         * Original inputs
         */
        originalInputs?: ZenHideoutDto;
        /**
         * Compounded shape representation of all of the geometric objects of the building
         */
        compound?: T;
        /**
         * All the shapes of the building
         */
        shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
        /**
         * Representation of zen hideout parts that are useful for drawing the object efficiently
         */
        drawingPart?: ZenHideoutDrawingPart<T>;
        /**
         * Sandwitch parts that have inner and outer panels, can have windows and doors
         */
        sandwitchPartsBetweenColumns?: Things.Architecture.SandwitchPart<T>[];
        /**
         * Corner part panels forming 90 degree angle
         */
        cornerParts?: Things.Architecture.CornerPart<T>[];
        /**
         * Column parts of the building
         */
        columnParts?: Things.Architecture.ColumnPart<T>[];
        /**
         * Roof parts of the building. Contain all the upper geometry, together with beams and columns.
         */
        roofParts?: Things.Architecture.RoofPart<T>[];
        /**
         * Entrance corner part of the building, containing interior and exterior panels, staircase, and a corner window part
         */
        entranceCorner?: Things.Architecture.CornerEntrancePart<T>;
        /**
         * Terrace corner of the building, containing interior and exterior panels, staircase, and a corner window part
         */
        entranceTerrace?: Things.Architecture.CornerEntrancePart<T>;
        /**
         * Floor parts of the building
         */
        floors?: Things.Architecture.FloorPart<T>[];
        /**
         * Ceiling parts of the building
         */
        ceilings?: Things.Architecture.CeilingPart<T>[];
      }
      /**
       * This defines useful compounded objects for representing zen hideout in optimal and fast way.
       */
      declare class ZenHideoutDrawingPartShapes<T> {
        /**
         * The representation of all window glass objects in the building
         */
        windowGlassCompound?: T;
        /**
         * The representation of all glass frame objects in the building
         */
        glassFramesCompound?: T;
        /**
         * The representation of all window frame objects in the building
         */
        windowFrameCompound?: T;
        /**
         * The representation of all beam objects in the building
         */
        beamsCompound?: T;
        /**
         * The representation of all column objects in the building
         */
        columnsCompound?: T;
        /**
         * The representation of all exterior panels on the first floor
         * of the building
         */
        firstFloorExteriorPanelsCompound?: T;
        /**
         * The representation of all interior panels on the first floor
         * of the building
         */
        firstFloorInteriorPanelsCompound?: T;
        /**
         * The representation of all exterior panels on the roof
         * of the building
         */
        roofExteriorPanelsCompound?: T;
        /**
         * The representation of all interior panels on the roof
         * of the building
         */
        roofInteriorPanelsCompound?: T;
        /**
         * The representation of the first roof cover
         * of the building
         */
        roofCoverFirstCompound?: T;
        /**
         * The representation of the second roof cover
         * of the building
         */
        roofCoverSecondCompound?: T;
        /**
         * The representation of the floor
         * of the building
         */
        floorCompound?: T;
        /**
         * The representation of the ceiling
         * of the building
         */
        ceilingCompound?: T;
        /**
         * The representation of stairs
         */
        stairsCompound?: T;
      }
      /**
       * Information needed to draw the part in an optimal way
       */
      declare class ZenHideoutDrawingPart<T> {
        /**
         * Shapes that exist in the drawing part, T can represent opancascade geometry,
         * babylonjs mesh, materials or other things that map to these drawing categories.
         */
        shapes?: ZenHideoutDrawingPartShapes<T>;
      }
      declare class ZenHideoutDtoBase<T, U, V> {
        widthFirstWing: T;
        lengthFirstWing: T;
        terraceWidth: T;
        widthSecondWing: T;
        lengthSecondWing: T;
        heightWalls: T;
        roofAngleFirstWing: T;
        roofAngleSecondWing: T;
        roofOffset: T;
        roofInsideOverhang: T;
        roofMaxDistAttachmentBeams: T;
        roofAttachmentBeamWidth: T;
        roofAttachmentBeamHeight: T;
        roofOutsideOverhang: T;
        columnSize: T;
        ceilingBeamHeight: T;
        ceilingBeamWidth: T;
        nrCeilingBeamsBetweenColumns: T;
        distBetweenColumns: T;
        floorHeight: T;
        groundLevel: T;
        facadePanelThickness: T;
        windowWidthOffset: T;
        windowHeightOffset: T;
        windowFrameThickness: T;
        windowGlassFrameThickness: T;
        lod: U;
        rotation?: T;
        origin?: V;
      }
      declare class ZenHideoutDto
        implements
          ZenHideoutDtoBase<number, Things.Enums.lodEnum, Inputs.Base.Point3>
      {
        constructor(
          widthFirstWing?: number,
          lengthFirstWing?: number,
          terraceWidth?: number,
          widthSecondWing?: number,
          lengthSecondWing?: number,
          heightWalls?: number,
          roofAngleFirstWing?: number,
          roofAngleSecondWing?: number,
          roofOffset?: number,
          roofInsideOverhang?: number,
          roofMaxDistAttachmentBeams?: number,
          roofAttachmentBeamWidth?: number,
          roofAttachmentBeamHeight?: number,
          roofOutsideOverhang?: number,
          columnSize?: number,
          ceilingBeamHeight?: number,
          ceilingBeamWidth?: number,
          nrCeilingBeamsBetweenColumns?: number,
          distBetweenColumns?: number,
          floorHeight?: number,
          groundLevel?: number,
          facadePanelThickness?: number,
          windowWidthOffset?: number,
          windowHeightOffset?: number,
          windowFrameThickness?: number,
          windowGlassFrameThickness?: number,
          lod?: Things.Enums.lodEnum,
          skinOpacity?: number,
          rotation?: number,
          origin?: Inputs.Base.Point3
        );
        /**
         * Width of the first wing of L shaped building
         * @default 4
         * @minimum 3
         * @maximum Infinity
         * @step 0.5
         */
        widthFirstWing: number;
        /**
         * Length of the first wing of L shaped building
         * @default 10
         * @minimum 3
         * @maximum Infinity
         * @step 0.5
         */
        lengthFirstWing: number;
        /**
         * Width of the terrace
         * @default 3
         * @minimum 1
         * @maximum Infinity
         * @step 0.25
         */
        terraceWidth: number;
        /**
         * Width of the second wing of L shaped building
         * @default 5
         * @minimum 3
         * @maximum Infinity
         * @step 0.5
         */
        widthSecondWing: number;
        /**
         * Length of the second wing of L shaped building
         * @default 10
         * @minimum 3
         * @maximum Infinity
         * @step 0.5
         */
        lengthSecondWing: number;
        /**
         * Height of the walls
         * @default 3
         * @minimum 3
         * @maximum Infinity
         * @step 0.1
         */
        heightWalls: number;
        /**
         * Height of the first wing end
         * @default 15
         * @minimum 5
         * @maximum Infinity
         * @step 5
         */
        roofAngleFirstWing: number;
        /**
         * Height of the first wing end
         * @default 25
         * @minimum 5
         * @maximum Infinity
         * @step 5
         */
        roofAngleSecondWing: number;
        /**
         * The offset to be applied to where the roof starts
         * @default 0.5
         * @minimum 0.2
         * @maximum Infinity
         * @step 0.25
         */
        roofOffset: number;
        /**
         * Roof overhang on the inside of the building (where the terrace is)
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.25
         */
        roofInsideOverhang: number;
        /**
         * Roof max distance between top attachment beams
         * @default 0.8
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.25
         */
        roofMaxDistAttachmentBeams: number;
        /**
         * Roof attachment beam width
         * @default 0.2
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        roofAttachmentBeamWidth: number;
        /**
         * Roof attachment beam height
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        roofAttachmentBeamHeight: number;
        /**
         * Roof overhang on the inside of the building
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.25
         */
        roofOutsideOverhang: number;
        /**
         * Column size
         * @default 0.3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        columnSize: number;
        /** Ceiling beam height
         * @default 0.25
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        ceilingBeamHeight: number;
        /** Ceiling beam width
         * @default 0.1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        ceilingBeamWidth: number;
        /** Nr ceiling beams between columns
         * @default 3
         * @minimum 1
         * @maximum Infinity
         * @step 1
         */
        nrCeilingBeamsBetweenColumns: number;
        /** Distance between columns
         * @default 2
         * @minimum 0.5
         * @maximum Infinity
         * @step 0.25
         */
        distBetweenColumns: number;
        /** The height of the floor
         * @default 0.1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        floorHeight: number;
        /** ground level from the floor
         * @default 0.6
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        groundLevel: number;
        /** Facade panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        facadePanelThickness: number;
        /** Window width parameter
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        windowWidthOffset: number;
        /** Window bottom offset
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        windowHeightOffset: number;
        /** Window frame thickness
         * @default 0.1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        windowFrameThickness: number;
        /** Window glass frame thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        windowGlassFrameThickness: number;
        /**
         * Level of detail to compute
         * @default high
         */
        lod: Things.Enums.lodEnum;
        /**
         * The opacity of the skin - only applied if lod is set to high
         * @default 1
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        skinOpacity: number;
        /**
         * Rotation of the zen hideout
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 10
         */
        rotation: number;
        /**
         * Origin of the zen hideout
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Point3;
      }
      declare class RoofBeamsPart<T> {
        beamsCeiling?: BeamPart<T>[];
        beamsVerticalHigh?: BeamPart<T>[];
        beamsVerticalLow?: BeamPart<T>[];
        beamsTop?: BeamPart<T>[];
        beamsAttachment: BeamPart<T>[];
        shapes?: {
          compound?: T;
        };
      }
      declare class RoofCoverOneSidedDto {
        /**
         * Roof cover name
         * @default roof-cover
         */
        name: string;
        /**
         * Roof angle
         * @default 15
         * @minimum 0
         * @maximum Infinity
         * @step 5
         */
        roofAngle: number;
        /**
         * Roof length
         * @default 3
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        roofLength: number;
        /**
         * Roof width along the angle part, total width contains roof inside and outside overhangs
         * @default 3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        roofWidth: number;
        /**
         * Roof outside overhang
         * @default 0.5
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        roofOutsideOverhang: number;
        /**
         * Roof inside overhang
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        roofInsideOverhang: number;
        /**
         * Roof overhang facade
         * @default 0.1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        roofOverhangFacade: number;
        /**
         * Roof thickness
         * @default 0.05
         * @minimum 0.001
         * @maximum Infinity
         * @step 0.01
         */
        roofThickness: number;
        /**
         * Roof cover height
         * @default 0.3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        roofCoverHeight: number;
        /**
         * Rotation of the window
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Level of detail
         * @default high
         */
        lod: Things.Enums.lodEnum;
        /**
         * Origin of the stairs
         * @default [0, 0, 0]
         */
        center: Inputs.Base.Point3;
        /**
         * Direction of the window
         * @default [0, 1, 0]
         */
        direction: Inputs.Base.Vector3;
      }
      declare class RoofCoverPart<T> extends RoofCoverOneSidedDto {
        id?: string;
        shapes?: {
          compound?: T;
        };
      }
      declare class RoofPanelPart<T> {
        id?: string;
        name?: string;
        innerPanels?: SandwitchPart<T>[];
        innerFillPanels?: SandwitchPart<T>[];
        outerPanels?: SandwitchPart<T>[];
        outerFillPanels?: SandwitchPart<T>[];
        ends?: SandwitchPartFlex<T>[];
        shapes?: {
          compoundInnerExteriorPanels?: T;
          compoundInnerInteriorPanels?: T;
          compoundInnerFillExteriorPanels?: T;
          compoundInnerFillInteriorPanels?: T;
          compoundOuterExteriorPanels?: T;
          compoundOuterInteriorPanels?: T;
          compoundOuterFillExteriorPanels?: T;
          compoundOuterFillInteriorPanels?: T;
          compoundEndsInteriorPanels?: T;
          compoundEndsExteriorPanels?: T;
          compound?: T;
        };
      }
      declare class RoofPart<T> {
        id?: string;
        name?: string;
        beams: RoofBeamsPart<T>;
        panels?: RoofPanelPart<T>;
        covers?: RoofCoverPart<T>[];
        shapes?: {
          compound?: T;
        };
      }
      declare class SandwitchPanelDto {
        /** Name of the sandwitch panel
         * @default sandwitch-panel
         */
        name: string;
        /** Indicates wether a window should be created
         * @default true
         */
        createWindow: boolean;
        /** Indicates wether the inner panel should be created
         * @default true
         */
        createInnerPanel: boolean;
        /** Indicates wether the exterior panel should be created
         * @default true
         */
        createExteriorPanel: boolean;
        /** Wall thickness
         * @default 0.3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        wallWidth: number;
        /** Exterior panel width
         * @default 0.4
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        exteriorPanelWidth: number;
        /** Exterior panel height
         * @default 3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        exteriorPanelHeight: number;
        /** Exterior panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        exteriorPanelThickness: number;
        /** Exterior panel bottom offset
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        exteriorPanelBottomOffset: number;
        /** Interior panel width
         * @default 0.4
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        interiorPanelWidth: number;
        /** Interior panel height
         * @default 3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        interiorPanelHeight: number;
        /** Interior panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        interiorPanelThickness: number;
        /** Interior panel bottom offset
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        interiorPanelBottomOffset: number;
        /** Window width parameter
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        windowWidthOffset: number;
        /** Window bottom offset
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        windowHeightOffset: number;
        /** Window frame thickness
         * @default 0.1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        windowFrameThickness: number;
        /** Window glass frame thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        windowGlassFrameThickness: number;
      }
      declare class SandwitchPanelFlexDto {
        /** Name of the sandwitch panel
         * @default sandwitch-panel
         */
        name: string;
        /** Indicates wether a window should be created
         * @default true
         */
        createInteriorPanel: boolean;
        /** Indicates wether the exterior panel should be created
         * @default true
         */
        createExteriorPanel: boolean;
        /** Wall thickness
         * @default 0.3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        wallWidth: number;
        /** Exterior panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        exteriorPanelThickness: number;
        /** Interior panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        interiorPanelThickness: number;
        /**
         * Interior wall panel polygon points
         * @default []
         */
        interiorPanelPolygonPoints: Inputs.Base.Point2[];
        /**
         * Exterior wall panel polygon points
         * @default []
         */
        exteriorPanelPolygonPoints: Inputs.Base.Point2[];
      }
      declare class SandwitchPart<T> extends SandwitchPanelDto {
        id?: string;
        rotation?: number;
        center?: Inputs.Base.Point3;
        direction?: Inputs.Base.Vector3;
        windows?: WindowRectangularPart<T>[];
        shapes?: {
          panelExterior?: T;
          panelInterior?: T;
          compound?: T;
        };
      }
      declare class SandwitchPartFlex<T> extends SandwitchPanelFlexDto {
        id?: string;
        rotation?: number;
        center?: Inputs.Base.Point3;
        direction?: Inputs.Base.Vector3;
        windows?: WindowRectangularPart<T>[];
        shapes?: {
          panelExterior?: T;
          panelInterior?: T;
          compound?: T;
        };
      }
      declare class WindowCornerDto {
        /** Wall thickness
         * @default 0.4
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        wallThickness: number;
        /** Facade panel thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        facadePanelThickness: number;
        /** Glass frame thickness
         * @default 0.02
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        glassFrameThickness: number;
        /** Glass thickness
         * @default 0.005
         * @minimum 0.001
         * @maximum Infinity
         * @step 0.001
         */
        glassThickness: number;
        /** Frame thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        frameThckness: number;
        /** Window height
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        height: number;
        /** Length first window
         * @default 1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        lengthFirst: number;
        /** Length second window
         * @default 1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        lengthSecond: number;
        /**
         * Rotation of the window
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the stairs
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Point3;
      }
      declare class WindowPartShapes<T> {
        /**
         * Cutout of the window - this can be used to make the hole in the wall and usually should not be visualised
         */
        cutout?: T;
        /**
         * Shape of the glass of the window
         */
        glass?: T;
        /**
         * Glass frame of the window
         */
        glassFrame?: T;
        /**
         * Frame of the window that usually is as thick as the wall and that touches glass frame
         */
        frame?: T;
        /**
         * Compounded shape of the window with all other shapes joined together
         */
        compound?: T;
      }
      declare class WindowRectangularPart<T> extends WindowRectangularDto {
        /**
         * The name of the window part
         */
        name: string;
        /**
         * The unique id of the window part
         */
        id?: string;
        /**
         * Generic shapes that represent the window part
         */
        shapes?: WindowPartShapes<T>;
      }
      declare class WindowCornerPart<T> extends WindowCornerDto {
        /**
         * The name of the window part
         */
        name: string;
        /**
         * The unique id of the window part
         */
        id?: string;
        /**
         * Generic shapes that represent the window part
         */
        shapes?: WindowPartShapes<T>;
      }
      declare class WindowRectangularDto {
        /** Window thickness
         * @default 0.3
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.05
         */
        thickness: number;
        /** Glass frame thickness
         * @default 0.02
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        glassFrameThickness: number;
        /** Glass thickness
         * @default 0.005
         * @minimum 0.001
         * @maximum Infinity
         * @step 0.001
         */
        glassThickness: number;
        /** Frame thickness
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        frameThickness: number;
        /** Window height
         * @default 0.05
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        height: number;
        /** Width first window
         * @default 1
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        width: number;
        /**
         * Rotation of the window
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the stairs
         * @default [0, 0, 0]
         */
        center: Inputs.Base.Point3;
        /**
         * Direction of the window
         * @default [0, 1, 0]
         */
        direction: Inputs.Base.Vector3;
      }
    }
    declare namespace KidsCorner {
      declare namespace BirdHouses {
        declare namespace WingtipVilla {
          declare class WingtipVillaData<T> {
            type: string;
            name: string;
            compound?: T;
            roof: {
              compound: T;
              shapes: T[];
            };
            walls: {
              compound: T;
              shapes: T[];
            };
            stick: {
              shape: T;
            };
            floor: {
              shape: T;
            };
            chimney: {
              shape: T;
            };
            basicPoints: {
              kind: string;
              point: Inputs.Base.Point3;
            }[];
          }
          declare class WingtipVillaDto {
            constructor(
              interiorWidth?: number,
              interiorLength?: number,
              interiorHeight?: number,
              thickness?: number,
              holeDiameter?: number,
              holeDistToBottom?: number,
              stickLength?: number,
              stickDiameter?: number,
              baseAttachmentHeight?: number,
              roofOverhang?: number,
              rotation?: number,
              chimneyHeight?: number,
              origin?: Inputs.Base.Point3
            );
            /**
             * Width of the house
             * @default 3
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            interiorWidth: number;
            /**
             * Interior length of the house
             * @default 3
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            interiorLength: number;
            /**
             * Interior height that goes from the floor to where the roof starts
             * @default 5
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            interiorHeight: number;
            /**
             * thickness of the house
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            thickness: number;
            /**
             * hole diameter of the house
             * @default 1.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            holeDiameter: number;
            /**
             * hole distance to the bottom of the house
             * @default 2.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            holeDistToBottom: number;
            /**
             * stick length
             * @default 1.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            stickLength: number;
            /**
             * stick diameter
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            stickDiameter: number;
            /**
             * base attachment height
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            baseAttachmentHeight: number;
            /**
             * roof overhang
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            roofOverhang: number;
            /**
             * Rotation of the bird house around the origin.
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Chimney height
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            chimneyHeight: number;
            /**
             * Origin of the bird house (where the bird house would be attached to the tree or the wall)
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
          }
        }
        declare namespace ChirpyChalet {
          declare class ChirpyChaletData<T> {
            type: string;
            name: string;
            compound?: T;
            roof: {
              compound: T;
              shapes: T[];
            };
            walls: {
              compound: T;
              shapes: T[];
            };
            stick: {
              shape: T;
            };
            floor: {
              shape: T;
            };
            basicPoints: {
              kind: string;
              point: Inputs.Base.Point3;
            }[];
          }
          declare class ChirpyChaletDto {
            constructor(
              interiorWidth?: number,
              interiorLength?: number,
              interiorHeight?: number,
              thickness?: number,
              holeDiameter?: number,
              holeDistToBottom?: number,
              stickLength?: number,
              stickDiameter?: number,
              baseAttachmentHeight?: number,
              roofOverhang?: number,
              roofAngle?: number,
              rotation?: number,
              origin?: Inputs.Base.Point3
            );
            /**
             * Width of the house
             * @default 3
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            interiorWidth: number;
            /**
             * Interior length of the house
             * @default 3
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            interiorLength: number;
            /**
             * Interior height that goes from the floor to where the roof starts
             * @default 5
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            interiorHeight: number;
            /**
             * thickness of the house
             * @default 0.3
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            thickness: number;
            /**
             * hole diameter of the house
             * @default 1.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            holeDiameter: number;
            /**
             * hole distance to the bottom of the house
             * @default 2.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            holeDistToBottom: number;
            /**
             * stick length
             * @default 0.9
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            stickLength: number;
            /**
             * stick diameter
             * @default 0.3
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            stickDiameter: number;
            /**
             * base attachment height
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            baseAttachmentHeight: number;
            /**
             * roof overhang
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.5
             */
            roofOverhang: number;
            /**
             * roof overhang
             * @default 20
             * @minimum 0
             * @maximum 80
             * @step 5
             */
            roofAngle: number;
            /**
             * Rotation of the bird house around the origin.
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Origin of the bird house (where the bird house would be attached to the tree or the wall)
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
          }
        }
      }
    }

    declare namespace ThreeDPrinting {
      declare namespace Vases {
        declare namespace SerenitySwirl {
          declare class SerenitySwirlData<T> {
            type: string;
            name: string;
            compound?: T;
          }
          declare class SerenitySwirlDto {
            constructor(
              swirl?: number,
              nrOfDivisions?: number,
              addRadiusNarrow?: number,
              addRadiusWide?: number,
              addMiddleHeight?: number,
              addTopHeight?: number,
              thickness?: number,
              rotation?: number,
              origin?: Inputs.Base.Point3
            );
            /**
             * Swirl 0 - no swirl 1 max swirl
             * @default 0.6
             * @minimum 0
             * @maximum 1
             * @step 0.1
             */
            swirl: number;
            /**
             * Nr of divisions
             * @default 10
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrOfDivisions: number;
            /**
             * Add to narrow radius
             * @default 0.4
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            addRadiusNarrow: number;
            /**
             * Add to radius wide
             * @default 0.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            addRadiusWide: number;
            /**
             * Add to middle height
             * @default 1.6
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            addMiddleHeight: number;
            /**
             * Add to top height
             * @default 1.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            addTopHeight: number;
            /**
             * Thickness of the vase on the widest part
             * @default 1
             * @minimum 0
             * @maximum 1
             * @step 0.1
             */
            thickness: number;
            /**
             * Rotation of the serenity swirl
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Origin of the vase
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
          }
        }
        declare namespace ArabicArchway {
          declare class ArabicArchwayData<T> {
            /**
             * Type of the object being configured
             */
            type: string;
            /**
             * Default name of the object
             */
            name: string;
            /**
             * Compound shape of all the parts
             */
            compound?: T;
            /**
             * Original inputs
             */
            originalInputs: ArabicArchwayDto;
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
            /**
             * Representation of arabic archway parts that are useful for drawing the object efficiently
             */
            drawingPart?: ArabicArchwayDrawingPart<T>;
          }
          declare class ArabicArchwayDrawingPartShapes<T> {
            /**
             * The representation of all objects in the vase
             */
            compound?: T;
            /**
             * The representation of all vase part objects in the vase
             */
            vasePartsCompound?: T;
            /**
             * The representation of all glass objects in the vase
             */
            glassPartsCompound?: T;
            /**
             * The representation of the base of the vase
             */
            vaseBaseCompound?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class ArabicArchwayDrawingPart<T> {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?:
              | ArabicArchwayDrawingPartShapes<T>
              | {
                  [x: string]: T;
                };
          }
          declare class ArabicArchwayDtoBase<T, V, P, U, B> {
            profilePoints?: P;
            nrOfSides: T;
            nrOfVerticalArches: T;
            thickness: T;
            edgesThickness: T;
            archCenterThickness: T;
            baseHeight: T;
            patchHoles: B;
            lod?: U;
            rotation?: T;
            direction?: V;
            scale?: V;
            origin?: V;
          }
          declare class ArabicArchwayDto
            implements
              ArabicArchwayDtoBase<
                number,
                Inputs.Base.Point3,
                Inputs.Base.Point3[],
                Things.Enums.lodEnum,
                boolean
              >
          {
            constructor(
              nrOfSides?: number,
              nrOfVerticalArches?: number,
              archCenterThickness?: number,
              edgesThickness?: number,
              thickness?: number,
              baseHeight?: number,
              patchHoles?: boolean,
              lod?: Things.Enums.lodEnum,
              rotation?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Point3,
              scale?: Inputs.Base.Vector3
            );
            /**
             * nr of sides for arabic archway vase
             * @default [[2, 0, 0],[4, 5, 0],[1.5, 10, 0],[2, 14, 0]]
             */
            profilePoints: Inputs.Base.Point3[];
            /**
             * nr of sides for arabic archway vase
             * @default 3
             * @minimum 3
             * @maximum 30
             * @step 1
             */
            nrOfSides: number;
            /**
             * nr of vertical arches
             * @default 6
             * @minimum 2
             * @maximum 30
             * @step 1
             */
            nrOfVerticalArches: number;
            /**
             * Arch center thickness
             * @default 0.8
             * @minimum 0
             * @maximum 10
             * @step 0.1
             */
            archCenterThickness: number;
            /**
             * Edges thickness
             * @default 0.2
             * @minimum 0
             * @maximum 10
             * @step 0.1
             */
            edgesThickness: number;
            /**
             * Thickness of the vase on the widest part
             * @default 1
             * @minimum 0
             * @maximum 1
             * @step 0.1
             */
            thickness: number;
            /**
             * Indicates how high the base should be, if 0 then no base will be made
             * @default 0.4
             * @minimum 0
             * @maximum 10
             * @step 0.1
             */
            baseHeight: number;
            /**
             * Indicates whether holes of the vase should be patched
             * @default true
             */
            patchHoles: boolean;
            /**
             * Level of details for the model
             * @default high
             */
            lod: Things.Enums.lodEnum;
            /**
             * Rotation of the serenity swirl
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Origin of the vase
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the vase
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Point3;
            /**
             * Scale of the vase
             * @default [1, 1, 1]
             */
            scale: Inputs.Base.Vector3;
          }
        }
      }
      declare namespace Cups {
        declare namespace CalmCup {
          declare class CalmCupData<T> {
            type: string;
            name: string;
            originalInputs: CalmCupDto;
            compound?: T;
          }
          declare class CalmCupDtoBase<T, U> {
            height: T;
            radiusBottom: T;
            radiusTopOffset: T;
            thickness: T;
            fillet: T;
            nrOfHandles: T;
            handleDist: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class CalmCupDto
            implements CalmCupDtoBase<number, Inputs.Base.Point3>
          {
            constructor(
              height?: number,
              radiusBottom?: number,
              radiusTopOffset?: number,
              thickness?: number,
              fillet?: number,
              nrOfHandles?: number,
              handleDist?: number,
              precision?: number,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the cup
             * @default 6
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.1
             */
            height: number;
            /**
             * Radius top offset
             * @default 4
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusBottom: number;
            /**
             * Radius top offset
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusTopOffset: number;
            /**
             * Thickness of the cup
             * @default 0.6
             * @minimum 0.05
             * @maximum 3
             * @step 0.01
             */
            thickness: number;
            /**
             * Fillet of the cup
             * @default 0.2
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            fillet: number;
            /**
             * Nr of handles, 0 will create a cup without handles
             * @default 1
             * @minimum 0
             * @maximum 2
             * @step 1
             */
            nrOfHandles: number;
            /**
             * Handle distance from the cup
             * @default 2
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.1
             */
            handleDist: number;
            /**
             * Meshing precision of the drawn model. Scale scales precision as well. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Rotation of the cup
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the cup - affects edge width and precision
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
        }
        declare namespace DragonCup {
          declare class DragonCupData<T> {
            type: string;
            name: string;
            originalInputs: DragonCupDto;
            compound?: T;
          }
          declare class DragonCupDtoBase<T, U> {
            height: T;
            radiusBottom: T;
            radiusTopOffset: T;
            radiusMidOffset: T;
            rotationMidAngle: T;
            rotationTopAngle: T;
            thickness: T;
            bottomThickness: T;
            nrSkinCellsHorizontal: T;
            nrSkinCellsVertical: T;
            nrSkinCellDivisionsTop: T;
            nrSkinCellDivisionsBottom: T;
            skinCellOuterHeight: T;
            skinCellInnerHeight: T;
            skinCellBottomHeight: T;
            skinCellTopHeight: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class DragonCupDto
            implements DragonCupDtoBase<number, Inputs.Base.Point3>
          {
            constructor(
              height?: number,
              radiusBottom?: number,
              radiusTopOffset?: number,
              radiusMidOffset?: number,
              rotationTopAngle?: number,
              rotationMidAngle?: number,
              nrSkinCellsVertical?: number,
              nrSkinCellsHorizontal?: number,
              nrSkinCellDivisionsTop?: number,
              nrSkinCellDivisionsBottom?: number,
              skinCellOuterHeight?: number,
              skinCellInnerHeight?: number,
              skinCellBottomHeight?: number,
              skinCellTopHeight?: number,
              thickness?: number,
              bottomThickness?: number,
              precision?: number,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the cup
             * @default 6
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.1
             */
            height: number;
            /**
             * Radius top offset
             * @default 4
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusBottom: number;
            /**
             * Radius top offset
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusTopOffset: number;
            /**
             * Radius middle offset
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusMidOffset: number;
            /**
             * Rotation of the top from the middle (angle in degrees)
             * @default 20
             * @minimum -90
             * @maximum 90
             * @step 1
             */
            rotationTopAngle: number;
            /**
             * Rotation of the middle from the bottom (angle in degrees)
             * @default 20
             * @minimum -90
             * @maximum 90
             * @step 1
             */
            rotationMidAngle: number;
            /**
             * Nr of skin cells along vertical direction
             * @default 5
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrSkinCellsVertical: number;
            /**
             * Nr of skin cells along horizontal direction
             * @default 10
             * @minimum 3
             * @maximum Infinity
             * @step 1
             */
            nrSkinCellsHorizontal: number;
            /**
             * Nr of skin cell divisions on the top of the cup
             * @default 1
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrSkinCellDivisionsTop: number;
            /**
             * Nr of skin cell divisions on the bottom of the cup
             * @default 3
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrSkinCellDivisionsBottom: number;
            /**
             * skin cell outer height
             * @default 0.4
             * @minimum -Infinity
             * @maximum Infinity
             * @step 0.01
             */
            skinCellOuterHeight: number;
            /**
             * skin cell inner height
             * @default 0.3
             * @minimum -Infinity
             * @maximum Infinity
             * @step 0.01
             */
            skinCellInnerHeight: number;
            /**
             * skin cell bottom height
             * @default 0.4
             * @minimum -Infinity
             * @maximum Infinity
             * @step 0.01
             */
            skinCellBottomHeight: number;
            /**
             * skin cell top height
             * @default 0.4
             * @minimum -Infinity
             * @maximum Infinity
             * @step 0.01
             */
            skinCellTopHeight: number;
            /**
             * Thickness of the cup
             * @default 0.6
             * @minimum 0.05
             * @maximum Infinity
             * @step 0.01
             */
            thickness: number;
            /**
             * Bottom thickness of the cup
             * @default 1
             * @minimum 0.05
             * @maximum Infinity
             * @step 0.01
             */
            bottomThickness: number;
            /**
             * Meshing precision of the drawn model. Scale scales precision as well. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Rotation of the cup
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the cup - affects edge width and precision
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class DragonCupModelDto<T> {
            /**
             * The model that represents result of the dragon cup
             * @default undefined
             */
            model: DragonCupData<T>;
          }
        }
      }
      declare namespace Boxes {
        declare namespace SpicyBox {
          declare class SpicyBoxData<T> {
            type: string;
            name: string;
            originalInputs: SpicyBoxDto;
            compound?: T;
          }
          declare class SpicyBoxDtoBase<T, U, V, Z> {
            textTop: V;
            textFront: V;
            height: T;
            coverHeight: T;
            baseHeight: T;
            radiusBase: T;
            radiusOffset: T;
            thickness: T;
            ornamentalThickness: T;
            nrOrnamnetsPerSide: T;
            invertOrnaments: Z;
            fillet: T;
            nrSides: T;
            nrOffsets: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class SpicyBoxDto
            implements
              SpicyBoxDtoBase<number, Inputs.Base.Point3, string, boolean>
          {
            constructor(
              textTop?: string,
              textFront?: string,
              nrSides?: number,
              nrOffsets?: number,
              height?: number,
              coverHeight?: number,
              baseHeight?: number,
              radiusBottom?: number,
              radiusTopOffset?: number,
              thickness?: number,
              ornamentalThickness?: number,
              nrOrnamnetsPerSide?: number,
              invertOrnaments?: boolean,
              fillet?: number,
              precision?: number,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Text on the top of the box
             * @default Pepper
             */
            textTop: string;
            /**
             * Text on the front of the box
             * @default For Your Spicy Needs
             */
            textFront: string;
            /**
             * Nr of sides of the box
             * @default 4
             * @minimum 3
             * @maximum 16
             * @step 1
             */
            nrSides: number;
            /**
             * Nr vertical offsets
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            nrOffsets: number;
            /**
             * Height of the cup
             * @default 6
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.1
             */
            height: number;
            /**
             * Radius top offset
             * @default 4
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusBase: number;
            /**
             * Radius top offset
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            radiusOffset: number;
            /**
             * Cover height
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            coverHeight: number;
            /**
             * Base height
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            baseHeight: number;
            /**
             * Thickness of the cup
             * @default 0.6
             * @minimum 0.05
             * @maximum Infinity
             * @step 0.01
             */
            thickness: number;
            /**
             * Ornamental thickness
             * @default 0.1
             * @minimum 0.05
             * @maximum Infinity
             * @step 0.01
             */
            ornamentalThickness: number;
            /**
             * Ornamental thickness
             * @default 10
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrOrnamnetsPerSide: number;
            /**
             * Inverst the ornaments
             * @default false
             */
            invertOrnaments: boolean;
            /**
             * Fillet of the cup
             * @default 0.2
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            fillet: number;
            /**
             * Meshing precision of the drawn model. Scale scales precision as well. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Rotation of the cup
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the cup - affects edge width and precision
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class SpicyBoxModelDto<T> {
            /**
             * The model that represents result of the spicy box
             * @default undefined
             */
            model: SpicyBoxData<T>;
          }
        }
      }
      declare namespace Medals {
        declare namespace EternalLove {
          declare class EternalLoveData<T> {
            type: string;
            name: string;
            originalInputs: EternalLoveDto;
            compound?: T;
          }
          declare class EternalLoveDtoBase<T, U, B, V> {
            textHeading: T;
            textName: T;
            fullModel: B;
            thickness: U;
            decorationThickness: U;
            rotation?: U;
            origin?: V;
            direction?: V;
          }
          declare class EternalLoveDto
            implements
              EternalLoveDtoBase<string, number, boolean, Inputs.Base.Point3>
          {
            constructor(
              textHeading?: string,
              textName?: string,
              fullModel?: boolean,
              thickness?: number,
              decorationThickness?: number,
              rotation?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * The head text
             * @default LOVE YOU
             */
            textHeading: string;
            /**
             * Name of the person
             * @default NORA
             */
            textName: string;
            /**
             * Choose whether to produce half of the model (better for 3d printing) or full model with two sides
             * @default true
             */
            fullModel: boolean;
            /**
             * Thickness of the model
             * @default 6
             * @minimum 0.5
             * @maximum 20
             * @step 0.1
             */
            thickness: number;
            /**
             * Additional thickness of the decorations
             * @default 1
             * @minimum 0.1
             * @maximum 3
             * @step 0.1
             */
            decorationThickness: number;
            /**
             * Rotation of the erenal love medal
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
        }
      }
      declare namespace Desktop {
        declare namespace PhoneNest {
          declare class PhoneNestData<T> {
            type: string;
            /**
             * The name of the model
             */
            name: string;
            /**
             * Original inputs that were used to create the model
             */
            originalInputs: PhoneNestDto;
            /**
             * Compound shape of the table geometry
             */
            compound?: T;
            /**
             * Representation of table parts that are useful for drawing the object efficiently
             */
            drawingPart?: PhoneNestDrawingPart<T>;
            /**
             * Data that contains information and shapes of the top part of the table
             */
            mainPart?: PhoneNestMainPart<T>;
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
          }
          declare class PhoneNestDrawDto<T> {
            /**
             * Main material
             * @defaul undefined
             * @optional true
             */
            mainMaterial?: T;
            /**
             * Phone material
             * @defaul undefined
             * @optional true
             */
            phoneMaterial?: T;
            /**
             * You can turn off drawing of faces via this property
             * @default true
             */
            drawFaces: boolean;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Hex colour string for the edges
             * @default #ffffff
             */
            edgeColour: Inputs.Base.Color;
            /**
             * Edge width
             * @default 0.06
             * @minimum 0
             * @maximum Infinity
             */
            edgeWidth: number;
          }
          /**
           * This defines useful compounded objects for representing model in optimal and fast way.
           */
          declare class PhoneNestDrawingPartShapes<T> {
            /**
             * The representation of main part of the table
             */
            main?: T;
            /**
             * The representation of the glass of the table
             */
            phone?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class PhoneNestDrawingPart<T> extends Part {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?: PhoneNestDrawingPartShapes<T>;
          }
          declare class PhoneNestDtoBase<T, U, B> {
            heightBottom: T;
            heightTop: T;
            widthBack: T;
            widthFront: T;
            length: T;
            backOffset: T;
            thickness: T;
            filletRadius: T;
            applyOrnaments: B;
            phoneHeight: T;
            phoneWidth: T;
            phoneThickness: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class PhoneNestDto
            implements PhoneNestDtoBase<number, Inputs.Base.Point3, boolean>
          {
            constructor(
              heightBottom?: number,
              heightTop?: number,
              widthBack?: number,
              widthFront?: number,
              length?: number,
              backOffset?: number,
              thickness?: number,
              applyOrnaments?: boolean,
              filletRadius?: number,
              phoneHeight?: number,
              phoneWidth?: number,
              phoneThickness?: number,
              precision?: number,
              drawEdges?: boolean,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the phone holder at the bottom
             * @default 5
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            heightBottom: number;
            /**
             * Height of the phone holder at the top
             * @default 16
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            heightTop: number;
            /**
             * Width of the phone holder on the back
             * @default 25
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            widthBack: number;
            /**
             * Width of the phone holder on the front and holder
             * @default 10
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            widthFront: number;
            /**
             * Length of the holder base
             * @default 16
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            length: number;
            /**
             * The back offset
             * @default 6
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            backOffset: number;
            /**
             * The thickness of the table
             * @default 0.4
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            thickness: number;
            /**
             * Apply final ornaments
             * @default false
             */
            applyOrnaments: boolean;
            /**
             * The radius of the fillet
             * @default 2
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.1
             */
            filletRadius: number;
            /**
             * The height of the phone
             * @default 16.8
             * @minimum 0
             * @maximum Infinitypho
             * @step 0.01
             */
            phoneHeight: number;
            /**
             * The width of the phone
             * @default 7.8
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            phoneWidth: number;
            /**
             * The thickness of the phone
             * @default 0.7
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            phoneThickness: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Rotation of the table in degrees
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class PhoneNestModelDto<T> {
            /**
             * The model that represents result of the good coffee table create operation
             * @default undefined
             */
            model: PhoneNestData<T>;
          }
          declare class PhoneNestMainPart<T> extends Part {
            shapes?: {
              phone?: T;
              main?: T;
              compound?: T;
            };
          }
        }
      }
    }

    declare namespace LaserCutting {
      declare namespace Gadgets {
        declare namespace DropletsPhoneHolder {
          declare class DropletsPhoneHolderData<T> {
            /**
             * Type of the object being configured
             */
            type: string;
            /**
             * Default name of the object
             */
            name: string;
            /**
             * Compound shape of all the parts
             */
            compound?: T;
            /**
             * Original inputs
             */
            originalInputs: DropletsPhoneHolderDto;
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
            /**
             * Representation of arabic archway parts that are useful for drawing the object efficiently
             */
            drawingPart?: DropletsPhoneHolderDrawingPart<T>;
          }
          declare class DropletsPhoneHolderDrawingPartShapes<T> {
            /**
             * The representation of all the objects in the phone holder, including all wires
             */
            compound?: T;
            /**
             * The representation of 3D model of the phone holder
             */
            phoneHolderCompound?: T;
            /**
             * The representation of all cut wires
             */
            cutWiresCompound?: T;
            /**
             * The representation of the engraving wires
             */
            engravingWiresCompound?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class DropletsPhoneHolderDrawingPart<T> {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?:
              | DropletsPhoneHolderDrawingPartShapes<T>
              | {
                  [x: string]: T;
                };
          }
          declare class DropletsPhoneHolderDtoBase<S, B, T, V> {
            title?: S;
            subtitle: S;
            includeLogo: B;
            thickness: T;
            kerf: T;
            phoneWidth: T;
            phoneHeight: T;
            phoneThickness: T;
            backLength: T;
            angle: T;
            offsetAroundPhone: T;
            penShelf: T;
            phoneLockHeight: T;
            filletRadius: T;
            includePattern: B;
            densityPattern: T;
            holesForWire: B;
            wireInputThickness: T;
            includeModel: B;
            includeDrawings: B;
            spacingDrawings: T;
            rotation?: T;
            direction?: V;
            scale?: V;
            origin?: V;
          }
          declare class DropletsPhoneHolderDto
            implements
              DropletsPhoneHolderDtoBase<
                string,
                boolean,
                number,
                Inputs.Base.Vector3
              >
          {
            constructor(
              title?: string,
              subtitle?: string,
              includeLogo?: boolean,
              thickness?: number,
              kerf?: number,
              phoneWidth?: number,
              phoneHeight?: number,
              phoneThickness?: number,
              backLength?: number,
              angle?: number,
              offsetAroundPhone?: number,
              penShelf?: number,
              phoneLockHeight?: number,
              filletRadius?: number,
              includePattern?: boolean,
              densityPattern?: number,
              holesForWire?: boolean,
              wireInputThickness?: number,
              includeModel?: boolean,
              includeDrawings?: boolean,
              spacingDrawings?: number,
              rotation?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Point3,
              scale?: Inputs.Base.Vector3
            );
            /**
             * Title of the phone holder
             * @default Your Name
             */
            title: string;
            /**
             * Subtitle of the phone holder
             * @default And Message
             */
            subtitle: string;
            /**
             * Include the logo
             * @default true
             */
            includeLogo: boolean;
            /**
             * Thickness of the phone holder
             * @default 0.4
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            thickness: number;
            /**
             * Kerf value for the laser cutting of joints
             * @default 0.01
             * @minimum 0
             * @maximum Infinity
             * @step 0.001
             */
            kerf: number;
            /**
             * Width of the phone
             * @default 8
             * @minimum 4
             * @maximum Infinity
             * @step 0.1
             */
            phoneWidth: number;
            /**
             * Height of the phone
             * @default 16
             * @minimum 4
             * @maximum Infinity
             * @step 0.1
             */
            phoneHeight: number;
            /**
             * Thickness of the phone
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            phoneThickness: number;
            /**
             * Length of the back
             * @default 10
             * @minimum 5
             * @maximum Infinity
             * @step 0.1
             */
            backLength: number;
            /**
             * Angle of the back
             * @default 20
             * @minimum 0
             * @maximum 60
             * @step 1
             */
            angle: number;
            /**
             * Offset around the phone
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            offsetAroundPhone: number;
            /**
             * Pen shelf
             * @default 1
             * @minimum 0.5
             * @maximum Infinity
             * @step 0.1
             */
            penShelf: number;
            /**
             * Phone lock height
             * @default 2
             * @minimum 0.5
             * @maximum Infinity
             * @step 0.1
             */
            phoneLockHeight: number;
            /**
             * Fillet radius
             * @default 0.3
             * @minimum 0.1
             * @maximum 0.4
             * @step 0.1
             */
            filletRadius: number;
            /**
             * Include pattern
             * @default false
             */
            includePattern: boolean;
            /**
             * Density of the pattern
             * @default 0.4
             * @minimum 0
             * @maximum 2
             * @step 0.1
             */
            densityPattern: number;
            /**
             * Include pattern
             * @default true
             */
            holesForWire: boolean;
            /**
             * Wire input thickness
             * @default 1.5
             * @minimum 0.7
             * @maximum Infinity
             * @step 0.1
             */
            wireInputThickness: number;
            /**
             * Include 3D model
             * @default true
             */
            includeModel: boolean;
            /**
             * Include drawings
             * @default true
             */
            includeDrawings: boolean;
            /**
             * Spacing of the drawings
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            spacingDrawings: number;
            /**
             * Rotation of the model
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Origin of the model
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Point3;
            /**
             * Scale of the model
             * @default [1, 1, 1]
             */
            scale: Inputs.Base.Vector3;
          }
          declare class DropletsPhoneHolderModelDto<T> {
            /**
             * The model that represents result of the model
             * @default undefined
             */
            model: DropletsPhoneHolderData<T>;
          }
          declare class DropletsPhoneHolderModelDxfDto<T> {
            /**
             * The model that represents result of the model
             * @default undefined
             */
            model: DropletsPhoneHolderData<T>;
            /**
             * The laser cut wires color
             * @default #000000
             */
            cutWiresColor: Inputs.Base.Color;
            /**
             * The laser engraving wires color
             * @default #0000ff
             */
            engravingWiresColor: Inputs.Base.Color;
            /**
             * The file name
             * @default bitbybit-droplets-phone-holder
             */
            fileName: string;
            /**
             * The angular deflection
             * @default 0.1
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            angularDeflection: number;
            /**
             * The curvature deflection
             * @default 0.1
             * @minimum 0
             * @maximum Infinity
             * @step 0.001
             */
            curvatureDeflection: number;
            /**
             * Minimum of points
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            minimumOfPoints: number;
            /**
             * U tolerance
             * @default 1.0e-9
             * @minimum 0
             * @maximum Infinity
             * @step 1.0e-9
             */
            uTolerance: number;
            /**
             * Minimum length
             * @default 1.0e-7
             * @minimum 0
             * @maximum Infinity
             * @step 1.0e-7
             */
            minimumLength: number;
          }
          declare class DropletsPhoneHolderModelStepDto<T> {
            /**
             * The model that represents result of the model
             * @default undefined
             */
            model: DropletsPhoneHolderData<T>;
            /**
             * The file name
             * @default bitbybit-droplets-phone-holder
             */
            fileName: string;
            /**
             * Adjust Y to Z axis
             * @default true
             */
            adjustYZ: boolean;
          }
        }
      }
    }

    declare namespace Furniture {
      declare namespace Chairs {
        declare namespace SnakeChair {
          declare class SnakeChairData<T> {
            type: string;
            /**
             * The name of the model
             */
            name: string;
            /**
             * Original inputs that were used to create the model
             */
            originalInputs: SnakeChairDto;
            /**
             * Compound shape of the table geometry
             */
            compound?: T;
            /**
             * Representation of table parts that are useful for drawing the object efficiently
             */
            drawingPart?: SnakeChairDrawingPart<T>;
            /**
             * Data that contains information and shapes of the top part of the table
             */
            mainPart?: SnakeChairMainPart<T>;
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
          }
          declare class SnakeChairDrawDto<T> {
            /**
             * Main material
             * @defaul undefined
             * @optional true
             */
            mainMaterial?: T;
            /**
             * You can turn off drawing of faces via this property
             * @default true
             */
            drawFaces: boolean;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Hex colour string for the edges
             * @default #ffffff
             */
            edgeColour: Inputs.Base.Color;
            /**
             * Edge width
             * @default 0.06
             * @minimum 0
             * @maximum Infinity
             */
            edgeWidth: number;
          }
          /**
           * This defines useful compounded objects for representing model in optimal and fast way.
           */
          declare class SnakeChairDrawingPartShapes<T> {
            /**
             * The representation of main part of the chair
             */
            main?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class SnakeChairDrawingPart<T> extends Part {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?: SnakeChairDrawingPartShapes<T>;
          }
          declare class SnakeChairDtoBase<T, U> {
            sittingHeight: T;
            backRestOffset: T;
            backRestHeight: T;
            width: T;
            length: T;
            thickness: T;
            ornamentDepth: T;
            nrOrnamentPlanks: T;
            filletRadius: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class SnakeChairDto
            implements SnakeChairDtoBase<number, Inputs.Base.Point3>
          {
            constructor(
              sittingHeight?: number,
              backRestOffset?: number,
              backRestHeight?: number,
              width?: number,
              length?: number,
              thickness?: number,
              nrOrnamentPlanks?: number,
              ornamentDepth?: number,
              filletRadius?: number,
              precision?: number,
              drawEdges?: boolean,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the sitting area
             * @default 0.45
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.01
             */
            sittingHeight: number;
            /**
             * Sitting top offset from perpendicular ending of the chair
             * @default 0.1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            backRestOffset: number;
            /**
             * Height of the back rest
             * @default 0.7
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.01
             */
            backRestHeight: number;
            /**
             * Width of the table
             * @default 0.45
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            width: number;
            /**
             * Length of the table
             * @default 0.45
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            length: number;
            /**
             * The thickness of the chair
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            thickness: number;
            /**
             * The number of ornament planks
             * @default 7
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrOrnamentPlanks: number;
            /**
             * The ornament depth of the chair
             * @default 0.01
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            ornamentDepth: number;
            /**
             * The radius of the fillet
             * @default 0.05
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.01
             */
            filletRadius: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Rotation of the table in degrees
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class SnakeChairModelDto<T> {
            /**
             * The model that represents result of the good coffee table create operation
             * @default undefined
             */
            model: SnakeChairData<T>;
          }
          declare class SnakeChairMainPart<T> extends Part {
            sittingCenter?: Inputs.Base.Point3;
            shapes?: {
              sittingWire?: T;
              compound?: T;
            };
          }
        }
      }
      declare namespace Tables {
        declare namespace ElegantTable {
          declare class ElegantTableData<T> {
            type: string;
            /**
             * The name of the model
             */
            name: string;
            /**
             * Original inputs that were used to create the model
             */
            originalInputs: ElegantTableDto;
            /**
             * Compound shape of the table geometry
             */
            compound?: T;
            /**
             * Representation of table parts that are useful for drawing the object efficiently
             */
            drawingPart?: ElegantTableDrawingPart<T>;
            /**
             * Data that contains information and shapes of the top part of the table
             */
            topPart?: ElegantTableTopPart<T>;
            /**
             * Data that contains information and shapes repreesenting the legs of the table
             */
            legParts?: ElegantTableLegPart<T>[];
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
          }
          declare class ElegantTableDrawDto<T> {
            /**
             * Material of the top of the table
             * @defaul undefined
             * @optional true
             */
            topMaterial?: T;
            /**
             * Material of the top base of the table
             * @defaul undefined
             * @optional true
             */
            topBaseMaterial?: T;
            /**
             * Material of the legs of the table
             * @defaul undefined
             * @optional true
             */
            legsMaterial?: T;
            /**
             * You can turn off drawing of faces via this property
             * @default true
             */
            drawFaces: boolean;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Hex colour string for the edges
             * @default #ffffff
             */
            edgeColour: Inputs.Base.Color;
            /**
             * Edge width
             * @default 0.06
             * @minimum 0
             * @maximum Infinity
             */
            edgeWidth: number;
          }
          /**
           * This defines useful compounded objects for representing elegant table in optimal and fast way.
           */
          declare class ElegantTableDrawingPartShapes<T> {
            /**
             * The representation of top of the table
             */
            top?: T;
            /**
             * The representation of base of the table top
             */
            topBase?: T;
            /**
             * The representation of all legs as compound of the table
             */
            legs?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class ElegantTableDrawingPart<T> extends Part {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?: ElegantTableDrawingPartShapes<T>;
          }
          declare class ElegantTableDtoBase<T, U> {
            height: T;
            width: T;
            length: T;
            topThickness: T;
            topOffset: T;
            bottomThickness: T;
            minFillet: T;
            radiusLegTop: T;
            radiusLegBottom: T;
            nrLegPairs: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class ElegantTableDto
            implements ElegantTableDtoBase<number, Inputs.Base.Point3>
          {
            constructor(
              height?: number,
              width?: number,
              length?: number,
              topThickness?: number,
              topOffset?: number,
              bottomThickness?: number,
              minFillet?: number,
              radiusLegTop?: number,
              radiusLegBottom?: number,
              nrLegPairs?: number,
              precision?: number,
              drawEdges?: boolean,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the table
             * @default 0.74
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.01
             */
            height: number;
            /**
             * Width of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            width: number;
            /**
             * Length of the table
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            length: number;
            /**
             * Top thickness of the table
             * @default 0.02
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            topThickness: number;
            /**
             * Top offset from the base of the table
             * @default 0.03
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            topOffset: number;
            /**
             * Bottom thickness of the table
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            bottomThickness: number;
            /**
             * Fillet table corners
             * @default 0.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            minFillet: number;
            /**
             * Radius leg top
             * @default 0.03
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            radiusLegTop: number;
            /**
             * Radius leg top
             * @default 0.01
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            radiusLegBottom: number;
            /**
             * The number of leg pairs of the table
             * @default 2
             * @minimum 2
             * @maximum Infinity
             * @step 1
             */
            nrLegPairs: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Rotation of the table in degrees
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class ElegantTableLegByIndexDto<T> {
            /**
             * The model that represents result of the elegant table create operation
             * @default undefined
             */
            model: ElegantTableData<T>;
            /**
             * The index of the leg to be returned
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            index: number;
          }
          declare class ElegantTableLegPart<T> extends Part {
            topCenter?: Inputs.Base.Point3;
            bottomCenter?: Inputs.Base.Point3;
            topRadius?: number;
            bottomRadius?: number;
            shapes?: {
              topCircleWire?: T;
              bottomCircleWire?: T;
              leg?: T;
            };
          }
          declare class ElegantTableModelDto<T> {
            /**
             * The model that represents result of the elegant table create operation
             * @default undefined
             */
            model: ElegantTableData<T>;
          }
          declare class ElegantTableTopPart<T> extends Part {
            topCenter?: Inputs.Base.Point3;
            bottomCenter?: Inputs.Base.Point3;
            shapes?: {
              topPanel?: T;
              topWire?: T;
              bottomWire?: T;
              bottomPanel?: T;
              compound?: T;
            };
          }
        }
        declare namespace GoodCoffeeTable {
          declare class GoodCoffeeTableData<T> {
            type: string;
            /**
             * The name of the model
             */
            name: string;
            /**
             * Original inputs that were used to create the model
             */
            originalInputs: GoodCoffeeTableDto;
            /**
             * Compound shape of the table geometry
             */
            compound?: T;
            /**
             * Representation of table parts that are useful for drawing the object efficiently
             */
            drawingPart?: GoodCoffeeTableDrawingPart<T>;
            /**
             * Data that contains information and shapes of the top part of the table
             */
            topPart?: GoodCoffeeTableTopPart<T>;
            /**
             * Data that contains information and shapes of the shelf part of the table
             */
            shelfPart?: GoodCoffeeTableShelfPart<T>;
            /**
             * Data that contains information and shapes repreesenting the legs of the table
             */
            legParts?: GoodCoffeeTableLegPart<T>[];
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
          }
          declare class GoodCoffeeTableDrawDto<T> {
            /**
             * Material of the glass
             * @defaul undefined
             * @optional true
             */
            topGlassMaterial?: T;
            /**
             * Material of the top frame of the table
             * @defaul undefined
             * @optional true
             */
            topMaterial?: T;
            /**
             * Material of the shelf of the table
             * @defaul undefined
             * @optional true
             */
            shelfMaterial?: T;
            /**
             * Material of the legs of the table
             * @defaul undefined
             * @optional true
             */
            legsMaterial?: T;
            /**
             * You can turn off drawing of faces via this property
             * @default true
             */
            drawFaces: boolean;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Hex colour string for the edges
             * @default #ffffff
             */
            edgeColour: Inputs.Base.Color;
            /**
             * Edge width
             * @default 0.06
             * @minimum 0
             * @maximum Infinity
             */
            edgeWidth: number;
          }
          /**
           * This defines useful compounded objects for representing elegant table in optimal and fast way.
           */
          declare class GoodCoffeeTableDrawingPartShapes<T> {
            /**
             * The representation of top of the table
             */
            top?: T;
            /**
             * The representation of glass of the table top
             */
            topGlass?: T;
            /**
             * The shelf of the table
             */
            shelf?: T;
            /**
             * The representation of all legs as compound of the table
             */
            legs?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class GoodCoffeeTableDrawingPart<T> extends Part {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?: GoodCoffeeTableDrawingPartShapes<T>;
          }
          declare class GoodCoffeeTableDtoBase<T, U> {
            height: T;
            width: T;
            length: T;
            topThickness: T;
            topGlassOffset: T;
            glassThickness: T;
            glassHolderLength: T;
            chamfer: T;
            shelfTopOffset: T;
            shelfThickness: T;
            legWidth: T;
            legDepth: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class GoodCoffeeTableDto
            implements GoodCoffeeTableDtoBase<number, Inputs.Base.Point3>
          {
            constructor(
              height?: number,
              width?: number,
              length?: number,
              chamfer?: number,
              topThickness?: number,
              topGlassOffset?: number,
              glassThickness?: number,
              glassHolderLength?: number,
              shelfTopOffset?: number,
              shelfThickness?: number,
              legWidth?: number,
              legDepth?: number,
              precision?: number,
              drawEdges?: boolean,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the table
             * @default 0.4
             * @minimum 0.1
             * @maximum Infinity
             * @step 0.01
             */
            height: number;
            /**
             * Width of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            width: number;
            /**
             * Length of the table
             * @default 1.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            length: number;
            /**
             * Chamfer the corners
             * @default 0.01
             * @minimum 0
             * @maximum Infinity
             * @step 0.001
             */
            chamfer: number;
            /**
             * Top thickness of the table
             * @default 0.05
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            topThickness: number;
            /**
             * Top offset from the edge of the table till the glass
             * @default 0.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            topGlassOffset: number;
            /**
             * Glass thickness of the table
             * @default 0.005
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            glassThickness: number;
            /**
             * Glass holder length of the table
             * @default 0.02
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            glassHolderLength: number;
            /**
             * The offset of the shelf from the bottom of the top - 0 means that no shelf is made as such shelf would be non-functional.
             * @default 0.15
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            shelfTopOffset: number;
            /**
             * Shelf thickness
             * @default 0.03
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            shelfThickness: number;
            /**
             * Width of the leg
             * @default 0.1
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            legWidth: number;
            /**
             * The depth of the leg
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            legDepth: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Rotation of the table in degrees
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class GoodCoffeeTableLegByIndexDto<T> {
            /**
             * The model that represents result of the elegant table create operation
             * @default undefined
             */
            model: GoodCoffeeTableData<T>;
            /**
             * The index of the leg to be returned
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            index: number;
          }
          declare class GoodCoffeeTableLegPart<T> extends Part {
            topCenter?: Inputs.Base.Point3;
            bottomCenter?: Inputs.Base.Point3;
            width: number;
            depth: number;
            height: number;
            shapes?: {
              topWire?: T;
              bottomWire?: T;
              leg?: T;
            };
          }
          declare class GoodCoffeeTableModelDto<T> {
            /**
             * The model that represents result of the good coffee table create operation
             * @default undefined
             */
            model: GoodCoffeeTableData<T>;
          }
          declare class GoodCoffeeTableShelfPart<T> extends Part {
            topCenter?: Inputs.Base.Point3;
            bottomCenter?: Inputs.Base.Point3;
            shapes?: {
              topWire?: T;
              bottomWire?: T;
              compound?: T;
            };
          }
          declare class GoodCoffeeTableTopPart<T> extends Part {
            topCenter?: Inputs.Base.Point3;
            shapes?: {
              topFrame?: T;
              topWire?: T;
              glassWire?: T;
              glassPanel?: T;
              compound?: T;
            };
          }
        }
        declare namespace SnakeTable {
          declare class SnakeTableData<T> {
            type: string;
            /**
             * The name of the model
             */
            name: string;
            /**
             * Original inputs that were used to create the model
             */
            originalInputs: SnakeTableDto;
            /**
             * Compound shape of the table geometry
             */
            compound?: T;
            /**
             * Representation of table parts that are useful for drawing the object efficiently
             */
            drawingPart?: SnakeTableDrawingPart<T>;
            /**
             * Data that contains information and shapes of the top part of the table
             */
            mainPart?: SnakeTableMainPart<T>;
            /**
             * All the shapes of the vase
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
          }
          declare class SnakeTableDrawDto<T> {
            /**
             * Main material
             * @defaul undefined
             * @optional true
             */
            mainMaterial?: T;
            /**
             * Glass material
             * @defaul undefined
             * @optional true
             */
            glassMaterial?: T;
            /**
             * You can turn off drawing of faces via this property
             * @default true
             */
            drawFaces: boolean;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.001
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Hex colour string for the edges
             * @default #ffffff
             */
            edgeColour: Inputs.Base.Color;
            /**
             * Edge width
             * @default 0.06
             * @minimum 0
             * @maximum Infinity
             */
            edgeWidth: number;
          }
          /**
           * This defines useful compounded objects for representing model in optimal and fast way.
           */
          declare class SnakeTableDrawingPartShapes<T> {
            /**
             * The representation of main part of the table
             */
            main?: T;
            /**
             * The representation of the glass of the table
             */
            glass?: T;
          }
          /**
           * Information needed to draw the part in an optimal way
           */
          declare class SnakeTableDrawingPart<T> extends Part {
            /**
             * Shapes that exist in the drawing part, T can represent opancascade geometry,
             * babylonjs mesh, materials or other things that map to these drawing categories.
             */
            shapes?: SnakeTableDrawingPartShapes<T>;
          }
          declare class SnakeTableDtoBase<T, U> {
            height: T;
            width: T;
            length: T;
            supportLength: T;
            shelfHeight: T;
            glassThickness: T;
            glassOffset: T;
            thickness: T;
            ornamentDepth: T;
            nrOrnamentPlanks: T;
            filletRadius: T;
            precision: T;
            rotation?: T;
            scale?: T;
            origin?: U;
            direction?: U;
          }
          declare class SnakeTableDto
            implements SnakeTableDtoBase<number, Inputs.Base.Point3>
          {
            constructor(
              height?: number,
              width?: number,
              length?: number,
              supportLength?: number,
              shelfHeight?: number,
              thickness?: number,
              glassThickness?: number,
              glassOffset?: number,
              nrOrnamentPlanks?: number,
              ornamentDepth?: number,
              filletRadius?: number,
              precision?: number,
              drawEdges?: boolean,
              rotation?: number,
              scale?: number,
              origin?: Inputs.Base.Point3,
              direction?: Inputs.Base.Vector3
            );
            /**
             * Height of the table
             * @default 0.74
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            height: number;
            /**
             * Width of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            width: number;
            /**
             * Length of the table
             * @default 2
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            length: number;
            /**
             * The length of the support
             * @default 0.5
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            supportLength: number;
            /**
             * The height of the shelf
             * @default 0.2
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            shelfHeight: number;
            /**
             * The thickness of the table
             * @default 0.05
             * @minimum 0.01
             * @maximum Infinity
             * @step 0.01
             */
            thickness: number;
            /**
             * The thickness of the glass
             * @default 0.005
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            glassThickness: number;
            /**
             * The glass offset - goes beyond width and length limitations
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 0.01
             */
            glassOffset: number;
            /**
             * The number of ornament planks
             * @default 7
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            nrOrnamentPlanks: number;
            /**
             * The ornament depth of the table
             * @default 0.01
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.001
             */
            ornamentDepth: number;
            /**
             * The radius of the fillet
             * @default 0.05
             * @minimum 0.001
             * @maximum Infinity
             * @step 0.01
             */
            filletRadius: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
            /**
             * Defines if the edges of the model should be drawn
             * @default true
             */
            drawEdges: boolean;
            /**
             * Rotation of the table in degrees
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 10
             */
            rotation: number;
            /**
             * Scale of the table
             * @default 1
             * @minimum 0
             * @maximum Infinity
             */
            scale: number;
            /**
             * Origin of the medal
             * @default [0, 0, 0]
             */
            origin: Inputs.Base.Point3;
            /**
             * Direction of the model
             * @default [0, 1, 0]
             */
            direction: Inputs.Base.Vector3;
          }
          declare class SnakeTableModelDto<T> {
            /**
             * The model that represents result of the good coffee table create operation
             * @default undefined
             */
            model: SnakeTableData<T>;
          }
          declare class SnakeTableMainPart<T> extends Part {
            topCenter?: Inputs.Base.Point3;
            shapes?: {
              topWire?: T;
              glass?: T;
              main?: T;
              compound?: T;
            };
          }
        }
      }
    }

    declare namespace Shared {
      declare class Part {
        id?: string;
        rotation?: number;
        center?: Inputs.Base.Point3;
        scale?: Inputs.Base.Vector3;
        direction?: Inputs.Base.Vector3;
      }
    }
  }
  declare namespace Advanced {
    declare namespace Enums {
      declare enum outputShapeEnum {
        wire = "wire",
        face = "face",
        solid = "solid",
      }
    }
    declare namespace Text3D {
      declare class CharacterPart<T> {
        id: string;
        shapes?: {
          compound?: T;
        };
      }
      declare class FacePart<T> {
        id: string;
        type: faceTypeEnum;
        shapes?: {
          face?: T;
        };
      }
      declare enum faceTextVarEnum {
        separatedExtrusion = "separatedExtrusion",
        integratedExtrusion = "integratedExtrusion",
        cutout = "cutout",
      }
      declare enum faceTypeEnum {
        compound = "compound",
        cutout = "originalCutout",
        cutoutInsideCharacter = "cutoutInsideCharacter",
      }
      declare class FontDefinition {
        name: string;
        type?: fontsEnum;
        variant?: fontVariantsEnum;
        font: Font;
      }
      declare const fontsModel: {
        key: string;
        variants: string[];
      }[];
      declare enum fontVariantsEnum {
        Regular = "Regular",
        Black = "Black",
        Bold = "Bold",
        ExtraBold = "ExtraBold",
        Medium = "Medium",
        SemiBold = "SemiBold",
        BlackItalic = "BlackItalic",
        BoldItalic = "BoldItalic",
        Italic = "Italic",
        Light = "Light",
        LightItalic = "LightItalic",
        MediumItalic = "MediumItalic",
        Thin = "Thin",
        ThinItalic = "ThinItalic",
        ExtraLight = "ExtraLight",
      }
      declare enum fontsEnum {
        Aboreto = "Aboreto",
        Bungee = "Bungee",
        IndieFlower = "IndieFlower",
        Lugrasimo = "Lugrasimo",
        Orbitron = "Orbitron",
        Roboto = "Roboto",
        RobotoSlab = "RobotoSlab",
        Silkscreen = "Silkscreen",
        Tektur = "Tektur",
        Workbench = "Workbench",
      }
      declare enum recAlignmentEnum {
        leftTop = "leftTop",
        leftMiddle = "leftMiddle",
        leftBottom = "leftBottom",
        centerTop = "centerTop",
        centerMiddle = "centerMiddle",
        centerBottom = "centerBottom",
        rightTop = "rightTop",
        rightMiddle = "rightMiddle",
        rightBottom = "rightBottom",
      }
      declare class Text3DData<T> {
        /**
         * Type of the object being configured
         */
        type: string;
        /**
         * Default name of the object
         */
        name: string;
        /**
         * The advance width of the text
         */
        advanceWidth: number;
        /**
         * The bounding box of the text
         */
        boundingBox: {
          x1: number;
          y1: number;
          x2: number;
          y2: number;
        };
        /**
         * Original inputs
         */
        originalInputs?: Text3DDto | Texts3DFaceDto<T>;
        /**
         * Compounded shape of the 3d text
         */
        compound?: T;
        /**
         * The parts of letters
         */
        characterParts?: CharacterPart<T>[];
        /**
         * This only applies if we use 3d text on face algorithms
         */
        faceParts?: FacePart<T>[];
        /**
         * All the shapes of the 3d text
         */
        shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
        /**
         * All the letter coordinates of the 3d text
         */
        characterCenterCoordinates: Inputs.Base.Point3[];
      }
      declare class Text3DDto {
        constructor(
          text?: string,
          fontType?: fontsEnum,
          fontVariant?: fontVariantsEnum,
          fontSize?: number,
          height?: number,
          rotation?: number,
          origin?: Inputs.Base.Vector3,
          direction?: Inputs.Base.Vector3,
          originAlignment?: recAlignmentEnum
        );
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The type of font to use
         * @default Roboto
         */
        fontType: fontsEnum;
        /**
         * The type of font to use
         * @default Regular
         */
        fontVariant: fontVariantsEnum;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the text
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Vector3;
        /**
         * Direction of the text
         * @default [0, 1, 0]
         */
        direction: Inputs.Base.Vector3;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DFaceDefinitionDto {
        constructor(
          faceTextVar?: faceTextVarEnum,
          text?: string,
          fontType?: fontsEnum,
          fontVariant?: fontVariantsEnum,
          fontSize?: number,
          height?: number,
          rotation?: number,
          originParamU?: number,
          originParamV?: number,
          originAlignment?: recAlignmentEnum
        );
        /**
         * You can choose how your face text will be constructed.
         * Separated extrusion will only return text letters
         * Integrated extrusion will create a shell from the extruded text and original face
         * Integrated pull in will create a shell from the negative extrusion and original face
         * Cutout will return compound with faces that are left after cutting the original face with text
         * @default separatedExtrusion
         */
        faceTextVar: faceTextVarEnum;
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The type of font to use
         * @default Roboto
         */
        fontType: fontsEnum;
        /**
         * The type of font to use
         * @default Regular
         */
        fontVariant: fontVariantsEnum;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin u param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamU: number;
        /**
         * Origin v param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamV: number;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DFaceDefinitionUrlDto {
        constructor(
          faceTextVar?: faceTextVarEnum,
          text?: string,
          fontUrl?: string,
          fontSize?: number,
          height?: number,
          rotation?: number,
          originParamU?: number,
          originParamV?: number,
          originAlignment?: recAlignmentEnum
        );
        /**
         * You can choose how your face text will be constructed.
         * Separated extrusion will only return text letters
         * Integrated extrusion will create a shell from the extruded text and original face
         * Integrated pull in will create a shell from the negative extrusion and original face
         * Cutout will return compound with faces that are left after cutting the original face with text
         * @default separatedExtrusion
         */
        faceTextVar: faceTextVarEnum;
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The font URL to load and use. If Url is provided then font will be loaded using opentype.js.
         * Supported formats are: ttf, otf, woff.
         * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
         * @default https://cdn.jsdelivr.net/gh/bitbybit-dev/bitbybit-assets@latest/fonts/Tektur/Tektur-Bold.ttf
         */
        fontUrl: string;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin u param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamU: number;
        /**
         * Origin v param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamV: number;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DFaceDefinitionUrlParsedDto {
        constructor(
          faceTextVar?: faceTextVarEnum,
          text?: string,
          letterPaths?: any,
          fontSize?: number,
          height?: number,
          rotation?: number,
          originParamU?: number,
          originParamV?: number,
          originAlignment?: recAlignmentEnum
        );
        /**
         * You can choose how your face text will be constructed.
         * Separated extrusion will only return text letters
         * Integrated extrusion will create a shell from the extruded text and original face
         * Integrated pull in will create a shell from the negative extrusion and original face
         * Cutout will return compound with faces that are left after cutting the original face with text
         * @default separatedExtrusion
         */
        faceTextVar: faceTextVarEnum;
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The parsed letter paths that were generated by opentype.js
         * @default undefined
         */
        letterPaths: any;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin u param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamU: number;
        /**
         * Origin v param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamV: number;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DFaceDto<T> {
        constructor(
          face?: T,
          facePlanar?: boolean,
          faceTextVar?: faceTextVarEnum,
          text?: string,
          fontType?: fontsEnum,
          fontVariant?: fontVariantsEnum,
          fontSize?: number,
          height?: number,
          rotation?: number,
          originParamU?: number,
          originParamV?: number,
          originAlignment?: recAlignmentEnum
        );
        /**
         * The face of the text
         * @default undefined
         */
        face: T;
        /**
         * If the face is planar it should be true
         * @default false
         */
        facePlanar: boolean;
        /**
         * You can choose how your face text will be constructed.
         * Separated extrusion will only return text letters
         * Integrated extrusion will create a shell from the extruded text and original face
         * Integrated pull in will create a shell from the negative extrusion and original face
         * Cutout will return compound with faces that are left after cutting the original face with text
         */
        faceTextVar: faceTextVarEnum;
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The type of font to use
         * @default Roboto
         */
        fontType: fontsEnum;
        /**
         * The type of font to use
         * @default Regular
         */
        fontVariant: fontVariantsEnum;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin u param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamU: number;
        /**
         * Origin v param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamV: number;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DFaceUrlDto<T> {
        constructor(
          face?: T,
          facePlanar?: boolean,
          faceTextVar?: faceTextVarEnum,
          text?: string,
          fontUrl?: string,
          fontSize?: number,
          height?: number,
          rotation?: number,
          originParamU?: number,
          originParamV?: number,
          originAlignment?: recAlignmentEnum
        );
        /**
         * The face of the text
         * @default undefined
         */
        face: T;
        /**
         * If the face is planar it should be true
         * @default false
         */
        facePlanar: boolean;
        /**
         * You can choose how your face text will be constructed.
         * Separated extrusion will only return text letters
         * Integrated extrusion will create a shell from the extruded text and original face
         * Integrated pull in will create a shell from the negative extrusion and original face
         * Cutout will return compound with faces that are left after cutting the original face with text
         */
        faceTextVar: faceTextVarEnum;
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The font URL to load and use. If Url is provided then font will be loaded using opentype.js.
         * Supported formats are: ttf, otf, woff.
         * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
         * @default https://cdn.jsdelivr.net/gh/bitbybit-dev/bitbybit-assets@latest/fonts/Tektur/Tektur-Bold.ttf
         */
        fontUrl: string;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin u param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamU: number;
        /**
         * Origin v param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamV: number;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DFaceUrlParsedDto<T> {
        constructor(
          face?: T,
          facePlanar?: boolean,
          faceTextVar?: faceTextVarEnum,
          text?: string,
          letterPaths?: any,
          fontSize?: number,
          height?: number,
          rotation?: number,
          originParamU?: number,
          originParamV?: number,
          originAlignment?: recAlignmentEnum
        );
        /**
         * The face of the text
         * @default undefined
         */
        face: T;
        /**
         * If the face is planar it should be true
         * @default false
         */
        facePlanar: boolean;
        /**
         * You can choose how your face text will be constructed.
         * Separated extrusion will only return text letters
         * Integrated extrusion will create a shell from the extruded text and original face
         * Integrated pull in will create a shell from the negative extrusion and original face
         * Cutout will return compound with faces that are left after cutting the original face with text
         */
        faceTextVar: faceTextVarEnum;
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The parsed letter paths that were generated by opentype.js
         * @default undefined
         */
        letterPaths: any;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin u param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamU: number;
        /**
         * Origin v param for the text 0 - 1
         * @default 0.5
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        originParamV: number;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DLetterByIndexDto<T> {
        /**
         * The model that represents result of the text3d create operation
         * @default undefined
         */
        model: Text3DData<T>;
        /**
         * The index of the letter to be returned
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 1
         */
        index: number;
      }
      declare class Text3DModelDto<T> {
        /**
         * The model that represents result of the text3d create operation
         * @default undefined
         */
        model: Text3DData<T>;
      }
      declare class Text3DUrlDto {
        constructor(
          text?: string,
          fontUrl?: string,
          fontSize?: number,
          height?: number,
          rotation?: number,
          origin?: Inputs.Base.Vector3,
          direction?: Inputs.Base.Vector3,
          originAlignment?: recAlignmentEnum
        );
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The font URL to load and use. If Url is provided then font will be loaded using opentype.js.
         * Supported formats are: ttf, otf, woff.
         * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
         * @default https://cdn.jsdelivr.net/gh/bitbybit-dev/bitbybit-assets@latest/fonts/Tektur/Tektur-Bold.ttf
         */
        fontUrl: string;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the text
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Vector3;
        /**
         * Direction of the text
         * @default [0, 1, 0]
         */
        direction: Inputs.Base.Vector3;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Text3DUrlParsedDto {
        constructor(
          text?: string,
          letterPaths?: any,
          fontSize?: number,
          height?: number,
          rotation?: number,
          origin?: Inputs.Base.Vector3,
          direction?: Inputs.Base.Vector3,
          originAlignment?: recAlignmentEnum
        );
        /**
         * The type of font to use
         * @default bitbybit.dev
         */
        text: string;
        /**
         * The parsed letter paths that were generated by opentype.js
         * @default undefined
         */
        letterPaths: any;
        /**
         * The size of the font
         * @default 1.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        fontSize: number;
        /**
         * The height of the font extrusion, if 0 then face will be returned and not a solid
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        height: number;
        /**
         * The rotation of the generated text
         * @default 0
         * @minimum 0
         * @maximum Infinity
         * @step 15
         */
        rotation: number;
        /**
         * Origin of the text
         * @default [0, 0, 0]
         */
        origin: Inputs.Base.Vector3;
        /**
         * Direction of the text
         * @default [0, 1, 0]
         */
        direction: Inputs.Base.Vector3;
        /**
         * Origin alignment
         * @default centerMiddle
         */
        originAlignment: recAlignmentEnum;
      }
      declare class Texts3DFaceDto<T> {
        constructor(
          face: T,
          facePlanar?: boolean,
          definitions?: Text3DFaceDefinitionDto[]
        );
        /**
         * The face of the text
         * @default undefined
         */
        face: T;
        /**
         * If the face is planar it should be true
         * @default false
         */
        facePlanar: boolean;
        /**
         * The definitions of texts to create on the face
         * @default undefined
         */
        definitions: Text3DFaceDefinitionDto[];
      }
      declare class Texts3DFaceUrlDto<T> {
        constructor(
          face: T,
          facePlanar?: boolean,
          definitions?: Text3DFaceDefinitionUrlDto[]
        );
        /**
         * The face of the text
         * @default undefined
         */
        face: T;
        /**
         * If the face is planar it should be true
         * @default false
         */
        facePlanar: boolean;
        /**
         * The definitions of texts to create on the face
         * @default undefined
         */
        definitions: Text3DFaceDefinitionUrlDto[];
      }
      declare class Texts3DFaceUrlParsedDto<T> {
        constructor(
          face: T,
          facePlanar?: boolean,
          definitions?: Text3DFaceDefinitionUrlParsedDto[]
        );
        /**
         * The face of the text
         * @default undefined
         */
        face: T;
        /**
         * If the face is planar it should be true
         * @default false
         */
        facePlanar: boolean;
        /**
         * The definitions of texts to create on the face
         * @default undefined
         */
        definitions: Text3DFaceDefinitionUrlParsedDto[];
      }
    }
    declare namespace Patterns {
      declare namespace FacePatterns {
        declare namespace PyramidSimple {
          declare class PyramidSimpleAffectorsDto<T> {
            constructor(
              faces?: T[],
              affectorPoints?: Inputs.Base.Point3[],
              uNumber?: number,
              vNumber?: number,
              minHeight?: number,
              maxHeight?: number,
              precision?: number
            );
            /**
             * The faces on which to apply the pattern
             * @default undefined
             */
            faces: T[];
            /**
             * The affector points affect the height of the pyramid elements. The distance is measured between a center point of the corner points and the attractor point. Then it is remapped to certain values.
             * @default undefined
             */
            affectorPoints: Inputs.Base.Point3[];
            /**
             * The affector radius indicates the limit of affection. Cells heights that are further away from the affector than this radius will not be adjusted. If value is not provided, all affector points will use the radius of 10.
             * @default undefined
             * @optional true
             */
            affectorRadiusList?: number[];
            /**
             * The affector factors determine if a given affector attracts (value 0 to 1) or repulses (values -1 to 0) the default height of the pyramid elements.
             * If value is not provided, all affector points will use the factor of 1 and will thus attract the heights.
             * @default undefined
             * @optional true
             */
            affectorFactors?: number[];
            /**
             * The nr of pyramids along u direction of the face
             * @default 10
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            uNumber: number;
            /**
             * The nr of pyramids along v direction of the face
             * @default 5
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            vNumber: number;
            /**
             * The default height for the pyramid if it is not affected by any of the affectors.
             * @default 0.2
             * @minimum -Infinity
             * @maximum Infinity
             * @step 0.1
             */
            defaultHeight: number;
            /**
             * Min value to add to the height if affector factor is 1 or subtract from the height if affector factor is -1.
             * This adds to the height if the affector factor > 0 and subtracts from the height if the affector factor is < 0.
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            affectMinHeight: number;
            /**
             * Max value to add to the height if affector factor is 1 or subtract from the height if affector factor is -1.
             * This adds to the height if the affector factor > 0 and subtracts from the height if the affector factor is < 0.
             * @default 1
             * @minimum 0
             * @maximum Infinity
             * @step 0.1
             */
            affectMaxHeight: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
          }
          declare class PyramidSimpeByIndexDto<T> {
            /**
             * The model that represents result of the pyramid
             * @default undefined
             */
            model: PyramidSimpleData<T>;
            /**
             * The index of pyramid element to be returned
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            index: number;
          }
          declare class PyramidSimpleCellPart<T> {
            id: string;
            uIndex: number;
            vIndex: number;
            cornerPoint1: Inputs.Base.Point3;
            cornerPoint2: Inputs.Base.Point3;
            cornerPoint3: Inputs.Base.Point3;
            cornerPoint4: Inputs.Base.Point3;
            cornerNormal1?: Inputs.Base.Vector3;
            cornerNormal2?: Inputs.Base.Vector3;
            cornerNormal3?: Inputs.Base.Vector3;
            cornerNormal4?: Inputs.Base.Vector3;
            centerPoint?: Inputs.Base.Point3;
            centerNormal?: Inputs.Base.Point3;
            topPoint?: Inputs.Base.Point3;
            shapes?: {
              wire1?: T;
              wire2?: T;
              wire3?: T;
              wire4?: T;
              face1?: T;
              face2?: T;
              face3?: T;
              face4?: T;
              compound?: T;
            };
          }
          declare class PyramidSimpleData<T> {
            /**
             * Type of the object being configured
             */
            type: string;
            /**
             * Default name of the object
             */
            name: string;
            /**
             * Original inputs
             */
            originalInputs?: PyramidSimpleDto<T> | PyramidSimpleAffectorsDto<T>;
            /**
             * Compounded shape of the pyramids
             */
            compound?: T;
            /**
             * All the shapes of the pyramid
             */
            shapes?: Models.OCCT.ShapeWithId<Inputs.OCCT.TopoDSShapePointer>[];
            /**
             * Data that contains information and shapes about each face on which pyramids were computed
             */
            faceParts?: PyramidSimpleFacePart<T>[];
            /**
             * All the pyramid top coordinates
             */
            topCoordinates: Inputs.Base.Point3[];
          }
          declare class PyramidSimpleDto<T> {
            constructor(
              faces?: T[],
              uNumber?: number,
              vNumber?: number,
              height?: number
            );
            /**
             * The faces on which to apply the pattern
             * @default undefined
             */
            faces: T[];
            /**
             * The nr of pyramids along u direction of the face
             * @default 10
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            uNumber: number;
            /**
             * The nr of pyramids along v direction of the face
             * @default 10
             * @minimum 1
             * @maximum Infinity
             * @step 1
             */
            vNumber: number;
            /**
             * The height of the pyramid
             * @default 0.2
             * @minimum -Infinity
             * @maximum Infinity
             * @step 0.1
             */
            height: number;
            /**
             * Meshing precision of the drawn model. The lower the number the more precise the drawn model is. Keep in mind that output of this algorithm also contains pure occt shape that can be meshed separately in draw any async commands
             * @default 0.01
             * @minimum 0.000001
             * @maximum 5
             * @step 0.001
             */
            precision: number;
          }
          declare class PyramidSimpleFacePart<T> {
            id: string;
            /**
             * Data that contains information and shapes of the top part of the table
             */
            cells?: PyramidSimpleCellPart<T>[];
            shapes?: {
              compound?: T;
              startPolylineWireU?: T;
              startPolylineWireV?: T;
              endPolylineWireU?: T;
              endPolylineWireV?: T;
              compoundPolylineWiresU?: T;
              compoundPolylineWiresV?: T;
              compoundPolylineWiresUV?: T;
            };
          }
          declare class PyramidSimpleModelCellDto<T> {
            /**
             * The part that represents the cell of the pyramid
             * @default undefined
             */
            cells: PyramidSimpleCellPart<T>;
          }
          declare class PyramidSimpleModelCellsDto<T> {
            /**
             * The part that represents the cells of the pyramid
             * @default undefined
             */
            cells: PyramidSimpleCellPart<T>[];
          }
          declare class PyramidSimpleModelCellsIndexDto<T> {
            /**
             * The part that represents the cells of the pyramid
             * @default undefined
             */
            cells: PyramidSimpleCellPart<T>[];
            /**
             * The index that can represent a corner, face or a wire in the pyramid
             * @default 0
             * @minimum 0
             * @maximum 3
             * @step 1
             */
            index: number;
          }
          declare class PyramidSimpleModelDto<T> {
            /**
             * The model that represents result of the pyramid create operation
             * @default undefined
             */
            model: PyramidSimpleData<T>;
          }
          declare class PyramidSimpleModelFaceCellIndexDto<T> {
            /**
             * The model that represents result of the pyramid create operation
             * @default undefined
             */
            model: PyramidSimpleData<T>;
            /**
             * Face index for the pyramid queries
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            faceIndex: number;
            /**
             * Cell u index for the pyramid
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            uIndex: number;
            /**
             * Cell v index for the pyramid
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            vIndex: number;
          }
          declare class PyramidSimpleModelFaceCellsUIndexDto<T> {
            /**
             * The model that represents result of the pyramid create operation
             * @default undefined
             */
            model: PyramidSimpleData<T>;
            /**
             * Face index for the pyramid queries
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            faceIndex: number;
            /**
             * U index of the pyramid cells
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            uIndex: number;
          }
          declare class PyramidSimpleModelFaceCellsVIndexDto<T> {
            /**
             * The model that represents result of the pyramid create operation
             * @default undefined
             */
            model: PyramidSimpleData<T>;
            /**
             * Face index for the pyramid queries
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            faceIndex: number;
            /**
             * V index of the pyramid cells
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            vIndex: number;
          }
          declare class PyramidSimpleModelFaceIndexDto<T> {
            /**
             * The model that represents result of the pyramid create operation
             * @default undefined
             */
            model: PyramidSimpleData<T>;
            /**
             * Face index for the pyramid queries
             * @default 0
             * @minimum 0
             * @maximum Infinity
             * @step 1
             */
            faceIndex: number;
          }
        }
      }
    }
    declare namespace Navigation {
      declare class FocusFromAngleDto {
        constructor(
          meshes?: BABYLON.Mesh[],
          includeChildren?: boolean,
          orientation?: number[],
          distance?: number,
          padding?: number,
          animationSpeed?: number
        );
        /**
         * List of meshes to focus on
         * @default []
         */
        meshes: BABYLON.Mesh[];
        /**
         * Whether to include children when computing bounding boxes
         * @default true
         */
        includeChildren: boolean;
        /**
         * Orientation vector indicating the direction from which to view the object
         * The camera will be positioned in this direction from the center of the bounding box
         * @default [1, 1, 1]
         */
        orientation: number[];
        /**
         * Distance from the center of the bounding box to position the camera
         * If not specified, distance will be automatically calculated based on object size
         * @default undefined
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         * @optional true
         */
        distance?: number;
        /**
         * Padding multiplier to control spacing around objects when distance is auto-calculated
         * Higher values = more space around object (camera further away)
         * Lower values = tighter framing (camera closer)
         * Only applies when distance is not manually specified
         * @default 1.5
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        padding: number;
        /**
         * Speed of camera animation in seconds
         * @default 1.0
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        animationSpeed: number;
      }
      declare class PointOfInterestDto {
        constructor(
          name?: string,
          position?: Inputs.Base.Point3,
          cameraTarget?: Inputs.Base.Point3,
          cameraPosition?: Inputs.Base.Point3,
          style?: PointOfInterestStyleDto
        );
        /** Point of Interest  name
         * @default Point of Interest
         */
        name: string;
        /**
         * Camera look at point
         * @default [0, 1, 0]
         */
        position: Inputs.Base.Point3;
        /**
         * Camera look at point
         * @default [0, 0, 0]
         */
        cameraTarget: Inputs.Base.Point3;
        /**
         * Camera position
         * @default [10, 10, 10]
         */
        cameraPosition: Inputs.Base.Point3;
        /**
         * Point of Interest style
         * @default undefined
         * @optional true
         */
        style?: PointOfInterestStyleDto;
      }
      declare class PointOfInterestEntity extends PointOfInterestDto {
        type: string;
        entityName: string;
      }
      declare class PointOfInterestStyleDto {
        constructor(
          pointSize?: number,
          pointColor?: string,
          hoverPointColor?: string,
          pulseColor?: string,
          pulseMinSize?: number,
          pulseMaxSize?: number,
          pulseThickness?: number,
          pulseSpeed?: number,
          textColor?: string,
          hoverTextColor?: string,
          textSize?: number,
          textFontWeight?: number,
          textBackgroundColor?: string,
          textBackgroundOpacity?: number,
          textBackgroundStroke?: boolean,
          textBackgroundStrokeThickness?: number,
          textBackgroundRadius?: number,
          textPosition?: Inputs.Base.topBottomEnum,
          stableSize?: boolean,
          alwaysOnTop?: boolean
        );
        /**
         * Diameter of the central point in pixels
         * @default 20
         */
        pointSize?: number;
        /** Color of the central point
         * @default #ffffff
         */
        pointColor?: Inputs.Base.Color;
        /** Color of the central point on hover
         * @default #0000ff
         */
        hoverPointColor?: Inputs.Base.Color;
        /** Color of the animated pulse
         * @default #ffffff
         */
        pulseColor?: Inputs.Base.Color;
        /** Hover color of the animated pulse
         * @default #0000ff
         */
        hoverPulseColor?: Inputs.Base.Color;
        /** Smallest diameter of the pulse in pixels
         * @default 20
         */
        pulseMinSize?: number;
        /** Largest diameter of the pulse in pixels
         * @default 50
         */
        pulseMaxSize?: number;
        /** Thickness of the pulse ring in pixels
         * @default 2
         */
        pulseThickness?: number;
        /** Speed multiplier for the pulse animation
         * @default 3
         */
        pulseSpeed?: number;
        /** Color of the text label
         * @default #ffffff
         */
        textColor?: Inputs.Base.Color;
        /** Color of the text label on hover
         * @default #0000ff
         */
        hoverTextColor?: Inputs.Base.Color;
        /** Font size of the text label in pixels
         * @default 14
         */
        textSize?: number;
        /** Font weight of the text label
         * @default 400
         * @minimum 100
         * @maximum 900
         * @step 100
         */
        textFontWeight?: number;
        /** Background color of text label
         * @default #000000
         */
        textBackgroundColor?: Inputs.Base.Color;
        /** Opacity of text background
         * @default 0.0
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        textBackgroundOpacity: number;
        /** Whether to show stroke around text background
         * @default false
         */
        textBackgroundStroke: boolean;
        /** Thickness of the stroke around text background
         * @default 8
         * @minimum 1
         * @maximum 20
         * @step 1
         */
        textBackgroundStrokeThickness: number;
        /** Corner radius for text background rounding
         * @default 40
         * @minimum 0
         * @maximum 100
         * @step 5
         */
        textBackgroundRadius: number;
        /** Position of the text label relative to the point in screen space (top or bottom)
         * @default bottom
         */
        textPosition: Inputs.Base.topBottomEnum;
        /** Whether the entire point of interest should maintain stable size regardless of camera distance
         * @default true
         */
        stableSize: boolean;
        /** Whether the point of interest should always render on top of other objects
         * @default false
         */
        alwaysOnTop: boolean;
      }
      declare class ZoomOnDto {
        constructor(
          meshes?: BABYLON.Mesh[],
          includeChildren?: boolean,
          animationSpeed?: number,
          offset?: number,
          doNotUpdateMaxZ?: boolean
        );
        /**
         * List of meshes to zoom on
         * @default []
         */
        meshes: BABYLON.Mesh[];
        /**
         * Whether to include children when analyzing bounding boxes
         * @default true
         */
        includeChildren: boolean;
        /**
         * Speed of camera animation in seconds
         * @default 0.8
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.01
         */
        animationSpeed: number;
        /**
         * Offset multiplier to control spacing around objects
         * Negative values = tighter framing (closer to object)
         * 0 = default BabylonJS framing (has built-in padding)
         * Positive values = more space around object
         * @default 0
         * @minimum -0.9
         * @maximum Infinity
         * @step 0.1
         */
        offset: number;
        /**
         * Whether to prevent updating camera's maxZ (far clipping plane) during zoom
         * @default true
         */
        doNotUpdateMaxZ: boolean;
      }
    }
    declare namespace Dimensions {
      declare class AngularDimensionDto {
        constructor(
          centerPoint?: Inputs.Base.Point3,
          direction1?: Inputs.Base.Vector3,
          direction2?: Inputs.Base.Vector3,
          radius?: number,
          labelOffset?: number,
          decimalPlaces?: number,
          labelSuffix?: string,
          labelOverwrite?: string,
          radians?: boolean,
          removeTrailingZeros?: boolean,
          style?: DimensionStyleDto
        );
        /**
         * Center point of the angle
         * @default [0, 0, 0]
         */
        centerPoint: Inputs.Base.Point3;
        /**
         * First direction vector
         * @default [1, 0, 0]
         */
        direction1: Inputs.Base.Vector3;
        /**
         * Second direction vector
         * @default [0, 1, 0]
         */
        direction2: Inputs.Base.Vector3;
        /**
         * Radius of the dimension arc
         * @default 1
         * @minimum 0.1
         * @maximum Infinity
         * @step 0.1
         */
        radius: number;
        /**
         * Label offset from arc
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset: number;
        /**
         * Decimal places for angle display
         * @default 1
         * @minimum 0
         * @maximum 10
         * @step 1
         */
        decimalPlaces: number;
        /**
         * Suffix to add to the angle label
         * @default 
         */
        labelSuffix: string;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', 'Angle: val')
         * @default 1*val
         */
        labelOverwrite: string;
        /**
         * Whether to display angle in radians
         * @default false
         */
        radians: boolean;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros: boolean;
        /**
         * Dimension style
         * @default undefined
         * @optional true
         */
        style?: DimensionStyleDto;
      }
      declare class AngularDimensionEntity extends AngularDimensionDto {
        type: string;
        entityName: string;
        /** Identifier for this dimension entity
         * @ignore true
         */
        id?: string;
      }
      declare class DiametralDimensionDto {
        constructor(
          centerPoint?: Inputs.Base.Point3,
          direction?: Inputs.Base.Vector3,
          diameter?: number,
          labelOffset?: number,
          decimalPlaces?: number,
          labelSuffix?: string,
          labelOverwrite?: string,
          showCenterMark?: boolean,
          removeTrailingZeros?: boolean,
          style?: DimensionStyleDto
        );
        /**
         * Center point of the circle/arc
         * @default [0, 0, 0]
         */
        centerPoint: Inputs.Base.Point3;
        /**
         * Direction vector for diameter line
         * @default [1, 0, 0]
         */
        direction: Inputs.Base.Vector3;
        /**
         * Diameter value
         * @default 2
         * @minimum 0.01
         * @maximum Infinity
         * @step 0.1
         */
        diameter: number;
        /**
         * Label offset from diameter line
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset: number;
        /**
         * Decimal places for measurement display
         * @default 2
         * @minimum 0
         * @maximum 10
         * @step 1
         */
        decimalPlaces: number;
        /**
         * Label suffix text
         * @default mm
         */
        labelSuffix: string;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', ' val mm')
         * @default 1*val
         */
        labelOverwrite: string;
        /**
         * Whether to show center mark at center point
         * @default true
         */
        showCenterMark: boolean;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros: boolean;
        /**
         * Dimension style
         * @default undefined
         * @optional true
         */
        style?: DimensionStyleDto;
      }
      declare class DiametralDimensionEntity extends DiametralDimensionDto {
        type: string;
        entityName: string;
        /** Identifier for this dimension entity
         * @ignore true
         */
        id?: string;
      }
      declare class DimensionStyleDto {
        constructor(
          lineColor?: string,
          lineThickness?: number,
          extensionLineLength?: number,
          arrowTailLength?: number,
          textColor?: string,
          textSize?: number,
          textFontWeight?: number,
          textBackgroundColor?: string,
          textBackgroundOpacity?: number,
          textBackgroundStroke?: boolean,
          textBackgroundStrokeThickness?: number,
          textBackgroundRadius?: number,
          textStableSize?: boolean,
          arrowSize?: number,
          arrowColor?: string,
          showArrows?: boolean,
          textBillboard?: boolean,
          occlusionCheckInterval?: number,
          alwaysOnTop?: boolean
        );
        /**
         * Color of dimension lines
         * @default #ffffff
         */
        lineColor: Inputs.Base.Color;
        /**
         * Thickness of dimension lines
         * @default 0.01
         * @minimum 0.01
         * @maximum 0.5
         * @step 0.01
         */
        lineThickness: number;
        /**
         * Length of extension lines beyond dimension line
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        extensionLineLength: number;
        /**
         * Length of arrow tail extensions beyond arrow tips
         * @default 0.2
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        arrowTailLength: number;
        /**
         * Color of dimension text
         * @default #ffffff
         */
        textColor: Inputs.Base.Color;
        /**
         * Size of dimension text
         * @default 16
         * @minimum 0
         * @maximum Infinity
         * @step 2
         */
        textSize: number;
        /**
         * Font weight of dimension text
         * @default 400
         * @minimum 100
         * @maximum 900
         * @step 100
         */
        textFontWeight: number;
        /**
         * Background color of text (if needed)
         * @default #000000
         */
        textBackgroundColor: Inputs.Base.Color;
        /**
         * Opacity of text background
         * @default 0.0
         * @minimum 0
         * @maximum 1
         * @step 0.1
         */
        textBackgroundOpacity: number;
        /**
         * Whether to show stroke around text background
         * @default false
         */
        textBackgroundStroke: boolean;
        /**
         * Thickness of the stroke around text background
         * @default 8
         * @minimum 1
         * @maximum 20
         * @step 1
         */
        textBackgroundStrokeThickness: number;
        /**
         * Corner radius for text background rounding
         * @default 40
         * @minimum 0
         * @maximum 100
         * @step 5
         */
        textBackgroundRadius: number;
        /**
         * Whether text should maintain stable size regardless of camera distance
         * @default false
         */
        textStableSize: boolean;
        /**
         * Size of arrow heads
         * @default 0.05
         * @minimum 0
         * @maximum Infinity
         * @step 0.01
         */
        arrowSize: number;
        /**
         * Color of arrow heads
         * @default #ffffff
         */
        arrowColor: Inputs.Base.Color;
        /**
         * Whether to show arrow heads/cones
         * @default true
         */
        showArrows: boolean;
        /**
         * Whether text should billboard (always face camera)
         * @default true
         */
        textBillboard: boolean;
        /**
         * How often to check for occlusion in milliseconds (only for GUI modes)
         * @default 100
         * @minimum 50
         * @maximum 1000
         * @step 50
         */
        occlusionCheckInterval: number;
        /**
         * Whether dimensions should always render on top of other objects
         * @default false
         */
        alwaysOnTop: boolean;
      }
      declare class LinearDimensionDto {
        constructor(
          startPoint?: Inputs.Base.Point3,
          endPoint?: Inputs.Base.Point3,
          direction?: Inputs.Base.Vector3,
          labelOffset?: number,
          decimalPlaces?: number,
          labelSuffix?: string,
          labelOverwrite?: string,
          removeTrailingZeros?: boolean,
          style?: DimensionStyleDto
        );
        /**
         * Start point of the dimension
         * @default [0, 0, 0]
         */
        startPoint: Inputs.Base.Point3;
        /**
         * End point of the dimension
         * @default [1, 0, 0]
         */
        endPoint: Inputs.Base.Point3;
        /**
         * Direction vector for dimension line offset
         * @default [0, 1, 0]
         */
        direction: Inputs.Base.Vector3;
        /**
         * Label offset from dimension line
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset: number;
        /**
         * Decimal places for measurement display
         * @default 2
         * @minimum 0
         * @maximum 10
         * @step 1
         */
        decimalPlaces: number;
        /**
         * Label suffix text
         * @default mm
         */
        labelSuffix: string;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', 'Length: val mm')
         * @default 1*val
         */
        labelOverwrite: string;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros: boolean;
        /**
         * Dimension style
         * @default undefined
         * @optional true
         */
        style?: DimensionStyleDto;
      }
      declare class LinearDimensionEntity extends LinearDimensionDto {
        type: string;
        entityName: string;
        /** Identifier for this dimension entity
         * @ignore true
         */
        id?: string;
      }
      declare enum ordinateAxisEnum {
        x = "x",
        y = "y",
        z = "z",
      }
      declare class OrdinateDimensionDto {
        constructor(
          measurementPoint?: Inputs.Base.Point3,
          referencePoint?: Inputs.Base.Point3,
          axis?: ordinateAxisEnum,
          labelOffset?: number,
          decimalPlaces?: number,
          labelSuffix?: string,
          labelOverwrite?: string,
          showLeaderLine?: boolean,
          removeTrailingZeros?: boolean,
          style?: DimensionStyleDto
        );
        /**
         * Point to measure coordinate from
         * @default [1, 1, 1]
         */
        measurementPoint: Inputs.Base.Point3;
        /**
         * Reference origin point for coordinate system
         * @default [0, 0, 0]
         */
        referencePoint: Inputs.Base.Point3;
        /**
         * Which axis coordinate to display (X, Y, or Z)
         * @default x
         */
        axis: ordinateAxisEnum;
        /**
         * Label offset from measurement point
         * @default 0.5
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset: number;
        /**
         * Decimal places for measurement display
         * @default 2
         * @minimum 0
         * @maximum 10
         * @step 1
         */
        decimalPlaces: number;
        /**
         * Label suffix text
         * @default mm
         */
        labelSuffix: string;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', 'X: val mm')
         * @default 1*val
         */
        labelOverwrite: string;
        /**
         * Whether to show leader line from measurement point to label
         * @default true
         */
        showLeaderLine: boolean;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros: boolean;
        /**
         * Dimension style
         * @default undefined
         * @optional true
         */
        style?: DimensionStyleDto;
      }
      declare class OrdinateDimensionEntity extends OrdinateDimensionDto {
        type: string;
        entityName: string;
        /** Identifier for this dimension entity
         * @ignore true
         */
        id?: string;
      }
      declare class RadialDimensionDto {
        constructor(
          centerPoint?: Inputs.Base.Point3,
          radiusPoint?: Inputs.Base.Point3,
          labelOffset?: number,
          decimalPlaces?: number,
          labelSuffix?: string,
          labelOverwrite?: string,
          showDiameter?: boolean,
          showCenterMark?: boolean,
          removeTrailingZeros?: boolean,
          style?: DimensionStyleDto
        );
        /**
         * Center point of the circle/arc
         * @default [0, 0, 0]
         */
        centerPoint: Inputs.Base.Point3;
        /**
         * Point on the radius/perimeter of the circle/arc
         * @default [1, 0, 0]
         */
        radiusPoint: Inputs.Base.Point3;
        /**
         * Label offset from radius line
         * @default 0.1
         * @minimum 0
         * @maximum Infinity
         * @step 0.1
         */
        labelOffset: number;
        /**
         * Decimal places for measurement display
         * @default 2
         * @minimum 0
         * @maximum 10
         * @step 1
         */
        decimalPlaces: number;
        /**
         * Label suffix text
         * @default mm
         */
        labelSuffix: string;
        /**
         * Override label text with custom expression (supports 'val' for computed value, e.g., '100*val', 'R val mm')
         * @default 1*val
         */
        labelOverwrite: string;
        /**
         * Whether to show diameter instead of radius
         * @default false
         */
        showDiameter: boolean;
        /**
         * Whether to show center mark at center point
         * @default true
         */
        showCenterMark: boolean;
        /**
         * Remove trailing zeros from decimal places
         * @default false
         */
        removeTrailingZeros: boolean;
        /**
         * Dimension style
         * @default undefined
         * @optional true
         */
        style?: DimensionStyleDto;
      }
      declare class RadialDimensionEntity extends RadialDimensionDto {
        type: string;
        entityName: string;
        /** Identifier for this dimension entity
         * @ignore true
         */
        id?: string;
      }
    }
  }

  /**
   * This should be used only if you want to use only JSCAD worker without other of the bitbybit packages
   */
  declare class BitByBitJSCAD {
    jscadWorkerManager: JSCADWorkerManager;
    jscad: JSCAD;
    constructor();
    init(jscad: Worker): void;
  }
  /**
   * Contains various functions for Solid booleans from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADBooleans {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Intersect multiple solid mesh objects
     * @param inputs Contains multiple solids for intersection
     * @returns Solid mesh
     * @group boolean
     * @shortname intersect
     * @drawable true
     */
    intersect(
      inputs: Inputs.JSCAD.BooleanObjectsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Subtract multiple solid mesh objects
     * @param inputs Contains multiple solids for subtraction
     * @returns Solid mesh
     * @group boolean
     * @shortname subtract
     * @drawable true
     */
    subtract(
      inputs: Inputs.JSCAD.BooleanObjectsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Union multiple solid mesh objects
     * @param inputs Contains multiple solids for union
     * @returns Solid mesh
     * @group boolean
     * @shortname union
     * @drawable true
     */
    union(
      inputs: Inputs.JSCAD.BooleanObjectsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Intersect two solid mesh objects
     * @param inputs Contains multiple solids for intersection
     * @returns Solid mesh
     * @group boolean
     * @shortname intersect two
     * @drawable true
     */
    intersectTwo(
      inputs: Inputs.JSCAD.BooleanTwoObjectsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Subtract two solid mesh objects
     * @param inputs Contains multiple solids for subtraction
     * @returns Solid mesh
     * @group boolean
     * @shortname subtract two
     * @drawable true
     */
    subtractTwo(
      inputs: Inputs.JSCAD.BooleanTwoObjectsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Union two solid mesh objects
     * @param inputs Contains multiple solids for union
     * @returns Solid mesh
     * @group boolean
     * @shortname union two
     * @drawable true
     */
    unionTwo(
      inputs: Inputs.JSCAD.BooleanTwoObjectsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Subtract multiple meshes from one mesh object
     * @param inputs Contains mesh from which to subtract and multiple meshes for subtraction
     * @returns mesh
     * @group boolean
     * @shortname subtract from
     * @drawable true
     */
    subtractFrom(
      inputs: Inputs.JSCAD.BooleanObjectsFromDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains functions for colorizing objects
   */
  declare class JSCADColors {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Colorizes geometry of jscad. If geometry is in the array it will colorize all items and return them. If geometry is a single item it will return a single item.
     * Keep in mind that colorized geometry in jscad will always be drawn in that color even if you try to change it via draw options.
     * @param inputs contain geometry and hex color
     * @returns Colorized geometry of jsacd
     * @group colorize
     * @shortname colorize geometry
     * @drawable true
     */
    colorize(
      inputs: Inputs.JSCAD.ColorizeDto
    ): Promise<Inputs.JSCAD.JSCADEntity | Inputs.JSCAD.JSCADEntity[]>;
  }
  /**
   * Contains various functions for Solid expansions from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADExpansions {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Expand geometries of solid category
     * @param inputs Contains options and geometries for expansion
     * @returns Expanded geometry
     * @group expansion
     * @shortname expand
     * @drawable true
     */
    expand(
      inputs: Inputs.JSCAD.ExpansionDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Offset 2d geometries of solid category
     * @param inputs Contains options and geometries for offset
     * @returns Expanded geometry
     * @group expansion
     * @shortname offset
     * @drawable true
     */
    offset(
      inputs: Inputs.JSCAD.ExpansionDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains various functions for Solid extrusions from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADExtrusions {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Linear extrude 2D geometries of solid category
     * @param inputs Contains options and geometries for linear extrude
     * @returns Extruded geometry
     * @group extrude
     * @shortname linear
     * @drawable true
     */
    extrudeLinear(
      inputs: Inputs.JSCAD.ExtrudeLinearDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Rectangular extrude 2D geometries of solid category. Creates a wall-type extrusion of certain height and size.
     * @param inputs Contains options and geometries for rectangular extrude
     * @returns Extruded geometry
     * @group extrude
     * @shortname rectangular
     * @drawable true
     */
    extrudeRectangular(
      inputs: Inputs.JSCAD.ExtrudeRectangularDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Rectangular extrude a list of 2D points. Creates a wall-type extrusion of certain height and size.
     * @param inputs Contains options and points for extrusion
     * @returns Extruded geometry
     * @group extrude
     * @shortname rectangular points
     * @drawable true
     */
    extrudeRectangularPoints(
      inputs: Inputs.JSCAD.ExtrudeRectangularPointsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Rectangular extrude a list of 2D points. Creates a wall-type extrusion of certain height and size.
     * @param inputs Contains options and points for extrusion
     * @returns Extruded geometry
     * @group extrude
     * @shortname rotational
     * @drawable true
     */
    extrudeRotate(
      inputs: Inputs.JSCAD.ExtrudeRotateDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains various functions for Solid hulls from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADHulls {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Hull chain connects solids or 2d geometries by filling an empty space in between objects in order.
     * Geometries need to be of the same type.
     * @param inputs Geometries
     * @returns Chain hulled geometry
     * @group hulls
     * @shortname hull chain
     * @drawable true
     */
    hullChain(inputs: Inputs.JSCAD.HullDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Convex hull connects solids or 2d geometries by filling an empty space in between without following order.
     * Geometries need to be of the same type.
     * @param inputs Geometries
     * @returns Hulled geometry
     * @group hulls
     * @shortname hull
     * @drawable true
     */
    hull(inputs: Inputs.JSCAD.HullDto): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains various functions for Solid meshes from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCAD {
    private readonly jscadWorkerManager;
    readonly booleans: JSCADBooleans;
    readonly expansions: JSCADExpansions;
    readonly extrusions: JSCADExtrusions;
    readonly hulls: JSCADHulls;
    readonly path: JSCADPath;
    readonly polygon: JSCADPolygon;
    readonly shapes: JSCADShapes;
    readonly text: JSCADText;
    readonly colors: JSCADColors;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Converts the Jscad mesh to polygon points representing triangles of the mesh.
     * @param inputs Jscad mesh
     * @returns polygon points
     * @group conversions
     * @shortname to polygon points
     * @drawable false
     */
    toPolygonPoints(inputs: Inputs.JSCAD.MeshDto): Promise<Inputs.Base.Mesh3>;
    /**
     * Transforms the Jscad solid meshes with a given list of transformations.
     * @param inputs Solids with the transformation matrixes
     * @returns Solids with a transformation
     * @group transforms
     * @shortname transform solids
     * @drawable true
     */
    transformSolids(
      inputs: Inputs.JSCAD.TransformSolidsDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Transforms the Jscad solid mesh with a given list of transformations.
     * @param inputs Solid with the transformation matrixes
     * @returns Solid with a transformation
     * @group transforms
     * @shortname transform solid
     * @drawable true
     */
    transformSolid(
      inputs: Inputs.JSCAD.TransformSolidDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Downloads the binary STL file from a 3D solid
     * @param inputs 3D Solid
     * @group io
     * @shortname solid to stl
     */
    downloadSolidSTL(inputs: Inputs.JSCAD.DownloadSolidDto): Promise<void>;
    /**
     * Downloads the binary STL file from a 3D solids
     * @param inputs 3D Solid
     * @group io
     * @shortname solids to stl
     */
    downloadSolidsSTL(inputs: Inputs.JSCAD.DownloadSolidsDto): Promise<void>;
    /**
     * Downloads the dxf file from jscad geometry. Supports paths and meshes in array.
     * @param inputs 3D geometry
     * @group io
     * @shortname geometry to dxf
     */
    downloadGeometryDxf(
      inputs: Inputs.JSCAD.DownloadGeometryDto
    ): Promise<void>;
    /**
     * Downloads the 3MF file from jscad geometry.
     * @param inputs 3D geometry
     * @group io
     * @shortname geometry to 3mf
     */
    downloadGeometry3MF(
      inputs: Inputs.JSCAD.DownloadGeometryDto
    ): Promise<void>;
    private downloadFile;
  }
  /**
   * Contains various functions for Path from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADPath {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Create a 2D path from a list of points
     * @param inputs Points and indication if we want a closed path or not
     * @returns Path
     * @group from
     * @shortname points
     * @drawable true
     */
    createFromPoints(
      inputs: Inputs.JSCAD.PathFromPointsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create 2D paths from a lists of points
     * @param inputs Points lists
     * @returns Paths
     * @group from
     * @shortname paths from points
     * @drawable true
     */
    createPathsFromPoints(
      inputs: Inputs.JSCAD.PathsFromPointsDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 2D path from a polyline
     * @param inputs Polyline and indication if we want a closed path or not
     * @returns Path
     * @group from
     * @shortname polyline
     * @drawable true
     */
    createFromPolyline(
      inputs: Inputs.JSCAD.PathFromPolylineDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create empty 2D path
     * @returns Empty path
     * @group create
     * @shortname empty
     * @drawable false
     */
    createEmpty(): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Closes an open 2D path
     * @param inputs Path
     * @returns Closed path
     * @group edit
     * @shortname close
     * @drawable true
     */
    close(inputs: Inputs.JSCAD.PathDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Append the path with 2D points
     * @param inputs Path to append and points
     * @returns Appended path
     * @group append
     * @shortname points
     * @drawable true
     */
    appendPoints(
      inputs: Inputs.JSCAD.PathAppendPointsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Append the path with polyline
     * @param inputs Path to append and polyline
     * @returns Appended path
     * @group append
     * @shortname polyline
     * @drawable true
     */
    appendPolyline(
      inputs: Inputs.JSCAD.PathAppendPolylineDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Append the arc to the path
     * @param inputs Path and arc parameters
     * @returns Appended path
     * @group append
     * @shortname arc
     * @drawable true
     */
    appendArc(
      inputs: Inputs.JSCAD.PathAppendArcDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains various functions for Polygon from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADPolygon {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Create a 2D polygon from a list of points
     * @param inputs Points
     * @returns Polygons
     * @group from
     * @shortname polygon from points
     * @drawable true
     */
    createFromPoints(
      inputs: Inputs.JSCAD.PointsDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon from a polyline
     * @param inputs Polyline
     * @returns Polygon
     * @group from
     * @shortname polyline
     * @drawable true
     */
    createFromPolyline(
      inputs: Inputs.JSCAD.PolylineDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon from a curve
     * @param inputs Nurbs curve
     * @returns Polygon
     * @group from
     * @shortname curve
     * @drawable true
     */
    createFromCurve(
      inputs: Inputs.JSCAD.CurveDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon from a path
     * @param inputs Path
     * @returns Polygon
     * @group from
     * @shortname path
     * @drawable true
     */
    createFromPath(
      inputs: Inputs.JSCAD.PathDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon circle
     * @param inputs Circle parameters
     * @returns Circle polygon
     * @group primitives
     * @shortname circle
     * @drawable true
     */
    circle(inputs: Inputs.JSCAD.CircleDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon ellipse
     * @param inputs Ellipse parameters
     * @returns Ellipse polygon
     * @group primitives
     * @shortname ellipse
     * @drawable true
     */
    ellipse(inputs: Inputs.JSCAD.EllipseDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon rectangle
     * @param inputs Rectangle parameters
     * @returns Rectangle polygon
     * @group primitives
     * @shortname rectangle
     * @drawable true
     */
    rectangle(
      inputs: Inputs.JSCAD.RectangleDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D rounded rectangle
     * @param inputs Rounded rectangle parameters
     * @returns Rounded rectangle polygon
     * @group primitives
     * @shortname rounded rectangle
     * @drawable true
     */
    roundedRectangle(
      inputs: Inputs.JSCAD.RoundedRectangleDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon square
     * @param inputs Square parameters
     * @returns Square polygon
     * @group primitives
     * @shortname square
     * @drawable true
     */
    square(inputs: Inputs.JSCAD.SquareDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 2D polygon star
     * @param inputs Star parameters
     * @returns Star polygon
     * @group primitives
     * @shortname star
     * @drawable true
     */
    star(inputs: Inputs.JSCAD.StarDto): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains various functions for solid 3D shapes from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADShapes {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Create a 3D cube shape
     * @param inputs Cube parameters
     * @returns Cube solid
     * @group primitives
     * @shortname cube
     * @drawable true
     */
    cube(inputs: Inputs.JSCAD.CubeDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D cubes on multiple center points
     * @param inputs Cube with multiple center points parameters
     * @returns List of cube solids
     * @group primitives on centers
     * @shortname cubes
     * @drawable true
     */
    cubesOnCenterPoints(
      inputs: Inputs.JSCAD.CubeCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D cuboid shape
     * @param inputs Cuboid parameters
     * @returns Cuboid solid
     * @group primitives
     * @shortname cuboid
     * @drawable true
     */
    cuboid(inputs: Inputs.JSCAD.CuboidDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D cuboids on multiple center points
     * @param inputs Cuboids with multiple center point parameters
     * @returns List of cuboid solids
     * @group primitives on centers
     * @shortname cuboids
     * @drawable true
     */
    cuboidsOnCenterPoints(
      inputs: Inputs.JSCAD.CuboidCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D elliptic cylinder solid
     * @param inputs Elliptic cylinder parameters
     * @returns Elliptic cylinder solid
     * @group primitives
     * @shortname cylinder elliptic
     * @drawable true
     */
    cylinderElliptic(
      inputs: Inputs.JSCAD.CylidnerEllipticDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D elliptic cylinders on multiple center points
     * @param inputs Elliptic cylinders with multiple center point parameters
     * @returns List of elliptic cylinders solids
     * @group primitives on centers
     * @shortname cylinder elliptic
     * @drawable true
     */
    cylinderEllipticOnCenterPoints(
      inputs: Inputs.JSCAD.CylidnerCentersEllipticDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D cylinder solid
     * @param inputs Cylinder parameters
     * @returns Cylinder solid
     * @group primitives
     * @shortname cylinder
     * @drawable true
     */
    cylinder(
      inputs: Inputs.JSCAD.CylidnerDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D cylinders on multiple center points
     * @param inputs Cylinders with multiple center point parameters
     * @returns List of cylinder solids
     * @group primitives on centers
     * @shortname cylinder
     * @drawable true
     */
    cylindersOnCenterPoints(
      inputs: Inputs.JSCAD.CylidnerCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D ellipsoid solid
     * @param inputs Ellipsoid parameters
     * @returns Ellipsoid solid
     * @group primitives
     * @shortname ellipsoid
     * @drawable true
     */
    ellipsoid(
      inputs: Inputs.JSCAD.EllipsoidDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D ellipsoids on multiple center points
     * @param inputs Ellipsoid parameters with multiple center points
     * @returns List of ellipsoid solids
     * @group primitives on centers
     * @shortname ellipsoid
     * @drawable true
     */
    ellipsoidsOnCenterPoints(
      inputs: Inputs.JSCAD.EllipsoidCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D geodesic sphere solid
     * @param inputs Geodesic sphere parameters
     * @returns Geodesic sphere solid
     * @group primitives
     * @shortname geodesic sphere
     * @drawable true
     */
    geodesicSphere(
      inputs: Inputs.JSCAD.GeodesicSphereDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D geodesic spheres on multiple center points
     * @param inputs Geodesic sphere parameters with multiple center points
     * @returns List of geodesic spheres
     * @group primitives on centers
     * @shortname geodesic sphere
     * @drawable true
     */
    geodesicSpheresOnCenterPoints(
      inputs: Inputs.JSCAD.GeodesicSphereCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D rounded cuboid solid
     * @param inputs Rounded cuboid parameters
     * @returns Rounded cuboid solid
     * @group primitives
     * @shortname rounded cuboid
     * @drawable true
     */
    roundedCuboid(
      inputs: Inputs.JSCAD.RoundedCuboidDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D rounded cuboids on multiple center points
     * @param inputs Rounded cuboids parameters with multiple center points
     * @returns List of rounded cuboids
     * @group primitives on centers
     * @shortname rounded cuboid
     * @drawable true
     */
    roundedCuboidsOnCenterPoints(
      inputs: Inputs.JSCAD.RoundedCuboidCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D rounded cylinder solid
     * @param inputs Rounded cylinder parameters
     * @returns Rounded cylinder solid
     * @group primitives
     * @shortname rounded cylinder
     * @drawable true
     */
    roundedCylinder(
      inputs: Inputs.JSCAD.RoundedCylidnerDto
    ): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D rounded cylinders on multiple center points
     * @param inputs Rounded cylinders parameters with multiple center points
     * @returns List of rounded cylinders
     * @group primitives on centers
     * @shortname rounded cylinder
     * @drawable true
     */
    roundedCylindersOnCenterPoints(
      inputs: Inputs.JSCAD.RoundedCylidnerCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D sphere solid
     * @param inputs Sphere parameters
     * @returns Sphere solid
     * @group primitives
     * @shortname sphere
     * @drawable true
     */
    sphere(inputs: Inputs.JSCAD.SphereDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D sphere on multiple center points
     * @param inputs Sphere parameters with multiple center points
     * @returns List of spheres
     * @group primitives on centers
     * @shortname sphere
     * @drawable true
     */
    spheresOnCenterPoints(
      inputs: Inputs.JSCAD.SphereCentersDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Create a 3D torus solid
     * @param inputs Torus parameters
     * @returns Torus solid
     * @group primitives
     * @shortname torus
     * @drawable true
     */
    torus(inputs: Inputs.JSCAD.TorusDto): Promise<Inputs.JSCAD.JSCADEntity>;
    /**
     * Create a 3D shape from poylgon points that have to be nested arrays of points
     * @param inputs points
     * @returns shape
     * @group shapes
     * @shortname from polygon points
     * @drawable true
     */
    fromPolygonPoints(
      inputs: Inputs.JSCAD.FromPolygonPoints
    ): Promise<Inputs.JSCAD.JSCADEntity>;
  }
  /**
   * Contains various functions for solid 3D texts from JSCAD library https://github.com/jscad/OpenJSCAD.org
   * Thanks JSCAD community for developing this kernel
   */
  declare class JSCADText {
    private readonly jscadWorkerManager;
    constructor(jscadWorkerManager: JSCADWorkerManager);
    /**
     * Creates a text that is based on chain hulling cylinders
     * @param inputs Cylindrical text parameters
     * @returns List of solids for text
     * @group text
     * @shortname cylindrical
     * @drawable true
     */
    cylindricalText(
      inputs: Inputs.JSCAD.CylinderTextDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Creates a text that is based on chain hulling spheres
     * @param inputs Spherical text parameters
     * @returns List of solids for text
     * @group text
     * @shortname spherical
     * @drawable true
     */
    sphericalText(
      inputs: Inputs.JSCAD.SphereTextDto
    ): Promise<Inputs.JSCAD.JSCADEntity[]>;
    /**
     * Creates a vector text
     * @param inputs Vector text parameters
     * @returns List of polygons
     * @group text
     * @shortname vector
     * @drawable false
     */
    createVectorText(
      inputs: Inputs.JSCAD.TextDto
    ): Promise<Inputs.Base.Point2[][]>;
  }
  /**
   * This should be used only if you want to use only Manifold worker without other of the bitbybit packages
   */
  declare class BitByBitManifold {
    manifoldWorkerManager: ManifoldWorkerManager;
    manifold: ManifoldBitByBit;
    constructor();
    init(manifold: Worker): void;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class CrossSectionBooleans {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Subtract two cross sections
     * @param inputs two cross sections
     * @returns subtracted cross section
     * @group a to b
     * @shortname subtract
     * @drawable true
     */
    subtract(
      inputs: Inputs.Manifold.TwoCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Add two cross sections
     * @param inputs two cross sections
     * @returns unioned cross section
     * @group a to b
     * @shortname add
     * @drawable true
     */
    add(
      inputs: Inputs.Manifold.TwoCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Intersect two cross sections
     * @param inputs two cross sections
     * @returns intersected cross section
     * @group a to b
     * @shortname intersect
     * @drawable true
     */
    intersect(
      inputs: Inputs.Manifold.TwoCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Difference of two cross sections
     * @param inputs two cross sections
     * @returns difference of two cross sections
     * @group 2 cross sections
     * @shortname difference 2 cs
     * @drawable true
     */
    differenceTwo(
      inputs: Inputs.Manifold.TwoCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Union of two cross sections
     * @param inputs two cross sections
     * @returns union of two cross sections
     * @group 2 cross sections
     * @shortname union 2 cs
     * @drawable true
     */
    unionTwo(
      inputs: Inputs.Manifold.TwoCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Intersection of two cross sections
     * @param inputs two shapes
     * @returns intersection of two cross sections
     * @group 2 cross sections
     * @shortname intersect 2 cs
     * @drawable true
     */
    intersectionTwo(
      inputs: Inputs.Manifold.TwoCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Difference of multiple cross sections
     * @param inputs multiple cross sections
     * @returns difference of cross sections
     * @group multiple
     * @shortname diff cross sections
     * @drawable true
     */
    difference(
      inputs: Inputs.Manifold.CrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Union of multiple cross sections
     * @param inputs multiple cross sections
     * @returns union of two cross sections
     * @group multiple
     * @shortname union cross sections
     * @drawable true
     */
    union(
      inputs: Inputs.Manifold.CrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Intersection of multiple cross sections
     * @param inputs two cross sections
     * @returns intersection of multiple cross sections
     * @group multiple
     * @shortname intersection cross sections
     * @drawable true
     */
    intersection(
      inputs: Inputs.Manifold.CrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldCrossSection {
    private readonly manifoldWorkerManager;
    shapes: CrossSectionShapes;
    operations: CrossSectionOperations;
    booleans: CrossSectionBooleans;
    transforms: CrossSectionTransforms;
    evaluate: CrossSectionEvaluate;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Creates a cross section from a single polygon points
     * @param inputs polygon points
     * @returns cross section
     * @group create
     * @shortname cross section from points
     * @drawable true
     */
    crossSectionFromPoints(
      inputs: Inputs.Manifold.CrossSectionFromPolygonPointsDto
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Creates a cross section from multiple polygons points
     * @param inputs polygons points
     * @returns cross section
     * @group create
     * @shortname cross section from polygons
     * @drawable true
     */
    crossSectionFromPolygons(
      inputs: Inputs.Manifold.CrossSectionFromPolygonsPointsDto
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Turns cross section into polygons
     * @param inputs cross section
     * @returns polygons
     * @group decompose
     * @shortname cross section to polygons
     * @drawable false
     */
    crossSectionToPolygons(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Base.Vector2[][]>;
    /**
     * Extracts points from a cross section
     * @param inputs cross section
     * @returns points
     * @group decompose
     * @shortname cross section to points
     * @drawable false
     */
    crossSectionToPoints(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<number[][][]>;
    /**
     * Turns cross sections into polygons
     * @param inputs cross sections
     * @returns polygons
     * @group decompose
     * @shortname cross sections to polygons
     * @drawable false
     */
    crossSectionsToPolygons(
      inputs: Inputs.Manifold.CrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Base.Vector2[][][]>;
    /**
     * Extracts points from cross sections
     * @param inputs cross sections
     * @returns points
     * @group decompose
     * @shortname cross sections to points
     * @drawable false
     */
    crossSectionsToPoints(
      inputs: Inputs.Manifold.CrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<number[][][][]>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class CrossSectionEvaluate {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Get area of cross section
     * @param inputs cross section
     * @returns area of cross section
     * @group basic
     * @shortname area
     * @drawable false
     */
    area(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<number>;
    /**
     * Check if cross section is empty
     * @param inputs cross section
     * @returns boolean indicating emptyness
     * @group basic
     * @shortname is empty
     * @drawable false
     */
    isEmpty(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<boolean>;
    /**
     * Get number of vertices in cross section
     * @param inputs cross section
     * @returns number of vertices of cross section
     * @group basic
     * @shortname num vert
     * @drawable false
     */
    numVert(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<number>;
    /**
     * Get number of contours in cross section
     * @param inputs cross section
     * @returns number of contour of cross section
     * @group basic
     * @shortname num contour
     * @drawable false
     */
    numContour(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<number>;
    /**
     * Get the bounds of the contour as a rectangle. Output is given in two vec2 points in the array. First array is the min point and second array is the max point.
     * @param inputs cross section
     * @returns bounds of cross section
     * @group basic
     * @shortname bounds
     * @drawable false
     */
    bounds(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Base.Vector2[]>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class CrossSectionOperations {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Compute convex hull for the cross section
     * @param inputs cross section
     * @returns hulled cross section
     * @group basic
     * @shortname hull
     * @drawable true
     */
    hull(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Extrude the cross section to create a 3D shape
     * @param inputs cross section and extrusion parameters
     * @returns extruded manifold shape
     * @group basic
     * @shortname extrude
     * @drawable true
     */
    extrude(
      inputs: Inputs.Manifold.ExtrudeDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Revolve the cross section to create a 3D shape
     * @param inputs cross section and extrusion parameters
     * @returns extruded manifold shape
     * @group basic
     * @shortname revolve
     * @drawable true
     */
    revolve(
      inputs: Inputs.Manifold.RevolveDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Offsets the cross section to create a new cross section with a given delta (uses Clipper2 algorithm behind).
     * @param inputs cross section and offset parameters
     * @returns offset cross section
     * @group basic
     * @shortname offset
     * @drawable true
     */
    offset(
      inputs: Inputs.Manifold.OffsetDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Remove vertices from the contours in this CrossSection that are less than
     * the specified distance epsilon from an imaginary line that passes through
     * its two adjacent vertices. Near duplicate vertices and collinear points
     * will be removed at lower epsilons, with elimination of line segments
     * becoming increasingly aggressive with larger epsilons.
     *
     * It is recommended to apply this function following Offset, in order to
     * clean up any spurious tiny line segments introduced that do not improve
     * offseting operations are to be performed, which would compound the issue.
     * @param inputs cross section and epsilon parameters
     * @returns simplified cross section
     * @group basic
     * @shortname simplify
     * @drawable true
     */
    simplify(
      inputs: Inputs.Manifold.SimplifyDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Composes multiple cross sections or polygons into a single cross section
     * @param inputs cross sections or polygons
     * @returns composed cross section
     * @group composition
     * @shortname compose
     * @drawable true
     */
    compose(
      inputs: Inputs.Manifold.ComposeDto<
        (Inputs.Manifold.CrossSectionPointer | Inputs.Base.Vector2[])[]
      >
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Decompose cross sections that are topologically
     * disconnected, each containing one outline contour with zero or more
     * holes.
     * @param inputs cross section
     * @returns decomposed cross sections
     * @group composition
     * @shortname decompose
     * @drawable true
     */
    decompose(
      inputs: Inputs.Manifold.CrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer[]>;
  }
  /**
   * Contains various functions for making shapes Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class CrossSectionShapes {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Create a 2d cross-section from a set of contours (complex polygons). A
     * boolean union operation (with Positive filling rule by default) is
     * performed to combine overlapping polygons and ensure the resulting
     * CrossSection is free of intersections.
     * @param inputs polygons and fill rule
     * @returns cross section
     * @group base
     * @shortname create
     * @drawable true
     */
    create(
      inputs: Inputs.Manifold.CreateContourSectionDto
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Create a 2D square cross section
     * @param inputs Square parameters
     * @returns square cross section
     * @group primitives
     * @shortname square
     * @drawable true
     */
    square(
      inputs: Inputs.Manifold.SquareDto
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Create a 2D circle cross section
     * @param inputs Circle parameters
     * @returns circle cross section
     * @group primitives
     * @shortname circle
     * @drawable true
     */
    circle(
      inputs: Inputs.Manifold.CircleDto
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Create a 2D rectangle cross section
     * @param inputs Rectangle parameters
     * @returns rectangle cross section
     * @group primitives
     * @shortname rectangle
     * @drawable true
     */
    rectangle(
      inputs: Inputs.Manifold.RectangleDto
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
  }
  /**
   * Contains various functions for transforming cross section from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class CrossSectionTransforms {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Scales a cross section shape with 2D vector
     * @param inputs cross section and scale vector
     * @returns Scaled cross section shape
     * @group transforms
     * @shortname scale 2d
     * @drawable true
     */
    scale2D(
      inputs: Inputs.Manifold.Scale2DCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Scales a cross section shape with single factor
     * @param inputs cross section and scale factor
     * @returns Scaled cross section shape
     * @group transforms
     * @shortname scale uniform
     * @drawable true
     */
    scale(
      inputs: Inputs.Manifold.ScaleCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Mirrors a cross section shape over a plane defined by a normal vector
     * @param inputs cross section and normal vector
     * @returns Mirrored cross section shape
     * @group transforms
     * @shortname mirror
     * @drawable true
     */
    mirror(
      inputs: Inputs.Manifold.MirrorCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Translates a cross section shape along the vector
     * @param inputs cross section and trnaslation vector
     * @returns Translated cross section shape
     * @group transforms
     * @shortname translate
     * @drawable true
     */
    translate(
      inputs: Inputs.Manifold.TranslateCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Translates a cross section shape along x, y
     * @param inputs cross section and trnaslation coordinates
     * @returns Translated cross section shape
     * @group transforms
     * @shortname translate xy
     * @drawable true
     */
    translateXY(
      inputs: Inputs.Manifold.TranslateXYCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Rotates a cross section shape along the containing degrees
     * @param inputs cross section and rotation degrees
     * @returns Rotated cross section shape
     * @group transforms
     * @shortname rotate
     * @drawable true
     */
    rotate(
      inputs: Inputs.Manifold.RotateCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Transforms a cross section shape by using the 3x3 transformation matrix
     * @param inputs cross section and transformation matrix
     * @returns Transformed cross section shape
     * @group matrix
     * @shortname transform
     * @drawable true
     */
    transform(
      inputs: Inputs.Manifold.TransformCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Move the vertices of this CrossSection (creating a new one) according to
     * any arbitrary input function, followed by a union operation (with a
     * Positive fill rule) that ensures any introduced intersections are not
     * included in the result.
     * @param inputs cross section and warp function
     * @returns Warped cross section shape
     * @group transforms
     * @shortname warp
     * @drawable true
     */
    warp(
      inputs: Inputs.Manifold.CrossSectionWarpDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldBooleans {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Subtract two manifold shapes
     * @param inputs two shapes
     * @returns subtracted manifold shape
     * @group a to b
     * @shortname subtract
     * @drawable true
     */
    subtract(
      inputs: Inputs.Manifold.TwoManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Add two manifold shapes
     * @param inputs two shapes
     * @returns unioned manifold shape
     * @group a to b
     * @shortname add
     * @drawable true
     */
    add(
      inputs: Inputs.Manifold.TwoManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Intersect two manifold shapes
     * @param inputs two shapes
     * @returns intersected manifold shape
     * @group a to b
     * @shortname intersect
     * @drawable true
     */
    intersect(
      inputs: Inputs.Manifold.TwoManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Difference of two manifold shapes
     * @param inputs two shapes
     * @returns difference of two manifold shapes
     * @group 2 manifolds
     * @shortname difference 2 manifolds
     * @drawable true
     */
    differenceTwo(
      inputs: Inputs.Manifold.TwoManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Union of two manifold shapes
     * @param inputs two shapes
     * @returns union of two manifold shapes
     * @group 2 manifolds
     * @shortname union 2 manifolds
     * @drawable true
     */
    unionTwo(
      inputs: Inputs.Manifold.TwoManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Intersection of two manifold shapes
     * @param inputs two shapes
     * @returns intersection of two manifold shapes
     * @group 2 manifolds
     * @shortname intersection 2 manifolds
     * @drawable true
     */
    intersectionTwo(
      inputs: Inputs.Manifold.TwoManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Difference of multiple manifold shapes
     * @param inputs multiple shapes
     * @returns difference of two manifold shapes
     * @group multiple
     * @shortname difference manifolds
     * @drawable true
     */
    difference(
      inputs: Inputs.Manifold.ManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Union of multiple manifold shapes
     * @param inputs multiple shapes
     * @returns union of two manifold shapes
     * @group multiple
     * @shortname union manifolds
     * @drawable true
     */
    union(
      inputs: Inputs.Manifold.ManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Intersection of multiple manifold shapes
     * @param inputs two shapes
     * @returns intersection of multiple manifold shapes
     * @group multiple
     * @shortname intersection manifolds
     * @drawable true
     */
    intersection(
      inputs: Inputs.Manifold.ManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Split manifold by another manifold
     * @param inputs manifold to split and manifold cutter
     * @returns split manifold
     * @group split
     * @shortname split
     * @drawable true
     */
    split(
      inputs: Inputs.Manifold.SplitManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer[]>;
    /**
     * Split manifold by plane
     * @param inputs manifold and plane
     * @returns split manifold
     * @group split
     * @shortname split by plane
     * @drawable true
     */
    splitByPlane(
      inputs: Inputs.Manifold.SplitByPlaneDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer[]>;
    /**
     * Split manifold by plane on various offsets
     * @param inputs manifold, plane and the list of offsets
     * @returns splitted manifolds
     * @group split
     * @shortname split by plane on offsets
     * @drawable true
     */
    splitByPlaneOnOffsets(
      inputs: Inputs.Manifold.SplitByPlaneOnOffsetsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer[]>;
    /**
     * Trim manifold by plane
     * @param inputs manifold and plane
     * @returns trimmed manifold
     * @group trim
     * @shortname trim by plane
     * @drawable true
     */
    trimByPlane(
      inputs: Inputs.Manifold.TrimByPlaneDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldEvaluate {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Get surface area of manifold
     * @param inputs manifold
     * @returns surface area of manifold
     * @group basic
     * @shortname surface area
     * @drawable false
     */
    surfaceArea(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Get volume of manifold
     * @param inputs manifold
     * @returns volume of manifold
     * @group basic
     * @shortname volume
     * @drawable false
     */
    volume(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Check if manifold contains triangles
     * @param inputs manifold
     * @returns boolean indicating emptyness
     * @group basic
     * @shortname is empty
     * @drawable false
     */
    isEmpty(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<boolean>;
    /**
     * Get number of vertices in manifold
     * @param inputs manifold
     * @returns number of vertices of manifold
     * @group basic
     * @shortname num vert
     * @drawable false
     */
    numVert(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Get number of triangles in manifold
     * @param inputs manifold
     * @returns number of triangles of manifold
     * @group basic
     * @shortname num triangles
     * @drawable false
     */
    numTri(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Get number of edges in manifold
     * @param inputs manifold
     * @returns number of edges of manifold
     * @group basic
     * @shortname num edges
     * @drawable false
     */
    numEdge(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Get number of properties in manifold
     * @param inputs manifold
     * @returns number of properties of manifold
     * @group basic
     * @shortname num prop
     * @drawable false
     */
    numProp(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * The number of property vertices in the Manifold. This will always be >=
     * numVert, as some physical vertices may be duplicated to account for
     * different properties on different neighboring triangles.
     * @param inputs manifold
     * @returns number of properties of manifold
     * @group basic
     * @shortname num prop vert
     * @drawable false
     */
    numPropVert(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Returns the axis-aligned bounding box of all the Manifold's vertices.
     * @param inputs manifold
     * @returns bounding box corner vectors of manifold
     * @group basic
     * @shortname bounding box
     * @drawable false
     */
    boundingBox(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Base.Vector3[]>;
    /**
     * Returns the tolerance of this Manifold's vertices, which tracks the
     * approximate rounding error over all the transforms and operations that have
     * led to this state. Any triangles that are colinear within this tolerance
     * are considered degenerate and removed. This is the value of &epsilon;
     * defining
     * [&epsilon;-valid](https://github.com/elalish/manifold/wiki/Manifold-Library#definition-of-%CE%B5-valid).
     * @param inputs manifold
     * @returns tolerance of manifold
     * @group basic
     * @shortname tolerance
     * @drawable false
     */
    tolerance(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * The genus is a topological property of the manifold, representing the
     * number of handles. A sphere is 0, torus 1, etc. It is only meaningful for
     * a single mesh, so it is best to call Decompose() first.
     * @param inputs manifold
     * @returns genus of manifold
     * @group basic
     * @shortname genus
     * @drawable false
     */
    genus(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Returns the minimum gap between two manifolds. Returns a float between
     * 0 and searchLength.
     * @param inputs two manifolds and search length
     * @returns minimum
     * @group basic
     * @shortname min gap
     * @drawable false
     */
    minGap(
      inputs: Inputs.Manifold.ManifoldsMinGapDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * If this mesh is an original, this returns its ID that can be referenced
     * by product manifolds. If this manifold is a product, this
     * returns -1.
     * @param inputs manifold
     * @returns original id of manifold
     * @group basic
     * @shortname original id
     * @drawable false
     */
    originalID(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<number>;
    /**
     * Returns the reason for an input Mesh producing an empty Manifold. This
     * Status will carry on through operations like NaN propogation, ensuring an
     * errored mesh doesn't get mysteriously lost. Empty meshes may still show
     * NoError, for instance the intersection of non-overlapping meshes.
     * @param inputs manifold
     * @returns error status string (NoError, NotManifold, InvalidConstruction, etc.)
     * @group basic
     * @shortname status
     * @drawable false
     */
    status(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<string>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class Manifold {
    private readonly manifoldWorkerManager;
    readonly shapes: ManifoldShapes;
    readonly booleans: ManifoldBooleans;
    readonly operations: ManifoldOperations;
    readonly transforms: ManifoldTransforms;
    readonly evaluate: ManifoldEvaluate;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Turns manifold shape into a mesh
     * @param inputs Manifold shape
     * @returns Decomposed mesh definition
     * @group meshing
     * @shortname manifold to mesh
     * @drawable false
     */
    manifoldToMesh(
      inputs: Inputs.Manifold.ManifoldToMeshDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.DecomposedManifoldMeshDto>;
    /**
     * Turns manifold shapes into meshes
     * @param inputs Manifold shapes
     * @returns Decomposed mesh definitions
     * @group meshing
     * @shortname manifolds to meshes
     * @drawable false
     */
    manifoldsToMeshes(
      inputs: Inputs.Manifold.ManifoldsToMeshesDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.DecomposedManifoldMeshDto[]>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldOperations {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Computes convex hull of the manifold shape provided
     * @param inputs two shapes
     * @returns hulled manifold shape
     * @group hulls
     * @shortname convex hull
     * @drawable true
     */
    hull(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Hull points or manifolds
     * @param inputs manifold
     * @returns manifold
     * @group hulls
     * @shortname hull points
     * @drawable true
     */
    hullPoints(
      inputs: Inputs.Manifold.HullPointsDto<
        (Inputs.Base.Point3 | Inputs.Manifold.ManifoldPointer)[]
      >
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Returns the cross section of this object parallel to the X-Y plane at the
     * specified height. Using a height equal to the bottom
     * of the bounding box will return the bottom faces, while using a height
     * equal to the top of the bounding box will return empty.
     * @param inputs manifold and height
     * @returns sliced cross section
     * @group cross sections
     * @shortname slice
     * @drawable true
     */
    slice(
      inputs: Inputs.Manifold.SliceDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Creates a projection on xy plane from the shape outline
     * @param inputs manifold
     * @returns projected cross section
     * @group cross sections
     * @shortname project
     * @drawable true
     */
    project(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.CrossSectionPointer>;
    /**
     * Return a copy of the manifold with the set tolerance value.
     * This performs mesh simplification when the tolerance value is increased.
     * @param inputs manifold and tolerance
     * @returns manifold with new tolerance
     * @group basic
     * @shortname set tolerance
     * @drawable false
     */
    setTolerance(
      inputs: Inputs.Manifold.ManifoldRefineToleranceDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Returns the first of n sequential new unique mesh IDs for marking sets of triangles that can be looked up after further operations. Assign to Mesh.runOriginalID vector.
     * @param inputs count
     * @returns void
     * @group basic
     * @shortname reserve id
     * @drawable false
     */
    reserveIds(inputs: Inputs.Manifold.CountDto): Promise<number>;
    /**
     * If you copy a manifold, but you want this new copy to have new properties
     * (e.g. a different UV mapping), you can reset its IDs to a new original,
     * meaning it will now be referenced by its descendants instead of the meshes
     * it was built from, allowing you to differentiate the copies when applying
     * your properties to the final result.
     *
     * This function also condenses all coplanar faces in the relation, and
     * collapses those edges. If you want to have inconsistent properties across
     * these faces, meaning you want to preserve some of these edges, you should
     * instead call GetMesh(), calculate your properties and use these to
     * construct a new manifold.
     * @param inputs manifold
     * @returns original manifold
     * @group basic
     * @shortname as original
     * @drawable true
     */
    asOriginal(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Constructs a new manifold from a list of other manifolds. This is a purely
     * topological operation, so care should be taken to avoid creating
     * overlapping results. It is the inverse operation of Decompose().
     * @param inputs manifold shapes
     * @returns composed manifold
     * @group composition
     * @shortname compose
     * @drawable true
     */
    compose(
      inputs: Inputs.Manifold.ManifoldsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * This operation returns a vector of Manifolds that are topologically
     * disconnected. If everything is connected, the vector is length one,
     * containing a copy of the original. It is the inverse operation of
     * Compose().
     * @param inputs manifold
     * @returns decomposed manifold shapes
     * @group composition
     * @shortname decompose
     * @drawable true
     */
    decompose(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer[]>;
    /**
     * Fills in vertex properties for normal vectors, calculated from the mesh
     * geometry. Flat faces composed of three or more triangles will remain flat.
     * @param inputs manifold and normal index with minimum sharp angle
     * @returns manifold with calculated normals
     * @group adjustments
     * @shortname calculate normals
     * @drawable true
     */
    calculateNormals(
      inputs: Inputs.Manifold.CalculateNormalsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Curvature is the inverse of the radius of curvature, and signed such that
     * positive is convex and negative is concave. There are two orthogonal
     * principal curvatures at any point on a manifold, with one maximum and the
     * other minimum. Gaussian curvature is their product, while mean
     * curvature is their sum. This approximates them for every vertex and assigns
     * them as vertex properties on the given channels.
     * @param inputs manifold and gaussian and mean index
     * @returns manifold with calculated curvature
     * @group adjustments
     * @shortname calculate curvature
     * @drawable true
     */
    calculateCurvature(
      inputs: Inputs.Manifold.CalculateCurvatureDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Increase the density of the mesh by splitting each edge into pieces such
     * that any point on the resulting triangles is roughly within tolerance of
     * the smoothly curved surface defined by the tangent vectors. This means
     * tightly curving regions will be divided more finely than smoother regions.
     * If halfedgeTangents are not present, the result will simply be a copy of
     * the original. Quads will ignore their interior triangle bisector.
     * @param inputs manifold and tolerance
     * @returns refined manifold
     * @group adjustments
     * @shortname refine to tolerance
     * @drawable true
     */
    refineToTolerance(
      inputs: Inputs.Manifold.ManifoldRefineToleranceDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Increase the density of the mesh by splitting each edge into pieces of
     * roughly the input length. Interior verts are added to keep the rest of the
     * triangulation edges also of roughly the same length. If halfedgeTangents
     * are present (e.g. from the Smooth() constructor), the new vertices will be
     * moved to the interpolated surface according to their barycentric
     * coordinates.
     * @param inputs manifold and length
     * @returns refined manifold
     * @group adjustments
     * @shortname refine to length
     * @drawable true
     */
    refineToLength(
      inputs: Inputs.Manifold.ManifoldRefineLengthDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Increase the density of the mesh by splitting every edge into n pieces. For
     * instance, with n = 2, each triangle will be split into 4 triangles. These
     * will all be coplanar (and will not be immediately collapsed) unless the
     * Mesh/Manifold has halfedgeTangents specified (e.g. from the Smooth()
     * constructor), in which case the new vertices will be moved to the
     * interpolated surface according to their barycentric coordinates.
     * @param inputs manifold and count
     * @returns refined manifold
     * @group adjustments
     * @shortname refine
     * @drawable true
     */
    refine(
      inputs: Inputs.Manifold.ManifoldRefineDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Smooths out the Manifold by filling in the halfedgeTangent vectors. The
     * geometry will remain unchanged until Refine or RefineToLength is called to
     * interpolate the surface. This version uses the geometry of the triangles
     * and pseudo-normals to define the tangent vectors.
     * @param inputs manifold and minimum sharp angle and minimum smoothness
     * @returns smoothed manifold
     * @group adjustments
     * @shortname smooth out
     * @drawable true
     */
    smoothOut(
      inputs: Inputs.Manifold.ManifoldSmoothOutDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Smooths out the Manifold by filling in the halfedgeTangent vectors. The
     * geometry will remain unchanged until Refine or RefineToLength is called to
     * interpolate the surface. This version uses the supplied vertex normal
     * properties to define the tangent vectors.
     * @param inputs manifold and normal index
     * @returns smoothed manifold
     * @group adjustments
     * @shortname smooth by normals
     * @drawable true
     */
    smoothByNormals(
      inputs: Inputs.Manifold.ManifoldSmoothByNormalsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Return a copy of the manifold simplified to the given tolerance, but with
     * its actual tolerance value unchanged. The result will contain a subset of
     * the original verts and all surfaces will have moved by less than tolerance.
     * @param inputs manifold and tolerance
     * @returns simplified manifold
     * @group adjustments
     * @shortname simplify
     * @drawable true
     */
    simplify(
      inputs: Inputs.Manifold.ManifoldSimplifyDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Create a new copy of this manifold with updated vertex properties by
     * supplying a function that takes the existing position and properties as
     * input. You may specify any number of output properties, allowing creation
     * and removal of channels. Note: undefined behavior will result if you read
     * past the number of input properties or write past the number of output
     * properties.
     * @param inputs manifold, numProp and property function
     * @returns manifold with updated properties
     * @group adjustments
     * @shortname set properties
     * @drawable true
     */
    setProperties(
      inputs: Inputs.Manifold.ManifoldSetPropertiesDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldShapes {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Convert a Mesh into a Manifold, retaining its properties and merging only
     * the positions according to the merge vectors. Will throw an error if the
     * result is not an oriented 2-manifold. Will collapse degenerate triangles
     * and unnecessary vertices.
     *
     * All fields are read, making this structure suitable for a lossless
     * round-trip of data from manifoldToMesh(). For multi-material input, use
     * reserveIDs() to set a unique originalID for each material, and sort the
     * materials into triangle runs.
     * @param inputs mesh definition
     * @returns manifold
     * @group create
     * @shortname manifold from mesh
     * @drawable true
     */
    manifoldFromMesh(
      inputs: Inputs.Manifold.CreateFromMeshDto
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Create a Manifold from a set of polygon points describing triangles.
     * @param inputs Polygon points
     * @returns Manifold
     * @group create
     * @shortname from polygon points
     * @drawable true
     */
    fromPolygonPoints(
      inputs: Inputs.Manifold.FromPolygonPointsDto
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Create a 3D cube shape
     * @param inputs Cube parameters
     * @returns Cube solid
     * @group primitives
     * @shortname cube
     * @drawable true
     */
    cube(
      inputs: Inputs.Manifold.CubeDto
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Create a 3D sphere shape
     * @param inputs Sphere parameters
     * @returns Sphere solid
     * @group primitives
     * @shortname sphere
     * @drawable true
     */
    sphere(
      inputs: Inputs.Manifold.SphereDto
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Create a 3D tetrahedron shape
     * @returns Tetrahedron solid
     * @group primitives
     * @shortname tetrahedron
     * @drawable true
     */
    tetrahedron(): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Create a 3D cylinder shape
     * @param inputs Cylinder parameters
     * @returns Cylinder solid
     * @group primitives
     * @shortname cylinder
     * @drawable true
     */
    cylinder(
      inputs: Inputs.Manifold.CylinderDto
    ): Promise<Inputs.Manifold.ManifoldPointer>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldTransforms {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Scales a manifold shape with 3D vector
     * @param inputs manifold and scale vector
     * @returns Scaled manifold shape
     * @group transforms
     * @shortname scale 3d
     * @drawable true
     */
    scale3D(
      inputs: Inputs.Manifold.Scale3DDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Scales a manifold shape with single factor
     * @param inputs manifold and scale factor
     * @returns Scaled manifold shape
     * @group transforms
     * @shortname scale uniform
     * @drawable true
     */
    scale(
      inputs: Inputs.Manifold.ScaleDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Mirrors a manifold shape over a plane defined by a normal vector
     * @param inputs manifold and normal vector
     * @returns Mirrored manifold shape
     * @group transforms
     * @shortname mirror
     * @drawable true
     */
    mirror(
      inputs: Inputs.Manifold.MirrorDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Translates a manifold shape along the vector
     * @param inputs manifold and trnaslation vector
     * @returns Translated manifold shape
     * @group transforms
     * @shortname translate
     * @drawable true
     */
    translate(
      inputs: Inputs.Manifold.TranslateDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Translates a manifold shape along by multiple vectors
     * @param inputs manifold and trnaslation vectors
     * @returns Translated manifold shapes
     * @group multiple
     * @shortname translate by vectors
     * @drawable true
     */
    translateByVectors(
      inputs: Inputs.Manifold.TranslateByVectorsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer[]>;
    /**
     * Translates a manifold shape along x, y, z
     * @param inputs manifold and trnaslation coordinates
     * @returns Translated manifold shape
     * @group transforms
     * @shortname translate xyz
     * @drawable true
     */
    translateXYZ(
      inputs: Inputs.Manifold.TranslateXYZDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Rotates a manifold shape along the vector containing euler angles
     * @param inputs manifold and rotation vector
     * @returns Rotated manifold shape
     * @group transforms
     * @shortname rotate
     * @drawable true
     */
    rotate(
      inputs: Inputs.Manifold.RotateDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Rotates a manifold shape along the x y z euler angles
     * @param inputs manifold and rotation eulers
     * @returns Rotated manifold shape
     * @group transforms
     * @shortname rotate xyz
     * @drawable true
     */
    rotateXYZ(
      inputs: Inputs.Manifold.RotateXYZDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Transforms a manifold shape by using the 4x4 transformation matrix
     * @param inputs manifold and transformation matrix
     * @returns Transformed manifold shape
     * @group matrix
     * @shortname transform
     * @drawable true
     */
    transform(
      inputs: Inputs.Manifold.TransformDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Transforms a manifold shape by using the 4x4 transformation matrixes
     * @param inputs manifold and transformation matrixes
     * @returns Transformed manifold shape
     * @group matrix
     * @shortname transforms
     * @drawable true
     */
    transforms(
      inputs: Inputs.Manifold.TransformsDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
    /**
     * Move the vertices of this Manifold (creating a new one) according to any
     * arbitrary input function. It is easy to create a function that warps a
     * geometrically valid object into one which overlaps, but that is not checked
     * here, so it is up to the user to choose their function with discretion.
     * @param inputs manifold and warp function
     * @returns Warped manifold shape
     * @group transforms
     * @shortname warp
     * @drawable true
     */
    warp(
      inputs: Inputs.Manifold.ManifoldWarpDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.ManifoldPointer>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class ManifoldBitByBit {
    private readonly manifoldWorkerManager;
    readonly manifold: Manifold;
    readonly crossSection: ManifoldCrossSection;
    readonly mesh: Mesh;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Turns manifold shape into a mesh pointer that lives in worker's memory. This pointer can be used with bitbybit.manifold.mesh functions
     * @param inputs Manifold shape
     * @returns Pointer to manifold mesh definition
     * @group meshing
     * @shortname manifold to mesh pointer
     * @drawable false
     */
    manifoldToMeshPointer(
      inputs: Inputs.Manifold.ManifoldToMeshDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Manifold.MeshPointer>;
    /**
     * Decomposes manifold or cross section shape into a mesh or simple polygons
     * @param inputs Manifold shape or cross section
     * @returns Decomposed mesh definition or simple polygons
     * @group decompose
     * @shortname decompose m or cs
     * @drawable false
     */
    decomposeManifoldOrCrossSection(
      inputs: Inputs.Manifold.DecomposeManifoldOrCrossSectionDto<
        Inputs.Manifold.ManifoldPointer | Inputs.Manifold.CrossSectionPointer
      >
    ): Promise<
      Inputs.Manifold.DecomposedManifoldMeshDto | Inputs.Base.Vector2[][]
    >;
    /**
     * Turns manifold shape into a collection of polygon points representing the mesh.
     * @param inputs Manifold shape
     * @returns polygon points
     * @group decompose
     * @shortname to polygon points
     * @drawable false
     */
    toPolygonPoints(
      inputs: Inputs.Manifold.ManifoldDto<Inputs.Manifold.ManifoldPointer>
    ): Promise<Inputs.Base.Mesh3>;
    /**
     * Decomposes manifold or cross section shape into a mesh or simple polygons
     * @param inputs Manifold shapes or cross sections
     * @returns Decomposed mesh definitions or a list of simple polygons
     * @group decompose
     * @shortname decompose m's or cs's
     * @drawable false
     */
    decomposeManifoldsOrCrossSections(
      inputs: Inputs.Manifold.DecomposeManifoldsOrCrossSectionsDto<
        Inputs.Manifold.ManifoldPointer | Inputs.Manifold.CrossSectionPointer
      >
    ): Promise<
      (Inputs.Manifold.DecomposedManifoldMeshDto | Inputs.Base.Vector2[][])[]
    >;
    /**
     * Delete manifold or cross section from memory
     * @param inputs manifold or cross section
     * @group cleanup
     * @shortname delete m or cs
     * @drawable false
     */
    deleteManifoldOrCrossSection(
      inputs: Inputs.Manifold.ManifoldOrCrossSectionDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<void>;
    /**
     * Delete manifolds or cross sections from memory
     * @param inputs manifolds or cross sections
     * @group cleanup
     * @shortname delete m's or cs's
     * @drawable false
     */
    deleteManifoldsOrCrossSections(
      inputs: Inputs.Manifold.ManifoldsOrCrossSectionsDto<Inputs.Manifold.CrossSectionPointer>
    ): Promise<void>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class MeshEvaluate {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Get position on mesh vertex index
     * @param inputs mesh
     * @returns point
     * @group basic
     * @shortname position
     * @drawable true
     */
    position(
      inputs: Inputs.Manifold.MeshVertexIndexDto<Inputs.Manifold.MeshPointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the three vertex indices of this triangle in CCW order.
     * @param inputs mesh
     * @returns verts
     * @group basic
     * @shortname verts
     * @drawable false
     */
    verts(
      inputs: Inputs.Manifold.MeshTriangleIndexDto<Inputs.Manifold.MeshPointer>
    ): Promise<number[]>;
    /**
     * Gets the tangent vector starting at verts(tri)[j] pointing to the next
     * Bezier point along the CCW edge. The fourth value is its weight.
     * @param inputs mesh
     * @returns tangent
     * @group basic
     * @shortname tangent
     * @drawable true
     */
    tangent(
      inputs: Inputs.Manifold.MeshHalfEdgeIndexDto<Inputs.Manifold.MeshPointer>
    ): Promise<number[]>;
    /**
     * Gets any other properties associated with this vertex.
     * @param inputs mesh
     * @returns extras
     * @group basic
     * @shortname extras
     * @drawable false
     */
    extras(
      inputs: Inputs.Manifold.MeshVertexIndexDto<Inputs.Manifold.MeshPointer>
    ): Promise<number[]>;
    /**
     * Gets the column-major 4x4 matrix transform from the original mesh to these
     * related triangles.
     * @param inputs mesh
     * @returns transform matrix
     * @group basic
     * @shortname transform 4x4 matrix
     * @drawable false
     */
    transform(
      inputs: Inputs.Manifold.MeshVertexIndexDto<Inputs.Manifold.MeshPointer>
    ): Promise<number[]>;
    /**
     * Number of properties per vertex, always >= 3.
     * @param inputs mesh
     * @returns number of properties
     * @group basic
     * @shortname number props
     * @drawable false
     */
    numProp(
      inputs: Inputs.Manifold.MeshDto<Inputs.Manifold.MeshPointer>
    ): Promise<number>;
    /**
     * Number of property vertices
     * @param inputs mesh
     * @returns number of vertices
     * @group basic
     * @shortname number vertices
     * @drawable false
     */
    numVert(
      inputs: Inputs.Manifold.MeshDto<Inputs.Manifold.MeshPointer>
    ): Promise<number>;
    /**
     * Get number of triangles on mesh
     * @param inputs mesh
     * @returns number of triangles
     * @group basic
     * @shortname number triangles
     * @drawable false
     */
    numTri(
      inputs: Inputs.Manifold.MeshDto<Inputs.Manifold.MeshPointer>
    ): Promise<number>;
    /**
     * Number of triangle runs. Each triangle run is a set of consecutive
     * triangles that all come from the same instance of the same input mesh.
     * @param inputs mesh
     * @returns number of runs
     * @group basic
     * @shortname number runs
     * @drawable false
     */
    numRun(
      inputs: Inputs.Manifold.MeshDto<Inputs.Manifold.MeshPointer>
    ): Promise<number>;
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class Mesh {
    private readonly manifoldWorkerManager;
    readonly operations: MeshOperations;
    readonly evaluate: MeshEvaluate;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
  }
  /**
   * Contains various functions for Solid meshes from Manifold library https://github.com/elalish/manifold
   * Thanks Manifold community for developing this kernel
   */
  declare class MeshOperations {
    private readonly manifoldWorkerManager;
    constructor(manifoldWorkerManager: ManifoldWorkerManager);
    /**
     * Updates the mergeFromVert and mergeToVert vectors in order to create a
     * manifold solid. If the MeshGL is already manifold, no change will occur and
     * the function will return false. Otherwise, this will merge verts along open
     * edges within tolerance (the maximum of the MeshGL tolerance and the
     * baseline bounding-box tolerance), keeping any from the existing merge
     * vectors.
     *
     * There is no guarantee the result will be manifold - this is a best-effort
     * helper function designed primarily to aid in the case where a manifold
     * multi-material MeshGL was produced, but its merge vectors were lost due to
     * a round-trip through a file format. Constructing a Manifold from the result
     * will report a Status if it is not manifold.
     * @param inputs mesh
     * @returns merged mesh
     * @group base
     * @shortname merge
     * @drawable true
     */
    merge(
      inputs: Inputs.Manifold.MeshDto<Inputs.Manifold.MeshPointer>
    ): Promise<Inputs.Manifold.MeshPointer>;
  }
  declare class BitByBitOCCT {
    occtWorkerManager: OCCTWorkerManager;
    occt: OCCT;
    constructor();
    init(occt: Worker): void;
  }
  declare class OCCTBooleans {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Joins separate objects
     * @param inputs Objects to join
     * @returns OpenCascade joined shape
     * @group booleans
     * @shortname union
     * @drawable true
     */
    union(
      inputs: Inputs.OCCT.UnionDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Does boolean difference operation between a main shape and given shapes
     * @param inputs Main shape and shapes to differ
     * @returns OpenCascade difference shape
     * @group booleans
     * @shortname difference
     * @drawable true
     */
    difference(
      inputs: Inputs.OCCT.DifferenceDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Does boolean intersection operation between a main shape and given shapes
     * @param inputs Main shape and shapes to differ
     * @returns OpenCascade intersection of shapes
     * @group booleans
     * @shortname intersection
     * @drawable true
     */
    intersection(
      inputs: Inputs.OCCT.IntersectionDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Does mesh mesh intersection operation between two shapes - both shapes can have their own  meshing precision.
     * This algorithm intersects the meshes and returns the wires of the intersection, which are polylines or polygons.
     * @param inputs Two shapes to intersect
     * @returns Wires where shapes intersect
     * @group mesh based
     * @shortname mesh mesh intersection as wires
     * @drawable true
     */
    meshMeshIntersectionWires(
      inputs: Inputs.OCCT.MeshMeshIntersectionTwoShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Does mesh mesh intersection operation between two shapes - both shapes can have their own  meshing precision.
     * This algorithm intersects the meshes and returns the points of the intersection, which are polylines or polygons.
     * @param inputs Two shapes to intersect
     * @returns Points where shapes intersect
     * @group mesh based
     * @shortname mesh mesh intersection as points
     * @drawable true
     */
    meshMeshIntersectionPoints(
      inputs: Inputs.OCCT.MeshMeshIntersectionTwoShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Does mesh mesh intersection operation between the shape and multiple other shapes - all shapes can have their own meshing precision.
     * This algorithm intersects the meshes and returns the wires of the intersection, which are polylines or polygons.
     * @param inputs Two shapes to intersect
     * @returns Wires where shapes intersect
     * @group mesh based
     * @shortname mesh mesh intersection of shapes as wires
     * @drawable true
     */
    meshMeshIntersectionOfShapesWires(
      inputs: Inputs.OCCT.MeshMeshesIntersectionOfShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Does mesh mesh intersection operation between the shape and multiple other shapes - all shapes can have their own meshing precision.
     * This algorithm intersects the meshes and returns the points of the intersection.
     * @param inputs Two shapes to intersect
     * @returns Wires where shapes intersect
     * @group mesh based
     * @shortname mesh mesh intersection of shapes as points
     * @drawable true
     */
    meshMeshIntersectionOfShapesPoints(
      inputs: Inputs.OCCT.MeshMeshesIntersectionOfShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[][]>;
  }
  declare class OCCTDimensions {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates simple linear length dimension between two points - measuring units. You decide what kind of units you re using by providing a suffix.
     * @param inputs two points, direction, label size, label normal direction, offset, and unit suffix, decimal rounding place
     * @returns compound wires representing dimensions
     * @group simple
     * @shortname linear dimension
     * @drawable true
     */
    simpleLinearLengthDimension(
      inputs: Inputs.OCCT.SimpleLinearLengthDimensionDto
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * Creates simple angular dimension. By default we output degrees, but you can opt to use radians.
     * @param inputs a center, two directions, radius and various label parameters
     * @returns compound wires representing dimension
     * @group simple
     * @shortname angular dimension
     * @drawable true
     */
    simpleAngularDimension(
      inputs: Inputs.OCCT.SimpleAngularDimensionDto
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * @param inputs a start and end point, direction and parameters for the label
     * @returns compound wires representing dimension
     * @group simple
     * @shortname pin with label
     * @drawable true
     */
    pinWithLabel(
      inputs: Inputs.OCCT.PinWithLabelDto
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
  }
  declare class OCCTFillets {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Fillets OpenCascade Shapes
     * @param inputs Shape, radius and edge indexes to fillet
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet edges
     * @drawable true
     */
    filletEdges(
      inputs: Inputs.OCCT.FilletDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets edges list with different radius on each edge.
     * @param inputs Shape, edges and radius list
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet edges list
     * @drawable true
     */
    filletEdgesList(
      inputs: Inputs.OCCT.FilletEdgesListDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets edges list with the single radius on all edges.
     * @param inputs Shape, edges and radius
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet edges list one r
     * @drawable true
     */
    filletEdgesListOneRadius(
      inputs: Inputs.OCCT.FilletEdgesListOneRadiusDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets a single edge with variable radius list on given u params. You need to provide a list of params to identify on which U param to apply the radius on.
     * @param inputs Shape, edge, radius list and param list
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet edge variable r
     * @drawable true
     */
    filletEdgeVariableRadius(
      inputs: Inputs.OCCT.FilletEdgeVariableRadiusDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets multiple provided edges with the same variable radiuses on u params for each edge.
     * @param inputs Shape, edge, radius list and param list
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet edges same variable r
     * @drawable true
     */
    filletEdgesSameVariableRadius(
      inputs: Inputs.OCCT.FilletEdgesSameVariableRadiusDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets multiple provided edges with variable radius lists on given params lists. You need to provide a list of params to identify on which U param to apply the radius on.
     * @param inputs Shape, edge, radius list and param list
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet edges variable r
     * @drawable true
     */
    filletEdgesVariableRadius(
      inputs: Inputs.OCCT.FilletEdgesVariableRadiusDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets OpenCascade 3d wire, this algorithm takes one guiding direction for fillets to be formed.
     * It does not respect tangent directions on each filleted corner. This algorithm is based on extruding wire along the given direction
     * to form a shell, then filleting the shell and finally extracting the filleted wire from the shell itself.
     * Make sure you provide a direction that is not parallel to the wire and that forms high enough extrusion for the fillet to succeed.
     * @param inputs Shape, radius and edge indexes to fillet
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet 3d wire
     * @drawable true
     */
    fillet3DWire(
      inputs: Inputs.OCCT.Fillet3DWireDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets OpenCascade 3d wires, this algorithm takes one guiding direction for fillets to be formed.
     * It does not respect tangent directions on each filleted corner. This algorithm is based on extruding wires along the given direction
     * to form a shell, then filleting the shell and finally extracting the filleted wire from the shell itself.
     * Make sure you provide a direction that is not parallel to the wire and that forms high enough extrusion for the fillet to succeed.
     * @param inputs Shapes, radius and edge indexes to fillet
     * @returns OpenCascade shape with filleted edges
     * @group 3d fillets
     * @shortname fillet 3d wires
     * @drawable true
     */
    fillet3DWires(
      inputs: Inputs.OCCT.Fillet3DWiresDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Chamfer OpenCascade Shape edges
     * @param inputs Shape, distance and edge indexes to chamfer
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edges
     * @drawable true
     */
    chamferEdges(
      inputs: Inputs.OCCT.ChamferDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers edges list with different distance on each edge.
     * @param inputs Shape, edges and distance list
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edges list
     * @drawable true
     */
    chamferEdgesList(
      inputs: Inputs.OCCT.ChamferEdgesListDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers edge by a by two distances. Face indicates the first distance to be applied
     * @param inputs Shape, edge, face, distance1 and distance2
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edge 2 dist
     * @drawable true
     */
    chamferEdgeTwoDistances(
      inputs: Inputs.OCCT.ChamferEdgeTwoDistancesDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers edges by a by two distances. Face indicates the first distance to be applied
     * @param inputs Shape, edges, faces, distance1 and distance2
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edges 2 dist
     * @drawable true
     */
    chamferEdgesTwoDistances(
      inputs: Inputs.OCCT.ChamferEdgesTwoDistancesDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers edges by two distances. Face indicates the first distance to be applied
     * @param inputs Shape, edges, faces, distance1 list and distance2 list
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edges 2 dist lists
     * @drawable true
     */
    chamferEdgesTwoDistancesLists(
      inputs: Inputs.OCCT.ChamferEdgesTwoDistancesListsDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers edge by a given distance and angle from the face
     * @param inputs Shape, edge, face, distance and angle
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edge angle
     * @drawable true
     */
    chamferEdgeDistAngle(
      inputs: Inputs.OCCT.ChamferEdgeDistAngleDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers multiple edges by a given distance and angle from the faces
     * @param inputs Shape, edge, face, distance and angle
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edges angle
     * @drawable true
     */
    chamferEdgesDistAngle(
      inputs: Inputs.OCCT.ChamferEdgesDistAngleDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Chamfers edges by a given distances and angles from the faces
     * @param inputs Shape, edges, faces, distances and angles
     * @returns OpenCascade shape with chamfered edges
     * @group 3d chamfers
     * @shortname chamfer edges angles
     * @drawable true
     */
    chamferEdgesDistsAngles(
      inputs: Inputs.OCCT.ChamferEdgesDistsAnglesDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSEdgePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets 2d wire or face
     * @param inputs Shape
     * @returns OpenCascade filleted shape result
     * @group 2d fillets
     * @shortname fillet 2d wire or face
     * @drawable true
     */
    fillet2d(
      inputs: Inputs.OCCT.FilletDto<
        Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fillets 2d wires or faces
     * @param inputs Shapes
     * @returns OpenCascade filleted shapes result
     * @group 2d fillets
     * @shortname fillet 2d wires or faces
     * @drawable true
     */
    fillet2dShapes(
      inputs: Inputs.OCCT.FilletShapesDto<
        Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Fillets two planar edges into a wire by providing a radius, plane, edges and possible solution index if more than one result exists
     * @param inputs Definition for fillets
     * @returns OpenCascade wire shape if solution is found
     * @group 2d fillets
     * @shortname fillet 2 edges
     * @drawable true
     */
    filletTwoEdgesInPlaneIntoAWire(
      inputs: Inputs.OCCT.FilletTwoEdgesInPlaneDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
  }
  declare class OCCTCurves {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates a 2d ellipse. Be sure to use this geometry only for constructive purposes of modeling, but not for representation. You need to transform these curves to edges in order to draw them.
     * @param inputs 2D Ellipse parameters
     * @returns OpenCascade Geom2d_ellipse
     * @group primitives
     * @shortname ellipse 2d
     */
    geom2dEllipse(
      inputs: Inputs.OCCT.Geom2dEllipseDto
    ): Promise<Inputs.OCCT.Geom2dCurvePointer>;
    /**
     * Creates a trimmed curve from the basis curve limited between U1 and U2. This curve can't be drawn.
     * @param inputs Bounds and strategy for trimming the curve
     * @returns OpenCascade Geom2d_TrimmedCurve
     * @group create
     * @shortname trimmed 2d
     */
    geom2dTrimmedCurve(
      inputs: Inputs.OCCT.Geom2dTrimmedCurveDto<Inputs.OCCT.Geom2dCurvePointer>
    ): Promise<Inputs.OCCT.Geom2dCurvePointer>;
    /**
     * Creates a trimmed 2d curve segment between two 2d points. This curve can't be drawn.
     * @param inputs Two 2d points for start and end
     * @returns OpenCascade Geom2d_Segment
     * @group primitives
     * @shortname segment 2d
     */
    geom2dSegment(
      inputs: Inputs.OCCT.Geom2dSegmentDto
    ): Promise<Inputs.OCCT.Geom2dCurvePointer>;
    /**
     * Gets 2d point represented by [number, number] on a curve at parameter.
     * @param inputs 2D Curve shape and parameter
     * @returns Point as array of 2 numbers
     * @group get
     * @shortname 2d point on curve
     */
    get2dPointFrom2dCurveOnParam(
      inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.Geom2dCurvePointer>
    ): Promise<Inputs.Base.Point2>;
    /**
     * Creates a circle geom curve
     * @param inputs Axis information and radius
     * @returns Opencascade Geom_Circle curve
     * @group primitives
     * @shortname circle
     * @drawable false
     */
    geomCircleCurve(
      inputs: Inputs.OCCT.CircleDto
    ): Promise<Inputs.OCCT.GeomCurvePointer>;
    /**
     * Creates an ellipse geom curve
     * @param inputs Axis information and radius
     * @returns Opencascade Geom_Ellipse curve
     * @group primitives
     * @shortname ellipse
     * @drawable false
     */
    geomEllipseCurve(
      inputs: Inputs.OCCT.EllipseDto
    ): Promise<Inputs.OCCT.GeomCurvePointer>;
  }
  declare class OCCTGeom {
    readonly curves: OCCTCurves;
    readonly surfaces: OCCTSurfaces;
    constructor(occWorkerManager: OCCTWorkerManager);
  }
  declare class OCCTSurfaces {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates an infinite cylindrical surface that can not be drawn. Be sure to use this geometry only for constructive purposes of modeling, but not for representation.
     * @param inputs Cylinder parameters
     * @returns OpenCascade cylindrical surface
     * @group surfaces
     * @shortname cylindrical
     * @drawable false
     */
    cylindricalSurface(
      inputs: Inputs.OCCT.GeomCylindricalSurfaceDto
    ): Promise<Inputs.OCCT.GeomSurfacePointer>;
    /**
     * Creates a surface from the face
     * @param inputs Face shape
     * @returns OpenCascade geom surface
     * @group surfaces
     * @shortname from face
     * @drawable false
     */
    surfaceFromFace(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.GeomSurfacePointer>;
  }
  declare class OCCTIO {
    readonly occWorkerManager: OCCTWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Saves the step file
     * @param inputs STEP filename and shape to be saved
     * @group io
     * @shortname save step
     * @drawable false
     */
    saveShapeSTEP(
      inputs: Inputs.OCCT.SaveStepDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Saves the step file and returns the text value
     * @param inputs STEP filename and shape to be saved
     * @group io
     * @shortname save step and return
     * @drawable false
     */
    saveShapeSTEPAndReturn(
      inputs: Inputs.OCCT.SaveStepDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<string>;
    /**
     * Saves the stl file
     * @param inputs STL filename and shape to be saved
     * @group io
     * @shortname save stl
     * @drawable false
     */
    saveShapeStl(
      inputs: Inputs.OCCT.SaveStlDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Saves the stl file and returns
     * @param inputs STL filename and shape to be saved
     * @group io
     * @shortname save stl return
     * @drawable false
     */
    saveShapeStlAndReturn(
      inputs: Inputs.OCCT.SaveStlDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<string>;
    private saveSTEP;
    private saveStl;
    /**
     * Creates DXF paths from an OCCT shape
     * Important - shapes containing wires must lie on XZ plane (Y=0) for correct 2D DXF export.
     * @param inputs Shape to convert to DXF paths
     * @group dxf
     * @shortname shape to dxf paths
     * @drawable false
     */
    shapeToDxfPaths(
      inputs: Inputs.OCCT.ShapeToDxfPathsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<IO.DxfPathDto[]>;
    /**
     * Adds layer and color information to DXF paths
     * Important - shapes containing wires must lie on XZ plane (Y=0) for correct 2D DXF export.
     * @param inputs DXF paths, layer name, and color
     * @group dxf
     * @shortname dxf paths with layer
     * @drawable false
     */
    dxfPathsWithLayer(
      inputs: Inputs.OCCT.DxfPathsWithLayerDto
    ): Promise<IO.DxfPathsPartDto>;
    /**
     * Assembles multiple path parts into a complete DXF file.
     * Important - shapes containing wires must lie on XZ plane (Y=0) for correct 2D DXF export.
     * @param inputs Multiple DXF paths parts
     * @group dxf
     * @shortname dxf create
     * @drawable false
     */
    dxfCreate(inputs: Inputs.OCCT.DxfPathsPartsListDto): Promise<string>;
  }
  /**
   * Contains various methods for OpenCascade implementation
   */
  declare class OCCT {
    readonly occWorkerManager: OCCTWorkerManager;
    readonly shapes: OCCTShapes;
    readonly geom: OCCTGeom;
    readonly fillets: OCCTFillets;
    readonly transforms: OCCTTransforms;
    readonly operations: OCCTOperations;
    readonly booleans: OCCTBooleans;
    readonly dimensions: OCCTDimensions;
    readonly shapeFix: OCCTShapeFix;
    io: OCCTIO;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates polygon points from the shape faces
     * @param inputs shape
     * @group convert
     * @shortname faces to polygon points
     * @drawable false
     */
    shapeFacesToPolygonPoints(
      inputs: Inputs.OCCT.ShapeFacesToPolygonPointsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Creates mesh from the shape
     * @param inputs shape
     * @group convert
     * @shortname shape to mesh
     * @drawable false
     */
    shapeToMesh(
      inputs: Inputs.OCCT.ShapeToMeshDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.DecomposedMeshDto>;
    /**
     * Creates mesh from the shape
     * @param inputs shape
     * @group convert
     * @shortname shape to mesh
     * @drawable false
     */
    shapesToMeshes(
      inputs: Inputs.OCCT.ShapesToMeshesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.DecomposedMeshDto[]>;
    /**
     * Deletes shape from the cache to keep memory usage low
     * @param inputs shape
     * @group memory
     * @shortname delete shape
     */
    deleteShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Deletes shapes from the cache to keep memory usage low
     * @param inputs shape
     * @group memory
     * @shortname delete shapes
     */
    deleteShapes(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Cleans all cache and all shapes from the memory
     * @param inputs shape
     * @group memory
     * @shortname clean all cache
     */
    cleanAllCache(): Promise<void>;
  }
  declare class OCCTOperations {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Lofts wires into a shell
     * @param inputs Loft wires
     * @returns Resulting loft shape
     * @group lofts
     * @shortname loft
     * @drawable true
     */
    loft(
      inputs: Inputs.OCCT.LoftDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Lofts wires into a shell by using many advanced options
     * @param inputs Advanced loft parameters
     * @returns Resulting loft shell
     * @group lofts
     * @shortname loft adv.
     * @drawable true
     */
    loftAdvanced(
      inputs: Inputs.OCCT.LoftAdvancedDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Computes two closest points between two shapes
     * @param inputs two shapes
     * @returns Resulting points
     * @group closest pts
     * @shortname two shapes
     * @drawable true
     */
    closestPointsBetweenTwoShapes(
      inputs: Inputs.OCCT.ClosestPointsBetweenTwoShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Computes closest points between a list of points and a given shape
     * @param inputs a list of points and a shape
     * @returns Resulting points
     * @group closest pts
     * @shortname on shape
     * @drawable true
     */
    closestPointsOnShapeFromPoints(
      inputs: Inputs.OCCT.ClosestPointsOnShapeFromPointsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Computes closest points between a list of points and shapes
     * @param inputs a list of points and a list of shapes
     * @returns Resulting points
     * @group closest pts
     * @shortname on shapes
     * @drawable true
     */
    closestPointsOnShapesFromPoints(
      inputs: Inputs.OCCT.ClosestPointsOnShapesFromPointsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Computes distances between a list of points and a corresponding closest points on shapes.
     * @param inputs a list of points and a shapes
     * @returns Resulting distances
     * @group measure
     * @shortname distances points to shape
     * @drawable false
     */
    distancesToShapeFromPoints(
      inputs: Inputs.OCCT.ClosestPointsOnShapeFromPointsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<number[]>;
    /**
     * Computes bounding box parameters of the shape
     * @param inputs a shape
     * @returns Min, max center and size of the bounding box
     * @group measure
     * @shortname bbox of shape
     * @drawable false
     */
    boundingBoxOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.BoundingBoxPropsDto>;
    /**
     * Get min point of the bounding box of the shape
     * @param inputs a shape
     * @returns Min point of the bounding box
     * @group measure
     * @shortname bbox min of shape
     * @drawable true
     */
    boundingBoxMinOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get max point of the bounding box of the shape
     * @param inputs a shape
     * @returns Max point of the bounding box
     * @group measure
     * @shortname bbox max of shape
     * @drawable true
     */
    boundingBoxMaxOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get center point of the bounding box of the shape
     * @param inputs a shape
     * @returns Center point of the bounding box
     * @group measure
     * @shortname bbox center of shape
     * @drawable true
     */
    boundingBoxCenterOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get size point of the bounding box of the shape
     * @param inputs a shape
     * @returns Center point of the bounding box
     * @group measure
     * @shortname bbox size of shape
     * @drawable false
     */
    boundingBoxSizeOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Vector3>;
    /**
     * Get bounding box shape of the shape
     * @param inputs a shape
     * @returns shape of the bounding box
     * @group measure
     * @shortname bbox shape of shape
     * @drawable true
     */
    boundingBoxShapeOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Computes bounding sphere parameters of the shape
     * @param inputs a shape
     * @returns Center and radius of the bounding sphere
     * @group measure
     * @shortname bsphere of shape
     * @drawable false
     */
    boundingSphereOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.BoundingSpherePropsDto>;
    /**
     * Get center point of the bounding sphere of the shape
     * @param inputs a shape
     * @returns Center point of the bounding sphere
     * @group measure
     * @shortname bsphere center of shape
     * @drawable false
     */
    boundingSphereCenterOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get radius of the bounding sphere of the shape
     * @param inputs a shape
     * @returns Radius of the bounding sphere
     * @group measure
     * @shortname bsphere radius of shape
     * @drawable false
     */
    boundingSphereRadiusOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<number>;
    /**
     * Get bounding sphere shape of the shape
     * @param inputs a shape
     * @returns shape of the bounding sphere
     * @group measure
     * @shortname bsphere shape of shape
     * @drawable true
     */
    boundingSphereShapeOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Extrudes the shape along direction - wire will produce shell, face will produce solid
     * @param inputs Shape to extrude and direction parameter with tolerance
     * @returns Resulting extruded shape
     * @group extrusions
     * @shortname extrude
     * @drawable true
     */
    extrude(
      inputs: Inputs.OCCT.ExtrudeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Extrudes the shapes along direction
     * @param inputs Shapes to extrude and direction parameter with tolerance
     * @returns Resulting extruded shapes
     * @group extrusions
     * @shortname extrude shapes
     * @drawable true
     */
    extrudeShapes(
      inputs: Inputs.OCCT.ExtrudeShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Splits the shape with shapes
     * @param inputs Shape to split and shapes to split with
     * @returns Resulting shapes
     * @group divisions
     * @shortname split
     * @drawable true
     */
    splitShapeWithShapes(
      inputs: Inputs.OCCT.SplitDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Revolves the shape around the given direction
     * @param inputs Revolve parameters
     * @returns Resulting revolved shape
     * @group revolutions
     * @shortname revolve
     * @drawable true
     */
    revolve(
      inputs: Inputs.OCCT.RevolveDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Rotated extrude that is perofrmed on the shape
     * @param inputs Rotated extrusion inputs
     * @returns OpenCascade shape
     * @group extrusions
     * @shortname rotated extrude
     * @drawable true
     */
    rotatedExtrude(
      inputs: Inputs.OCCT.RotationExtrudeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Pipe shapes along the wire
     * @param inputs Path wire and shapes along the path
     * @returns OpenCascade shape
     * @group pipeing
     * @shortname pipe
     * @drawable true
     */
    pipe(
      inputs: Inputs.OCCT.ShapeShapesDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSShapePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Pipes polyline wire with ngon profile.
     * @param inputs Path polyline wire
     * @returns OpenCascade piped shapes
     * @group pipeing
     * @shortname pipe polyline ngon
     * @drawable true
     */
    pipePolylineWireNGon(
      inputs: Inputs.OCCT.PipePolygonWireNGonDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Pipe wires with cylindrical shape
     * @param inputs Path wires and radius
     * @returns OpenCascade piped shapes
     * @group pipeing
     * @shortname pipe wires cylindrical
     * @drawable true
     */
    pipeWiresCylindrical(
      inputs: Inputs.OCCT.PipeWiresCylindricalDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Pipe wire with cylindrical shape
     * @param inputs Path wire and radius
     * @returns OpenCascade piped shapes
     * @group pipeing
     * @shortname pipe wire cylindrical
     * @drawable true
     */
    pipeWireCylindrical(
      inputs: Inputs.OCCT.PipeWireCylindricalDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Offset for various shapes
     * @param inputs Shape to offset and distance with tolerance
     * @returns Resulting offset shape
     * @group offsets
     * @shortname offset
     * @drawable true
     */
    offset(
      inputs: Inputs.OCCT.OffsetDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Offset advanced that give more options for offset, such as joinType for edges and corners
     * @param inputs Shape to offset and advanced parameters
     * @returns Resulting offset shape
     * @group offsets
     * @shortname offset adv.
     * @drawable true
     */
    offsetAdv(
      inputs: Inputs.OCCT.OffsetAdvancedDto<
        Inputs.OCCT.TopoDSShapePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Thickens the shape into a solid by an offset distance
     * @param inputs OpenCascade shape
     * @returns OpenCascade solid shape
     * @group offsets
     * @shortname thicken
     * @drawable true
     */
    makeThickSolidSimple(
      inputs: Inputs.OCCT.ThisckSolidSimpleDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Thickens the shape into a solid by joining
     * @param inputs OpenCascade shape and options for thickening
     * @returns OpenCascade solid shape
     * @group offsets
     * @shortname joined thicken
     * @drawable true
     */
    makeThickSolidByJoin(
      inputs: Inputs.OCCT.ThickSolidByJoinDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Slices the shape
     * @param inputs OpenCascade shape and options for slicing
     * @returns OpenCascade shape
     * @group divisions
     * @shortname slice
     * @drawable true
     */
    slice(
      inputs: Inputs.OCCT.SliceDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * Slices the shape in step pattern
     * @param inputs OpenCascade shape and options for slicing
     * @returns OpenCascade shape
     * @group divisions
     * @shortname slice in step pattern
     * @drawable true
     */
    sliceInStepPattern(
      inputs: Inputs.OCCT.SliceInStepPatternDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * Offset the 3D wire. When using this method consider using it on filleted wires that do not contain sharp corners.
     * You can use fillet 3D on it.
     * @param inputs wire and shape
     * @returns OpenCascade compound
     * @group offsets
     * @shortname offset 3d wire
     * @drawable true
     */
    offset3DWire(
      inputs: Inputs.OCCT.Offset3DWireDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
  }
  declare class OCCTShapeFix {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Performs the basic shape repair
     * @param inputs the shape to be fixed and some options
     * @returns OpenCascade fixed shape
     * @group shape
     * @shortname basic shape repair
     * @drawable true
     */
    basicShapeRepair(
      inputs: Inputs.OCCT.BasicShapeRepairDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Fix small edge on wire
     * @param inputs the wire to be fixed and some options
     * @returns OpenCascade fixed wire
     * @group wire
     * @shortname fix small edge
     * @drawable true
     */
    fixSmallEdgeOnWire(
      inputs: Inputs.OCCT.FixSmallEdgesInWireDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Fix edge orientations along wire
     * @param inputs the wire to be fixed and some options
     * @returns OpenCascade fixed wire
     * @group wire
     * @shortname fix edge orientations
     * @drawable true
     */
    fixEdgeOrientationsAlongWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
  }
  declare class OCCTCompound {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Makes the compound shape, which can include any kind of shapes
     * @param inputs OpenCascade shapes
     * @returns OpenCascade compounded shape
     * @group create
     * @shortname make
     * @drawable true
     */
    makeCompound(
      inputs: Inputs.OCCT.CompoundShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * Gets the shapes that compound is made of
     * @param inputs OpenCascade shapes
     * @returns OpenCascade compounded shape
     * @group get
     * @shortname get shapes of compound
     * @drawable true
     */
    getShapesOfCompound(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSCompoundPointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
  }
  declare class OCCTEdge {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates linear edge from base line format {start: Point3, end: Point3}
     * @param inputs base line
     * @returns OpenCascade edge
     * @group from base
     * @shortname edge from base line
     * @drawable true
     */
    fromBaseLine(
      inputs: Inputs.OCCT.LineBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates linear edges from base lines format {start: Point3, end: Point3}[]
     * @param inputs base lines
     * @returns OpenCascade edges
     * @group from base
     * @shortname edges from base lines
     * @drawable true
     */
    fromBaseLines(
      inputs: Inputs.OCCT.LineBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Creates linear edge from base segment format [Point3, Point3]
     * @param inputs base segment
     * @returns OpenCascade edge
     * @group from base
     * @shortname edge from base segment
     * @drawable true
     */
    fromBaseSegment(
      inputs: Inputs.OCCT.SegmentBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates linear edge from base segments format [Point3, Point3][]
     * @param inputs base segments
     * @returns OpenCascade edges
     * @group from base
     * @shortname edges from base segments
     * @drawable true
     */
    fromBaseSegments(
      inputs: Inputs.OCCT.SegmentsBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Creates linear edges from collection of points
     * @param inputs Points
     * @returns OpenCascade edges
     * @group from base
     * @shortname edges from points
     * @drawable true
     */
    fromPoints(
      inputs: Inputs.OCCT.PointsDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Creates linear edges from polyline definition
     * @param inputs Polyline
     * @returns OpenCascade edges
     * @group from base
     * @shortname edges from polyline
     * @drawable true
     */
    fromBasePolyline(
      inputs: Inputs.OCCT.PolylineBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Creates linear edges from triangle definition
     * @param inputs Triangle
     * @returns OpenCascade edges
     * @group from base
     * @shortname edges from triangle
     * @drawable true
     */
    fromBaseTriangle(
      inputs: Inputs.OCCT.TriangleBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Creates linear edges from mesh definition
     * @param inputs Mesh
     * @returns OpenCascade edges
     * @group from base
     * @shortname edges from mesh
     * @drawable true
     */
    fromBaseMesh(
      inputs: Inputs.OCCT.MeshBaseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Creates linear edge between two points
     * @param inputs Two points between which edge should be created
     * @returns OpenCascade edge
     * @group primitives
     * @shortname line
     * @drawable true
     */
    line(inputs: Inputs.OCCT.LineDto): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates arc edge between three points
     * @param inputs three points
     * @returns OpenCascade edge
     * @group primitives
     * @shortname arc 3 points
     * @drawable true
     */
    arcThroughThreePoints(
      inputs: Inputs.OCCT.ArcEdgeThreePointsDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates arc edge between two points given the tangent direction vector on first point.
     * @param inputs two points and tangent vector
     * @returns OpenCascade edge
     * @group primitives
     * @shortname arc 2 points tangent
     * @drawable true
     */
    arcThroughTwoPointsAndTangent(
      inputs: Inputs.OCCT.ArcEdgeTwoPointsTangentDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates an arc edge between two points on a circle
     * @param inputs two points and circle edge
     * @returns OpenCascade edge
     * @group primitives
     * @shortname arc from circle and points
     * @drawable true
     */
    arcFromCircleAndTwoPoints(
      inputs: Inputs.OCCT.ArcEdgeCircleTwoPointsDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates an arc edge between two alpha angles on a circle
     * @param inputs two angles and circle edge
     * @returns OpenCascade edge
     * @group primitives
     * @shortname arc from circle and angles
     * @drawable true
     */
    arcFromCircleAndTwoAngles(
      inputs: Inputs.OCCT.ArcEdgeCircleTwoAnglesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates an arc edge between the point on a circle and a given alpha angle
     * @param inputs point, circle edge and alpha angle
     * @returns OpenCascade edge
     * @group primitives
     * @shortname arc from circle point and angle
     * @drawable true
     */
    arcFromCirclePointAndAngle(
      inputs: Inputs.OCCT.ArcEdgeCirclePointAngleDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates OpenCascade circle edge
     * @param inputs Circle parameters
     * @returns OpenCascade circle edge
     * @group primitives
     * @shortname circle
     * @drawable true
     */
    createCircleEdge(
      inputs: Inputs.OCCT.CircleDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Creates OpenCascade ellipse edge
     * @param inputs Ellipse parameters
     * @returns OpenCascade ellipse edge
     * @group primitives
     * @shortname ellipse
     * @drawable true
     */
    createEllipseEdge(
      inputs: Inputs.OCCT.EllipseDto
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Removes internal faces for the shape
     * @param inputs Shape
     * @returns OpenCascade shape with no internal edges
     * @group shapes
     * @shortname remove internal
     * @drawable true
     */
    removeInternalEdges(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Creates an edge from geom curve and geom surface
     * @param inputs shapes are expected to contain 2 array elements - first is geom curve, second geom surface
     * @returns OpenCascade TopoDS_Edge
     * @group from
     * @shortname 2d curve and surface
     * @drawable true
     */
    makeEdgeFromGeom2dCurveAndSurface(
      inputs: Inputs.OCCT.CurveAndSurfaceDto<
        Inputs.OCCT.Geom2dCurvePointer,
        Inputs.OCCT.GeomSurfacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Gets the edge by providing an index from the shape
     * @param inputs Shape
     * @returns OpenCascade edge
     * @group get
     * @shortname get edge
     * @drawable true
     */
    getEdge(
      inputs: Inputs.OCCT.EdgeIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Gets the edges of a shape in a list
     * @param inputs Shape
     * @returns OpenCascade edge list
     * @group get
     * @shortname get edges
     * @drawable true
     */
    getEdges(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Gets the edges of a wire ordered along the direction of the wire
     * @param inputs wire shape
     * @returns OpenCascade edge list
     * @group get
     * @shortname get edges along wire
     * @drawable true
     */
    getEdgesAlongWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Gets circular edges of a wire ordered along the direction of the wire
     * @param inputs wire shape
     * @returns OpenCascade edge list
     * @group get
     * @shortname get circular edges along wire
     * @drawable true
     */
    getCircularEdgesAlongWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Gets linear edges of a wire ordered along the direction of the wire
     * @param inputs wire shape
     * @returns OpenCascade edge list
     * @group get
     * @shortname get linear edges along wire
     * @drawable true
     */
    getLinearEdgesAlongWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;
    /**
     * Gets corner points of edges for a shape. There's no order guarantee here. All duplicates are removed, so when three edges form one corner, that will be represented by a single point in the list.
     * @param inputs Shape that contains edges - wire, face, shell, solid
     * @returns List of points
     * @group get
     * @shortname corners
     * @drawable true
     */
    getCornerPointsOfEdgesForShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the edge length
     * @param inputs edge
     * @returns Length
     * @group get
     * @shortname edge length
     * @drawable false
     */
    getEdgeLength(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<number>;
    /**
     * Gets the edge lengths of the shape
     * @param inputs shape
     * @returns Lengths
     * @group get
     * @shortname edge lengths of shape
     * @drawable false
     */
    getEdgeLengthsOfShape(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<number[]>;
    /**
     * Gets the lengths of the edges
     * @param inputs edges
     * @returns Lengths
     * @group get
     * @shortname lengths
     * @drawable false
     */
    getEdgesLengths(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<number[]>;
    /**
     * Gets the center of mass for the edge
     * @param inputs edge
     * @returns Point representing center of mass
     * @group get
     * @shortname center of mass
     * @drawable true
     */
    getEdgeCenterOfMass(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the centers of mass for the edges
     * @param inputs edges
     * @returns Points representing centers of mass
     * @group get
     * @shortname centers of mass
     * @drawable true
     */
    getEdgesCentersOfMass(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the center point of the circular edge. If edge is not circular, point will not be returned.
     * @param inputs edge
     * @returns Point representing center of the circular edge
     * @group get circular edge
     * @shortname get center of circular edge
     * @drawable true
     */
    getCircularEdgeCenterPoint(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the radius of the circular edge. If edge is not circular, radius will not be returned.
     * @param inputs edge
     * @returns Radius of the circular edge
     * @group get circular edge
     * @shortname get radius of circular edge
     * @drawable false
     */
    getCircularEdgeRadius(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<number>;
    /**
     * Gets the direction vector of the plane of the circular edge. If edge is not circular, direction vector will not be returned.
     * @param inputs edge
     * @returns Direction vector of the circular edge
     * @group get circular edge
     * @shortname get plane direction of circular edge
     * @drawable true
     */
    getCircularEdgePlaneDirection(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Vector3>;
    /**
     * Gets the point on edge at param
     * @param input edge
     * @returns Point on param
     * @group extract
     * @shortname point at param
     * @drawable true
     */
    pointOnEdgeAtParam(
      inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the points on edges at param
     * @param input edges
     * @returns Points on param
     * @group extract
     * @shortname points on edges at param
     * @drawable true
     */
    pointsOnEdgesAtParam(
      inputs: Inputs.OCCT.DataOnGeometryesAtParamDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the points of all edges from a shape in separate lists for each edge
     * @param inputs Shape
     * @returns OpenCascade points lists
     * @group extract
     * @shortname edges to points
     * @drawable false
     */
    edgesToPoints(
      inputs: Inputs.OCCT.EdgesToPointsDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Computes reversed edge from input edge
     * @param inputs Shape
     * @returns OpenCascade edge
     * @group get
     * @shortname reversed edge
     * @drawable true
     */
    reversedEdge(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSEdgePointer>;
    /**
     * Gets the tangent vector on edge at param
     * @param input edge
     * @returns Tangent vector on param
     * @group extract
     * @shortname tangent at param
     * @drawable true
     */
    tangentOnEdgeAtParam(
      inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the tangent vectors on edges at param
     * @param input edges
     * @returns Tangent vectors on param
     * @group extract
     * @shortname tangents on edges at param
     * @drawable true
     */
    tangentsOnEdgesAtParam(
      inputs: Inputs.OCCT.DataOnGeometryesAtParamDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the point on edge at length
     * @param input edge and length
     * @returns Point on edge
     * @group extract
     * @shortname point at length
     * @drawable true
     */
    pointOnEdgeAtLength(
      inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the points on edges at length
     * @param input edges and length
     * @returns Points on edges
     * @group extract
     * @shortname points at length
     * @drawable true
     */
    pointsOnEdgesAtLength(
      inputs: Inputs.OCCT.DataOnGeometryesAtLengthDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the tangent vector on edge at length
     * @param input edge and length
     * @returns Tangent vector on edge
     * @group extract
     * @shortname tangent at length
     * @drawable true
     */
    tangentOnEdgeAtLength(
      inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the tangent vectors on edges at length
     * @param input edges and length
     * @returns Tangent vectors on edges
     * @group extract
     * @shortname tangents at length
     * @drawable true
     */
    tangentsOnEdgesAtLength(
      inputs: Inputs.OCCT.DataOnGeometryesAtLengthDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the start point on edge
     * @param input edge
     * @returns Start point
     * @group extract
     * @shortname start point
     * @drawable true
     */
    startPointOnEdge(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the start points on edges
     * @param input edges
     * @returns Start points
     * @group extract
     * @shortname start points
     * @drawable true
     */
    startPointsOnEdges(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the end point on edge
     * @param input edge
     * @returns End point
     * @group extract
     * @shortname end point
     * @drawable true
     */
    endPointOnEdge(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Gets the end points on edges
     * @param input edges
     * @returns End points
     * @group extract
     * @shortname end points
     * @drawable true
     */
    endPointsOnEdges(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Divides edge by params to points
     * @param input edge and division params
     * @returns Points
     * @group extract
     * @shortname points by params
     * @drawable true
     */
    divideEdgeByParamsToPoints(
      inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Divides edges by params to points
     * @param input edges and division params
     * @returns Points
     * @group extract
     * @shortname points by params on edges
     * @drawable false
     */
    divideEdgesByParamsToPoints(
      inputs: Inputs.OCCT.DivideShapesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Divides edge by length to points
     * @param input edge and division params
     * @returns Points
     * @group extract
     * @shortname points by distance
     * @drawable true
     */
    divideEdgeByEqualDistanceToPoints(
      inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Divides edges by length to points
     * @param input edges and division params
     * @returns Points
     * @group extract
     * @shortname points by distance on edges
     * @drawable false
     */
    divideEdgesByEqualDistanceToPoints(
      inputs: Inputs.OCCT.DivideShapesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Creates lines from two given points till circle tangent locations
     * @param input resulting lines
     * @returns lines
     * @group constraint
     * @shortname tan lines from 2 pts to circle
     * @drawable true
     */
    constraintTanLinesFromTwoPtsToCircle(
      inputs: Inputs.OCCT.ConstraintTanLinesFromTwoPtsToCircleDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Creates lines from a given point till circle tangent locations
     * @param input resulting lines
     * @returns lines
     * @group constraint
     * @shortname tan lines from pt to circle
     * @drawable true
     */
    constraintTanLinesFromPtToCircle(
      inputs: Inputs.OCCT.ConstraintTanLinesFromPtToCircleDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Creates tangent lines between two circles.
     * @param input resulting lines
     * @returns lines
     * @group constraint
     * @shortname tan lines on two circles
     * @drawable true
     */
    constraintTanLinesOnTwoCircles(
      inputs: Inputs.OCCT.ConstraintTanLinesOnTwoCirclesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Creates tangent circles between two circles.
     * @param input resulting circles
     * @returns circles
     * @group constraint
     * @shortname tan circles on two circles
     * @drawable true
     */
    constraintTanCirclesOnTwoCircles(
      inputs: Inputs.OCCT.ConstraintTanCirclesOnTwoCirclesDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Creates tangent circles between a point and a circle.
     * @param input resulting circles
     * @returns circles
     * @group constraint
     * @shortname tan circles on circle and pnt
     * @drawable true
     */
    constraintTanCirclesOnCircleAndPnt(
      inputs: Inputs.OCCT.ConstraintTanCirclesOnCircleAndPntDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Checks whether an edge is linear
     * @param input edge
     * @returns boolean if is linear
     * @group is
     * @shortname is edge linear
     * @drawable false
     */
    isEdgeLinear(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<boolean>;
    /**
     * Checks whether an edge is circular
     * @param input edge
     * @returns boolean if is circular
     * @group is
     * @shortname is edge circular
     * @drawable false
     */
    isEdgeCircular(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<boolean>;
  }
  declare class OCCTFace {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates face from triangle definition
     * @param inputs Triangle
     * @returns OpenCascade face
     * @group from base
     * @shortname face from triangle
     * @drawable true
     */
    fromBaseTriangle(
      inputs: Inputs.OCCT.TriangleBaseDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates faces from mesh definition
     * @param inputs Mesh
     * @returns OpenCascade faces
     * @group from base
     * @shortname faces from mesh
     * @drawable true
     */
    fromBaseMesh(
      inputs: Inputs.OCCT.MeshBaseDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Creates a faces from wires on face
     * @param inputs OpenCascade wires and guiding face
     * @returns OpenCascade faces
     * @group from
     * @shortname faces from wires on face
     * @drawable true
     */
    createFacesFromWiresOnFace(
      inputs: Inputs.OCCT.FacesFromWiresOnFaceDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Creates a face from wire on face
     * @param inputs OpenCascade wire shape and guiding face
     * @returns OpenCascade face shape
     * @group from
     * @shortname face from wire on face
     * @drawable true
     */
    createFaceFromWireOnFace(
      inputs: Inputs.OCCT.FaceFromWireOnFaceDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates a face from wire
     * @param inputs OpenCascade wire shape and indication if face should be planar
     * @returns OpenCascade face shape
     * @group from
     * @shortname face from wire
     * @drawable true
     */
    createFaceFromWire(
      inputs: Inputs.OCCT.FaceFromWireDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates a face from wires. This can produce hollow faces.
     * @param inputs OpenCascade wire shapes and indication if face should be planar
     * @returns OpenCascade face shape
     * @group from
     * @shortname face from wires
     * @drawable true
     */
    createFaceFromWires(
      inputs: Inputs.OCCT.FaceFromWiresDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates a face from wires on the guiding face. This can produce hollow faces.
     * @param inputs OpenCascade wire shapes and indication if wire is inside the face
     * @returns OpenCascade face shape
     * @group from
     * @shortname face from wires on face
     * @drawable true
     */
    createFaceFromWiresOnFace(
      inputs: Inputs.OCCT.FaceFromWiresOnFaceDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates faces from wires
     * @param inputs OpenCascade wire shape and indication if face should be planar
     * @returns OpenCascade face shape
     * @group from
     * @shortname faces from wires
     * @drawable true
     */
    createFacesFromWires(
      inputs: Inputs.OCCT.FacesFromWiresDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Creates face from multiple circle tangent wires
     * @param inputs OpenCascade circle wire shapes
     * @returns OpenCascade face shape
     * @group from
     * @shortname face from circles tan
     * @drawable true
     */
    createFaceFromMultipleCircleTanWires(
      inputs: Inputs.OCCT.FaceFromMultipleCircleTanWiresDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Creates face from multiple circle tangent wire collections
     * @param inputs OpenCascade circle wire shapes
     * @returns OpenCascade face shape
     * @group from
     * @shortname face from multiple circle tan collections
     * @drawable true
     */
    createFaceFromMultipleCircleTanWireCollections(
      inputs: Inputs.OCCT.FaceFromMultipleCircleTanWireCollectionsDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Creates a face from the surface
     * @param inputs Face shape
     * @returns OpenCascade surface
     * @group from
     * @shortname surface
     * @drawable true
     */
    faceFromSurface(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.GeomSurfacePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates a face from the surface and a wire
     * @param inputs OpenCascade surface, a wire and indication wether face should be created inside or not
     * @returns Face shape
     * @group from
     * @shortname surface and wire
     * @drawable true
     */
    faceFromSurfaceAndWire(
      inputs: Inputs.OCCT.FaceFromSurfaceAndWireDto<
        Inputs.OCCT.GeomSurfacePointer,
        Inputs.OCCT.TopoDSWirePointer
      >
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade Polygon face
     * @param inputs Polygon points
     * @returns OpenCascade polygon face
     * @group primitives
     * @shortname polygon
     * @drawable true
     */
    createPolygonFace(
      inputs: Inputs.OCCT.PolygonDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade circle face
     * @param inputs Circle parameters
     * @returns OpenCascade circle face
     * @group primitives
     * @shortname circle
     * @drawable true
     */
    createCircleFace(
      inputs: Inputs.OCCT.CircleDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade hexagons in grid
     * @param inputs Hexagon parameters
     * @returns OpenCascade hexagons in grid
     * @group primitives
     * @shortname hexagons in grid
     * @drawable true
     */
    hexagonsInGrid(
      inputs: Inputs.OCCT.HexagonsInGridDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Creates OpenCascade ellipse face
     * @param inputs Ellipse parameters
     * @returns OpenCascade ellipse face
     * @group primitives
     * @shortname ellipse
     * @drawable true
     */
    createEllipseFace(
      inputs: Inputs.OCCT.EllipseDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade square face
     * @param inputs Square parameters
     * @returns OpenCascade square face
     * @group primitives
     * @shortname square
     * @drawable true
     */
    createSquareFace(
      inputs: Inputs.OCCT.SquareDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade rectangle face
     * @param inputs rectangle parameters
     * @returns OpenCascade rectangle
     * @group primitives
     * @shortname rectangle
     * @drawable true
     */
    createRectangleFace(
      inputs: Inputs.OCCT.RectangleDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade L-polygon face
     * @param inputs L-polygon parameters
     * @returns OpenCascade L-polygon face
     * @group primitives
     * @shortname L-polygon
     * @drawable true
     */
    createLPolygonFace(
      inputs: Inputs.OCCT.LPolygonDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade star face
     * @param inputs Star parameters
     * @returns OpenCascade star face
     * @group primitives
     * @shortname star
     * @drawable true
     */
    createStarFace(
      inputs: Inputs.OCCT.StarDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade christmas tree face
     * @param inputs Christmas tree parameters
     * @returns OpenCascade christmas tree face
     * @group primitives
     * @shortname christmas tree
     * @drawable true
     */
    createChristmasTreeFace(
      inputs: Inputs.OCCT.ChristmasTreeDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade parallelogram face
     * @param inputs Parallelogram parameters
     * @returns OpenCascade parallelogram face
     * @group primitives
     * @shortname parallelogram
     * @drawable true
     */
    createParallelogramFace(
      inputs: Inputs.OCCT.ParallelogramDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade heart face
     * @param inputs Heart parameters
     * @returns OpenCascade heart face
     * @group primitives
     * @shortname heart
     * @drawable true
     */
    createHeartFace(
      inputs: Inputs.OCCT.Heart2DDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade n-gon face
     * @param inputs N-gon parameters
     * @returns OpenCascade n-gon face
     * @group primitives
     * @shortname n-gon
     * @drawable true
     */
    createNGonFace(
      inputs: Inputs.OCCT.NGonWireDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade I-beam profile face
     * @param inputs I-beam profile parameters
     * @returns OpenCascade I-beam profile face
     * @group beam profiles
     * @shortname I-beam profile
     * @drawable true
     */
    createIBeamProfileFace(
      inputs: Inputs.OCCT.IBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade H-beam profile face
     * @param inputs H-beam profile parameters
     * @returns OpenCascade H-beam profile face
     * @group beam profiles
     * @shortname H-beam profile
     * @drawable true
     */
    createHBeamProfileFace(
      inputs: Inputs.OCCT.HBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade T-beam profile face
     * @param inputs T-beam profile parameters
     * @returns OpenCascade T-beam profile face
     * @group beam profiles
     * @shortname T-beam profile
     * @drawable true
     */
    createTBeamProfileFace(
      inputs: Inputs.OCCT.TBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Creates OpenCascade U-beam profile face
     * @param inputs U-beam profile parameters
     * @returns OpenCascade U-beam profile face
     * @group beam profiles
     * @shortname U-beam profile
     * @drawable true
     */
    createUBeamProfileFace(
      inputs: Inputs.OCCT.UBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Gets the face by providing an index from the shape
     * @param inputs Shape
     * @returns OpenCascade face
     * @group get
     * @shortname face
     * @drawable true
     */
    getFace(
      inputs: Inputs.OCCT.ShapeIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Gets the faces of the shape in a list
     * @param inputs Shape
     * @returns OpenCascade faces array
     * @group get
     * @shortname faces
     * @drawable true
     */
    getFaces(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Computes reversed face from input face
     * @param inputs Face
     * @returns OpenCascade face
     * @group get
     * @shortname reversed
     * @drawable true
     */
    reversedFace(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer>;
    /**
     * Subdivides a face to point grid
     * @param inputs Face and options for subdivision
     * @returns points
     * @group extract
     * @shortname points
     * @drawable true
     */
    subdivideToPoints(
      inputs: Inputs.OCCT.FaceSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Subdivides a face to wires
     * @param inputs Face and options for subdivision
     * @returns wires
     * @group extract
     * @shortname wires
     * @drawable true
     */
    subdivideToWires(
      inputs: Inputs.OCCT.FaceSubdivisionToWiresDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Subdivides a face to rectangle wires
     * @param inputs Face and options for subdivision
     * @returns wires
     * @group patterns
     * @shortname rectangle wires on face
     * @drawable true
     */
    subdivideToRectangleWires(
      inputs: Inputs.OCCT.FaceSubdivideToRectangleWiresDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Subdivides a face to rectangle wires
     * @param inputs Face and options for subdivision
     * @returns wires
     * @group patterns
     * @shortname rectangle holes on face
     * @drawable true
     */
    subdivideToRectangleHoles(
      inputs: Inputs.OCCT.FaceSubdivideToRectangleHolesDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Subdivides a face to hexagon wires
     * @param inputs Face and options for subdivision
     * @returns wires
     * @group patterns
     * @shortname hexagon wires on face
     * @drawable true
     */
    subdivideToHexagonWires(
      inputs: Inputs.OCCT.FaceSubdivideToHexagonWiresDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Subdivides a face to hexagon holes
     * @param inputs Face and options for subdivision
     * @returns faces
     * @group patterns
     * @shortname hexagon holes on face
     * @drawable true
     */
    subdivideToHexagonHoles(
      inputs: Inputs.OCCT.FaceSubdivideToHexagonHolesDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSFacePointer[]>;
    /**
     * Subdivides a face to point grid with shifts and removals on nth uv rows or columns
     * @param inputs Face and params for subdivision
     * @returns points
     * @group extract
     * @shortname points nth
     * @drawable true
     */
    subdivideToPointsControlled(
      inputs: Inputs.OCCT.FaceSubdivisionControlledDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Subdivides a face to normals grid
     * @param inputs Face and params for subdivision
     * @returns normal vectors
     * @group extract
     * @shortname normals
     * @drawable true
     */
    subdivideToNormals(
      inputs: Inputs.OCCT.FaceSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Vector3[]>;
    /**
     * Subdivides a face to uv grid
     * @param inputs Face and params for subdivision
     * @returns uv params in array
     * @group extract
     * @shortname uvs
     * @drawable true
     */
    subdivideToUV(
      inputs: Inputs.OCCT.FaceSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point2[]>;
    /**
     * Get point on UV where U and V are described between 0 and 1. These will be mapped to real bounds.
     * @param inputs Face and params for subdivision
     * @returns point
     * @group extract
     * @shortname point on uv
     * @drawable true
     */
    pointOnUV(
      inputs: Inputs.OCCT.DataOnUVDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get normal on UV where U and V are described between 0 and 1. These will be mapped to real bounds.
     * @param inputs Face and params for subdivision
     * @returns normal vector
     * @group extract
     * @shortname normal on uv
     * @drawable true
     */
    normalOnUV(
      inputs: Inputs.OCCT.DataOnUVDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Vector3>;
    /**
     * Get points on UVs where U and V are described between 0 and 1 in two dimensional arrays. These will be mapped to real bounds.
     * @param inputs Face and params for subdivision
     * @returns points
     * @group extract
     * @shortname points on uvs
     * @drawable true
     */
    pointsOnUVs(
      inputs: Inputs.OCCT.DataOnUVsDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Get normals on UVs where U and V are described between 0 and 1 in two dimensional arrays. These will be mapped to real bounds.
     * @param inputs Face and params for subdivision
     * @returns normals
     * @group extract
     * @shortname normals on uvs
     * @drawable true
     */
    normalsOnUVs(
      inputs: Inputs.OCCT.DataOnUVsDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Vector3[]>;
    /**
     * Subdivides a face to points along a line on parameter
     * @param inputs Face and params for subdivision
     * @returns points
     * @group extract
     * @shortname points on param
     * @drawable true
     */
    subdivideToPointsOnParam(
      inputs: Inputs.OCCT.FaceLinearSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the wire along the parameter on the face
     * @param inputs Face and param
     * @returns wire
     * @group extract
     * @shortname wire along param
     * @drawable true
     */
    wireAlongParam(
      inputs: Inputs.OCCT.WireAlongParamDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Gets the wires along the parameters on the face
     * @param inputs Face and params
     * @returns wires
     * @group extract
     * @shortname wires along params
     * @drawable true
     */
    wiresAlongParams(
      inputs: Inputs.OCCT.WiresAlongParamsDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Gets the U min bound of the face
     * @param inputs OCCT Face
     * @returns u min bound
     * @group get
     * @shortname u min
     * @drawable false
     */
    getUMinBound(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<number>;
    /**
     * Gets the U max bound of the face
     * @param inputs OCCT Face
     * @returns u max bound
     * @group get
     * @shortname u max
     * @drawable false
     */
    getUMaxBound(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<number>;
    /**
     * Gets the V min bound of the face
     * @param inputs OCCT Face
     * @returns v min bound
     * @group get
     * @shortname v min
     * @drawable false
     */
    getVMinBound(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<number>;
    /**
     * Gets the V max bound of the face
     * @param inputs OCCT Face
     * @returns v max bound
     * @group get
     * @shortname v max
     * @drawable false
     */
    getVMaxBound(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<number>;
    /**
     * Get the area of the face
     * @param inputs OCCT Face
     * @returns area
     * @group get
     * @shortname face area
     * @drawable false
     */
    getFaceArea(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<number>;
    /**
     * Get the areas of the faces
     * @param inputs OCCT Faces
     * @returns areas
     * @group get
     * @shortname areas of faces
     * @drawable false
     */
    getFacesAreas(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<number[]>;
    /**
     * Get the face center of mass point
     * @param inputs OCCT Face
     * @returns point
     * @group get
     * @shortname center of mass
     * @drawable true
     */
    getFaceCenterOfMass(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get the center of mass points for faces
     * @param inputs OCCT Faces
     * @returns points
     * @group get
     * @shortname centers of mass
     * @drawable true
     */
    getFacesCentersOfMass(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Filters points on face
     * @param inputs face and collection of points with options
     * @returns filtered points
     * @group filter
     * @shortname filter face points
     * @drawable true
     */
    filterFacePoints(
      inputs: Inputs.OCCT.FilterFacePointsDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Filters points on faces
     * @param inputs faces and collection of points with options
     * @returns filtered points
     * @group filter
     * @shortname filter points on faces
     * @drawable true
     */
    filterFacesPoints(
      inputs: Inputs.OCCT.FilterFacesPointsDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.Base.Point3[] | Inputs.Base.Point3[][]>;
  }
  declare class OCCTShape {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Remove internal edges that are not connected to any face in the shape
     * @param inputs shape
     * @returns purged shape
     * @group edit
     * @shortname purge internal edges
     * @drawable true
     */
    purgeInternalEdges(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Unifies faces, edges in the same domain and has possibility to concatinate bsplines
     * @param inputs shape
     * @returns unified shape
     * @group edit
     * @shortname unify same domain
     * @drawable true
     */
    unifySameDomain(
      inputs: Inputs.OCCT.UnifySameDomainDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Check if the shape is closed
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is closed
     * @drawable false
     */
    isClosed(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is convex
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is convex
     * @drawable false
     */
    isConvex(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is checked
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is checked
     * @drawable false
     */
    isChecked(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is free
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is free
     * @drawable false
     */
    isFree(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is infinite
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is infinite
     * @drawable false
     */
    isInfinite(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is modified
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is modified
     * @drawable false
     */
    isModified(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is locked
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is locked
     * @drawable false
     */
    isLocked(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is null
     * @param inputs shape
     * @returns boolean answer
     * @group analysis
     * @shortname is null
     * @drawable false
     */
    isNull(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is equal to other shape
     * @param inputs shapes
     * @returns boolean answer
     * @group analysis
     * @shortname is equal
     * @drawable false
     */
    isEqual(
      inputs: Inputs.OCCT.CompareShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is not equal to other shape
     * @param inputs shapes
     * @returns boolean answer
     * @group analysis
     * @shortname is not equal
     * @drawable false
     */
    isNotEqual(
      inputs: Inputs.OCCT.CompareShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is partner to other shape
     * @param inputs shapes
     * @returns boolean answer
     * @group analysis
     * @shortname is partner
     * @drawable false
     */
    isPartner(
      inputs: Inputs.OCCT.CompareShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Check if the shape is the same as the other shape
     * @param inputs shapes
     * @returns boolean answer
     * @group analysis
     * @shortname is same
     * @drawable false
     */
    isSame(
      inputs: Inputs.OCCT.CompareShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<boolean>;
    /**
     * Get the shape orientation
     * @param inputs shape
     * @returns shape orientation
     * @group analysis
     * @shortname get orientation
     * @drawable false
     */
    getOrientation(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.topAbsOrientationEnum>;
    /**
     * Get the shape type
     * @param inputs shape
     * @returns shape type
     * @group analysis
     * @shortname get shape type
     * @drawable false
     */
    getShapeType(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.shapeTypeEnum>;
  }
  declare class OCCTShapes {
    readonly vertex: OCCTVertex;
    readonly edge: OCCTEdge;
    readonly wire: OCCTWire;
    readonly face: OCCTFace;
    readonly shell: OCCTShell;
    readonly solid: OCCTSolid;
    readonly compound: OCCTCompound;
    readonly shape: OCCTShape;
    constructor(occWorkerManager: OCCTWorkerManager);
  }
  declare class OCCTShell {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates a shell from faces
     * @param inputs OpenCascade shell and faces
     * @returns OpenCascade shell
     * @group create
     * @shortname sew
     * @drawable true
     */
    sewFaces(
      inputs: Inputs.OCCT.SewDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Inputs.OCCT.TopoDSShellPointer>;
    /**
     * Get shell surface area
     * @param inputs shell shape
     * @returns Surface area
     * @group get
     * @shortname area
     * @drawable false
     */
    getShellSurfaceArea(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShellPointer>
    ): Promise<number>;
  }
  declare class OCCTSolid {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates Solid From shell that must be closed
     * @param inputs Closed shell to make into solid
     * @returns OpenCascade Solid
     * @group from
     * @shortname solid from closed shell
     * @drawable true
     */
    fromClosedShell(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShellPointer>
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade Box
     * @param inputs Box size and center
     * @returns OpenCascade Box
     * @group primitives
     * @shortname box
     * @drawable true
     */
    createBox(
      inputs: Inputs.OCCT.BoxDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade Cube
     * @param inputs Cube size and center
     * @returns OpenCascade Cube
     * @group primitives
     * @shortname cube
     * @drawable true
     */
    createCube(
      inputs: Inputs.OCCT.CubeDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade Box from corner
     * @param inputs Box size and corner coordinates
     * @returns OpenCascade Box
     * @group primitives
     * @shortname box corner
     * @drawable true
     */
    createBoxFromCorner(
      inputs: Inputs.OCCT.BoxFromCornerDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade Cylinder
     * @param inputs Cylinder parameters
     * @returns OpenCascade Cylinder
     * @group primitives
     * @shortname cylinder
     * @drawable true
     */
    createCylinder(
      inputs: Inputs.OCCT.CylinderDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade Cylinders on simple bit by bit lines represented by two points
     * @param inputs Cylinder parameters
     * @returns OpenCascade Cylinder
     * @group primitives
     * @shortname cylinders on lines
     * @drawable true
     */
    createCylindersOnLines(
      inputs: Inputs.OCCT.CylindersOnLinesDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer[]>;
    /**
     * Creates OpenCascade Sphere
     * @param inputs Sphere radius and center
     * @returns OpenCascade Sphere
     * @group primitives
     * @shortname sphere
     * @drawable true
     */
    createSphere(
      inputs: Inputs.OCCT.SphereDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade Cone
     * @param inputs Cone parameters
     * @returns OpenCascade cone shape
     * @group primitives
     * @shortname cone
     * @drawable true
     */
    createCone(
      inputs: Inputs.OCCT.ConeDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade star solid
     * @param inputs Star solid parameters
     * @returns OpenCascade star solid
     * @group primitives
     * @shortname star
     * @drawable true
     */
    createStarSolid(
      inputs: Inputs.OCCT.StarSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade n-gon solid
     * @param inputs N-gon solid parameters
     * @returns OpenCascade n-gon solid
     * @group primitives
     * @shortname n-gon
     * @drawable true
     */
    createNGonSolid(
      inputs: Inputs.OCCT.NGonSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade parallelogram solid
     * @param inputs Parallelogram solid parameters
     * @returns OpenCascade parallelogram solid
     * @group primitives
     * @shortname parallelogram
     * @drawable true
     */
    createParallelogramSolid(
      inputs: Inputs.OCCT.ParallelogramSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade heart solid
     * @param inputs Heart solid parameters
     * @returns OpenCascade heart solid
     * @group primitives
     * @shortname heart
     * @drawable true
     */
    createHeartSolid(
      inputs: Inputs.OCCT.HeartSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade christmas tree solid
     * @param inputs Christmas tree solid parameters
     * @returns OpenCascade christmas tree solid
     * @group primitives
     * @shortname christmas tree
     * @drawable true
     */
    createChristmasTreeSolid(
      inputs: Inputs.OCCT.ChristmasTreeSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade L-polygon solid
     * @param inputs L-polygon solid parameters
     * @returns OpenCascade L-polygon solid
     * @group primitives
     * @shortname L-polygon
     * @drawable true
     */
    createLPolygonSolid(
      inputs: Inputs.OCCT.LPolygonSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade I-beam profile solid
     * @param inputs I-beam profile solid parameters
     * @returns OpenCascade I-beam profile solid
     * @group beam
     * @shortname I-beam profile
     * @drawable true
     */
    createIBeamProfileSolid(
      inputs: Inputs.OCCT.IBeamProfileSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade H-beam profile solid
     * @param inputs H-beam profile solid parameters
     * @returns OpenCascade H-beam profile solid
     * @group beam
     * @shortname H-beam profile
     * @drawable true
     */
    createHBeamProfileSolid(
      inputs: Inputs.OCCT.HBeamProfileSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade T-beam profile solid
     * @param inputs T-beam profile solid parameters
     * @returns OpenCascade T-beam profile solid
     * @group beam
     * @shortname T-beam profile
     * @drawable true
     */
    createTBeamProfileSolid(
      inputs: Inputs.OCCT.TBeamProfileSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Creates OpenCascade U-beam profile solid
     * @param inputs U-beam profile solid parameters
     * @returns OpenCascade U-beam profile solid
     * @group beam
     * @shortname U-beam profile
     * @drawable true
     */
    createUBeamProfileSolid(
      inputs: Inputs.OCCT.UBeamProfileSolidDto
    ): Promise<Inputs.OCCT.TopoDSSolidPointer>;
    /**
     * Get solid surface area
     * @param inputs Closed solid shape
     * @returns Surface area
     * @group get
     * @shortname area
     * @drawable false
     */
    getSolidSurfaceArea(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSSolidPointer>
    ): Promise<number>;
    /**
     * Get solid volume
     * @param inputs Closed solid shape
     * @returns volume
     * @group get
     * @shortname volume
     * @drawable false
     */
    getSolidVolume(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSSolidPointer>
    ): Promise<number>;
    /**
     * Get solids volumes
     * @param inputs Closed solid shapes
     * @returns volumes
     * @group get
     * @shortname volumes
     * @drawable false
     */
    getSolidsVolumes(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSSolidPointer>
    ): Promise<number[]>;
    /**
     * Get solid center of mass
     * @param inputs Closed solid shape
     * @returns center of mass point
     * @group get
     * @shortname center of mass
     * @drawable true
     */
    getSolidCenterOfMass(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSSolidPointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get centers of mass of solids
     * @param inputs Closed solid shapes
     * @returns Points indicating centers of mass
     * @group get
     * @shortname centers of mass
     * @drawable true
     */
    getSolidsCentersOfMass(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSSolidPointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Gets the solids of the shape in a list
     * @param inputs Shape
     * @returns OpenCascade solids array
     * @group get
     * @shortname solids
     * @drawable true
     */
    getSolids(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSSolidPointer[]>;
    /**
     * Filters collection of points based on relationship with the solid. You can choose whether to output in, on or out points.
     * @param inputs OpenCascade solid and collection of points with options
     * @returns filtered points
     * @group filter
     * @shortname filter solid points
     * @drawable true
     */
    filterSolidPoints(
      inputs: Inputs.OCCT.FilterSolidPointsDto<Inputs.OCCT.TopoDSSolidPointer>
    ): Promise<Inputs.Base.Point3[]>;
  }
  declare class OCCTVertex {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates vertex shape from x y z coordinates
     * @param inputs x y z coordinates
     * @returns OpenCascade vertex
     * @group from
     * @shortname vertex from xyz
     * @drawable true
     */
    vertexFromXYZ(
      inputs: Inputs.OCCT.XYZDto
    ): Promise<Inputs.OCCT.TopoDSVertexPointer>;
    /**
     * Creates vertex shape from point
     * @param inputs a point
     * @returns OpenCascade vertex
     * @group from
     * @shortname vertex from point
     * @drawable true
     */
    vertexFromPoint(
      inputs: Inputs.OCCT.PointDto
    ): Promise<Inputs.OCCT.TopoDSVertexPointer>;
    /**
     * Creates vertices from points
     * @param inputs a point
     * @returns OpenCascade vertices
     * @group from
     * @shortname vertices from points
     * @drawable true
     */
    verticesFromPoints(
      inputs: Inputs.OCCT.PointsDto
    ): Promise<Inputs.OCCT.TopoDSVertexPointer[]>;
    /**
     * Creates compound shape containing multiple vertices. This simply speeds up rendering and allows to apply occt transformations easily on vertex groups.
     * @param inputs points
     * @returns OpenCascade vertices as compound shape
     * @group from
     * @shortname compound vertices from points
     * @drawable true
     */
    verticesCompoundFromPoints(
      inputs: Inputs.OCCT.PointsDto
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * Get all vertices in the list of a shape
     * @param inputs a shape
     * @returns OpenCascade vertices
     * @group get
     * @shortname get vertices from shape
     * @drawable true
     */
    getVertices(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSVertexPointer[]>;
    /**
     * Get all vertices in the list of a shape as points
     * @param inputs a shape
     * @returns Points
     * @group get
     * @shortname get vertices as points
     * @drawable true
     */
    getVerticesAsPoints(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Transforms vertices to points
     * @param inputs a vertex shapes
     * @returns Points
     * @group transform
     * @shortname vertices to points
     * @drawable true
     */
    verticesToPoints(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSVertexPointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Transform vertex to point
     * @param inputs a vertex shape
     * @returns Point
     * @group transform
     * @shortname vertex to point
     * @drawable true
     */
    vertexToPoint(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSVertexPointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * @param inputs points, shape and direction that includes the length
     * @returns Points
     * @group place
     * @shortname project points
     * @drawable true
     */
    projectPoints(
      inputs: Inputs.OCCT.ProjectPointsOnShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[]>;
  }
  declare class OCCTWire {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Creates linear wire from base line format {start: Point3, end: Point3}
     * @param inputs base line
     * @returns OpenCascade wire
     * @group from base
     * @shortname wire from base line
     * @drawable true
     */
    fromBaseLine(
      inputs: Inputs.OCCT.LineBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates linear wires from base lines format {start: Point3, end: Point3}[]
     * @param inputs base lines
     * @returns OpenCascade wires
     * @group from base
     * @shortname wires from base lines
     * @drawable true
     */
    fromBaseLines(
      inputs: Inputs.OCCT.LineBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Creates linear wire from base segment format [Point3, Point3]
     * @param inputs base segment
     * @returns OpenCascade wire
     * @group from base
     * @shortname wire from base segment
     * @drawable true
     */
    fromBaseSegment(
      inputs: Inputs.OCCT.SegmentBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates linear wires from base segments format [Point3, Point3][]
     * @param inputs base segments
     * @returns OpenCascade wires
     * @group from base
     * @shortname wires from base segments
     * @drawable true
     */
    fromBaseSegments(
      inputs: Inputs.OCCT.SegmentsBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Creates wire from collection of points
     * @param inputs Points
     * @returns OpenCascade wire
     * @group from base
     * @shortname wire from points
     * @drawable true
     */
    fromPoints(
      inputs: Inputs.OCCT.PointsDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates wire from polyline definition
     * @param inputs Polyline
     * @returns OpenCascade wire
     * @group from base
     * @shortname wire from polyline
     * @drawable true
     */
    fromBasePolyline(
      inputs: Inputs.OCCT.PolylineBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates wire from triangle definition
     * @param inputs Triangle
     * @returns OpenCascade wire
     * @group from base
     * @shortname wire from triangle
     * @drawable true
     */
    fromBaseTriangle(
      inputs: Inputs.OCCT.TriangleBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates wires from mesh definition
     * @param inputs Mesh
     * @returns OpenCascade wires
     * @group from base
     * @shortname wires from mesh
     * @drawable true
     */
    fromBaseMesh(
      inputs: Inputs.OCCT.MeshBaseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Creates OpenCascade Polygon wire
     * @param inputs Polygon points
     * @returns OpenCascade polygon wire shape
     * @group via points
     * @shortname polygon
     * @drawable true
     */
    createPolygonWire(
      inputs: Inputs.OCCT.PolygonDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade Polygons
     * @param inputs Polygon points
     * @returns OpenCascade polygon wires shapes
     * @group multiple
     * @shortname polygons
     * @drawable true
     */
    createPolygons(
      inputs: Inputs.OCCT.PolygonsDto
    ): Promise<
      Inputs.OCCT.TopoDSWirePointer[] | Inputs.OCCT.TopoDSCompoundPointer
    >;
    /**
     * Creates OpenCascade line wire
     * @param inputs line start and end point
     * @returns OpenCascade line wire shape
     * @group via points
     * @shortname line
     * @drawable true
     */
    createLineWire(
      inputs: Inputs.OCCT.LineDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade line wire with extensions
     * @param inputs line start and end point and extension lengths for both start and end
     * @returns OpenCascade line wire shape
     * @group via points
     * @shortname line with extensions
     * @drawable true
     */
    createLineWireWithExtensions(
      inputs: Inputs.OCCT.LineWithExtensionsDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade lines
     * @param inputs lines with start and end points
     * @returns OpenCascade line wire shapes
     * @group multiple
     * @shortname lines
     * @drawable true
     */
    createLines(
      inputs: Inputs.OCCT.LinesDto
    ): Promise<
      Inputs.OCCT.TopoDSWirePointer[] | Inputs.OCCT.TopoDSCompoundPointer
    >;
    /**
     * Splits a wire on a set of given points
     * @param inputs wire and a list of points
     * @returns OpenCascade line wire shapes
     * @group extract
     * @shortname split on points
     * @drawable true
     */
    splitOnPoints(
      inputs: Inputs.OCCT.SplitWireOnPointsDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Transform shape wires to points ordered in lists.
     * This also removes duplicated points between start end end points of
     * consecutive edges on the wire
     * @param inputs OCCT shape
     * @returns point lists for wires
     * @group extract
     * @shortname wires to points
     * @drawable false
     */
    wiresToPoints(
      inputs: Inputs.OCCT.WiresToPointsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Creates OpenCascade polyline wire
     * @param inputs polyline points
     * @returns OpenCascade polyline wire shape
     * @group via points
     * @shortname polyline
     * @drawable true
     */
    createPolylineWire(
      inputs: Inputs.OCCT.PolylineDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates zig zag between two wires
     * @param inputs two wires and zig zag parameters
     * @returns OpenCascade polyline wire shape
     * @group via wires
     * @shortname zig zag between two wires
     * @drawable true
     */
    createZigZagBetweenTwoWires(
      inputs: Inputs.OCCT.ZigZagBetweenTwoWiresDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates a tangent wire enclosing two planar circles
     * @param inputs two circle wires and tolerance
     * @returns OpenCascade wire shape
     * @group via wires
     * @shortname tangent wire from two circles
     * @drawable true
     */
    createWireFromTwoCirclesTan(
      inputs: Inputs.OCCT.WireFromTwoCirclesTanDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade polyline wires
     * @param inputs polylines
     * @returns OpenCascade polyline wire shapes
     * @group multiple
     * @shortname polylines
     * @drawable true
     */
    createPolylines(
      inputs: Inputs.OCCT.PolylinesDto
    ): Promise<
      Inputs.OCCT.TopoDSWirePointer[] | Inputs.OCCT.TopoDSCompoundPointer
    >;
    /**
     * Creates OpenCascade Bezier wire
     * @param inputs Points through which to make bezier curve
     * @returns OpenCascade Bezier wire
     * @group via points
     * @shortname bezier
     * @drawable true
     */
    createBezier(
      inputs: Inputs.OCCT.BezierDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade Bezier wire with weights
     * @param inputs Points through which to make bezier curve and weights on those points which are used to control the curve
     * @returns OpenCascade Bezier wire
     * @group via points
     * @shortname bezier weights
     * @drawable true
     */
    createBezierWeights(
      inputs: Inputs.OCCT.BezierWeightsDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade Bezier wires
     * @param inputs Multiple bezier wire definitions
     * @returns OpenCascade Bezier wires
     * @group multiple
     * @shortname bezier wires
     * @drawable true
     */
    createBezierWires(
      inputs: Inputs.OCCT.BezierWiresDto
    ): Promise<
      Inputs.OCCT.TopoDSWirePointer[] | Inputs.OCCT.TopoDSCompoundPointer
    >;
    /**
     * Creates OpenCascade BSpline wire from points. This method can be used to create nicely shaped (periodic) loops.
     * @param inputs Points through which to make the curve, periodic bool and tolerance
     * @returns OpenCascade BSpline wire
     * @group via points
     * @shortname interpolate
     * @drawable true
     */
    interpolatePoints(
      inputs: Inputs.OCCT.InterpolationDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade multiple interpolated wires
     * @param inputs Interpolated wire definitions
     * @returns OpenCascade BSpline wires
     * @group multiple
     * @shortname interpolate wires
     * @drawable true
     */
    interpolateWires(
      inputs: Inputs.OCCT.InterpolateWiresDto
    ): Promise<
      Inputs.OCCT.TopoDSWirePointer[] | Inputs.OCCT.TopoDSCompoundPointer
    >;
    /**
     * Creates OpenCascade BSPline wire
     * @param inputs Points through which to make BSpline
     * @returns OpenCascade BSpline wire
     * @group via points
     * @shortname bspline
     * @drawable true
     */
    createBSpline(
      inputs: Inputs.OCCT.BSplineDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade BSPline wires
     * @param inputs Points through which to make BSpline
     * @returns OpenCascade BSpline wires
     * @group multiple
     * @shortname bsplines
     * @drawable true
     */
    createBSplines(
      inputs: Inputs.OCCT.BSplinesDto
    ): Promise<
      Inputs.OCCT.TopoDSWirePointer[] | Inputs.OCCT.TopoDSCompoundPointer
    >;
    /**
     * Combines OpenCascade edges and wires into a single wire
     * @param inputs List of shapes of edges and wires
     * @returns OpenCascade wire
     * @group build
     * @shortname combine
     * @drawable true
     */
    combineEdgesAndWiresIntoAWire(
      inputs: Inputs.OCCT.ShapesDto<
        Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates wire from edge
     * @param inputs An edge to transform into a wire
     * @returns OpenCascade wire
     * @group build
     * @shortname wire from edge
     * @drawable true
     */
    createWireFromEdge(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Adds OpenCascade edges and wires into another wire
     * @param inputs List of shapes of edges and wires and a single shape wire to which edges need to be added
     * @returns OpenCascade wire
     * @group build
     * @shortname extend
     * @drawable true
     */
    addEdgesAndWiresToWire(
      inputs: Inputs.OCCT.ShapeShapesDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSEdgePointer
      >
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Divides OpenCascade wire to points blindly following its parametric space
     * @param inputs Describes into how many points should the wire be divided
     * @returns Points on wire
     * @group extract
     * @shortname points by params
     * @drawable true
     */
    divideWireByParamsToPoints(
      inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Divides OpenCascade wires to points blindly following its parametric space
     * @param inputs Describes into how many points should the wires be divided
     * @returns Points on wire
     * @group extract from wires
     * @shortname points by params
     * @drawable true
     */
    divideWiresByParamsToPoints(
      inputs: Inputs.OCCT.DivideShapesDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3[][]>;
    /**
     * Divides OpenCascade wire to equal distance points
     * @param inputs Describes into how many points should the wire be divided
     * @returns Points on wire
     * @group extract
     * @shortname points by distance
     * @drawable true
     */
    divideWireByEqualDistanceToPoints(
      inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Divides OpenCascade wires to equal distance points
     * @param inputs Describes into how many points should the wires be divided
     * @returns Points on wire
     * @group extract from wires
     * @shortname points by distance
     * @drawable true
     */
    divideWiresByEqualDistanceToPoints(
      inputs: Inputs.OCCT.DivideShapesDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Evaluates point on a wire at parameter value between 0 and 1, being start and end points
     * @param inputs Wire shape and parameter
     * @returns Point as array of 3 numbers
     * @group extract
     * @shortname point at param
     * @drawable true
     */
    pointOnWireAtParam(
      inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Evaluates point on a wire at certain length
     * @param inputs Wire shape and length value
     * @returns Point as array of 3 numbers
     * @group extract
     * @shortname point at length
     * @drawable true
     */
    pointOnWireAtLength(
      inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Evaluates points on a wire at certain lengths
     * @param inputs Wire shape and lengths array
     * @returns Points as arrays of 3 numbers
     * @group extract
     * @shortname points at lengths
     * @drawable true
     */
    pointsOnWireAtLengths(
      inputs: Inputs.OCCT.DataOnGeometryAtLengthsDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Evaluates points on a wire at equal length
     * @param inputs Wire shape and length
     * @returns Points as arrays of 3 numbers
     * @group extract
     * @shortname points at equal length
     * @drawable true
     */
    pointsOnWireAtEqualLength(
      inputs: Inputs.OCCT.PointsOnWireAtEqualLengthDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Evaluates points on a wire at pattern of lengths
     * @param inputs Wire shape and lengths pattern
     * @returns Points as arrays of 3 numbers
     * @group extract
     * @shortname points at pattern of lengths
     * @drawable true
     */
    pointsOnWireAtPatternOfLengths(
      inputs: Inputs.OCCT.PointsOnWireAtPatternOfLengthsDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Evaluates tangent vector on a wire at parameter value between 0 and 1, being start and end points
     * @param inputs Wire shape and parameter
     * @returns Tangent vector as array of 3 numbers
     * @group extract
     * @shortname tangent at param
     * @drawable true
     */
    tangentOnWireAtParam(
      inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Vector3>;
    /**
     * Evaluates tangent vector on a wire at certain length
     * @param inputs Wire shape and length value
     * @returns Tangent vector as array of 3 numbers
     * @group extract
     * @shortname tangent at length
     * @drawable true
     */
    tangentOnWireAtLength(
      inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Vector3>;
    /**
     * Computes 3 derivative vectors of a curve at a given length
     * @param inputs Wire shape and length value
     * @returns Three arrays of vectors. Each vector represents derivatives in order - first, second, third
     * @group extract
     * @shortname derivatives at length
     * @drawable false
     */
    derivativesOnWireAtLength(
      inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<[Inputs.Base.Vector3, Inputs.Base.Vector3, Inputs.Base.Vector3]>;
    /**
     * Computes 3 derivative vectors of a curve on parameter between 0 and 1.
     * @param inputs Wire shape and parameter value
     * @returns Three arrays of vectors. Each vector represents derivatives in order - first, second, third
     * @group extract
     * @shortname derivatives at param
     * @drawable false
     */
    derivativesOnWireAtParam(
      inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<[Inputs.Base.Vector3, Inputs.Base.Vector3, Inputs.Base.Vector3]>;
    /**
     * Computes the start point on the wire at param 0
     * @param inputs Wire shape
     * @returns The start point on wire
     * @group extract
     * @shortname start point
     * @drawable true
     */
    startPointOnWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Computes the middle point on the wire at param 0.5
     * @param inputs Wire shape
     * @returns The middle point on wire
     * @group extract
     * @shortname mid point
     * @drawable true
     */
    midPointOnWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Computes the end point on the wire at param 1
     * @param inputs Wire shape
     * @returns The length of the wire
     * @group extract
     * @shortname end point
     * @drawable true
     */
    endPointOnWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Creates OpenCascade circle wire
     * @param inputs Circle parameters
     * @returns OpenCascade circle wire
     * @group primitives
     * @shortname circle
     * @drawable true
     */
    createCircleWire(
      inputs: Inputs.OCCT.CircleDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade hexagon wires in grid
     * @param inputs grid parameters
     * @returns OpenCascade hexagon wires
     * @group primitives
     * @shortname hegagons in grid
     * @drawable true
     */
    hexagonsInGrid(
      inputs: Inputs.OCCT.HexagonsInGridDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Creates OpenCascade square wire
     * @param inputs Square parameters
     * @returns OpenCascade square wire
     * @group primitives
     * @shortname square
     * @drawable true
     */
    createSquareWire(
      inputs: Inputs.OCCT.SquareDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade star wire
     * @param inputs star parameters
     * @returns OpenCascade star wire
     * @group primitives
     * @shortname star
     * @drawable true
     */
    createStarWire(
      inputs: Inputs.OCCT.StarDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates Christmas tree wire
     * @param inputs christmas tree parameters
     * @returns OpenCascade christmas tree wire
     * @group primitives
     * @shortname christmas tree
     * @drawable true
     */
    createChristmasTreeWire(
      inputs: Inputs.OCCT.ChristmasTreeDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade n-gon wire
     * @param inputs ngon parameters
     * @returns OpenCascade ngon wire
     * @group primitives
     * @shortname n-gon
     * @drawable true
     */
    createNGonWire(
      inputs: Inputs.OCCT.NGonWireDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates n parallelogram wire
     * @param inputs parallelogram parameters
     * @returns OpenCascade parallelogram wire
     * @group primitives
     * @shortname parallelogram
     * @drawable true
     */
    createParallelogramWire(
      inputs: Inputs.OCCT.ParallelogramDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates a heart wire
     * @param inputs heart parameters
     * @returns OpenCascade heart shaped wire
     * @group primitives
     * @shortname heart
     * @drawable true
     */
    createHeartWire(
      inputs: Inputs.OCCT.Heart2DDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade rectangle wire
     * @param inputs rectangle parameters
     * @returns OpenCascade rectangle
     * @group primitives
     * @shortname rectangle
     * @drawable true
     */
    createRectangleWire(
      inputs: Inputs.OCCT.RectangleDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade L polygon wire
     * @param inputs L polygon parameters
     * @returns OpenCascade polygon
     * @group primitives
     * @shortname L polygon
     * @drawable true
     */
    createLPolygonWire(
      inputs: Inputs.OCCT.LPolygonDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade I-beam profile wire
     * @param inputs I-beam profile parameters
     * @returns OpenCascade I-beam profile wire
     * @group beam profiles
     * @shortname I-beam profile
     * @drawable true
     */
    createIBeamProfileWire(
      inputs: Inputs.OCCT.IBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade H-beam profile wire
     * @param inputs H-beam profile parameters
     * @returns OpenCascade H-beam profile wire
     * @group beam profiles
     * @shortname H-beam profile
     * @drawable true
     */
    createHBeamProfileWire(
      inputs: Inputs.OCCT.HBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade T-beam profile wire
     * @param inputs T-beam profile parameters
     * @returns OpenCascade T-beam profile wire
     * @group beam profiles
     * @shortname T-beam profile
     * @drawable true
     */
    createTBeamProfileWire(
      inputs: Inputs.OCCT.TBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade U-beam profile wire
     * @param inputs U-beam profile parameters
     * @returns OpenCascade U-beam profile wire
     * @group beam profiles
     * @shortname U-beam profile
     * @drawable true
     */
    createUBeamProfileWire(
      inputs: Inputs.OCCT.UBeamProfileDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade ellipse wire
     * @param inputs Ellipse parameters
     * @returns OpenCascade ellipse wire
     * @group primitives
     * @shortname ellipse
     * @drawable true
     */
    createEllipseWire(
      inputs: Inputs.OCCT.EllipseDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Creates OpenCascade text wires based on simplex font created by Dr. A. V. Hershey
     * @param inputs Text parameters
     * @returns OpenCascade text wires
     * @group primitives
     * @shortname text wires
     * @drawable true
     */
    textWires(
      inputs: Inputs.OCCT.TextWiresDto
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Creates OpenCascade compound out of text wires and returns additional information based on simplex font created by Dr. A. V. Hershey
     * @param inputs Text parameters
     * @returns OpenCascade text compound derivative data
     * @group primitives
     * @shortname text wires deriv
     * @drawable true
     */
    textWiresWithData(
      inputs: Inputs.OCCT.TextWiresDto
    ): Promise<Models.OCCT.TextWiresDataDto<Inputs.OCCT.TopoDSCompoundPointer>>;
    /**
     * Gets the wire by providing an index from the shape
     * @param inputs Shape
     * @returns OpenCascade wire
     * @group get
     * @shortname wire
     * @drawable true
     */
    getWire(
      inputs: Inputs.OCCT.ShapeIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Gets all the wires from the shape
     * @param inputs Shape
     * @returns OpenCascade wires
     * @group get
     * @shortname wires
     * @drawable true
     */
    getWires(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Get the wire center of mass point
     * @param inputs OCCT Wire
     * @returns point
     * @group get
     * @shortname center of mass
     * @drawable true
     */
    getWireCenterOfMass(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3>;
    /**
     * Get the wires centers of mass point
     * @param inputs OCCT Wires
     * @returns points
     * @group get
     * @shortname centers of mass
     * @drawable true
     */
    getWiresCentersOfMass(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.Base.Point3[]>;
    /**
     * Computes reversed wire from input wire
     * @param inputs Shape
     * @returns OpenCascade wire
     * @group get
     * @shortname reversed
     * @drawable true
     */
    reversedWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Computes reversed wire by reversing all edges and combining them into a new wire
     * @param inputs Shape
     * @returns OpenCascade wire
     * @group get
     * @shortname reversed wire by rev edges
     * @drawable true
     */
    reversedWireFromReversedEdges(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Checks whether wire is closed
     * @param inputs wire
     * @returns boolean
     * @group get
     * @shortname is wire closed
     * @drawable false
     */
    isWireClosed(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<boolean>;
    /**
     * Gets the wire length
     * @param inputs wire
     * @returns Length
     * @group get
     * @shortname length
     * @drawable false
     */
    getWireLength(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<number>;
    /**
     * Gets the lengths of wires
     * @param inputs wires
     * @returns Lengths
     * @group get
     * @shortname lengths
     * @drawable false
     */
    getWiresLengths(
      inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<number[]>;
    /**
     * Places a wire on the face by mapping it's 2d coordinates to UV space. Wire must be positioned on the ground XZ plane for this to work.
     * @param inputs two shapes - first a wire and second a face
     * @returns OpenCascade wire
     * @group place
     * @shortname wire on face
     * @drawable true
     */
    placeWireOnFace(
      inputs: Inputs.OCCT.WireOnFaceDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Places multiple wires on the face by mapping it's 2d coordinates to UV space. Wires must be positioned on the ground XZ plane for this to work.
     * @param inputs a face and a list of wires
     * @returns OpenCascade wires
     * @group place
     * @shortname wires on face
     * @drawable true
     */
    placeWiresOnFace(
      inputs: Inputs.OCCT.WiresOnFaceDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSFacePointer
      >
    ): Promise<Inputs.OCCT.TopoDSWirePointer[]>;
    /**
     * Closes the open wire with additional straight edge joining start and end points
     * @param inputs Shape
     * @returns OpenCascade wire
     * @group edit
     * @shortname close open wire
     * @drawable true
     */
    closeOpenWire(
      inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>
    ): Promise<Inputs.OCCT.TopoDSWirePointer>;
    /**
     * Project wire on the shape
     * @param inputs wire and shape
     * @returns OpenCascade compound
     * @group place
     * @shortname project
     * @drawable true
     */
    project(
      inputs: Inputs.OCCT.ProjectWireDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSShapePointer
      >
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer>;
    /**
     * Project multiple wires on the shape
     * @param inputs wire and shape
     * @returns OpenCascade compound
     * @group place
     * @shortname project wires
     * @drawable true
     */
    projectWires(
      inputs: Inputs.OCCT.ProjectWiresDto<
        Inputs.OCCT.TopoDSWirePointer,
        Inputs.OCCT.TopoDSShapePointer
      >
    ): Promise<Inputs.OCCT.TopoDSCompoundPointer[]>;
  }
  declare class OCCTTransforms {
    private readonly occWorkerManager;
    constructor(occWorkerManager: OCCTWorkerManager);
    /**
     * Transforms the shape
     * @param inputs Transformation description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname transform
     * @drawable true
     */
    transform(
      inputs: Inputs.OCCT.TransformDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Rotate the shape
     * @param inputs Rotation description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname rotate
     * @drawable true
     */
    rotate(
      inputs: Inputs.OCCT.RotateDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Rotate the shape around the provided center
     * @param inputs Rotation description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname rotate around center
     * @drawable true
     */
    rotateAroundCenter(
      inputs: Inputs.OCCT.RotateAroundCenterDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Align the shape
     * @param inputs Align description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname align
     * @drawable true
     */
    align(
      inputs: Inputs.OCCT.AlignDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Align the shape with normal and axis
     * @param inputs Align description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname align normal and axis
     * @drawable true
     */
    alignNormAndAxis(
      inputs: Inputs.OCCT.AlignNormAndAxisDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Align and translates the shape
     * @param inputs Align description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname align and translate
     * @drawable true
     */
    alignAndTranslate(
      inputs: Inputs.OCCT.AlignAndTranslateDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Translates the shape
     * @param inputs Translation description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname translate
     * @drawable true
     */
    translate(
      inputs: Inputs.OCCT.TranslateDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Scales the shape
     * @param inputs Scale description
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname scale
     * @drawable true
     */
    scale(
      inputs: Inputs.OCCT.ScaleDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Scales the shape in 3D
     * @param inputs Scale 3D description
     * @returns OpenCascade scaled shape
     * @group on single shape
     * @shortname scale 3d
     * @drawable true
     */
    scale3d(
      inputs: Inputs.OCCT.Scale3DDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Mirrors the shape
     * @param inputs Mirror axis origin, axis direction and shape
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname mirror
     * @drawable true
     */
    mirror(
      inputs: Inputs.OCCT.MirrorDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Mirrors the shape along the normal and origin
     * @param inputs Normal for mirroring with origin
     * @returns OpenCascade shape
     * @group on single shape
     * @shortname mirror normal
     * @drawable true
     */
    mirrorAlongNormal(
      inputs: Inputs.OCCT.MirrorAlongNormalDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Transforms the array of shapes with transformations
     * @param inputs Transformation descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname transforms
     * @drawable true
     */
    transformShapes(
      inputs: Inputs.OCCT.TransformShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Rotate the shapes with rotations
     * @param inputs Rotation descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname rotations
     * @drawable true
     */
    rotateShapes(
      inputs: Inputs.OCCT.RotateShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Rotate the shapes around the center and an axis
     * @param inputs Rotation descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname rotations around center
     * @drawable true
     */
    rotateAroundCenterShapes(
      inputs: Inputs.OCCT.RotateAroundCenterShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Align the shapes with alignments
     * @param inputs Align descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname alignments
     * @drawable true
     */
    alignShapes(
      inputs: Inputs.OCCT.AlignShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Align and translate the shapes
     * @param inputs Align descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname align and translate
     * @drawable true
     */
    alignAndTranslateShapes(
      inputs: Inputs.OCCT.AlignAndTranslateShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Translates the shapes with translations
     * @param inputs Translation descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname translations
     * @drawable true
     */
    translateShapes(
      inputs: Inputs.OCCT.TranslateShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Scales the shapes with scale factors
     * @param inputs Scale descriptions
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname scales
     * @drawable true
     */
    scaleShapes(
      inputs: Inputs.OCCT.ScaleShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Scales the shape in 3D
     * @param inputs Scale 3D descriptions
     * @returns OpenCascade scaled shapes
     * @group on shapes
     * @shortname scales 3d
     * @drawable true
     */
    scale3dShapes(
      inputs: Inputs.OCCT.Scale3DShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Mirrors the shapes with multiple mirrors
     * @param inputs Mirror axis origins, axis directions and shapes
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname mirrors
     * @drawable true
     */
    mirrorShapes(
      inputs: Inputs.OCCT.MirrorShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
    /**
     * Mirrors the shapes along the normal and origin
     * @param inputs Normals for mirroring with origins
     * @returns OpenCascade shapes
     * @group on shapes
     * @shortname mirrors normal
     * @drawable true
     */
    mirrorAlongNormalShapes(
      inputs: Inputs.OCCT.MirrorAlongNormalShapesDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Inputs.OCCT.TopoDSShapePointer[]>;
  }
  /**
   * Contains various functions that expose BABYLONJS objects
   */
  declare class Babylon {
    mesh: BabylonMesh;
    gaussianSplatting: BabylonGaussianSplatting;
    camera: BabylonCamera;
    webXr: BabylonWebXR;
    node: BabylonNode;
    engine: BabylonEngine;
    scene: BabylonScene;
    transforms: BabylonTransforms;
    io: BabylonIO;
    ray: BabylonRay;
    pick: BabylonPick;
    material: BabylonMaterial;
    lights: BabylonLights;
    meshBuilder: BabylonMeshBuilder;
    texture: BabylonTexture;
    tools: BabylonTools;
    gui: BabylonGui;
    gizmo: BabylonGizmo;
    constructor(context: Context, drawHelper: DrawHelper, color: Color);
  }
  declare class BabylonArcRotateCamera {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates a camera that rotates around a given target while traveling the arc path. This camera is suitable for simple 3D navigation and is a default camera used by bitbybit.
     * @param inputs Describes the arc rotate camera
     * @returns BabylonJS arc rotate camera
     * @group create
     * @shortname new arc rotate camera
     */
    create(
      inputs: Inputs.BabylonCamera.ArcRotateCameraDto
    ): BABYLON.ArcRotateCamera;
    private getRadians;
  }
  declare class BabylonCamera {
    private readonly context;
    free: BabylonFreeCamera;
    arcRotate: BabylonArcRotateCamera;
    target: BabylonTargetCamera;
    constructor(context: Context);
    /**
     * Freeze projection matrix of the camera
     * @param inputs camera to freeze
     * @group adjust
     * @shortname freeze projection matrix
     */
    freezeProjectionMatrix(inputs: Inputs.BabylonCamera.CameraDto): void;
    /**
     * Unfreeze projection matrix of the camera
     * @param inputs camera to unfreeze
     * @group adjust
     * @shortname unfreeze projection matrix
     */
    unfreezeProjectionMatrix(inputs: Inputs.BabylonCamera.CameraDto): void;
    /**
     * Changes the position of a camera
     * @param inputs camera and position
     * @group set
     * @shortname set camera position
     */
    setPosition(inputs: Inputs.BabylonCamera.PositionDto): void;
    /**
     * Gets the position of a camera
     * @param inputs camera
     * @group get
     * @shortname get camera position
     */
    getPosition(inputs: Inputs.BabylonCamera.PositionDto): Base.Point3;
    /**
     * Changes the target of a camera
     * @param inputs camera and target
     * @group set
     * @shortname set camera target
     */
    setTarget(inputs: Inputs.BabylonCamera.TargetDto): void;
    /**
     * Gets the target of a camera
     * @param inputs camera
     * @group get
     * @shortname get camera target
     */
    getTarget(inputs: Inputs.BabylonCamera.PositionDto): Base.Point3;
    /**
     * Changes the speed of a camera
     * @param inputs camera and speed
     * @group set
     * @shortname set camera speed
     */
    setSpeed(inputs: Inputs.BabylonCamera.SpeedDto): void;
    /**
     * Gets the speed of a camera
     * @param inputs camera
     * @group get
     * @shortname get camera speed
     */
    getSpeed(inputs: Inputs.BabylonCamera.PositionDto): Base.Point3;
    /**
     * Changes the minZ of a camera
     * @param inputs camera
     * @group set
     * @shortname set camera min z
     */
    setMinZ(inputs: Inputs.BabylonCamera.MinZDto): void;
    /**
     * Changes the maxZ of a camera
     * @param inputs camera and maxz value
     * @group set
     * @shortname camera max z
     */
    setMaxZ(inputs: Inputs.BabylonCamera.MaxZDto): void;
    /**
     * Changes the the mode of the camera to orthographic
     * @param inputs the camera and orthographic properties
     * @group adjust
     * @shortname enable orthographic mode
     */
    makeCameraOrthographic(inputs: Inputs.BabylonCamera.OrthographicDto): void;
    /**
     * Changes the mode of a camera to perspective
     * @param inputs Changes the camera maxZ
     * @group adjust
     * @shortname enable perspective mode
     */
    makeCameraPerspective(inputs: Inputs.BabylonCamera.CameraDto): void;
  }
  declare class BabylonFreeCamera {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates a free camera
     * @param inputs Describes the free camera
     * @returns BabylonJS free camera
     * @group create
     * @shortname new free camera
     */
    create(inputs: Inputs.BabylonCamera.FreeCameraDto): BABYLON.FreeCamera;
  }
  declare class BabylonTargetCamera {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates a target camera
     * @param inputs Describes the target camera
     * @returns BabylonJS target camera
     * @group create
     * @shortname new target camera
     */
    create(inputs: Inputs.BabylonCamera.TargetCameraDto): BABYLON.TargetCamera;
  }
  declare class BabylonEngine {
    private readonly context;
    constructor(context: Context);
    /**
     * Gets the engine for the current context
     * @ignore true
     * @group engine
     * @shortname get engine
     */
    getEngine(): BABYLON.Engine | BABYLON.WebGPUEngine;
    /**
     * Gets the rendering canvas on which scene cameras can be attached
     * @ignore true
     * @group engine
     * @shortname get rendering canvas
     */
    getRenderingCanvas(): HTMLCanvasElement;
  }
  declare class BabylonGaussianSplatting {
    private readonly context;
    constructor(context: Context);
    /** Creates gaussian splatting mesh
     * @param inputs Contains url of Gaussian splatting mesh
     * @group create
     * @shortname gaussian splatting mesh
     * @disposableOutput true
     */
    create(
      inputs: Inputs.BabylonGaussianSplatting.CreateGaussianSplattingMeshDto
    ): Promise<BABYLON.GaussianSplattingMesh>;
    /** Clones gaussian splatting mesh
     * @param inputs Contains BabylonJS mesh that should be cloned
     * @group multiply
     * @shortname clone splat
     * @disposableOutput true
     */
    clone(
      inputs: Inputs.BabylonGaussianSplatting.GaussianSplattingMeshDto
    ): BABYLON.GaussianSplattingMesh;
    /**
     * Gets splat positions of the gaussian splat mesh
     * @param inputs Contains BabylonJS mesh
     * @group get
     * @shortname get splat positions
     * @drawable true
     */
    getSplatPositions(
      inputs: Inputs.BabylonGaussianSplatting.GaussianSplattingMeshDto
    ): Inputs.Base.Point3[];
    private enableShadows;
  }
  declare class BabylonGizmoAxisDragGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Sets if axis is enabled or not
     * @param inputs axis drag gizmo
     * @returns axis drag gizmo
     * @group set
     * @shortname set is axis enabled
     */
    setIsEnabled(
      inputs: Inputs.BabylonGizmo.SetIsEnabledAxisDragGizmoDto
    ): BABYLON.IAxisDragGizmo;
    /**
     * Checks if axis is enabled
     * @param inputs axis drag gizmo
     * @returns is enabled
     * @group get
     * @shortname is axis enabled
     */
    getIsEnabled(inputs: Inputs.BabylonGizmo.AxisDragGizmoDto): boolean;
  }
  declare class BabylonGizmoAxisScaleGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Sets if axis is enabled or not
     * @param inputs axis scale gizmo
     * @returns axis scale gizmo
     * @group set
     * @shortname set is axis enabled
     */
    setIsEnabled(
      inputs: Inputs.BabylonGizmo.SetIsEnabledAxisScaleGizmoDto
    ): BABYLON.IAxisScaleGizmo;
    /**
     * Checks if axis is enabled
     * @param inputs axis scale gizmo
     * @returns is enabled
     * @group get
     * @shortname is axis enabled
     */
    getIsEnabled(inputs: Inputs.BabylonGizmo.AxisScaleGizmoDto): boolean;
  }
  declare class BabylonGizmoBoundingBoxGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Set bounding box gizmo rotation sphere size
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set rotation sphere size
     */
    setRotationSphereSize(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoRotationSphereSizeDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * If set, the rotation anchors and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false) Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set fixed drag mesh screen size
     */
    setFixedDragMeshScreenSize(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoFixedDragMeshScreenSizeDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo fixed drag mesh bounds size
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set fixed drag mesh bounds size
     */
    setFixedDragMeshBoundsSize(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoFixedDragMeshBoundsSizeDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set fixed drag mesh screen size dist factor
     */
    setFixedDragMeshScreenSizeDistanceFactor(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoFixedDragMeshScreenSizeDistanceFactorDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo scaling snap distance. Drag distance in babylon units that the gizmo will snap scaling to when dragged.
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set scaling snap dist.
     */
    setScalingSnapDistance(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoScalingSnapDistanceDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo rotation snap distance. Drag distance in babylon units that the gizmo will snap rotation to when dragged.
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set rotation snap dist.
     */
    setRotationSnapDistance(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoRotationSnapDistanceDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo scale box size
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set scale box size
     */
    setScaleBoxSize(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoScaleBoxSizeDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo incremental snap. Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...
     * @param inputs bounding box gizmo
     * @returns bounding box gizmo
     * @group set
     * @shortname set incremental snap
     */
    setIncrementalSnap(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoIncrementalSnapDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo scale pivot. Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)
     * @param inputs bounding box gizmo and scale pivot
     * @returns bounding box gizmo
     * @group set
     * @shortname set scale pivot
     */
    setScalePivot(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoScalePivotDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo axis factor. Set custom sensitivity value for each axis
     * @param inputs bounding box gizmo and axis factor
     * @returns bounding box gizmo
     * @group set
     * @shortname set axis factor
     */
    setAxisFactor(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoAxisFactorDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Set bounding box gizmo scale drag speed
     * @param inputs bounding box gizmo and scale drag speed
     * @returns bounding box gizmo
     * @group set
     * @shortname set scale drag speed
     */
    setScaleDragSpeed(
      inputs: Inputs.BabylonGizmo.SetBoundingBoxGizmoScaleDragSpeedDto
    ): BABYLON.BoundingBoxGizmo;
    /**
     * Get rotation sphere size
     * @param inputs bounding box gizmo
     * @returns rotation sphere size
     * @group get
     * @shortname get rotation sphere size
     */
    getRotationSphereSize(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): number;
    /**
     * Get scale box size
     * @param inputs bounding box gizmo
     * @returns scale box size
     * @group get
     * @shortname get scale box size
     */
    getScaleBoxSize(inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto): number;
    /**
     * Get fixed drag mesh screen size
     * @param inputs bounding box gizmo
     * @returns fixed drag mesh screen size
     * @group get
     * @shortname get fixed drag mesh screen size
     */
    getFixedDragMeshScreenSize(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): boolean;
    /**
     * Get fixed drag mesh bounds size
     * @param inputs bounding box gizmo
     * @returns fixed drag mesh bounds size
     * @group get
     * @shortname get fixed drag mesh bounds size
     */
    getFixedDragMeshBoundsSize(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): boolean;
    /**
     * Get fixed drag mesh screen size distance factor
     * @param inputs bounding box gizmo
     * @returns fixed drag mesh screen size distance factor
     * @group get
     * @shortname get fixed drag mesh screen size distance factor
     */
    getFixedDragMeshScreenSizeDistanceFactor(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): number;
    /**
     * Get scaling snap distance
     * @param inputs bounding box gizmo
     * @returns scaling snap distance
     * @group get
     * @shortname get scaling snap distance
     */
    getScalingSnapDistance(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): number;
    /**
     * Get rotation snap distance
     * @param inputs bounding box gizmo
     * @returns rotation snap distance
     * @group get
     * @shortname get rotation snap distance
     */
    getRotationSnapDistance(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): number;
    /**
     * Get incremental snap
     * @param inputs bounding box gizmo
     * @returns incremental snap
     * @group get
     * @shortname get incremental snap
     */
    getIncrementalSnap(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): boolean;
    /**
     * Get scale pivot
     * @param inputs bounding box gizmo
     * @returns scale pivot
     * @group get
     * @shortname get scale pivot
     */
    getScalePivot(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): Inputs.Base.Vector3;
    /**
     * Get axis factor
     * @param inputs bounding box gizmo
     * @returns axis factor
     * @group get
     * @shortname get axis factor
     */
    getAxisFactor(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto
    ): Inputs.Base.Vector3;
    /**
     * Get scale drag speed
     * @param inputs bounding box gizmo
     * @returns scale drag speed
     * @group get
     * @shortname get scale drag speed
     */
    getScaleDragSpeed(inputs: Inputs.BabylonGizmo.BoundingBoxGizmoDto): number;
    /**
     * Creates the selector of an observable for a bounding box gizmo
     * @param inputs observable name
     * @returns bounding box gizmo observable selector
     * @group create
     * @shortname bounding box gizmo observable selector
     */
    createBoundingBoxGizmoObservableSelector(
      inputs: Inputs.BabylonGizmo.BoundingBoxGizmoObservableSelectorDto
    ): Inputs.BabylonGizmo.boundingBoxGizmoObservableSelectorEnum;
  }
  declare class BabylonGizmoBase {
    private readonly context;
    constructor(context: Context);
    /**
     * Set gizmo scale ratio
     * @param inputs gizmo
     * @group set
     * @shortname set scale ratio
     */
    scaleRatio(
      inputs: Inputs.BabylonGizmo.SetGizmoScaleRatioDto
    ): BABYLON.IGizmo;
    /**
     * Gets scale ratio
     * @param inputs gizmo
     * @returns scale ratio
     * @group get
     * @shortname get scale ratio
     */
    getScaleRatio(inputs: Inputs.BabylonGizmo.GizmoDto): number;
  }
  declare class BabylonGizmo {
    private readonly context;
    manager: BabylonGizmoManager;
    base: BabylonGizmoBase;
    positionGizmo: BabylonGizmoPositionGizmo;
    rotationGizmo: BabylonGizmoRotationGizmo;
    scaleGizmo: BabylonGizmoScaleGizmo;
    boundingBoxGizmo: BabylonGizmoBoundingBoxGizmo;
    axisDragGizmo: BabylonGizmoAxisDragGizmo;
    axisScaleGizmo: BabylonGizmoAxisScaleGizmo;
    planeDragGizmo: BabylonGizmoPlaneDragGizmo;
    planeRotationGizmo: BabylonGizmoPlaneRotationGizmo;
    constructor(context: Context);
  }
  declare class BabylonGizmoManager {
    private readonly context;
    constructor(context: Context);
    /**
     * Create gizmo manager
     * @param inputs gizmo manager options
     * @group create
     * @shortname create gizmo manager
     * @disposableOutput true
     */
    createGizmoManager(
      inputs: Inputs.BabylonGizmo.CreateGizmoDto
    ): BABYLON.GizmoManager;
    /**
     * Get position gizmo
     * @param inputs gizmo manager
     * @returns position gizmo
     * @group get
     * @shortname get position gizmo
     */
    getPositionGizmo(
      inputs: Inputs.BabylonGizmo.GizmoManagerDto
    ): BABYLON.IPositionGizmo;
    /**
     * Get rotation gizmo
     * @param inputs gizmo manager
     * @returns rotation gizmo
     * @group get
     * @shortname get rotation gizmo
     */
    getRotationGizmo(
      inputs: Inputs.BabylonGizmo.GizmoManagerDto
    ): BABYLON.IRotationGizmo;
    /**
     * Get scale gizmo
     * @param inputs gizmo manager
     * @returns scale gizmo
     * @group get
     * @shortname get scale gizmo
     */
    getScaleGizmo(
      inputs: Inputs.BabylonGizmo.GizmoManagerDto
    ): BABYLON.IScaleGizmo;
    /**
     * Get bounding box gizmo
     * @param inputs gizmo manager
     * @returns bounding box gizmo
     * @group get
     * @shortname get bounding box gizmo
     */
    getBoundingBoxGizmo(
      inputs: Inputs.BabylonGizmo.GizmoManagerDto
    ): BABYLON.IBoundingBoxGizmo;
    /**
     * Attach gizmo manager to mesh
     * @param inputs gizmo manager, mesh
     * @returns gizmo manager
     * @group update
     * @shortname attach to mesh
     */
    attachToMesh(
      inputs: Inputs.BabylonGizmo.AttachToMeshDto
    ): BABYLON.GizmoManager;
    /**
     * Detach gizmo manager from mesh
     * @param inputs gizmo manager, mesh
     * @returns gizmo manager
     * @group update
     * @shortname detach mesh
     */
    detachMesh(
      inputs: Inputs.BabylonGizmo.GizmoManagerDto
    ): BABYLON.GizmoManager;
  }
  declare class BabylonGizmoPlaneDragGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Sets if plane is enabled or not
     * @param inputs plane drag gizmo
     * @returns plane drag gizmo
     * @group set
     * @shortname set is plane enabled
     */
    setIsEnabled(
      inputs: Inputs.BabylonGizmo.SetIsEnabledPlaneDragGizmoDto
    ): BABYLON.IPlaneDragGizmo;
    /**
     * Checks if plane is enabled
     * @param inputs plane drag gizmo
     * @returns is enabled
     * @group get
     * @shortname is plane enabled
     */
    getIsEnabled(inputs: Inputs.BabylonGizmo.PlaneDragGizmoDto): boolean;
  }
  declare class BabylonGizmoPlaneRotationGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Sets if plane is enabled or not
     * @param inputs plane rotation gizmo
     * @returns plane rotation gizmo
     * @group set
     * @shortname set is plane enabled
     */
    setIsEnabled(
      inputs: Inputs.BabylonGizmo.SetIsEnabledPlaneRotationGizmoDto
    ): BABYLON.IPlaneRotationGizmo;
    /**
     * Checks if plane is enabled
     * @param inputs plane rotation gizmo
     * @returns is enabled
     * @group get
     * @shortname is plane enabled
     */
    getIsEnabled(inputs: Inputs.BabylonGizmo.PlaneRotationGizmoDto): boolean;
  }
  declare class BabylonGizmoPositionGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Set planar gizmo enabled
     * @param inputs position gizmo
     * @group set
     * @shortname set planar gizmo enabled
     */
    planarGizmoEnabled(
      inputs: Inputs.BabylonGizmo.SetPlanarGizmoEnabled
    ): BABYLON.IPositionGizmo;
    /**
     * Set position gizmo snap distance
     * @param inputs position gizmo
     * @group set
     * @shortname set snap distance
     */
    snapDistance(
      inputs: Inputs.BabylonGizmo.SetPositionGizmoSnapDistanceDto
    ): BABYLON.IPositionGizmo;
    /**
     * Get attached mesh
     * @param inputs position gizmo
     * @returns attached mesh
     * @group get
     * @shortname get attached mesh
     */
    getAttachedMesh(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.AbstractMesh;
    /**
     * Get attached node
     * @param inputs position gizmo
     * @returns attached node
     * @group get
     * @shortname get attached node
     */
    getAttachedNode(inputs: Inputs.BabylonGizmo.PositionGizmoDto): BABYLON.Node;
    /**
     * Get x gizmo
     * @param inputs position gizmo
     * @returns x drag gizmo
     * @group get
     * @shortname get x gizmo
     */
    getXGizmo(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.IAxisDragGizmo;
    /**
     * Get y gizmo
     * @param inputs position gizmo
     * @returns y drag gizmo
     * @group get
     * @shortname get y gizmo
     */
    getYGizmo(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.IAxisDragGizmo;
    /**
     * Get z gizmo
     * @param inputs position gizmo
     * @returns z drag gizmo
     * @group get
     * @shortname get z gizmo
     */
    getZGizmo(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.IAxisDragGizmo;
    /**
     * Get x plane gizmo
     * @param inputs position gizmo
     * @group get
     * @shortname get x plane gizmo
     */
    getXPlaneGizmo(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.IPlaneDragGizmo;
    /**
     * Get y plane gizmo
     * @param inputs position gizmo
     * @group get
     * @shortname get y plane gizmo
     */
    getYPlaneGizmo(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.IPlaneDragGizmo;
    /**
     * Get z plane gizmo
     * @param inputs position gizmo
     * @group get
     * @shortname get z plane gizmo
     */
    getZPlaneGizmo(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): BABYLON.IPlaneDragGizmo;
    /**
     * Get if planar gizmo enabled
     * @param inputs position gizmo
     * @returns is enabled
     * @group get
     * @shortname get planar gizmo enabled
     */
    getPlanarGizmoEnabled(
      inputs: Inputs.BabylonGizmo.PositionGizmoDto
    ): boolean;
    /**
     * Get snap distance
     * @param inputs position gizmo
     * @returns snap distance
     * @group get
     * @shortname get snap distance
     */
    getSnapDistance(inputs: Inputs.BabylonGizmo.PositionGizmoDto): number;
    /**
     * Get if is dragging
     * @param inputs position gizmo
     * @returns is dragging
     * @group get
     * @shortname get is dragging
     */
    getIsDragging(inputs: Inputs.BabylonGizmo.PositionGizmoDto): boolean;
    /**
     * Creates the selector of an observable for a position gizmo
     * @param inputs observable name
     * @returns position gizmo observable selector
     * @group create
     * @shortname position gizmo observable selector
     */
    createPositionGizmoObservableSelector(
      inputs: Inputs.BabylonGizmo.PositionGizmoObservableSelectorDto
    ): Inputs.BabylonGizmo.positionGizmoObservableSelectorEnum;
  }
  declare class BabylonGizmoRotationGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Set rotation gizmo snap distance
     * @param inputs rotation gizmo
     * @returns rotation gizmo
     * @group set
     * @shortname set snap distance
     */
    snapDistance(
      inputs: Inputs.BabylonGizmo.SetRotationGizmoSnapDistanceDto
    ): BABYLON.IRotationGizmo;
    /**
     * Set rotation gizmo sensitivity
     * @param inputs rotation gizmo
     * @returns rotation gizmo
     * @group set
     * @shortname set sensitivity
     */
    sensitivity(
      inputs: Inputs.BabylonGizmo.SetRotationGizmoSensitivityDto
    ): BABYLON.IRotationGizmo;
    /**
     * Get attached mesh
     * @param inputs rotation gizmo
     * @returns attached mesh
     * @group get
     * @shortname get attached mesh
     */
    getAttachedMesh(
      inputs: Inputs.BabylonGizmo.RotationGizmoDto
    ): BABYLON.Nullable<BABYLON.AbstractMesh>;
    /**
     * Get attached node
     * @param inputs rotation gizmo
     * @returns attached node
     * @group get
     * @shortname get attached node
     */
    getAttachedNode(inputs: Inputs.BabylonGizmo.RotationGizmoDto): BABYLON.Node;
    /**
     * Get x gizmo
     * @param inputs rotation gizmo
     * @returns x drag gizmo
     * @group get
     * @shortname get x gizmo
     */
    getXGizmo(
      inputs: Inputs.BabylonGizmo.RotationGizmoDto
    ): BABYLON.IPlaneRotationGizmo;
    /**
     * Get y gizmo
     * @param inputs rotation gizmo
     * @returns y drag gizmo
     * @group get
     * @shortname get y gizmo
     */
    getYGizmo(
      inputs: Inputs.BabylonGizmo.RotationGizmoDto
    ): BABYLON.IPlaneRotationGizmo;
    /**
     * Get z gizmo
     * @param inputs rotation gizmo
     * @returns z drag gizmo
     * @group get
     * @shortname get z gizmo
     */
    getZGizmo(
      inputs: Inputs.BabylonGizmo.RotationGizmoDto
    ): BABYLON.IPlaneRotationGizmo;
    /**
     * Get snap distance
     * @param inputs rotation gizmo
     * @returns snap distance
     * @group get
     * @shortname get snap distance
     */
    getSnapDistance(inputs: Inputs.BabylonGizmo.RotationGizmoDto): number;
    /**
     * Get sensitivity
     * @param inputs rotation gizmo
     * @returns sensitivity
     * @group get
     * @shortname get sensitivity
     */
    getSensitivity(inputs: Inputs.BabylonGizmo.RotationGizmoDto): number;
    /**
     * Creates the selector of an observable for a rotation gizmo
     * @param inputs observable name
     * @returns rotation gizmo observable selector
     * @group create
     * @shortname rotation gizmo observable selector
     */
    createRotationGizmoObservableSelector(
      inputs: Inputs.BabylonGizmo.RotationGizmoObservableSelectorDto
    ): Inputs.BabylonGizmo.rotationGizmoObservableSelectorEnum;
  }
  declare class BabylonGizmoScaleGizmo {
    private readonly context;
    constructor(context: Context);
    /**
     * Get x gizmo
     * @param inputs scale gizmo
     * @returns x scale gizmo
     * @group get
     * @shortname get x gizmo
     */
    getXGizmo(
      inputs: Inputs.BabylonGizmo.ScaleGizmoDto
    ): BABYLON.IAxisScaleGizmo;
    /**
     * Get y gizmo
     * @param inputs position gizmo
     * @returns y scale gizmo
     * @group get
     * @shortname get y gizmo
     */
    getYGizmo(
      inputs: Inputs.BabylonGizmo.ScaleGizmoDto
    ): BABYLON.IAxisScaleGizmo;
    /**
     * Get z gizmo
     * @param inputs scale gizmo
     * @returns z scale gizmo
     * @group get
     * @shortname get z gizmo
     */
    getZGizmo(
      inputs: Inputs.BabylonGizmo.ScaleGizmoDto
    ): BABYLON.IAxisScaleGizmo;
    /**
     * Set scale gizmo snap distance
     * @param inputs scale gizmo
     * @returns scale gizmo
     * @group set
     * @shortname set snap distance
     */
    snapDistance(
      inputs: Inputs.BabylonGizmo.SetScaleGizmoSnapDistanceDto
    ): BABYLON.IScaleGizmo;
    /**
     * Set scale gizmo incremental snap
     * @param inputs scale gizmo
     * @returns scale gizmo
     * @group set
     * @shortname set incremental snap
     */
    setIncrementalSnap(
      inputs: Inputs.BabylonGizmo.SetScaleGizmoIncrementalSnapDto
    ): BABYLON.IScaleGizmo;
    /**
     * Set scale gizmo sensitivity
     * @param inputs scale gizmo
     * @returns scale gizmo
     * @group set
     * @shortname set sensitivity
     */
    sensitivity(
      inputs: Inputs.BabylonGizmo.SetScaleGizmoSensitivityDto
    ): BABYLON.IScaleGizmo;
    /**
     * Get incremental snap
     * @param inputs scale gizmo
     * @returns incremental snap
     * @group get
     * @shortname get incremental snap
     */
    getIncrementalSnap(inputs: Inputs.BabylonGizmo.ScaleGizmoDto): boolean;
    /**
     * Get snap distance
     * @param inputs scale gizmo
     * @returns snap distance
     * @group get
     * @shortname get snap distance
     */
    getSnapDistance(inputs: Inputs.BabylonGizmo.ScaleGizmoDto): number;
    /**
     * Get sensitivity
     * @param inputs scale gizmo
     * @returns sensitivity
     * @group get
     * @shortname get sensitivity
     */
    getSensitivity(inputs: Inputs.BabylonGizmo.ScaleGizmoDto): number;
    /**
     * Creates the selector of an observable for a scale gizmo
     * @param inputs observable name
     * @returns scale gizmo observable selector
     * @group create
     * @shortname scale gizmo observable selector
     */
    createScaleGizmoObservableSelector(
      inputs: Inputs.BabylonGizmo.ScaleGizmoObservableSelectorDto
    ): Inputs.BabylonGizmo.scaleGizmoObservableSelectorEnum;
  }
  declare class BabylonGuiAdvancedDynamicTexture {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates full screen UI
     * @param inputs with name of advanced texture, foreground, sampling and adaptive scaling
     * @returns advanced dynamic texture
     * @group spaces
     * @shortname create full screen ui
     * @disposableOutput true
     */
    createFullScreenUI(
      inputs: Inputs.BabylonGui.CreateFullScreenUIDto
    ): BABYLON.GUI.AdvancedDynamicTexture;
    /**
     * Creates advanced dynamic texture for a mesh
     * @param inputs with mesh, width, height, support pointer move, only alpha testing, invert y and sampling
     * @returns advanced dynamic texture
     * @group spaces
     * @shortname create for mesh
     * @disposableOutput true
     */
    createForMesh(
      inputs: Inputs.BabylonGui.CreateForMeshDto
    ): BABYLON.GUI.AdvancedDynamicTexture;
  }
  declare class BabylonGuiButton {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates simple button
     * @param inputs button properties
     * @returns button
     * @group create
     * @shortname create simple button
     * @disposableOutput true
     */
    createSimpleButton(
      inputs: Inputs.BabylonGui.CreateButtonDto
    ): BABYLON.GUI.Button;
    /**
     * Set button text
     * @param inputs button and text
     * @returns button with changed text
     * @group set
     * @shortname set button text
     */
    setButtonText(
      inputs: Inputs.BabylonGui.SetButtonTextDto
    ): BABYLON.GUI.Button;
    /**
     * Get button text
     * @param inputs button
     * @returns button text
     * @group get
     * @shortname get button text
     */
    getButtonText(inputs: Inputs.BabylonGui.ButtonDto): string;
  }
  declare class BabylonGuiCheckbox {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates checkbox
     * @param inputs checkbox properties
     * @returns checkbox
     * @group create
     * @shortname create checkbox
     * @disposableOutput true
     */
    createCheckbox(
      inputs: Inputs.BabylonGui.CreateCheckboxDto
    ): BABYLON.GUI.Checkbox;
    /**
     * Sets the checkbox background
     * @param inputs checkbox and background
     * @group set
     * @shortname set checkbox background
     */
    setBackground(
      inputs: Inputs.BabylonGui.SetCheckboxBackgroundDto
    ): BABYLON.GUI.Checkbox;
    /**
     * Sets the checkbox check size ratio
     * @param inputs checkbox and check size ratio
     * @group set
     * @shortname set checkbox check size ratio
     */
    setCheckSizeRatio(
      inputs: Inputs.BabylonGui.SetCheckboxCheckSizeRatioDto
    ): BABYLON.GUI.Checkbox;
    /**
     * Sets the checkbox is checked
     * @param inputs checkbox and is checked
     * @group set
     * @shortname set checkbox is checked
     */
    setIsChecked(
      inputs: Inputs.BabylonGui.SetCheckboxIsCheckedDto
    ): BABYLON.GUI.Checkbox;
    /**
     * Gets the check size ratio
     * @param inputs checkbox
     * @group get
     * @shortname get check size ratio
     */
    getCheckSizeRatio(inputs: Inputs.BabylonGui.CheckboxDto): number;
    /**
     * Gets the is checked
     * @param inputs checkbox
     * @group get
     * @shortname get is checked
     */
    getIsChecked(inputs: Inputs.BabylonGui.CheckboxDto): boolean;
    /**
     * Gets the background
     * @param inputs checkbox
     * @group get
     * @shortname get checkbox background
     */
    getBackground(inputs: Inputs.BabylonGui.CheckboxDto): string;
    /**
     * Creates the selector of an observable for the checkbox
     * @param inputs observable name
     * @group create
     * @shortname checkbox observable selector
     */
    createCheckboxObservableSelector(
      inputs: Inputs.BabylonGui.CheckboxObservableSelectorDto
    ): Inputs.BabylonGui.checkboxObservableSelectorEnum;
  }
  declare class BabylonGuiColorPicker {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates color picker
     * @param inputs color picker properties
     * @returns color picker
     * @group create
     * @shortname color picker
     * @disposableOutput true
     */
    createColorPicker(
      inputs: Inputs.BabylonGui.CreateColorPickerDto
    ): BABYLON.GUI.ColorPicker;
    /**
     * Sets color picker value color
     * @param inputs color picker and color
     * @returns color picker
     * @group set
     * @shortname set colo picker value
     */
    setColorPickerValue(
      inputs: Inputs.BabylonGui.SetColorPickerValueDto
    ): BABYLON.GUI.ColorPicker;
    /**
     * Sets color picker size (width and height)
     * @param inputs color picker and size
     * @returns color picker
     * @group set
     * @shortname set color picker size
     */
    setColorPickerSize(
      inputs: Inputs.BabylonGui.SetColorPickerSizeDto
    ): BABYLON.GUI.ColorPicker;
    /**
     * Gets color picker value color
     * @param inputs color picker
     * @returns color
     * @group get
     * @shortname get color picker value
     */
    getColorPickerValue(inputs: Inputs.BabylonGui.ColorPickerDto): string;
    /**
     * Gets color picker size
     * @param inputs color picker
     * @returns size
     * @group get
     * @shortname get color picker size
     */
    getColorPickerSize(
      inputs: Inputs.BabylonGui.ColorPickerDto
    ): string | number;
    /**
     * Creates the selector of an observable for color picker
     * @param inputs observable name
     * @returns color picker observable selector
     * @group create
     * @shortname color picker observable selector
     */
    createColorPickerObservableSelector(
      inputs: Inputs.BabylonGui.ColorPickerObservableSelectorDto
    ): Inputs.BabylonGui.colorPickerObservableSelectorEnum;
  }
  declare class BabylonGuiContainer {
    private readonly context;
    constructor(context: Context);
    /**
     * Adds controls to container and keeps the order
     * @param inputs with container and controls
     * @returns container
     * @group controls
     * @shortname add controls to container
     */
    addControls(
      inputs: Inputs.BabylonGui.AddControlsToContainerDto
    ): BABYLON.GUI.Container;
    /**
     * Sets the container background
     * @param inputs container and background
     * @group set
     * @shortname set container background
     */
    setBackground(
      inputs: Inputs.BabylonGui.SetContainerBackgroundDto
    ): BABYLON.GUI.Container;
    /**
     * Sets the container is readonly
     * @param inputs container and is readonly
     * @group set
     * @shortname set container is readonly
     */
    setIsReadonly(
      inputs: Inputs.BabylonGui.SetContainerIsReadonlyDto
    ): BABYLON.GUI.Container;
    /**
     * Gets the container background
     * @param inputs container
     * @group get
     * @shortname get container background
     */
    getBackground(inputs: Inputs.BabylonGui.ContainerDto): string;
    /**
     * Gets the container is readonly
     * @param inputs container
     * @group get
     * @shortname get container is readonly
     */
    getIsReadonly(inputs: Inputs.BabylonGui.ContainerDto): boolean;
  }
  declare class BabylonGuiControl {
    private readonly context;
    constructor(context: Context);
    /**
     * Change the padding for the control
     * @param inputs the control and the padding values
     * @returns control that has changed padding
     * @group positioning
     * @shortname change padding
     */
    changeControlPadding(
      inputs: Inputs.BabylonGui.PaddingLeftRightTopBottomDto
    ): BABYLON.GUI.Control;
    /**
     * Change the alignment for the control
     * @param inputs the control and the alignment values
     * @returns control that has changed alignment
     * @group positioning
     * @shortname change alignment
     */
    changeControlAlignment(
      inputs: Inputs.BabylonGui.AlignmentDto<BABYLON.GUI.Control>
    ): BABYLON.GUI.Control;
    /**
     * Clone control
     * @param inputs control to clone
     * @returns cloned control
     * @group create
     * @shortname clone control
     * @disposableOutput true
     */
    cloneControl(
      inputs: Inputs.BabylonGui.CloneControlDto
    ): BABYLON.GUI.Control;
    /**
     * Creates the selector of an observable for a control
     * @param inputs observable name
     * @group create
     * @shortname control observable selector
     */
    createControlObservableSelector(
      inputs: Inputs.BabylonGui.ControlObservableSelectorDto
    ): Inputs.BabylonGui.controlObservableSelectorEnum;
    /**
     * Get control by name
     * @param inputs container and control name
     * @returns control with the name
     * @group get
     * @shortname get control by name
     */
    getControlByName(
      inputs: Inputs.BabylonGui.GetControlByNameDto
    ): BABYLON.GUI.Control;
    /**
     * Set if control is visible
     * @param inputs control and is visible
     * @returns control with changed visibility
     * @group set
     * @shortname set control is visible
     */
    setIsVisible(
      inputs: Inputs.BabylonGui.SetControlIsVisibleDto
    ): BABYLON.GUI.Control;
    /**
     * Set if control is readonly
     * @param inputs control and is readonly
     * @returns control with changed readonly
     * @group set
     * @shortname set control is readonly
     */
    setIsReadonly(
      inputs: Inputs.BabylonGui.SetControlIsReadonlyDto
    ): BABYLON.GUI.Control;
    /**
     * Set if control is enabled
     * @param inputs control and is enabled
     * @returns control with changed enabled
     * @group set
     * @shortname set control is enabled
     */
    setIsEnabled(
      inputs: Inputs.BabylonGui.SetControlIsEnabledDto
    ): BABYLON.GUI.Control;
    /**
     * Sets the control height
     * @param inputs control and height
     * @group set
     * @shortname set control height
     */
    setHeight(
      inputs: Inputs.BabylonGui.SetControlHeightDto
    ): BABYLON.GUI.Control;
    /**
     * Sets the control width
     * @param inputs control and width
     * @group set
     * @shortname set control width
     */
    setWidth(inputs: Inputs.BabylonGui.SetControlWidthDto): BABYLON.GUI.Control;
    /**
     * Sets the control color
     * @param inputs control and color
     * @group set
     * @shortname set control color
     */
    setColor(inputs: Inputs.BabylonGui.SetControlColorDto): BABYLON.GUI.Control;
    /**
     * Set font size
     * @param inputs control and font size
     * @returns control with changed font size
     * @group set
     * @shortname set control font size
     */
    setFontSize(
      inputs: Inputs.BabylonGui.SetControlFontSizeDto
    ): BABYLON.GUI.Control;
    /**
     * Gets the height
     * @param inputs control
     * @group get
     * @shortname get control height
     */
    getHeight(inputs: Inputs.BabylonGui.ControlDto): string | number;
    /**
     * Gets the width
     * @param inputs control
     * @group get
     * @shortname get control width
     */
    getWidth(inputs: Inputs.BabylonGui.ControlDto): string | number;
    /**
     * Gets the color
     * @param inputs control
     * @group get
     * @shortname get control color
     */
    getColor(inputs: Inputs.BabylonGui.ControlDto): string;
    /**
     * Get control font size
     * @param inputs control
     * @returns control font size. Can be in the form of a string "24px" or a number
     * @group get
     * @shortname get control font size
     */
    getFontSize(inputs: Inputs.BabylonGui.ControlDto): string | number;
    /**
     * Get control is visible
     * @param inputs control
     * @returns control visibility
     * @group get
     * @shortname get control is visible
     */
    getIsVisible(inputs: Inputs.BabylonGui.ControlDto): boolean;
    /**
     * Get control is readonly
     * @param inputs control
     * @returns control readonly
     * @group get
     * @shortname get control is readonly
     */
    getIsReadonly(inputs: Inputs.BabylonGui.ControlDto): boolean;
    /**
     * Get control is enabled
     * @param inputs control
     * @returns control enabled
     * @group get
     * @shortname get control is enabled
     */
    getIsEnabled(inputs: Inputs.BabylonGui.ControlDto): boolean;
  }
  declare class BabylonGui {
    private readonly context;
    advancedDynamicTexture: BabylonGuiAdvancedDynamicTexture;
    control: BabylonGuiControl;
    container: BabylonGuiContainer;
    stackPanel: BabylonGuiStackPanel;
    button: BabylonGuiButton;
    slider: BabylonGuiSlider;
    textBlock: BabylonGuiTextBlock;
    radioButton: BabylonGuiRadioButton;
    checkbox: BabylonGuiCheckbox;
    inputText: BabylonGuiInputText;
    colorPicker: BabylonGuiColorPicker;
    image: BabylonGuiImage;
    constructor(context: Context);
  }
  declare class BabylonGuiImage {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates image
     * @param inputs image properties
     * @returns image
     * @group create
     * @shortname create image
     * @disposableOutput true
     */
    createImage(inputs: Inputs.BabylonGui.CreateImageDto): BABYLON.GUI.Image;
    /**
     * Sets image source url
     * @param inputs image and url
     * @returns image
     * @group set
     * @shortname set image source url
     */
    setSourceUrl(inputs: Inputs.BabylonGui.SetImageUrlDto): BABYLON.GUI.Image;
    /**
     * Gets image source url
     * @param inputs image
     * @returns image source url
     * @group get
     * @shortname get image source url
     */
    getSourceUrl(inputs: Inputs.BabylonGui.ImageDto): string;
  }
  declare class BabylonGuiInputText {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates input text
     * @param inputs input text properties
     * @returns input text
     * @group create
     * @shortname create input text
     * @disposableOutput true
     */
    createInputText(
      inputs: Inputs.BabylonGui.CreateInputTextDto
    ): BABYLON.GUI.InputText;
    /**
     * Sets the input text background
     * @param inputs input text and background
     * @returns input text
     * @group set
     * @shortname set input text background
     */
    setBackground(
      inputs: Inputs.BabylonGui.SetInputTextBackgroundDto
    ): BABYLON.GUI.InputText;
    /**
     * Sets the input text text
     * @param inputs input text and text
     * @returns input text
     * @group set
     * @shortname set input text text
     */
    setText(
      inputs: Inputs.BabylonGui.SetInputTextTextDto
    ): BABYLON.GUI.InputText;
    /**
     * Sets the input text placeholder
     * @param inputs input text and placeholder
     * @returns input text
     * @group set
     * @shortname set input text placeholder
     */
    setPlaceholder(
      inputs: Inputs.BabylonGui.SetInputTextPlaceholderDto
    ): BABYLON.GUI.InputText;
    /**
     * Gets the input text background
     * @param inputs input text
     * @returns input text background
     * @group get
     * @shortname get input text background
     */
    getBackground(inputs: Inputs.BabylonGui.InputTextDto): string;
    /**
     * Gets the input text text
     * @param inputs input text
     * @returns input text text
     * @group get
     * @shortname get input text text
     */
    getText(inputs: Inputs.BabylonGui.InputTextDto): string;
    /**
     * Gets the input text placeholder
     * @param inputs input text
     * @returns input text placeholder
     * @group get
     * @shortname get input text placeholder
     */
    getPlaceholder(inputs: Inputs.BabylonGui.InputTextDto): string;
    /**
     * Creates the selector of an observable for the input text
     * @param inputs observable name
     * @group create
     * @shortname input text observable selector
     */
    createInputTextObservableSelector(
      inputs: Inputs.BabylonGui.InputTextObservableSelectorDto
    ): Inputs.BabylonGui.inputTextObservableSelectorEnum;
  }
  declare class BabylonGuiRadioButton {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates radio button
     * @param inputs radio button properties
     * @returns radio button
     * @group create
     * @shortname create radio button
     * @disposableOutput true
     */
    createRadioButton(
      inputs: Inputs.BabylonGui.CreateRadioButtonDto
    ): BABYLON.GUI.RadioButton;
    /**
     * Sets the radio button check size ratio
     * @param inputs radio button and check size ratio
     * @group set
     * @shortname set radio button check size ratio
     */
    setCheckSizeRatio(
      inputs: Inputs.BabylonGui.SetRadioButtonCheckSizeRatioDto
    ): BABYLON.GUI.RadioButton;
    /**
     * Sets the radio button group
     * @param inputs radio button and group
     * @group set
     * @shortname set radio button group
     */
    setGroup(
      inputs: Inputs.BabylonGui.SetRadioButtonGroupDto
    ): BABYLON.GUI.RadioButton;
    /**
     * Sets the radio button background
     * @param inputs radio button and background
     * @group set
     * @shortname set radio button background
     */
    setBackground(
      inputs: Inputs.BabylonGui.SetRadioButtonBackgroundDto
    ): BABYLON.GUI.RadioButton;
    /**
     * Gets the radio button check size ratio
     * @param inputs radio button
     * @group get
     * @shortname get radio button check size ratio
     */
    getCheckSizeRatio(inputs: Inputs.BabylonGui.RadioButtonDto): number;
    /**
     * Gets the radio button group
     * @param inputs radio button
     * @group get
     * @shortname get radio button group
     */
    getGroup(inputs: Inputs.BabylonGui.RadioButtonDto): string;
    /**
     * Gets the radio button background
     * @param inputs radio button
     * @group get
     * @shortname get radio button background
     */
    getBackground(inputs: Inputs.BabylonGui.RadioButtonDto): string;
    /**
     * Creates the selector of an observable for the radio button
     * @param inputs observable name
     * @group create
     * @shortname radio button observable selector
     */
    createRadioButtonObservableSelector(
      inputs: Inputs.BabylonGui.RadioButtonObservableSelectorDto
    ): Inputs.BabylonGui.radioButtonObservableSelectorEnum;
  }
  declare class BabylonGuiSlider {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates slider
     * @param inputs slider properties
     * @returns slider
     * @group create
     * @shortname create slider
     * @disposableOutput true
     */
    createSlider(inputs: Inputs.BabylonGui.CreateSliderDto): BABYLON.GUI.Slider;
    /**
     * Changes slider thumb properties
     * @param inputs slider properties*
     * @returns slider
     * @group set
     * @shortname set slider thumb
     */
    changeSliderThumb(
      inputs: Inputs.BabylonGui.SliderThumbDto
    ): BABYLON.GUI.Slider;
    /**
     * Changes slider border color
     * @param inputs slider border color
     * @returns slider
     * @group set
     * @shortname set slider border color
     */
    setBorderColor(
      inputs: Inputs.BabylonGui.SliderBorderColorDto
    ): BABYLON.GUI.Slider;
    /**
     * Changes slider background color
     * @param inputs slider background color
     * @returns slider
     * @group set
     * @shortname set slider background color
     */
    setBackgroundColor(
      inputs: Inputs.BabylonGui.SliderBackgroundColorDto
    ): BABYLON.GUI.Slider;
    /**
     * Changes slider maximum value
     * @param inputs slider maximum value
     * @returns slider
     * @group set
     * @shortname set slider maximum
     */
    setMaximum(inputs: Inputs.BabylonGui.SetSliderValueDto): BABYLON.GUI.Slider;
    /**
     * Changes slider minimum value
     * @param inputs slider minimum value
     * @returns slider
     * @group set
     * @shortname set slider minimum
     */
    setMinimum(inputs: Inputs.BabylonGui.SetSliderValueDto): BABYLON.GUI.Slider;
    /**
     * Changes slider step value
     * @param inputs slider step value
     * @returns slider
     * @group set
     * @shortname set slider step
     */
    setStep(inputs: Inputs.BabylonGui.SetSliderValueDto): BABYLON.GUI.Slider;
    /**
     * Changes slider value
     * @param inputs slider value
     * @returns slider
     * @group set
     * @shortname set slider value
     */
    setValue(inputs: Inputs.BabylonGui.SetSliderValueDto): BABYLON.GUI.Slider;
    /**
     * Creates the selector of an observable for a slider
     * @param inputs observable name
     * @returns slider observable selector
     * @group create
     * @shortname slider observable selector
     */
    createSliderObservableSelector(
      inputs: Inputs.BabylonGui.SliderObservableSelectorDto
    ): Inputs.BabylonGui.sliderObservableSelectorEnum;
    /**
     * Gets the slider border color
     * @param slider slider
     * @returns slider border color
     * @group get
     * @shortname get slider border color
     */
    getBorderColor(inputs: Inputs.BabylonGui.SliderDto): string;
    /**
     * Gets the slider background color
     * @param slider slider
     * @returns slider background color
     * @group get
     * @shortname get slider background color
     */
    getBackgroundColor(inputs: Inputs.BabylonGui.SliderDto): string;
    /**
     * Gets the slider maximum value
     * @param slider slider
     * @returns slider maximum value
     * @group get
     * @shortname get slider maximum
     */
    getMaximum(inputs: Inputs.BabylonGui.SliderDto): number;
    /**
     * Gets the slider minimum value
     * @param slider slider
     * @returns slider minimum value
     * @group get
     * @shortname get slider minimum
     */
    getMinimum(inputs: Inputs.BabylonGui.SliderDto): number;
    /**
     * Gets the slider step value
     * @param slider slider
     * @returns slider step value
     * @group get
     * @shortname get slider step
     */
    getStep(inputs: Inputs.BabylonGui.SliderDto): number;
    /**
     * Gets the slider value
     * @param slider slider
     * @returns slider value
     * @group get
     * @shortname get slider value
     */
    getValue(inputs: Inputs.BabylonGui.SliderDto): number;
    /**
     * Gets the slider thumb color
     * @param slider slider
     * @returns slider thumb color
     * @group get
     * @shortname get slider thumb color
     */
    getThumbColor(inputs: Inputs.BabylonGui.SliderDto): string;
    /**
     * Gets the slider thumb width
     * @param slider slider
     * @returns slider thumb width
     * @group get
     * @shortname get slider thumb width
     */
    getThumbWidth(inputs: Inputs.BabylonGui.SliderDto): string | number;
    /**
     * Gets the slider is vertical
     * @param slider slider
     * @returns slider is vertical
     * @group get
     * @shortname get slider is vertical
     */
    getIsVertical(inputs: Inputs.BabylonGui.SliderDto): boolean;
    /**
     * Gets the slider display thumb
     * @param slider slider
     * @returns slider display thumb
     * @group get
     * @shortname get slider display thumb
     */
    getDisplayThumb(inputs: Inputs.BabylonGui.SliderDto): boolean;
    /**
     * Gets the slider is thumb circle
     * @param slider slider
     * @returns slider is thumb circle
     * @group get
     * @shortname get slider is thumb circle
     */
    getIsThumbCircle(inputs: Inputs.BabylonGui.SliderDto): boolean;
    /**
     * Gets the slider is thumb clamped
     * @param slider slider
     * @returns slider is thumb clamped
     * @group get
     * @shortname get slider is thumb clamped
     */
    getIsThumbClamped(inputs: Inputs.BabylonGui.SliderDto): boolean;
  }
  declare class BabylonGuiStackPanel {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates stack panel
     * @param inputs stack panel props
     * @group create
     * @shortname create stack panel
     * @disposableOutput true
     */
    createStackPanel(
      inputs: Inputs.BabylonGui.CreateStackPanelDto
    ): BABYLON.GUI.StackPanel;
    /**
     * Set stack panel is vertical
     * @param inputs with stack panel and is vertical
     * @returns stack panel with changed is vertical
     * @group set
     * @shortname set stack panel is vertical
     */
    setIsVertical(
      inputs: Inputs.BabylonGui.SetStackPanelIsVerticalDto
    ): BABYLON.GUI.StackPanel;
    /**
     * Set stack panel spacing
     * @param inputs with stack panel and spacing
     * @returns stack panel with changed spacing
     * @group set
     * @shortname set stack panel spacing
     */
    setSpacing(
      inputs: Inputs.BabylonGui.SetStackPanelSpacingDto
    ): BABYLON.GUI.StackPanel;
    /**
     * Set stack panel width
     * @param inputs with stack panel and width
     * @returns stack panel with changed width
     * @group set
     * @shortname set stack panel width
     */
    setWidth(
      inputs: Inputs.BabylonGui.SetStackPanelWidthDto
    ): BABYLON.GUI.StackPanel;
    /**
     * Set stack panel height
     * @param inputs with stack panel and height
     * @returns stack panel with changed height
     * @group set
     * @shortname set stack panel height
     */
    setHeight(
      inputs: Inputs.BabylonGui.SetStackPanelHeightDto
    ): BABYLON.GUI.StackPanel;
    /**
     * Get stack panel is vertical
     * @param inputs with stack panel
     * @returns stack panel is vertical
     * @group get
     * @shortname get stack panel is vertical
     */
    getIsVertical(inputs: Inputs.BabylonGui.StackPanelDto): boolean;
    /**
     * Get stack panel spacing
     * @param inputs with stack panel
     * @returns stack panel spacing
     * @group get
     * @shortname get stack panel spacing
     */
    getSpacing(inputs: Inputs.BabylonGui.StackPanelDto): number;
    /**
     * Get stack panel width
     * @param inputs with stack panel
     * @returns stack panel width
     * @group get
     * @shortname get stack panel width
     */
    getWidth(inputs: Inputs.BabylonGui.StackPanelDto): string | number;
    /**
     * Get stack panel height
     * @param inputs with stack panel
     * @returns stack panel height
     * @group get
     * @shortname get stack panel height
     */
    getHeight(inputs: Inputs.BabylonGui.StackPanelDto): string | number;
  }
  declare class BabylonGuiTextBlock {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates text block
     * @param inputs text block properties
     * @group create
     * @shortname create text block
     * @disposableOutput true
     */
    createTextBlock(
      inputs: Inputs.BabylonGui.CreateTextBlockDto
    ): BABYLON.GUI.TextBlock;
    /**
     * Change the alignment for the text
     * @param inputs the text block and the alignment values
     * @returns control that has changed text alignment
     * @group positioning
     * @shortname align text block text
     */
    alignText(
      inputs: Inputs.BabylonGui.AlignmentDto<BABYLON.GUI.TextBlock>
    ): BABYLON.GUI.TextBlock;
    /**
     * Change the text outline for the text
     * @param inputs the text block and the outline values
     * @returns control that has changed text outline
     * @group set
     * @shortname text outline
     */
    setTextOutline(
      inputs: Inputs.BabylonGui.SetTextBlockTextOutlineDto
    ): BABYLON.GUI.TextBlock;
    /**
     * Sets the new text to the text block
     * @param inputs text block and text
     * @returns control that has changed text
     * @group set
     * @shortname set text block text
     */
    setText(
      inputs: Inputs.BabylonGui.SetTextBlockTextDto
    ): BABYLON.GUI.TextBlock;
    /**
     * Enable or disable resize to fit
     * @param inputs text block and boolean value
     * @returns control that has enabled or disabled resize to fit
     * @group set
     * @shortname set resize to fit
     */
    setRsizeToFit(
      inputs: Inputs.BabylonGui.SetTextBlockResizeToFitDto
    ): BABYLON.GUI.TextBlock;
    /**
     * Sets the new text wrapping to the text block
     * @param inputs text block and text wrapping
     * @returns control that has changed text wrapping
     * @group set
     * @shortname set text wrapping
     */
    setTextWrapping(
      inputs: Inputs.BabylonGui.SetTextBlockTextWrappingDto
    ): BABYLON.GUI.TextBlock;
    /**
     * Sets the line spacing of the text
     * @param inputs text block and line spacing
     * @returns control that has changed line spacing
     * @group set
     * @shortname set line spacing
     */
    setLineSpacing(
      inputs: Inputs.BabylonGui.SetTextBlockLineSpacingDto
    ): BABYLON.GUI.TextBlock;
    /**
     * Gets the text of the text block
     * @param inputs text block
     * @returns text of the text block
     * @group get
     * @shortname get text block text
     */
    getText(inputs: Inputs.BabylonGui.TextBlockDto): string;
    /**
     * Gets the text wrapping of the text block
     * @param inputs text block
     * @returns text wrapping of the text block
     * @group get
     * @shortname get text wrapping
     */
    getTextWrapping(
      inputs: Inputs.BabylonGui.TextBlockDto
    ): boolean | BABYLON.GUI.TextWrapping;
    /**
     * Gets the line spacing of the text block
     * @param inputs text block
     * @returns line spacing of the text block
     * @group get
     * @shortname get line spacing
     */
    getLineSpacing(inputs: Inputs.BabylonGui.TextBlockDto): string | number;
    /**
     * Gets the outline width of the text block
     * @param inputs text block
     * @returns outline width of the text block
     * @group get
     * @shortname get outline width
     */
    getOutlineWidth(inputs: Inputs.BabylonGui.TextBlockDto): number;
    /**
     * Gets the resize to fit of the text block
     * @param inputs text block
     * @returns resize to fit of the text block
     * @group get
     * @shortname get resize to fit
     */
    getResizeToFit(inputs: Inputs.BabylonGui.TextBlockDto): boolean;
    /**
     * Gets the text horizontal alignment of the text block
     * @param inputs text block
     * @returns text horizontal alignment of the text block
     * @group get
     * @shortname get text horizontal alignment
     */
    getTextHorizontalAlignment(inputs: Inputs.BabylonGui.TextBlockDto): number;
    /**
     * Gets the text vertical alignment of the text block
     * @param inputs text block
     * @returns text vertical alignment of the text block
     * @group get
     * @shortname get text vertical alignment
     */
    getTextVerticalAlignment(inputs: Inputs.BabylonGui.TextBlockDto): number;
    /**
     * Creates the selector of an observable for a text block
     * @param inputs observable name
     * @group create
     * @shortname text block observable selector
     */
    createTextBlockObservableSelector(
      inputs: Inputs.BabylonGui.TextBlockObservableSelectorDto
    ): Inputs.BabylonGui.textBlockObservableSelectorEnum;
  }
  declare class BabylonIO {
    private readonly context;
    private supportedFileFormats;
    private objectUrl;
    constructor(context: Context);
    /**
     * Imports mesh from the asset that you have uploaded for the project.
     * You must upload your assets to your project via project management page.
     * @returns scene loaded mesh
     * @group load
     * @shortname asset
     */
    loadAssetIntoScene(
      inputs: Inputs.Asset.AssetFileDto
    ): Promise<BABYLON.Mesh>;
    /**
     * Imports mesh from the asset that you have uploaded for the project.
     * You must upload your assets to your project via project management page.
     * @returns scene loaded mesh
     * @group load
     * @shortname asset
     */
    loadAssetIntoSceneNoReturn(
      inputs: Inputs.Asset.AssetFileDto
    ): Promise<void>;
    /**
     * Imports mesh from the asset url that you have uploaded to an accessible web storage.
     * Keep in mind that files need to be publically accessible for this to work, be sure that CORS access is enabled for the assets.
     * @returns scene loaded mesh
     * @group load
     * @shortname asset from url
     */
    loadAssetIntoSceneFromRootUrl(
      inputs: Inputs.Asset.AssetFileByUrlDto
    ): Promise<BABYLON.Mesh>;
    /**
     * Imports mesh from the asset url that you have uploaded to an accessible web storage.
     * Keep in mind that files need to be publically accessible for this to work, be sure that CORS access is enabled for the assets.
     * @returns scene loaded mesh
     * @group load
     * @shortname asset from url
     */
    loadAssetIntoSceneFromRootUrlNoReturn(
      inputs: Inputs.Asset.AssetFileByUrlDto
    ): Promise<void>;
    /**
     * Exports the whole scene to .babylon scene format. You can then edit it further in babylonjs editors.
     * @param inputs filename
     * @group export
     * @shortname babylon scene
     */
    exportBabylon(inputs: Inputs.BabylonIO.ExportSceneDto): void;
    /**
     * Exports the whole scene to .glb format. This file format has become industry standard for web models.
     * @param inputs filename
     * @group export
     * @shortname gltf scene
     */
    exportGLB(inputs: Inputs.BabylonIO.ExportSceneGlbDto): void;
    /**
     * Exports the mesh with its children to stl
     * @param inputs filename and the mesh
     * @group export
     * @shortname babylon mesh to stl
     */
    exportMeshToStl(inputs: Inputs.BabylonIO.ExportMeshToStlDto): Promise<any>;
    /**
     * Exports the meshes to stl
     * @param inputs filename and the mesh
     * @group export
     * @shortname babylon meshes to stl
     */
    exportMeshesToStl(
      inputs: Inputs.BabylonIO.ExportMeshesToStlDto
    ): Promise<any>;
    private loadAsset;
  }
  declare class BabylonLights {
    private readonly context;
    shadowLight: BabylonShadowLight;
    constructor(context: Context);
  }
  declare class BabylonShadowLight {
    private readonly context;
    constructor(context: Context);
    /**
     * Sets the direction of the shadow light
     * @param inputs shadow light and direction
     * @group set
     * @shortname set target
     */
    setDirectionToTarget(
      inputs: Inputs.BabylonLight.ShadowLightDirectionToTargetDto
    ): void;
    /**
     * Sets the position of the shadow light
     * @param inputs shadow light and position
     * @group set
     * @shortname set position
     */
    setPosition(inputs: Inputs.BabylonLight.ShadowLightPositionDto): void;
  }
  declare class BabylonMaterial {
    private readonly context;
    private readonly color;
    pbrMetallicRoughness: BabylonMaterialPbrMetallicRoughness;
    skyMaterial: BabylonMaterialSky;
    constructor(context: Context, color: Color);
  }
  declare class BabylonMaterialPbrMetallicRoughness {
    private readonly context;
    private readonly color;
    constructor(context: Context, color: Color);
    /**
     * Create PBR metallic roughnes material.
     * @param inputs required to set up metallic roughness material
     * @returns PBR metallic roughness material
     * @group create
     * @shortname pbr material
     * @disposableOutput true
     */
    create(
      inputs: Inputs.BabylonMaterial.PBRMetallicRoughnessDto
    ): BABYLON.PBRMetallicRoughnessMaterial;
    /**
     * Sets the base color of material
     * @param inputs base color and material
     * @group set
     * @shortname set base color
     */
    setBaseColor(inputs: Inputs.BabylonMaterial.BaseColorDto): void;
    /**
     * Sets the metallic property of material
     * @param inputs metallic value
     * @group set
     * @shortname set metallic
     */
    setMetallic(inputs: Inputs.BabylonMaterial.MetallicDto): void;
    /**
     * Sets the roughness of material
     * @param inputs roughness value
     * @group set
     * @shortname set roughness
     */
    setRoughness(inputs: Inputs.BabylonMaterial.RoughnessDto): void;
    /**
     * Sets the alpha of material
     * @param inputs alpha value
     * @group set
     * @shortname set alpha
     */
    setAlpha(inputs: Inputs.BabylonMaterial.AlphaDto): void;
    /**
     * Sets the back face culling of material
     * @param inputs back face culling boolean
     * @group set
     * @shortname set back face culling
     */
    setBackFaceCulling(inputs: Inputs.BabylonMaterial.BackFaceCullingDto): void;
    /**
     * Sets the texture of material
     * @param inputs texture and material
     * @group set
     * @shortname set base texture
     */
    setBaseTexture(inputs: Inputs.BabylonMaterial.BaseTextureDto): void;
    /**
     * Gets the base color of material
     * @param inputs material
     * @return base color
     * @group get
     * @shortname get base color
     */
    getBaseColor(inputs: Inputs.BabylonMaterial.MaterialPropDto): string;
    /**
     * Gets the metallic property of material
     * @param inputs material
     * @return metallic value
     * @group get
     * @shortname get metallic
     */
    getMetallic(inputs: Inputs.BabylonMaterial.MaterialPropDto): number;
    /**
     * Gets the roughness of material
     * @param inputs material
     * @return roughness value
     * @group get
     * @shortname get roughness
     */
    getRoughness(inputs: Inputs.BabylonMaterial.MaterialPropDto): number;
    /**
     * Gets the alpha of material
     * @param inputs material
     * @return alpha value
     * @group get
     * @shortname get alpha
     */
    getAlpha(inputs: Inputs.BabylonMaterial.MaterialPropDto): number;
    /**
     * Gets the back face culling of material
     * @param inputs material
     * @return backfaceculling boolean
     * @group get
     * @shortname get back face culling
     */
    getBackFaceCulling(inputs: Inputs.BabylonMaterial.MaterialPropDto): boolean;
    /**
     * Get the base texture of material
     * @param inputs material
     * @group get
     * @shortname get base texture
     */
    getBaseTexture(
      inputs: Inputs.BabylonMaterial.MaterialPropDto
    ): BABYLON.BaseTexture;
  }
  declare class BabylonMaterialSky {
    private readonly context;
    constructor(context: Context);
    /**
     * Create Sky Material
     * @param inputs required to set up the sky material
     * @returns Sky material
     * @group create
     * @shortname sky material
     */
    create(inputs: Inputs.BabylonMaterial.SkyMaterialDto): SkyMaterial;
    /**
     * Sets the luminance of the sky material
     * @param inputs luminance value and material
     * @group set
     * @shortname set luminance
     */
    setLuminance(inputs: Inputs.BabylonMaterial.LuminanceDto): void;
    /**
     * Sets the turbidity of the sky material
     * @param inputs turbidity value and material
     * @group set
     * @shortname set turbidity
     */
    setTurbidity(inputs: Inputs.BabylonMaterial.TurbidityDto): void;
    /**
     * Sets the rayleigh of the sky material
     * @param inputs rayleigh value and material
     * @group set
     * @shortname set rayleigh
     */
    setRayleigh(inputs: Inputs.BabylonMaterial.RayleighDto): void;
    /**
     * Sets the mieCoefficient of the sky material
     * @param inputs mieCoefficient value and material
     * @group set
     * @shortname set mieCoefficient
     */
    setMieCoefficient(inputs: Inputs.BabylonMaterial.MieCoefficientDto): void;
    /**
     * Sets the mieDirectionalG of the sky material
     * @param inputs mieDirectionalG value and material
     * @group set
     * @shortname set mieDirectionalG
     */
    setMieDirectionalG(inputs: Inputs.BabylonMaterial.MieDirectionalGDto): void;
    /**
     * Sets the distance of the sky material
     * @param inputs distance value and material
     * @group set
     * @shortname set distance
     */
    setDistance(inputs: Inputs.BabylonMaterial.DistanceDto): void;
    /**
     * Sets the inclination of the sky material
     * @param inputs inclination value and material
     * @group set
     * @shortname set inclination
     */
    setInclination(inputs: Inputs.BabylonMaterial.InclinationDto): void;
    /**
     * Sets the azimuth of the sky material
     * @param inputs azimuth value and material
     * @group set
     * @shortname set azimuth
     */
    setAzimuth(inputs: Inputs.BabylonMaterial.AzimuthDto): void;
    /**
     * Sets the sun position of the sky material
     * @param inputs sun position value and material
     * @group set
     * @shortname set sun position
     */
    setSunPosition(inputs: Inputs.BabylonMaterial.SunPositionDto): void;
    /**
     * Sets the use sun position of the sky material
     * @param inputs use sun position value and material
     * @group set
     * @shortname set use sun position
     */
    setUseSunPosition(inputs: Inputs.BabylonMaterial.UseSunPositionDto): void;
    /**
     * Sets the camera offset of the sky material
     * @param inputs camera offset value and material
     * @group set
     * @shortname set camera offset
     */
    setCameraOffset(inputs: Inputs.BabylonMaterial.CameraOffsetDto): void;
    /**
     * Sets the up of the sky material
     * @param inputs up value and material
     * @group set
     * @shortname set up
     */
    setUp(inputs: Inputs.BabylonMaterial.UpDto): void;
    /**
     * Sets the dithering of the sky material
     * @param inputs dithering value and material
     * @group set
     * @shortname set dithering
     */
    setDithering(inputs: Inputs.BabylonMaterial.DitheringDto): void;
    /**
     * Gets the luminance of the sky material
     * @param inputs material
     * @group get
     * @shortname get luminance
     */
    getLuminance(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): number;
    /**
     * Gets the turbidity of the sky material
     * @param inputs material
     * @group get
     * @shortname get turbidity
     */
    getTurbidity(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): number;
    /**
     * Gets the rayleigh of the sky material
     * @param inputs material
     * @group get
     * @shortname get rayleigh
     */
    getRayleigh(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): number;
    /**
     * Gets the mieCoefficient of the sky material
     * @param inputs material
     * @group get
     * @shortname get mieCoefficient
     */
    getMieCoefficient(
      inputs: Inputs.BabylonMaterial.SkyMaterialPropDto
    ): number;
    /**
     * Gets the mieDirectionalG of the sky material
     * @param inputs material
     * @group get
     * @shortname get mieDirectionalG
     */
    getMieDirectionalG(
      inputs: Inputs.BabylonMaterial.SkyMaterialPropDto
    ): number;
    /**
     * Gets the distance of the sky material
     * @param inputs material
     * @group get
     * @shortname get distance
     */
    getDistance(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): number;
    /**
     * Gets the inclination of the sky material
     * @param inputs material
     * @group get
     * @shortname get inclination
     */
    getInclination(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): number;
    /**
     * Gets the azimuth of the sky material
     * @param inputs material
     * @group get
     * @shortname get azimuth
     */
    getAzimuth(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): number;
    /**
     * Gets the sun position of the sky material
     * @param inputs material
     * @group get
     * @shortname get sun position
     */
    getSunPosition(
      inputs: Inputs.BabylonMaterial.SkyMaterialPropDto
    ): Inputs.Base.Vector3;
    /**
     * Gets the use sun position of the sky material
     * @param inputs material
     * @group get
     * @shortname get use sun position
     */
    getUseSunPosition(
      inputs: Inputs.BabylonMaterial.SkyMaterialPropDto
    ): boolean;
    /**
     * Gets the camera offset of the sky material
     * @param inputs material
     * @group get
     * @shortname get camera offset
     */
    getCameraOffset(
      inputs: Inputs.BabylonMaterial.SkyMaterialPropDto
    ): Inputs.Base.Vector3;
    /**
     * Gets the up of the sky material
     * @param inputs material
     * @group get
     * @shortname get up
     */
    getUp(
      inputs: Inputs.BabylonMaterial.SkyMaterialPropDto
    ): Inputs.Base.Vector3;
    /**
     * Gets the dithering of the sky material
     * @param inputs material
     * @group get
     * @shortname get dithering
     */
    getDithering(inputs: Inputs.BabylonMaterial.SkyMaterialPropDto): boolean;
  }
  declare class BabylonMeshBuilder {
    private readonly context;
    private readonly mesh;
    constructor(context: Context, mesh: BabylonMesh);
    /**
     * Creates a box mesh
     * @param inputs required to set up basic box
     * @returns Babylon mesh
     * @group create simple
     * @shortname create box
     * @disposableOutput true
     * @drawable true
     */
    createBox(inputs: Inputs.BabylonMeshBuilder.CreateBoxDto): BABYLON.Mesh;
    /**
     * Creates a cube mesh
     * @param inputs required to set up basic cube
     * @returns Babylon mesh
     * @group create simple
     * @shortname create cube
     * @disposableOutput true
     * @drawable true
     */
    createCube(inputs: Inputs.BabylonMeshBuilder.CreateCubeDto): BABYLON.Mesh;
    /**
     * Creates a square plane mesh
     * @param inputs required to set up basic cube
     * @returns Babylon mesh
     * @group create simple
     * @shortname square plane
     * @disposableOutput true
     * @drawable true
     */
    createSquarePlane(
      inputs: Inputs.BabylonMeshBuilder.CreateSquarePlaneDto
    ): BABYLON.Mesh;
    /**
     * Creates a sphere mesh
     * @param inputs required to set up basic sphere
     * @returns Babylon mesh
     * @group create simple
     * @shortname create sphere
     * @disposableOutput true
     * @drawable true
     */
    createSphere(
      inputs: Inputs.BabylonMeshBuilder.CreateSphereDto
    ): BABYLON.Mesh;
    /**
     * Create ico sphere
     * @param inputs required to set up a ico sphere
     * @returns Babylon mesh
     * @group create simple
     * @shortname create ico sphere
     * @disposableOutput true
     * @drawable true
     */
    createIcoSphere(
      inputs: Inputs.BabylonMeshBuilder.CreateIcoSphereDto
    ): BABYLON.Mesh;
    /**
     * Creates a disc
     * @param inputs required to set up a disc
     * @returns Babylon mesh
     * @group create simple
     * @shortname create disc
     * @disposableOutput true
     * @drawable true
     */
    createDisc(inputs: Inputs.BabylonMeshBuilder.CreateDiscDto): BABYLON.Mesh;
    /**
     * Create a torus mesh
     * @param inputs required to set up a torus
     * @returns Babylon mesh
     * @group create simple
     * @shortname create torus
     * @disposableOutput true
     * @drawable true
     */
    createTorus(inputs: Inputs.BabylonMeshBuilder.CreateTorusDto): BABYLON.Mesh;
    /**
     * Create a torus knot mesh
     * @param inputs required to set up a torus knot
     * @returns Babylon mesh
     * @group create simple
     * @shortname create torus knot
     * @disposableOutput true
     * @drawable true
     */
    createTorusKnot(
      inputs: Inputs.BabylonMeshBuilder.CreateTorusKnotDto
    ): BABYLON.Mesh;
    /**
     * Create a polygon mesh
     * @param inputs required to set up a polygon
     * @returns Babylon mesh
     * @group create simple
     * @shortname create polygon
     * @disposableOutput true
     * @drawable true
     */
    createPolygon(
      inputs: Inputs.BabylonMeshBuilder.CreatePolygonDto
    ): BABYLON.Mesh;
    /**
     * Create extruded polygon mesh
     * @param inputs required to set up a extrude polygon
     * @returns Babylon mesh
     * @group create simple
     * @shortname create extrude polygon
     * @disposableOutput true
     * @drawable true
     */
    extrudePolygon(
      inputs: Inputs.BabylonMeshBuilder.ExtrudePolygonDto
    ): BABYLON.Mesh;
    /**
     * Create a tube mesh
     * @param inputs required to set up a tube
     * @returns Babylon mesh
     * @group create simple
     * @shortname create tube
     * @disposableOutput true
     * @drawable true
     */
    createTube(inputs: Inputs.BabylonMeshBuilder.CreateTubeDto): BABYLON.Mesh;
    /**
     * Create a polyhedron mesh
     * @param inputs required to set up a polyhedron
     * @returns Babylon mesh
     * @group create simple
     * @shortname create polyhedron
     * @disposableOutput true
     * @drawable true
     */
    createPolyhedron(
      inputs: Inputs.BabylonMeshBuilder.CreatePolyhedronDto
    ): BABYLON.Mesh;
    /**
     * Create geodesic mesh
     * @param inputs required to set up a geodesic
     * @returns Babylon mesh
     * @group create simple
     * @shortname create geodesic
     * @disposableOutput true
     * @drawable true
     */
    createGeodesic(
      inputs: Inputs.BabylonMeshBuilder.CreateGeodesicDto
    ): BABYLON.Mesh;
    /**
     * Create goldberg mesh
     * @param inputs required to set up a goldberg mesh
     * @returns Babylon mesh
     * @group create simple
     * @shortname create goldberg
     * @disposableOutput true
     * @drawable true
     */
    createGoldberg(
      inputs: Inputs.BabylonMeshBuilder.CreateGoldbergDto
    ): BABYLON.Mesh;
    /**
     * Create capsule mesh
     * @param inputs required to set up a capsule
     * @returns Babylon mesh
     * @group create simple
     * @shortname create capsule
     * @disposableOutput true
     * @drawable true
     */
    createCapsule(
      inputs: Inputs.BabylonMeshBuilder.CreateCapsuleDto
    ): BABYLON.Mesh;
    /**
     * Create a cylinder mesh
     * @param inputs required to set up a cylinder
     * @returns Babylon mesh
     * @group create simple
     * @shortname create cylinder
     * @disposableOutput true
     * @drawable true
     */
    createCylinder(
      inputs: Inputs.BabylonMeshBuilder.CreateCylinderDto
    ): BABYLON.Mesh;
    /**
     * Create extruded shape
     * @param inputs required to set up a extrude shape
     * @returns Babylon mesh
     * @group create simple
     * @shortname create extruded shape
     * @disposableOutput true
     * @drawable true
     */
    createExtrudedSahpe(
      inputs: Inputs.BabylonMeshBuilder.CreateExtrudedShapeDto
    ): BABYLON.Mesh;
    /**
     * Create a ribbon mesh
     * @param inputs required to set up a ribbon
     * @returns Babylon mesh
     * @group create simple
     * @shortname create ribbon
     * @disposableOutput true
     * @drawable true
     */
    createRibbon(
      inputs: Inputs.BabylonMeshBuilder.CreateRibbonDto
    ): BABYLON.Mesh;
    /**
     * Create lathe mesh
     * @param inputs required to set up a lathe
     * @returns Babylon mesh
     * @group create simple
     * @shortname create lathe
     * @disposableOutput true
     * @drawable true
     */
    createLathe(inputs: Inputs.BabylonMeshBuilder.CreateLatheDto): BABYLON.Mesh;
    /**
     * Create the ground mesh
     * @param inputs required to set up a ground
     * @returns Babylon mesh
     * @group create simple
     * @shortname create ground
     * @disposableOutput true
     * @drawable true
     */
    createGround(
      inputs: Inputs.BabylonMeshBuilder.CreateGroundDto
    ): BABYLON.Mesh;
    /**
     * Creates a rectangle plane mesh
     * @param inputs required to set up basic cube
     * @returns Babylon mesh
     * @group create simple
     * @shortname rectangle plane
     * @disposableOutput true
     * @drawable true
     */
    createRectanglePlane(
      inputs: Inputs.BabylonMeshBuilder.CreateRectanglePlaneDto
    ): BABYLON.Mesh;
    private enableShadows;
  }
  declare class BabylonMesh {
    private readonly context;
    constructor(context: Context);
    /** Disposes drawn mesh object from the scene
     * @param inputs Contains BabylonJS mesh that should be disposed
     * @group memory
     * @shortname dispose
     */
    dispose(inputs: Inputs.BabylonMesh.BabylonMeshDto): void;
    /** Udates drawn BabylonJS mesh object without disposing it
     * @param inputs Contains BabylonJS mesh that should be updated, together with position, rotation, scaling and colour info
     * @returns BabylonJS Mesh
     * @group updates
     * @shortname update drawn
     */
    updateDrawn(inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMesh): void;
    /**
     * Change the visibility of a drawn BabylonJS mesh
     * @param inputs BabylonJS mesh and parent mesh
     * @group visibility
     * @shortname set visibility
     */
    setVisibility(inputs: Inputs.BabylonMesh.SetMeshVisibilityDto): void;
    /**
     * Hides the mesh
     * @param inputs BabylonJS mesh to hide
     * @group visibility
     * @shortname hide
     */
    hide(inputs: Inputs.BabylonMesh.ShowHideMeshDto): void;
    /**
     * Show the mesh
     * @param inputs BabylonJS mesh to hide
     * @group visibility
     * @shortname show
     */
    show(inputs: Inputs.BabylonMesh.ShowHideMeshDto): void;
    /**
     * Change the parent of the drawn mesh
     * @param inputs BabylonJS mesh and parent mesh
     * @group set
     * @shortname parent
     */
    setParent(inputs: Inputs.BabylonMesh.SetParentDto): void;
    /**
     * Get the parent of the drawn mesh
     * @param inputs BabylonJS mesh
     * @returns Parent mesh
     * @group get
     * @shortname parent
     */
    getParent(inputs: Inputs.BabylonMesh.SetParentDto): BABYLON.Node;
    /**
     * Change the check collisions property of the drawn mesh
     * @param inputs BabylonJS mesh and check collisions
     * @group set
     * @shortname check collisions
     */
    setCheckCollisions(
      inputs: Inputs.BabylonMesh.CheckCollisionsBabylonMeshDto
    ): void;
    /**
     * Get the check collisions property of the drawn mesh
     * @param inputs BabylonJS mesh and check collisions
     * @group get
     * @shortname check collisions
     */
    getCheckCollisions(
      inputs: Inputs.BabylonMesh.CheckCollisionsBabylonMeshDto
    ): boolean;
    /**
     * Change the pickable property of the drawn mesh
     * @param inputs BabylonJS mesh and pickable
     * @group get
     * @shortname check collisions
     */
    setPickable(inputs: Inputs.BabylonMesh.PickableBabylonMeshDto): void;
    /**
     * Force mesh to be pickable by pointer move events, default is false as it is performance heavy
     * @param inputs BabylonJS mesh
     * @group set
     * @shortname enable pointer move events
     */
    enablePointerMoveEvents(
      inputs: Inputs.BabylonMesh.BabylonMeshWithChildrenDto
    ): void;
    /**
     * Make mesh ignore pointer move events, default is false
     * @param inputs BabylonJS mesh and pickable
     * @group set
     * @shortname disable pointer move events
     */
    disablePointerMoveEvents(
      inputs: Inputs.BabylonMesh.BabylonMeshWithChildrenDto
    ): void;
    /**
     * Change the pickable property of the drawn mesh
     * @param inputs BabylonJS mesh and pickable
     * @group get
     * @shortname pickable
     */
    getPickable(inputs: Inputs.BabylonMesh.BabylonMeshDto): boolean;
    /**
     * Gets meshes that have names which contain a given text
     * @param inputs BabylonJS mesh and name
     * @group get
     * @shortname meshes where name contains
     */
    getMeshesWhereNameContains(
      inputs: Inputs.BabylonMesh.ByNameBabylonMeshDto
    ): BABYLON.AbstractMesh[];
    /**
     * Gets child meshes
     * @param inputs BabylonJS mesh and whether to include only direct descendants
     * @group get
     * @shortname child meshes
     */
    getChildMeshes(
      inputs: Inputs.BabylonMesh.ChildMeshesBabylonMeshDto
    ): BABYLON.AbstractMesh[];
    /**
     * Gets meshes of id
     * @param inputs BabylonJS mesh and name
     * @group get
     * @shortname meshes by id
     */
    getMeshesOfId(
      inputs: Inputs.BabylonMesh.ByIdBabylonMeshDto
    ): BABYLON.AbstractMesh[];
    /**
     * Gets mesh of id
     * @param inputs BabylonJS mesh and name
     * @group get
     * @shortname mesh by id
     */
    getMeshOfId(
      inputs: Inputs.BabylonMesh.ByIdBabylonMeshDto
    ): BABYLON.AbstractMesh;
    /**
     * Gets mesh of unique id
     * @param inputs BabylonJS mesh and name
     * @group get
     * @shortname mesh by unique id
     */
    getMeshOfUniqueId(
      inputs: Inputs.BabylonMesh.UniqueIdBabylonMeshDto
    ): BABYLON.AbstractMesh;
    /**
     * Merges multiple meshes into one
     * @param inputs BabylonJS meshes and options
     * @returns a new mesh
     * @group edit
     * @shortname merge
     */
    mergeMeshes(inputs: Inputs.BabylonMesh.MergeMeshesDto): BABYLON.Mesh;
    /** Convers mesh to flat shaded mesh
     * @param inputs BabylonJS mesh
     * @returns a new mesh
     * @group edit
     * @shortname convert to flat shaded
     */
    convertToFlatShadedMesh(
      inputs: Inputs.BabylonMesh.BabylonMeshDto
    ): BABYLON.Mesh;
    /**
     * Clones the mesh
     * @param inputs BabylonJS mesh to clone
     * @returns a new mesh
     * @group edit
     * @shortname clone
     * @disposableOutput true
     */
    clone(inputs: Inputs.BabylonMesh.BabylonMeshDto): BABYLON.Mesh;
    /**
     * Clones the mesh to positions
     * @param inputs BabylonJS mesh and positions
     * @returns a new mesh
     * @group edit
     * @shortname clone to positions
     * @disposableOutput true
     * @drawable true
     */
    cloneToPositions(
      inputs: Inputs.BabylonMesh.CloneToPositionsDto
    ): BABYLON.Mesh[];
    /**
     * Change the id of the drawn mesh
     * @param inputs BabylonJS mesh and name
     * @group set
     * @shortname id
     */
    setId(inputs: Inputs.BabylonMesh.IdBabylonMeshDto): void;
    /**
     * Get the id of the drawn mesh
     * @param inputs BabylonJS mesh and id
     * @group get
     * @shortname id
     */
    getId(inputs: Inputs.BabylonMesh.IdBabylonMeshDto): string;
    /**
     * Get the unique id of the drawn mesh
     * @param inputs BabylonJS mesh and id
     * @returns unique id number
     * @group get
     * @shortname unique id
     */
    getUniqueId(inputs: Inputs.BabylonMesh.BabylonMeshDto): number;
    /**
     * Change the name of the drawn mesh
     * @param inputs BabylonJS mesh and name
     * @group set
     * @shortname name
     */
    setName(inputs: Inputs.BabylonMesh.NameBabylonMeshDto): void;
    /**
     * Gets the vertices as polygon points. These can be used with other construction methods to create meshes. Mesh must be triangulated.
     * @param inputs BabylonJS mesh and name
     * @group get
     * @shortname vertices as polygon points
     */
    getVerticesAsPolygonPoints(
      inputs: Inputs.BabylonMesh.BabylonMeshDto
    ): Base.Point3[][];
    /**
     * Gets the name of babylon mesh
     * @param inputs BabylonJS mesh and name
     * @group get
     * @shortname name
     */
    getName(inputs: Inputs.BabylonMesh.BabylonMeshDto): string;
    /**
     * Change the material of the drawn mesh
     * @param inputs BabylonJS mesh and material
     * @group set
     * @shortname material
     */
    setMaterial(inputs: Inputs.BabylonMesh.MaterialBabylonMeshDto): void;
    /**
     * Gets the material of babylon mesh
     * @param inputs BabylonJS mesh
     * @group get
     * @shortname material
     */
    getMaterial(inputs: Inputs.BabylonMesh.BabylonMeshDto): BABYLON.Material;
    /**
     * Gets the position as point of babylonjs mesh
     * @param inputs BabylonJS mesh
     * @returns point
     * @group get
     * @shortname position
     */
    getPosition(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;
    /**
     * Gets the absolute position in the world as point of babylonjs mesh
     * @param inputs BabylonJS mesh
     * @returns point
     * @group get
     * @shortname absolute position
     */
    getAbsolutePosition(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;
    /**
     * Gets the rotation vector of babylonjs mesh
     * @param inputs BabylonJS mesh
     * @group get
     * @shortname rotation
     */
    getRotation(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;
    /**
     * Gets the scale vector of babylonjs mesh
     * @param inputs BabylonJS mesh
     * @group get
     * @shortname scale
     */
    getScale(inputs: Inputs.BabylonMesh.BabylonMeshDto): Base.Point3;
    /**
     * Moves babylonjs mesh forward in local space
     * @param inputs BabylonJS mesh and distance
     * @group move
     * @shortname forward
     */
    moveForward(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;
    /**
     * Moves babylonjs mesh backward in local space
     * @param inputs BabylonJS mesh and distance
     * @group move
     * @shortname backward
     */
    moveBackward(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;
    /**
     * Moves babylonjs mesh up in local space
     * @param inputs BabylonJS mesh and distance
     * @group move
     * @shortname up
     */
    moveUp(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;
    /**
     * Moves babylonjs mesh down in local space
     * @param inputs BabylonJS mesh and distance
     * @group move
     * @shortname down
     */
    moveDown(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;
    /**
     * Moves babylonjs mesh right in local space
     * @param inputs BabylonJS mesh and distance
     * @group move
     * @shortname right
     */
    moveRight(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;
    /**
     * Moves babylonjs mesh left in local space
     * @param inputs BabylonJS mesh and distance
     * @group move
     * @shortname left
     */
    moveLeft(inputs: Inputs.BabylonMesh.TranslateBabylonMeshDto): void;
    /**
     * Rotates babylonjs mesh around local y axis
     * @param inputs BabylonJS mesh and rotation in degrees
     * @group move
     * @shortname yaw
     */
    yaw(inputs: Inputs.BabylonMesh.RotateBabylonMeshDto): void;
    /**
     * Rotates babylonjs mesh around local x axis
     * @param inputs BabylonJS mesh and rotation in degrees
     * @group move
     * @shortname pitch
     */
    pitch(inputs: Inputs.BabylonMesh.RotateBabylonMeshDto): void;
    /**
     * Rotates babylonjs mesh around local z axis
     * @param inputs BabylonJS mesh and rotation in degrees
     * @group move
     * @shortname roll
     */
    roll(inputs: Inputs.BabylonMesh.RotateBabylonMeshDto): void;
    /**
     * Rotates the mesh around axis and given position by a given angle
     * @param inputs Rotation around axis information
     * @group move
     * @shortname rotate around axis with position
     */
    rotateAroundAxisWithPosition(
      inputs: Inputs.BabylonMesh.RotateAroundAxisNodeDto
    ): void;
    /**
     * Updates the position of the BabylonJS mesh or instanced mesh
     * @param inputs BabylonJS mesh and position point
     * @group set
     * @shortname position
     */
    setPosition(
      inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMeshPositionDto
    ): void;
    /**
     * Updates the rotation of the BabylonJS mesh or instanced mesh
     * @param inputs BabylonJS mesh and rotation along x, y and z axis in degrees
     * @group set
     * @shortname rotation
     */
    setRotation(
      inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMeshRotationDto
    ): void;
    /**
     * Updates the scale of the BabylonJS mesh or instanced mesh
     * @param inputs BabylonJS mesh and scale vector
     * @group set
     * @shortname scale
     */
    setScale(inputs: Inputs.BabylonMesh.UpdateDrawnBabylonMeshScaleDto): void;
    /**
     * Scales the BabylonJS mesh or instanced mesh in place by a given factor
     * @param inputs BabylonJS mesh and scale factor
     * @group set
     * @shortname scale in place
     */
    setLocalScale(inputs: Inputs.BabylonMesh.ScaleInPlaceDto): void;
    /**
     * Checks wether mesh intersects another mesh mesh
     * @param inputs Two BabylonJS meshes
     * @group intersects
     * @shortname mesh
     */
    intersectsMesh(inputs: Inputs.BabylonMesh.IntersectsMeshDto): boolean;
    /**
     * Checks wether mesh intersects point
     * @param inputs BabylonJS mesh and point
     * @group intersects
     * @shortname point
     */
    intersectsPoint(inputs: Inputs.BabylonMesh.IntersectsPointDto): boolean;
    /**
     * Creates mesh instance for optimised rendering. This method will check if mesh contains children and will create instances for each child.
     *  These are optimised for max performance when rendering many similar objects in the scene. This method returns instances as childrens in a new mesh.
     * If the mesh has children, then every child goes a mesh instance.
     * @group instance
     * @shortname create and transform
     * @disposableOutput true
     */
    createMeshInstanceAndTransformNoReturn(
      inputs: Inputs.BabylonMesh.MeshInstanceAndTransformDto
    ): void;
    /**
     * Creates mesh instance for optimised rendering. This method will check if mesh contains children and will create instances for each child.
     *  These are optimised for max performance when rendering many similar objects in the scene. This method returns instances as childrens in a new mesh.
     * If the mesh has children, then every child goes a mesh instance.
     * @group instance
     * @returns babylon mesh
     * @shortname create and transform
     * @disposableOutput true
     */
    createMeshInstanceAndTransform(
      inputs: Inputs.BabylonMesh.MeshInstanceAndTransformDto
    ): BABYLON.Mesh;
    /**
     * Creates mesh instance. These are optimised for max performance
     * when rendering many similar objects in the scene. If the mesh has children, then every child gets a mesh instance.
     * @group instance
     * @shortname create
     * @disposableOutput true
     */
    createMeshInstance(
      inputs: Inputs.BabylonMesh.MeshInstanceDto
    ): BABYLON.Mesh;
    /**
     * Gets side orientation
     * @ignore true
     */
    getSideOrientation(
      sideOrientation: Inputs.BabylonMesh.sideOrientationEnum
    ): number;
    private assignColorToMesh;
  }
  /**
   * Nodes help understand the space and construct more complicated space structures. Nodes can be nested together
   * into child parent relationships to simplify the creation of 3D objects.
   */
  declare class BabylonNode {
    private readonly context;
    private readonly drawHelper;
    constructor(context: Context, drawHelper: DrawHelper);
    /**
     * Draws a node of given size with given colours for every axis
     * @param inputs Contains node data that includes size and colour information
     */
    drawNode(inputs: Inputs.BabylonNode.DrawNodeDto): void;
    /**
     * Draws a nodes of given size with given colours for every axis
     * @param inputs Contains node data that includes size and colour information
     */
    drawNodes(inputs: Inputs.BabylonNode.DrawNodesDto): void;
    /**
     * Creates a node on the origin with the given rotations in the parent coordinate system
     * @param inputs Contains information for origin, rotation and parent node
     * @returns A new node
     */
    createNodeFromRotation(
      inputs: Inputs.BabylonNode.CreateNodeFromRotationDto
    ): BABYLON.TransformNode;
    /**
     * Creates a world node which has root node as his parent
     * @returns A new node whos parent is the root node of the scene
     */
    createWorldNode(): BABYLON.TransformNode;
    /**
     * Gets the absolute forward facing vector in world space
     * @param inputs Node from which to get the forward vector
     * @returns Vector as an array of numbers
     */
    getAbsoluteForwardVector(inputs: Inputs.BabylonNode.NodeDto): number[];
    /**
     * Gets the absolute right facing vector in world space
     * @param inputs Node from which to get the right vector
     * @returns Vector as an array of numbers
     */
    getAbsoluteRightVector(inputs: Inputs.BabylonNode.NodeDto): number[];
    /**
     * Gets the absolute up facing vector in world space
     * @param inputs Node from which to get the up vector
     * @returns Vector as an array of numbers
     */
    getAbsoluteUpVector(inputs: Inputs.BabylonNode.NodeDto): number[];
    /**
     * Gets the absolute position of the node as origin vector in world space
     * @param inputs Node from which to get the absolute position
     * @returns Vector as an array of numbers indicating location of origin in world space
     */
    getAbsolutePosition(inputs: Inputs.BabylonNode.NodeDto): number[];
    /**
     * Gets the absolute rotation of the node as a transformation matrix encoded in array of 16 numbers
     * @param inputs Node from which to get the rotation transformation
     * @returns Transformation as an array of 16 numbers
     */
    getAbsoluteRotationTransformation(
      inputs: Inputs.BabylonNode.NodeDto
    ): number[];
    /**
     * Gets the rotation of the node in local parent coordinate space as a transformation matrix encoded in array of 16 numbers
     * @param inputs Node from which to get the rotation transformation
     * @returns Transformation as an array of 16 numbers
     */
    getRotationTransformation(inputs: Inputs.BabylonNode.NodeDto): number[];
    /**
     * Gets children of the node
     * @param inputs Node from which to get the children
     * @returns List of children nodes in the array
     */
    getChildren(inputs: Inputs.BabylonNode.NodeDto): BABYLON.Node[];
    /**
     * Gets parent of the node
     * @param inputs Node from which to get a parent
     * @returns Parent node
     */
    getParent(inputs: Inputs.BabylonNode.NodeDto): BABYLON.Node;
    /**
     * Gets the position of the node expressed in local space
     * @param inputs Node from which to get the position in local space
     * @returns Position vector
     */
    getPositionExpressedInLocalSpace(
      inputs: Inputs.BabylonNode.NodeDto
    ): number[];
    /**
     * Gets the root node
     * @returns Root node
     */
    getRootNode(): BABYLON.TransformNode;
    /**
     * Gets the euler rotations
     * @param inputs Node from which to get rotation
     * @returns Euler rotations of x, y and z angles in the number array
     */
    getRotation(inputs: Inputs.BabylonNode.NodeDto): number[];
    /**
     * Rotates the node around axis and given position by a given angle
     * @param inputs Rotation around axis information
     */
    rotateAroundAxisWithPosition(
      inputs: Inputs.BabylonNode.RotateAroundAxisNodeDto
    ): void;
    /**
     * Rotates the node around the origin and given axis
     * @param inputs Rotation information
     */
    rotate(inputs: Inputs.BabylonNode.RotateNodeDto): void;
    /**
     * Sets the absolute position of the node
     * @param inputs Node absolute position information
     */
    setAbsolutePosition(inputs: Inputs.BabylonNode.NodePositionDto): void;
    /**
     * Sets the direction of the node
     * @param inputs Direction information
     */
    setDirection(inputs: Inputs.BabylonNode.NodeDirectionDto): void;
    /**
     * Sets the new parent to the node
     * @param inputs Node parent information
     */
    setParent(inputs: Inputs.BabylonNode.NodeParentDto): void;
    /**
     * Translates the node by a given direction vector and a distance
     * @param inputs Node translation information
     */
    translate(inputs: Inputs.BabylonNode.NodeTranslationDto): void;
  }
  declare class BabylonPick {
    private readonly context;
    constructor(context: Context);
    /**
     * Get a hit result of picking with ray
     * @param inputs ray to use for picking
     * @group pick
     * @shortname pick with custom ray
     * @returns Picking info
     */
    pickWithRay(inputs: Inputs.BabylonPick.RayDto): BABYLON.PickingInfo;
    /**
     * Pick with picking ray of the current mouse position in the active camera
     * @group pick
     * @shortname pick with picking ray
     * @returns Picking info
     */
    pickWithPickingRay(): BABYLON.PickingInfo;
    /**
     * Get the distance to the object if picking result exists
     * @param inputs picking result
     * @group get from pick info
     * @shortname pick distance
     * @returns Distance
     */
    getDistance(inputs: Inputs.BabylonPick.PickInfo): number;
    /**
     * Get the picked mesh
     * @param inputs picking result
     * @group get from pick info
     * @shortname picked mesh
     * @returns Picked mesh
     */
    getPickedMesh(inputs: Inputs.BabylonPick.PickInfo): BABYLON.AbstractMesh;
    /**
     * Get the picked point
     * @param inputs picking result
     * @group get from pick info
     * @shortname picked point
     * @returns Picked point
     */
    getPickedPoint(inputs: Inputs.BabylonPick.PickInfo): Base.Point3;
    /**
     * Check if pick ray hit something in the scene or not
     * @param inputs picking result
     * @group get from pick info
     * @shortname hit
     * @returns Indication of a hit
     */
    hit(inputs: Inputs.BabylonPick.PickInfo): boolean;
    /**
     * Gets the unique submesh id if it was picked
     * @param inputs picking result
     * @group get from pick info
     * @shortname sub mesh id
     * @returns Submesh id
     */
    getSubMeshId(inputs: Inputs.BabylonPick.PickInfo): number;
    /**
     * Gets the unique submesh face id if it was picked
     * @param inputs picking result
     * @group get from pick info
     * @shortname sub mesh face id
     * @returns Submesh face id
     */
    getSubMeshFaceId(inputs: Inputs.BabylonPick.PickInfo): number;
    /**
     * Gets the the barycentric U coordinate that is used when calculating the texture coordinates of the collision
     * @param inputs picking result
     * @group get from pick info
     * @shortname picked bu
     * @returns U coordinate
     */
    getBU(inputs: Inputs.BabylonPick.PickInfo): number;
    /**
     * Gets the the barycentric V coordinate that is used when calculating the texture coordinates of the collision
     * @param inputs picking result
     * @group get from pick info
     * @shortname picked bv
     * @returns V coordinate
     */
    getBV(inputs: Inputs.BabylonPick.PickInfo): number;
    /**
     * Get the picked sprite
     * @param inputs picking result
     * @group get from pick info
     * @shortname picked sprite
     * @returns Picked sprite
     */
    getPickedSprite(inputs: Inputs.BabylonPick.PickInfo): BABYLON.Sprite;
  }
  declare class BabylonRay {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates a picking ray of the current mouse position in the active camera
     * @group create
     * @shortname create picking ray
     * @returns Ray
     */
    createPickingRay(): BABYLON.Ray;
    /**
     * Create a ray that start at origin, has direction vector and optionally length
     * @param inputs origin, direction and length
     * @group create
     * @shortname create custom ray
     * @returns ray
     */
    createRay(inputs: Inputs.BabylonRay.BaseRayDto): BABYLON.Ray;
    /**
     * Create a ray from one point to another
     * @param inputs origin, direction and length
     * @group create
     * @shortname create ray from to
     * @returns ray
     */
    createRayFromTo(inputs: Inputs.BabylonRay.FromToDto): BABYLON.Ray;
    /**
     * Get the origin of the ray
     * @param inputs ray
     * @group get
     * @shortname get ray origin
     * @returns origin point
     */
    getOrigin(inputs: Inputs.BabylonRay.RayDto): Base.Point3;
    /**
     * Get the direction of the ray
     * @param inputs ray
     * @group get
     * @shortname get ray direction
     * @returns direction vector
     */
    getDirection(inputs: Inputs.BabylonRay.RayDto): Base.Vector3;
    /**
     * Get the length of the ray
     * @param inputs ray
     * @group get
     * @shortname get ray length
     * @returns length
     */
    getLength(inputs: Inputs.BabylonRay.RayDto): number;
  }
  declare class BabylonScene {
    private readonly context;
    constructor(context: Context);
    /**
     * Gets the scene for the current context
     * @ignore true
     * @group scene
     * @shortname get scene
     */
    getScene(): BABYLON.Scene;
    /**
     * Gets the scene for the current context
     * @ignore true
     * @group scene
     * @shortname get scene
     */
    setAndAttachScene(inputs: Inputs.BabylonScene.SceneDto): BABYLON.Scene;
    /**
     * Activate camera by overwriting currently active camera
     * @param inputs Activates the camera
     * @group camera
     * @shortname activate
     */
    activateCamera(inputs: Inputs.BabylonScene.ActiveCameraDto): void;
    /**
     * Use right handed system
     * @param inputs Activates the camera
     * @group system
     * @shortname hand right
     */
    useRightHandedSystem(
      inputs: Inputs.BabylonScene.UseRightHandedSystemDto
    ): void;
    /**
     * Creates and draws a point light in the scene but does not output anything
     * @param inputs Describes the light source
     * @group lights
     * @shortname point
     * @disposableOutput true
     */
    drawPointLightNoReturn(inputs: Inputs.BabylonScene.PointLightDto): void;
    /**
     * Get shadow generators added by light sources through bitbybit
     * @param inputs Describes the light source
     * @group lights
     * @shortname point
     * @disposableOutput true
     */
    getShadowGenerators(): BABYLON.ShadowGenerator[];
    /**
     * Creates and draws a point light in the scene
     * @param inputs Describes the light source
     * @returns BabylonJS point light
     * @group lights
     * @shortname point light
     * @disposableOutput true
     */
    drawPointLight(
      inputs: Inputs.BabylonScene.PointLightDto
    ): BABYLON.PointLight;
    /**
     * Creates and draws a directional light in the scene
     * @param inputs Describes the light source
     * @group lights
     * @shortname directional
     * @disposableOutput true
     */
    drawDirectionalLightNoReturn(
      inputs: Inputs.BabylonScene.DirectionalLightDto
    ): void;
    /**
     * Creates and draws a directional light in the scene
     * @param inputs Describes the light source
     * @returns BabylonJS directional light
     * @group lights
     * @shortname directional light
     * @disposableOutput true
     */
    drawDirectionalLight(
      inputs: Inputs.BabylonScene.DirectionalLightDto
    ): BABYLON.DirectionalLight;
    /**
     * Gets the active camera of the scene
     * @group camera
     * @shortname get active camera
     */
    getActiveCamera(): BABYLON.Camera;
    /**
     * Adjusts the active arc rotate camera with configuration parameters
     * @group camera
     * @shortname adjust active camera
     */
    adjustActiveArcRotateCamera(
      inputs: Inputs.BabylonScene.CameraConfigurationDto
    ): void;
    /**
     * Clears all of the drawn objects in the 3D scene
     * @group environment
     * @shortname clear all drawn
     */
    clearAllDrawn(): void;
    /**
     * Enables skybox
     * @param inputs Skybox configuration
     * @group environment
     * @shortname skybox
     */
    enableSkybox(inputs: Inputs.BabylonScene.SkyboxDto): void;
    /**
     * Enables skybox with custom texture
     * @param inputs Skybox configuration
     * @group environment
     * @shortname skybox
     */
    enableSkyboxCustomTexture(
      inputs: Inputs.BabylonScene.SkyboxCustomTextureDto
    ): void;
    /**
     * Registers code to run when pointer is down
     * @param inputs pointer statement
     * @ignore true
     */
    onPointerDown(inputs: Inputs.BabylonScene.PointerDto): void;
    /**
     * Registers code to run when pointer is up
     * @param inputs pointer statement
     * @ignore true
     */
    onPointerUp(inputs: Inputs.BabylonScene.PointerDto): void;
    /**
     * Registers code to run when pointer is moving
     * @param inputs pointer statement
     * @ignore true
     */
    onPointerMove(inputs: Inputs.BabylonScene.PointerDto): void;
    /**
     * Enables fog mode
     * @param inputs fog options
     * @group environment
     * @shortname fog
     */
    fog(inputs: Inputs.BabylonScene.FogDto): void;
    /**
     * Enables the physics
     * @param inputs the gravity vector
     * @ignore true
     * @group physics
     * @shortname enable
     */
    enablePhysics(inputs: Inputs.BabylonScene.EnablePhysicsDto): void;
    /**
     * Changes the scene background to a css background image for 3D space
     * @param inputs Describes the css of the scene background or image
     * @group background
     * @shortname css background image
     */
    canvasCSSBackgroundImage(
      inputs: Inputs.BabylonScene.SceneCanvasCSSBackgroundImageDto
    ): {
      backgroundImage: string;
    };
    /**
     * Creates a two-color linear gradient background for 3D space
     * @param inputs Describes the two-color linear gradient parameters
     * @group background
     * @shortname two color linear gradient
     */
    twoColorLinearGradientBackground(
      inputs: Inputs.BabylonScene.SceneTwoColorLinearGradientDto
    ): {
      backgroundImage: string;
    };
    /**
     * Creates a two-color radial gradient background for 3D space
     * @param inputs Describes the two-color radial gradient parameters
     * @group background
     * @shortname two color radial gradient
     */
    twoColorRadialGradientBackground(
      inputs: Inputs.BabylonScene.SceneTwoColorRadialGradientDto
    ): {
      backgroundImage: string;
    };
    /**
     * Creates a multi-color linear gradient background for 3D space
     * @param inputs Describes the multi-color linear gradient parameters
     * @group background
     * @shortname multi color linear gradient
     */
    multiColorLinearGradientBackground(
      inputs: Inputs.BabylonScene.SceneMultiColorLinearGradientDto
    ):
      | {
          backgroundImage: string;
        }
      | {
          error: string;
        };
    /**
     * Creates a multi-color radial gradient background for 3D space
     * @param inputs Describes the multi-color radial gradient parameters
     * @group background
     * @shortname multi color radial gradient
     */
    multiColorRadialGradientBackground(
      inputs: Inputs.BabylonScene.SceneMultiColorRadialGradientDto
    ):
      | {
          backgroundImage: string;
        }
      | {
          error: string;
        };
    /**
     * Sets a background image with various customization options for 3D space
     * @param inputs Describes the background image parameters
     * @group background
     * @shortname background image
     */
    canvasBackgroundImage(
      inputs: Inputs.BabylonScene.SceneCanvasBackgroundImageDto
    ): {
      backgroundImage: string;
      backgroundRepeat: string;
      backgroundSize: string;
      backgroundPosition: string;
      backgroundAttachment: string;
      backgroundOrigin: string;
      backgroundClip: string;
    };
    /**
     * Changes the scene background colour for 3D space
     * @param inputs Describes the colour of the scene background
     * @group background
     * @shortname colour
     */
    backgroundColour(
      inputs: Inputs.BabylonScene.SceneBackgroundColourDto
    ): void;
    private getRadians;
    private createSkyboxMesh;
  }
  declare class BabylonTexture {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates texture from URL from a few basic options. If you loaded the asset via the file, create object url and pass it here.
     * @param inputs required to set up basic texture
     * @returns Babylon texture that can be used with materials
     * @group create
     * @shortname simple texture
     * @disposableOutput true
     */
    createSimple(
      inputs: Inputs.BabylonTexture.TextureSimpleDto
    ): BABYLON.Texture;
  }
  declare class BabylonTools {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates a screenshot of the scene
     * @group screenshots
     * @shortname create screenshot
     */
    createScreenshot(
      inputs: Inputs.BabylonTools.ScreenshotDto
    ): Promise<string>;
    /**
     * Creates a screenshot of the scene and download file
     * @group screenshots
     * @shortname create screenshot and download
     */
    createScreenshotAndDownload(
      inputs: Inputs.BabylonTools.ScreenshotDto
    ): Promise<string>;
  }
  /**
   * Transformations help to move, scale, rotate and mirror objects. You can combine multiple transformations
   * for object to be placed exactly into position and orientation that you want.
   * Contains various methods for transformations that represent 4x4 matrixes in flat 16 number arrays.
   */
  declare class BabylonTransforms {
    /**
     * Creates a rotation transformations around the center and an axis
     * @param inputs Rotation around center with an axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center axis
     * @drawable false
     */
    rotationCenterAxis(
      inputs: Inputs.BabylonTransforms.RotationCenterAxisDto
    ): Base.TransformMatrixes;
    /**
     * Creates a rotation transformations around the center and an X axis
     * @param inputs Rotation around center with an X axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center x
     * @drawable false
     */
    rotationCenterX(
      inputs: Inputs.BabylonTransforms.RotationCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates a rotation transformations around the center and an Y axis
     * @param inputs Rotation around center with an Y axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center y
     * @drawable false
     */
    rotationCenterY(
      inputs: Inputs.BabylonTransforms.RotationCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates a rotation transformations around the center and an Z axis
     * @param inputs Rotation around center with an Z axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center z
     * @drawable false
     */
    rotationCenterZ(
      inputs: Inputs.BabylonTransforms.RotationCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates a rotation transformations with yaw pitch and roll
     * @param inputs Yaw pitch roll rotation information
     * @returns array of transformations
     * @group rotation
     * @shortname yaw pitch roll
     * @drawable false
     */
    rotationCenterYawPitchRoll(
      inputs: Inputs.BabylonTransforms.RotationCenterYawPitchRollDto
    ): Base.TransformMatrixes;
    /**
     * Scale transformation around center and xyz directions
     * @param inputs Scale center xyz trnansformation
     * @returns array of transformations
     * @group rotation
     * @shortname center xyz
     * @drawable false
     */
    scaleCenterXYZ(
      inputs: Inputs.BabylonTransforms.ScaleCenterXYZDto
    ): Base.TransformMatrixes;
    /**
     * Creates the scale transformation in x, y and z directions
     * @param inputs Scale XYZ number array information
     * @returns transformation
     * @group scale
     * @shortname xyz
     * @drawable false
     */
    scaleXYZ(
      inputs: Inputs.BabylonTransforms.ScaleXYZDto
    ): Base.TransformMatrixes;
    /**
     * Creates uniform scale transformation
     * @param inputs Scale Dto
     * @returns transformation
     * @group scale
     * @shortname uniform
     * @drawable false
     */
    uniformScale(
      inputs: Inputs.BabylonTransforms.UniformScaleDto
    ): Base.TransformMatrixes;
    /**
     * Creates uniform scale transformation from the center
     * @param inputs Scale Dto with center point information
     * @returns array of transformations
     * @group scale
     * @shortname uniform from center
     * @drawable false
     */
    uniformScaleFromCenter(
      inputs: Inputs.BabylonTransforms.UniformScaleFromCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates the translation transformation
     * @param inputs Translation information
     * @returns transformation
     * @group translation
     * @shortname xyz
     * @drawable false
     */
    translationXYZ(
      inputs: Inputs.BabylonTransforms.TranslationXYZDto
    ): Base.TransformMatrixes;
    /**
     * Creates the translation transformation
     * @param inputs Translation information
     * @returns transformation
     * @group translations
     * @shortname xyz
     * @drawable false
     */
    translationsXYZ(
      inputs: Inputs.BabylonTransforms.TranslationsXYZDto
    ): Base.TransformMatrixes[];
  }
  declare class BabylonWebXRBase {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates default XR experience
     * @param inputs Options for basic configuration
     * @group scene
     * @shortname default xr experience async
     * @disposableOutput true
     */
    createDefaultXRExperienceAsync(
      inputs: Inputs.BabylonWebXR.WebXRDefaultExperienceOptions
    ): Promise<BABYLON.WebXRDefaultExperience>;
    /**
     * Creates default XR experience
     * @param inputs Options for basic configuration
     * @group scene
     * @shortname default xr experience no opt. async
     * @disposableOutput true
     */
    createDefaultXRExperienceNoOptionsAsync(): Promise<BABYLON.WebXRDefaultExperience>;
    /**
     * Returns the base experience of the default XR experience
     * @param inputs Inputs with the default XR experience
     * @group get
     * @shortname get base experience
     */
    getBaseExperience(
      inputs: Inputs.BabylonWebXR.WebXRDefaultExperienceDto
    ): BABYLON.WebXRExperienceHelper;
    /**
     * Returns the feature manager of the default XR experience
     * @param inputs Inputs with the default XR experience
     * @group get
     * @shortname get feature manager
     */
    getFeatureManager(
      inputs: Inputs.BabylonWebXR.WebXRExperienceHelperDto
    ): BABYLON.WebXRFeaturesManager;
  }
  declare class BabylonWebXRSimple {
    private readonly context;
    constructor(context: Context);
    /**
     * Creates default XR experience in immersive-ar mode
     * @param inputs Creates default XR experience with teleportation
     * @returns Default XR experience
     * @group scene
     * @shortname simple immersive ar experience
     * @disposableOutput true
     */
    createImmersiveARExperience(): Promise<BABYLON.WebXRDefaultExperience>;
    /**
     * Creates default XR experience with teleportation that is very basic and works for simple scenarios
     * @param inputs Creates default XR experience with teleportation
     * @group scene
     * @shortname simple xr with teleportation
     */
    createDefaultXRExperienceWithTeleportation(
      inputs: Inputs.BabylonWebXR.DefaultWebXRWithTeleportationDto
    ): Promise<void>;
    /**
     * Creates default XR experience with teleportation that is very basic and works for simple scenarios
     * @param inputs Creates default XR experience with teleportation
     * @group scene
     * @shortname simple xr with teleportation return
     * @disposableOutput true
     */
    createDefaultXRExperienceWithTeleportationReturn(
      inputs: Inputs.BabylonWebXR.DefaultWebXRWithTeleportationDto
    ): Promise<{
      xr: BABYLON.WebXRDefaultExperience;
      torusMat: BABYLON.PBRMetallicRoughnessMaterial;
      manager: GUI3DManager;
      near: NearMenu;
      button: TouchHolographicButton;
      text: TextBlock;
      dispose: () => void;
    }>;
  }
  declare class BabylonWebXR {
    private readonly context;
    simple: BabylonWebXRSimple;
    constructor(context: Context);
  }
  declare class Draw extends DrawCore {
    /**
     * @ignore true
     */
    readonly drawHelper: DrawHelper;
    /**
     * @ignore true
     */
    readonly node: BabylonNode;
    /**
     * @ignore true
     */
    readonly tag: Tag;
    /**
     * @ignore true
     */
    readonly context: Context;
    private defaultBasicOptions;
    private defaultPolylineOptions;
    private defaultNodeOptions;
    constructor(
      /**
       * @ignore true
       */
      drawHelper: DrawHelper,
      /**
       * @ignore true
       */
      node: BabylonNode,
      /**
       * @ignore true
       */
      tag: Tag,
      /**
       * @ignore true
       */
      context: Context
    );
    /**
     * Draws any kind of geometry and does not return anything
     * @param inputs Contains options and entities to be drawn
     * @group draw async
     * @shortname draw async void
     * @disposableOutput true
     * @drawable true
     */
    drawAnyAsyncNoReturn(inputs: Inputs.Draw.DrawAny): Promise<void>;
    /**
     * Draws any kind of geometry and returns the babylon mesh
     * @param inputs Contains options and entities to be drawn
     * @returns BabylonJS Mesh Promise
     * @group draw async
     * @shortname draw async
     * @drawable true
     * @disposableOutput true
     */
    drawAnyAsync(inputs: Inputs.Draw.DrawAny): Promise<BABYLON.Mesh>;
    private updateAny;
    /**
     * Draws any kind of geometry that does not need asynchronous computing, thus it cant be used with shapes coming from occt or jscad
     * @param inputs Contains options and entities to be drawn
     * @returns BabylonJS Mesh
     * @group draw sync
     * @shortname draw sync void
     */
    drawAnyNoReturn(inputs: Inputs.Draw.DrawAny): void;
    /**
     * Draws any kind of geometry that does not need asynchronous computing, thus it cant be used with shapes coming from occt or jscad
     * @param inputs Contains options and entities to be drawn
     * @returns BabylonJS Mesh
     * @group draw sync
     * @shortname draw sync
     */
    drawAny(inputs: Inputs.Draw.DrawAny): BABYLON.Mesh;
    /**
     * Draws a grid mesh on the ground plane in 3D space. This helps to orient yourself in the world.
     * @param inputs Describes various parameters of the grid mesh like size, colour, etc.
     * @group grid
     * @shortname draw grid no return
     * @disposableOutput true
     */
    drawGridMeshNoReturn(inputs: Inputs.Draw.SceneDrawGridMeshDto): void;
    /**
     * Draws a grid mesh on the ground plane in 3D space. This helps to orient yourself in the world.
     * @param inputs Describes various parameters of the grid mesh like size, colour, etc.
     * @returns grid mesh
     * @group grid
     * @shortname draw grid
     * @disposableOutput true
     */
    drawGridMesh(inputs: Inputs.Draw.SceneDrawGridMeshDto): BABYLON.Mesh;
    /**
     * Creates draw options for basic geometry types like points, lines, polylines, surfaces and jscad meshes
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname simple
     */
    optionsSimple(
      inputs: Inputs.Draw.DrawBasicGeometryOptions
    ): Inputs.Draw.DrawBasicGeometryOptions;
    /**
     * Creates draw options for occt shape geometry like edges, wires, faces, shells, solids and compounds
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname occt shape
     */
    optionsOcctShape(
      inputs: Inputs.Draw.DrawOcctShapeOptions
    ): Inputs.Draw.DrawOcctShapeOptions;
    /**
     * Creates simple draw options for occt shape geometry
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname occt shape simple
     */
    optionsOcctShapeSimple(
      inputs: Inputs.Draw.DrawOcctShapeSimpleOptions
    ): Inputs.Draw.DrawOcctShapeSimpleOptions;
    /**
     * Creates simple draw options with custom face material for occt shape geometry
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname occt shape with material
     */
    optionsOcctShapeMaterial(
      inputs: Inputs.Draw.DrawOcctShapeMaterialOptions
    ): Inputs.Draw.DrawOcctShapeMaterialOptions;
    /**
     * Creates draw options for manifold gemetry
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname manifold shape draw options
     */
    optionsManifoldShapeMaterial(
      inputs: Inputs.Draw.DrawManifoldOrCrossSectionOptions
    ): Inputs.Draw.DrawManifoldOrCrossSectionOptions;
    /**
     * Creates draw options for babylon js nodes
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname babylon node
     */
    optionsBabylonNode(
      inputs: Inputs.Draw.DrawNodeOptions
    ): Inputs.Draw.DrawNodeOptions;
    /**
     * Creates a generic texture that can be used with PBR materials.
     * This method provides a cross-engine compatible way to create textures.
     * @param inputs Texture configuration options
     * @returns BabylonJS Texture
     * @group material
     * @shortname create texture
     * @disposableOutput true
     */
    createTexture(inputs: Inputs.Draw.GenericTextureDto): BABYLON.Texture;
    /**
     * Creates a generic PBR (Physically Based Rendering) material.
     * This method provides a cross-engine compatible way to create materials
     * that can be used with draw options for OCCT shapes and other geometry.
     * @param inputs Material configuration options
     * @returns BabylonJS PBRMetallicRoughnessMaterial
     * @group material
     * @shortname create pbr material
     * @disposableOutput true
     */
    createPBRMaterial(
      inputs: Inputs.Draw.GenericPBRMaterialDto
    ): BABYLON.PBRMetallicRoughnessMaterial;
    private getSamplingMode;
    private handleTags;
    private handleTag;
    private handleVerbSurfaces;
    private handleVerbCurves;
    private handleNodes;
    private handlePoints;
    private handleLines;
    private handlePolylines;
    private handleVerbSurface;
    private handleVerbCurve;
    private handleNode;
    private handlePolyline;
    private handlePoint;
    private handleLine;
    private handleJscadMeshes;
    private handleManifoldShape;
    private handleManifoldShapes;
    private handleOcctShape;
    private handleOcctShapes;
    private handleJscadMesh;
    private applyGlobalSettingsAndMetadataAndShadowCasting;
  }
  declare class Color {
    private readonly math;
    constructor(math: MathBitByBit);
    /**
     * Creates and returns a hex color string (pass-through for color input).
     * Example: '#FF5733'  '#FF5733'
     * @param inputs Color hex
     * @returns color string
     * @group create
     * @shortname color
     * @drawable false
     */
    hexColor(inputs: Inputs.Color.HexDto): Inputs.Base.Color;
    /**
     * Converts hex color to RGB object with r, g, b values (0-255 range).
     * Example: '#FF5733'  {r: 255, g: 87, b: 51}
     * @param inputs Color hex
     * @returns rgb color
     * @group convert
     * @shortname hex to rgb
     * @drawable false
     */
    hexToRgb(inputs: Inputs.Color.HexDto): Inputs.Base.ColorRGB;
    /**
     * Converts RGB values to hex color string (supports custom min/max ranges, auto-remaps to 0-255).
     * Example: r=255, g=87, b=51 with range [0,255]  '#ff5733'
     * Example: r=1, g=0.5, b=0.2 with range [0,1]  '#ff7f33'
     * @param inputs Color hext
     * @returns hex color
     * @group convert
     * @shortname rgb to hex
     * @drawable false
     */
    rgbToHex(inputs: Inputs.Color.RGBMinMaxDto): Inputs.Base.Color;
    /**
     * Converts RGB object to hex color string (supports custom min/max ranges).
     * Example: {r: 1, g: 0.5, b: 0.2} with range [0,1]  '#ff7f33'
     * @param inputs Color hext
     * @returns hex color string
     * @group convert
     * @shortname rgb obj to hex
     * @drawable false
     */
    rgbObjToHex(inputs: Inputs.Color.RGBObjectMaxDto): Inputs.Base.Color;
    /**
     * Converts hex color to RGB and remaps values to a custom range.
     * Example: '#FF5733' mapped to [0,1]  {r: 1, g: 0.341, b: 0.2}
     * Example: '#FF5733' mapped to [0,100]  {r: 100, g: 34.1, b: 20}
     * @param inputs Color hext
     * @returns rgb color
     * @group convert
     * @shortname hex to rgb mapped
     * @drawable false
     */
    hexToRgbMapped(inputs: Inputs.Color.HexDtoMapped): Inputs.Base.ColorRGB;
    /**
     * Extracts the red channel value from hex color (can be mapped to custom range).
     * Example: '#FF5733' with range [0,1]  1
     * @param inputs Color hext
     * @returns rgb color
     * @group hex to
     * @shortname red
     * @drawable false
     */
    getRedParam(inputs: Inputs.Color.HexDtoMapped): number;
    /**
     * Extracts the green channel value from hex color (can be mapped to custom range).
     * Example: '#FF5733' with range [0,1]  0.341
     * @param inputs Color hext
     * @returns rgb color
     * @group hex to
     * @shortname green
     * @drawable false
     */
    getGreenParam(inputs: Inputs.Color.HexDtoMapped): number;
    /**
     * Extracts the blue channel value from hex color (can be mapped to custom range).
     * Example: '#FF5733' with range [0,1]  0.2
     * @param inputs Color hext
     * @returns blue param
     * @group hex to
     * @shortname blue
     * @drawable false
     */
    getBlueParam(inputs: Inputs.Color.HexDtoMapped): number;
    /**
     * Extracts the red channel value from RGB object.
     * Example: {r: 255, g: 87, b: 51}  255
     * @param inputs Color rgb
     * @returns red param
     * @group  rgb to
     * @shortname red
     * @drawable false
     */
    rgbToRed(inputs: Inputs.Color.RGBObjectDto): number;
    /**
     * Extracts the green channel value from RGB object.
     * Example: {r: 255, g: 87, b: 51}  87
     * @param inputs Color rgb
     * @returns green param
     * @group rgb to
     * @shortname green
     * @drawable false
     */
    rgbToGreen(inputs: Inputs.Color.RGBObjectDto): number;
    /**
     * Extracts the blue channel value from RGB object.
     * Example: {r: 255, g: 87, b: 51}  51
     * @param inputs Color rgb
     * @returns blue param
     * @group rgb to
     * @shortname blue
     * @drawable false
     */
    rgbToBlue(inputs: Inputs.Color.RGBObjectDto): number;
    /**
     * Inverts a hex color (flips RGB channels: 255-r, 255-g, 255-b).
     * With blackAndWhite=true  returns '#000000' or '#ffffff' based on brightness.
     * Example: '#FF5733'  '#00a8cc', '#FF5733' with blackAndWhite=true  '#ffffff'
     * @param inputs hex color and black and white option
     * @returns inverted color
     * @group hex to
     * @shortname invert color
     * @drawable false
     */
    invert(inputs: Inputs.Color.InvertHexDto): Inputs.Base.Color;
  }
  /**
   * Contains various date methods.
   */
  declare class Dates {
    /**
     * Converts date to human-readable date string (excludes time).
     * Example: Date(2024,0,15,14,30)  'Mon Jan 15 2024'
     * @param inputs a date
     * @returns date as string
     * @group convert
     * @shortname date to string
     * @drawable false
     */
    toDateString(inputs: Inputs.Dates.DateDto): string;
    /**
     * Converts date to ISO 8601 format string (standard format for APIs and data interchange).
     * Example: Date(2024,0,15,14,30,45)  '2024-01-15T14:30:45.000Z'
     * @param inputs a date
     * @returns date as string
     * @group convert
     * @shortname date to iso string
     * @drawable false
     */
    toISOString(inputs: Inputs.Dates.DateDto): string;
    /**
     * Converts date to JSON-compatible string (same as ISO format, used in JSON.stringify).
     * Example: Date(2024,0,15,14,30)  '2024-01-15T14:30:00.000Z'
     * @param inputs a date
     * @returns date as string
     * @group convert
     * @shortname date to json
     * @drawable false
     */
    toJSON(inputs: Inputs.Dates.DateDto): string;
    /**
     * Converts date to full locale-specific string (includes date, time, and timezone).
     * Example: Date(2024,0,15,14,30)  'Mon Jan 15 2024 14:30:00 GMT+0000'
     * @param inputs a date
     * @returns date as string
     * @group convert
     * @shortname date to locale string
     * @drawable false
     */
    toString(inputs: Inputs.Dates.DateDto): string;
    /**
     * Converts date to time string (excludes date, includes timezone).
     * Example: Date(2024,0,15,14,30,45)  '14:30:45 GMT+0000'
     * @param inputs a date
     * @returns time as string
     * @group convert
     * @shortname date to time string
     * @drawable false
     */
    toTimeString(inputs: Inputs.Dates.DateDto): string;
    /**
     * Converts date to UTC string format (Universal Coordinated Time, no timezone offset).
     * Example: Date(2024,0,15,14,30)  'Mon, 15 Jan 2024 14:30:00 GMT'
     * @param inputs a date
     * @returns date as utc string
     * @group convert
     * @shortname date to utc string
     * @drawable false
     */
    toUTCString(inputs: Inputs.Dates.DateDto): string;
    /**
     * Returns the current date and time at the moment of execution.
     * Example: calling now()  Date object representing current moment (e.g., '2024-01-15T14:30:45')
     * @returns date
     * @group create
     * @shortname now
     * @drawable false
     */
    now(): Date;
    /**
     * Creates a new date from individual components using local time.
     * Month is 0-indexed: 0=January, 11=December.
     * Example: year=2024, month=0, day=15, hours=14, minutes=30  Date(Jan 15, 2024 14:30)
     * @param inputs a date
     * @returns date
     * @group create
     * @shortname create date
     * @drawable false
     */
    createDate(inputs: Inputs.Dates.CreateDateDto): Date;
    /**
     * Creates a new date from individual components using UTC (ignores timezone).
     * Returns milliseconds since Unix epoch (Jan 1, 1970 00:00:00 UTC).
     * Example: year=2024, month=0, day=15  Date representing Jan 15, 2024 00:00 UTC
     * @param inputs a date
     * @returns date
     * @group create
     * @shortname create utc date
     * @drawable false
     */
    createDateUTC(inputs: Inputs.Dates.CreateDateDto): Date;
    /**
     * Creates a date from Unix timestamp (milliseconds since Jan 1, 1970 UTC).
     * Example: unixTimeStamp=1705329000000  Date(Jan 15, 2024 14:30:00)
     * @param inputs a unix time stamp
     * @returns date
     * @group create
     * @shortname create from unix timestamp
     * @drawable false
     */
    createFromUnixTimeStamp(
      inputs: Inputs.Dates.CreateFromUnixTimeStampDto
    ): Date;
    /**
     * Parses a date string and returns Unix timestamp (milliseconds since Jan 1, 1970 UTC).
     * Example: dateString='2024-01-15'  1705276800000
     * @param inputs a date string
     * @returns the number of milliseconds between that date and midnight, January 1, 1970.
     * @group parse
     * @shortname parse date string
     * @drawable false
     */
    parseDate(inputs: Inputs.Dates.DateStringDto): number;
    /**
     * Extracts day of the month from date (1-31) using local time.
     * Example: Date(2024,0,15)  15
     * @returns date
     * @group get
     * @shortname get date of month
     * @drawable false
     */
    getDayOfMonth(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts day of the week from date (0=Sunday, 6=Saturday) using local time.
     * Example: Date(2024,0,15)  1 (Monday)
     * @returns day
     * @group get
     * @shortname get weekday
     * @drawable false
     */
    getWeekday(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts full year from date using local time.
     * Example: Date(2024,0,15)  2024
     * @returns year
     * @group get
     * @shortname get year
     * @drawable false
     */
    getYear(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts month from date (0=January, 11=December) using local time.
     * Example: Date(2024,0,15)  0 (January)
     * @returns month
     * @group get
     * @shortname get month
     * @drawable false
     */
    getMonth(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts hours from date (0-23) using local time.
     * Example: Date(2024,0,15,14,30)  14
     * @returns hours
     * @group get
     * @shortname get hours
     * @drawable false
     */
    getHours(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts minutes from date (0-59) using local time.
     * Example: Date(2024,0,15,14,30)  30
     * @returns minutes
     * @group get
     * @shortname get minutes
     * @drawable false
     */
    getMinutes(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts seconds from date (0-59) using local time.
     * Example: Date(2024,0,15,14,30,45)  45
     * @returns seconds
     * @group get
     * @shortname get seconds
     * @drawable false
     */
    getSeconds(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts milliseconds from date (0-999) using local time.
     * Example: Date(2024,0,15,14,30,45,123)  123
     * @returns milliseconds
     * @group get
     * @shortname get milliseconds
     * @drawable false
     */
    getMilliseconds(inputs: Inputs.Dates.DateDto): number;
    /**
     * Converts date to Unix timestamp (milliseconds since Jan 1, 1970 UTC).
     * Example: Date(2024,0,15,14,30)  1705329000000
     * @returns time
     * @group get
     * @shortname get time
     * @drawable false
     */
    getTime(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts full year from date using UTC (ignores timezone).
     * Example: Date(2024,0,15)  2024
     * @returns year
     * @group get
     * @shortname get utc year
     * @drawable false
     */
    getUTCYear(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts month from date (0=January, 11=December) using UTC.
     * Example: Date.UTC(2024,0,15)  0 (January)
     * @returns month
     * @group get
     * @shortname get utc month
     * @drawable false
     */
    getUTCMonth(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts day of the month from date (1-31) using UTC.
     * Example: Date.UTC(2024,0,15)  15
     * @returns day
     * @group get
     * @shortname get utc day
     * @drawable false
     */
    getUTCDay(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts hours from date (0-23) using UTC.
     * Example: Date.UTC(2024,0,15,14)  14
     * @returns hours
     * @group get
     * @shortname get utc hours
     * @drawable false
     */
    getUTCHours(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts minutes from date (0-59) using UTC.
     * Example: Date.UTC(2024,0,15,14,30)  30
     * @returns minutes
     * @group get
     * @shortname get utc minutes
     * @drawable false
     */
    getUTCMinutes(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts seconds from date (0-59) using UTC.
     * Example: Date.UTC(2024,0,15,14,30,45)  45
     * @returns seconds
     * @group get
     * @shortname get utc seconds
     * @drawable false
     */
    getUTCSeconds(inputs: Inputs.Dates.DateDto): number;
    /**
     * Extracts milliseconds from date (0-999) using UTC.
     * Example: Date.UTC(2024,0,15,14,30,45,123)  123
     * @returns milliseconds
     * @group get
     * @shortname get utc milliseconds
     * @drawable false
     */
    getUTCMilliseconds(inputs: Inputs.Dates.DateDto): number;
    /**
     * Creates new date with modified year (returns new date, original unchanged).
     * Example: Date(2024,0,15) with year=2025  Date(2025,0,15)
     * @param inputs a date and the year
     * @returns date
     * @group set
     * @shortname set year
     * @drawable false
     * */
    setYear(inputs: Inputs.Dates.DateYearDto): Date;
    /**
     * Creates new date with modified month (0=January, 11=December, returns new date).
     * Example: Date(2024,0,15) with month=5  Date(2024,5,15) (June 15)
     * @param inputs a date and the month
     * @returns date
     * @group set
     * @shortname set month
     * @drawable false
     * */
    setMonth(inputs: Inputs.Dates.DateMonthDto): Date;
    /**
     * Creates new date with modified day of month (1-31, returns new date).
     * Example: Date(2024,0,15) with day=20  Date(2024,0,20)
     * @param inputs a date and the day
     * @returns date
     * @group set
     * @shortname set day of month
     * @drawable false
     */
    setDayOfMonth(inputs: Inputs.Dates.DateDayDto): Date;
    /**
     * Sets the hour value in the Date object using local time.
     * @param inputs a date and the hours
     * @returns date
     * @group set
     * @shortname set hours
     * @drawable false
     * */
    setHours(inputs: Inputs.Dates.DateHoursDto): Date;
    /**
     * Sets the minutes value in the Date object using local time.
     * @param inputs a date and the minutes
     * @returns date
     * @group set
     * @shortname set minutes
     * @drawable false
     * */
    setMinutes(inputs: Inputs.Dates.DateMinutesDto): Date;
    /**
     * Sets the seconds value in the Date object using local time.
     * @param inputs a date and the seconds
     * @returns date
     * @group set
     * @shortname set seconds
     * @drawable false
     */
    setSeconds(inputs: Inputs.Dates.DateSecondsDto): Date;
    /**
     * Sets the milliseconds value in the Date object using local time.
     * @param inputs a date and the milliseconds
     * @returns date
     * @group set
     * @shortname set milliseconds
     * @drawable false
     */
    setMilliseconds(inputs: Inputs.Dates.DateMillisecondsDto): Date;
    /**
     * Sets the date and time value in the Date object.
     * @param inputs a date and the time
     * @returns date
     * @group set
     * @shortname set time
     * @drawable false
     */
    setTime(inputs: Inputs.Dates.DateTimeDto): Date;
    /**
     * Sets the year value in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the year
     * @returns date
     * @group set
     * @shortname set utc year
     * @drawable false
     * */
    setUTCYear(inputs: Inputs.Dates.DateYearDto): Date;
    /**
     * Sets the month value in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the month
     * @returns date
     * @group set
     * @shortname set utc month
     * @drawable false
     * */
    setUTCMonth(inputs: Inputs.Dates.DateMonthDto): Date;
    /**
     * Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the day
     * @returns date
     * @group set
     * @shortname set utc day
     * @drawable false
     */
    setUTCDay(inputs: Inputs.Dates.DateDayDto): Date;
    /**
     * Sets the hours value in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the hours
     * @returns date
     * @group set
     * @shortname set utc hours
     * @drawable false
     * */
    setUTCHours(inputs: Inputs.Dates.DateHoursDto): Date;
    /**
     * Sets the minutes value in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the minutes
     * @returns date
     * @group set
     * @shortname set utc minutes
     * @drawable false
     * */
    setUTCMinutes(inputs: Inputs.Dates.DateMinutesDto): Date;
    /**
     * Sets the seconds value in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the seconds
     * @returns date
     * @group set
     * @shortname set utc seconds
     * @drawable false
     */
    setUTCSeconds(inputs: Inputs.Dates.DateSecondsDto): Date;
    /**
     * Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).
     * @param inputs a date and the milliseconds
     * @returns date
     * @group set
     * @shortname set utc milliseconds
     * @drawable false
     */
    setUTCMilliseconds(inputs: Inputs.Dates.DateMillisecondsDto): Date;
  }
  declare class GeometryHelper {
    /**
     * Applies one or more 44 transformation matrices to a list of points sequentially.
     * Each transformation is applied in order (composition of transformations).
     * Example: points=[[0,0,0], [1,0,0]] with translation [5,0,0]  [[5,0,0], [6,0,0]]
     */
    transformControlPoints(
      transformation: number[][] | number[][][],
      transformedControlPoints: Inputs.Base.Point3[]
    ): Inputs.Base.Point3[];
    /**
     * Flattens nested transformation arrays into a single-level array of transformation matrices.
     * Handles both 2D arrays (single transform list) and 3D arrays (nested transform lists).
     * Example: [[[matrix1, matrix2]], [[matrix3]]]  [matrix1, matrix2, matrix3]
     */
    getFlatTransformations(
      transformation: number[][] | number[][][]
    ): number[][];
    /**
     * Calculates the nesting depth of an array recursively.
     * Example: [1,2,3]  1, [[1,2],[3,4]]  2, [[[1]]]  3
     */
    getArrayDepth: (value: any) => number;
    /**
     * Applies a single 44 transformation matrix (as flat 16-element array) to multiple points.
     * Example: points=[[0,0,0], [1,0,0]] with translation matrix  transformed points
     */
    transformPointsByMatrixArray(
      points: Inputs.Base.Point3[],
      transform: number[]
    ): Inputs.Base.Point3[];
    /**
     * Transforms multiple points using a transformation matrix (maps each point through the matrix).
     * Example: points=[[1,0,0], [0,1,0]] with 90 rotation  [[0,1,0], [-1,0,0]]
     */
    transformPointsCoordinates(
      points: Inputs.Base.Point3[],
      transform: number[]
    ): Inputs.Base.Point3[];
    /**
     * Removes all duplicate vectors from a list (works with arbitrary-length numeric vectors).
     * Compares vectors using tolerance for floating-point equality.
     * Example: [[1,2], [3,4], [1,2], [5,6]] with tolerance=1e-7  [[1,2], [3,4], [5,6]]
     */
    removeAllDuplicateVectors(
      vectors: number[][],
      tolerance?: number
    ): number[][];
    /**
     * Removes consecutive duplicate vectors from a list (keeps only first occurrence in each sequence).
     * Optionally checks and removes duplicate if first and last vectors match.
     * Example: [[1,2], [1,2], [3,4], [3,4], [5,6]]  [[1,2], [3,4], [5,6]]
     */
    removeConsecutiveVectorDuplicates(
      vectors: number[][],
      checkFirstAndLast?: boolean,
      tolerance?: number
    ): number[][];
    /**
     * Compares two vectors for approximate equality using tolerance (element-wise comparison).
     * Returns false if vectors have different lengths.
     * Example: [1.0000001, 2.0], [1.0, 2.0] with tolerance=1e-6  true
     */
    vectorsTheSame(vec1: number[], vec2: number[], tolerance: number): boolean;
    /**
     * Checks if two numbers are approximately equal within a tolerance.
     * Example: 1.0000001, 1.0 with tolerance=1e-6  true, 1.001, 1.0 with tolerance=1e-6  false
     */
    approxEq(num1: number, num2: number, tolerance: number): boolean;
    /**
     * Removes consecutive duplicate points from a list (specialized for 3D/2D points).
     * Optionally checks and removes duplicate if first and last points match (for closed loops).
     * Example: [[0,0,0], [0,0,0], [1,0,0], [1,0,0]]  [[0,0,0], [1,0,0]]
     */
    removeConsecutivePointDuplicates(
      points: Inputs.Base.Point3[],
      checkFirstAndLast?: boolean,
      tolerance?: number
    ): Inputs.Base.Point3[];
    /**
     * Checks if two points are approximately equal using tolerance (supports 2D and 3D points).
     * Example: [1.0000001, 2.0, 3.0], [1.0, 2.0, 3.0] with tolerance=1e-6  true
     */
    arePointsTheSame(
      pointA: Inputs.Base.Point3 | Inputs.Base.Point2,
      pointB: Inputs.Base.Point3 | Inputs.Base.Point2,
      tolerance: number
    ): boolean;
    private transformCoordinates;
  }
  declare class DxfGenerator {
    private entityHandle;
    private colorFormat;
    private acadVersion;
    /**
     * Generate a complete DXF file content from path-based entities
     */
    generateDxf(dxfInputs: Inputs.IO.DxfModelDto): string;
    /**
     * Generate DXF header section
     */
    private generateHeader;
    /**
     * Generate DXF tables section (layers, line types, etc.)
     */
    private generateTables;
    /**
     * Generate line type table
     */
    private generateLineTypeTable;
    /**
     * Generate text style table
     */
    private generateStyleTable;
    /**
     * Generate VPORT table (viewport configuration)
     */
    private generateVportTable;
    /**
     * Generate VIEW table (empty but required for AC1009)
     */
    private generateViewTable;
    /**
     * Generate UCS table (user coordinate system - empty but required for AC1009)
     */
    private generateUcsTable;
    /**
     * Generate APPID table (application ID - required for AC1009)
     */
    private generateAppidTable;
    /**
     * Generate DIMSTYLE table (dimension style - empty but required for AC1009)
     */
    private generateDimstyleTable;
    /**
     * Generate blocks section (empty but required)
     */
    private generateBlocks;
    /**
     * Generate layer table based on unique layers in all parts
     */
    private generateLayerTable;
    /**
     * Generate DXF entities section with all path segments
     */
    private generateEntities;
    /**
     * Generate entity for a single segment based on its type
     */
    private generateSegmentEntity;
    /**
     * Type guard for line segments
     */
    private isLineSegment;
    /**
     * Type guard for arc segments
     */
    private isArcSegment;
    /**
     * Type guard for circle segments
     */
    private isCircleSegment;
    /**
     * Type guard for polyline segments
     */
    private isPolylineSegment;
    /**
     * Type guard for spline segments
     */
    private isSplineSegment;
    /**
     * Generate a LINE entity
     */
    private generateLineEntity;
    /**
     * Generate a CIRCLE entity
     */
    private generateCircleEntity;
    /**
     * Generate an ARC entity
     */
    private generateArcEntity;
    /**
     * Generate a LWPOLYLINE entity
     */
    private generatePolylineEntity;
    /**
     * Generate a SPLINE entity
     */
    private generateSplineEntity;
    /**
     * Check if polyline should be closed (first and last points are the same)
     */
    private isClosedPolyline;
    /**
     * Get next entity handle as hex string
     */
    private getNextHandle;
    /**
     * Convert color to DXF format
     * Accepts hex color (#RRGGBB) or ACI color index (1-255)
     * Returns appropriate DXF color codes based on colorFormat setting
     */
    private convertColorToDxf;
    /**
     * Convert RGB values to nearest AutoCAD Color Index (ACI)
     * Uses a simplified mapping to standard ACI colors
     */
    private rgbToAciColorIndex;
  }
  declare class Dxf {
    private dxfGenerator;
    /**
     * Creates a line segment definition for DXF (pass-through for validation).
     * Example: start=[0,0], end=[10,5]  DXF line segment from origin to [10,5]
     * @param inputs Line segment definition
     * @returns Line segment DTO
     * @group dxf
     * @shortname line segment
     * @drawable false
     */
    lineSegment(
      inputs: Inputs.IO.DxfLineSegmentDto
    ): Inputs.IO.DxfLineSegmentDto;
    /**
     * Creates an arc segment definition for DXF (curved path between two points).
     * Example: center=[5,5], radius=5, startAngle=0, endAngle=90  quarter circle arc
     * @param inputs Arc segment definition
     * @returns Arc segment DTO
     * @group dxf
     * @shortname arc segment
     * @drawable false
     */
    arcSegment(inputs: Inputs.IO.DxfArcSegmentDto): Inputs.IO.DxfArcSegmentDto;
    /**
     * Creates a circle segment definition for DXF (closed circular path).
     * Example: center=[10,10], radius=5  full circle with diameter 10 centered at [10,10]
     * @param inputs Circle segment definition
     * @returns Circle segment DTO
     * @group dxf
     * @shortname circle segment
     * @drawable false
     */
    circleSegment(
      inputs: Inputs.IO.DxfCircleSegmentDto
    ): Inputs.IO.DxfCircleSegmentDto;
    /**
     * Creates a polyline segment definition for DXF (connected line segments through points).
     * Example: points=[[0,0], [5,0], [5,5], [0,5]]  rectangular polyline path
     * @param inputs Polyline segment definition
     * @returns Polyline segment DTO
     * @group dxf
     * @shortname polyline segment
     * @drawable false
     */
    polylineSegment(
      inputs: Inputs.IO.DxfPolylineSegmentDto
    ): Inputs.IO.DxfPolylineSegmentDto;
    /**
     * Creates a spline segment definition for DXF (smooth curve through control points).
     * Example: controlPoints=[[0,0], [5,10], [10,0]]  smooth curved path through points
     * @param inputs Spline segment definition
     * @returns Spline segment DTO
     * @group dxf
     * @shortname spline segment
     * @drawable false
     */
    splineSegment(
      inputs: Inputs.IO.DxfSplineSegmentDto
    ): Inputs.IO.DxfSplineSegmentDto;
    /**
     * Creates a path from multiple segments (combines lines, arcs, circles, polylines, splines).
     * Similar to OCCT wires - segments are connected to form a continuous or multi-part path.
     * Example: segments=[lineSegment, arcSegment, polylineSegment]  combined path entity
     * @param inputs Path definition with segments
     * @returns Path DTO
     * @group dxf
     * @shortname path
     * @drawable false
     */
    path(inputs: Inputs.IO.DxfPathDto): Inputs.IO.DxfPathDto;
    /**
     * Creates a paths part with layer and color assignment for DXF organization.
     * Groups multiple paths into a single layer with consistent styling.
     * Example: paths=[path1, path2], layer="Outlines", color=red  grouped geometry
     * @param inputs Paths part definition
     * @returns Paths part DTO
     * @group dxf
     * @shortname paths part
     * @drawable false
     */
    pathsPart(inputs: Inputs.IO.DxfPathsPartDto): Inputs.IO.DxfPathsPartDto;
    /**
     * Generates a complete DXF file from paths parts (exports 2D CAD drawing format).
     * Supports lines, arcs, circles, polylines, and splines organized in layered paths.
     * Example: model with 3 parts on different layers  valid DXF file string for CAD software
     * @param inputs DXF model definition
     * @returns DXF file content as string
     * @group dxf
     * @shortname dxf create
     * @drawable false
     */
    dxfCreate(inputs: Inputs.IO.DxfModelDto): string;
  }
  declare class IoBitByBit {
    dxf: Dxf;
    constructor();
  }
  /**
   * Contains various methods for lines and segments. Line in bitbybit is a simple object that has start and end point properties.
   * { start: [ x, y, z ], end: [ x, y, z ] }
   */
  declare class Line {
    private readonly vector;
    private readonly point;
    private readonly geometryHelper;
    constructor(vector: Vector, point: Point, geometryHelper: GeometryHelper);
    /**
     * Extracts start point from a line.
     * Example: line={start:[0,0,0], end:[10,5,0]}  [0,0,0]
     * @param inputs a line
     * @returns start point
     * @group get
     * @shortname line start point
     * @drawable true
     */
    getStartPoint(inputs: Inputs.Line.LineDto): Inputs.Base.Point3;
    /**
     * Extracts end point from a line.
     * Example: line={start:[0,0,0], end:[10,5,0]}  [10,5,0]
     * @param inputs a line
     * @returns end point
     * @group get
     * @shortname line end point
     * @drawable true
     */
    getEndPoint(inputs: Inputs.Line.LineDto): Inputs.Base.Point3;
    /**
     * Calculates length (distance) of a line segment.
     * Example: line={start:[0,0,0], end:[3,4,0]}  5 (using Pythagorean theorem)
     * @param inputs a line
     * @returns line length
     * @group get
     * @shortname line length
     * @drawable false
     */
    length(inputs: Inputs.Line.LineDto): number;
    /**
     * Reverses line direction by swapping start and end points.
     * Example: line={start:[0,0,0], end:[10,5,0]}  {start:[10,5,0], end:[0,0,0]}
     * @param inputs a line
     * @returns reversed line
     * @group operations
     * @shortname reversed line
     * @drawable true
     */
    reverse(inputs: Inputs.Line.LineDto): Inputs.Base.Line3;
    /**
     * Applies transformation matrix to line (rotates, scales, or translates both endpoints).
     * Example: line={start:[0,0,0], end:[10,0,0]} with translation [5,5,0]  {start:[5,5,0], end:[15,5,0]}
     * @param inputs a line
     * @returns transformed line
     * @group transforms
     * @shortname transform line
     * @drawable true
     */
    transformLine(inputs: Inputs.Line.TransformLineDto): Inputs.Base.Line3;
    /**
     * Applies multiple transformations to multiple lines (one transform per line).
     * Example: 3 lines with 3 different translation matrices  each line moved independently
     * @param inputs lines
     * @returns transformed lines
     * @group transforms
     * @shortname transform lines
     * @drawable true
     */
    transformsForLines(
      inputs: Inputs.Line.TransformsLinesDto
    ): Inputs.Base.Line3[];
    /**
     * Creates a line from two points (line object with start and end properties).
     * Example: start=[0,0,0], end=[10,5,0]  {start:[0,0,0], end:[10,5,0]}
     * @param inputs start and end points of the line
     * @returns line
     * @group create
     * @shortname line
     * @drawable true
     */
    create(inputs: Inputs.Line.LinePointsDto): Inputs.Base.Line3;
    /**
     * Creates a segment from two points (array format: [start, end]).
     * Example: start=[0,0,0], end=[10,5,0]  [[0,0,0], [10,5,0]]
     * @param inputs start and end points of the segment
     * @returns segment
     * @group create
     * @shortname segment
     * @drawable true
     */
    createSegment(inputs: Inputs.Line.LinePointsDto): Inputs.Base.Segment3;
    /**
     * Calculates point at parameter t along line segment (0=start, 1=end, linear interpolation).
     * Example: line={start:[0,0,0], end:[10,0,0]}, param=0.5  [5,0,0] (midpoint)
     * @param inputs line
     * @returns point on line
     * @group get
     * @shortname point on line
     * @drawable true
     */
    getPointOnLine(inputs: Inputs.Line.PointOnLineDto): Inputs.Base.Point3;
    /**
     * Creates line segments connecting consecutive points in a list (forms a polyline path).
     * Example: points=[[0,0,0], [5,0,0], [5,5,0]]  2 lines: [05] and [55,5]
     * @param inputs points
     * @returns lines
     * @group create
     * @shortname lines between points
     * @drawable true
     */
    linesBetweenPoints(inputs: Inputs.Line.PointsLinesDto): Inputs.Base.Line3[];
    /**
     * Creates lines by pairing corresponding start and end points from two arrays.
     * Filters out zero-length lines.
     * Example: starts=[[0,0,0], [5,0,0]], ends=[[0,5,0], [5,5,0]]  2 lines connecting paired points
     * @param inputs start points and end points
     * @returns lines
     * @group create
     * @shortname start and end points to lines
     * @drawable true
     */
    linesBetweenStartAndEndPoints(
      inputs: Inputs.Line.LineStartEndPointsDto
    ): Inputs.Base.Line3[];
    /**
     * Converts line object to segment array format.
     * Example: {start:[0,0,0], end:[10,5,0]}  [[0,0,0], [10,5,0]]
     * @param inputs line
     * @returns segment
     * @group convert
     * @shortname line to segment
     * @drawable false
     */
    lineToSegment(inputs: Inputs.Line.LineDto): Inputs.Base.Segment3;
    /**
     * Converts multiple line objects to segment array format (batch conversion).
     * Example: 3 line objects  3 segment arrays [[start1, end1], [start2, end2], ...]
     * @param inputs lines
     * @returns segments
     * @group convert
     * @shortname lines to segments
     * @drawable false
     */
    linesToSegments(inputs: Inputs.Line.LinesDto): Inputs.Base.Segment3[];
    /**
     * Converts segment array to line object format.
     * Example: [[0,0,0], [10,5,0]]  {start:[0,0,0], end:[10,5,0]}
     * @param inputs segment
     * @returns line
     * @group convert
     * @shortname segment to line
     * @drawable true
     */
    segmentToLine(inputs: Inputs.Line.SegmentDto): Inputs.Base.Line3;
    /**
     * Converts multiple segment arrays to line object format (batch conversion).
     * Example: 3 segment arrays  3 line objects with start/end properties
     * @param inputs segments
     * @returns lines
     * @group convert
     * @shortname segments to lines
     * @drawable true
     */
    segmentsToLines(inputs: Inputs.Line.SegmentsDto): Inputs.Base.Line3[];
    /**
     * Calculates intersection point of two lines (or segments if checkSegmentsOnly=true).
     * Returns undefined if lines are parallel, skew, or segments don't overlap.
     * Example: line1={start:[0,0,0], end:[10,0,0]}, line2={start:[5,-5,0], end:[5,5,0]}  [5,0,0]
     * @param inputs line1 and line2
     * @returns intersection point or undefined if no intersection
     * @group intersection
     * @shortname line-line int
     * @drawable true
     */
    lineLineIntersection(
      inputs: Inputs.Line.LineLineIntersectionDto
    ): Inputs.Base.Point3 | undefined;
  }
  /**
   * Contains various list methods.
   */
  declare class Lists {
    /**
     * Gets an item from the list at a specific position using zero-based indexing.
     * Example: From [10, 20, 30, 40], getting index 2 returns 30
     * @param inputs a list and an index
     * @returns item
     * @group get
     * @shortname item by index
     * @drawable false
     */
    getItem<T>(inputs: Inputs.Lists.ListItemDto<T>): T;
    /**
     * Gets the first item from the list.
     * Example: From [10, 20, 30, 40], returns 10
     * @param inputs a list
     * @returns first item
     * @group get
     * @shortname first item
     * @drawable false
     */
    getFirstItem<T>(inputs: Inputs.Lists.ListCloneDto<T>): T;
    /**
     * Gets the last item from the list.
     * Example: From [10, 20, 30, 40], returns 40
     * @param inputs a list
     * @returns last item
     * @group get
     * @shortname last item
     * @drawable false
     */
    getLastItem<T>(inputs: Inputs.Lists.ListCloneDto<T>): T;
    /**
     * Randomly keeps items from the list based on a probability threshold (0 to 1).
     * Example: From [1, 2, 3, 4, 5] with threshold 0.5, might return [1, 3, 5] (50% chance for each item)
     * @param inputs a list and a threshold for randomization of items to remove
     * @returns list with remaining items
     * @group get
     * @shortname random get threshold
     * @drawable false
     */
    randomGetThreshold<T>(inputs: Inputs.Lists.RandomThresholdDto<T>): T[];
    /**
     * Extracts a portion of the list between start and end positions (end is exclusive).
     * Example: From [10, 20, 30, 40, 50] with start=1 and end=4, returns [20, 30, 40]
     * @param inputs a list and start and end indexes
     * @returns sub list
     * @group get
     * @shortname sublist
     * @drawable false
     */
    getSubList<T>(inputs: Inputs.Lists.SubListDto<T>): T[];
    /**
     * Gets every nth item from the list, starting from an optional offset position.
     * Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with nth=3 and offset=0, returns [0, 3, 6]
     * Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with nth=2 and offset=1, returns [1, 3, 5, 7]
     * @param inputs a list and index
     * @returns list with filtered items
     * @group get
     * @shortname every n-th
     * @drawable false
     */
    getNthItem<T>(inputs: Inputs.Lists.GetNthItemDto<T>): T[];
    /**
     * Filters items from the list using a repeating true/false pattern.
     * Example: From [0, 1, 2, 3, 4, 5] with pattern [true, true, false], returns [0, 1, 3, 4] (keeps items where pattern is true)
     * @param inputs a list and index
     * @returns list with filtered items
     * @group get
     * @shortname by pattern
     * @drawable false
     */
    getByPattern<T>(inputs: Inputs.Lists.GetByPatternDto<T>): T[];
    /**
     * Merges elements from multiple lists at a specific nesting level, grouping elements by position.
     * Example: From [[0, 1, 2], [3, 4, 5]] at level 0, returns [[0, 3], [1, 4], [2, 5]]
     * @param inputs lists, level and flatten data
     * @returns list with merged lists and flattened lists
     * @group get
     * @shortname merge levels
     * @drawable false
     */
    mergeElementsOfLists<T>(
      inputs: Inputs.Lists.MergeElementsOfLists<T[]>
    ): T[];
    /**
     * Finds the length of the longest list among multiple lists.
     * Example: From [[1, 2], [3, 4, 5, 6], [7]], returns 4 (length of [3, 4, 5, 6])
     * @param inputs a list of lists
     * @returns number of max length
     * @group get
     * @shortname longest list length
     * @drawable false
     */
    getLongestListLength<T>(
      inputs: Inputs.Lists.GetLongestListLength<T[]>
    ): number;
    /**
     * Reverses the order of items in the list.
     * Example: From [1, 2, 3, 4, 5], returns [5, 4, 3, 2, 1]
     * @param inputs a list and an index
     * @returns item
     * @group edit
     * @shortname reverse
     * @drawable false
     */
    reverse<T>(inputs: Inputs.Lists.ListCloneDto<T>): T[];
    /**
     * Randomly rearranges all items in the list (using Fisher-Yates algorithm).
     * Example: From [1, 2, 3, 4, 5], might return [3, 1, 5, 2, 4] (order varies each time)
     * @param inputs a list
     * @returns shuffled list
     * @group edit
     * @shortname shuffle
     * @drawable false
     */
    shuffle<T>(inputs: Inputs.Lists.ListCloneDto<T>): T[];
    /**
     * Transposes a 2D list by swapping rows and columns (all sublists must be equal length).
     * Example: From [[0, 1, 2], [3, 4, 5]], returns [[0, 3], [1, 4], [2, 5]]
     * @param inputs a list of lists to flip
     * @returns item
     * @group edit
     * @shortname flip lists
     * @drawable false
     */
    flipLists<T>(inputs: Inputs.Lists.ListCloneDto<T[]>): T[][];
    /**
     * Splits the list into smaller lists of n elements each.
     * Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with n=3, returns [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
     * Example: From [0, 1, 2, 3, 4] with n=2 and keepRemainder=true, returns [[0, 1], [2, 3], [4]]
     * @param inputs a list
     * @returns items grouped in lists of n elements
     * @group edit
     * @shortname group elements
     * @drawable false
     */
    groupNth<T>(inputs: Inputs.Lists.GroupListDto<T>): T[][];
    /**
     * Checks whether the list contains a specific item.
     * Example: List [10, 20, 30, 40] with item 30 returns true, with item 50 returns false
     * @param inputs a list and an item
     * @returns true if item is in list
     * @group get
     * @shortname contains item
     * @drawable false
     */
    includes<T>(inputs: Inputs.Lists.IncludesDto<T>): boolean;
    /**
     * Finds the position (index) of the first occurrence of an item in the list.
     * Example: In [10, 20, 30, 20, 40], finding 20 returns 1 (first occurrence), finding 50 returns -1 (not found)
     * @param inputs a list and an item
     * @returns index of the item or -1 if not found
     * @group get
     * @shortname find index
     * @drawable false
     */
    findIndex<T>(inputs: Inputs.Lists.IncludesDto<T>): number;
    /**
     * Determines the maximum nesting level (depth) of a list structure.
     * Example: [1, 2, 3] has depth 1, [[1, 2], [3, 4]] has depth 2, [[[1]]] has depth 3
     * @param inputs a list
     * @returns number of depth
     * @group get
     * @shortname max list depth
     * @drawable false
     */
    getListDepth(inputs: Inputs.Lists.ListCloneDto<[]>): number;
    /**
     * Returns the number of items in the list.
     * Example: [10, 20, 30, 40, 50] returns 5, [] returns 0
     * @param inputs a length list
     * @returns a number
     * @group get
     * @shortname list length
     * @drawable false
     */
    listLength<T>(inputs: Inputs.Lists.ListCloneDto<T>): number;
    /**
     * Inserts an item at a specific position in the list.
     * Example: In [10, 20, 30, 40], adding 99 at index 2 gives [10, 20, 99, 30, 40]
     * @param inputs a list, item and an index
     * @returns list with added item
     * @group add
     * @shortname add item
     * @drawable false
     */
    addItemAtIndex<T>(inputs: Inputs.Lists.AddItemAtIndexDto<T>): T[];
    /**
     * Inserts the same item at multiple specified positions in the list.
     * Example: In [10, 20, 30], adding 99 at indexes [0, 2] gives [99, 10, 20, 99, 30]
     * @param inputs a list, item and an indexes
     * @returns list with added item
     * @group add
     * @shortname add item at indexes
     * @drawable false
     */
    addItemAtIndexes<T>(inputs: Inputs.Lists.AddItemAtIndexesDto<T>): T[];
    /**
     * Inserts multiple items at corresponding positions (first item at first index, second item at second index, etc.).
     * Example: In [10, 20, 30], adding items [88, 99] at indexes [1, 2] gives [10, 88, 20, 99, 30]
     * @param inputs a list, items and an indexes
     * @returns list with added items
     * @group add
     * @shortname add items
     * @drawable false
     */
    addItemsAtIndexes<T>(inputs: Inputs.Lists.AddItemsAtIndexesDto<T>): T[];
    /**
     * Removes the item at a specific position in the list.
     * Example: From [10, 20, 30, 40, 50], removing index 2 gives [10, 20, 40, 50]
     * @param inputs a list and index
     * @returns list with removed item
     * @group remove
     * @shortname remove item
     * @drawable false
     */
    removeItemAtIndex<T>(inputs: Inputs.Lists.RemoveItemAtIndexDto<T>): T[];
    /**
     * Removes the first item from the list.
     * Example: From [10, 20, 30, 40], returns [20, 30, 40]
     * @param inputs a list
     * @returns list with first item removed
     * @group remove
     * @shortname remove first item
     * @drawable false
     */
    removeFirstItem<T>(inputs: Inputs.Lists.ListCloneDto<T>): T[];
    /**
     * Removes the last item from the list.
     * Example: From [10, 20, 30, 40], returns [10, 20, 30]
     * @param inputs a list
     * @returns list with last item removed
     * @group remove
     * @shortname remove last item
     * @drawable false
     */
    removeLastItem<T>(inputs: Inputs.Lists.ListCloneDto<T>): T[];
    /**
     * Removes an item counting from the end of the list (index 0 = last item, 1 = second-to-last, etc.).
     * Example: From [10, 20, 30, 40, 50], removing index 1 from end gives [10, 20, 30, 50] (removes 40)
     * @param inputs a list and index from end
     * @returns list with removed item
     * @group remove
     * @shortname remove item from end
     * @drawable false
     */
    removeItemAtIndexFromEnd<T>(
      inputs: Inputs.Lists.RemoveItemAtIndexDto<T>
    ): T[];
    /**
     * Removes items at multiple specified positions from the list.
     * Example: From [10, 20, 30, 40, 50], removing indexes [1, 3] gives [10, 30, 50]
     * @param inputs a list and indexes
     * @returns list with removed items
     * @group remove
     * @shortname remove items
     * @drawable false
     */
    removeItemsAtIndexes<T>(
      inputs: Inputs.Lists.RemoveItemsAtIndexesDto<T>
    ): T[];
    /**
     * Clears all items from the list, resulting in an empty list.
     * Example: From [10, 20, 30, 40], returns []
     * @param inputs a list
     * @returns The length is set to 0 and same array memory object is returned
     * @group remove
     * @shortname remove all items
     * @drawable false
     */
    removeAllItems<T>(inputs: Inputs.Lists.ListDto<T>): T[];
    /**
     * Removes every nth item from the list, starting from an optional offset position.
     * Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with nth=3 and offset=0, returns [1, 2, 4, 5, 7, 8] (removes 0, 3, 6)
     * @param inputs a list and index
     * @returns list with removed item
     * @group remove
     * @shortname every n-th
     * @drawable false
     */
    removeNthItem<T>(inputs: Inputs.Lists.RemoveNthItemDto<T>): T[];
    /**
     * Randomly removes items from the list based on a probability threshold (0 to 1).
     * Example: From [1, 2, 3, 4, 5] with threshold 0.5, might return [2, 4] (50% chance to remove each item)
     * @param inputs a list and a threshold for randomization of items to remove
     * @returns list with removed items
     * @group remove
     * @shortname random remove threshold
     * @drawable false
     */
    randomRemoveThreshold<T>(inputs: Inputs.Lists.RandomThresholdDto<T>): T[];
    /**
     * Removes duplicate numbers from the list, keeping only the first occurrence of each value.
     * Example: From [1, 2, 3, 2, 4, 3, 5], returns [1, 2, 3, 4, 5]
     * @param inputs a list of numbers
     * @returns list with unique numbers
     * @group remove
     * @shortname remove duplicate numbers
     * @drawable false
     */
    removeDuplicateNumbers(
      inputs: Inputs.Lists.RemoveDuplicatesDto<number>
    ): number[];
    /**
     * Removes duplicate numbers that are within a specified tolerance range of each other.
     * Example: From [1.0, 1.001, 2.0, 2.002, 3.0] with tolerance 0.01, returns [1.0, 2.0, 3.0]
     * @param inputs a list of numbers and the tolerance
     * @returns list with unique numbers
     * @group remove
     * @shortname remove duplicates tol
     * @drawable false
     */
    removeDuplicateNumbersTolerance(
      inputs: Inputs.Lists.RemoveDuplicatesToleranceDto<number>
    ): number[];
    /**
     * Removes duplicate items from the list using strict equality comparison (works with any type).
     * Example: From ['a', 'b', 'c', 'a', 'd', 'b'], returns ['a', 'b', 'c', 'd']
     * @param inputs a list
     * @returns list with unique items
     * @group remove
     * @shortname remove duplicates
     * @drawable false
     */
    removeDuplicates<T>(inputs: Inputs.Lists.RemoveDuplicatesDto<T>): T[];
    /**
     * Appends an item to the end of the list.
     * Example: To [10, 20, 30], adding 40 gives [10, 20, 30, 40]
     * @param inputs a list and an item
     * @returns list with added item
     * @group add
     * @shortname add item to list
     * @drawable false
     */
    addItem<T>(inputs: Inputs.Lists.AddItemDto<T>): T[];
    /**
     * Adds an item to the beginning of the list.
     * Example: To [10, 20, 30], prepending 5 gives [5, 10, 20, 30]
     * @param inputs a list and an item
     * @returns list with added item
     * @group add
     * @shortname prepend item to list
     * @drawable false
     */
    prependItem<T>(inputs: Inputs.Lists.AddItemDto<T>): T[];
    /**
     * Adds an item either at the beginning or end of the list based on the position parameter.
     * Example: To [10, 20, 30], adding 5 at 'first' gives [5, 10, 20, 30], at 'last' gives [10, 20, 30, 5]
     * @param inputs a list, item and an option for first or last position
     * @returns list with added item
     * @group add
     * @shortname item at first or last
     * @drawable false
     */
    addItemFirstLast<T>(inputs: Inputs.Lists.AddItemFirstLastDto<T>): T[];
    /**
     * Combines multiple lists into a single list by joining them end-to-end.
     * Example: From [[1, 2], [3, 4], [5, 6]], returns [1, 2, 3, 4, 5, 6]
     * @param inputs lists to concatenate
     * @returns concatenated list
     * @group add
     * @shortname concatenate lists
     * @drawable false
     */
    concatenate<T>(inputs: Inputs.Lists.ConcatenateDto<T>): T[];
    /**
     * Creates a new empty list with no items.
     * Example: Returns []
     * @returns an empty array list
     * @group create
     * @shortname empty list
     * @drawable false
     */
    createEmptyList(): [];
    /**
     * Creates a new list by repeating an item a specified number of times.
     * Example: Repeating 5 three times returns [5, 5, 5]
     * @param inputs an item to multiply
     * @returns list
     * @group create
     * @shortname repeat
     * @drawable false
     */
    repeat<T>(inputs: Inputs.Lists.MultiplyItemDto<T>): T[];
    /**
     * Repeats a pattern of items cyclically until reaching a target list length.
     * Example: Pattern [1, 2, 3] with length 7 returns [1, 2, 3, 1, 2, 3, 1]
     * @param inputs a list to multiply and a length limit
     * @returns list
     * @group create
     * @shortname repeat in pattern
     * @drawable false
     */
    repeatInPattern<T>(inputs: Inputs.Lists.RepeatInPatternDto<T>): T[];
    /**
     * Sorts numbers in ascending (lowest to highest) or descending (highest to lowest) order.
     * Example: [5, 2, 8, 1, 9] ascending returns [1, 2, 5, 8, 9], descending returns [9, 8, 5, 2, 1]
     * @param inputs a list of numbers to sort and an option for ascending or descending order
     * @returns list
     * @group sorting
     * @shortname sort numbers
     * @drawable false
     */
    sortNumber(inputs: Inputs.Lists.SortDto<number>): number[];
    /**
     * Sorts text strings alphabetically in ascending (A to Z) or descending (Z to A) order.
     * Example: ['dog', 'apple', 'cat', 'banana'] ascending returns ['apple', 'banana', 'cat', 'dog']
     * @param inputs a list of texts to sort and an option for ascending or descending order
     * @returns list
     * @group sorting
     * @shortname sort texts
     * @drawable false
     */
    sortTexts(inputs: Inputs.Lists.SortDto<string>): string[];
    /**
     * Sorts objects by comparing numeric values of a specified property.
     * Example: [{age: 30}, {age: 20}, {age: 25}] sorted by 'age' ascending returns [{age: 20}, {age: 25}, {age: 30}]
     * @param inputs a list to sort, a property to sort by and an option for ascending or descending order
     * @returns list
     * @group sorting
     * @shortname sort json objects
     * @drawable false
     */
    sortByPropValue(inputs: Inputs.Lists.SortJsonDto<any>): any[];
    /**
     * Combines multiple lists by alternating elements from each list (first from list1, first from list2, second from list1, etc.).
     * Example: From [[0, 1, 2], [3, 4, 5]], returns [0, 3, 1, 4, 2, 5]
     * @param inputs Lists to interleave
     * @returns Flattened interleaved list
     * @group transform
     * @shortname interleave lists
     * @drawable false
     */
    interleave<T>(inputs: Inputs.Lists.InterleaveDto<T>): T[];
  }
  /**
   * Contains various logic methods.
   */
  declare class Logic {
    /**
     * Creates and returns a boolean value (pass-through for boolean input).
     * Example: true  true, false  false
     * @param inputs a true or false boolean
     * @returns boolean
     * @group create
     * @shortname boolean
     * @drawable false
     */
    boolean(inputs: Inputs.Logic.BooleanDto): boolean;
    /**
     * Generates a random boolean list where each value has a threshold chance of being true.
     * Example: length=5, threshold=0.7  might produce [true, true, false, true, true]
     * @param inputs a length and a threshold for randomization of true values
     * @returns booleans
     * @group create
     * @shortname random booleans
     * @drawable false
     */
    randomBooleans(inputs: Inputs.Logic.RandomBooleansDto): boolean[];
    /**
     * Converts numbers to booleans using two thresholds with gradient randomization between them.
     * Values below trueThreshold  always true, above falseThreshold  always false.
     * Between thresholds  probability gradient (closer to false threshold = higher chance of false).
     * Example: [0.1, 0.4, 0.6, 0.9] with thresholds [0.3, 0.7]  [true, gradient, gradient, false]
     * @param inputs a length and a threshold for randomization of true values
     * @returns booleans
     * @group create
     * @shortname 2 threshold random gradient
     * @drawable false
     */
    twoThresholdRandomGradient(
      inputs: Inputs.Logic.TwoThresholdRandomGradientDto
    ): boolean[];
    /**
     * Converts numbers to booleans based on a threshold (below threshold  true, above  false).
     * Can be inverted to flip the logic.
     * Example: [0.3, 0.7, 0.5] with threshold=0.6  [true, false, true]
     * @param inputs a length and a threshold for randomization of true values
     * @returns booleans
     * @group create
     * @shortname threshold boolean list
     * @drawable false
     */
    thresholdBooleanList(
      inputs: Inputs.Logic.ThresholdBooleanListDto
    ): boolean[];
    /**
     * Converts numbers to booleans using multiple range thresholds (gaps define true ranges).
     * Values within any gap range  true, outside all gaps  false. Can be inverted.
     * Example: [0.2, 0.5, 0.8] with gaps [[0.3, 0.6], [0.7, 0.9]]  [false, true, true]
     * @param inputs a length and a threshold for randomization of true values
     * @returns booleans
     * @group create
     * @shortname threshold gaps boolean list
     * @drawable false
     */
    thresholdGapsBooleanList(
      inputs: Inputs.Logic.ThresholdGapsBooleanListDto
    ): boolean[];
    /**
     * Applies NOT operator to flip a boolean value.
     * Example: true  false, false  true
     * @param inputs a true or false boolean
     * @returns boolean
     * @group edit
     * @shortname not
     * @drawable false
     */
    not(inputs: Inputs.Logic.BooleanDto): boolean;
    /**
     * Applies NOT operator to flip all boolean values in a list.
     * Example: [true, false, true]  [false, true, false]
     * @param inputs a list of true or false booleans
     * @returns booleans
     * @group edit
     * @shortname not list
     * @drawable false
     */
    notList(inputs: Inputs.Logic.BooleanListDto): boolean[];
    /**
     * Compares two values using various operators (==, !=, ===, !==, <, <=, >, >=).
     * Example: 5 > 3  true, 'hello' === 'world'  false
     * @param inputs two values to be compared
     * @returns Result of the comparison
     * @group operations
     * @shortname compare
     * @drawable false
     */
    compare<T>(inputs: Inputs.Logic.ComparisonDto<T>): boolean;
    /**
     * Conditionally passes a value through if boolean is true, otherwise returns undefined.
     * Example: value=42, boolean=true  42, value=42, boolean=false  undefined
     * @param inputs a value and a boolean value
     * @returns value or undefined
     * @group operations
     * @shortname value gate
     * @drawable false
     */
    valueGate<T>(inputs: Inputs.Logic.ValueGateDto<T>): T | undefined;
    /**
     * Returns the first defined (non-undefined) value from two options (fallback pattern).
     * Example: value1=42, value2=10  42, value1=undefined, value2=10  10
     * @param inputs two values
     * @returns value or undefined
     * @group operations
     * @shortname first defined value gate
     * @drawable false
     */
    firstDefinedValueGate<T, U>(
      inputs: Inputs.Logic.TwoValueGateDto<T, U>
    ): T | U | undefined;
  }
  /**
   * Contains various math methods.
   */
  declare class MathBitByBit {
    /**
     * Creates and returns a number value (pass-through for number input).
     * Example: Input 42  42, Input 3.14  3.14
     * @param inputs a number to be created
     * @returns number
     * @group create
     * @shortname number
     * @drawable false
     */
    number(inputs: Inputs.Math.NumberDto): number;
    /**
     * Performs basic arithmetic operations on two numbers (add, subtract, multiply, divide, power, modulus).
     * Example: 5 + 3  8, 10 % 3  1, 2 ^ 3  8
     * @param inputs two numbers and operator
     * @returns Result of math operation action
     * @group operations
     * @shortname two numbers
     * @drawable false
     */
    twoNrOperation(inputs: Inputs.Math.ActionOnTwoNumbersDto): number;
    /**
     * Calculates the remainder after division (modulus operation).
     * Example: 10 % 3  1, 17 % 5  2
     * @param inputs two numbers and operator
     * @returns Result of modulus operation
     * @group operations
     * @shortname modulus
     * @drawable false
     */
    modulus(inputs: Inputs.Math.ModulusDto): number;
    /**
     * Rounds a number to specified decimal places.
     * Example: 1.32156 with 3 decimals returns 1.322
     * @param inputs a number and decimal places
     * @returns Result of rounding
     * @group operations
     * @shortname round to decimals
     * @drawable false
     */
    roundToDecimals(inputs: Inputs.Math.RoundToDecimalsDto): number;
    /**
     * Rounds a number to specified decimal places and removes trailing zeros.
     * Example: 1.32156 with 3 decimals returns 1.322, but 1.320000001 returns 1.32, and 1.000 returns 1
     * @param inputs a number and decimal places
     * @returns Result of rounding as a number without trailing zeros
     * @group operations
     * @shortname round trim zeros
     * @drawable false
     */
    roundAndRemoveTrailingZeros(inputs: Inputs.Math.RoundToDecimalsDto): number;
    /**
     * Performs mathematical operations on a single number (absolute, negate, sqrt, trig functions, logarithms, etc.).
     * Example: sqrt(5)  2.236, abs(-3)  3, sin(/2)  1
     * @param inputs one number and operator action
     * @returns Result of math operation
     * @group operations
     * @shortname one number
     * @drawable false
     */
    oneNrOperation(inputs: Inputs.Math.ActionOnOneNumberDto): number;
    /**
     * Maps a number from one range to another range proportionally.
     * Example: 5 from [0,10] to [0,100]  50, 0.5 from [0,1] to [-10,10]  0
     * @param inputs one number and operator action
     * @returns Result of mapping
     * @group operations
     * @shortname remap
     * @drawable false
     */
    remap(inputs: Inputs.Math.RemapNumberDto): number;
    /**
     * Generates a random decimal number between 0 (inclusive) and 1 (exclusive).
     * Example: Outputs like 0.342, 0.891, or any value in [0, 1)
     * @returns A random number between 0 and 1
     * @group generate
     * @shortname random 0 - 1
     * @drawable false
     */
    random(): number;
    /**
     * Generates a random number within a specified range (low to high).
     * Example: Range [0, 10]  outputs like 3.7, 8.2, or any value between 0 and 10
     * @param inputs low and high numbers
     * @returns A random number
     * @group generate
     * @shortname random number
     * @drawable false
     */
    randomNumber(inputs: Inputs.Math.RandomNumberDto): number;
    /**
     * Generates multiple random numbers within a specified range.
     * Example: Range [0, 10] with 3 items  [2.5, 7.1, 4.8]
     * @param inputs low and high numbers
     * @returns A list of random numbers
     * @group generate
     * @shortname random numbers
     * @drawable false
     */
    randomNumbers(inputs: Inputs.Math.RandomNumbersDto): number[];
    /**
     * Returns the mathematical constant  (pi)  3.14159.
     * Example: Outputs 3.141592653589793
     * @returns A number PI
     * @group generate
     * @shortname 
     * @drawable false
     */
    pi(): number;
    /**
     * Formats a number as a string with a fixed number of decimal places (always shows trailing zeros).
     * Example: 3.14159 with 2 decimals  '3.14', 5 with 3 decimals  '5.000'
     * @param inputs a number to be rounded to decimal places
     * @returns number
     * @group operations
     * @shortname to fixed
     * @drawable false
     */
    toFixed(inputs: Inputs.Math.ToFixedDto): string;
    /**
     * Adds two numbers together.
     * Example: 5 + 3  8, -2 + 7  5
     * @param inputs two numbers
     * @returns number
     * @group basics
     * @shortname add
     * @drawable false
     */
    add(inputs: Inputs.Math.TwoNumbersDto): number;
    /**
     * Subtracts the second number from the first.
     * Example: 10 - 3  7, 5 - 8  -3
     * @param inputs two numbers
     * @returns number
     * @group basics
     * @shortname subtract
     * @drawable false
     */
    subtract(inputs: Inputs.Math.TwoNumbersDto): number;
    /**
     * Multiplies two numbers together.
     * Example: 5  3  15, -2  4  -8
     * @param inputs two numbers
     * @returns number
     * @group basics
     * @shortname multiply
     * @drawable false
     */
    multiply(inputs: Inputs.Math.TwoNumbersDto): number;
    /**
     * Divides the first number by the second.
     * Example: 10  2  5, 7  2  3.5
     * @param inputs two numbers
     * @returns number
     * @group basics
     * @shortname divide
     * @drawable false
     */
    divide(inputs: Inputs.Math.TwoNumbersDto): number;
    /**
     * Raises the first number to the power of the second (exponentiation).
     * Example: 2  8, 5  25, 10  0.1
     * @param inputs two numbers
     * @returns number
     * @group basics
     * @shortname power
     * @drawable false
     */
    power(inputs: Inputs.Math.TwoNumbersDto): number;
    /**
     * Calculates the square root of a number.
     * Example: 9  3, 2  1.414, 16  4
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname sqrt
     * @drawable false
     */
    sqrt(inputs: Inputs.Math.NumberDto): number;
    /**
     * Returns the absolute value (removes negative sign, always positive or zero).
     * Example: |-5|  5, |3|  3, |0|  0
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname abs
     * @drawable false
     */
    abs(inputs: Inputs.Math.NumberDto): number;
    /**
     * Rounds a number to the nearest integer.
     * Example: 3.7  4, 2.3  2, 5.5  6
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname round
     * @drawable false
     */
    round(inputs: Inputs.Math.NumberDto): number;
    /**
     * Rounds a number down to the nearest integer (toward negative infinity).
     * Example: 3.7  3, -2.3  -3, 5  5
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname floor
     * @drawable false
     */
    floor(inputs: Inputs.Math.NumberDto): number;
    /**
     * Rounds a number up to the nearest integer (toward positive infinity).
     * Example: 3.2  4, -2.8  -2, 5  5
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname ceil
     * @drawable false
     */
    ceil(inputs: Inputs.Math.NumberDto): number;
    /**
     * Negates a number (flips its sign: positive becomes negative, negative becomes positive).
     * Example: 5  -5, -3  3, 0  0
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname negate
     * @drawable false
     */
    negate(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the natural logarithm (base e) of a number.
     * Example: ln(2.718)  ~1, ln(7.389)  ~2, ln(1)  0
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname ln
     * @drawable false
     */
    ln(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the base 10 logarithm of a number.
     * Example: log(100)  2, log(1000)  3, log(10)  1
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname log10
     * @drawable false
     */
    log10(inputs: Inputs.Math.NumberDto): number;
    /**
     * Raises 10 to the power of the input number.
     * Example: 10  100, 10  1000, 10  0.1
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname ten pow
     * @drawable false
     */
    tenPow(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the sine of an angle in radians.
     * Example: sin(0)  0, sin(/2)  1, sin()  ~0
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname sin
     * @drawable false
     */
    sin(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the cosine of an angle in radians.
     * Example: cos(0)  1, cos(/2)  ~0, cos()  -1
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname cos
     * @drawable false
     */
    cos(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the tangent of an angle in radians.
     * Example: tan(0)  0, tan(/4)  ~1, tan(/2)  infinity
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname tan
     * @drawable false
     */
    tan(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the arcsine (inverse sine) in radians, returns angle whose sine is the input.
     * Example: asin(0)  0, asin(1)  /2 (~1.57), asin(0.5)  /6 (~0.524)
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname asin
     * @drawable false
     */
    asin(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the arccosine (inverse cosine) in radians, returns angle whose cosine is the input.
     * Example: acos(1)  0, acos(0)  /2 (~1.57), acos(-1)   (~3.14)
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname acos
     * @drawable false
     */
    acos(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates the arctangent (inverse tangent) in radians, returns angle whose tangent is the input.
     * Example: atan(0)  0, atan(1)  /4 (~0.785), atan(-1)  -/4
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname atan
     * @drawable false
     */
    atan(inputs: Inputs.Math.NumberDto): number;
    /**
     * Calculates e raised to the power of the input (exponential function).
     * Example: e  1, e  ~2.718, e  ~7.389
     * @param inputs a number
     * @returns number
     * @group basics
     * @shortname exp
     * @drawable false
     */
    exp(inputs: Inputs.Math.NumberDto): number;
    /**
     * Converts an angle from degrees to radians.
     * Example: 180   (~3.14159), 90  /2 (~1.5708), 360  2
     * @param inputs a number in degrees
     * @returns number
     * @group basics
     * @shortname deg to rad
     * @drawable false
     */
    degToRad(inputs: Inputs.Math.NumberDto): number;
    /**
     * Converts an angle from radians to degrees.
     * Example:   180, /2  90, 2  360
     * @param inputs a number in radians
     * @returns number
     * @group basics
     * @shortname rad to deg
     * @drawable false
     */
    radToDeg(inputs: Inputs.Math.NumberDto): number;
    /**
     * Applies an easing function to interpolate smoothly between min and max values.
     * Example: x=0.5 from [0,100] with easeInQuad  applies quadratic acceleration curve
     * Useful for smooth animations with various acceleration/deceleration curves.
     * @param inputs a number, min and max values, and ease type
     * @returns number
     * @group operations
     * @shortname ease
     * @drawable false
     */
    ease(inputs: Inputs.Math.EaseDto): number;
    /**
     * Constrains a value between a minimum and maximum value.
     * Example: clamp(5, 0, 3) returns 3, clamp(-1, 0, 3) returns 0, clamp(1.5, 0, 3) returns 1.5
     * @param inputs a number, min and max values
     * @returns number clamped between min and max
     * @group operations
     * @shortname clamp
     * @drawable false
     */
    clamp(inputs: Inputs.Math.ClampDto): number;
    /**
     * Linear interpolation between two values using parameter t (0 to 1).
     * Example: From 0 to 100 at t=0.5  50, From 10 to 20 at t=0.25  12.5
     * When t=0 returns start, when t=1 returns end. Useful for smooth transitions.
     * @param inputs start value, end value, and interpolation parameter t
     * @returns interpolated value
     * @group operations
     * @shortname lerp
     * @drawable false
     */
    lerp(inputs: Inputs.Math.LerpDto): number;
    /**
     * Calculates the interpolation parameter t for a value between start and end (reverse of lerp).
     * Example: Value 5 in range [0,10]  t=0.5, Value 2.5 in range [0,10]  t=0.25
     * Returns what t value would produce the given value in a lerp. Useful for finding relative position.
     * @param inputs start value, end value, and the value to find t for
     * @returns interpolation parameter (typically 0-1)
     * @group operations
     * @shortname inverse lerp
     * @drawable false
     */
    inverseLerp(inputs: Inputs.Math.InverseLerpDto): number;
    /**
     * Hermite interpolation with smooth acceleration and deceleration (smoother than linear lerp).
     * Example: x=0  0, x=0.5  0.5, x=1  1 (but with smooth S-curve in between)
     * Input is automatically clamped to [0,1]. Output eases in and out smoothly. Great for animations.
     * @param inputs a number between 0 and 1
     * @returns smoothly interpolated value
     * @group operations
     * @shortname smoothstep
     * @drawable false
     */
    smoothstep(inputs: Inputs.Math.NumberDto): number;
    /**
     * Returns the sign of a number: -1 for negative, 0 for zero, 1 for positive.
     * Example: -5  -1, 0  0, 3.14  1
     * Useful for determining direction or polarity.
     * @param inputs a number
     * @returns -1, 0, or 1
     * @group operations
     * @shortname sign
     * @drawable false
     */
    sign(inputs: Inputs.Math.NumberDto): number;
    /**
     * Returns the fractional part of a number (removes integer part, keeps decimals).
     * Example: 3.14  0.14, 5.9  0.9, -2.3  0.7
     * Useful for wrapping values and creating repeating patterns.
     * @param inputs a number
     * @returns fractional part (always positive)
     * @group operations
     * @shortname fract
     * @drawable false
     */
    fract(inputs: Inputs.Math.NumberDto): number;
    /**
     * Wraps a number within a specified range (creates repeating cycle).
     * Example: 1.5 in range [0,1)  0.5, -0.3 in range [0,1)  0.7, 370 in range [0,360)  10
     * Useful for angles, UVs, or any repeating domain. Like modulo but handles negatives properly.
     * @param inputs a number, min and max values
     * @returns wrapped value within range
     * @group operations
     * @shortname wrap
     * @drawable false
     */
    wrap(inputs: Inputs.Math.WrapDto): number;
    /**
     * Creates a ping-pong (back-and-forth) effect that bounces a value between 0 and length.
     * The value goes from 0length, then back length0, repeating this cycle.
     * Example: With length=1: t=00, t=0.50.5, t=11 (peak), t=1.50.5, t=20, t=2.50.5 (repeats)
     * Useful for creating bouncing animations like a ball or oscillating motion.
     * @param inputs time value t and length
     * @returns value bouncing between 0 and length
     * @group operations
     * @shortname ping pong
     * @drawable false
     */
    pingPong(inputs: Inputs.Math.PingPongDto): number;
    /**
     * Moves a value toward a target by a maximum delta amount (never overshooting).
     * Example: From 0 toward 10 by max 3  3, From 8 toward 10 by max 3  10 (reached)
     * Useful for smooth movement with maximum speed limits.
     * @param inputs current value, target value, and maximum delta
     * @returns new value moved toward target
     * @group operations
     * @shortname move towards
     * @drawable false
     */
    moveTowards(inputs: Inputs.Math.MoveTowardsDto): number;
    private easeInSine;
    private easeOutSine;
    private easeInOutSine;
    private easeInQuad;
    private easeOutQuad;
    private easeInOutQuad;
    private easeInCubic;
    private easeOutCubic;
    private easeInOutCubic;
    private easeInQuart;
    private easeOutQuart;
    private easeInOutQuart;
    private easeInQuint;
    private easeOutQuint;
    private easeInOutQuint;
    private easeInExpo;
    private easeOutExpo;
    private easeInOutExpo;
    private easeInCirc;
    private easeOutCirc;
    private easeInOutCirc;
    private easeInBack;
    private easeOutBack;
    private easeInOutBack;
    private easeInElastic;
    private easeOutElastic;
    private easeInOutElastic;
    private easeInBounce;
    private easeOutBounce;
    private easeInOutBounce;
  }
  /**
   * Contains various mesh helper methods that are not necessarily present in higher level CAD kernels that bitbybit is using.
   */
  declare class MeshBitByBit {
    private readonly vector;
    private readonly polyline;
    constructor(vector: Vector, polyline: Polyline);
    /**
     * Calculates signed distance from a point to a plane (positive=above plane, negative=below).
     * Example: point=[0,5,0], plane={normal:[0,1,0], d:0}  5 (point is 5 units above XZ plane)
     * @param inputs a point and a plane
     * @returns signed distance
     * @group base
     * @shortname signed dist to plane
     * @drawable false
     */
    signedDistanceToPlane(
      inputs: Inputs.Mesh.SignedDistanceFromPlaneToPointDto
    ): number;
    /**
     * Calculates plane equation from triangle vertices (normal vector and distance from origin).
     * Returns undefined if triangle is degenerate (zero area, collinear points).
     * Example: triangle=[[0,0,0], [1,0,0], [0,1,0]]  {normal:[0,0,1], d:0} (XY plane)
     * @param inputs triangle and tolerance
     * @returns triangle plane
     * @group traingle
     * @shortname triangle plane
     * @drawable false
     */
    calculateTrianglePlane(
      inputs: Inputs.Mesh.TriangleToleranceDto
    ): Inputs.Base.TrianglePlane3 | undefined;
    /**
     * Calculates intersection segment of two triangles (line segment where they cross).
     * Returns undefined if triangles don't intersect, are parallel, or are coplanar.
     * Example: triangle1=[[0,0,0], [2,0,0], [1,2,0]], triangle2=[[1,-1,1], [1,1,1], [1,1,-1]]  [[1,0,0], [1,1,0]]
     * @param inputs first triangle, second triangle, and tolerance
     * @returns intersection segment or undefined if no intersection
     * @group traingle
     * @shortname triangle-triangle int
     * @drawable false
     */
    triangleTriangleIntersection(
      inputs: Inputs.Mesh.TriangleTriangleToleranceDto
    ): Inputs.Base.Segment3 | undefined;
    /**
     * Calculates all intersection segments between two triangle meshes (pairwise triangle tests).
     * Returns array of line segments where mesh surfaces intersect.
     * Example: cube mesh intersecting with sphere mesh  multiple segments forming intersection curve
     * @param inputs first mesh, second mesh, and tolerance
     * @returns array of intersection segments
     * @group mesh
     * @shortname mesh-mesh int segments
     * @drawable false
     */
    meshMeshIntersectionSegments(
      inputs: Inputs.Mesh.MeshMeshToleranceDto
    ): Inputs.Base.Segment3[];
    /**
     * Calculates intersection polylines between two meshes by sorting segments into connected paths.
     * Segments are joined end-to-end to form continuous or closed curves.
     * Example: cube-sphere intersection  closed polyline loops where surfaces meet
     * @param inputs first mesh, second mesh, and tolerance
     * @returns array of intersection polylines
     * @group mesh
     * @shortname mesh-mesh int polylines
     * @drawable true
     */
    meshMeshIntersectionPolylines(
      inputs: Inputs.Mesh.MeshMeshToleranceDto
    ): Inputs.Base.Polyline3[];
    /**
     * Calculates intersection points between two meshes as point arrays (one array per polyline).
     * Closed polylines have first point duplicated at end.
     * Example: cube-sphere intersection  arrays of points defining intersection curves
     * @param inputs first mesh, second mesh, and tolerance
     * @returns array of intersection points
     * @group mesh
     * @shortname mesh-mesh int points
     * @drawable false
     */
    meshMeshIntersectionPoints(
      inputs: Inputs.Mesh.MeshMeshToleranceDto
    ): Inputs.Base.Point3[][];
    private computeIntersectionPoint;
  }
  /**
   * Contains various methods for points. Point in bitbybit is simply an array containing 3 numbers for [x, y, z].
   * Because of this form Point can be interchanged with Vector, which also is an array in [x, y, z] form.
   * When creating 2D points, z coordinate is simply set to 0 - [x, y, 0].
   */
  declare class Point {
    private readonly geometryHelper;
    private readonly transforms;
    private readonly vector;
    private readonly lists;
    constructor(
      geometryHelper: GeometryHelper,
      transforms: Transforms,
      vector: Vector,
      lists: Lists
    );
    /**
     * Applies transformation matrix to a single point (rotates, scales, or translates).
     * Example: point=[0,0,0] with translation [5,5,0]  [5,5,0]
     * @param inputs Contains a point and the transformations to apply
     * @returns Transformed point
     * @group transforms
     * @shortname transform point
     * @drawable true
     */
    transformPoint(inputs: Inputs.Point.TransformPointDto): Inputs.Base.Point3;
    /**
     * Applies same transformation matrix to multiple points (batch transform).
     * Example: 5 points with rotation 90  all 5 points rotated together
     * @param inputs Contains points and the transformations to apply
     * @returns Transformed points
     * @group transforms
     * @shortname transform points
     * @drawable true
     */
    transformPoints(
      inputs: Inputs.Point.TransformPointsDto
    ): Inputs.Base.Point3[];
    /**
     * Applies different transformation matrices to corresponding points (one transform per point).
     * Arrays must have equal length.
     * Example: 3 points with 3 different translations  each point moved independently
     * @param inputs Contains points and the transformations to apply
     * @returns Transformed points
     * @group transforms
     * @shortname transforms for points
     * @drawable true
     */
    transformsForPoints(
      inputs: Inputs.Point.TransformsForPointsDto
    ): Inputs.Base.Point3[];
    /**
     * Moves multiple points by a translation vector (same offset for all points).
     * Example: points=[[0,0,0], [1,0,0]], translation=[5,5,0]  [[5,5,0], [6,5,0]]
     * @param inputs Contains points and the translation vector
     * @returns Translated points
     * @group transforms
     * @shortname translate points
     * @drawable true
     */
    translatePoints(
      inputs: Inputs.Point.TranslatePointsDto
    ): Inputs.Base.Point3[];
    /**
     * Moves multiple points by corresponding translation vectors (one vector per point).
     * Arrays must have equal length.
     * Example: 3 points with 3 different vectors  each point moved by its corresponding vector
     * @param inputs Contains points and the translation vector
     * @returns Translated points
     * @group transforms
     * @shortname translate points with vectors
     * @drawable true
     */
    translatePointsWithVectors(
      inputs: Inputs.Point.TranslatePointsWithVectorsDto
    ): Inputs.Base.Point3[];
    /**
     * Moves multiple points by separate X, Y, Z values (convenience method for translation).
     * Example: points=[[0,0,0]], x=10, y=5, z=0  [[10,5,0]]
     * @param inputs Contains points and the translation in x y and z
     * @returns Translated points
     * @group transforms
     * @shortname translate xyz points
     * @drawable true
     */
    translateXYZPoints(
      inputs: Inputs.Point.TranslateXYZPointsDto
    ): Inputs.Base.Point3[];
    /**
     * Scales multiple points around a center point with different factors per axis.
     * Example: points=[[10,0,0]], center=[5,0,0], scaleXyz=[2,1,1]  [[15,0,0]] (doubles X distance from center)
     * @param inputs Contains points, center point and scale factors
     * @returns Scaled points
     * @group transforms
     * @shortname scale points on center
     * @drawable true
     */
    scalePointsCenterXYZ(
      inputs: Inputs.Point.ScalePointsCenterXYZDto
    ): Inputs.Base.Point3[];
    /**
     * Stretches multiple points along a direction from a center point (directional scaling).
     * Example: points=[[10,0,0]], center=[0,0,0], direction=[1,0,0], scale=2  [[20,0,0]]
     * @param inputs Contains points, center point, direction and scale factor
     * @returns Stretched points
     * @group transforms
     * @shortname stretch points dir from center
     * @drawable true
     */
    stretchPointsDirFromCenter(
      inputs: Inputs.Point.StretchPointsDirFromCenterDto
    ): Inputs.Base.Point3[];
    /**
     * Rotates multiple points around a center point along a custom axis.
     * Example: points=[[10,0,0]], center=[0,0,0], axis=[0,1,0], angle=90  [[0,0,-10]]
     * @param inputs Contains points, axis, center point and angle of rotation
     * @returns Rotated points
     * @group transforms
     * @shortname rotate points center axis
     * @drawable true
     */
    rotatePointsCenterAxis(
      inputs: Inputs.Point.RotatePointsCenterAxisDto
    ): Inputs.Base.Point3[];
    /**
     * Calculates axis-aligned bounding box containing all points (min, max, center, width, height, length).
     * Example: points=[[0,0,0], [10,5,3]]  {min:[0,0,0], max:[10,5,3], center:[5,2.5,1.5], width:10, height:5, length:3}
     * @param inputs Points
     * @returns Bounding box of points
     * @group extract
     * @shortname bounding box pts
     * @drawable true
     */
    boundingBoxOfPoints(
      inputs: Inputs.Point.PointsDto
    ): Inputs.Base.BoundingBox;
    /**
     * Calculates distance to the nearest point in a collection.
     * Example: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]]  3 (distance to [3,0,0])
     * @param inputs Point from which to measure and points to measure the distance against
     * @returns Distance to closest point
     * @group extract
     * @shortname distance to closest pt
     * @drawable false
     */
    closestPointFromPointsDistance(
      inputs: Inputs.Point.ClosestPointFromPointsDto
    ): number;
    /**
     * Finds array index of the nearest point in a collection (1-based index, not 0-based).
     * Example: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]]  3 (index of [3,0,0])
     * @param inputs Point from which to find the index in a collection of points
     * @returns Closest point index
     * @group extract
     * @shortname index of closest pt
     * @drawable false
     */
    closestPointFromPointsIndex(
      inputs: Inputs.Point.ClosestPointFromPointsDto
    ): number;
    /**
     * Finds the nearest point in a collection to a reference point.
     * Example: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]]  [3,0,0]
     * @param inputs Point and points collection to find the closest point in
     * @returns Closest point
     * @group extract
     * @shortname closest pt
     * @drawable true
     */
    closestPointFromPoints(
      inputs: Inputs.Point.ClosestPointFromPointsDto
    ): Inputs.Base.Point3;
    /**
     * Calculates Euclidean distance between two points.
     * Example: start=[0,0,0], end=[3,4,0]  5 (using Pythagorean theorem: (3+4))
     * @param inputs Coordinates of start and end points
     * @returns Distance
     * @group measure
     * @shortname distance
     * @drawable false
     */
    distance(inputs: Inputs.Point.StartEndPointsDto): number;
    /**
     * Calculates distances from a start point to multiple end points.
     * Example: start=[0,0,0], endPoints=[[3,0,0], [0,4,0], [5,0,0]]  [3, 4, 5]
     * @param inputs Coordinates of start and end points
     * @returns Distances
     * @group measure
     * @shortname distances to points
     * @drawable false
     */
    distancesToPoints(inputs: Inputs.Point.StartEndPointsListDto): number[];
    /**
     * Duplicates a point N times (creates array with N copies of the same point).
     * Example: point=[5,5,0], amountOfPoints=3  [[5,5,0], [5,5,0], [5,5,0]]
     * @param inputs The point to be multiplied and the amount of points to create
     * @returns Distance
     * @group transforms
     * @shortname multiply point
     * @drawable true
     */
    multiplyPoint(inputs: Inputs.Point.MultiplyPointDto): Inputs.Base.Point3[];
    /**
     * Extracts X coordinate from a point.
     * Example: point=[5,10,3]  5
     * @param inputs The point
     * @returns X coordinate
     * @group get
     * @shortname x coord
     * @drawable false
     */
    getX(inputs: Inputs.Point.PointDto): number;
    /**
     * Extracts Y coordinate from a point.
     * Example: point=[5,10,3]  10
     * @param inputs The point
     * @returns Y coordinate
     * @group get
     * @shortname y coord
     * @drawable false
     */
    getY(inputs: Inputs.Point.PointDto): number;
    /**
     * Extracts Z coordinate from a point.
     * Example: point=[5,10,3]  3
     * @param inputs The point
     * @returns Z coordinate
     * @group get
     * @shortname z coord
     * @drawable false
     */
    getZ(inputs: Inputs.Point.PointDto): number;
    /**
     * Calculates centroid (average position) of multiple points.
     * Example: points=[[0,0,0], [10,0,0], [10,10,0]]  [6.67,3.33,0]
     * @param inputs The points
     * @returns point
     * @group extract
     * @shortname average point
     * @drawable true
     */
    averagePoint(inputs: Inputs.Point.PointsDto): Inputs.Base.Point3;
    /**
     * Creates a 3D point from X, Y, Z coordinates.
     * Example: x=10, y=5, z=3  [10,5,3]
     * @param inputs xyz information
     * @returns point 3d
     * @group create
     * @shortname point xyz
     * @drawable true
     */
    pointXYZ(inputs: Inputs.Point.PointXYZDto): Inputs.Base.Point3;
    /**
     * Creates a 2D point from X, Y coordinates.
     * Example: x=10, y=5  [10,5]
     * @param inputs xy information
     * @returns point 3d
     * @group create
     * @shortname point xy
     * @drawable false
     */
    pointXY(inputs: Inputs.Point.PointXYDto): Inputs.Base.Point2;
    /**
     * Creates logarithmic spiral points using golden angle or custom widening factor.
     * Generates natural spiral patterns common in nature (sunflower, nautilus shell).
     * Example: numberPoints=100, radius=10, phi=1.618  100 points forming outward spiral
     * @param inputs Spiral information
     * @returns Specified number of points in the array along the spiral
     * @group create
     * @shortname spiral
     * @drawable true
     */
    spiral(inputs: Inputs.Point.SpiralDto): Inputs.Base.Point3[];
    /**
     * Creates hexagonal grid center points on XY plane (honeycomb pattern).
     * Grid size controlled by number of hexagons, not width/height.
     * Example: radiusHexagon=1, nrHexagonsX=3, nrHexagonsY=3  9 hex centers in grid pattern
     * @param inputs Information about hexagon and the grid
     * @returns Points in the array on the grid
     * @group create
     * @shortname hex grid
     * @drawable true
     */
    hexGrid(inputs: Inputs.Point.HexGridCentersDto): Inputs.Base.Point3[];
    /**
     * Creates hexagonal grid scaled to fit within specified width/height bounds (auto-calculates hex size).
     * Returns center points and hex vertices. Supports pointy-top or flat-top orientation.
     * Example: width=10, height=10, nrHexagonsInHeight=3  hex grid filling 1010 area with 3 rows
     * @param inputs Information about the desired grid dimensions and hexagon counts.
     * @returns An object containing the array of center points and an array of hexagon vertex arrays.
     * @group create
     * @shortname scaled hex grid to fit
     * @drawable false
     */
    hexGridScaledToFit(
      inputs: Inputs.Point.HexGridScaledToFitDto
    ): Models.Point.HexGridData;
    /**
     * Calculates the maximum possible fillet radius at a corner formed by two line segments
     * sharing an endpoint (C), such that the fillet arc is tangent to both segments
     * and lies entirely within them.
     * @param inputs three points and the tolerance
     * @returns the maximum fillet radius
     * @group fillet
     * @shortname max fillet radius
     * @drawable false
     */
    maxFilletRadius(inputs: Inputs.Point.ThreePointsToleranceDto): number;
    /**
     * Calculates the maximum possible fillet radius at a corner C, such that the fillet arc
     * is tangent to both segments (P1-C, P2-C) and the tangent points lie within
     * the first half of each segment (measured from C).
     * @param inputs three points and the tolerance
     * @returns the maximum fillet radius
     * @group fillet
     * @shortname max fillet radius half line
     * @drawable false
     */
    maxFilletRadiusHalfLine(
      inputs: Inputs.Point.ThreePointsToleranceDto
    ): number;
    /**
     * Calculates the maximum possible fillet radius at each corner of a polyline formed by
     * formed by a series of points. The fillet radius is calculated for each internal
     * corner and optionally for the closing corners if the polyline is closed.
     * @param inputs Points, checkLastWithFirst flag, and tolerance
     * @returns Array of maximum fillet radii for each corner
     * @group fillet
     * @shortname max fillets half line
     * @drawable false
     */
    maxFilletsHalfLine(
      inputs: Inputs.Point.PointsMaxFilletsHalfLineDto
    ): number[];
    /**
     * Calculates the single safest maximum fillet radius that can be applied
     * uniformly to all corners of collection of points, based on the 'half-line' constraint.
     * This is determined by finding the minimum of the maximum possible fillet
     * radii calculated for each individual corner.
     * @param inputs Defines the points, whether it's closed, and an optional tolerance.
     * @returns The smallest value from the results of pointsMaxFilletsHalfLine.
     *          Returns 0 if the polyline has fewer than 3 points or if any
     *          calculated maximum radius is 0.
     * @group fillet
     * @shortname safest fillet radii points
     * @drawable false
     */
    safestPointsMaxFilletHalfLine(
      inputs: Inputs.Point.PointsMaxFilletsHalfLineDto
    ): number;
    /**
     * Removes consecutive duplicate points from array within tolerance.
     * Example: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]]  [[0,0,0], [1,0,0], [2,0,0]]
     * @param inputs points, tolerance and check first and last
     * @returns Points in the array without consecutive duplicates
     * @group clean
     * @shortname remove duplicates
     * @drawable true
     */
    removeConsecutiveDuplicates(
      inputs: Inputs.Point.RemoveConsecutiveDuplicatesDto
    ): Inputs.Base.Point3[];
    /**
     * Calculates normal vector from three points using cross product (perpendicular to plane).
     * Example: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0]  [0,0,1] (pointing up from XY plane)
     * @param inputs Three points and the reverse normal flag
     * @returns Normal vector
     * @group create
     * @shortname normal from 3 points
     * @drawable true
     */
    normalFromThreePoints(
      inputs: Inputs.Point.ThreePointsNormalDto
    ): Inputs.Base.Vector3;
    private closestPointFromPointData;
    /**
     * Checks if two points are approximately equal within tolerance (distance-based comparison).
     * Example: point1=[1.0000001, 2.0, 3.0], point2=[1.0, 2.0, 3.0], tolerance=1e-6  true
     * @param inputs Two points and the tolerance
     * @returns true if the points are almost equal
     * @group measure
     * @shortname two points almost equal
     * @drawable false
     */
    twoPointsAlmostEqual(inputs: Inputs.Point.TwoPointsToleranceDto): boolean;
    /**
     * Sorts points lexicographically (by X, then Y, then Z coordinates).
     * Example: [[5,0,0], [1,0,0], [3,0,0]]  [[1,0,0], [3,0,0], [5,0,0]]
     * @param inputs points
     * @returns sorted points
     * @group sort
     * @shortname sort points
     * @drawable true
     */
    sortPoints(inputs: Inputs.Point.PointsDto): Inputs.Base.Point3[];
    /**
     * Calculates the 6 vertices of a regular flat-top hexagon.
     * @param center The center point [x, y, z].
     * @param radius The radius (distance from center to vertex).
     * @returns An array of 6 Point3 vertices in counter-clockwise order.
     */
    private getRegularHexagonVertices;
  }
  /**
   * Contains various methods for polyline. Polyline in bitbybit is a simple object that has points property containing an array of points.
   * { points: number[][] }
   */
  declare class Polyline {
    private readonly vector;
    private readonly point;
    private readonly line;
    private readonly geometryHelper;
    constructor(
      vector: Vector,
      point: Point,
      line: Line,
      geometryHelper: GeometryHelper
    );
    /**
     * Calculates total length of polyline by summing distances between consecutive points.
     * Example: points=[[0,0,0], [3,0,0], [3,4,0]]  3 + 4 = 7
     * @param inputs a polyline
     * @returns length
     * @group get
     * @shortname polyline length
     * @drawable false
     */
    length(inputs: Inputs.Polyline.PolylineDto): number;
    /**
     * Counts number of points in polyline.
     * Example: polyline with points=[[0,0,0], [1,0,0], [1,1,0]]  3
     * @param inputs a polyline
     * @returns nr of points
     * @group get
     * @shortname nr polyline points
     * @drawable false
     */
    countPoints(inputs: Inputs.Polyline.PolylineDto): number;
    /**
     * Extracts points array from polyline object.
     * Example: polyline={points:[[0,0,0], [1,0,0]]}  [[0,0,0], [1,0,0]]
     * @param inputs a polyline
     * @returns points
     * @group get
     * @shortname points
     * @drawable true
     */
    getPoints(inputs: Inputs.Polyline.PolylineDto): Inputs.Base.Point3[];
    /**
     * Reverses point order of polyline (flips direction).
     * Example: points=[[0,0,0], [1,0,0], [2,0,0]]  [[2,0,0], [1,0,0], [0,0,0]]
     * @param inputs a polyline
     * @returns reversed polyline
     * @group convert
     * @shortname reverse polyline
     * @drawable true
     */
    reverse(
      inputs: Inputs.Polyline.PolylineDto
    ): Inputs.Polyline.PolylinePropertiesDto;
    /**
     * Applies transformation matrix to all points in polyline (rotates, scales, or translates).
     * Example: polyline with 4 points, translation [5,0,0]  all points moved +5 in X direction
     * @param inputs a polyline
     * @returns transformed polyline
     * @group transforms
     * @shortname transform polyline
     * @drawable true
     */
    transformPolyline(
      inputs: Inputs.Polyline.TransformPolylineDto
    ): Inputs.Polyline.PolylinePropertiesDto;
    /**
     * Creates a polyline from points array with optional isClosed flag.
     * Example: points=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true  {points:..., isClosed:true}
     * @param inputs points and info if its closed
     * @returns polyline
     * @group create
     * @shortname polyline
     * @drawable true
     */
    create(
      inputs: Inputs.Polyline.PolylineCreateDto
    ): Inputs.Polyline.PolylinePropertiesDto;
    /**
     * Converts polyline to line segments (each segment as line object with start/end).
     * Closed polylines include closing segment.
     * Example: 3 points  2 or 3 lines (depending on isClosed)
     * @param inputs polyline
     * @returns lines
     * @group convert
     * @shortname polyline to lines
     * @drawable true
     */
    polylineToLines(inputs: Inputs.Polyline.PolylineDto): Inputs.Base.Line3[];
    /**
     * Converts polyline to segment arrays (each segment as [point1, point2]).
     * Closed polylines include closing segment if endpoints differ.
     * Example: 4 points, closed  4 segments connecting all points in a loop
     * @param inputs polyline
     * @returns segments
     * @group convert
     * @shortname polyline to segments
     * @drawable false
     */
    polylineToSegments(
      inputs: Inputs.Polyline.PolylineDto
    ): Inputs.Base.Segment3[];
    /**
     * Finds points where polyline crosses itself (self-intersection points).
     * Skips adjacent segments and deduplicates close points.
     * Example: figure-8 shaped polyline  returns center crossing point
     * @param inputs points of self intersection
     * @returns polyline
     * @group intersections
     * @shortname polyline self intersections
     * @drawable true
     */
    polylineSelfIntersection(
      inputs: Inputs.Polyline.PolylineToleranceDto
    ): Inputs.Base.Point3[];
    /**
     * Finds intersection points between two polylines (all segment-segment crossings).
     * Tests all segment pairs and deduplicates close points.
     * Example: crossing polylines forming an X  returns center intersection point
     * @param inputs two polylines and tolerance
     * @returns points
     * @group intersection
     * @shortname two polyline intersection
     * @drawable true
     */
    twoPolylineIntersection(
      inputs: Inputs.Polyline.TwoPolylinesToleranceDto
    ): Inputs.Base.Point3[];
    /**
     * Sorts scrambled segments into connected polylines by matching endpoints.
     * Uses spatial hashing for efficient connection finding.
     * Example: 10 random segments that form 2 connected paths  2 polylines
     * @param inputs segments
     * @returns polylines
     * @group sort
     * @shortname segments to polylines
     * @drawable true
     */
    sortSegmentsIntoPolylines(
      inputs: Inputs.Polyline.SegmentsToleranceDto
    ): Inputs.Base.Polyline3[];
    /**
     * Calculates the maximum possible half-line fillet radius for each corner
     * of a given polyline. For a closed polyline, it includes the corners
     * connecting the last segment back to the first.
     *
     * The calculation uses the 'half-line' constraint, meaning the fillet's
     * tangent points must lie within the first half of each segment connected
     * to the corner.
     *
     * @param inputs Defines the polyline points, whether it's closed, and an optional tolerance.
     * @returns An array containing the maximum fillet radius calculated for each corner.
     *          The order corresponds to corners P[1]...P[n-2] for open polylines,
     *          and P[1]...P[n-2], P[0], P[n-1] for closed polylines.
     *          Returns an empty array if the polyline has fewer than 3 points.
     * @group fillet
     * @shortname polyline max fillet radii
     * @drawable false
     */
    maxFilletsHalfLine(inputs: Inputs.Polyline.PolylineToleranceDto): number[];
    /**
     * Calculates the single safest maximum fillet radius that can be applied
     * uniformly to all corners of a polyline, based on the 'half-line' constraint.
     * This is determined by finding the minimum of the maximum possible fillet
     * radii calculated for each individual corner.
     *
     * @param inputs Defines the polyline points, whether it's closed, and an optional tolerance.
     * @returns The smallest value from the results of calculatePolylineMaxFillets.
     *          Returns 0 if the polyline has fewer than 3 points or if any
     *          calculated maximum radius is 0.
     * @group fillet
     * @shortname polyline safest fillet radius
     * @drawable false
     */
    safestFilletRadius(inputs: Inputs.Polyline.PolylineToleranceDto): number;
  }
  /**
   * Contains various text methods.
   */
  declare class TextBitByBit {
    private readonly point;
    constructor(point: Point);
    /**
     * Creates and returns a text string (pass-through for text input).
     * Example: text='Hello World'  'Hello World'
     * @param inputs a text
     * @returns text
     * @group create
     * @shortname text
     * @drawable false
     */
    create(inputs: Inputs.Text.TextDto): string;
    /**
     * Splits text into multiple pieces using a separator string.
     * Example: text='apple,banana,cherry', separator=','  ['apple', 'banana', 'cherry']
     * @param inputs a text
     * @returns text
     * @group transform
     * @shortname split
     * @drawable false
     */
    split(inputs: Inputs.Text.TextSplitDto): string[];
    /**
     * Replaces all occurrences of a search string with a replacement string.
     * Example: text='hello hello', search='hello', replaceWith='hi'  'hi hi'
     * @param inputs a text
     * @returns text
     * @group transform
     * @shortname replaceAll
     * @drawable false
     */
    replaceAll(inputs: Inputs.Text.TextReplaceDto): string;
    /**
     * Joins multiple items into a single text string using a separator.
     * Example: list=['apple', 'banana', 'cherry'], separator=', '  'apple, banana, cherry'
     * @param inputs a list of items
     * @returns text
     * @group transform
     * @shortname join
     * @drawable false
     */
    join(inputs: Inputs.Text.TextJoinDto): string;
    /**
     * Transform any item to text
     * @param inputs any item
     * @returns text
     * @group transform
     * @shortname to string
     * @drawable false
     */
    toString<T>(inputs: Inputs.Text.ToStringDto<T>): string;
    /**
     * Transform each item in list to text
     * @param inputs list of items
     * @returns texts
     * @group transform
     * @shortname to strings
     * @drawable false
     */
    toStringEach<T>(inputs: Inputs.Text.ToStringEachDto<T>): string[];
    /**
     * Formats text with placeholder values using {0}, {1}, etc. syntax.
     * Example: text='Point: ({0}, {1})', values=[10, 5]  'Point: (10, 5)'
     * @param inputs a text and values
     * @returns formatted text
     * @group transform
     * @shortname format
     * @drawable false
     */
    format(inputs: Inputs.Text.TextFormatDto): string;
    /**
     * Checks if text contains a search string.
     * Example: text='hello world', search='world'  true
     * @param inputs a text and search string
     * @returns boolean
     * @group query
     * @shortname includes
     * @drawable false
     */
    includes(inputs: Inputs.Text.TextSearchDto): boolean;
    /**
     * Checks if text starts with a search string.
     * Example: text='hello world', search='hello'  true
     * @param inputs a text and search string
     * @returns boolean
     * @group query
     * @shortname starts with
     * @drawable false
     */
    startsWith(inputs: Inputs.Text.TextSearchDto): boolean;
    /**
     * Checks if text ends with a search string.
     * Example: text='hello world', search='world'  true
     * @param inputs a text and search string
     * @returns boolean
     * @group query
     * @shortname ends with
     * @drawable false
     */
    endsWith(inputs: Inputs.Text.TextSearchDto): boolean;
    /**
     * Returns the index of the first occurrence of a search string.
     * Example: text='hello world', search='world'  6
     * @param inputs a text and search string
     * @returns index or -1 if not found
     * @group query
     * @shortname index of
     * @drawable false
     */
    indexOf(inputs: Inputs.Text.TextSearchDto): number;
    /**
     * Returns the index of the last occurrence of a search string.
     * Example: text='hello world hello', search='hello'  12
     * @param inputs a text and search string
     * @returns index or -1 if not found
     * @group query
     * @shortname last index of
     * @drawable false
     */
    lastIndexOf(inputs: Inputs.Text.TextSearchDto): number;
    /**
     * Extracts a section of text between two indices.
     * Example: text='hello world', start=0, end=5  'hello'
     * @param inputs a text, start and end indices
     * @returns extracted text
     * @group transform
     * @shortname substring
     * @drawable false
     */
    substring(inputs: Inputs.Text.TextSubstringDto): string;
    /**
     * Extracts a section of text and returns a new string.
     * Example: text='hello world', start=0, end=5  'hello'
     * @param inputs a text, start and end indices
     * @returns extracted text
     * @group transform
     * @shortname slice
     * @drawable false
     */
    slice(inputs: Inputs.Text.TextSubstringDto): string;
    /**
     * Returns the character at the specified index.
     * Example: text='hello', index=1  'e'
     * @param inputs a text and index
     * @returns character
     * @group query
     * @shortname char at
     * @drawable false
     */
    charAt(inputs: Inputs.Text.TextIndexDto): string;
    /**
     * Removes whitespace from both ends of text.
     * Example: text='  hello  '  'hello'
     * @param inputs a text
     * @returns trimmed text
     * @group transform
     * @shortname trim
     * @drawable false
     */
    trim(inputs: Inputs.Text.TextDto): string;
    /**
     * Removes whitespace from the start of text.
     * Example: text='  hello  '  'hello  '
     * @param inputs a text
     * @returns trimmed text
     * @group transform
     * @shortname trim start
     * @drawable false
     */
    trimStart(inputs: Inputs.Text.TextDto): string;
    /**
     * Removes whitespace from the end of text.
     * Example: text='  hello  '  '  hello'
     * @param inputs a text
     * @returns trimmed text
     * @group transform
     * @shortname trim end
     * @drawable false
     */
    trimEnd(inputs: Inputs.Text.TextDto): string;
    /**
     * Pads text from the start to reach target length.
     * Example: text='x', length=3, padString='a'  'aax'
     * @param inputs a text, target length and pad string
     * @returns padded text
     * @group transform
     * @shortname pad start
     * @drawable false
     */
    padStart(inputs: Inputs.Text.TextPadDto): string;
    /**
     * Pads text from the end to reach target length.
     * Example: text='x', length=3, padString='a'  'xaa'
     * @param inputs a text, target length and pad string
     * @returns padded text
     * @group transform
     * @shortname pad end
     * @drawable false
     */
    padEnd(inputs: Inputs.Text.TextPadDto): string;
    /**
     * Converts text to uppercase.
     * Example: text='hello'  'HELLO'
     * @param inputs a text
     * @returns uppercase text
     * @group transform
     * @shortname to upper case
     * @drawable false
     */
    toUpperCase(inputs: Inputs.Text.TextDto): string;
    /**
     * Converts text to lowercase.
     * Example: text='HELLO'  'hello'
     * @param inputs a text
     * @returns lowercase text
     * @group transform
     * @shortname to lower case
     * @drawable false
     */
    toLowerCase(inputs: Inputs.Text.TextDto): string;
    /**
     * Capitalizes the first character of text.
     * Example: text='hello world'  'Hello world'
     * @param inputs a text
     * @returns text with first character uppercase
     * @group transform
     * @shortname capitalize first
     * @drawable false
     */
    toUpperCaseFirst(inputs: Inputs.Text.TextDto): string;
    /**
     * Lowercases the first character of text.
     * Example: text='Hello World'  'hello World'
     * @param inputs a text
     * @returns text with first character lowercase
     * @group transform
     * @shortname uncapitalize first
     * @drawable false
     */
    toLowerCaseFirst(inputs: Inputs.Text.TextDto): string;
    /**
     * Repeats text a specified number of times.
     * Example: text='ha', count=3  'hahaha'
     * @param inputs a text and count
     * @returns repeated text
     * @group transform
     * @shortname repeat
     * @drawable false
     */
    repeat(inputs: Inputs.Text.TextRepeatDto): string;
    /**
     * Reverses the characters in text.
     * Example: text='hello'  'olleh'
     * @param inputs a text
     * @returns reversed text
     * @group transform
     * @shortname reverse
     * @drawable false
     */
    reverse(inputs: Inputs.Text.TextDto): string;
    /**
     * Returns the length of text.
     * Example: text='hello'  5
     * @param inputs a text
     * @returns length
     * @group query
     * @shortname length
     * @drawable false
     */
    length(inputs: Inputs.Text.TextDto): number;
    /**
     * Checks if text is empty or only whitespace.
     * Example: text='   '  true
     * @param inputs a text
     * @returns boolean
     * @group query
     * @shortname is empty
     * @drawable false
     */
    isEmpty(inputs: Inputs.Text.TextDto): boolean;
    /**
     * Concatenates multiple text strings.
     * Example: texts=['hello', ' ', 'world']  'hello world'
     * @param inputs array of texts
     * @returns concatenated text
     * @group transform
     * @shortname concat
     * @drawable false
     */
    concat(inputs: Inputs.Text.TextConcatDto): string;
    /**
     * Tests if text matches a regular expression pattern.
     * Example: text='hello123', pattern='[0-9]+'  true
     * @param inputs a text and regex pattern
     * @returns boolean
     * @group regex
     * @shortname test regex
     * @drawable false
     */
    regexTest(inputs: Inputs.Text.TextRegexDto): boolean;
    /**
     * Matches text against a regular expression and returns matches.
     * Example: text='hello123world456', pattern='[0-9]+', flags='g'  ['123', '456']
     * @param inputs a text and regex pattern
     * @returns array of matches or null
     * @group regex
     * @shortname regex match
     * @drawable false
     */
    regexMatch(inputs: Inputs.Text.TextRegexDto): string[] | null;
    /**
     * Replaces text matching a regular expression pattern.
     * Example: text='hello123world456', pattern='[0-9]+', flags='g', replaceWith='X'  'helloXworldX'
     * @param inputs a text, regex pattern, and replacement
     * @returns text with replacements
     * @group regex
     * @shortname regex replace
     * @drawable false
     */
    regexReplace(inputs: Inputs.Text.TextRegexReplaceDto): string;
    /**
     * Searches text for a regular expression pattern and returns the index.
     * Example: text='hello123', pattern='[0-9]+'  5
     * @param inputs a text and regex pattern
     * @returns index or -1 if not found
     * @group regex
     * @shortname regex search
     * @drawable false
     */
    regexSearch(inputs: Inputs.Text.TextRegexDto): number;
    /**
     * Splits text using a regular expression pattern.
     * Example: text='a1b2c3', pattern='[0-9]+'  ['a', 'b', 'c']
     * @param inputs a text and regex pattern
     * @returns array of split strings
     * @group regex
     * @shortname regex split
     * @drawable false
     */
    regexSplit(inputs: Inputs.Text.TextRegexDto): string[];
    /**
     * Converts a character to vector paths (polylines) with width and height data for rendering.
     * Uses simplex stroke font to generate 2D line segments representing the character shape.
     * Example: char='A', height=10  {width:8, height:10, paths:[[points forming A shape]]}
     * @param inputs a text
     * @returns width, height and segments as json
     * @group vector
     * @shortname vector char
     * @drawable false
     */
    vectorChar(inputs: Inputs.Text.VectorCharDto): Models.Text.VectorCharData;
    /**
         * Converts multi-line text to vector paths (polylines) with alignment and spacing controls.
         * Supports line breaks, letter spacing, line spacing, horizontal alignment, and origin centering.
         * Example: text='Hello
    World', height=10, align=center  [{line1 chars}, {line2 chars}]
         * @param inputs a text as string
         * @returns segments
         * @group vector
         * @shortname vector text
         * @drawable false
         */
    vectorText(inputs: Inputs.Text.VectorTextDto): Models.Text.VectorTextData[];
    private vectorParamsChar;
    private translateLine;
  }
  /**
   * Transformations help to move, scale, rotate objects. You can combine multiple transformations
   * for object to be placed exactly into position and orientation that you want.
   * Contains various methods for transformations that represent 4x4 matrixes in flat 16 number arrays.
   */
  declare class Transforms {
    private readonly vector;
    private readonly math;
    constructor(vector: Vector, math: MathBitByBit);
    /**
     * Creates rotation transformations around a center point and custom axis.
     * Combines translation to origin, axis rotation, then translation back.
     * Example: center=[5,0,0], axis=[0,1,0], angle=90  rotates around vertical axis through point [5,0,0]
     * @param inputs Rotation around center with an axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center axis
     * @drawable false
     */
    rotationCenterAxis(
      inputs: Inputs.Transforms.RotationCenterAxisDto
    ): Base.TransformMatrixes;
    /**
     * Creates rotation transformations around a center point along the X axis.
     * Example: center=[5,5,5], angle=90  rotates 90 around X axis through point [5,5,5]
     * @param inputs Rotation around center with an X axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center x
     * @drawable false
     */
    rotationCenterX(
      inputs: Inputs.Transforms.RotationCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates rotation transformations around a center point along the Y axis.
     * Example: center=[0,0,0], angle=45  rotates 45 around Y axis through origin
     * @param inputs Rotation around center with an Y axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center y
     * @drawable false
     */
    rotationCenterY(
      inputs: Inputs.Transforms.RotationCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates rotation transformations around a center point along the Z axis.
     * Example: center=[10,10,0], angle=180  rotates 180 around Z axis through point [10,10,0]
     * @param inputs Rotation around center with an Z axis information
     * @returns array of transformations
     * @group rotation
     * @shortname center z
     * @drawable false
     */
    rotationCenterZ(
      inputs: Inputs.Transforms.RotationCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates rotation transformations using yaw-pitch-roll (Euler angles) around a center point.
     * Yaw  Y axis rotation, Pitch  X axis rotation, Roll  Z axis rotation.
     * Example: center=[0,0,0], yaw=90, pitch=0, roll=0  rotates 90 around Y axis
     * @param inputs Yaw pitch roll rotation information
     * @returns array of transformations
     * @group rotation
     * @shortname yaw pitch roll
     * @drawable false
     */
    rotationCenterYawPitchRoll(
      inputs: Inputs.Transforms.RotationCenterYawPitchRollDto
    ): Base.TransformMatrixes;
    /**
     * Creates non-uniform scale transformation around a center point (different scale per axis).
     * Example: center=[5,5,5], scaleXyz=[2,1,0.5]  doubles X, keeps Y, halves Z around point [5,5,5]
     * @param inputs Scale center xyz trnansformation
     * @returns array of transformations
     * @group scale
     * @shortname center xyz
     * @drawable false
     */
    scaleCenterXYZ(
      inputs: Inputs.Transforms.ScaleCenterXYZDto
    ): Base.TransformMatrixes;
    /**
     * Creates non-uniform scale transformation from origin (different scale per axis).
     * Example: scaleXyz=[2,3,1]  doubles X, triples Y, keeps Z unchanged
     * @param inputs Scale XYZ number array information
     * @returns transformation
     * @group scale
     * @shortname xyz
     * @drawable false
     */
    scaleXYZ(inputs: Inputs.Transforms.ScaleXYZDto): Base.TransformMatrixes;
    /**
     * Creates directional stretch transformation that scales along a specific direction from a center point.
     * Points move only along the direction vector; perpendicular plane remains unchanged.
     * Example: center=[0,0,0], direction=[1,0,0], scale=2  stretches 2 along X axis only
     * @param inputs Defines the center, direction, and scale factor for the stretch.
     * @returns Array of transformations: [Translate To Origin, Stretch, Translate Back].
     * @group scale
     * @shortname stretch dir center
     * @drawable false
     */
    stretchDirFromCenter(
      inputs: Inputs.Transforms.StretchDirCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates uniform scale transformation from origin (same scale on all axes).
     * Example: scale=2  doubles size in all directions (X, Y, Z)
     * @param inputs Scale Dto
     * @returns transformation
     * @group scale
     * @shortname uniform
     * @drawable false
     */
    uniformScale(
      inputs: Inputs.Transforms.UniformScaleDto
    ): Base.TransformMatrixes;
    /**
     * Creates uniform scale transformation around a center point (same scale on all axes).
     * Example: center=[5,5,5], scale=0.5  halves size in all directions around point [5,5,5]
     * @param inputs Scale Dto with center point information
     * @returns array of transformations
     * @group scale
     * @shortname uniform from center
     * @drawable false
     */
    uniformScaleFromCenter(
      inputs: Inputs.Transforms.UniformScaleFromCenterDto
    ): Base.TransformMatrixes;
    /**
     * Creates translation transformation (moves objects in space).
     * Example: translation=[10,5,0]  moves object 10 units in X, 5 in Y, 0 in Z
     * @param inputs Translation information
     * @returns transformation
     * @group translation
     * @shortname xyz
     * @drawable false
     */
    translationXYZ(
      inputs: Inputs.Transforms.TranslationXYZDto
    ): Base.TransformMatrixes;
    /**
     * Creates multiple translation transformations (batch move operations).
     * Example: translations=[[1,0,0], [0,2,0]]  generates two transforms: move +X, move +Y
     * @param inputs Translation information
     * @returns transformation
     * @group translations
     * @shortname xyz
     * @drawable false
     */
    translationsXYZ(
      inputs: Inputs.Transforms.TranslationsXYZDto
    ): Base.TransformMatrixes[];
    /**
     * Creates identity transformation matrix (no transformation - leaves objects unchanged).
     * Returns 44 matrix: [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]
     * @returns transformation
     * @group identity
     * @shortname identity
     * @drawable false
     */
    identity(): Base.TransformMatrix;
    private translation;
    private scaling;
    private rotationAxis;
    private rotationX;
    private rotationY;
    private rotationZ;
    private rotationYawPitchRoll;
    private rotationMatrixFromQuat;
    /**
     * Creates a 4x4 matrix that scales along a given direction vector.
     * @param direction The direction vector (will be normalized).
     * @param scale The scale factor along the direction.
     * @returns A 4x4 column-major transformation matrix.
     */
    private stretchDirection;
  }
  /**
   * Contains various methods for vector mathematics. Vector in bitbybit is simply an array, usually containing numbers.
   * In 3D [x, y, z] form describes space, where y is the up vector.
   * Because of this form Vector can be interchanged with Point, which also is an array in [x, y, z] form.
   */
  declare class Vector {
    private readonly math;
    private readonly geometryHelper;
    constructor(math: MathBitByBit, geometryHelper: GeometryHelper);
    /**
     * Removes all duplicate vectors from the input array (keeps only unique vectors).
     * Example: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]]  [[1,2,3], [4,5,6], [7,8,9]]
     * @param inputs Contains vectors and a tolerance value
     * @returns Array of vectors without duplicates
     * @group remove
     * @shortname remove all duplicates
     * @drawable false
     */
    removeAllDuplicateVectors(
      inputs: Inputs.Vector.RemoveAllDuplicateVectorsDto
    ): number[][];
    /**
     * Removes consecutive duplicate vectors from the input array (only removes duplicates that appear next to each other).
     * Example: [[1,2], [1,2], [3,4], [1,2]]  [[1,2], [3,4], [1,2]] (only removed consecutive duplicate)
     * @param inputs Contains vectors and a tolerance value
     * @returns Array of vectors without duplicates
     * @group remove
     * @shortname remove consecutive duplicates
     * @drawable false
     */
    removeConsecutiveDuplicateVectors(
      inputs: Inputs.Vector.RemoveConsecutiveDuplicateVectorsDto
    ): number[][];
    /**
     * Checks if two vectors are the same within a given tolerance (accounts for floating point precision).
     * Example: [1,2,3] vs [1.0001,2.0001,3.0001] with tolerance 0.001  true
     * @param inputs Contains two vectors and a tolerance value
     * @returns Boolean indicating if vectors are the same
     * @group validate
     * @shortname vectors the same
     * @drawable false
     */
    vectorsTheSame(inputs: Inputs.Vector.VectorsTheSameDto): boolean;
    /**
     * Measures the angle between two vectors in degrees (always returns positive angle 0-180).
     * Example: [1,0,0] and [0,1,0]  90 (perpendicular vectors)
     * @param inputs Contains two vectors represented as number arrays
     * @group angles
     * @shortname angle
     * @returns Number in degrees
     * @drawable false
     */
    angleBetween(inputs: Inputs.Vector.TwoVectorsDto): number;
    /**
     * Measures the normalized 2D angle between two vectors in degrees (considers direction, can be negative).
     * Example: [1,0] to [0,1]  90, [0,1] to [1,0]  -90
     * @param inputs Contains two vectors represented as number arrays
     * @returns Number in degrees
     * @group angles
     * @shortname angle normalized 2d
     * @drawable false
     */
    angleBetweenNormalized2d(inputs: Inputs.Vector.TwoVectorsDto): number;
    /**
     * Measures a positive angle between two vectors given the reference vector in degrees (always 0-360).
     * Example: converts negative signed angles to positive by adding 360 when needed
     * @param inputs Contains information of two vectors and a reference vector
     * @returns Number in degrees
     * @group angles
     * @shortname positive angle
     * @drawable false
     */
    positiveAngleBetween(inputs: Inputs.Vector.TwoVectorsReferenceDto): number;
    /**
     * Adds all vector xyz values together element-wise and creates a new vector.
     * Example: [[1,2,3], [4,5,6], [7,8,9]]  [12,15,18] (sums each column)
     * @param inputs Vectors to be added
     * @returns New vector that has xyz values as sums of all the vectors
     * @group sum
     * @shortname add all
     * @drawable false
     */
    addAll(inputs: Inputs.Vector.VectorsDto): number[];
    /**
     * Adds two vectors together element-wise.
     * Example: [1,2,3] + [4,5,6]  [5,7,9]
     * @param inputs Two vectors to be added
     * @returns Number array representing vector
     * @group sum
     * @shortname add
     * @drawable false
     */
    add(inputs: Inputs.Vector.TwoVectorsDto): number[];
    /**
     * Checks if the boolean array contains only true values, returns false if there's a single false.
     * Example: [true, true, true]  true, [true, false, true]  false
     * @param inputs Vectors to be checked
     * @returns Boolean indicating if vector contains only true values
     * @group sum
     * @shortname all
     * @drawable false
     */
    all(inputs: Inputs.Vector.VectorBoolDto): boolean;
    /**
     * Computes the cross product of two 3D vectors (perpendicular vector to both inputs).
     * Example: [1,0,0]  [0,1,0]  [0,0,1] (right-hand rule)
     * @param inputs Two vectors to be crossed
     * @group base
     * @shortname cross
     * @returns Crossed vector
     * @drawable false
     */
    cross(inputs: Inputs.Vector.TwoVectorsDto): number[];
    /**
     * Calculates squared distance between two vectors (faster than distance, avoids sqrt).
     * Example: [0,0,0] to [3,4,0]  25 (distance 5 squared)
     * @param inputs Two vectors
     * @returns Number representing squared distance between two vectors
     * @group distance
     * @shortname dist squared
     * @drawable false
     */
    distSquared(inputs: Inputs.Vector.TwoVectorsDto): number;
    /**
     * Calculates the Euclidean distance between two vectors.
     * Example: [0,0,0] to [3,4,0]  5, [1,1] to [4,5]  5
     * @param inputs Two vectors
     * @returns Number representing distance between two vectors
     * @group distance
     * @shortname dist
     * @drawable false
     */
    dist(inputs: Inputs.Vector.TwoVectorsDto): number;
    /**
     * Divides each element of the vector by a scalar value.
     * Example: [10,20,30]  2  [5,10,15]
     * @param inputs Contains vector and a scalar
     * @returns Vector that is a result of division by a scalar
     * @group base
     * @shortname div
     * @drawable false
     */
    div(inputs: Inputs.Vector.VectorScalarDto): number[];
    /**
     * Computes the domain (range) between minimum and maximum values of the vector.
     * Example: [1,3,5,9]  8 (difference between last and first: 9-1)
     * @param inputs Vector information
     * @returns Number representing distance between two vectors
     * @group base
     * @shortname domain
     * @drawable false
     */
    domain(inputs: Inputs.Vector.VectorDto): number;
    /**
     * Calculates the dot product between two vectors (measures similarity/projection).
     * Example: [1,2,3]  [4,5,6]  32 (14 + 25 + 36), perpendicular vectors  0
     * @param inputs Two vectors
     * @returns Number representing dot product of the vector
     * @group base
     * @shortname dot
     * @drawable false
     */
    dot(inputs: Inputs.Vector.TwoVectorsDto): number;
    /**
     * Checks if each element in the vector is finite and returns a boolean array.
     * Example: [1, 2, Infinity, 3]  [true, true, false, true]
     * @param inputs Vector with possibly infinite values
     * @returns Vector array that contains boolean values for each number in the input
     * vector that identifies if value is finite (true) or infinite (false)
     * @group validate
     * @shortname finite
     * @drawable false
     */
    finite(inputs: Inputs.Vector.VectorDto): boolean[];
    /**
     * Checks if the vector has zero length (all elements are zero).
     * Example: [0,0,0]  true, [0,0,0.001]  false
     * @param inputs Vector to be checked
     * @returns Boolean that identifies if vector is zero length
     * @group validate
     * @shortname isZero
     * @drawable false
     */
    isZero(inputs: Inputs.Vector.VectorDto): boolean;
    /**
     * Finds an interpolated vector between two vectors using a fraction (linear interpolation).
     * Example: [0,0,0] to [10,10,10] at 0.5  [5,5,5], fraction=0  first, fraction=1  second
     * @param inputs Information for finding vector between two vectors using a fraction
     * @returns Vector that is in between two vectors
     * @group distance
     * @shortname lerp
     * @drawable false
     */
    lerp(inputs: Inputs.Vector.FractionTwoVectorsDto): number[];
    /**
     * Finds the maximum (largest) value in the vector.
     * Example: [3, 7, 2, 9, 1]  9
     * @param inputs Vector to be checked
     * @returns Largest number in the vector
     * @group extract
     * @shortname max
     * @drawable false
     */
    max(inputs: Inputs.Vector.VectorDto): number;
    /**
     * Finds the minimum (smallest) value in the vector.
     * Example: [3, 7, 2, 9, 1]  1
     * @param inputs Vector to be checked
     * @returns Lowest number in the vector
     * @group extract
     * @shortname min
     * @drawable false
     */
    min(inputs: Inputs.Vector.VectorDto): number;
    /**
     * Multiplies each element of the vector by a scalar value.
     * Example: [2,3,4]  5  [10,15,20]
     * @param inputs Vector with a scalar
     * @returns Vector that results from multiplication
     * @group base
     * @shortname mul
     * @drawable false
     */
    mul(inputs: Inputs.Vector.VectorScalarDto): number[];
    /**
     * Negates the vector (flips the sign of each element).
     * Example: [5,-3,2]  [-5,3,-2]
     * @param inputs Vector to negate
     * @returns Negative vector
     * @group base
     * @shortname neg
     * @drawable false
     */
    neg(inputs: Inputs.Vector.VectorDto): number[];
    /**
     * Computes the squared norm (squared magnitude/length) of the vector.
     * Example: [3,4,0]  25 (length 5 squared)
     * @param inputs Vector for squared norm
     * @returns Number that is squared norm
     * @group base
     * @shortname norm squared
     * @drawable false
     */
    normSquared(inputs: Inputs.Vector.VectorDto): number;
    /**
     * Calculates the norm (magnitude/length) of the vector.
     * Example: [3,4,0]  5, [1,0,0]  1
     * @param inputs Vector to compute the norm
     * @returns Number that is norm of the vector
     * @group base
     * @shortname norm
     * @drawable false
     */
    norm(inputs: Inputs.Vector.VectorDto): number;
    /**
     * Normalizes the vector into a unit vector that has a length of 1 (maintains direction, scales magnitude to 1).
     * Example: [3,4,0]  [0.6,0.8,0], [10,0,0]  [1,0,0]
     * @param inputs Vector to normalize
     * @returns Unit vector that has length of 1
     * @group base
     * @shortname normalized
     * @drawable false
     */
    normalized(inputs: Inputs.Vector.VectorDto): number[];
    /**
     * Finds a point on a ray at a given distance from the origin along the direction vector.
     * Example: Point [0,0,0] + direction [1,0,0] at distance 5  [5,0,0]
     * @param inputs Provide a point, vector and a distance for finding a point
     * @returns Vector representing point on the ray
     * @group base
     * @shortname on ray
     * @drawable false
     */
    onRay(inputs: Inputs.Vector.RayPointDto): number[];
    /**
     * Creates a 3D vector from x, y, z coordinates.
     * Example: x=1, y=2, z=3  [1,2,3]
     * @param inputs Vector coordinates
     * @returns Create a vector of xyz values
     * @group create
     * @shortname vector XYZ
     * @drawable true
     */
    vectorXYZ(inputs: Inputs.Vector.VectorXYZDto): Inputs.Base.Vector3;
    /**
     * Creates a 2D vector from x, y coordinates.
     * Example: x=3, y=4  [3,4]
     * @param inputs Vector coordinates
     * @returns Create a vector of xy values
     * @group create
     * @shortname vector XY
     * @drawable true
     */
    vectorXY(inputs: Inputs.Vector.VectorXYDto): Inputs.Base.Vector2;
    /**
     * Creates a vector of integers from 0 to max (exclusive).
     * Example: max=5  [0,1,2,3,4], max=3  [0,1,2]
     * @param inputs Max value for the range
     * @returns Vector containing items from 0 to max
     * @group create
     * @shortname range
     * @drawable false
     */
    range(inputs: Inputs.Vector.RangeMaxDto): number[];
    /**
     * Computes signed angle between two vectors using a reference vector (determines rotation direction).
     * Example: Returns positive or negative angle depending on rotation direction relative to reference
     * @param inputs Contains information of two vectors and a reference vector
     * @returns Signed angle in degrees
     * @group angles
     * @shortname signed angle
     * @drawable false
     */
    signedAngleBetween(inputs: Inputs.Vector.TwoVectorsReferenceDto): number;
    /**
     * Creates a vector containing numbers from min to max at a given step increment.
     * Example: min=0, max=10, step=2  [0,2,4,6,8,10]
     * @param inputs Span information containing min, max and step values
     * @returns Vector containing number between min, max and increasing at a given step
     * @group create
     * @shortname span
     * @drawable false
     */
    span(inputs: Inputs.Vector.SpanDto): number[];
    /**
     * Creates a vector with numbers from min to max using an easing function for non-linear distribution.
     * Example: min=0, max=100, nrItems=5, ease='easeInQuad'  creates accelerating intervals
     * @param inputs Span information containing min, max and ease function
     * @returns Vector containing numbers between min, max and increasing in non-linear steps defined by nr of items in the vector and type
     * @group create
     * @shortname span ease items
     * @drawable false
     */
    spanEaseItems(inputs: Inputs.Vector.SpanEaseItemsDto): number[];
    /**
     * Creates a vector with evenly spaced numbers from min to max with a specified number of items.
     * Example: min=0, max=10, nrItems=5  [0, 2.5, 5, 7.5, 10]
     * @param inputs Span information containing min, max and step values
     * @returns Vector containing number between min, max by giving nr of items
     * @group create
     * @shortname span linear items
     * @drawable false
     */
    spanLinearItems(inputs: Inputs.Vector.SpanLinearItemsDto): number[];
    /**
     * Subtracts the second vector from the first element-wise.
     * Example: [10,20,30] - [1,2,3]  [9,18,27]
     * @param inputs Two vectors
     * @returns Vector that result by subtraction two vectors
     * @group base
     * @shortname sub
     * @drawable false
     */
    sub(inputs: Inputs.Vector.TwoVectorsDto): number[];
    /**
     * Sums all values in the vector and returns a single number.
     * Example: [1,2,3,4]  10, [5,10,15]  30
     * @param inputs Vector to sum
     * @returns Number that results by adding up all values in the vector
     * @group base
     * @shortname sum
     * @drawable false
     */
    sum(inputs: Inputs.Vector.VectorDto): number;
    /**
     * Computes the squared length (squared magnitude) of a 3D vector.
     * Example: [3,4,0]  25 (length 5 squared)
     * @param inputs Vector to compute the length
     * @returns Number that is squared length of the vector
     * @group base
     * @shortname length squared
     * @drawable false
     */
    lengthSq(inputs: Inputs.Vector.Vector3Dto): number;
    /**
     * Computes the length (magnitude) of a 3D vector.
     * Example: [3,4,0]  5, [1,0,0]  1
     * @param inputs Vector to compute the length
     * @returns Number that is length of the vector
     * @group base
     * @shortname length
     * @drawable false
     */
    length(inputs: Inputs.Vector.Vector3Dto): number;
    /**
     * Converts an array of stringified numbers to actual numbers.
     * Example: ['1', '2.5', '3']  [1, 2.5, 3], ['10', '-5', '0.1']  [10, -5, 0.1]
     * @param inputs Array of stringified numbers
     * @returns Array of numbers
     * @group create
     * @shortname parse numbers
     * @drawable false
     */
    parseNumbers(inputs: Inputs.Vector.VectorStringDto): number[];
  }
  declare class Asset {
    assetManager: AssetManager;
    constructor();
    /**
     * Gets the asset file
     * @param inputs file name to get from project assets
     * @returns Blob of asset
     * @group get
     * @shortname cloud file
     */
    getFile(inputs: Inputs.Asset.GetAssetDto): Promise<File>;
    /**
     * Gets the text from asset file stored in your cloud account.
     * @param inputs asset name to get from project assets
     * @returns Text of asset
     * @group get
     * @shortname text file
     */
    getTextFile(inputs: Inputs.Asset.GetAssetDto): Promise<string>;
    /**
     * Gets the local asset file stored in your browser.
     * @param inputs asset name to get from local assets
     * @returns Blob of asset
     * @group get
     * @shortname local file
     */
    getLocalFile(inputs: Inputs.Asset.GetAssetDto): Promise<File | File[]>;
    /**
     * Gets the text from asset file stored in your browser.
     * @param inputs asset name to get from local assets
     * @returns Text of asset or array of texts
     * @group get
     * @shortname local text file
     */
    getLocalTextFile(
      inputs: Inputs.Asset.GetAssetDto
    ): Promise<string | string[]>;
    /**
     * Fetches the blob from the given url, must be CORS enabled accessible endpoint
     * @param inputs url of the asset
     * @returns Blob
     * @group fetch
     * @shortname fetch blob
     */
    fetchBlob(inputs: Inputs.Asset.FetchDto): Promise<Blob>;
    /**
     * Fetches the file from the given url, must be CORS enabled accessible endpoint
     * @param inputs url of the asset
     * @returns File
     * @group fetch
     * @shortname fetch file
     */
    fetchFile(inputs: Inputs.Asset.FetchDto): Promise<File>;
    /**
     * Fetches the json from the given url, must be CORS enabled accessible endpoint
     * @param inputs url of the asset
     * @returns JSON
     * @group fetch
     * @shortname fetch json
     */
    fetchJSON(inputs: Inputs.Asset.FetchDto): Promise<any>;
    /**
     * Fetches the json from the given url, must be CORS enabled accessible endpoint
     * @param inputs url of the asset
     * @returns Text
     * @group fetch
     * @shortname fetch text
     */
    fetchText(inputs: Inputs.Asset.FetchDto): Promise<string>;
    /**
     * Gets and creates the url string path to your file stored in your memory.
     * @param File or a blob
     * @returns URL string of a file
     * @group create
     * @shortname object url
     */
    createObjectURL(inputs: Inputs.Asset.FileDto): string;
    /**
     * Gets and creates the url string paths to your files stored in your memory.
     * @param Files or a blobs
     * @returns URL strings for given files
     * @group create
     * @shortname object urls
     */
    createObjectURLs(inputs: Inputs.Asset.FilesDto): string[];
    /**
     * Downloads a file with the given content, extension, and content type.
     * @param inputs file name, content, extension, and content type
     * @group download
     * @shortname download file
     */
    download(inputs: Inputs.Asset.DownloadDto): void;
  }
  declare namespace BaseTypes {
    /**
     * Interval represents an object that has two properties - min and max.
     */
    class IntervalDto {
      /**
       * Minimum value of the interval
       */
      min: number;
      /**
       * Maximum value of the interval
       */
      max: number;
    }
    /**
     * UV usually represents 2D coordinates on 3D or 2D surfaces. It is similar to XY coordinates in planes.
     */
    class UVDto {
      /**
       * U coordinate of the surface
       */
      u: number;
      /**
       * V coordinate of the surface
       */
      v: number;
    }
    /**
     * Intersection result of curve curve
     */
    class CurveCurveIntersection {
      /**
       * Point of intersection on the first curve
       */
      point0: number[];
      /**
       * Point of intersection on the second curve
       */
      point1: number[];
      /**
       * Parameter of intersection on the first curve
       */
      u0: number;
      /**
       * Parameter of intersection on the second curve
       */
      u1: number;
    }
    /**
     * Intersection result of curve and surface
     */
    class CurveSurfaceIntersection {
      /**
       * Parameter of intersection on the curve
       */
      u: number;
      /**
       * UV Parameters of intersection on the surface
       */
      uv: UVDto;
      /**
       * Point of intersection on the curve
       */
      curvePoint: number[];
      /**
       * Point of intersection on the surface
       */
      surfacePoint: number[];
    }
    /**
     * Intersection point between two surfaces
     */
    class SurfaceSurfaceIntersectionPoint {
      /**
       * UV parameters of intersection on first surface
       */
      uv0: UVDto;
      /**
       * UV parameters of intersection on second surface
       */
      uv1: UVDto;
      /**
       * Point of intersection
       */
      point: number[];
      /**
       * Distance
       */
      dist: number;
    }
  }
  /**
   * Contains various CSV parsing and generation methods.
   */
  declare class CSVBitByBit {
    /**
         * Parses CSV text to a 2D array of strings (rows and columns).
         * Example: csv='a,b,c
    1,2,3'  [['a','b','c'], ['1','2','3']]
         * @param inputs CSV text and parsing options
         * @returns 2D array of strings
         * @group parse
         * @shortname parse to array
         * @drawable false
         */
    parseToArray(inputs: Inputs.CSV.ParseToArrayDto): string[][];
    /**
         * Parses CSV text to an array of JSON objects using headers.
         * Example: csv='name,age
    John,30
    Jane,25', headerRow=0, dataStartRow=1
         *  [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]
         * @param inputs CSV text and parsing options
         * @returns Array of JSON objects
         * @group parse
         * @shortname parse to json
         * @drawable false
         */
    parseToJson<T = Record<string, string | number>>(
      inputs: Inputs.CSV.ParseToJsonDto
    ): T[];
    /**
         * Parses CSV text to JSON using custom headers (ignores CSV headers if present).
         * Example: csv='John,30
    Jane,25', headers=['name','age']
         *  [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]
         * @param inputs CSV text, custom headers, and parsing options
         * @returns Array of JSON objects
         * @group parse
         * @shortname parse to json with headers
         * @drawable false
         */
    parseToJsonWithHeaders<T = Record<string, string | number>>(
      inputs: Inputs.CSV.ParseToJsonWithHeadersDto
    ): T[];
    /**
         * Queries CSV data by column/header name and returns all values in that column.
         * Example: csv='name,age
    John,30
    Jane,25', column='name'  ['John', 'Jane']
         * @param inputs CSV text, column name, and parsing options
         * @returns Array of values from the specified column
         * @group query
         * @shortname query column
         * @drawable false
         */
    queryColumn<T = Record<string, string | number>>(
      inputs: Inputs.CSV.QueryColumnDto
    ): (string | number)[];
    /**
         * Queries CSV data and filters rows where a column matches a value.
         * Example: csv='name,age
    John,30
    Jane,25', column='age', value='30'  [{'name':'John','age':'30'}]
         * @param inputs CSV text, column name, value, and parsing options
         * @returns Array of matching rows as JSON objects
         * @group query
         * @shortname query rows by value
         * @drawable false
         */
    queryRowsByValue<T = Record<string, string | number>>(
      inputs: Inputs.CSV.QueryRowsByValueDto
    ): T[];
    /**
         * Converts a 2D array to CSV text.
         * Example: array=[['name','age'], ['John','30']]  'name,age
    John,30'
         * @param inputs 2D array and formatting options
         * @returns CSV text
         * @group generate
         * @shortname array to csv
         * @drawable false
         */
    arrayToCsv(inputs: Inputs.CSV.ArrayToCsvDto): string;
    /**
         * Converts an array of JSON objects to CSV text.
         * Example: json=[{'name':'John','age':'30'}], headers=['name','age']  'name,age
    John,30'
         * @param inputs JSON array, headers, and formatting options
         * @returns CSV text
         * @group generate
         * @shortname json to csv
         * @drawable false
         */
    jsonToCsv<T = Record<string, unknown>>(
      inputs: Inputs.CSV.JsonToCsvDto<T>
    ): string;
    /**
         * Converts an array of JSON objects to CSV text using object keys as headers.
         * Example: json=[{'name':'John','age':'30'}]  'name,age
    John,30'
         * @param inputs JSON array and formatting options
         * @returns CSV text
         * @group generate
         * @shortname json to csv auto
         * @drawable false
         */
    jsonToCsvAuto<T = Record<string, unknown>>(
      inputs: Inputs.CSV.JsonToCsvAutoDto<T>
    ): string;
    /**
         * Gets the headers from a CSV file.
         * Example: csv='name,age
    John,30', headerRow=0  ['name', 'age']
         * @param inputs CSV text and options
         * @returns Array of header names
         * @group query
         * @shortname get headers
         * @drawable false
         */
    getHeaders(inputs: Inputs.CSV.GetHeadersDto): string[];
    /**
         * Gets the number of rows in a CSV file (excluding headers if specified).
         * Example: csv='name,age
    John,30
    Jane,25', headerRow=0  2
         * @param inputs CSV text and options
         * @returns Number of data rows
         * @group query
         * @shortname row count
         * @drawable false
         */
    getRowCount(inputs: Inputs.CSV.GetRowCountDto): number;
    /**
         * Gets the number of columns in a CSV file.
         * Example: csv='name,age,city
    John,30,NYC'  3
         * @param inputs CSV text and options
         * @returns Number of columns
         * @group query
         * @shortname column count
         * @drawable false
         */
    getColumnCount(inputs: Inputs.CSV.ParseToArrayDto): number;
    private parseCsvLine;
    private escapeCsvCell;
    /**
         * Converts literal escape sequence strings to their actual characters.
         * For example, converts "\n" (two characters) to "
    " (newline character).
         */
    private convertEscapeSequences;
  }
  /**
   * Contains various json path methods.
   */
  declare class JSONBitByBit {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Stringifies the input value
     * @param inputs a value to be stringified
     * @returns string
     * @group transform
     * @shortname stringify
     * @drawable false
     */
    stringify(inputs: Inputs.JSON.StringifyDto): string;
    /**
     * Parses the input value
     * @param inputs a value to be parsed
     * @returns any
     * @group transform
     * @shortname parse
     * @drawable false
     */
    parse(inputs: Inputs.JSON.ParseDto): any;
    /**
     * Queries the input value
     * @param inputs a value to be queried
     * @returns any
     * @group jsonpath
     * @shortname query
     * @drawable false
     */
    query(inputs: Inputs.JSON.QueryDto): any;
    /**
     * Sets value on given property of the given json
     * @param inputs a value to be added, json and a property name
     * @returns any
     * @group props
     * @shortname set value on property
     * @drawable false
     */
    setValueOnProp(inputs: Inputs.JSON.SetValueOnPropDto): any;
    /**
     * Gets json from array by first property match. This is very simplistic search and only returns the first match.
     * If you need more complex search, you can use jsonpath query with filters.
     * @param inputs an array of json objects, a property name and a value to match
     * @returns any
     * @group props
     * @shortname get json from array by prop match
     * @drawable false
     */
    getJsonFromArrayByFirstPropMatch(
      inputs: Inputs.JSON.GetJsonFromArrayByFirstPropMatchDto
    ): any;
    /**
     * Gets value of the property in the given json
     * @param inputs a value to be added, json and a property name
     * @returns any
     * @group props
     * @shortname get value on property
     * @drawable false
     */
    getValueOnProp(inputs: Inputs.JSON.GetValueOnPropDto): any;
    /**
     * Sets value to the json by providing a path
     * @param inputs a value to be added, json and a path
     * @returns any
     * @group jsonpath
     * @shortname set value on path
     * @drawable false
     */
    setValue(inputs: Inputs.JSON.SetValueDto): any;
    /**
     * Sets multiple values to the json by providing paths
     * @param inputs a value to be added, json and a path
     * @returns any
     * @group jsonpath
     * @shortname set values on paths
     * @drawable false
     */
    setValuesOnPaths(inputs: Inputs.JSON.SetValuesOnPathsDto): any;
    /**
     * Find paths to elements in object matching path expression
     * @param inputs a json value and a query
     * @returns any
     * @group jsonpath
     * @shortname paths
     * @drawable false
     */
    paths(inputs: Inputs.JSON.PathsDto): any;
    /**
     * Creates an empty JavaScript object
     * @returns any
     * @group create
     * @shortname empty
     * @drawable false
     */
    createEmpty(): any;
    /**
     * Previews json and gives option to save it
     * @returns any
     * @group preview
     * @shortname json preview and save
     * @drawable false
     */
    previewAndSaveJson(inputs: Inputs.JSON.JsonDto): void;
    /**
     * Previews json
     * @returns any
     * @group preview
     * @shortname json preview
     * @drawable false
     */
    previewJson(inputs: Inputs.JSON.JsonDto): void;
  }
  declare class OCCTWIO extends OCCTIO {
    readonly occWorkerManager: OCCTWorkerManager;
    private readonly context;
    constructor(occWorkerManager: OCCTWorkerManager, context: ContextBase);
    /**
     * Imports the step or iges asset file
     * @group io
     * @shortname load step | iges
     * @returns OCCT Shape
     */
    loadSTEPorIGES(
      inputs: Inputs.OCCT.ImportStepIgesDto
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Imports the step or iges asset file from text
     * @group io
     * @shortname load text step | iges
     * @returns OCCT Shape
     */
    loadSTEPorIGESFromText(
      inputs: Inputs.OCCT.ImportStepIgesFromTextDto
    ): Promise<Inputs.OCCT.TopoDSShapePointer>;
  }
  /**
   * Contains various methods for OpenCascade implementation
   */
  declare class OCCTW extends OCCT {
    readonly context: ContextBase;
    readonly occWorkerManager: OCCTWorkerManager;
    readonly io: OCCTWIO;
    constructor(context: ContextBase, occWorkerManager: OCCTWorkerManager);
  }
  /**
   * Tags help you to put text on top of your 3D objects. Tags are heavily used in data visualization scenarios
   * where you need to convery additional textual information.
   */
  declare class Tag {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Creates a tag dto
     * @param inputs Tag description
     * @returns A tag
     */
    create(inputs: Inputs.Tag.TagDto): Inputs.Tag.TagDto;
    /**
     * Draws a single tag
     * @param inputs Information to draw the tag
     * @returns A tag
     * @ignore true
     */
    drawTag(inputs: Inputs.Tag.DrawTagDto): Inputs.Tag.TagDto;
    /**
     * Draws multiple tags
     * @param inputs Information to draw the tags
     * @returns Tags
     * @ignore true
     */
    drawTags(inputs: Inputs.Tag.DrawTagsDto): Inputs.Tag.TagDto[];
  }
  /**
   * Time functions help to create various interactions which happen in time
   */
  declare class Time {
    private context;
    constructor(context: ContextBase);
    /**
     * Registers a function to render loop
     * @param update The function to call in render loop
     */
    registerRenderFunction(update: (timePassedMs: number) => void): void;
  }
  /**
   * Contains various methods for nurbs circle.
   * These methods wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbCurveCircle {
    private readonly context;
    private readonly math;
    constructor(context: ContextBase, math: MathBitByBit);
    /**
     * Creates the circle Nurbs curve
     * @param inputs Circle parameters
     * @returns Circle Nurbs curve
     */
    createCircle(inputs: Inputs.Verb.CircleParametersDto): any;
    /**
     * Creates the arc Nurbs curve
     * @param inputs Arc parameters
     * @returns Arc Nurbs curve
     */
    createArc(inputs: Inputs.Verb.ArcParametersDto): any;
    /**
     * Gets the center point of the circle or an arc
     * @param inputs An arc or a circle Nurbs curve
     * @returns Point
     */
    center(inputs: Inputs.Verb.CircleDto): number[];
    /**
     * Gets the radius of the circle or an arc
     * @param inputs An arc or a circle Nurbs curve
     * @returns Radius
     */
    radius(inputs: Inputs.Verb.CircleDto): number;
    /**
     * Gets the max angle of the arc in degrees
     * @param inputs Arc
     * @returns Max angle in degrees
     */
    maxAngle(inputs: Inputs.Verb.CircleDto): number;
    /**
     * Gets the min angle of the arc in degrees
     * @param inputs Arc
     * @returns Min angle in degrees
     */
    minAngle(inputs: Inputs.Verb.CircleDto): number;
    /**
     * Gets the x angle of the arc
     * @param inputs Circle
     * @returns X axis vector
     */
    xAxis(inputs: Inputs.Verb.CircleDto): number[];
    /**
     * Gets the y angle of the arc
     * @param inputs Circle
     * @returns Y axis vector
     */
    yAxis(inputs: Inputs.Verb.CircleDto): number[];
  }
  /**
   * Contains various methods for nurbs ellipse.
   * These methods wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbCurveEllipse {
    private readonly context;
    private readonly math;
    constructor(context: ContextBase, math: MathBitByBit);
    /**
     * Creates the ellipse Nurbs curve
     * @param inputs Ellipse parameters
     * @returns Ellipse Nurbs curve
     */
    createEllipse(inputs: Inputs.Verb.EllipseParametersDto): any;
    /**
     * Creates the ellipse arc Nurbs curve
     * @param inputs Ellipse arc parameters
     * @returns Ellipse arc Nurbs curve
     */
    createArc(inputs: Inputs.Verb.EllipseArcParametersDto): any;
    /**
     * Gets the center point of the ellipse or an arc
     * @param inputs The arc or the ellipse Nurbs curve
     * @returns Point
     */
    center(inputs: Inputs.Verb.EllipseDto): number[];
    /**
     * Gets the max angle of the arc in degrees
     * @param inputs Arc
     * @returns Max angle in degrees
     */
    maxAngle(inputs: Inputs.Verb.EllipseDto): number;
    /**
     * Gets the min angle of the arc in degrees
     * @param inputs Arc
     * @returns Min angle in degrees
     */
    minAngle(inputs: Inputs.Verb.EllipseDto): number;
    /**
     * Gets the x angle of the arc or an ellipse
     * @param inputs Ellipse or an arc
     * @returns X axis vector
     */
    xAxis(inputs: Inputs.Verb.EllipseDto): number[];
    /**
     * Gets the y angle of the arc or an ellipse
     * @param inputs Ellipse or an arc
     * @returns Y axis vector
     */
    yAxis(inputs: Inputs.Verb.EllipseDto): number[];
  }
  /**
   * Contains various methods for nurbs curves.
   * These methods wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbCurve {
    private readonly context;
    private readonly geometryHelper;
    private readonly math;
    readonly circle: VerbCurveCircle;
    readonly ellipse: VerbCurveEllipse;
    constructor(
      context: ContextBase,
      geometryHelper: GeometryHelper,
      math: MathBitByBit
    );
    /**
     * Creates a Nurbs curve by providing knots, control points & weights
     * @param inputs Contains knots, control points and weights
     * @returns Nurbs curve
     */
    createCurveByKnotsControlPointsWeights(
      inputs: Inputs.Verb.CurveNurbsDataDto
    ): any;
    /**
     * Creates a Nurbs curve by providing control points
     * @param inputs Control points
     * @returns Nurbs curve
     */
    createCurveByPoints(inputs: Inputs.Verb.CurvePathDataDto): any;
    /**
     * Converts lines to NURBS curves
     * Returns array of the verbnurbs Line objects
     * @param inputs Lines to be transformed to curves
     * @returns Verb nurbs curves
     */
    convertLinesToNurbsCurves(inputs: Inputs.Verb.LinesDto): any[];
    /**
     * Converts line to NURBS curve
     * Returns the verbnurbs Line object
     * @param inputs Line to be transformed to curve
     * @returns Verb nurbs curves
     */
    convertLineToNurbsCurve(inputs: Inputs.Verb.LineDto): any;
    /**
     * Converts a polyline to a NURBS curve
     * Returns the verbnurbs NurbsCurve object
     * @param inputs Polyline to be transformed to curve
     * @returns Verb nurbs curve
     */
    convertPolylineToNurbsCurve(inputs: Inputs.Verb.PolylineDto): any;
    /**
     * Converts a polylines to a NURBS curves
     * Returns the verbnurbs NurbsCurve objects
     * @param inputs Polylines to be transformed to curves
     * @returns Verb nurbs curves
     */
    convertPolylinesToNurbsCurves(inputs: Inputs.Verb.PolylinesDto): any[];
    /**
     * Creates a Bezier Nurbs curve by providing control points and weights
     * @param inputs Control points
     * @returns Bezier Nurbs curve
     */
    createBezierCurve(inputs: Inputs.Verb.BezierCurveDto): any;
    /**
     * Clone the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Nurbs curve
     */
    clone(inputs: Inputs.Verb.CurveDto): any;
    /**
     * Finds the closest param on the Nurbs curve from the point
     * @param inputs Nurbs curve with point
     * @returns Param number
     */
    closestParam(inputs: Inputs.Verb.ClosestPointDto): number;
    /**
     * Finds the closest params on the Nurbs curve from the points
     * @param inputs Nurbs curve with points
     * @returns Param numbers
     */
    closestParams(inputs: Inputs.Verb.ClosestPointsDto): number[];
    /**
     * Finds the closest point on the Nurbs curve from the point
     * @param inputs Nurbs curve with point
     * @returns Point
     */
    closestPoint(inputs: Inputs.Verb.ClosestPointDto): Inputs.Base.Point3;
    /**
     * Finds the closest points on the Nurbs curve from the list of points
     * @param inputs Nurbs curve with points
     * @returns Points
     */
    closestPoints(inputs: Inputs.Verb.ClosestPointsDto): Inputs.Base.Point3[];
    /**
     * Finds the control points of the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Points
     */
    controlPoints(inputs: Inputs.Verb.CurveDto): Inputs.Base.Point3[];
    /**
     * Finds the degree of the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Degree number
     */
    degree(inputs: Inputs.Verb.CurveDto): number;
    /**
     * Finds the derivatives of the Nurbs curve at parameter
     * @param inputs Nurbs curve with specified derivative number and parameter
     * @returns Derivatives
     */
    derivatives(inputs: Inputs.Verb.CurveDerivativesDto): number[];
    /**
     * Divides the curve by equal arc length to parameters
     * @param inputs Nurbs curve
     * @returns Parameters
     */
    divideByEqualArcLengthToParams(
      inputs: Inputs.Verb.CurveSubdivisionsDto
    ): number[];
    /**
     * Divides the curve by equal arc length to points
     * @param inputs Nurbs curve
     * @returns Points
     */
    divideByEqualArcLengthToPoints(
      inputs: Inputs.Verb.CurveSubdivisionsDto
    ): Inputs.Base.Point3[];
    /**
     * Divides the curve by arc length to parameters
     * @param inputs Nurbs curve
     * @returns Parameters
     */
    divideByArcLengthToParams(
      inputs: Inputs.Verb.CurveDivideLengthDto
    ): number[];
    /**
     * Divides the curve by arc length to points
     * @param inputs Nurbs curve
     * @returns Points
     */
    divideByArcLengthToPoints(
      inputs: Inputs.Verb.CurveDivideLengthDto
    ): Inputs.Base.Point3[];
    /**
     * Divides multiple curves by equal arc length to points
     * @param inputs Nurbs curves
     * @returns Points placed for each curve in separate arrays
     */
    divideCurvesByEqualArcLengthToPoints(
      inputs: Inputs.Verb.CurvesSubdivisionsDto
    ): Inputs.Base.Point3[][];
    /**
     * Divides multiple curves by arc length to points
     * @param inputs Nurbs curves
     * @returns Points placed for each curve in separate arrays
     */
    divideCurvesByArcLengthToPoints(
      inputs: Inputs.Verb.CurvesDivideLengthDto
    ): Inputs.Base.Point3[][];
    /**
     * Finds the domain interval of the curve parameters
     * @param inputs Nurbs curve
     * @returns Interval domain
     */
    domain(inputs: Inputs.Verb.CurveDto): BaseTypes.IntervalDto;
    /**
     * Start point of the curve
     * @param inputs Nurbs curve
     * @returns Start point
     */
    startPoint(inputs: Inputs.Verb.CurveDto): Inputs.Base.Point3;
    /**
     * End point of the curve
     * @param inputs Nurbs curve
     * @returns End point
     */
    endPoint(inputs: Inputs.Verb.CurveDto): Inputs.Base.Point3;
    /**
     * Start points of the curves
     * @param inputs Nurbs curves
     * @returns Start points
     */
    startPoints(inputs: Inputs.Verb.CurvesDto): Inputs.Base.Point3[];
    /**
     * End points of the curves
     * @param inputs Nurbs curves
     * @returns End points
     */
    endPoints(inputs: Inputs.Verb.CurvesDto): Inputs.Base.Point3[];
    /**
     * Finds the knots of the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Knots
     */
    knots(inputs: Inputs.Verb.CurveDto): number[];
    /**
     * Gets the length of the Nurbs curve at specific parameter
     * @param inputs Nurbs curve and parameter
     * @returns Length
     */
    lengthAtParam(inputs: Inputs.Verb.CurveParameterDto): number;
    /**
     * Gets the length of the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Length
     */
    length(inputs: Inputs.Verb.CurveDto): number;
    /**
     * Gets the param at specified length on the Nurbs curve
     * @param inputs Nurbs curve, length and tolerance
     * @returns Parameter
     */
    paramAtLength(inputs: Inputs.Verb.CurveLengthToleranceDto): number;
    /**
     * Gets the point at specified parameter on the Nurbs curve
     * @param inputs Nurbs curve and a parameter
     * @returns Point
     */
    pointAtParam(inputs: Inputs.Verb.CurveParameterDto): Inputs.Base.Point3;
    /**
     * Gets the points at specified parameter on the Nurbs curves
     * @param inputs Nurbs curves and a parameter
     * @returns Points in arrays for each curve
     */
    pointsAtParam(inputs: Inputs.Verb.CurvesParameterDto): Inputs.Base.Point3[];
    /**
     * Reverses the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Reversed Nurbs curve
     */
    reverse(inputs: Inputs.Verb.CurveDto): any;
    /**
     * Splits the Nurbs curve in two at a given parameter
     * @param inputs Nurbs curve with parameter
     * @returns Nurbs curves
     */
    split(inputs: Inputs.Verb.CurveParameterDto): any[];
    /**
     * Tangent of the Nurbs curve at a given parameter
     * @param inputs Nurbs curve with parameter
     * @returns Tangent vector
     */
    tangent(inputs: Inputs.Verb.CurveParameterDto): Inputs.Base.Vector3;
    /**
     * Tessellates the Nurbs curve into a list of points
     * @param inputs Nurbs curve with tolerance
     * @returns Points
     */
    tessellate(inputs: Inputs.Verb.CurveToleranceDto): Inputs.Base.Point3[];
    /**
     * Transforms the Nurbs curve
     * @param inputs Nurbs curve with transformation matrixes
     * @returns Transformed curve
     */
    transform(inputs: Inputs.Verb.CurveTransformDto): any;
    /**
     * Transforms the Nurbs curves
     * @param inputs Nurbs curves with transformation matrixes
     * @returns Transformed curves
     */
    transformCurves(inputs: Inputs.Verb.CurvesTransformDto): any[];
    /**
     * Weights of the Nurbs curve
     * @param inputs Nurbs curve
     * @returns Weights
     */
    weights(inputs: Inputs.Verb.CurveDto): number[];
  }
  /**
   * Functions that allow to intersect various geometric entities and get the results
   */
  declare class VerbIntersect {
    private readonly context;
    private readonly geometryHelper;
    constructor(context: ContextBase, geometryHelper: GeometryHelper);
    /**
     * Intersects two verb Nurbs curves together and returns intersection results
     * @param inputs Two Nurbs curves
     * @returns Intersection results
     */
    curves(
      inputs: Inputs.Verb.CurveCurveDto
    ): BaseTypes.CurveCurveIntersection[];
    /**
     * Intersects curve and surface
     * @param inputs Nurbs curve and a Nurbs surface
     * @returns Intersection results
     */
    curveAndSurface(
      inputs: Inputs.Verb.CurveSurfaceDto
    ): BaseTypes.CurveSurfaceIntersection[];
    /**
     * Intersects two surfaces
     * @param inputs Nurbs curve and a Nurbs surface
     * @returns Nurbs curves along the intersection
     */
    surfaces(inputs: Inputs.Verb.SurfaceSurfaceDto): any[];
    /**
     * Gets intersection parameters on the first curve from curve-curve intersection
     * @param inputs Intersections data
     * @returns Parameters on first curve
     */
    curveCurveFirstParams(
      inputs: Inputs.Verb.CurveCurveIntersectionsDto
    ): number[];
    /**
     * Gets intersection parameters on the second curve from curve-curve intersection
     * @param inputs Intersections data
     * @returns Parameters on second curve
     */
    curveCurveSecondParams(
      inputs: Inputs.Verb.CurveCurveIntersectionsDto
    ): number[];
    /**
     * Gets intersection points on the first curve from curve-curve intersection
     * @param inputs Intersections data
     * @returns Points on first curve
     */
    curveCurveFirstPoints(
      inputs: Inputs.Verb.CurveCurveIntersectionsDto
    ): number[][];
    /**
     * Gets intersection points on the second curve from curve-curve intersection
     * @param inputs Intersections data
     * @returns Points on second curve
     */
    curveCurveSecondPoints(
      inputs: Inputs.Verb.CurveCurveIntersectionsDto
    ): number[][];
    /**
     * Gets intersection parameters on the curve from curve-surface intersection
     * @param inputs Intersections data
     * @returns Parameters on the curve
     */
    curveSurfaceCurveParams(
      inputs: Inputs.Verb.CurveSurfaceIntersectionsDto
    ): number[];
    /**
     * Gets intersection parameters on the surface from curve-surface intersection
     * @param inputs Intersections data
     * @returns Parameters on the surface
     */
    curveSurfaceSurfaceParams(
      inputs: Inputs.Verb.CurveSurfaceIntersectionsDto
    ): BaseTypes.UVDto[];
    /**
     * Gets intersection points on the curve from curve-surface intersection
     * @param inputs Intersections data
     * @returns Points on the curve
     */
    curveSurfaceCurvePoints(
      inputs: Inputs.Verb.CurveSurfaceIntersectionsDto
    ): number[][];
    /**
     * Gets intersection points on the surface from curve-surface intersection
     * @param inputs Intersections data
     * @returns Points on the surface
     */
    curveSurfaceSurfacePoints(
      inputs: Inputs.Verb.CurveSurfaceIntersectionsDto
    ): number[][];
  }
  /**
   * Conical surface functions.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurfaceConical {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Creates the conical Nurbs surface
     * @param inputs Parameters for Nurbs conical surface
     * @returns Conical Nurbs surface
     */
    create(inputs: Inputs.Verb.ConeAndCylinderParametersDto): any;
    /**
     * Get cone axis
     * @param inputs Nurbs conical surface
     * @returns Axis vector
     */
    axis(inputs: Inputs.Verb.ConeDto): number[];
    /**
     * Get cone base
     * @param inputs Nurbs conical surface
     * @returns Base point
     */
    base(inputs: Inputs.Verb.ConeDto): number[];
    /**
     * Get cone height
     * @param inputs Nurbs conical surface
     * @returns Height
     */
    height(inputs: Inputs.Verb.ConeDto): number;
    /**
     * Get cone radius
     * @param inputs Nurbs conical surface
     * @returns Radius
     */
    radius(inputs: Inputs.Verb.ConeDto): number;
    /**
     * Get cone x axis
     * @param inputs Nurbs conical surface
     * @returns X axis vector
     */
    xAxis(inputs: Inputs.Verb.ConeDto): number[];
  }
  /**
   * Cylindrical surface functions.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurfaceCylindrical {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Creates the cylindrical Nurbs surface
     * @param inputs Parameters for cylindrical Nurbs surface
     * @returns Cylindrical Nurbs surface
     */
    create(inputs: Inputs.Verb.ConeAndCylinderParametersDto): any;
    /**
     * Get cylinder axis
     * @param inputs Nurbs cylindrical surface
     * @returns Axis vector
     */
    axis(inputs: Inputs.Verb.CylinderDto): number[];
    /**
     * Get cylinder base
     * @param inputs Nurbs cylindrical surface
     * @returns Base point
     */
    base(inputs: Inputs.Verb.CylinderDto): number[];
    /**
     * Get cylinder height
     * @param inputs Nurbs cylindrical surface
     * @returns Height
     */
    height(inputs: Inputs.Verb.CylinderDto): number;
    /**
     * Get cylinder radius
     * @param inputs Nurbs cylindrical surface
     * @returns Radius
     */
    radius(inputs: Inputs.Verb.CylinderDto): number;
    /**
     * Get cylinder x axis
     * @param inputs Nurbs cylindrical surface
     * @returns X axis vector
     */
    xAxis(inputs: Inputs.Verb.CylinderDto): number[];
  }
  /**
   * Extrusion surface functions.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurfaceExtrusion {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Creates the Nurbs surface extrusion from the curve
     * @param inputs Nurbs profile curve and direction vector
     * @returns Nurbs surface
     */
    create(inputs: Inputs.Verb.ExtrusionParametersDto): any;
    /**
     * Gets the direction vector of the extrusion
     * @param inputs Extruded Nurbs surface
     * @returns Vector
     */
    direction(inputs: Inputs.Verb.ExtrusionDto): number[];
    /**
     * Gets the profile Nurbs curve of the extrusion
     * @param inputs Extruded Nurbs surface
     * @returns Profile Nurbs curve
     */
    profile(inputs: Inputs.Verb.ExtrusionDto): number[];
  }
  /**
   * Revolved surface functions.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurfaceRevolved {
    private readonly context;
    private readonly math;
    constructor(context: ContextBase, math: MathBitByBit);
    /**
     * Creates the revolved Nurbs surface
     * @param inputs Parameters for Nurbs revolved surface
     * @returns Revolved Nurbs surface
     */
    create(inputs: Inputs.Verb.RevolutionParametersDto): any;
    /**
     * Get the profile Nurbs curve of the revolved Nurbs surface
     * @param inputs Revolved Nurbs surface
     * @returns Nurbs curve
     */
    profile(inputs: Inputs.Verb.RevolutionDto): any;
    /**
     * Get the center Nurbs curve of the revolved Nurbs surface
     * @param inputs Revolved Nurbs surface
     * @returns Center point
     */
    center(inputs: Inputs.Verb.RevolutionDto): number[];
    /**
     * Get the rotation axis of the revolved Nurbs surface
     * @param inputs Revolved Nurbs surface
     * @returns Axis vector of rotation
     */
    axis(inputs: Inputs.Verb.RevolutionDto): number[];
    /**
     * Get the angle of rotation from revolved Nurbs surface
     * @param inputs Revolved Nurbs surface
     * @returns Angle in degrees
     */
    angle(inputs: Inputs.Verb.RevolutionDto): number;
  }
  /**
   * Spherical surface functions.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurfaceSpherical {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Creates the spherical Nurbs surface
     * @param inputs Parameters for Nurbs spherical surface
     * @returns Spherical Nurbs surface
     */
    create(inputs: Inputs.Verb.SphericalParametersDto): any;
    /**
     * Get the radius of the spherical Nurbs surface
     * @param inputs Spherical Nurbs surface
     * @returns Radius
     */
    radius(inputs: Inputs.Verb.SphereDto): number;
    /**
     * Get the center of the spherical Nurbs surface
     * @param inputs Spherical Nurbs surface
     * @returns Center point
     */
    center(inputs: Inputs.Verb.SphereDto): number[];
  }
  /**
   * Sweep surface functions.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurfaceSweep {
    private readonly context;
    constructor(context: ContextBase);
    /**
     * Creates the sweep Nurbs surface
     * @param inputs Parameters for Nurbs sweep surface
     * @returns Sweep Nurbs surface
     */
    create(inputs: Inputs.Verb.SweepParametersDto): any;
    /**
     * Get the profile Nurbs curve of the swept Nurbs surface
     * @param inputs Sweep Nurbs surface
     * @returns Profile Nurbs curve
     */
    profile(inputs: Inputs.Verb.SweepDto): any;
    /**
     * Get the rail Nurbs curve of the swept Nurbs surface
     * @param inputs Sweep Nurbs surface
     * @returns Rail Nurbs curve
     */
    rail(inputs: Inputs.Verb.SweepDto): any;
  }
  /**
   * Contains various functions for Nurbs surfaces.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class VerbSurface {
    private readonly context;
    private readonly geometryHelper;
    private readonly math;
    readonly cone: VerbSurfaceConical;
    readonly cylinder: VerbSurfaceCylindrical;
    readonly extrusion: VerbSurfaceExtrusion;
    readonly sphere: VerbSurfaceSpherical;
    readonly revolved: VerbSurfaceRevolved;
    readonly sweep: VerbSurfaceSweep;
    constructor(
      context: ContextBase,
      geometryHelper: GeometryHelper,
      math: MathBitByBit
    );
    /**
     * Gets the boundary edge Nurbs curves of the surface in a list
     * @param inputs Nurbs surface
     * @returns Array of curves
     */
    boundaries(inputs: Inputs.Verb.SurfaceDto): any[];
    /**
     * Creates the surface by providing 4 points as corners
     * @param inputs 4 points
     * @returns Nurbs surface
     */
    createSurfaceByCorners(inputs: Inputs.Verb.CornersDto): any;
    /**
     * Creates the Nurbs surface by providing uv knots, uv degrees, points and weights
     * @param inputs Surface creation information
     * @returns Nurbs surface
     */
    createSurfaceByKnotsControlPointsWeights(
      inputs: Inputs.Verb.KnotsControlPointsWeightsDto
    ): any;
    /**
     * Creates the Nurbs surface by lofting curves
     * @param inputs Curves to loft through
     * @returns Nurbs surface
     */
    createSurfaceByLoftingCurves(inputs: Inputs.Verb.LoftCurvesDto): any;
    /**
     * Clone the Nurbs surface
     * @param inputs Nurbs surface
     * @returns Nurbs surface
     */
    clone(inputs: Inputs.Verb.SurfaceDto): any;
    /**
     * Finds the closest parameter on the surface from the point
     * @param inputs Nurbs surface with a point
     * @returns UV parameters
     */
    closestParam(inputs: Inputs.Verb.SurfaceParamDto): BaseTypes.UVDto;
    /**
     * Finds the closest point on the surface from the point
     * @param inputs Nurbs surface with a point
     * @returns Point
     */
    closestPoint(inputs: Inputs.Verb.SurfaceParamDto): number[];
    /**
     * Gets the control points on the surface
     * @param inputs Nurbs surface
     * @returns Two dimensional array of points
     */
    controlPoints(inputs: Inputs.Verb.SurfaceDto): number[][][];
    /**
     * Gets the U degree of the surface
     * @param inputs Nurbs surface
     * @returns U degree
     */
    degreeU(inputs: Inputs.Verb.SurfaceDto): number;
    /**
     * Gets the V degree of the surface
     * @param inputs Nurbs surface
     * @returns V degree
     */
    degreeV(inputs: Inputs.Verb.SurfaceDto): number;
    /**
     * Gets the derivatives of the surface at specified uv coordinate
     * @param inputs Nurbs surface
     * @returns Two dimensional array of vectors
     */
    derivatives(inputs: Inputs.Verb.DerivativesDto): number[][][];
    /**
     * Gets the U domain of the surface
     * @param inputs Nurbs surface
     * @returns U domain as interval
     */
    domainU(inputs: Inputs.Verb.SurfaceDto): BaseTypes.IntervalDto;
    /**
     * Gets the V domain of the surface
     * @param inputs Nurbs surface
     * @returns V domain as interval
     */
    domainV(inputs: Inputs.Verb.SurfaceDto): BaseTypes.IntervalDto;
    /**
     * Gets the Nurbs isocurve on the surface
     * @param inputs Nurbs surface
     * @returns Nurbs curve
     */
    isocurve(inputs: Inputs.Verb.SurfaceParameterDto): any;
    /**
     * Subdivides surface into preferred number of isocurves
     * @param inputs Nurbs surface
     * @returns Nurbs curves
     */
    isocurvesSubdivision(inputs: Inputs.Verb.IsocurveSubdivisionDto): any[];
    /**
     * Subdivides surface into isocurves on specified array of parameters
     * @param inputs Nurbs surface
     * @returns Nurbs curves
     */
    isocurvesAtParams(inputs: Inputs.Verb.IsocurvesParametersDto): any[];
    /**
     * Gets the U knots of the surface
     * @param inputs Nurbs surface
     * @returns Knots on u direction
     */
    knotsU(inputs: Inputs.Verb.SurfaceDto): number[];
    /**
     * Gets the V knots of the surface
     * @param inputs Nurbs surface
     * @returns Knots on v direction
     */
    knotsV(inputs: Inputs.Verb.SurfaceDto): number[];
    /**
     * Gets the normal on the surface at uv coordinate
     * @param inputs Nurbs surface
     * @returns Normal vector
     */
    normal(inputs: Inputs.Verb.SurfaceLocationDto): number[];
    /**
     * Gets the point on the surface at uv coordinate
     * @param inputs Nurbs surface
     * @returns Point
     */
    point(inputs: Inputs.Verb.SurfaceLocationDto): number[];
    /**
     * Reverse the Nurbs surface. This will reverse the UV origin and isocurve directions
     * @param inputs Nurbs surface
     * @returns Nurbs surface
     */
    reverse(inputs: Inputs.Verb.SurfaceDto): any;
    /**
     * Splits the Nurbs surface in two halfs.
     * @param inputs Nurbs surface
     * @returns Two Nurbs surfaces
     */
    split(inputs: Inputs.Verb.SurfaceParameterDto): any[];
    /**
     * Transforms the Nurbs surface with a given list of transformations.
     * @param inputs Nurbs surface with transforms
     * @returns Nurbs surface
     */
    transformSurface(inputs: Inputs.Verb.SurfaceTransformDto): any;
    /**
     * Gets the weights of the surface
     * @param inputs Nurbs surface
     * @returns Two dimensional array of weights
     */
    weights(inputs: Inputs.Verb.SurfaceDto): number[][];
  }
  /**
   * Contains various functions for Nurbs curves and surfaces.
   * These functions wrap around Verbnurbs library that you can find here http://verbnurbs.com/.
   * Thanks Peter Boyer for his work.
   */
  declare class Verb {
    private readonly math;
    readonly curve: VerbCurve;
    readonly surface: VerbSurface;
    readonly intersect: VerbIntersect;
    constructor(
      context: ContextBase,
      geometryHelper: GeometryHelper,
      math: MathBitByBit
    );
  }
  declare class AdvancedAdv {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    text3d: Text3D;
    patterns: Patterns;
    navigation: Navigation;
    dimensions: Dimensions;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
  }
  declare class Dimensions {
    private readonly context;
    constructor(context: ContextComplete);
    /**
     * Creates linear dimension - a measurement line between two points with extension lines and text label.
     * The dimension shows the distance between the points and can be styled with DimensionStyleDto.
     * @example Dimensions.linearDimension({ name: "Length", startPoint: [0, 0, 0], endPoint: [5, 0, 0], direction: [0, 1, 0] });
     * @param inputs
     * @returns Create linear dimension
     * @group dimensions
     * @shortname linear dimension
     * @drawable true
     */
    linearDimension(
      inputs: Advanced.Dimensions.LinearDimensionDto
    ): Advanced.Dimensions.LinearDimensionEntity;
    /**
     * Creates angular dimension - a measurement arc between two direction vectors with extension lines and text label.
     * The dimension shows the angle between the directions and can be styled with DimensionStyleDto.
     * @example Dimensions.angularDimension({ name: "Angle", centerPoint: [0, 0, 0], direction1: [1, 0, 0], direction2: [0, 1, 0], radius: 2 });
     * @param inputs
     * @returns Create angular dimension
     * @group dimensions
     * @shortname angular dimension
     * @drawable true
     */
    angularDimension(
      inputs: Advanced.Dimensions.AngularDimensionDto
    ): Advanced.Dimensions.AngularDimensionEntity;
    /**
     * Creates radial dimension - a measurement line from center to perimeter showing radius or diameter.
     * Shows 'R' prefix for radius or '' prefix for diameter with optional center mark.
     * @example Dimensions.radialDimension({ centerPoint: [0, 0, 0], radiusPoint: [2, 0, 0], showDiameter: false });
     * @param inputs
     * @returns Create radial dimension
     * @group dimensions
     * @shortname radial dimension
     * @drawable true
     */
    radialDimension(
      inputs: Advanced.Dimensions.RadialDimensionDto
    ): Advanced.Dimensions.RadialDimensionEntity;
    /**
     * Creates diametral dimension - a measurement line spanning full diameter of circular features.
     * Shows '' prefix with optional center mark and arrows at both ends.
     * @example Dimensions.diametralDimension({ centerPoint: [0, 0, 0], direction: [1, 0, 0], diameter: 4 });
     * @param inputs
     * @returns Create diametral dimension
     * @group dimensions
     * @shortname diametral dimension
     * @drawable true
     */
    diametralDimension(
      inputs: Advanced.Dimensions.DiametralDimensionDto
    ): Advanced.Dimensions.DiametralDimensionEntity;
    /**
     * Creates ordinate dimension - shows X, Y, or Z coordinate from a reference point with leader line.
     * Useful for coordinate annotations and datum referencing in technical drawings.
     * @example Dimensions.ordinateDimension({ measurementPoint: [5, 3, 2], referencePoint: [0, 0, 0], axis: "X" });
     * @param inputs
     * @returns Create ordinate dimension
     * @group dimensions
     * @shortname ordinate dimension
     * @drawable true
     */
    ordinateDimension(
      inputs: Advanced.Dimensions.OrdinateDimensionDto
    ): Advanced.Dimensions.OrdinateDimensionEntity;
    /**
     * Create dimension style - used to style dimension lines, arrows, and text in 3D space.
     * You can customize line colors, thickness, text size, arrow size, and background colors.
     * @param inputs
     * @returns Create dimension style
     * @group style
     * @shortname dimension style
     * @drawable false
     */
    dimensionStyle(
      inputs: Advanced.Dimensions.DimensionStyleDto
    ): Advanced.Dimensions.DimensionStyleDto;
    /**
     * Draw linear dimension in 3D space
     * @param inputs
     * @returns Draw linear dimension with dispose method
     * @group linear dimension
     * @shortname draw linear dimension
     * @drawable false
     * @ignore true
     */
    drawLinearDimension(inputs: Advanced.Dimensions.LinearDimensionEntity): {
      dispose: () => void;
    };
    /**
     * Draw angular dimension in 3D space
     * @param inputs
     * @returns Draw angular dimension with dispose method
     * @group angular dimension
     * @shortname draw angular dimension
     * @drawable false
     * @ignore true
     */
    drawAngularDimension(inputs: Advanced.Dimensions.AngularDimensionEntity): {
      dispose: () => void;
    };
    /**
     * Draw radial dimension in 3D space
     * @param inputs
     * @returns Draw radial dimension with dispose method
     * @group radial dimension
     * @shortname draw radial dimension
     * @drawable false
     * @ignore true
     */
    drawRadialDimension(inputs: Advanced.Dimensions.RadialDimensionEntity): {
      dispose: () => void;
    };
    /**
     * Draw diametral dimension in 3D space
     * @param inputs
     * @returns Draw diametral dimension with dispose method
     * @group diametral dimension
     * @shortname draw diametral dimension
     * @drawable false
     * @ignore true
     */
    drawDiametralDimension(
      inputs: Advanced.Dimensions.DiametralDimensionEntity
    ): {
      dispose: () => void;
    };
    /**
     * Draw ordinate dimension in 3D space
     * @param inputs
     * @returns Draw ordinate dimension with dispose method
     * @group ordinate dimension
     * @shortname draw ordinate dimension
     * @drawable false
     * @ignore true
     */
    drawOrdinateDimension(
      inputs: Advanced.Dimensions.OrdinateDimensionEntity
    ): {
      dispose: () => void;
    };
  }
  declare class AngularDimension {
    private scene;
    private data;
    private style;
    private arc;
    private extensionLine1;
    private extensionLine2;
    private tangentExtension1;
    private tangentExtension2;
    private arrow1;
    private arrow2;
    private dimensionText3D;
    private static readonly DEFAULT_STYLE;
    constructor(options: AngularDimensionDto, scene: BABYLON.Scene);
    private createDimension;
    private createArc;
    private createArrowTailExtensions;
    private createLine;
    private createArrow;
    private createText;
    dispose(): void;
  }
  declare class DiametralDimension {
    private scene;
    private data;
    private style;
    private diameterLine;
    private centerMark;
    private arrow1;
    private arrow2;
    private dimensionText3D;
    constructor(options: DiametralDimensionDto, scene: BABYLON.Scene);
    private create;
    private createLine;
    private createCenterMark;
    private createArrow;
    private createText;
    dispose(): void;
  }
  /**
   * Service for evaluating mathematical expressions in dimension labels.
   * Supports basic arithmetic operations and template string replacement.
   */
  declare class DimensionExpressionService {
    /**
     * Evaluates a mathematical expression or template string with a given value
     * @param expression The expression to evaluate (can contain 'val' placeholder)
     * @param value The numeric value to substitute for 'val'
     * @param decimalPlaces Number of decimal places to format the result
     * @param removeTrailingZeros Whether to remove trailing zeros from the result
     * @returns The evaluated expression as a formatted string
     */
    static evaluate(
      expression: string,
      value: number,
      decimalPlaces: number,
      removeTrailingZeros?: boolean
    ): string;
    /**
     * Formats dimension text with prefix, suffix, and expression evaluation
     * @param value The numeric value to display
     * @param labelOverwrite Optional expression to evaluate instead of raw value
     * @param decimalPlaces Number of decimal places for formatting
     * @param labelSuffix Suffix to append to the text
     * @param removeTrailingZeros Whether to remove trailing zeros from the result
     * @param prefix Optional prefix to prepend to the text
     * @returns Formatted dimension text
     */
    static formatDimensionText(
      value: number,
      labelOverwrite: string | undefined,
      decimalPlaces: number,
      labelSuffix: string,
      removeTrailingZeros?: boolean,
      prefix?: string
    ): string;
    /**
     * Formats linear dimension text
     */
    static formatLinearText(
      distance: number,
      labelOverwrite: string | undefined,
      decimalPlaces: number,
      labelSuffix: string,
      removeTrailingZeros?: boolean
    ): string;
    /**
     * Formats angular dimension text
     */
    static formatAngularText(
      angle: number,
      labelOverwrite: string | undefined,
      decimalPlaces: number,
      labelSuffix: string,
      removeTrailingZeros?: boolean
    ): string;
    /**
     * Formats radial dimension text
     */
    static formatRadialText(
      radius: number,
      showDiameter: boolean,
      labelOverwrite: string | undefined,
      decimalPlaces: number,
      labelSuffix: string,
      removeTrailingZeros?: boolean
    ): string;
    /**
     * Formats diametral dimension text
     */
    static formatDiametralText(
      diameter: number,
      labelOverwrite: string | undefined,
      decimalPlaces: number,
      labelSuffix: string,
      removeTrailingZeros?: boolean
    ): string;
    /**
     * Formats ordinate dimension text
     */
    static formatOrdinateText(
      coordinate: number,
      axisName: string,
      labelOverwrite: string | undefined,
      decimalPlaces: number,
      labelSuffix: string,
      removeTrailingZeros?: boolean
    ): string;
  }
  declare class DimensionManager {
    private linearDimensions;
    private angularDimensions;
    private radialDimensions;
    private diametralDimensions;
    private ordinateDimensions;
    addLinearDimension(dimension: LinearDimension): void;
    removeLinearDimension(dimension: LinearDimension): void;
    addAngularDimension(dimension: AngularDimension): void;
    removeAngularDimension(dimension: AngularDimension): void;
    addRadialDimension(dimension: RadialDimension): void;
    removeRadialDimension(dimension: RadialDimension): void;
    addDiametralDimension(dimension: DiametralDimension): void;
    removeDiametralDimension(dimension: DiametralDimension): void;
    addOrdinateDimension(dimension: OrdinateDimension): void;
    removeOrdinateDimension(dimension: OrdinateDimension): void;
    clearAllDimensions(): void;
    dispose(): void;
  }
  /**
   * Interface for GUI text creation result
   */
  interface GuiTextElements {
    textAnchor: BABYLON.TransformNode;
    textContainer: GUI.Rectangle;
    textBlock: GUI.TextBlock;
  }
  /**
   * Service for creating shared 3D and GUI rendering elements used across all dimension types.
   * Eliminates code duplication by providing common mesh and text creation functionality.
   */
  declare class DimensionRenderingService {
    /**
     * Creates a line mesh using tube geometry with consistent styling
     * @param scene The Babylon scene
     * @param points Array of Vector3 points defining the line path
     * @param name Name for the mesh
     * @param style Dimension style containing appearance settings
     * @param dimensionType Type of dimension for metadata
     * @returns The created line mesh
     */
    static createLine(
      scene: BABYLON.Scene,
      points: BABYLON.Vector3[],
      name: string,
      style: DimensionStyleDto,
      dimensionType: string
    ): BABYLON.Mesh;
    /**
     * Creates an arrow mesh (cone) with consistent styling
     * @param scene The Babylon scene
     * @param position Position for the arrow
     * @param direction Direction the arrow should point
     * @param name Name for the mesh
     * @param style Dimension style containing appearance settings
     * @param dimensionType Type of dimension for metadata
     * @returns The created arrow mesh
     */
    static createArrow(
      scene: BABYLON.Scene,
      position: BABYLON.Vector3,
      direction: BABYLON.Vector3,
      name: string,
      style: DimensionStyleDto,
      dimensionType: string
    ): BABYLON.Mesh;
    /**
     * Creates a 3D text mesh using DimensionText3D
     * @param scene The Babylon scene
     * @param text The text content
     * @param position Position for the text
     * @param style Dimension style containing appearance settings
     * @returns The created DimensionText3D instance
     */
    static create3DText(
      scene: BABYLON.Scene,
      text: string,
      position: BABYLON.Vector3,
      style: DimensionStyleDto
    ): DimensionText3D;
    /**
     * Creates GUI text elements (anchor, container, text block) with consistent styling
     * @param scene The Babylon scene
     * @param adt Advanced Dynamic Texture for GUI
     * @param text The text content
     * @param position Position for the text anchor
     * @param style Dimension style containing appearance settings
     * @param dimensionType Type of dimension for unique IDs
     * @returns Object containing the created GUI elements
     */
    static createGuiText(
      scene: BABYLON.Scene,
      adt: GUI.AdvancedDynamicTexture,
      text: string,
      position: BABYLON.Vector3,
      style: DimensionStyleDto
    ): GuiTextElements;
    /**
     * Creates a center mark (crossing lines) for radial/diametral dimensions
     * @param scene The Babylon scene
     * @param center Center position for the mark
     * @param style Dimension style containing appearance settings
     * @param dimensionType Type of dimension for metadata
     * @returns The merged center mark mesh
     */
    static createCenterMark(
      scene: BABYLON.Scene,
      center: BABYLON.Vector3,
      style: DimensionStyleDto,
      dimensionType: string
    ): BABYLON.Mesh;
  }
  /**
   * Manages shared services and utilities for all dimension classes.
   * Provides singleton pattern for occlusion services and shared utilities.
   */
  declare class DimensionServiceManager {
    private static idCounter;
    /**
     * Generates unique IDs for dimensions using a counter-based approach
     */
    static generateId(type: string): string;
    /**
     * Creates Vector3 from array efficiently
     */
    static createVector3FromArray(
      arr: [number, number, number]
    ): BABYLON.Vector3;
    /**
     * Creates a fresh material for dimension elements
     * No caching to avoid issues with disposed materials and external scene cleanup
     */
    static getDimensionMaterial(
      scene: BABYLON.Scene,
      color: string,
      materialType?: "line" | "arrow"
    ): BABYLON.StandardMaterial;
  }
  interface Text3DOptions {
    text: string;
    position: BABYLON.Vector3;
    size?: number;
    fontWeight?: number;
    color?: string;
    backgroundColor?: string;
    backgroundOpacity?: number;
    backgroundStroke?: boolean;
    backgroundStrokeThickness?: number;
    backgroundRadius?: number;
    stableSize?: boolean;
    billboardMode?: boolean;
    alwaysOnTop?: boolean;
    name?: string;
  }
  /**
   * Helper class for creating 3D text labels that properly participate in depth testing
   * and rendering within the 3D scene.
   */
  declare class DimensionText3D {
    private scene;
    private textMesh;
    private material;
    private dynamicTexture;
    private options;
    constructor(scene: BABYLON.Scene, options: Text3DOptions);
    private createTextMesh;
    private setupDistanceScaling;
    private measureText;
    /**
     * Update the text content
     */
    updateText(newText: string): void;
    /**
     * Update the position of the text mesh
     */
    updatePosition(position: BABYLON.Vector3): void;
    /**
     * Get the text mesh for further manipulation
     */
    getMesh(): BABYLON.Mesh | null;
    /**
     * Dispose all resources
     */
    dispose(): void;
  }
  declare class LinearDimension {
    private scene;
    private data;
    private style;
    private dimensionLine;
    private extensionLine1;
    private extensionLine2;
    private arrow1;
    private arrow2;
    private arrowTail1;
    private arrowTail2;
    private dimensionText3D;
    private static readonly DEFAULT_STYLE;
    constructor(options: LinearDimensionDto, scene: BABYLON.Scene);
    private createDimension;
    private createLine;
    private createArrow;
    private createText;
    dispose(): void;
  }
  declare class OrdinateDimension {
    private scene;
    private data;
    private style;
    private leaderLine;
    private arrow;
    private dimensionText3D;
    constructor(options: OrdinateDimensionDto, scene: BABYLON.Scene);
    private create;
    private calculateOffsetDirection;
    private createLine;
    private createArrow;
    private createText;
    dispose(): void;
  }
  declare class RadialDimension {
    private scene;
    private data;
    private style;
    private radiusLine;
    private centerMark;
    private arrow;
    private dimensionText3D;
    constructor(options: RadialDimensionDto, scene: BABYLON.Scene);
    private create;
    private createLine;
    private createCenterMark;
    private createArrow;
    private createText;
    dispose(): void;
  }
  declare class CameraManager {
    private scene;
    private camera;
    private readonly animationFrameRate;
    private readonly animationDurationInFrames;
    constructor(scene: BABYLON.Scene);
    flyTo(newPosition: BABYLON.Vector3, newTarget: BABYLON.Vector3): void;
  }
  declare class PointOfInterest {
    private scene;
    private data;
    private style;
    private time;
    private pointSphere;
    private pulseRing;
    private clickSphere;
    private labelText;
    private labelContainer;
    private containerNode;
    private pointMaterial;
    private pulseMaterial;
    private camera;
    private static readonly DEFAULT_STYLE;
    constructor(
      options: PointOfInterestDto,
      scene: BABYLON.Scene,
      onClick: () => void
    );
    private create3DVisual;
    private setupDistanceScaling;
    private updateLabelPosition;
    private createMaterials;
    private createLabelText;
    private updateLabelText;
    private setupInteractions;
    /** Animates the pulse effect using torus scaling and visibility changes for a ring effect. */
    animatePulse(): void;
    dispose(): void;
  }
  declare class Navigation {
    private readonly context;
    constructor(context: ContextComplete);
    /**
     * Creates point of interest - clickable indicator in 3D space that can be used to fly the camera to a specific location with predefined camera position and target.
     *  Point of interest can be styled with PointOfInterestStyleDto and animated with pulse effect.
     *  Point of interest can also have a text label.
     * @example Navigation.pointOfInterest({ name: "Entrance", position: [0, 1, 0], cameraPosition: [10, 10, 10], cameraTarget: [0, 0, 0] });
     * @param inputs
     * @returns Create point of interest
     * @group point of interest
     * @shortname point of interest
     * @drawable true
     */
    pointOfInterest(
      inputs: Advanced.Navigation.PointOfInterestDto
    ): Advanced.Navigation.PointOfInterestEntity;
    /**
     * Create point of interest style - used to style point of interest indicators in 3D space.
     *  You can customize point size, color, hover color, pulse effect, text label color and size.
     * @param inputs
     * @returns Create point of interest style
     * @group point of interest
     * @shortname point of interest style
     * @drawable false
     */
    pointOfInterestStyle(
      inputs: Advanced.Navigation.PointOfInterestStyleDto
    ): Advanced.Navigation.PointOfInterestStyleDto;
    /**
     * Zoom camera to fit specified meshes in the scene with smooth animation.
     * Works only with ArcRotateCamera. Animation can be interrupted if called multiple times.
     * @param inputs Configuration for zoom operation including meshes, children inclusion, and animation speed
     * @returns void
     * @group camera
     * @shortname zoom on
     * @drawable false
     */
    zoomOn(inputs: Advanced.Navigation.ZoomOnDto): Promise<void>;
    /**
     * Zoom camera to fit specified meshes in the scene with smooth animation, considering exact screen aspect ratio.
     * Unlike zoomOn, this method precisely calculates camera distance based on viewport dimensions and mesh bounding box
     * to ensure better fit at padding=0. Works only with ArcRotateCamera. Animation can be interrupted if called multiple times.
     * @param inputs Configuration for zoom operation including meshes, children inclusion, and animation speed
     * @returns void
     * @group camera
     * @shortname zoom on aspect
     * @drawable false
     */
    zoomOnAspect(inputs: Advanced.Navigation.ZoomOnDto): Promise<void>;
    /**
     * Focus camera on specified meshes from a specific angle with smooth animation.
     * Computes the center of the bounding box of all meshes and positions the camera
     * at the specified orientation vector to look at the center.
     * Works only with ArcRotateCamera. Animation can be interrupted if called multiple times.
     * @param inputs Configuration for focus operation including meshes, orientation, distance, and animation speed
     * @returns void
     * @group camera
     * @shortname focus from angle
     * @drawable false
     */
    focusFromAngle(
      inputs: Advanced.Navigation.FocusFromAngleDto
    ): Promise<void>;
    /**
     * Create fly through node
     * @param inputs
     * @returns Create fly through node
     * @group point of interest
     * @shortname fly through node
     * @drawable false
     * @ignore true
     */
    drawPointOfInterest(inputs: Advanced.Navigation.PointOfInterestEntity): {
      dispose: () => void;
    };
  }
  declare class FacePatterns {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    pyramidSimple: PyramidSimple;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
  }
  declare class PyramidSimple {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
    /**
     * Creates a simple pyramid pattern on faces
     * @param inputs
     * @returns pyramid shapes along the wire
     * @group create
     * @shortname create simple pyramid
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    createPyramidSimple(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<
      Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Creates a simple pyramid pattern on faces with affectors that change the height
     * @param inputs uv numbers, affector points and affector weights -1 to 1
     * @returns pyramid shapes along the wire
     * @group create
     * @shortname create simple pyramid affector
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    createPyramidSimpleAffectors(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleAffectorsDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<
      Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws pyramids on the screen
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<Mesh>;
    /**
     * Gets the compound shape of all the pyramids
     * @param inputs pyramid model
     * @returns Compound shape of the pyramid
     * @group get shapes
     * @shortname get compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the compound shape on the face
     * @param inputs pyramid model and face index
     * @returns Compound shape of the pyramids on the face
     * @group get shapes
     * @shortname get compound on face
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getCompoundShapeOnFace(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the compound shape of the pyramid on the face at particular index
     * @param inputs
     * @returns Compound shape of the pyramid
     * @group get shapes
     * @shortname get compound cell on face
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getCompoundShapeCellOnFace(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceCellIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets all of the pyramid cells. This is usually in between action to then read particular information of the cells themselves.
     * @param inputs
     * @returns Compound shape of the pyramid
     * @group get cells
     * @shortname get all cells
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getAllPyramidCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleCellPart<Inputs.OCCT.TopoDSShapePointer>[];
    /**
     * Gets pyramid cells on the face. This is usually in between action to then read particular information of the cells themselves.
     * @param inputs
     * @returns Cells of the pyramid
     * @group get cells
     * @shortname get cells on face
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getAllPyramidCellsOnFace(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleCellPart<Inputs.OCCT.TopoDSShapePointer>[];
    /**
     * Gets pyramid cells on the face. This is usually in between action to then read particular information of the cells themselves.
     * @param inputs
     * @returns Cells of the pyramid
     * @group get cells
     * @shortname get cells on face
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getAllPyramidUCellsOnFace(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleCellPart<Inputs.OCCT.TopoDSShapePointer>[];
    /**
     * Gets pyramid cells on the face at u index along v direction. This is usually in between action to then read particular information of the cells themselves.
     * @param inputs
     * @returns Cells of the pyramid
     * @group get cells
     * @shortname get cells on face at u
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getAllPyramidUCellsOnFaceAtU(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceCellsUIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleCellPart<Inputs.OCCT.TopoDSShapePointer>[];
    /**
     * Gets pyramid cells on the face at v index along u direction. This is usually in between action to then read particular information of the cells themselves.
     * @param inputs
     * @returns Cells of the pyramid
     * @group get cells
     * @shortname get cells on face at v
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getAllPyramidUCellsOnFaceAtV(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceCellsVIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleCellPart<Inputs.OCCT.TopoDSShapePointer>[];
    /**
     * Gets pyramid cell on the face at u and v index. This is usually in between action to then read particular information of the cell itself.
     * @param inputs
     * @returns Cell of the pyramid
     * @group get cell
     * @shortname get cell
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getCellOnIndex(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceCellIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleCellPart<Inputs.OCCT.TopoDSShapePointer>;
    /**
     * Gets the top points of cells
     * @param inputs cells of the pyramid
     * @returns Top points on the cells
     * @group get from cells
     * @shortname get top points
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getTopPointsOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the center point between cell corners
     * @param inputs cells of the pyramid
     * @returns Center points on the cells
     * @group get from cells
     * @shortname get center points
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getCenterPointsOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the corner points of cells
     * @param inputs cells of the pyramid
     * @returns Corner points on cells provided
     * @group get from cells
     * @shortname get corner points of cells
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getCornerPointsOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[][];
    /**
     * Gets the corner points of cells
     * @param inputs cells of the pyramid
     * @returns Corner points on cells provided
     * @group get from cells
     * @shortname get corner point of cells
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getCornerPointOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the corner normal of cells
     * @param inputs cells of the pyramid
     * @returns Corner normals on cells provided
     * @group get from cells
     * @shortname get corner normal of cells
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getCornerNormalOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the corner normals of cells
     * @param inputs cells of the pyramid
     * @returns Corner normals on cells provided
     * @group get from cells
     * @shortname get corner normals of cells
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable false
     */
    getCornerNormalsOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[][];
    /**
     * Gets the compound shapes of the pyramid cells
     * @param inputs cells of the pyramid
     * @returns Compound shapes on cells provided
     * @group get from cells
     * @shortname get compound shapes
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getCompoundShapesOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets the face shapes of the pyramid cells provided
     * @param inputs cells of the pyramid
     * @returns Face shapes on cells provided
     * @group get from cells
     * @shortname get face shapes
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getFaceShapesOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets the face shapes of the pyramid cells provided
     * @param inputs cells of the pyramid
     * @returns Wire shapes on cells provided
     * @group get from cells
     * @shortname get wire shapes
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getWireShapesOfCells(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelCellsIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets the polyline wire along the start edge of the face's U direction
     * @param inputs pyramid model and face index
     * @returns Wire shapes
     * @group get from face
     * @shortname get start polyline wire u
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getStartPolylineWireU(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the polyline wire along the end edge of the face's U direction
     * @param inputs pyramid model and face index
     * @returns Wire shapes
     * @group get from face
     * @shortname get end polyline wire u
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getEndPolylineWireU(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the polyline wire along the start edge of the face's V direction
     * @param inputs pyramid model and face index
     * @returns Wire shapes
     * @group get from face
     * @shortname get start polyline wire v
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getStartPolylineWireV(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the polyline wire along the end edge of the face's V direction
     * @param inputs pyramid model and face index
     * @returns Wire shapes
     * @group get from face
     * @shortname get end polyline wire v
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getEndPolylineWireV(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the polyline wires along U direction
     * @param inputs pyramid model and face index
     * @returns Wire shapes
     * @group get from face
     * @shortname get compound polyline wires u
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getPolylineWiresUCompound(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the polyline wires along V direction
     * @param inputs pyramid model and face index
     * @returns Wire shapes
     * @group get from face
     * @shortname get compound polyline wires v
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/advanced/patterns/pyramid-simple.jpeg
     * @drawable true
     */
    getPolylineWiresVCompound(
      inputs: Advanced.Patterns.FacePatterns.PyramidSimple.PyramidSimpleModelFaceIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
  }
  declare class Patterns {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    facePatterns: FacePatterns;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
  }
  declare class Text3D {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
    /**
     * Creates a 3d text
     * @param inputs
     * @returns 3d text
     * @group create
     * @shortname create 3d text
     * @drawable true
     */
    create(
      inputs: Advanced.Text3D.Text3DDto
    ): Promise<Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>>;
    /**
     * Creates a 3d text with a font URL
     * This is useful when you want to use a custom font that is not included in the library.
     * The font will be loaded from the provided URL and used to generate the 3d text.
     * Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts.
     * Font formats supported are: ttf, otf, woff.
     * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
     * @param inputs
     * @returns 3d text
     * @group create
     * @shortname create 3d text with url
     * @drawable true
     */
    createWithUrl(
      inputs: Advanced.Text3D.Text3DUrlDto
    ): Promise<Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>>;
    /**
     * Creates a 3d text on the face
     * @param inputs
     * @returns 3d text
     * @group create
     * @shortname create 3d text on face
     * @drawable true
     */
    createTextOnFace(
      inputs: Advanced.Text3D.Text3DFaceDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>>;
    /**
     * Creates a 3d text on the face using a font URL.
     * This is useful when you want to use a custom font that is not included in the library.
     * The font will be loaded from the provided URL and used to generate the 3d text.
     * Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts.
     * Font formats supported are: ttf, otf, woff.
     * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
     * @param inputs
     * @returns 3d text
     * @group create
     * @shortname create 3d text on face url
     * @drawable true
     */
    createTextOnFaceUrl(
      inputs: Advanced.Text3D.Text3DFaceUrlDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>>;
    /**
     * Creates 3d texts on the face from multiple definitions
     * @param inputs
     * @returns 3d text
     * @group create
     * @shortname create 3d texts on face
     * @drawable true
     */
    createTextsOnFace(
      inputs: Advanced.Text3D.Texts3DFaceDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>>;
    /**
     * Creates 3d texts on the face from multiple url definitions
     * This is useful when you want to use a custom font that is not included in the library.
     * The font will be loaded from the provided URL and used to generate the 3d text.
     * Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts.
     * Font formats supported are: ttf, otf, woff.
     * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
     * @param inputs
     * @returns 3d text
     * @group create
     * @shortname create 3d texts on face url
     * @drawable true
     */
    createTextsOnFaceUrl(
      inputs: Advanced.Text3D.Texts3DFaceUrlDto<Inputs.OCCT.TopoDSFacePointer>
    ): Promise<Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>>;
    /**
     * Creates 3d text that will be used on the face defintion
     * @param inputs
     * @returns definition
     * @group definitions
     * @shortname 3d text face def
     * @drawable false
     */
    definition3dTextOnFace(
      inputs: Advanced.Text3D.Text3DFaceDefinitionDto
    ): Advanced.Text3D.Text3DFaceDefinitionDto;
    /**
     * Creates 3d text that will be used on the face url defintion
     * This is useful when you want to use a custom font that is not included in the library.
     * The font will be loaded from the provided URL and used to generate the 3d text.
     * Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts.
     * Font formats supported are: ttf, otf, woff.
     * Please note that Woff2 is not supported by opentype.js as it is a compressed format.
     * @param inputs
     * @returns definition
     * @group definitions
     * @shortname 3d text face url def
     * @drawable false
     */
    definition3dTextOnFaceUrl(
      inputs: Advanced.Text3D.Text3DFaceDefinitionUrlDto
    ): Advanced.Text3D.Text3DFaceDefinitionUrlDto;
    /**
     * Draws 3d text on the screen
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      inputs: Advanced.Text3D.Text3DData<Inputs.OCCT.TopoDSShapePointer>,
      precision?: number
    ): Promise<BABYLON.Mesh>;
    /**
     * Gets compounded shape of the 3d text result
     * @param inputs
     * @returns compounded OCCT shape
     * @group get
     * @shortname compound shape
     * @drawable true
     */
    getCompoundShape(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the character shape at particular index
     * @param inputs
     * @returns character OCCT shape of the 3d text result at index
     * @group get
     * @shortname character shape
     * @drawable true
     */
    getCharacterShape(
      inputs: Advanced.Text3D.Text3DLetterByIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets character shapes of the 3d text result
     * @param inputs
     * @returns character OCCT shapes of the 3d text result
     * @group get
     * @shortname character shapes
     * @drawable true
     */
    getCharacterShapes(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets the center of mass coordinates of all characters
     * @param inputs
     * @returns character coordinates as points
     * @group get
     * @shortname character coordinates
     * @drawable true
     */
    getCharacterCenterCoordinates(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the face cutout from text 3d that was created on the face
     * @param inputs
     * @returns character coordinates as points
     * @group get from face
     * @shortname face cutout
     * @drawable true
     */
    getFaceCutout(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets all of the face cutouts from text 3d that was created on the original face
     * @param inputs
     * @returns character coordinates as points
     * @group get from face
     * @shortname get all coutout faces
     * @drawable true
     */
    getAllFacesOfCutout(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets character face cutouts from text 3d that was created on the original face
     * @param inputs
     * @returns character coordinates as points
     * @group get from face
     * @shortname get faces in characters
     * @drawable true
     */
    getCutoutsInsideCharacters(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Get advance width
     * @param inputs
     * @returns width dimension
     * @group dimensions
     * @shortname get advance width
     * @drawable false
     */
    getAdvanceWidth(
      inputs: Advanced.Text3D.Text3DModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): number;
  }
  declare class ContextComplete extends Context {
    advancedDynamicTextureForFullscreenUI: GUI.AdvancedDynamicTexture;
    pointsOfInterestSystem: {
      observer: BABYLON.Observer<BABYLON.Scene>;
      pois: BABYLON.Nullable<PointOfInterest>[];
      cameraManager: CameraManager;
    };
    dimensionsSystem: {
      dimensionManager: DimensionManager;
    };
  }
  declare class DrawComplete extends Draw {
    /**
     * @ignore true
     */
    readonly drawHelper: DrawHelper;
    /**
     * @ignore true
     */
    readonly node: BabylonNode;
    /**
     * @ignore true
     */
    readonly tag: Tag;
    /**
     * @ignore true
     */
    private readonly things;
    /**
     * @ignore true
     */
    private readonly advanced;
    /**
     * @ignore true
     */
    readonly context: Context;
    constructor(
      /**
       * @ignore true
       */
      drawHelper: DrawHelper,
      /**
       * @ignore true
       */
      node: BabylonNode,
      /**
       * @ignore true
       */
      tag: Tag,
      /**
       * @ignore true
       */
      things: ThingsAdv,
      /**
       * @ignore true
       */
      advanced: AdvancedAdv,
      /**
       * @ignore true
       */
      context: Context
    );
    /**
     * Draws any kind of geometry after all input promises are resolved. Inputs can also be non-promise like.
     * @param inputs Contains options and entities to be drawn
     * @returns BabylonJS Mesh Promise
     * @group draw
     * @shortname draw anything
     * @disposableOutput true
     */
    drawAnyAsync(inputs: Inputs.Draw.DrawAny): Promise<any>;
    /**
     * Draws a grid mesh on the ground plane in 3D space. This helps to orient yourself in the world.
     * @param inputs Describes various parameters of the grid mesh like size, colour, etc.
     * @group draw
     * @shortname draw grid
     * @disposableOutput true
     */
    drawGridMesh(inputs: Inputs.Draw.SceneDrawGridMeshDto): BABYLON.Mesh;
    /**
     * Creates draw options for basic geometry types like points, lines, polylines, surfaces and jscad meshes
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname simple
     */
    optionsSimple(
      inputs: Inputs.Draw.DrawBasicGeometryOptions
    ): Inputs.Draw.DrawBasicGeometryOptions;
    /**
     * Creates draw options for occt shape geometry like edges, wires, faces, shells, solids and compounds
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname occt shape
     */
    optionsOcctShape(
      inputs: Inputs.Draw.DrawOcctShapeOptions
    ): Inputs.Draw.DrawOcctShapeOptions;
    /**
     * Creates draw options for babylon js nodes
     * @param inputs option definition
     * @returns options
     * @group options
     * @shortname babylon node
     */
    optionsBabylonNode(
      inputs: Inputs.Draw.DrawNodeOptions
    ): Inputs.Draw.DrawNodeOptions;
  }
  declare class CreateMaterialDto {
    constructor(s: CreateMaterialDto);
    name: string;
    scene: BABYLON.Scene | undefined;
    wAng?: number;
    uScale?: number;
    vScale?: number;
    color?: string;
    albedoTextureUrl?: string;
    microSurfaceTextureUrl?: string;
    bumpTextureUrl?: string;
    metallic: number;
    roughness: number;
    zOffset: number;
  }
  declare class MaterialsService {
    static textures: {
      wood1: {
        microSurfaceTexture: string;
        light: {
          albedo: string;
        };
        dark: {
          albedo: string;
        };
      };
      wood2: {
        microSurfaceTexture: string;
        light: {
          albedo: string;
        };
      };
      metal1: {
        microSurfaceTexture: string;
        light: {
          albedo: string;
          normalGL: string;
          roughness: string;
          metalness: string;
        };
      };
      brownPlanks: {
        microSurfaceTexture: string;
        light: {
          albedo: string;
        };
      };
      woodenPlanks: {
        microSurfaceTexture: string;
        light: {
          albedo: string;
        };
      };
      brushedConcrete: {
        microSurfaceTexture: string;
        sand: {
          albedo: string;
        };
        grey: {
          albedo: string;
        };
      };
      rock1: {
        microSurfaceTexture: string;
        default: {
          albedo: string;
          roughness: string;
        };
      };
    };
    static simpleBlackMaterial(scene: any): BABYLON.PBRMaterial;
    static rock1Material(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static wood1Material(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static wood2Material(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static wood3Material(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static brownPlanks(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static woodenPlanks(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static glass(
      scene: BABYLON.Scene,
      albedoColor: string
    ): BABYLON.PBRMaterial;
    static brushedConcrete(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static metal1(
      scene: BABYLON.Scene,
      wAng: number,
      scale: number
    ): BABYLON.PBRMaterial;
    static roughPlastic(
      scene: BABYLON.Scene,
      color: string
    ): BABYLON.PBRMaterial;
    private static createMaterial;
    private static createTexture;
  }
  declare class ThreeDPrinting {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    vases: Vases;
    medals: Medals;
    cups: Cups;
    desktop: Desktop;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class Boxes {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    spicyBox: SpicyBox;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
  }
  declare class SpicyBox {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
    /**
     * Creates a spicy box model for your spices
     * @param inputs
     * @returns Spicy box model
     * @group create
     * @shortname spicy box
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/dragon-cup.jpeg
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Boxes.SpicyBox.SpicyBoxDto
    ): Promise<
      Things.ThreeDPrinting.Boxes.SpicyBox.SpicyBoxData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the spicy box
     * @param inputs
     * @returns Compound shape of the spicy box model
     * @group get shapes
     * @shortname compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/dragon-cup.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.ThreeDPrinting.Boxes.SpicyBox.SpicyBoxModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Draws spicy box model in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/dragon-cup.jpeg
     * @ignore true
     */
    drawModel(
      inputs: Things.ThreeDPrinting.Boxes.SpicyBox.SpicyBoxData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<BABYLON.Mesh>;
  }
  declare class CalmCup {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a cup model for your calm moments
     * @param inputs
     * @returns Calm cup model
     * @group create
     * @shortname calm cup
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/calm-cup.jpeg
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Cups.CalmCup.CalmCupDto
    ): Promise<
      Things.ThreeDPrinting.Cups.CalmCup.CalmCupData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws calm cup model in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/calm-cup.jpeg
     * @ignore true
     */
    drawModel(
      inputs: Things.ThreeDPrinting.Cups.CalmCup.CalmCupData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a cup model
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose calm cup
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.ThreeDPrinting.Vases.SerenitySwirl.SerenitySwirlData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
  }
  declare class Cups {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    calmCup: CalmCup;
    dragonCup: DragonCup;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class DragonCup {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw
    );
    /**
     * Creates a cup model for your inner dragon
     * @param inputs
     * @returns Dragon cup model
     * @group create
     * @shortname dragon cup
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/dragon-cup.jpeg
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Cups.DragonCup.DragonCupDto
    ): Promise<
      Things.ThreeDPrinting.Cups.DragonCup.DragonCupData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the dragon cup
     * @param inputs
     * @returns Compound shape of the dragon cup model
     * @group get shapes
     * @shortname compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/dragon-cup.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.ThreeDPrinting.Cups.DragonCup.DragonCupModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Draws dragon cup model in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/cups/dragon-cup.jpeg
     * @ignore true
     */
    drawModel(
      inputs: Things.ThreeDPrinting.Cups.DragonCup.DragonCupData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<BABYLON.Mesh>;
  }
  declare class Desktop {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    phoneNest: PhoneNest;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class PhoneNest {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a phone nest model
     * @param inputs
     * @returns phone nest model
     * @group create
     * @shortname phone nest
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/desktop/phone-nest.jpeg
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestDto
    ): Promise<
      Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the phone nest
     * @param inputs
     * @returns Compound shape of the phone nest model
     * @group get shapes
     * @shortname compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/desktop/phone-nest.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Creates draw options for model
     * @param inputs
     * @returns Draw options
     * @group draw
     * @shortname phone nest draw options
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/desktop/phone-nest.jpeg
     * @drawable false
     */
    drawOptions(
      inputs: Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestDrawDto<BABYLON.PBRMetallicRoughnessMaterial>;
    /**
     * Draws phone nest model in default settings
     * @param model Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/desktop/phone-nest.jpeg
     * @ignore true
     */
    drawModel(
      model: Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestData<Inputs.OCCT.TopoDSShapePointer>,
      options: Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a model
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose phone nest
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.ThreeDPrinting.Desktop.PhoneNest.PhoneNestData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates materials
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname creates default materials
     * @drawable false
     * @ignore true
     */
    private createMaterials;
  }
  declare class EternalLove {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a eternal love medal model
     * @param inputs
     * @returns Eternal love model
     * @group create
     * @shortname eternal love
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/Medals/EternalLove.jpeg
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Medals.EternalLove.EternalLoveDto
    ): Promise<
      Things.ThreeDPrinting.Medals.EternalLove.EternalLoveData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws wingtip villa in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      inputs: Things.ThreeDPrinting.Medals.EternalLove.EternalLoveData<Inputs.OCCT.TopoDSShapePointer>,
      precision?: number
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a wingtip villa model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose wingtip villa
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.ThreeDPrinting.Vases.SerenitySwirl.SerenitySwirlData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
  }
  declare class Medals {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    eternalLove: EternalLove;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class ArabicArchway {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a arabic archway vase
     * @param inputs
     * @returns Arabic archway mesh
     * @group create
     * @shortname arabic archway
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/Vases/ArabicArchway.jpeg
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Vases.ArabicArchway.ArabicArchwayDto
    ): Promise<
      Things.ThreeDPrinting.Vases.ArabicArchway.ArabicArchwayData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws arabic archway in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      model: Things.ThreeDPrinting.Vases.ArabicArchway.ArabicArchwayData<Inputs.OCCT.TopoDSShapePointer>,
      precision?: number
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a arabic archway model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose arabic archway
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.ThreeDPrinting.Vases.ArabicArchway.ArabicArchwayData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    private createMaterials;
    private createOpaqueMaterial;
    private createBaseMaterial;
    private createGlassMaterial;
  }
  declare class SerenitySwirl {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a serenity swirl
     * @param inputs
     * @returns Serenity swirl mesh
     * @group create
     * @shortname serenity swirl
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/3dprinting/Vases/SerenitySwirl.webp
     * @drawable true
     */
    create(
      inputs: Things.ThreeDPrinting.Vases.SerenitySwirl.SerenitySwirlDto
    ): Promise<
      Things.ThreeDPrinting.Vases.SerenitySwirl.SerenitySwirlData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws wingtip villa in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      inputs: Things.ThreeDPrinting.Vases.SerenitySwirl.SerenitySwirlData<Inputs.OCCT.TopoDSShapePointer>,
      precision?: number
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a wingtip villa model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose wingtip villa
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.ThreeDPrinting.Vases.SerenitySwirl.SerenitySwirlData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
  }
  declare class Vases {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    serenitySwirl: SerenitySwirl;
    arabicArchway: ArabicArchway;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class Architecture {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    houses: Houses;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class Houses {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    zenHideout: ZenHideout;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class ZenHideout {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    skin: Things.Architecture.Houses.ZenHideout.ZenHideoutDrawingPartShapes<boolean>;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a zen hideout
     * @param inputs
     * @returns Zen hideout mesh
     * @group create
     * @shortname zen hideout
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/architecture/Houses/ZenHideout.jpeg
     * @drawable true
     */
    create(
      inputs: Things.Architecture.Houses.ZenHideout.ZenHideoutDto
    ): Promise<
      Things.Architecture.Houses.ZenHideout.ZenHideoutData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws wingtip villa in default settings
     * @param model Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      model: Things.Architecture.Houses.ZenHideout.ZenHideoutData<Inputs.OCCT.TopoDSShapePointer>,
      precision?: number
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a zen hideout model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose zen hideout
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.Architecture.Houses.ZenHideout.ZenHideoutData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates materials
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname creates default materials for zen hideout
     * @drawable false
     * @ignore true
     */
    private createMaterials;
    private createSkin;
  }
  declare class Enums {
    /**
     * Creates a level of detail enumeration value
     * @param inputs
     * @returns level of detail
     * @group enums
     * @shortname lod
     * @drawable false
     */
    lodEnum(inputs: Things.Enums.LodDto): Things.Enums.lodEnum;
  }
  declare class Chairs {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    snakeChair: SnakeChair;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class SnakeChair {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a snake chair model
     * @param inputs
     * @returns Snake chair model
     * @group create
     * @shortname snake chair
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/chairs/snake-chair.jpeg
     * @drawable true
     */
    create(
      inputs: Things.Furniture.Chairs.SnakeChair.SnakeChairDto
    ): Promise<
      Things.Furniture.Chairs.SnakeChair.SnakeChairData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the chair
     * @param inputs
     * @returns Compound shape of the snake chair model
     * @group get shapes
     * @shortname compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/chairs/snake-chair.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.Furniture.Chairs.SnakeChair.SnakeChairModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the wire shape of the chair sitting area
     * @param inputs
     * @returns Wire shape of the sitting area
     * @group get shapes
     * @shortname get sitting wire
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/chairs/snake-chair.jpeg
     * @drawable true
     */
    getSittingWireShape(
      inputs: Things.Furniture.Chairs.SnakeChair.SnakeChairModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the center point of the chair sitting area
     * @param inputs
     * @returns The point on the center of the sitting area
     * @group get points
     * @shortname get sitting area center
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/chairs/snake-chair.jpeg
     * @drawable true
     */
    getSittingAreaCenterPoint(
      inputs: Things.Furniture.Chairs.SnakeChair.SnakeChairModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3;
    /**
     * Creates draw options for snake chair
     * @param inputs
     * @returns Draw options
     * @group draw
     * @shortname snake chair draw options
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/chairs/snake-chair.jpeg
     * @drawable false
     */
    drawOptions(
      inputs: Things.Furniture.Chairs.SnakeChair.SnakeChairDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Things.Furniture.Chairs.SnakeChair.SnakeChairDrawDto<BABYLON.PBRMetallicRoughnessMaterial>;
    /**
     * Draws snake chair model in default settings
     * @param model Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/chairs/snake-chair.jpeg
     * @ignore true
     */
    drawModel(
      model: Things.Furniture.Chairs.SnakeChair.SnakeChairData<Inputs.OCCT.TopoDSShapePointer>,
      options: Things.Furniture.Chairs.SnakeChair.SnakeChairDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a cup model
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose calm cup
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.Furniture.Chairs.SnakeChair.SnakeChairData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates materials
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname creates default materials for zen hideout
     * @drawable false
     * @ignore true
     */
    private createMaterials;
  }
  declare class Furniture {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    chairs: Chairs;
    tables: Tables;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class ElegantTable {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates an elegant table model
     * @param inputs
     * @returns Elegant table model
     * @group create
     * @shortname elegant table
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    create(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableDto
    ): Promise<
      Things.Furniture.Tables.ElegantTable.ElegantTableData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the table
     * @param inputs
     * @returns Compound shape of the elegant table model
     * @group get shapes
     * @shortname compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the leg shapes as a list
     * @param inputs
     * @returns Leg shapes of the table
     * @group get shapes
     * @shortname legs
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getLegShapes(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets the leg shape by index
     * @param inputs
     * @returns Leg shapes of the table
     * @group get shapes
     * @shortname leg by index
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getLegShapeByIndex(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableLegByIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table top panel shape
     * @param inputs
     * @returns Top panel shape of the table
     * @group get shapes
     * @shortname top panel
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getTopPanelShape(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table top panel wire shape
     * @param inputs
     * @returns Top panel wire shape of the table
     * @group get shapes
     * @shortname top panel wire
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getTopPanelWireShape(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table bottom panel wire shape
     * @param inputs
     * @returns Bottom panel wire shape of the table
     * @group get shapes
     * @shortname bottom panel wire
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getBottomPanelWireShape(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table bottom panel shape
     * @param inputs
     * @returns Bottom panel shape of the table
     * @group get shapes
     * @shortname bottom panel
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getBottomPanelShape(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the leg shapes as a compound shape
     * @param inputs
     * @returns Compound shape of the legs
     * @group get shapes
     * @shortname legs compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getLegsCompoundShape(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the top center point
     * @param inputs
     * @returns Top center point
     * @group get points
     * @shortname top center point
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getTableTopCenterPoint(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3;
    /**
     * Gets the bottom center point
     * @param inputs
     * @returns Bottom center point
     * @group get points
     * @shortname bottom center point
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getTableBottomCenterPoint(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3;
    /**
     * Gets the leg bottom points
     * @param inputs
     * @returns Bottom points
     * @group get points
     * @shortname leg bottom points
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getLegBottomPoints(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the leg top points
     * @param inputs
     * @returns Top points
     * @group get points
     * @shortname leg top points
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable true
     */
    getLegTopPoints(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Creates draw options for elegant table
     * @param inputs
     * @returns Draw options
     * @group draw
     * @shortname elegant table draw options
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @drawable false
     */
    drawOptions(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Things.Furniture.Tables.ElegantTable.ElegantTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>;
    /**
     * Draws elegant table model in default settings
     * @param model Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/elegant-table.jpeg
     * @ignore true
     */
    drawModel(
      model: Things.Furniture.Tables.ElegantTable.ElegantTableData<Inputs.OCCT.TopoDSShapePointer>,
      options: Things.Furniture.Tables.ElegantTable.ElegantTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a cup model
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose calm cup
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.Furniture.Tables.ElegantTable.ElegantTableData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates materials
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname creates default materials for zen hideout
     * @drawable false
     * @ignore true
     */
    private createMaterials;
  }
  declare class GoodCoffeeTable {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates an good coffee table model
     * @param inputs
     * @returns Good coffee table model
     * @group create
     * @shortname good coffee table
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    create(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableDto
    ): Promise<
      Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the table
     * @param inputs
     * @returns Compound shape of the elegant table model
     * @group get shapes
     * @shortname get compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the leg shapes as a list
     * @param inputs
     * @returns Leg shapes of the table
     * @group get shapes
     * @shortname get legs
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getLegShapes(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer[];
    /**
     * Gets the leg shape by index
     * @param inputs
     * @returns Leg shapes of the table
     * @group get shapes
     * @shortname get leg by index
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getLegShapeByIndex(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableLegByIndexDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table top panel shape
     * @param inputs
     * @returns Top panel shape of the table
     * @group get shapes
     * @shortname get top panel
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getTopPanelShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table top panel wire shape
     * @param inputs
     * @returns Top panel wire shape of the table
     * @group get shapes
     * @shortname get top panel wire
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getTopPanelWireShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table glass panel shape
     * @param inputs
     * @returns Glass panel shape of the table
     * @group get shapes
     * @shortname get glass panel
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getGlassPanelShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table glass panel wire shape
     * @param inputs
     * @returns Glass panel wire shape of the table
     * @group get shapes
     * @shortname get glass panel wire
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getGlassPanelWireShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table shelf shape
     * @param inputs
     * @returns Shelf shape of the table
     * @group get shapes
     * @shortname get shelf shape
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getShelfShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the table shelf top wire shape
     * @param inputs
     * @returns Shelf wire shape of the table
     * @group get shapes
     * @shortname get shelf top wire
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getShelfTopWireShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the leg shapes as a compound shape
     * @param inputs
     * @returns Compound shape of the legs
     * @group get shapes
     * @shortname get legs compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getLegsCompoundShape(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the top center point
     * @param inputs
     * @returns Top center point
     * @group get points
     * @shortname get top center point
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getTableTopCenterPoint(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3;
    /**
     * Gets the top center point of the shelf
     * @param inputs
     * @returns Top center point of the shelf
     * @group get points
     * @shortname get top shelf center point
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getTableShelfTopCenterPoint(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3;
    /**
     * Gets the leg bottom points
     * @param inputs
     * @returns Bottom points
     * @group get points
     * @shortname get leg bottom points
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getLegBottomPoints(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Gets the leg top points
     * @param inputs
     * @returns Top points
     * @group get points
     * @shortname get leg top points
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable true
     */
    getLegTopPoints(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3[];
    /**
     * Creates draw options for good coffee table
     * @param inputs
     * @returns Draw options
     * @group draw
     * @shortname good coffee table draw options
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @drawable false
     */
    drawOptions(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>;
    /**
     * Draws good coffee table model in default settings
     * @param model Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname get draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/good-coffee-table.jpeg
     * @ignore true
     */
    drawModel(
      model: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableData<Inputs.OCCT.TopoDSShapePointer>,
      options: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a cup model
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose calm cup
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.Furniture.Tables.GoodCoffeeTable.GoodCoffeeTableData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates materials
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname creates default materials for zen hideout
     * @drawable false
     * @ignore true
     */
    private createMaterials;
  }
  declare class SnakeTable {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private materials;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a snake table model
     * @param inputs
     * @returns Snake table model
     * @group create
     * @shortname snake table
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @drawable true
     */
    create(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableDto
    ): Promise<
      Things.Furniture.Tables.SnakeTable.SnakeTableData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the table
     * @param inputs
     * @returns Compound shape of the snake table model
     * @group get shapes
     * @shortname get compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the glass shape of the table
     * @param inputs
     * @returns The glass shape solid of the table
     * @group get shapes
     * @shortname get glass
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @drawable true
     */
    getGlassShape(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the main solid shape of the table
     * @param inputs
     * @returns The main shape solid of the table
     * @group get shapes
     * @shortname get main
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @drawable true
     */
    getMainShape(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the center point of the table top
     * @param inputs
     * @returns The point on the center of the top area
     * @group get points
     * @shortname get top center
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @drawable true
     */
    getTopCenterPoint(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.Base.Point3;
    /**
     * Creates draw options for snake table
     * @param inputs
     * @returns Draw options
     * @group draw
     * @shortname snake table draw options
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @drawable false
     */
    drawOptions(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Things.Furniture.Tables.SnakeTable.SnakeTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>;
    /**
     * Draws snake table model in default settings
     * @param model Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/furniture/tables/snake-table.jpeg
     * @ignore true
     */
    drawModel(
      model: Things.Furniture.Tables.SnakeTable.SnakeTableData<Inputs.OCCT.TopoDSShapePointer>,
      options: Things.Furniture.Tables.SnakeTable.SnakeTableDrawDto<BABYLON.PBRMetallicRoughnessMaterial>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a cup model
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose calm cup
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.Furniture.Tables.SnakeTable.SnakeTableData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates materials
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname creates default materials for zen hideout
     * @drawable false
     * @ignore true
     */
    private createMaterials;
  }
  declare class Tables {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    elegantTable: ElegantTable;
    goodCoffeeTable: GoodCoffeeTable;
    snakeTable: SnakeTable;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class Birdhouses {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    wingtipVilla: WingtipVilla;
    chirpyChalet: ChirpyChalet;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class ChirpyChalet {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Disposes a chirpy chalet model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose chirpy chalet
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.KidsCorner.BirdHouses.ChirpyChalet.ChirpyChaletData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Creates a chirpy chalet birdhouse with a 45 degree roof
     * @param inputs Contains points and the transformations to apply
     * @returns Transformed points
     * @group birdhouse
     * @shortname chirpy chalet
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/kids/Birdhouses/ChirpyChaletIcon.webp
     * @drawable true
     */
    create(
      inputs: Things.KidsCorner.BirdHouses.ChirpyChalet.ChirpyChaletDto
    ): Promise<
      Things.KidsCorner.BirdHouses.ChirpyChalet.ChirpyChaletData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws wingtip villa in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      inputs: Things.KidsCorner.BirdHouses.ChirpyChalet.ChirpyChaletData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<BABYLON.Mesh>;
  }
  declare class WingtipVilla {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
    /**
     * Creates a wingtip villa birdhouse with a 45 degree roof
     * @param inputs Contains points and the transformations to apply
     * @returns Transformed points
     * @group birdhouse
     * @shortname wingtip villa
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/kids/Birdhouses/WingtipVillaIcon.webp
     * @drawable true
     */
    create(
      inputs: Things.KidsCorner.BirdHouses.WingtipVilla.WingtipVillaDto
    ): Promise<
      Things.KidsCorner.BirdHouses.WingtipVilla.WingtipVillaData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Draws wingtip villa in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      inputs: Things.KidsCorner.BirdHouses.WingtipVilla.WingtipVillaData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a wingtip villa model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose wingtip villa
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.KidsCorner.BirdHouses.WingtipVilla.WingtipVillaData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
  }
  declare class KidsCorner {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    birdhouses: Birdhouses;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW
    );
  }
  declare class DropletsPhoneHolder {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private readonly jscad;
    private drawOptions;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW,
      jscad: JSCAD
    );
    /**
     * Creates droplets phone holder
     * @param inputs
     * @returns Droplets phone holder data
     * @group create
     * @shortname droplets phone holder
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable true
     */
    create(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderDto
    ): Promise<
      Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderData<Inputs.OCCT.TopoDSShapePointer>
    >;
    /**
     * Gets the compound shape of the droplets phone holder
     * @param inputs
     * @returns Compound shape of the droplets phone holder model
     * @group get shapes
     * @shortname compound
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable true
     */
    getCompoundShape(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the cut wires compound
     * @param inputs
     * @returns Compound of the cut wires
     * @group get shapes
     * @shortname cut wires
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable true
     */
    getCutWiresCompound(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Gets the engraving wires compound
     * @param inputs
     * @returns Compound of the engraving wires
     * @group get shapes
     * @shortname engraving wires
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable true
     */
    getEngravingWiresCompound(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderModelDto<Inputs.OCCT.TopoDSShapePointer>
    ): Inputs.OCCT.TopoDSShapePointer;
    /**
     * Downloads DXF drawing
     * @param inputs
     * @returns DXF File
     * @group download
     * @shortname dxf drawings
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable false
     */
    downloadDXFDrawings(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderModelDxfDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Downloads STEP drawing
     * @param inputs
     * @returns STEP File
     * @group download
     * @shortname step drawings
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable false
     */
    downloadSTEPDrawings(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderModelStepDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Downloads STEP 3D model
     * @param inputs
     * @returns STEP File
     * @group download
     * @shortname 3d step model
     * @image https://ik.imagekit.io/bitbybit/app/assets/spec-cat/things/laser-cutting/gadgets/DropletsPhoneHolder.jpeg
     * @drawable false
     */
    download3dSTEPModel(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderModelStepDto<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    /**
     * Draws droplets phone holder in default settings
     * @param inputs Contains a model shapes to be drawn and additional information
     * @returns BabylonJS Mesh
     * @group drawing
     * @shortname draw shape
     * @drawable false
     * @ignore true
     */
    drawModel(
      model: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderData<Inputs.OCCT.TopoDSShapePointer>,
      precision?: number
    ): Promise<BABYLON.Mesh>;
    /**
     * Disposes a droplets phone holder model objects
     * @param inputs Contains a model shapes to be disposed and additional information
     * @group drawing
     * @shortname dispose droplets phone holder
     * @drawable false
     * @ignore true
     */
    dispose(
      inputs: Things.LaserCutting.Gadgets.DropletsPhoneHolder.DropletsPhoneHolderData<Inputs.OCCT.TopoDSShapePointer>
    ): Promise<void>;
    private createDrawOptions;
  }
  declare class Gadgets {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private readonly jscad;
    dropletsPhoneHolder: DropletsPhoneHolder;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW,
      jscad: JSCAD
    );
  }
  declare class LaserCutting {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private readonly jscad;
    gadgets: Gadgets;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW,
      jscad: JSCAD
    );
  }
  declare class ThingsAdv {
    private readonly occWorkerManager;
    private readonly context;
    private readonly draw;
    private readonly occt;
    private readonly jscad;
    kidsCorner: KidsCorner;
    threeDPrinting: ThreeDPrinting;
    laserCutting: LaserCutting;
    architecture: Architecture;
    furniture: Furniture;
    enums: Enums;
    constructor(
      occWorkerManager: OCCTWorkerManager,
      context: Context,
      draw: Draw,
      occt: OCCTW,
      jscad: JSCAD
    );
  }

  declare class BitByBitBase {
    readonly draw: Draw;
    readonly babylon: Babylon;
    readonly vector: Vector;
    readonly point: Point;
    readonly line: Line;
    readonly polyline: Polyline;
    readonly mesh: MeshBitByBit;
    readonly occt: OCCTW & OCCT;
    readonly advanced: AdvancedAdv;
    readonly things: ThingsAdv;
    readonly jscad: JSCAD;
    readonly manifold: ManifoldBitByBit;
    readonly logic: Logic;
    readonly math: MathBitByBit;
    readonly lists: Lists;
    readonly color: Color;
    readonly text: TextBitByBit;
    readonly dates: Dates;
    readonly json: JSONBitByBit;
    readonly csv: CSVBitByBit;
    readonly verb: Verb;
    readonly tag: Tag;
    readonly time: Time;
    readonly asset: Asset;
  }

  declare var isRunnerContext: boolean;
  declare function mockBitbybitRunnerInputs<T>(inputs: T): T;
  declare function getBitbybitRunnerInputs<T>(): T;
  declare function setBitbybitRunnerResult<T>(result: T): void;
}
