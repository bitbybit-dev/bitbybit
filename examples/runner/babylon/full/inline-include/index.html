<!doctype html>
<html lang="en">

<head>
    <title>Runner Inline Example - Bit By Bit Developers</title>
    <base href="/">
    <link rel="icon" type="image/x-icon" href="https://bitbybit.dev/assets/favicon.png">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description"
        content="This site contains a very simple example of how runner can handle inline script of the alloy wheel concept design that was exported from bitbybit.dev Rete editor">
    <script src="https://cdn.jsdelivr.net/gh/bitbybit-dev/bitbybit-assets@latest/runner/bitbybit-runner-babylonjs.js"></script>
    <script>
        // Timeout is needed for HTML to have time to finish rendering. This also makes sure that myCanvas actually can be found
        setTimeout(async () => {

            const runnerOptions = {
                canvasId: "myCanvas",
                canvasZoneClass: "myCanvasZone",
                enablePhysics: true,
                enableOCCT: true,
                enableJSCAD: false,
                enableManifold: false,
                enableKeyEventListeners: false,
                loadFonts: ["Roboto"]
            };

            const runner = window.bitbybitRunner.getRunnerInstance();
            const { bitbybit, Bit, BABYLON, GUI } = await runner.run(
                runnerOptions
            );
            runner.executeScript(exportedScript(), {});
        }, 0)

        // This function simply outputs the script that was exported from the Rete editor by clicking "Export to Runner" and selecting Minify option.
        function exportedScript() {
            return '{\"type\":\"rete\",\"version\":\"0.20.5\",\"script\":\"!async function(e,t,s,n,r){let a={};a={x:[0],y:[0],z:[1],...a};const o=[{result:e.HS.executeBasedOnType(a,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let i={};i={text:[\\"[true,false]\\"],...i};const c=[{result:e.HS.executeBasedOnType(i,!1,(e=>t.json.parse(e))),transformers:[]}];let p={};p={text:[\\"[false,true]\\"],...p};const u=[{result:e.HS.executeBasedOnType(p,!1,(e=>t.json.parse(e))),transformers:[]}],l=[{result:[5],transformers:[]}];let d={};d={x:[1],y:[0],z:[0],...d};const m=[{result:e.HS.executeBasedOnType(d,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}],y=[{result:[12],transformers:[]}],S=[{result:[7],transformers:[]}];let H={};H={x:[0],y:[1],z:[0],...H};const f=[{result:e.HS.executeBasedOnType(H,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let h={};h={x:[0],y:[0],z:[1],...h};const x=[{result:e.HS.executeBasedOnType(h,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let v={};v={number:[.4],...v};const O=[{result:e.HS.executeBasedOnType(v,!1,(e=>t.math.number(e))),transformers:[]}];let I={};I={x:[0],y:[0],z:[-1],...I};const L=[{result:e.HS.executeBasedOnType(I,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let B={};B={x:[0],y:[0],z:[-2],...B};const w=[{result:e.HS.executeBasedOnType(B,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let T={};T={x:[0],y:[0],z:[1],...T};const g=[{result:e.HS.executeBasedOnType(T,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let A={};A={x:[0],y:[1.5],z:[0],...A};const E=[{result:e.HS.executeBasedOnType(A,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let b={};b={...{faceOpacity:[.5],edgeOpacity:[.5],edgeColour:[\\"#000000\\"],faceColour:[\\"#212121\\"],vertexColour:[\\"#ff00ff\\"],faceMaterial:[void 0],edgeWidth:[2],vertexSize:[.03],drawEdges:[!0],drawFaces:[!0],drawVertices:[!1],precision:[.02],drawEdgeIndexes:[!1],edgeIndexHeight:[.06],edgeIndexColour:[\\"ff00ff\\"],drawFaceIndexes:[!1],faceIndexHeight:[.06],faceIndexColour:[\\"#0000ff\\"]},...b};const z=[{result:e.HS.executeBasedOnType(b,!1,(e=>t.draw.optionsOcctShape(e))),transformers:[]}];let W={};W={name:[\\"Custom Material\\"],baseColor:[\\"#9c9cba\\"],emissiveColor:[\\"#000000\\"],metallic:[.9],roughness:[.1],alpha:[1],backFaceCulling:[!1],zOffset:[2],...W};const C=[{result:e.HS.executeBasedOnType(W,!1,(e=>t.babylon.material.pbrMetallicRoughness.create(e))),transformers:[]}];let P={};P={x:[0],y:[0],z:[-1],...P};const X=[{result:e.HS.executeBasedOnType(P,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Y={};Y={x:[0],y:[0],z:[-1.5],...Y};const Z=[{result:e.HS.executeBasedOnType(Y,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let N={};N={x:[0],y:[0],z:[1],...N};const k=[{result:e.HS.executeBasedOnType(N,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let M={};M={skybox:[\\"city\\"],size:[1e3],blur:[.4],environmentIntensity:[.4],...M};e.HS.executeBasedOnType(M,!1,(e=>t.babylon.scene.enableSkybox(e)));let F={number:[{result:[20],transformers:[]}]};e.HS.updateListInputs(F),F={number:[20],...F};const D=[{result:e.HS.executeBasedOnType(F,!1,(e=>t.math.number(e))),transformers:[]}];let R={};R.y=y,e.HS.updateListInputs(R),R={x:[0],y:[0],z:[0],...R};const j=[{result:e.HS.executeBasedOnType(R,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let q={};q.item=y,e.HS.updateListInputs(q),q={...q};const V=[{result:q.item}];let G={};G.first=S,e.HS.updateListInputs(G),G={first:[1],second:[-2],operation:[\\"divide\\"],...G};const J=[{result:e.HS.executeBasedOnType(G,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let K={};K.first=S,e.HS.updateListInputs(K),K={first:[1],second:[-4],operation:[\\"divide\\"],...K};const Q=[{result:e.HS.executeBasedOnType(K,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let U={};U.first=y,U.second=O,e.HS.updateListInputs(U),U={first:[1],second:[.4],operation:[\\"add\\"],...U};const $=[{result:e.HS.executeBasedOnType(U,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let _={};_.item=S,e.HS.updateListInputs(_),_={..._};const ee=[{result:_.item}],te={faceOpacity:[1],edgeOpacity:[1],edgeColour:[\\"#1c1c1c\\"],faceColour:[\\"#bdbdbd\\"],vertexColour:[\\"#ff00ff\\"],faceMaterial:[void 0],edgeWidth:[2],vertexSize:[.03],drawEdges:[!0],drawFaces:[!0],drawVertices:[!1],precision:[.01],drawEdgeIndexes:[!1],edgeIndexHeight:[.06],edgeIndexColour:[\\"ff00ff\\"],drawFaceIndexes:[!1],faceIndexHeight:[.06],faceIndexColour:[\\"#0000ff\\"]};let se={};se.faceMaterial=C,e.HS.updateListInputs(se),se={...te,...se};const ne=[{result:e.HS.executeBasedOnType(se,!1,(e=>t.draw.optionsOcctShape(e))),transformers:[]}];let re={};re.center=Z,re.direction=X,e.HS.updateListInputs(re),re={radius:[3],height:[1.9],center:[[0,0,0]],direction:[[0,1,0]],...re};const ae=[{result:await e.HS.executeBasedOnTypeAsync(re,!1,(e=>t.occt.shapes.solid.createCylinder(e))),transformers:[]}];let oe={};oe.y=$,e.HS.updateListInputs(oe),oe={x:[0],y:[12],z:[0],...oe};const ie=[{result:e.HS.executeBasedOnType(oe,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let ce={};ce.first=D,e.HS.updateListInputs(ce),ce={first:[1],second:[3],operation:[\\"multiply\\"],...ce};const pe=[{result:e.HS.executeBasedOnType(ce,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let ue={};ue.first=V,ue.second=O,e.HS.updateListInputs(ue),ue={first:[1],second:[.4],operation:[\\"add\\"],...ue};const le=[{result:e.HS.executeBasedOnType(ue,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let de={};de.first=V,de.second=O,e.HS.updateListInputs(de),de={first:[1],second:[.4],operation:[\\"subtract\\"],...de};const me=[{result:e.HS.executeBasedOnType(de,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let ye={};ye.first=ee,e.HS.updateListInputs(ye),ye={first:[1],second:[-.2],operation:[\\"multiply\\"],...ye};const Se=[{result:e.HS.executeBasedOnType(ye,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let He={};He.second=D,e.HS.updateListInputs(He),He={first:[360],second:[1],operation:[\\"divide\\"],...He};const fe=[{result:e.HS.executeBasedOnType(He,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}],he={shape:[void 0],radius:[.3],radiusList:[void 0],indexes:[void 0]};let xe={};xe.shape=ae,e.HS.updateListInputs(xe),xe={...he,...xe};const ve=[{result:await e.HS.executeBasedOnTypeAsync(xe,!1,(e=>t.occt.fillets.filletEdges(e))),transformers:[]}];let Oe={};Oe.start=L,Oe.end=ie,e.HS.updateListInputs(Oe),Oe={start:[[0,0,0]],end:[[0,1,0]],...Oe};const Ie=[{result:await e.HS.executeBasedOnTypeAsync(Oe,!1,(e=>t.occt.shapes.wire.createLineWire(e))),transformers:[]}];let Le={};Le.second=pe,e.HS.updateListInputs(Le),Le={first:[360],second:[1],operation:[\\"divide\\"],...Le};const Be=[{result:e.HS.executeBasedOnType(Le,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let we={};we.start=w,we.end=ie,e.HS.updateListInputs(we),we={start:[[0,0,0]],end:[[0,1,0]],...we};const Te=[{result:await e.HS.executeBasedOnTypeAsync(we,!1,(e=>t.occt.shapes.wire.createLineWire(e))),transformers:[]}];let ge={};ge.y=le,e.HS.updateListInputs(ge),ge={x:[0],y:[0],z:[.05],...ge};const Ae=[{result:e.HS.executeBasedOnType(ge,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Ee={};Ee.y=me,Ee.z=Q,e.HS.updateListInputs(Ee),Ee={x:[0],y:[0],z:[-1],...Ee};const be=[{result:e.HS.executeBasedOnType(Ee,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let ze={};ze.y=me,ze.z=J,e.HS.updateListInputs(ze),ze={x:[0],y:[0],z:[0],...ze};const We=[{result:e.HS.executeBasedOnType(ze,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Ce={};Ce.z=Se,e.HS.updateListInputs(Ce),Ce={x:[0],y:[0],z:[0],...Ce};const Pe=[{result:e.HS.executeBasedOnType(Ce,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Xe={};Xe.step=fe,e.HS.updateListInputs(Xe),Xe={step:[.1],min:[0],max:[360],...Xe};const Ye=e.HS.executeBasedOnType(Xe,!1,(e=>t.vector.span(e))),Ze=[];for(let e=0;e<1;e++)Ze.push({type:\\"flat\\"});const Ne=[{result:Ye,transformers:Ze}];let ke={};ke.first=Se,e.HS.updateListInputs(ke),ke={first:[2],second:[-2],operation:[\\"multiply\\"],...ke};e.HS.executeBasedOnType(ke,!1,(e=>t.math.twoNrOperation(e)));let Me={};Me.listElements=ve,e.HS.updateListInputs(Me),Me={...Me};const Fe=[{result:[Me.listElements?Me.listElements:[]]}],De={shape:[void 0],axis:[[0,0,1]],angle:[0]};let Re={};Re.shape=Ie,Re.axis=o,Re.angle=Be,e.HS.updateListInputs(Re),Re={...De,...Re};const je=[{result:await e.HS.executeBasedOnTypeAsync(Re,!1,(e=>t.occt.transforms.rotate(e))),transformers:[]}];let qe={};qe.first=Be,e.HS.updateListInputs(qe),qe={first:[1],second:[.4],operation:[\\"multiply\\"],...qe};const Ve=[{result:e.HS.executeBasedOnType(qe,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let Ge={};Ge.first=Be,e.HS.updateListInputs(Ge),Ge={first:[1],second:[.6],operation:[\\"multiply\\"],...Ge};const Je=[{result:e.HS.executeBasedOnType(Ge,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let Ke={};Ke.listElements=[Ae[0],j[0],be[0],We[0]],e.HS.updateListInputs(Ke),Ke={...Ke};const Qe=[{result:[Ke.listElements?Ke.listElements:[]]}];let Ue={};Ue.item=Ne,e.HS.updateListInputs(Ue),Ue={...Ue};const $e=[{result:Ue.item}],_e={shape:[void 0],nrOfDivisions:[11],removeStartPoint:[!1],removeEndPoint:[!1]};let et={};et.shape=je,et.nrOfDivisions=l,e.HS.updateListInputs(et),et={..._e,...et};const tt=[{result:await e.HS.executeBasedOnTypeAsync(et,!1,(e=>t.occt.shapes.wire.divideWireByEqualDistanceToPoints(e))),transformers:[]}],st={shape:[void 0],axis:[[0,0,1]],angle:[0]};let nt={};nt.shape=Te,nt.axis=o,nt.angle=[Ve[0],Je[0]],e.HS.updateListInputs(nt),nt={...st,...nt};const rt=[{result:await e.HS.executeBasedOnTypeAsync(nt,!1,(e=>t.occt.transforms.rotate(e))),transformers:[]}];let at={};at.number=Ve,e.HS.updateListInputs(at),at={number:[1],operation:[\\"negate\\"],...at};const ot=[{result:e.HS.executeBasedOnType(at,!1,(e=>t.math.oneNrOperation(e))),transformers:[]}],it={points:[void 0]};let ct={};ct.points=Qe,e.HS.updateListInputs(ct),ct={...it,...ct};const pt=[{result:await e.HS.executeBasedOnTypeAsync(ct,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}];e.HS.drawNodeMeshes(pt,t);const ut={list:[void 0],pattern:[[!0,!0,!1]]};let lt={};lt.list=tt,lt.pattern=u,e.HS.updateListInputs(lt),lt={...ut,...lt};const dt=[{result:e.HS.executeBasedOnType(lt,!0,(e=>t.lists.getByPattern(e))),transformers:[]}];let mt={};mt.listElements=rt,e.HS.updateListInputs(mt),mt={...mt};const yt=[{result:[mt.listElements?mt.listElements:[]]}],St={shape:[void 0],origin:[[0,0,0]],direction:[[0,0,1]]};let Ht={};Ht.shape=pt,Ht.origin=We,Ht.direction=f,e.HS.updateListInputs(Ht),Ht={...St,...Ht};const ft=[{result:await e.HS.executeBasedOnTypeAsync(Ht,!1,(e=>t.occt.transforms.mirror(e))),transformers:[]}],ht={shape:[void 0]};let xt={};xt.shape=pt,e.HS.updateListInputs(xt),xt={...ht,...xt};const vt=await e.HS.executeBasedOnTypeAsync(xt,!1,(e=>t.occt.shapes.edge.getCornerPointsOfEdgesForShape(e))),Ot=[];for(let e=0;e<1;e++)Ot.push({type:\\"flat\\"});const It=[{result:vt,transformers:Ot}],Lt={list:[void 0],index:[0],clone:[!0]};let Bt={};Bt.list=yt,e.HS.updateListInputs(Bt),Bt={...Lt,...Bt};const wt=[{result:e.HS.executeBasedOnType(Bt,!1,(e=>t.lists.getItem(e))),transformers:[]}],Tt={shape:[void 0]};let gt={};gt.shape=ft,e.HS.updateListInputs(gt),gt={...Tt,...gt};const At=[{result:await e.HS.executeBasedOnTypeAsync(gt,!1,(e=>t.occt.shapes.edge.getCornerPointsOfEdgesForShape(e))),transformers:[]}],Et={shape:[void 0],nrOfDivisions:[11],removeStartPoint:[!1],removeEndPoint:[!1]};let bt={};bt.shape=wt,bt.nrOfDivisions=l,e.HS.updateListInputs(bt),bt={...Et,...bt};const zt=[{result:await e.HS.executeBasedOnTypeAsync(bt,!1,(e=>t.occt.shapes.wire.divideWireByEqualDistanceToPoints(e))),transformers:[]}],Wt={list:[void 0],index:[3],clone:[!0]};let Ct={};Ct.list=At,e.HS.updateListInputs(Ct),Ct={...Wt,...Ct};const Pt=[{result:e.HS.executeBasedOnType(Ct,!1,(e=>t.lists.removeItemAtIndex(e))),transformers:[]}],Xt={list:[void 0],pattern:[[!0,!0,!1]]};let Yt={};Yt.list=zt,Yt.pattern=c,e.HS.updateListInputs(Yt),Yt={...Xt,...Yt};const Zt=[{result:e.HS.executeBasedOnType(Yt,!1,(e=>t.lists.getByPattern(e))),transformers:[]}],Nt={list:[void 0],clone:[!0]};let kt={};kt.list=Pt,e.HS.updateListInputs(kt),kt={...Nt,...kt};const Mt=e.HS.executeBasedOnType(kt,!1,(e=>t.lists.reverse(e))),Ft=[];for(let e=0;e<1;e++)Ft.push({type:\\"flat\\"});const Dt=[{result:Mt,transformers:Ft}];let Rt={};Rt.listElements=[Zt[0],dt[0]],e.HS.updateListInputs(Rt),Rt={...Rt};const jt=[{result:[Rt.listElements?Rt.listElements:[]]}];let qt={};qt.listElements=[It[0],Dt[0]],e.HS.updateListInputs(qt),qt={...qt};const Vt=[{result:[qt.listElements?qt.listElements:[]]}],Gt={list:[void 0],clone:[!0]};let Jt={};Jt.list=jt,e.HS.updateListInputs(Jt),Jt={...Gt,...Jt};const Kt=e.HS.executeBasedOnType(Jt,!1,(e=>t.lists.flipLists(e))),Qt=[];for(let e=0;e<2;e++)Qt.push({type:\\"flat\\"});const Ut=[{result:Kt,transformers:Qt}],$t={points:[void 0]};let _t={};_t.points=Vt,e.HS.updateListInputs(_t),_t={...$t,..._t};const es=[{result:await e.HS.executeBasedOnTypeAsync(_t,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}];let ts={};ts.listElements=Ut,e.HS.updateListInputs(ts),ts={...ts};const ss=[{result:[ts.listElements?ts.listElements:[]]}],ns={shape:[void 0],radius:[.3],radiusList:[void 0],indexes:[void 0]};let rs={};rs.shape=es,e.HS.updateListInputs(rs),rs={...ns,...rs};const as=[{result:await e.HS.executeBasedOnTypeAsync(rs,!1,(e=>t.occt.fillets.fillet2d(e))),transformers:[]}],os={points:[void 0]};let is={};is.points=ss,e.HS.updateListInputs(is),is={...os,...is};const cs=[{result:await e.HS.executeBasedOnTypeAsync(is,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}],ps={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let us={};us.shape=as,us.direction=x,e.HS.updateListInputs(us),us={...ps,...us};const ls=[{result:await e.HS.executeBasedOnTypeAsync(us,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}],ds={shape:[void 0]};let ms={};ms.shape=as,e.HS.updateListInputs(ms),ms={...ds,...ms};const ys=[{result:await e.HS.executeBasedOnTypeAsync(ms,!1,(e=>t.occt.shapes.wire.startPointOnWire(e))),transformers:[]}],Ss={shape:[void 0]};let Hs={};Hs.shape=as,e.HS.updateListInputs(Hs),Hs={...Ss,...Hs};const fs=[{result:await e.HS.executeBasedOnTypeAsync(Hs,!1,(e=>t.occt.shapes.wire.endPointOnWire(e))),transformers:[]}],hs={shape:[void 0]};let xs={};xs.shape=as,e.HS.updateListInputs(xs),xs={...hs,...xs};const vs=[{result:await e.HS.executeBasedOnTypeAsync(xs,!1,(e=>t.occt.shapes.wire.closeOpenWire(e))),transformers:[]}],Os={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let Is={};Is.shape=vs,Is.direction=x,e.HS.updateListInputs(Is),Is={...Os,...Is};const Ls=[{result:await e.HS.executeBasedOnTypeAsync(Is,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}],Bs={shape:[void 0],radius:[1],radiusList:[void 0],indexes:[void 0],direction:[[0,1,0]]};let ws={};ws.shape=cs,ws.direction=g,e.HS.updateListInputs(ws),ws={...Bs,...ws};const Ts=[{result:await e.HS.executeBasedOnTypeAsync(ws,!1,(e=>t.occt.fillets.fillet3DWire(e))),transformers:[]}],gs={shape:[void 0],face:[void 0],distance:[-.2],tolerance:[.1]};let As={};As.shape=ls,e.HS.updateListInputs(As),As={...gs,...As};const Es=[{result:await e.HS.executeBasedOnTypeAsync(As,!1,(e=>t.occt.operations.offset(e))),transformers:[]}],bs={shape:[void 0],index:[0]};let zs={};zs.shape=ls,e.HS.updateListInputs(zs),zs={...bs,...zs};const Ws=[{result:await e.HS.executeBasedOnTypeAsync(zs,!1,(e=>t.occt.shapes.wire.getWire(e))),transformers:[]}];let Cs={};Cs.item=ys,e.HS.updateListInputs(Cs),Cs={...Cs};const Ps=[{result:Cs.item}];let Xs={};Xs.item=fs,e.HS.updateListInputs(Xs),Xs={...Xs};const Ys=[{result:Xs.item}];let Zs={};Zs.start=fs,Zs.end=ys,e.HS.updateListInputs(Zs),Zs={start:[[0,0,0]],end:[[0,1,0]],...Zs};const Ns=[{result:await e.HS.executeBasedOnTypeAsync(Zs,!1,(e=>t.occt.shapes.wire.createLineWire(e))),transformers:[]}];e.HS.drawNodeMeshes(Ns,t);const ks={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let Ms={};Ms.shape=Ts,Ms.angle=ot,Ms.direction=o,e.HS.updateListInputs(Ms),Ms={...ks,...Ms};const Fs=[{result:await e.HS.executeBasedOnTypeAsync(Ms,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}],Ds={shape:[void 0]};let Rs={};Rs.shape=Ls,e.HS.updateListInputs(Rs),Rs={...Ds,...Rs};const js=[{result:await e.HS.executeBasedOnTypeAsync(Rs,!1,(e=>t.occt.shapes.solid.fromClosedShell(e))),transformers:[]}],qs={shape:[void 0],index:[1]};let Vs={};Vs.shape=Ws,e.HS.updateListInputs(Vs),Vs={...qs,...Vs};const Gs=[{result:await e.HS.executeBasedOnTypeAsync(Vs,!1,(e=>t.occt.shapes.edge.getEdge(e))),transformers:[]}],Js={shape:[void 0],index:[0]};let Ks={};Ks.shape=Es,e.HS.updateListInputs(Ks),Ks={...Js,...Ks};const Qs=[{result:await e.HS.executeBasedOnTypeAsync(Ks,!1,(e=>t.occt.shapes.wire.getWire(e))),transformers:[]}],Us={shape:[void 0],translation:[[0,0,0]]};let $s={};$s.shape=Ns,$s.translation=E,e.HS.updateListInputs($s),$s={...Us,...$s};const _s=[{result:await e.HS.executeBasedOnTypeAsync($s,!1,(e=>t.occt.transforms.translate(e))),transformers:[]}],en={shape:[void 0],direction:[[0,1,0]]};let tn={};tn.shape=Fs,tn.direction=Pe,e.HS.updateListInputs(tn),tn={...en,...tn};const sn=[{result:await e.HS.executeBasedOnTypeAsync(tn,!1,(e=>t.occt.operations.extrude(e))),transformers:[]}];let nn={};nn.listElements=js,e.HS.updateListInputs(nn),nn={...nn};const rn=[{result:[nn.listElements?nn.listElements:[]]}],an={shape:[void 0],index:[1]};let on={};on.shape=Qs,e.HS.updateListInputs(on),on={...an,...on};const cn=[{result:await e.HS.executeBasedOnTypeAsync(on,!1,(e=>t.occt.shapes.edge.getEdge(e))),transformers:[]}];let pn={};pn.listElements=Gs,e.HS.updateListInputs(pn),pn={...pn};const un=[{result:[pn.listElements?pn.listElements:[]]}],ln={shape:[void 0]};let dn={};dn.shape=_s,e.HS.updateListInputs(dn),dn={...ln,...dn};const mn=[{result:await e.HS.executeBasedOnTypeAsync(dn,!1,(e=>t.occt.shapes.wire.startPointOnWire(e))),transformers:[]}],yn={shape:[void 0]};let Sn={};Sn.shape=_s,e.HS.updateListInputs(Sn),Sn={...yn,...Sn};const Hn=[{result:await e.HS.executeBasedOnTypeAsync(Sn,!1,(e=>t.occt.shapes.wire.endPointOnWire(e))),transformers:[]}],fn={shapes:[void 0]};let hn={};hn.shapes=un,e.HS.updateListInputs(hn),hn={...fn,...hn};const xn=[{result:await e.HS.executeBasedOnTypeAsync(hn,!1,(e=>t.occt.shapes.wire.combineEdgesAndWiresIntoAWire(e))),transformers:[]}];let vn={};vn.listElements=cn,e.HS.updateListInputs(vn),vn={...vn};const On=[{result:[vn.listElements?vn.listElements:[]]}],In={shape:[void 0],shapes:[void 0],keepEdges:[!1]};let Ln={};Ln.shape=sn,Ln.shapes=Fe,e.HS.updateListInputs(Ln),Ln={...In,...Ln};const Bn=[{result:await e.HS.executeBasedOnTypeAsync(Ln,!1,(e=>t.occt.booleans.difference(e))),transformers:[]}];let wn={};wn.item=Hn,e.HS.updateListInputs(wn),wn={...wn};const Tn=[{result:wn.item}];let gn={};gn.item=mn,e.HS.updateListInputs(gn),gn={...gn};const An=[{result:gn.item}],En={shape:[void 0],shapes:[void 0],keepEdges:[!1]};let bn={};bn.shape=Bn,bn.shapes=rn,e.HS.updateListInputs(bn),bn={...En,...bn};const zn=[{result:await e.HS.executeBasedOnTypeAsync(bn,!1,(e=>t.occt.booleans.difference(e))),transformers:[]}],Wn={shapes:[void 0]};let Cn={};Cn.shapes=On,e.HS.updateListInputs(Cn),Cn={...Wn,...Cn};const Pn=[{result:await e.HS.executeBasedOnTypeAsync(Cn,!1,(e=>t.occt.shapes.wire.combineEdgesAndWiresIntoAWire(e))),transformers:[]}];let Xn={};Xn.listElements=[Ps[0],Tn[0],An[0],Ys[0]],e.HS.updateListInputs(Xn),Xn={...Xn};const Yn=[{result:[Xn.listElements?Xn.listElements:[]]}],Zn={shape:[void 0],origin:[[0,0,0]],normal:[[0,0,1]]};let Nn={};Nn.shape=zn,Nn.normal=m,e.HS.updateListInputs(Nn),Nn={...Zn,...Nn};const kn=[{result:await e.HS.executeBasedOnTypeAsync(Nn,!1,(e=>t.occt.transforms.mirrorAlongNormal(e))),transformers:[]}];let Mn={};Mn.listElements=[xn[0],Pn[0]],e.HS.updateListInputs(Mn),Mn={...Mn};const Fn=[{result:[Mn.listElements?Mn.listElements:[]]}],Dn={points:[void 0]};let Rn={};Rn.points=Yn,e.HS.updateListInputs(Rn),Rn={...Dn,...Rn};const jn=[{result:await e.HS.executeBasedOnTypeAsync(Rn,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}];let qn={};qn.listElements=[kn[0],zn[0]],e.HS.updateListInputs(qn),qn={...qn};const Vn=[{result:[qn.listElements?qn.listElements:[]]}],Gn={shapes:[void 0],makeSolid:[!1]};let Jn={};Jn.shapes=Fn,e.HS.updateListInputs(Jn),Jn={...Gn,...Jn};const Kn=[{result:await e.HS.executeBasedOnTypeAsync(Jn,!1,(e=>t.occt.operations.loft(e))),transformers:[]}],Qn={shape:[void 0],radius:[.5],radiusList:[void 0],indexes:[void 0]};let Un={};Un.shape=jn,e.HS.updateListInputs(Un),Un={...Qn,...Un};const $n=[{result:await e.HS.executeBasedOnTypeAsync(Un,!1,(e=>t.occt.fillets.fillet2d(e))),transformers:[]}],_n={shapes:[void 0]};let er={};er.shapes=Vn,e.HS.updateListInputs(er),er={..._n,...er};const tr=[{result:await e.HS.executeBasedOnTypeAsync(er,!1,(e=>t.occt.shapes.compound.makeCompound(e))),transformers:[]}],sr={shape:[void 0],origin:[[0,0,0]],direction:[[0,0,1]]};let nr={};nr.shape=Kn,nr.origin=We,nr.direction=f,e.HS.updateListInputs(nr),nr={...sr,...nr};const rr=[{result:await e.HS.executeBasedOnTypeAsync(nr,!1,(e=>t.occt.transforms.mirror(e))),transformers:[]}],ar={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let or={};or.shape=$n,or.direction=x,e.HS.updateListInputs(or),or={...ar,...or};const ir=[{result:await e.HS.executeBasedOnTypeAsync(or,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}];let cr={};cr.listElements=[ls[0],Es[0],Kn[0],rr[0]],e.HS.updateListInputs(cr),cr={...cr};const pr=[{result:[cr.listElements?cr.listElements:[]]}],ur={shape:[void 0],offset:[-.1]};let lr={};lr.shape=ir,e.HS.updateListInputs(lr),lr={...ur,...lr};const dr=[{result:await e.HS.executeBasedOnTypeAsync(lr,!1,(e=>t.occt.operations.makeThickSolidSimple(e))),transformers:[]}],mr={shape:[void 0],angle:[0],center:[[0,0,0]],axis:[[0,0,1]]};let yr={};yr.shape=tr,yr.angle=$e,yr.axis=k,e.HS.updateListInputs(yr),yr={...mr,...yr};const Sr=[{result:await e.HS.executeBasedOnTypeAsync(yr,!1,(e=>t.occt.transforms.rotateAroundCenter(e))),transformers:[]}],Hr={shapes:[void 0],tolerance:[1e-7]};let fr={};fr.shapes=pr,e.HS.updateListInputs(fr),fr={...Hr,...fr};const hr=[{result:await e.HS.executeBasedOnTypeAsync(fr,!1,(e=>t.occt.shapes.shell.sewFaces(e))),transformers:[]}],xr={entity:[void 0],options:[void 0],babylonMesh:[void 0]};let vr={};vr.entity=dr,vr.options=z,e.HS.updateListInputs(vr),vr={...xr,...vr};await e.HS.executeBasedOnTypeAsync(vr,!1,(e=>t.draw.drawAnyAsync(e)));let Or={};Or.listElements=Sr,e.HS.updateListInputs(Or),Or={...Or};const Ir=[{result:[Or.listElements?Or.listElements:[]]}],Lr={shapes:[void 0]};let Br={};Br.shapes=Ir,e.HS.updateListInputs(Br),Br={...Lr,...Br};const wr=[{result:await e.HS.executeBasedOnTypeAsync(Br,!1,(e=>t.occt.shapes.compound.makeCompound(e))),transformers:[]}];let Tr={};Tr.listElements=[hr[0],ve[0],wr[0]],e.HS.updateListInputs(Tr),Tr={...Tr};const gr=[{result:[Tr.listElements?Tr.listElements:[]]}],Ar={shapes:[void 0]};let Er={};Er.shapes=gr,e.HS.updateListInputs(Er),Er={...Ar,...Er};const br=[{result:await e.HS.executeBasedOnTypeAsync(Er,!1,(e=>t.occt.shapes.compound.makeCompound(e))),transformers:[]}],zr={entity:[void 0],options:[void 0],babylonMesh:[void 0]};let Wr={};Wr.entity=br,Wr.options=ne,e.HS.updateListInputs(Wr),Wr={...zr,...Wr};await e.HS.executeBasedOnTypeAsync(Wr,!1,(e=>t.draw.drawAnyAsync(e)))}(BitByBit,bitbybit,bitbybitRunnerResult,bitbybitRunnerInputs,Bit);\"}'
        };
    </script>
    <style>
        body {
            margin: 0;
            background-color: #1a1c1f;
            color: white;
            font-weight: 400;
            font-family: 'IBM Plex Sans';
            width: 100%;
            height: 100%;
        }

        .example {
            margin-top: 50px;
            margin-bottom: 50px;
            margin-left: 300px;
            margin-right: 300px;
        }

        @media(max-width:1400px) {
            .example {
                margin-left: 100px;
                margin-right: 100px;
            }
        }

        @media(max-width:769px) {
            .example {
                margin-left: 20px;
                margin-right: 20px;
            }
        }

        #myCanvas {
            display: block;
            outline: none;
            border: 1px solid white;
            border-radius: 5px;
            width: 100%;
        }

        .logo {
            margin-bottom: 20px;
        }

        .logo img {
            width: 50px;
            height: 50px;
        }

        .myCanvasZone {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        a {
            color: white;
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <div class="example">
        <a class="logo" href="https://bitbybit.dev" target="_blank" rel="noopener noreferrer">
            <img alt="Logo of Bit by bit developers company" src="https://bitbybit.dev/assets/logo-gold-small.png" />
            <div>bitbybit.dev</div>
        </a>
        <h1>Runner Example - Inline Rete Script Embed</h1>
        <div class="myCanvasZone">
            <canvas id="myCanvas"></canvas>
        </div>
        <a href="https://bitbybit.dev/projects/public/EMfBhqxbI5DibbwVactv/script/7LRqBI8nFqx32lXiK3G1/script-rete-script-alloy-wheel-cad-model-in-project-3d-alloy-wheel-cad-concept-by-author-matas"
            target="_blank" rel="noopener noreferrer">
            Embed string generated by using the "Rete Script Alloy Wheel CAD Model".
        </a>
    </div>
</body>

</html>