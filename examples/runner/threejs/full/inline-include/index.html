<!doctype html>
<html lang="en">

<head>
    <title>Runner Inline Example - Bit By Bit Developers</title>
    <base href="/">
    <link rel="icon" type="image/x-icon" href="https://bitbybit.dev/assets/favicon.png">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description"
        content="This site contains a very simple example of how runner can handle inline script of the alloy wheel concept design that was exported from bitbybit.dev Rete editor">
    <script src="https://app.bitbybit.dev/bitbybit-runner-threejs.js"></script>
    <script>
        // Timeout is needed for HTML to have time to finish rendering. This also makes sure that myCanvas actually can be found
        setTimeout(async () => {

            const runnerOptions = {
                canvasId: "myCanvas",
                canvasZoneClass: "myCanvasZone",
                enablePhysics: true,
                enableOCCT: true,
                enableJSCAD: false,
                enableManifold: false,
                enableKeyEventListeners: false,
                loadFonts: []
            };

            const runner = window.bitbybitRunner.getRunnerInstance();
            const { bitbybit, Bit } = await runner.run(
                runnerOptions
            );
            runner.executeScript(exportedScript(), {});
        }, 0)

        // This function simply outputs the script that was exported from the Rete editor by clicking "Export to Runner" and selecting Minify option.
        function exportedScript() {
            return '{\"type\":\"rete\",\"version\":\"0.20.8\",\"script\":\"async function(e,t,s,n,r){let a={};a={x:[0],y:[0],z:[1],...a};const o=[{result:e.HS.executeBasedOnType(a,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let i={};i={text:[\\"[true,false]\\"],...i};const p=[{result:e.HS.executeBasedOnType(i,!1,(e=>t.json.parse(e))),transformers:[]}];let c={};c={text:[\\"[false,true]\\"],...c};const u=[{result:e.HS.executeBasedOnType(c,!1,(e=>t.json.parse(e))),transformers:[]}],l=[{result:[5],transformers:[]}];let d={};d={x:[1],y:[0],z:[0],...d};const m=[{result:e.HS.executeBasedOnType(d,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}],y=[{result:[12],transformers:[]}],S=[{result:[7],transformers:[]}];let H={};H={x:[0],y:[1],z:[0],...H};const f=[{result:e.HS.executeBasedOnType(H,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let h={};h={x:[0],y:[0],z:[1],...h};const x=[{result:e.HS.executeBasedOnType(h,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let v={};v={number:[.4],...v};const O=[{result:e.HS.executeBasedOnType(v,!1,(e=>t.math.number(e))),transformers:[]}];let I={};I={x:[0],y:[0],z:[-1],...I};const L=[{result:e.HS.executeBasedOnType(I,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let B={};B={x:[0],y:[0],z:[-2],...B};const T=[{result:e.HS.executeBasedOnType(B,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let w={};w={x:[0],y:[0],z:[1],...w};const A=[{result:e.HS.executeBasedOnType(w,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let E={};E={x:[0],y:[1.5],z:[0],...E};const g=[{result:e.HS.executeBasedOnType(E,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let b={};b={...{faceOpacity:[.5],edgeOpacity:[.5],edgeColour:[\\"#000000\\"],faceColour:[\\"#212121\\"],vertexColour:[\\"#ff00ff\\"],faceMaterial:[void 0],edgeWidth:[2],vertexSize:[.03],drawEdges:[!0],drawFaces:[!0],drawVertices:[!1],precision:[.02],drawEdgeIndexes:[!1],edgeIndexHeight:[.06],edgeIndexColour:[\\"ff00ff\\"],drawFaceIndexes:[!1],faceIndexHeight:[.06],faceIndexColour:[\\"#0000ff\\"]},...b};const W=[{result:e.HS.executeBasedOnType(b,!1,(e=>t.draw.optionsOcctShape(e))),transformers:[]}];let z={};z={x:[0],y:[0],z:[-1],...z};const P=[{result:e.HS.executeBasedOnType(z,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let X={};X={x:[0],y:[0],z:[-1.5],...X};const Y=[{result:e.HS.executeBasedOnType(X,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Z={};Z={x:[0],y:[0],z:[1],...Z};const N=[{result:e.HS.executeBasedOnType(Z,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let C={number:[{result:[20],transformers:[]}]};e.HS.updateListInputs(C),C={number:[20],...C};const k=[{result:e.HS.executeBasedOnType(C,!1,(e=>t.math.number(e))),transformers:[]}];let D={};D.y=y,e.HS.updateListInputs(D),D={x:[0],y:[0],z:[0],...D};const F=[{result:e.HS.executeBasedOnType(D,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let M={};M.item=y,e.HS.updateListInputs(M),M={...M};const R=[{result:M.item}];let j={};j.first=S,e.HS.updateListInputs(j),j={first:[1],second:[-2],operation:[\\"divide\\"],...j};const q=[{result:e.HS.executeBasedOnType(j,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let V={};V.first=S,e.HS.updateListInputs(V),V={first:[1],second:[-4],operation:[\\"divide\\"],...V};const G=[{result:e.HS.executeBasedOnType(V,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let J={};J.first=y,J.second=O,e.HS.updateListInputs(J),J={first:[1],second:[.4],operation:[\\"add\\"],...J};const K=[{result:e.HS.executeBasedOnType(J,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let Q={};Q.item=S,e.HS.updateListInputs(Q),Q={...Q};const U=[{result:Q.item}];let $={};$.center=Y,$.direction=P,e.HS.updateListInputs($),$={radius:[3],height:[1.9],center:[[0,0,0]],direction:[[0,1,0]],...$};const _=[{result:await e.HS.executeBasedOnTypeAsync($,!1,(e=>t.occt.shapes.solid.createCylinder(e))),transformers:[]}];let ee={};ee.y=K,e.HS.updateListInputs(ee),ee={x:[0],y:[12],z:[0],...ee};const te=[{result:e.HS.executeBasedOnType(ee,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let se={};se.first=k,e.HS.updateListInputs(se),se={first:[1],second:[3],operation:[\\"multiply\\"],...se};const ne=[{result:e.HS.executeBasedOnType(se,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let re={};re.first=R,re.second=O,e.HS.updateListInputs(re),re={first:[1],second:[.4],operation:[\\"add\\"],...re};const ae=[{result:e.HS.executeBasedOnType(re,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let oe={};oe.first=R,oe.second=O,e.HS.updateListInputs(oe),oe={first:[1],second:[.4],operation:[\\"subtract\\"],...oe};const ie=[{result:e.HS.executeBasedOnType(oe,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let pe={};pe.first=U,e.HS.updateListInputs(pe),pe={first:[1],second:[-.2],operation:[\\"multiply\\"],...pe};const ce=[{result:e.HS.executeBasedOnType(pe,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let ue={};ue.second=k,e.HS.updateListInputs(ue),ue={first:[360],second:[1],operation:[\\"divide\\"],...ue};const le=[{result:e.HS.executeBasedOnType(ue,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}],de={shape:[void 0],radius:[.3],radiusList:[void 0],indexes:[void 0]};let me={};me.shape=_,e.HS.updateListInputs(me),me={...de,...me};const ye=[{result:await e.HS.executeBasedOnTypeAsync(me,!1,(e=>t.occt.fillets.filletEdges(e))),transformers:[]}];let Se={};Se.start=L,Se.end=te,e.HS.updateListInputs(Se),Se={start:[[0,0,0]],end:[[0,1,0]],...Se};const He=[{result:await e.HS.executeBasedOnTypeAsync(Se,!1,(e=>t.occt.shapes.wire.createLineWire(e))),transformers:[]}];let fe={};fe.second=ne,e.HS.updateListInputs(fe),fe={first:[360],second:[1],operation:[\\"divide\\"],...fe};const he=[{result:e.HS.executeBasedOnType(fe,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let xe={};xe.start=T,xe.end=te,e.HS.updateListInputs(xe),xe={start:[[0,0,0]],end:[[0,1,0]],...xe};const ve=[{result:await e.HS.executeBasedOnTypeAsync(xe,!1,(e=>t.occt.shapes.wire.createLineWire(e))),transformers:[]}];let Oe={};Oe.y=ae,e.HS.updateListInputs(Oe),Oe={x:[0],y:[0],z:[.05],...Oe};const Ie=[{result:e.HS.executeBasedOnType(Oe,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Le={};Le.y=ie,Le.z=G,e.HS.updateListInputs(Le),Le={x:[0],y:[0],z:[-1],...Le};const Be=[{result:e.HS.executeBasedOnType(Le,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Te={};Te.y=ie,Te.z=q,e.HS.updateListInputs(Te),Te={x:[0],y:[0],z:[0],...Te};const we=[{result:e.HS.executeBasedOnType(Te,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let Ae={};Ae.z=ce,e.HS.updateListInputs(Ae),Ae={x:[0],y:[0],z:[0],...Ae};const Ee=[{result:e.HS.executeBasedOnType(Ae,!1,(e=>t.vector.vectorXYZ(e))),transformers:[]}];let ge={};ge.step=le,e.HS.updateListInputs(ge),ge={step:[.1],min:[0],max:[360],...ge};const be=e.HS.executeBasedOnType(ge,!1,(e=>t.vector.span(e))),We=[];for(let e=0;e<1;e++)We.push({type:\\"flat\\"});const ze=[{result:be,transformers:We}];let Pe={};Pe.first=ce,e.HS.updateListInputs(Pe),Pe={first:[2],second:[-2],operation:[\\"multiply\\"],...Pe};e.HS.executeBasedOnType(Pe,!1,(e=>t.math.twoNrOperation(e)));let Xe={};Xe.listElements=ye,e.HS.updateListInputs(Xe),Xe={...Xe};const Ye=[{result:[Xe.listElements?Xe.listElements:[]]}],Ze={shape:[void 0],axis:[[0,0,1]],angle:[0]};let Ne={};Ne.shape=He,Ne.axis=o,Ne.angle=he,e.HS.updateListInputs(Ne),Ne={...Ze,...Ne};const Ce=[{result:await e.HS.executeBasedOnTypeAsync(Ne,!1,(e=>t.occt.transforms.rotate(e))),transformers:[]}];let ke={};ke.first=he,e.HS.updateListInputs(ke),ke={first:[1],second:[.4],operation:[\\"multiply\\"],...ke};const De=[{result:e.HS.executeBasedOnType(ke,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let Fe={};Fe.first=he,e.HS.updateListInputs(Fe),Fe={first:[1],second:[.6],operation:[\\"multiply\\"],...Fe};const Me=[{result:e.HS.executeBasedOnType(Fe,!1,(e=>t.math.twoNrOperation(e))),transformers:[]}];let Re={};Re.listElements=[Ie[0],F[0],Be[0],we[0]],e.HS.updateListInputs(Re),Re={...Re};const je=[{result:[Re.listElements?Re.listElements:[]]}];let qe={};qe.item=ze,e.HS.updateListInputs(qe),qe={...qe};const Ve=[{result:qe.item}],Ge={shape:[void 0],nrOfDivisions:[11],removeStartPoint:[!1],removeEndPoint:[!1]};let Je={};Je.shape=Ce,Je.nrOfDivisions=l,e.HS.updateListInputs(Je),Je={...Ge,...Je};const Ke=[{result:await e.HS.executeBasedOnTypeAsync(Je,!1,(e=>t.occt.shapes.wire.divideWireByEqualDistanceToPoints(e))),transformers:[]}],Qe={shape:[void 0],axis:[[0,0,1]],angle:[0]};let Ue={};Ue.shape=ve,Ue.axis=o,Ue.angle=[De[0],Me[0]],e.HS.updateListInputs(Ue),Ue={...Qe,...Ue};const $e=[{result:await e.HS.executeBasedOnTypeAsync(Ue,!1,(e=>t.occt.transforms.rotate(e))),transformers:[]}];let _e={};_e.number=De,e.HS.updateListInputs(_e),_e={number:[1],operation:[\\"negate\\"],..._e};const et=[{result:e.HS.executeBasedOnType(_e,!1,(e=>t.math.oneNrOperation(e))),transformers:[]}],tt={points:[void 0]};let st={};st.points=je,e.HS.updateListInputs(st),st={...tt,...st};const nt=[{result:await e.HS.executeBasedOnTypeAsync(st,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}],rt={list:[void 0],pattern:[[!0,!0,!1]]};let at={};at.list=Ke,at.pattern=u,e.HS.updateListInputs(at),at={...rt,...at};const ot=[{result:e.HS.executeBasedOnType(at,!0,(e=>t.lists.getByPattern(e))),transformers:[]}];let it={};it.listElements=$e,e.HS.updateListInputs(it),it={...it};const pt=[{result:[it.listElements?it.listElements:[]]}],ct={shape:[void 0],origin:[[0,0,0]],direction:[[0,0,1]]};let ut={};ut.shape=nt,ut.origin=we,ut.direction=f,e.HS.updateListInputs(ut),ut={...ct,...ut};const lt=[{result:await e.HS.executeBasedOnTypeAsync(ut,!1,(e=>t.occt.transforms.mirror(e))),transformers:[]}],dt={shape:[void 0]};let mt={};mt.shape=nt,e.HS.updateListInputs(mt),mt={...dt,...mt};const yt=await e.HS.executeBasedOnTypeAsync(mt,!1,(e=>t.occt.shapes.edge.getCornerPointsOfEdgesForShape(e))),St=[];for(let e=0;e<1;e++)St.push({type:\\"flat\\"});const Ht=[{result:yt,transformers:St}],ft={list:[void 0],index:[0],clone:[!0]};let ht={};ht.list=pt,e.HS.updateListInputs(ht),ht={...ft,...ht};const xt=[{result:e.HS.executeBasedOnType(ht,!1,(e=>t.lists.getItem(e))),transformers:[]}],vt={shape:[void 0]};let Ot={};Ot.shape=lt,e.HS.updateListInputs(Ot),Ot={...vt,...Ot};const It=[{result:await e.HS.executeBasedOnTypeAsync(Ot,!1,(e=>t.occt.shapes.edge.getCornerPointsOfEdgesForShape(e))),transformers:[]}],Lt={shape:[void 0],nrOfDivisions:[11],removeStartPoint:[!1],removeEndPoint:[!1]};let Bt={};Bt.shape=xt,Bt.nrOfDivisions=l,e.HS.updateListInputs(Bt),Bt={...Lt,...Bt};const Tt=[{result:await e.HS.executeBasedOnTypeAsync(Bt,!1,(e=>t.occt.shapes.wire.divideWireByEqualDistanceToPoints(e))),transformers:[]}],wt={list:[void 0],index:[3],clone:[!0]};let At={};At.list=It,e.HS.updateListInputs(At),At={...wt,...At};const Et=[{result:e.HS.executeBasedOnType(At,!1,(e=>t.lists.removeItemAtIndex(e))),transformers:[]}],gt={list:[void 0],pattern:[[!0,!0,!1]]};let bt={};bt.list=Tt,bt.pattern=p,e.HS.updateListInputs(bt),bt={...gt,...bt};const Wt=[{result:e.HS.executeBasedOnType(bt,!1,(e=>t.lists.getByPattern(e))),transformers:[]}],zt={list:[void 0],clone:[!0]};let Pt={};Pt.list=Et,e.HS.updateListInputs(Pt),Pt={...zt,...Pt};const Xt=e.HS.executeBasedOnType(Pt,!1,(e=>t.lists.reverse(e))),Yt=[];for(let e=0;e<1;e++)Yt.push({type:\\"flat\\"});const Zt=[{result:Xt,transformers:Yt}];let Nt={};Nt.listElements=[Wt[0],ot[0]],e.HS.updateListInputs(Nt),Nt={...Nt};const Ct=[{result:[Nt.listElements?Nt.listElements:[]]}];let kt={};kt.listElements=[Ht[0],Zt[0]],e.HS.updateListInputs(kt),kt={...kt};const Dt=[{result:[kt.listElements?kt.listElements:[]]}],Ft={list:[void 0],clone:[!0]};let Mt={};Mt.list=Ct,e.HS.updateListInputs(Mt),Mt={...Ft,...Mt};const Rt=e.HS.executeBasedOnType(Mt,!1,(e=>t.lists.flipLists(e))),jt=[];for(let e=0;e<2;e++)jt.push({type:\\"flat\\"});const qt=[{result:Rt,transformers:jt}],Vt={points:[void 0]};let Gt={};Gt.points=Dt,e.HS.updateListInputs(Gt),Gt={...Vt,...Gt};const Jt=[{result:await e.HS.executeBasedOnTypeAsync(Gt,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}];let Kt={};Kt.listElements=qt,e.HS.updateListInputs(Kt),Kt={...Kt};const Qt=[{result:[Kt.listElements?Kt.listElements:[]]}],Ut={shape:[void 0],radius:[.3],radiusList:[void 0],indexes:[void 0]};let $t={};$t.shape=Jt,e.HS.updateListInputs($t),$t={...Ut,...$t};const _t=[{result:await e.HS.executeBasedOnTypeAsync($t,!1,(e=>t.occt.fillets.fillet2d(e))),transformers:[]}],es={points:[void 0]};let ts={};ts.points=Qt,e.HS.updateListInputs(ts),ts={...es,...ts};const ss=[{result:await e.HS.executeBasedOnTypeAsync(ts,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}],ns={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let rs={};rs.shape=_t,rs.direction=x,e.HS.updateListInputs(rs),rs={...ns,...rs};const as=[{result:await e.HS.executeBasedOnTypeAsync(rs,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}],os={shape:[void 0]};let is={};is.shape=_t,e.HS.updateListInputs(is),is={...os,...is};const ps=[{result:await e.HS.executeBasedOnTypeAsync(is,!1,(e=>t.occt.shapes.wire.startPointOnWire(e))),transformers:[]}],cs={shape:[void 0]};let us={};us.shape=_t,e.HS.updateListInputs(us),us={...cs,...us};const ls=[{result:await e.HS.executeBasedOnTypeAsync(us,!1,(e=>t.occt.shapes.wire.endPointOnWire(e))),transformers:[]}],ds={shape:[void 0]};let ms={};ms.shape=_t,e.HS.updateListInputs(ms),ms={...ds,...ms};const ys=[{result:await e.HS.executeBasedOnTypeAsync(ms,!1,(e=>t.occt.shapes.wire.closeOpenWire(e))),transformers:[]}],Ss={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let Hs={};Hs.shape=ys,Hs.direction=x,e.HS.updateListInputs(Hs),Hs={...Ss,...Hs};const fs=[{result:await e.HS.executeBasedOnTypeAsync(Hs,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}],hs={shape:[void 0],radius:[1],radiusList:[void 0],indexes:[void 0],direction:[[0,1,0]]};let xs={};xs.shape=ss,xs.direction=A,e.HS.updateListInputs(xs),xs={...hs,...xs};const vs=[{result:await e.HS.executeBasedOnTypeAsync(xs,!1,(e=>t.occt.fillets.fillet3DWire(e))),transformers:[]}],Os={shape:[void 0],face:[void 0],distance:[-.2],tolerance:[.1]};let Is={};Is.shape=as,e.HS.updateListInputs(Is),Is={...Os,...Is};const Ls=[{result:await e.HS.executeBasedOnTypeAsync(Is,!1,(e=>t.occt.operations.offset(e))),transformers:[]}],Bs={shape:[void 0],index:[0]};let Ts={};Ts.shape=as,e.HS.updateListInputs(Ts),Ts={...Bs,...Ts};const ws=[{result:await e.HS.executeBasedOnTypeAsync(Ts,!1,(e=>t.occt.shapes.wire.getWire(e))),transformers:[]}];let As={};As.item=ps,e.HS.updateListInputs(As),As={...As};const Es=[{result:As.item}];let gs={};gs.item=ls,e.HS.updateListInputs(gs),gs={...gs};const bs=[{result:gs.item}];let Ws={};Ws.start=ls,Ws.end=ps,e.HS.updateListInputs(Ws),Ws={start:[[0,0,0]],end:[[0,1,0]],...Ws};const zs=[{result:await e.HS.executeBasedOnTypeAsync(Ws,!1,(e=>t.occt.shapes.wire.createLineWire(e))),transformers:[]}],Ps={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let Xs={};Xs.shape=vs,Xs.angle=et,Xs.direction=o,e.HS.updateListInputs(Xs),Xs={...Ps,...Xs};const Ys=[{result:await e.HS.executeBasedOnTypeAsync(Xs,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}],Zs={shape:[void 0]};let Ns={};Ns.shape=fs,e.HS.updateListInputs(Ns),Ns={...Zs,...Ns};const Cs=[{result:await e.HS.executeBasedOnTypeAsync(Ns,!1,(e=>t.occt.shapes.solid.fromClosedShell(e))),transformers:[]}],ks={shape:[void 0],index:[1]};let Ds={};Ds.shape=ws,e.HS.updateListInputs(Ds),Ds={...ks,...Ds};const Fs=[{result:await e.HS.executeBasedOnTypeAsync(Ds,!1,(e=>t.occt.shapes.edge.getEdge(e))),transformers:[]}],Ms={shape:[void 0],index:[0]};let Rs={};Rs.shape=Ls,e.HS.updateListInputs(Rs),Rs={...Ms,...Rs};const js=[{result:await e.HS.executeBasedOnTypeAsync(Rs,!1,(e=>t.occt.shapes.wire.getWire(e))),transformers:[]}],qs={shape:[void 0],translation:[[0,0,0]]};let Vs={};Vs.shape=zs,Vs.translation=g,e.HS.updateListInputs(Vs),Vs={...qs,...Vs};const Gs=[{result:await e.HS.executeBasedOnTypeAsync(Vs,!1,(e=>t.occt.transforms.translate(e))),transformers:[]}],Js={shape:[void 0],direction:[[0,1,0]]};let Ks={};Ks.shape=Ys,Ks.direction=Ee,e.HS.updateListInputs(Ks),Ks={...Js,...Ks};const Qs=[{result:await e.HS.executeBasedOnTypeAsync(Ks,!1,(e=>t.occt.operations.extrude(e))),transformers:[]}];let Us={};Us.listElements=Cs,e.HS.updateListInputs(Us),Us={...Us};const $s=[{result:[Us.listElements?Us.listElements:[]]}],_s={shape:[void 0],index:[1]};let en={};en.shape=js,e.HS.updateListInputs(en),en={..._s,...en};const tn=[{result:await e.HS.executeBasedOnTypeAsync(en,!1,(e=>t.occt.shapes.edge.getEdge(e))),transformers:[]}];let sn={};sn.listElements=Fs,e.HS.updateListInputs(sn),sn={...sn};const nn=[{result:[sn.listElements?sn.listElements:[]]}],rn={shape:[void 0]};let an={};an.shape=Gs,e.HS.updateListInputs(an),an={...rn,...an};const on=[{result:await e.HS.executeBasedOnTypeAsync(an,!1,(e=>t.occt.shapes.wire.startPointOnWire(e))),transformers:[]}],pn={shape:[void 0]};let cn={};cn.shape=Gs,e.HS.updateListInputs(cn),cn={...pn,...cn};const un=[{result:await e.HS.executeBasedOnTypeAsync(cn,!1,(e=>t.occt.shapes.wire.endPointOnWire(e))),transformers:[]}],ln={shapes:[void 0]};let dn={};dn.shapes=nn,e.HS.updateListInputs(dn),dn={...ln,...dn};const mn=[{result:await e.HS.executeBasedOnTypeAsync(dn,!1,(e=>t.occt.shapes.wire.combineEdgesAndWiresIntoAWire(e))),transformers:[]}];let yn={};yn.listElements=tn,e.HS.updateListInputs(yn),yn={...yn};const Sn=[{result:[yn.listElements?yn.listElements:[]]}],Hn={shape:[void 0],shapes:[void 0],keepEdges:[!1]};let fn={};fn.shape=Qs,fn.shapes=Ye,e.HS.updateListInputs(fn),fn={...Hn,...fn};const hn=[{result:await e.HS.executeBasedOnTypeAsync(fn,!1,(e=>t.occt.booleans.difference(e))),transformers:[]}];let xn={};xn.item=un,e.HS.updateListInputs(xn),xn={...xn};const vn=[{result:xn.item}];let On={};On.item=on,e.HS.updateListInputs(On),On={...On};const In=[{result:On.item}],Ln={shape:[void 0],shapes:[void 0],keepEdges:[!1]};let Bn={};Bn.shape=hn,Bn.shapes=$s,e.HS.updateListInputs(Bn),Bn={...Ln,...Bn};const Tn=[{result:await e.HS.executeBasedOnTypeAsync(Bn,!1,(e=>t.occt.booleans.difference(e))),transformers:[]}],wn={shapes:[void 0]};let An={};An.shapes=Sn,e.HS.updateListInputs(An),An={...wn,...An};const En=[{result:await e.HS.executeBasedOnTypeAsync(An,!1,(e=>t.occt.shapes.wire.combineEdgesAndWiresIntoAWire(e))),transformers:[]}];let gn={};gn.listElements=[Es[0],vn[0],In[0],bs[0]],e.HS.updateListInputs(gn),gn={...gn};const bn=[{result:[gn.listElements?gn.listElements:[]]}],Wn={shape:[void 0],origin:[[0,0,0]],normal:[[0,0,1]]};let zn={};zn.shape=Tn,zn.normal=m,e.HS.updateListInputs(zn),zn={...Wn,...zn};const Pn=[{result:await e.HS.executeBasedOnTypeAsync(zn,!1,(e=>t.occt.transforms.mirrorAlongNormal(e))),transformers:[]}];let Xn={};Xn.listElements=[mn[0],En[0]],e.HS.updateListInputs(Xn),Xn={...Xn};const Yn=[{result:[Xn.listElements?Xn.listElements:[]]}],Zn={points:[void 0]};let Nn={};Nn.points=bn,e.HS.updateListInputs(Nn),Nn={...Zn,...Nn};const Cn=[{result:await e.HS.executeBasedOnTypeAsync(Nn,!1,(e=>t.occt.shapes.wire.createPolylineWire(e))),transformers:[]}];let kn={};kn.listElements=[Pn[0],Tn[0]],e.HS.updateListInputs(kn),kn={...kn};const Dn=[{result:[kn.listElements?kn.listElements:[]]}],Fn={shapes:[void 0],makeSolid:[!1]};let Mn={};Mn.shapes=Yn,e.HS.updateListInputs(Mn),Mn={...Fn,...Mn};const Rn=[{result:await e.HS.executeBasedOnTypeAsync(Mn,!1,(e=>t.occt.operations.loft(e))),transformers:[]}],jn={shape:[void 0],radius:[.5],radiusList:[void 0],indexes:[void 0]};let qn={};qn.shape=Cn,e.HS.updateListInputs(qn),qn={...jn,...qn};const Vn=[{result:await e.HS.executeBasedOnTypeAsync(qn,!1,(e=>t.occt.fillets.fillet2d(e))),transformers:[]}],Gn={shapes:[void 0]};let Jn={};Jn.shapes=Dn,e.HS.updateListInputs(Jn),Jn={...Gn,...Jn};const Kn=[{result:await e.HS.executeBasedOnTypeAsync(Jn,!1,(e=>t.occt.shapes.compound.makeCompound(e))),transformers:[]}],Qn={shape:[void 0],origin:[[0,0,0]],direction:[[0,0,1]]};let Un={};Un.shape=Rn,Un.origin=we,Un.direction=f,e.HS.updateListInputs(Un),Un={...Qn,...Un};const $n=[{result:await e.HS.executeBasedOnTypeAsync(Un,!1,(e=>t.occt.transforms.mirror(e))),transformers:[]}],_n={shape:[void 0],angle:[360],direction:[[0,1,0]],copy:[!1]};let er={};er.shape=Vn,er.direction=x,e.HS.updateListInputs(er),er={..._n,...er};const tr=[{result:await e.HS.executeBasedOnTypeAsync(er,!1,(e=>t.occt.operations.revolve(e))),transformers:[]}];let sr={};sr.listElements=[as[0],Ls[0],Rn[0],$n[0]],e.HS.updateListInputs(sr),sr={...sr};const nr=[{result:[sr.listElements?sr.listElements:[]]}],rr={shape:[void 0],offset:[-.1]};let ar={};ar.shape=tr,e.HS.updateListInputs(ar),ar={...rr,...ar};const or=[{result:await e.HS.executeBasedOnTypeAsync(ar,!1,(e=>t.occt.operations.makeThickSolidSimple(e))),transformers:[]}],ir={shape:[void 0],angle:[0],center:[[0,0,0]],axis:[[0,0,1]]};let pr={};pr.shape=Kn,pr.angle=Ve,pr.axis=N,e.HS.updateListInputs(pr),pr={...ir,...pr};const cr=[{result:await e.HS.executeBasedOnTypeAsync(pr,!1,(e=>t.occt.transforms.rotateAroundCenter(e))),transformers:[]}],ur={shapes:[void 0],tolerance:[1e-7]};let lr={};lr.shapes=nr,e.HS.updateListInputs(lr),lr={...ur,...lr};const dr=[{result:await e.HS.executeBasedOnTypeAsync(lr,!1,(e=>t.occt.shapes.shell.sewFaces(e))),transformers:[]}],mr={entity:[void 0],options:[void 0],babylonMesh:[void 0]};let yr={};yr.entity=or,yr.options=W,e.HS.updateListInputs(yr),yr={...mr,...yr};await e.HS.executeBasedOnTypeAsync(yr,!1,(e=>t.draw.drawAnyAsync(e)));let Sr={};Sr.listElements=cr,e.HS.updateListInputs(Sr),Sr={...Sr};const Hr=[{result:[Sr.listElements?Sr.listElements:[]]}],fr={shapes:[void 0]};let hr={};hr.shapes=Hr,e.HS.updateListInputs(hr),hr={...fr,...hr};const xr=[{result:await e.HS.executeBasedOnTypeAsync(hr,!1,(e=>t.occt.shapes.compound.makeCompound(e))),transformers:[]}];let vr={};vr.listElements=[dr[0],ye[0],xr[0]],e.HS.updateListInputs(vr),vr={...vr};const Or=[{result:[vr.listElements?vr.listElements:[]]}],Ir={shapes:[void 0]};let Lr={};Lr.shapes=Or,e.HS.updateListInputs(Lr),Lr={...Ir,...Lr};const Br=[{result:await e.HS.executeBasedOnTypeAsync(Lr,!1,(e=>t.occt.shapes.compound.makeCompound(e))),transformers:[]}],Tr={entity:[void 0],options:[void 0],babylonMesh:[void 0]};let wr={};wr.entity=Br,e.HS.updateListInputs(wr),wr={...Tr,...wr};await e.HS.executeBasedOnTypeAsync(wr,!1,(e=>t.draw.drawAnyAsync(e)))}(BitByBit,bitbybit,bitbybitRunnerResult,bitbybitRunnerInputs,Bit);\"}'
        };
    </script>
    <style>
        body {
            margin: 0;
            background-color: #1a1c1f;
            color: white;
            font-weight: 400;
            font-family: 'IBM Plex Sans';
            width: 100%;
            height: 100%;
        }

        .example {
            margin-top: 50px;
            margin-bottom: 50px;
            margin-left: 300px;
            margin-right: 300px;
        }

        @media(max-width:1400px) {
            .example {
                margin-left: 100px;
                margin-right: 100px;
            }
        }

        @media(max-width:769px) {
            .example {
                margin-left: 20px;
                margin-right: 20px;
            }
        }

        #myCanvas {
            display: block;
            outline: none;
            border: 1px solid white;
            border-radius: 5px;
            width: 100%;
        }

        .logo {
            margin-bottom: 20px;
        }

        .logo img {
            width: 50px;
            height: 50px;
        }

        .myCanvasZone {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        a {
            color: white;
            vertical-align: middle;
        }
    </style>
</head>

<body>
    <div class="example">
        <a class="logo" href="https://bitbybit.dev" target="_blank" rel="noopener noreferrer">
            <img alt="Logo of Bit by bit developers company" src="https://bitbybit.dev/assets/logo-gold-small.png" />
            <div>bitbybit.dev</div>
        </a>
        <h1>Runner Example - Inline Rete Script Embed Via ThreeJS</h1>
        <div class="myCanvasZone">
            <canvas id="myCanvas"></canvas>
        </div>
        <a href="https://bitbybit.dev/projects/public/EMfBhqxbI5DibbwVactv/script/7LRqBI8nFqx32lXiK3G1/script-rete-script-alloy-wheel-cad-model-in-project-3d-alloy-wheel-cad-concept-by-author-matas"
            target="_blank" rel="noopener noreferrer">
            Embed string generated by using the "Rete Script Alloy Wheel CAD Model but we removed some BabylonJS specific logic like skybox to make it run".
        </a>
    </div>
</body>

</html>