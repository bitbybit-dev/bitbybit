{
    "bitbybit.draw.drawAnyAsyncNoReturn": "draw any async no return",
    "bitbybit": "bitbybit",
    "draw": "draw",
    "drawAnyAsyncNoReturn": "draw any async no return",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Draws any kind of geometry and does not return anything",
    "draw async": "draw async",
    "entity": "entity",
    "Entity": "entity",
    "options": "options",
    "DrawOptions": "draw options",
    "babylonMesh": "babylon mesh",
    "BABYLON.Mesh | BABYLON.LinesMesh": "babylon mesh or lines mesh",
    "bitbybit.draw.drawAnyAsync": "draw any async",
    "drawAnyAsync": "draw any async",
    "bitbybit.draw.drawAnyAsync_description": "Draws any kind of geometry and returns the babylon mesh",
    "bitbybit.draw.drawAnyNoReturn": "draw any no return",
    "drawAnyNoReturn": "draw any no return",
    "bitbybit.draw.drawAnyNoReturn_description": "Draws any kind of geometry that does not need asynchronous computing, thus it cant be used with shapes coming from occt or jscad",
    "draw sync": "draw sync",
    "bitbybit.draw.drawAny": "draw any",
    "drawAny": "draw any",
    "bitbybit.draw.drawAny_description": "Draws any kind of geometry that does not need asynchronous computing, thus it cant be used with shapes coming from occt or jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "draw grid mesh no return",
    "drawGridMeshNoReturn": "draw grid mesh no return",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Draws a grid mesh on the ground plane in 3D space. This helps to orient yourself in the world.",
    "grid": "grid",
    "width": "width",
    "number": "number",
    "height": "height",
    "subdivisions": "subdivisions",
    "majorUnitFrequency": "major unit frequency",
    "minorUnitVisibility": "minor unit visibility",
    "gridRatio": "grid ratio",
    "opacity": "opacity",
    "backFaceCulling": "back face culling",
    "boolean": "boolean",
    "mainColor": "main color",
    "Base.Color": "base color",
    "secondaryColor": "secondary color",
    "bitbybit.draw.drawGridMesh": "draw grid mesh",
    "drawGridMesh": "draw grid mesh",
    "bitbybit.draw.drawGridMesh_description": "Draws a grid mesh on the ground plane in 3D space. This helps to orient yourself in the world.",
    "bitbybit.draw.optionsSimple": "options simple",
    "optionsSimple": "options simple",
    "bitbybit.draw.optionsSimple_description": "Creates draw options for basic geometry types like points, lines, polylines, surfaces and jscad meshes",
    "colours": "colours",
    "string | string[]": "string or string array",
    "size": "size",
    "updatable": "updatable",
    "hidden": "hidden",
    "bitbybit.draw.optionsOcctShape": "options occt shape",
    "optionsOcctShape": "options occt shape",
    "bitbybit.draw.optionsOcctShape_description": "Creates draw options for occt shape geometry like edges, wires, faces, shells, solids and compounds",
    "faceOpacity": "face opacity",
    "edgeOpacity": "edge opacity",
    "edgeColour": "edge colour",
    "faceColour": "face colour",
    "vertexColour": "vertex colour",
    "faceMaterial": "face material",
    "Base.Material": "base material",
    "edgeWidth": "edge width",
    "vertexSize": "vertex size",
    "drawEdges": "draw edges",
    "drawFaces": "draw faces",
    "drawVertices": "draw vertices",
    "precision": "precision",
    "drawEdgeIndexes": "draw edge indexes",
    "edgeIndexHeight": "edge index height",
    "edgeIndexColour": "edge index colour",
    "drawFaceIndexes": "draw face indexes",
    "faceIndexHeight": "face index height",
    "faceIndexColour": "face index colour",
    "bitbybit.draw.optionsOcctShapeSimple": "options occt shape simple",
    "optionsOcctShapeSimple": "options occt shape simple",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Creates simple draw options for occt shape geometry",
    "bitbybit.draw.optionsOcctShapeMaterial": "options occt shape material",
    "optionsOcctShapeMaterial": "options occt shape material",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Creates simple draw options with custom face material for occt shape geometry",
    "any": "any",
    "bitbybit.draw.optionsManifoldShapeMaterial": "options manifold shape material",
    "optionsManifoldShapeMaterial": "options manifold shape material",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Creates draw options for manifold gemetry",
    "crossSectionColour": "cross section colour",
    "crossSectionWidth": "cross section width",
    "crossSectionOpacity": "cross section opacity",
    "computeNormals": "compute normals",
    "bitbybit.draw.optionsBabylonNode": "options babylon node",
    "optionsBabylonNode": "options babylon node",
    "bitbybit.draw.optionsBabylonNode_description": "Creates draw options for babylon js nodes",
    "colorX": "color x",
    "colorY": "color y",
    "colorZ": "color z",
    "bitbybit.babylon.mesh.dispose": "dispose mesh",
    "babylon": "babylon",
    "mesh": "mesh",
    "dispose": "dispose",
    "bitbybit.babylon.mesh.dispose_description": "Disposes drawn mesh object from the scene",
    "memory": "memory",
    "BABYLON.Mesh": "babylon mesh",
    "bitbybit.babylon.mesh.updateDrawn": "update drawn",
    "updateDrawn": "update drawn",
    "bitbybit.babylon.mesh.updateDrawn_description": "Udates drawn BabylonJS mesh object without disposing it",
    "updates": "updates",
    "position": "position",
    "Base.Point3": "base point 3",
    "rotation": "rotation",
    "Base.Vector3": "base vector 3",
    "scaling": "scaling",
    "bitbybit.babylon.mesh.setVisibility": "set visibility",
    "setVisibility": "set visibility",
    "bitbybit.babylon.mesh.setVisibility_description": "Change the visibility of a drawn BabylonJS mesh",
    "visibility": "visibility",
    "includeChildren": "include children",
    "bitbybit.babylon.mesh.hide": "hide",
    "hide": "hide",
    "bitbybit.babylon.mesh.hide_description": "hides the mesh",
    "bitbybit.babylon.mesh.show": "show",
    "show": "show",
    "bitbybit.babylon.mesh.show_description": "Show the mesh",
    "bitbybit.babylon.mesh.setParent": "set parent",
    "setParent": "set parent",
    "bitbybit.babylon.mesh.setParent_description": "Change the parent of the drawn mesh",
    "set": "set",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "babylon mesh or instanced mesh or abstract mesh",
    "parentMesh": "parent mesh",
    "bitbybit.babylon.mesh.getParent": "get parent",
    "getParent": "get parent",
    "bitbybit.babylon.mesh.getParent_description": "Get the parent of the drawn mesh",
    "get": "get",
    "bitbybit.babylon.mesh.setCheckCollisions": "set check collisions",
    "setCheckCollisions": "set check collisions",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Change the check collisions property of the drawn mesh",
    "checkCollisions": "check collisions",
    "bitbybit.babylon.mesh.getCheckCollisions": "get check collisions",
    "getCheckCollisions": "get check collisions",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Get the check collisions property of the drawn mesh",
    "bitbybit.babylon.mesh.setPickable": "set pickable",
    "setPickable": "set pickable",
    "bitbybit.babylon.mesh.setPickable_description": "Change the pickable property of the drawn mesh",
    "pickable": "pickable",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "enable pointer move events",
    "enablePointerMoveEvents": "enable pointer move events",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Force mesh to be pickable by pointer move events, default is false as it is performance heavy",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "disable pointer move events",
    "disablePointerMoveEvents": "disable pointer move events",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Make mesh ignore pointer move events, default is false",
    "bitbybit.babylon.mesh.getPickable": "get pickable",
    "getPickable": "get pickable",
    "bitbybit.babylon.mesh.getPickable_description": "Change the pickable property of the drawn mesh",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "get meshes where name contains",
    "getMeshesWhereNameContains": "get meshes where name contains",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Gets meshes that have names which contain a given text",
    "name": "name",
    "string": "string",
    "bitbybit.babylon.mesh.getChildMeshes": "get child meshes",
    "getChildMeshes": "get child meshes",
    "bitbybit.babylon.mesh.getChildMeshes_description": "gets child meshes",
    "directDescendantsOnly": "direct descendants only",
    "bitbybit.babylon.mesh.getMeshesOfId": "get meshes of id",
    "getMeshesOfId": "get meshes of id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Gets meshes of id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "get mesh of id",
    "getMeshOfId": "get mesh of id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Gets mesh of id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "get mesh of unique id",
    "getMeshOfUniqueId": "get mesh of unique id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Gets mesh of unique id",
    "uniqueId": "unique id",
    "bitbybit.babylon.mesh.mergeMeshes": "merge meshes",
    "mergeMeshes": "merge meshes",
    "bitbybit.babylon.mesh.mergeMeshes_description": "merges multiple meshes into one",
    "edit": "edit",
    "arrayOfMeshes": "array of meshes",
    "BABYLON.Mesh[]": "babylon mesh array",
    "disposeSource": "dispose source",
    "allow32BitsIndices": "allow 32 bits indices",
    "meshSubclass": "mesh subclass",
    "subdivideWithSubMeshes": "subdivide with sub meshes",
    "multiMultiMaterials": "multi multi materials",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "convert to flat shaded mesh",
    "convertToFlatShadedMesh": "convert to flat shaded mesh",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Convers mesh to flat shaded mesh",
    "bitbybit.babylon.mesh.clone": "clone",
    "clone": "clone",
    "bitbybit.babylon.mesh.clone_description": "clones the mesh",
    "bitbybit.babylon.mesh.cloneToPositions": "clone to positions",
    "cloneToPositions": "clone to positions",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Clones the mesh to positions",
    "positions": "positions",
    "Base.Point3[]": "base point 3 array",
    "bitbybit.babylon.mesh.setId": "set id",
    "setId": "set id",
    "bitbybit.babylon.mesh.setId_description": "Change the id of the drawn mesh",
    "bitbybit.babylon.mesh.getId": "get id",
    "getId": "get id",
    "bitbybit.babylon.mesh.getId_description": "Get the id of the drawn mesh",
    "bitbybit.babylon.mesh.getUniqueId": "get unique id",
    "getUniqueId": "get unique id",
    "bitbybit.babylon.mesh.getUniqueId_description": "Get the unique id of the drawn mesh",
    "bitbybit.babylon.mesh.setName": "set name",
    "setName": "set name",
    "bitbybit.babylon.mesh.setName_description": "Change the name of the drawn mesh",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "get vertices as polygon points",
    "getVerticesAsPolygonPoints": "get vertices as polygon points",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Gets the vertices as polygon points. These can be used with other construction methods to create meshes. Mesh must be triangulated.",
    "bitbybit.babylon.mesh.getName": "get name",
    "getName": "get name",
    "bitbybit.babylon.mesh.getName_description": "Gets the name of babylon mesh",
    "bitbybit.babylon.mesh.setMaterial": "set material",
    "setMaterial": "set material",
    "bitbybit.babylon.mesh.setMaterial_description": "Change the material of the drawn mesh",
    "material": "material",
    "BABYLON.Material": "babylon material",
    "bitbybit.babylon.mesh.getMaterial": "get material",
    "getMaterial": "get material",
    "bitbybit.babylon.mesh.getMaterial_description": "Gets the material of babylon mesh",
    "bitbybit.babylon.mesh.getPosition": "get position",
    "getPosition": "get position",
    "bitbybit.babylon.mesh.getPosition_description": "Gets the position as point of babylonjs mesh",
    "bitbybit.babylon.mesh.getAbsolutePosition": "get absolute position",
    "getAbsolutePosition": "get absolute position",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Gets the absolute position in the world as point of babylonjs mesh",
    "bitbybit.babylon.mesh.getRotation": "get rotation",
    "getRotation": "get rotation",
    "bitbybit.babylon.mesh.getRotation_description": "Gets the rotation vector of babylonjs mesh",
    "bitbybit.babylon.mesh.getScale": "get scale",
    "getScale": "get scale",
    "bitbybit.babylon.mesh.getScale_description": "Gets the scale vector of babylonjs mesh",
    "bitbybit.babylon.mesh.moveForward": "move forward",
    "moveForward": "move forward",
    "bitbybit.babylon.mesh.moveForward_description": "Moves babylonjs mesh forward in local space",
    "move": "move",
    "distance": "distance",
    "bitbybit.babylon.mesh.moveBackward": "move backward",
    "moveBackward": "move backward",
    "bitbybit.babylon.mesh.moveBackward_description": "Moves babylonjs mesh backward in local space",
    "bitbybit.babylon.mesh.moveUp": "move up",
    "moveUp": "move up",
    "bitbybit.babylon.mesh.moveUp_description": "Moves babylonjs mesh up in local space",
    "bitbybit.babylon.mesh.moveDown": "move down",
    "moveDown": "move down",
    "bitbybit.babylon.mesh.moveDown_description": "Moves babylonjs mesh down in local space",
    "bitbybit.babylon.mesh.moveRight": "move right",
    "moveRight": "move right",
    "bitbybit.babylon.mesh.moveRight_description": "Moves babylonjs mesh right in local space",
    "bitbybit.babylon.mesh.moveLeft": "move left",
    "moveLeft": "move left",
    "bitbybit.babylon.mesh.moveLeft_description": "Moves babylonjs mesh left in local space",
    "bitbybit.babylon.mesh.yaw": "yaw",
    "yaw": "yaw",
    "bitbybit.babylon.mesh.yaw_description": "Rotates babylonjs mesh around local y axis",
    "rotate": "rotate",
    "bitbybit.babylon.mesh.pitch": "pitch",
    "pitch": "pitch",
    "bitbybit.babylon.mesh.pitch_description": "Rotates babylonjs mesh around local x axis",
    "bitbybit.babylon.mesh.roll": "roll",
    "roll": "roll",
    "bitbybit.babylon.mesh.roll_description": "Rotates babylonjs mesh around local z axis",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "rotate around axis with position",
    "rotateAroundAxisWithPosition": "rotate around axis with position",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Rotates the mesh around axis and given position by a given angle",
    "axis": "axis",
    "angle": "angle",
    "bitbybit.babylon.mesh.setPosition": "set position",
    "setPosition": "set position",
    "bitbybit.babylon.mesh.setPosition_description": "Updates the position of the BabylonJS mesh or instanced mesh",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "babylon mesh or instanced mesh",
    "bitbybit.babylon.mesh.setRotation": "set rotation",
    "setRotation": "set rotation",
    "bitbybit.babylon.mesh.setRotation_description": "Updates the rotation of the BabylonJS mesh or instanced mesh",
    "bitbybit.babylon.mesh.setScale": "set scale",
    "setScale": "set scale",
    "bitbybit.babylon.mesh.setScale_description": "Updates the scale of the BabylonJS mesh or instanced mesh",
    "scale": "scale",
    "bitbybit.babylon.mesh.intersectsMesh": "intersects mesh",
    "intersectsMesh": "intersects mesh",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Checks wether mesh intersects another mesh mesh",
    "intersects": "intersects",
    "babylonMesh2": "babylon mesh 2",
    "precise": "precise",
    "includeDescendants": "include descendants",
    "bitbybit.babylon.mesh.intersectsPoint": "intersects point",
    "intersectsPoint": "intersects point",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Checks wether mesh intersects point",
    "point": "point",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "mesh instance and transform no return",
    "createMeshInstanceAndTransformNoReturn": "mesh instance and transform no return",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Creates mesh instance for optimised rendering. This method will check if mesh contains children and will create instances for each child. These are optimised for max performance when rendering many similar objects in the scene. This method returns instances as childrens in a new mesh. If the mesh has children, then every child goes a mesh instance.",
    "instance": "instance",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "mesh instance and transform",
    "createMeshInstanceAndTransform": "mesh instance and transform",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Creates mesh instance for optimised rendering. This method will check if mesh contains children and will create instances for each child. These are optimised for max performance when rendering many similar objects in the scene. This method returns instances as childrens in a new mesh. If the mesh has children, then every child goes a mesh instance.",
    "bitbybit.babylon.mesh.createMeshInstance": "mesh instance",
    "createMeshInstance": "mesh instance",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Creates mesh instance. These are optimised for max performance when rendering many similar objects in the scene. If the mesh has children, then every child gets a mesh instance.",
    "bitbybit.babylon.gaussianSplatting.create": "gaussian splatting",
    "gaussianSplatting": "gaussian splatting",
    "create": "create",
    "bitbybit.babylon.gaussianSplatting.create_description": "creates gaussian splatting mesh",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "clone gaussian splatting",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clones gaussian splatting mesh",
    "multiply": "multiply",
    "BABYLON.GaussianSplattingMesh": "babylon gaussian splatting mesh",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "get splat positions",
    "getSplatPositions": "get splat positions",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Gets splat positions of the gaussian splat mesh",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "freeze projection matrix",
    "camera": "camera",
    "freezeProjectionMatrix": "freeze projection matrix",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Freeze projection matrix of the camera",
    "adjust": "adjust",
    "BABYLON.Camera": "babylon camera",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "unfreeze projection matrix",
    "unfreezeProjectionMatrix": "unfreeze projection matrix",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Unfreeze projection matrix of the camera",
    "bitbybit.babylon.camera.setPosition": "set position",
    "bitbybit.babylon.camera.setPosition_description": "Changes the position of a camera",
    "BABYLON.TargetCamera": "babylon target camera",
    "bitbybit.babylon.camera.getPosition": "get position",
    "bitbybit.babylon.camera.getPosition_description": "Gets the position of a camera",
    "bitbybit.babylon.camera.setTarget": "set target",
    "setTarget": "set target",
    "bitbybit.babylon.camera.setTarget_description": "Changes the target of a camera",
    "target": "target",
    "bitbybit.babylon.camera.getTarget": "get target",
    "getTarget": "get target",
    "bitbybit.babylon.camera.getTarget_description": "Gets the target of a camera",
    "bitbybit.babylon.camera.setSpeed": "set speed",
    "setSpeed": "set speed",
    "bitbybit.babylon.camera.setSpeed_description": "Changes the speed of a camera",
    "speed": "speed",
    "bitbybit.babylon.camera.getSpeed": "get speed",
    "getSpeed": "get speed",
    "bitbybit.babylon.camera.getSpeed_description": "Gets the speed of a camera",
    "bitbybit.babylon.camera.setMinZ": "set min z",
    "setMinZ": "set min z",
    "bitbybit.babylon.camera.setMinZ_description": "Changes the minZ of a camera",
    "minZ": "min z",
    "bitbybit.babylon.camera.setMaxZ": "set max z",
    "setMaxZ": "set max z",
    "bitbybit.babylon.camera.setMaxZ_description": "Changes the maxZ of a camera",
    "maxZ": "max z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "make camera orthographic",
    "makeCameraOrthographic": "make camera orthographic",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Changes the the mode of the camera to orthographic",
    "orthoLeft": "ortho left",
    "orthoRight": "ortho right",
    "orthoBottom": "ortho bottom",
    "orthoTop": "ortho top",
    "bitbybit.babylon.camera.makeCameraPerspective": "make camera perspective",
    "makeCameraPerspective": "make camera perspective",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Changes the mode of a camera to perspective",
    "bitbybit.babylon.camera.free.create": "free camera",
    "free": "free",
    "bitbybit.babylon.camera.free.create_description": "Creates a free camera",
    "bitbybit.babylon.camera.arcRotate.create": "arc rotate camera",
    "arcRotate": "arc rotate",
    "bitbybit.babylon.camera.arcRotate.create_description": "Creates a camera that rotates around a given target while traveling the arc path. This camera is suitable for simple 3D navigation and is a default camera used by bitbybit.",
    "radius": "radius",
    "alpha": "alpha",
    "beta": "beta",
    "lowerRadiusLimit": "lower radius limit",
    "upperRadiusLimit": "upper radius limit",
    "lowerAlphaLimit": "lower alpha limit",
    "upperAlphaLimit": "upper alpha limit",
    "lowerBetaLimit": "lower beta limit",
    "upperBetaLimit": "upper beta limit",
    "angularSensibilityX": "angular sensibility x",
    "angularSensibilityY": "angular sensibility y",
    "panningSensibility": "panning sensibility",
    "wheelPrecision": "wheel precision",
    "bitbybit.babylon.camera.target.create": "target camera",
    "bitbybit.babylon.camera.target.create_description": "Creates a target camera",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "immersive ar experience",
    "webXr": "web xr",
    "simple": "simple",
    "createImmersiveARExperience": "immersive ar experience",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Creates default XR experience in immersive-ar mode",
    "scene": "scene",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "default xr experience with teleportation",
    "createDefaultXRExperienceWithTeleportation": "default xr experience with teleportation",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Creates default XR experience with teleportation that is very basic and works for simple scenarios",
    "groundMeshes": "ground meshes",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "default xr experience with teleportation return",
    "createDefaultXRExperienceWithTeleportationReturn": "default xr experience with teleportation return",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Creates default XR experience with teleportation that is very basic and works for simple scenarios",
    "bitbybit.babylon.node.drawNode": "draw node",
    "node": "node",
    "drawNode": "draw node",
    "bitbybit.babylon.node.drawNode_description": "Draws a node of given size with given colours for every axis",
    "BABYLON.TransformNode": "babylon transform node",
    "bitbybit.babylon.node.drawNodes": "draw nodes",
    "drawNodes": "draw nodes",
    "bitbybit.babylon.node.drawNodes_description": "Draws a nodes of given size with given colours for every axis",
    "nodes": "nodes",
    "BABYLON.TransformNode[]": "babylon transform node array",
    "bitbybit.babylon.node.createNodeFromRotation": "node from rotation",
    "createNodeFromRotation": "node from rotation",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Creates a node on the origin with the given rotations in the parent coordinate system",
    "parent": "parent",
    "BABYLON.TransformNode | null": "babylon transform node or null",
    "origin": "origin",
    "bitbybit.babylon.node.createWorldNode": "world node",
    "createWorldNode": "world node",
    "bitbybit.babylon.node.createWorldNode_description": "Creates a world node which has root node as his parent",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "get absolute forward vector",
    "getAbsoluteForwardVector": "get absolute forward vector",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Gets the absolute forward facing vector in world space",
    "bitbybit.babylon.node.getAbsoluteRightVector": "get absolute right vector",
    "getAbsoluteRightVector": "get absolute right vector",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Gets the absolute right facing vector in world space",
    "bitbybit.babylon.node.getAbsoluteUpVector": "get absolute up vector",
    "getAbsoluteUpVector": "get absolute up vector",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Gets the absolute up facing vector in world space",
    "bitbybit.babylon.node.getAbsolutePosition": "get absolute position",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Gets the absolute position of the node as origin vector in world space",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "get absolute rotation transformation",
    "getAbsoluteRotationTransformation": "get absolute rotation transformation",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Gets the absolute rotation of the node as a transformation matrix encoded in array of 16 numbers",
    "bitbybit.babylon.node.getRotationTransformation": "get rotation transformation",
    "getRotationTransformation": "get rotation transformation",
    "bitbybit.babylon.node.getRotationTransformation_description": "Gets the rotation of the node in local parent coordinate space as a transformation matrix encoded in array of 16 numbers",
    "bitbybit.babylon.node.getChildren": "get children",
    "getChildren": "get children",
    "bitbybit.babylon.node.getChildren_description": "Gets children of the node",
    "bitbybit.babylon.node.getParent": "get parent",
    "bitbybit.babylon.node.getParent_description": "Gets parent of the node",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "get position in local space",
    "getPositionExpressedInLocalSpace": "get position in local space",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Gets the position of the node expressed in local space",
    "bitbybit.babylon.node.getRootNode": "get root node",
    "getRootNode": "get root node",
    "bitbybit.babylon.node.getRootNode_description": "Gets the root node",
    "bitbybit.babylon.node.getRotation": "get rotation",
    "bitbybit.babylon.node.getRotation_description": "Gets the euler rotations",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "rotate around axis with position",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Rotates the node around axis and given position by a given angle",
    "bitbybit.babylon.node.rotate": "rotate",
    "bitbybit.babylon.node.rotate_description": "Rotates the node around the origin and given axis",
    "bitbybit.babylon.node.setAbsolutePosition": "set absolute position",
    "setAbsolutePosition": "set absolute position",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Sets the absolute position of the node",
    "bitbybit.babylon.node.setDirection": "set direction",
    "setDirection": "set direction",
    "bitbybit.babylon.node.setDirection_description": "Sets the direction of the node",
    "direction": "direction",
    "number[]": "number array",
    "bitbybit.babylon.node.setParent": "set parent",
    "bitbybit.babylon.node.setParent_description": "Sets the new parent to the node",
    "parentNode": "parent node",
    "bitbybit.babylon.node.translate": "translate",
    "translate": "translate",
    "bitbybit.babylon.node.translate_description": "Translates the node by a given direction vector and a distance",
    "bitbybit.babylon.scene.backgroundColour": "background colour",
    "backgroundColour": "background colour",
    "bitbybit.babylon.scene.backgroundColour_description": "Changes the scene background colour for 3D space",
    "environment": "environment",
    "colour": "colour",
    "bitbybit.babylon.scene.activateCamera": "activate camera",
    "activateCamera": "activate camera",
    "bitbybit.babylon.scene.activateCamera_description": "Activate camera by overwriting currently active camera",
    "bitbybit.babylon.scene.useRightHandedSystem": "use right handed system",
    "useRightHandedSystem": "use right handed system",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Use right handed system",
    "system": "system",
    "use": "use",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "draw point light no return",
    "drawPointLightNoReturn": "draw point light no return",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Creates and draws a point light in the scene but does not output anything",
    "lights": "lights",
    "intensity": "intensity",
    "diffuse": "diffuse",
    "specular": "specular",
    "shadowGeneratorMapSize": "shadow generator map size",
    "enableShadows": "enable shadows",
    "shadowDarkness": "shadow darkness",
    "shadowUsePercentageCloserFiltering": "shadow use percentage closer filtering",
    "shadowContactHardeningLightSizeUVRatio": "shadow contact hardening light size uv ratio",
    "shadowBias": "shadow bias",
    "shadowNormalBias": "shadow normal bias",
    "shadowMaxZ": "shadow max z",
    "shadowMinZ": "shadow min z",
    "bitbybit.babylon.scene.getShadowGenerators": "get shadow generators",
    "getShadowGenerators": "get shadow generators",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Get shadow generators added by light sources through bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "draw point light",
    "drawPointLight": "draw point light",
    "bitbybit.babylon.scene.drawPointLight_description": "Creates and draws a point light in the scene",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "draw directional light no return",
    "drawDirectionalLightNoReturn": "draw directional light no return",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Creates and draws a directional light in the scene",
    "bitbybit.babylon.scene.drawDirectionalLight": "draw directional light",
    "drawDirectionalLight": "draw directional light",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Creates and draws a directional light in the scene",
    "bitbybit.babylon.scene.getActiveCamera": "get active camera",
    "getActiveCamera": "get active camera",
    "bitbybit.babylon.scene.getActiveCamera_description": "Gets the active camera of the scene",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "adjust active arc rotate camera",
    "adjustActiveArcRotateCamera": "adjust active arc rotate camera",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Adjusts the active arc rotate camera with configuration parameters",
    "lookAt": "look at",
    "bitbybit.babylon.scene.clearAllDrawn": "clear all drawn",
    "clearAllDrawn": "clear all drawn",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Clears all of the drawn objects in the 3D scene",
    "bitbybit.babylon.scene.enableSkybox": "enable skybox",
    "enableSkybox": "enable skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "Enables skybox",
    "skybox": "skybox",
    "Base.skyboxEnum": "base skybox enum",
    "blur": "blur",
    "environmentIntensity": "environment intensity",
    "bitbybit.babylon.scene.fog": "fog",
    "fog": "fog",
    "bitbybit.babylon.scene.fog_description": "Enables fog mode",
    "mode": "mode",
    "Base.fogModeEnum": "base fog mode enum",
    "color": "color",
    "density": "density",
    "start": "start",
    "end": "end",
    "bitbybit.babylon.transforms.rotationCenterAxis": "rotation center axis",
    "transforms": "transforms",
    "rotationCenterAxis": "rotation center axis",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Creates a rotation transformations around the center and an axis",
    "center": "center",
    "bitbybit.babylon.transforms.rotationCenterX": "rotation center x",
    "rotationCenterX": "rotation center x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Creates a rotation transformations around the center and an X axis",
    "bitbybit.babylon.transforms.rotationCenterY": "rotation center y",
    "rotationCenterY": "rotation center y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Creates a rotation transformations around the center and an Y axis",
    "bitbybit.babylon.transforms.rotationCenterZ": "rotation center z",
    "rotationCenterZ": "rotation center z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Creates a rotation transformations around the center and an Z axis",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "rotation center yaw pitch roll",
    "rotationCenterYawPitchRoll": "rotation center yaw pitch roll",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Creates a rotation transformations with yaw pitch and roll",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "scale center xyz",
    "scaleCenterXYZ": "scale center xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Scale transformation around center and xyz directions",
    "scaleXyz": "scale xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "scale xyz",
    "scaleXYZ": "scale xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Creates the scale transformation in x, y and z directions",
    "bitbybit.babylon.transforms.uniformScale": "uniform scale",
    "uniformScale": "uniform scale",
    "bitbybit.babylon.transforms.uniformScale_description": "Creates uniform scale transformation",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "uniform scale from center",
    "uniformScaleFromCenter": "uniform scale from center",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Creates uniform scale transformation from the center",
    "bitbybit.babylon.transforms.translationXYZ": "translation xyz",
    "translationXYZ": "translation xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "Creates the translation transformation",
    "translation": "translation",
    "bitbybit.babylon.transforms.translationsXYZ": "translations xyz",
    "translationsXYZ": "translations xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Creates the translation transformation",
    "translations": "translations",
    "Base.Vector3[]": "base vector 3 array",
    "bitbybit.babylon.io.loadAssetIntoScene": "load asset into scene",
    "io": "io",
    "loadAssetIntoScene": "load asset into scene",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Imports mesh from the asset that you have uploaded for the project. You must upload your assets to your project via project management page.",
    "load": "load",
    "assetFile": "asset file",
    "File": "file",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "load asset into scene no return",
    "loadAssetIntoSceneNoReturn": "load asset into scene no return",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Imports mesh from the asset that you have uploaded for the project. You must upload your assets to your project via project management page.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "load asset into scene from root url",
    "loadAssetIntoSceneFromRootUrl": "load asset into scene from root url",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Imports mesh from the asset url that you have uploaded to an accessible web storage. Keep in mind that files need to be publically accessible for this to work, be sure that CORS access is enabled for the assets.",
    "rootUrl": "root url",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "load asset into scene from root url no return",
    "loadAssetIntoSceneFromRootUrlNoReturn": "load asset into scene from root url no return",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Imports mesh from the asset url that you have uploaded to an accessible web storage. Keep in mind that files need to be publically accessible for this to work, be sure that CORS access is enabled for the assets.",
    "bitbybit.babylon.io.exportBabylon": "export babylon",
    "exportBabylon": "export babylon",
    "bitbybit.babylon.io.exportBabylon_description": "Exports the whole scene to .babylon scene format. You can then edit it further in babylonjs editors.",
    "export": "export",
    "fileName": "file name",
    "bitbybit.babylon.io.exportGLB": "export glb",
    "exportGLB": "export glb",
    "bitbybit.babylon.io.exportGLB_description": "Exports the whole scene to .glb format. This file format has become industry standard for web models.",
    "discardSkyboxAndGrid": "discard skybox and grid",
    "bitbybit.babylon.io.exportMeshToStl": "export mesh to stl",
    "exportMeshToStl": "export mesh to stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "Exports the mesh with its children to stl",
    "bitbybit.babylon.io.exportMeshesToStl": "export meshes to stl",
    "exportMeshesToStl": "export meshes to stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Exports the meshes to stl",
    "meshes": "meshes",
    "bitbybit.babylon.ray.createPickingRay": "picking ray",
    "ray": "ray",
    "createPickingRay": "picking ray",
    "bitbybit.babylon.ray.createPickingRay_description": "Creates a picking ray of the current mouse position in the active camera",
    "bitbybit.babylon.ray.createRay": "ray",
    "createRay": "ray",
    "bitbybit.babylon.ray.createRay_description": "Create a ray that start at origin, has direction vector and optionally length",
    "length": "length",
    "bitbybit.babylon.ray.createRayFromTo": "ray from to",
    "createRayFromTo": "ray from to",
    "bitbybit.babylon.ray.createRayFromTo_description": "Create a ray from one point to another",
    "from": "from",
    "to": "to",
    "bitbybit.babylon.ray.getOrigin": "get origin",
    "getOrigin": "get origin",
    "bitbybit.babylon.ray.getOrigin_description": "Get the origin of the ray",
    "BABYLON.Ray": "babylon ray",
    "bitbybit.babylon.ray.getDirection": "get direction",
    "getDirection": "get direction",
    "bitbybit.babylon.ray.getDirection_description": "Get the direction of the ray",
    "bitbybit.babylon.ray.getLength": "get length",
    "getLength": "get length",
    "bitbybit.babylon.ray.getLength_description": "Get the length of the ray",
    "bitbybit.babylon.pick.pickWithRay": "pick with ray",
    "pick": "pick",
    "pickWithRay": "pick with ray",
    "bitbybit.babylon.pick.pickWithRay_description": "Get a hit result of picking with ray",
    "bitbybit.babylon.pick.pickWithPickingRay": "pick with picking ray",
    "pickWithPickingRay": "pick with picking ray",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Pick with picking ray of the current mouse position in the active camera",
    "bitbybit.babylon.pick.getDistance": "get distance",
    "getDistance": "get distance",
    "bitbybit.babylon.pick.getDistance_description": "Get the distance to the object if picking result exists",
    "get from pick info": "get from pick info",
    "pickInfo": "pick info",
    "BABYLON.PickingInfo": "babylon picking info",
    "bitbybit.babylon.pick.getPickedMesh": "get picked mesh",
    "getPickedMesh": "get picked mesh",
    "bitbybit.babylon.pick.getPickedMesh_description": "Get the picked mesh",
    "bitbybit.babylon.pick.getPickedPoint": "get picked point",
    "getPickedPoint": "get picked point",
    "bitbybit.babylon.pick.getPickedPoint_description": "Get the picked point",
    "bitbybit.babylon.pick.hit": "hit",
    "hit": "hit",
    "bitbybit.babylon.pick.hit_description": "Check if pick ray hit something in the scene or not",
    "bitbybit.babylon.pick.getSubMeshId": "get sub mesh id",
    "getSubMeshId": "get sub mesh id",
    "bitbybit.babylon.pick.getSubMeshId_description": "Gets the unique submesh id if it was picked",
    "bitbybit.babylon.pick.getSubMeshFaceId": "get sub mesh face id",
    "getSubMeshFaceId": "get sub mesh face id",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Gets the unique submesh face id if it was picked",
    "bitbybit.babylon.pick.getBU": "get bu",
    "getBU": "get bu",
    "bitbybit.babylon.pick.getBU_description": "Gets the the barycentric U coordinate that is used when calculating the texture coordinates of the collision",
    "bitbybit.babylon.pick.getBV": "get bv",
    "getBV": "get bv",
    "bitbybit.babylon.pick.getBV_description": "Gets the the barycentric V coordinate that is used when calculating the texture coordinates of the collision",
    "bitbybit.babylon.pick.getPickedSprite": "get picked sprite",
    "getPickedSprite": "get picked sprite",
    "bitbybit.babylon.pick.getPickedSprite_description": "Get the picked sprite",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr metallic roughness",
    "pbrMetallicRoughness": "pbr metallic roughness",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Create PBR metallic roughnes material.",
    "baseColor": "base color",
    "emissiveColor": "emissive color",
    "metallic": "metallic",
    "roughness": "roughness",
    "zOffset": "z offset",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "set base color",
    "setBaseColor": "set base color",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Sets the base color of material",
    "BABYLON.PBRMetallicRoughnessMaterial": "babylon pbr metallic roughness material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "set metallic",
    "setMetallic": "set metallic",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Sets the metallic property of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "set roughness",
    "setRoughness": "set roughness",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Sets the roughness of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "set alpha",
    "setAlpha": "set alpha",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Sets the alpha of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "set back face culling",
    "setBackFaceCulling": "set back face culling",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Sets the back face culling of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "set base texture",
    "setBaseTexture": "set base texture",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Sets the texture of material",
    "baseTexture": "base texture",
    "BABYLON.Texture": "babylon texture",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "get base color",
    "getBaseColor": "get base color",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Gets the base color of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "get metallic",
    "getMetallic": "get metallic",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Gets the metallic property of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "get roughness",
    "getRoughness": "get roughness",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Gets the roughness of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "get alpha",
    "getAlpha": "get alpha",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Gets the alpha of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "get back face culling",
    "getBackFaceCulling": "get back face culling",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Gets the back face culling of material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "get base texture",
    "getBaseTexture": "get base texture",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Get the base texture of material",
    "bitbybit.babylon.material.skyMaterial.create": "sky material",
    "skyMaterial": "sky material",
    "bitbybit.babylon.material.skyMaterial.create_description": "Create Sky Material",
    "luminance": "luminance",
    "turbidity": "turbidity",
    "rayleigh": "rayleigh",
    "mieCoefficient": "mie coefficient",
    "mieDirectionalG": "mie directional g",
    "inclination": "inclination",
    "azimuth": "azimuth",
    "sunPosition": "sun position",
    "useSunPosition": "use sun position",
    "cameraOffset": "camera offset",
    "up": "up",
    "dithering": "dithering",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "set luminance",
    "setLuminance": "set luminance",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Sets the luminance of the sky material",
    "MATERIALS.SkyMaterial": "materials sky material",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "set turbidity",
    "setTurbidity": "set turbidity",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Sets the turbidity of the sky material",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "set rayleigh",
    "setRayleigh": "set rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Sets the rayleigh of the sky material",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "set mie coefficient",
    "setMieCoefficient": "set mie coefficient",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Sets the mieCoefficient of the sky material",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "set mie directional g",
    "setMieDirectionalG": "set mie directional g",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Sets the mieDirectionalG of the sky material",
    "bitbybit.babylon.material.skyMaterial.setDistance": "set distance",
    "setDistance": "set distance",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Sets the distance of the sky material",
    "bitbybit.babylon.material.skyMaterial.setInclination": "set inclination",
    "setInclination": "set inclination",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Sets the inclination of the sky material",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "set azimuth",
    "setAzimuth": "set azimuth",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Sets the azimuth of the sky material",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "set sun position",
    "setSunPosition": "set sun position",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Sets the sun position of the sky material",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "set use sun position",
    "setUseSunPosition": "set use sun position",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Sets the use sun position of the sky material",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "set camera offset",
    "setCameraOffset": "set camera offset",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Sets the camera offset of the sky material",
    "bitbybit.babylon.material.skyMaterial.setUp": "set up",
    "setUp": "set up",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Sets the up of the sky material",
    "bitbybit.babylon.material.skyMaterial.setDithering": "set dithering",
    "setDithering": "set dithering",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Sets the dithering of the sky material",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "get luminance",
    "getLuminance": "get luminance",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Gets the luminance of the sky material",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "get turbidity",
    "getTurbidity": "get turbidity",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Gets the turbidity of the sky material",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "get rayleigh",
    "getRayleigh": "get rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Gets the rayleigh of the sky material",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "get mie coefficient",
    "getMieCoefficient": "get mie coefficient",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Gets the mieCoefficient of the sky material",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "get mie directional g",
    "getMieDirectionalG": "get mie directional g",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Gets the mieDirectionalG of the sky material",
    "bitbybit.babylon.material.skyMaterial.getDistance": "get distance",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Gets the distance of the sky material",
    "bitbybit.babylon.material.skyMaterial.getInclination": "get inclination",
    "getInclination": "get inclination",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Gets the inclination of the sky material",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "get azimuth",
    "getAzimuth": "get azimuth",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Gets the azimuth of the sky material",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "get sun position",
    "getSunPosition": "get sun position",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Gets the sun position of the sky material",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "get use sun position",
    "getUseSunPosition": "get use sun position",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Gets the use sun position of the sky material",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "get camera offset",
    "getCameraOffset": "get camera offset",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Gets the camera offset of the sky material",
    "bitbybit.babylon.material.skyMaterial.getUp": "get up",
    "getUp": "get up",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Gets the up of the sky material",
    "bitbybit.babylon.material.skyMaterial.getDithering": "get dithering",
    "getDithering": "get dithering",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Gets the dithering of the sky material",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "set direction to target",
    "shadowLight": "shadow light",
    "setDirectionToTarget": "set direction to target",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Sets the direction of the shadow light",
    "BABYLON.ShadowLight": "babylon shadow light",
    "bitbybit.babylon.lights.shadowLight.setPosition": "set position",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Sets the position of the shadow light",
    "bitbybit.babylon.meshBuilder.createBox": "box",
    "meshBuilder": "mesh builder",
    "createBox": "box",
    "bitbybit.babylon.meshBuilder.createBox_description": "Creates a box mesh",
    "create simple": "create simple",
    "depth": "depth",
    "sideOrientation": "side orientation",
    "BabylonMesh.sideOrientationEnum": "babylon mesh side orientation enum",
    "bitbybit.babylon.meshBuilder.createCube": "cube",
    "createCube": "cube",
    "bitbybit.babylon.meshBuilder.createCube_description": "Creates a cube mesh",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "square plane",
    "createSquarePlane": "square plane",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Creates a square plane mesh",
    "bitbybit.babylon.meshBuilder.createSphere": "sphere",
    "createSphere": "sphere",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Creates a sphere mesh",
    "diameter": "diameter",
    "segments": "segments",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "ico sphere",
    "createIcoSphere": "ico sphere",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Create ico sphere",
    "radiusX": "radius x",
    "radiusY": "radius y",
    "radiusZ": "radius z",
    "flat": "flat",
    "bitbybit.babylon.meshBuilder.createDisc": "disc",
    "createDisc": "disc",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Creates a disc",
    "tessellation": "tessellation",
    "arc": "arc",
    "bitbybit.babylon.meshBuilder.createTorus": "torus",
    "createTorus": "torus",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Create a torus mesh",
    "thickness": "thickness",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "torus knot",
    "createTorusKnot": "torus knot",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Create a torus knot mesh",
    "tube": "tube",
    "radialSegments": "radial segments",
    "tubularSegments": "tubular segments",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polygon",
    "createPolygon": "polygon",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Create a polygon mesh",
    "shape": "shape",
    "holes": "holes",
    "Base.Vector3[][]": "base vector 3 array array",
    "smoothingThreshold": "smoothing threshold",
    "wrap": "wrap",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extrude polygon",
    "extrudePolygon": "extrude polygon",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Create extruded polygon mesh",
    "bitbybit.babylon.meshBuilder.createTube": "tube",
    "createTube": "tube",
    "bitbybit.babylon.meshBuilder.createTube_description": "Create a tube mesh",
    "path": "path",
    "cap": "cap",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "polyhedron",
    "createPolyhedron": "polyhedron",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Create a polyhedron mesh",
    "type": "type",
    "sizeX": "size x",
    "sizeY": "size y",
    "sizeZ": "size z",
    "custom": "custom",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodesic",
    "createGeodesic": "geodesic",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Create geodesic mesh",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Create goldberg mesh",
    "bitbybit.babylon.meshBuilder.createCapsule": "capsule",
    "createCapsule": "capsule",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Create capsule mesh",
    "orientation": "orientation",
    "capSubdivisions": "cap subdivisions",
    "radiusTop": "radius top",
    "radiusBottom": "radius bottom",
    "topCapSubdivisions": "top cap subdivisions",
    "bottomCapSubdivisions": "bottom cap subdivisions",
    "bitbybit.babylon.meshBuilder.createCylinder": "cylinder",
    "createCylinder": "cylinder",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Create a cylinder mesh",
    "diameterTop": "diameter top",
    "diameterBottom": "diameter bottom",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "extruded shape",
    "createExtrudedSahpe": "extruded shape",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Create extruded shape",
    "closeShape": "close shape",
    "closePath": "close path",
    "bitbybit.babylon.meshBuilder.createRibbon": "ribbon",
    "createRibbon": "ribbon",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Create a ribbon mesh",
    "pathArray": "path array",
    "closeArray": "close array",
    "offset": "offset",
    "bitbybit.babylon.meshBuilder.createLathe": "lathe",
    "createLathe": "lathe",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Create lathe mesh",
    "closed": "closed",
    "bitbybit.babylon.meshBuilder.createGround": "ground",
    "createGround": "ground",
    "bitbybit.babylon.meshBuilder.createGround_description": "Create the ground mesh",
    "subdivisionsX": "subdivisions x",
    "subdivisionsY": "subdivisions y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "rectangle plane",
    "createRectanglePlane": "rectangle plane",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Creates a rectangle plane mesh",
    "bitbybit.babylon.texture.createSimple": "simple texture",
    "texture": "texture",
    "createSimple": "simple",
    "bitbybit.babylon.texture.createSimple_description": "Creates texture from URL from a few basic options. If you loaded the asset via the file, create object url and pass it here.",
    "invertY": "invert y",
    "invertZ": "invert z",
    "wAng": "w ang",
    "uScale": "u scale",
    "vScale": "v scale",
    "uOffset": "u offset",
    "vOffset": "v offset",
    "samplingMode": "sampling mode",
    "samplingModeEnum": "sampling mode enum",
    "bitbybit.babylon.tools.createScreenshot": "screenshot",
    "tools": "tools",
    "createScreenshot": "screenshot",
    "bitbybit.babylon.tools.createScreenshot_description": "Creates a screenshot of the scene",
    "screenshots": "screenshots",
    "mimeType": "mime type",
    "quality": "quality",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "screenshot and download",
    "createScreenshotAndDownload": "screenshot and download",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Creates a screenshot of the scene and download file",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "full screen ui",
    "gui": "gui",
    "advancedDynamicTexture": "advanced dynamic texture",
    "createFullScreenUI": "full screen ui",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "creates full screen ui",
    "spaces": "spaces",
    "foreground": "foreground",
    "adaptiveScaling": "adaptive scaling",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "for mesh",
    "createForMesh": "for mesh",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Creates advanced dynamic texture for a mesh",
    "BABYLON.AbstractMesh": "babylon abstract mesh",
    "supportPointerMove": "support pointer move",
    "onlyAlphaTesting": "only alpha testing",
    "sampling": "sampling",
    "BabylonTexture.samplingModeEnum": "babylon texture sampling mode enum",
    "bitbybit.babylon.gui.control.changeControlPadding": "change control padding",
    "control": "control",
    "changeControlPadding": "change control padding",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Change the padding for the control",
    "positioning": "positioning",
    "BABYLON.GUI.Control": "babylon gui control",
    "paddingLeft": "padding left",
    "number | string": "number or string",
    "paddingRight": "padding right",
    "paddingTop": "padding top",
    "paddingBottom": "padding bottom",
    "bitbybit.babylon.gui.control.changeControlAlignment": "change control alignment",
    "changeControlAlignment": "change control alignment",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Change the alignment for the control",
    "T": "t",
    "horizontalAlignment": "horizontal alignment",
    "horizontalAlignmentEnum": "horizontal alignment enum",
    "verticalAlignment": "vertical alignment",
    "verticalAlignmentEnum": "vertical alignment enum",
    "bitbybit.babylon.gui.control.cloneControl": "clone control",
    "cloneControl": "clone control",
    "bitbybit.babylon.gui.control.cloneControl_description": "Clone control",
    "container": "container",
    "BABYLON.GUI.Container": "babylon gui container",
    "host": "host",
    "BABYLON.GUI.AdvancedDynamicTexture": "babylon gui advanced dynamic texture",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "control observable selector",
    "createControlObservableSelector": "control observable selector",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Creates the selector of an observable for a control",
    "selector": "selector",
    "controlObservableSelectorEnum": "control observable selector enum",
    "bitbybit.babylon.gui.control.getControlByName": "get control by name",
    "getControlByName": "get control by name",
    "bitbybit.babylon.gui.control.getControlByName_description": "Get control by name",
    "bitbybit.babylon.gui.control.setIsVisible": "set is visible",
    "setIsVisible": "set is visible",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Set if control is visible",
    "isVisible": "is visible",
    "bitbybit.babylon.gui.control.setIsReadonly": "set is readonly",
    "setIsReadonly": "set is readonly",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Set if control is readonly",
    "isReadOnly": "is readonly",
    "bitbybit.babylon.gui.control.setIsEnabled": "set is enabled",
    "setIsEnabled": "set is enabled",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Set if control is enabled",
    "isEnabled": "is enabled",
    "bitbybit.babylon.gui.control.setHeight": "set height",
    "setHeight": "set height",
    "bitbybit.babylon.gui.control.setHeight_description": "Sets the control height",
    "bitbybit.babylon.gui.control.setWidth": "set width",
    "setWidth": "set width",
    "bitbybit.babylon.gui.control.setWidth_description": "Sets the control width",
    "bitbybit.babylon.gui.control.setColor": "set color",
    "setColor": "set color",
    "bitbybit.babylon.gui.control.setColor_description": "Sets the control color",
    "bitbybit.babylon.gui.control.setFontSize": "set font size",
    "setFontSize": "set font size",
    "bitbybit.babylon.gui.control.setFontSize_description": "Set font size",
    "fontSize": "font size",
    "bitbybit.babylon.gui.control.getHeight": "get height",
    "getHeight": "get height",
    "bitbybit.babylon.gui.control.getHeight_description": "Gets the height",
    "bitbybit.babylon.gui.control.getWidth": "get width",
    "getWidth": "get width",
    "bitbybit.babylon.gui.control.getWidth_description": "Gets the width",
    "bitbybit.babylon.gui.control.getColor": "get color",
    "getColor": "get color",
    "bitbybit.babylon.gui.control.getColor_description": "Gets the color",
    "bitbybit.babylon.gui.control.getFontSize": "get font size",
    "getFontSize": "get font size",
    "bitbybit.babylon.gui.control.getFontSize_description": "Get control font size",
    "bitbybit.babylon.gui.control.getIsVisible": "get is visible",
    "getIsVisible": "get is visible",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Get control is visible",
    "bitbybit.babylon.gui.control.getIsReadonly": "get is readonly",
    "getIsReadonly": "get is readonly",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Get control is readonly",
    "bitbybit.babylon.gui.control.getIsEnabled": "get is enabled",
    "getIsEnabled": "get is enabled",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Get control is enabled",
    "bitbybit.babylon.gui.container.addControls": "add controls",
    "addControls": "add controls",
    "bitbybit.babylon.gui.container.addControls_description": "Adds controls to container and keeps the order",
    "controls": "controls",
    "BABYLON.GUI.Control[]": "babylon gui control array",
    "clearControlsFirst": "clear controls first",
    "bitbybit.babylon.gui.container.setBackground": "set background",
    "setBackground": "set background",
    "bitbybit.babylon.gui.container.setBackground_description": "Sets the container background",
    "background": "background",
    "bitbybit.babylon.gui.container.setIsReadonly": "set is readonly",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Sets the container is readonly",
    "bitbybit.babylon.gui.container.getBackground": "get background",
    "getBackground": "get background",
    "bitbybit.babylon.gui.container.getBackground_description": "Gets the container background",
    "bitbybit.babylon.gui.container.getIsReadonly": "get is readonly",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Gets the container is readonly",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "stack panel",
    "stackPanel": "stack panel",
    "createStackPanel": "stack panel",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "creates stack panel",
    "isVertical": "is vertical",
    "spacing": "spacing",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "set is vertical",
    "setIsVertical": "set is vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Set stack panel is vertical",
    "BABYLON.GUI.StackPanel": "babylon gui stack panel",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "set spacing",
    "setSpacing": "set spacing",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Set stack panel spacing",
    "bitbybit.babylon.gui.stackPanel.setWidth": "set width",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Set stack panel width",
    "bitbybit.babylon.gui.stackPanel.setHeight": "set height",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Set stack panel height",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "get is vertical",
    "getIsVertical": "get is vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Get stack panel is vertical",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "get spacing",
    "getSpacing": "get spacing",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Get stack panel spacing",
    "bitbybit.babylon.gui.stackPanel.getWidth": "get width",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Get stack panel width",
    "bitbybit.babylon.gui.stackPanel.getHeight": "get height",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Get stack panel height",
    "bitbybit.babylon.gui.button.createSimpleButton": "simple button",
    "button": "button",
    "createSimpleButton": "simple button",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "creates simple button",
    "label": "label",
    "bitbybit.babylon.gui.button.setButtonText": "set button text",
    "setButtonText": "set button text",
    "bitbybit.babylon.gui.button.setButtonText_description": "Set button text",
    "BABYLON.GUI.Button": "babylon gui button",
    "text": "text",
    "bitbybit.babylon.gui.button.getButtonText": "get button text",
    "getButtonText": "get button text",
    "bitbybit.babylon.gui.button.getButtonText_description": "Get button text",
    "bitbybit.babylon.gui.slider.createSlider": "slider",
    "slider": "slider",
    "createSlider": "slider",
    "bitbybit.babylon.gui.slider.createSlider_description": "creates slider",
    "minimum": "minimum",
    "maximum": "maximum",
    "value": "value",
    "step": "step",
    "displayThumb": "display thumb",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "change slider thumb",
    "changeSliderThumb": "change slider thumb",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "changes slider thumb properties",
    "BABYLON.GUI.Slider": "babylon gui slider",
    "isThumbCircle": "is thumb circle",
    "thumbColor": "thumb color",
    "thumbWidth": "thumb width",
    "string | number": "string or number",
    "isThumbClamped": "is thumb clamped",
    "bitbybit.babylon.gui.slider.setBorderColor": "set border color",
    "setBorderColor": "set border color",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Changes slider border color",
    "borderColor": "border color",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "set background color",
    "setBackgroundColor": "set background color",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Changes slider background color",
    "backgroundColor": "background color",
    "bitbybit.babylon.gui.slider.setMaximum": "set maximum",
    "setMaximum": "set maximum",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Changes slider maximum value",
    "bitbybit.babylon.gui.slider.setMinimum": "set minimum",
    "setMinimum": "set minimum",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Changes slider minimum value",
    "bitbybit.babylon.gui.slider.setStep": "set step",
    "setStep": "set step",
    "bitbybit.babylon.gui.slider.setStep_description": "Changes slider step value",
    "bitbybit.babylon.gui.slider.setValue": "set value",
    "setValue": "set value",
    "bitbybit.babylon.gui.slider.setValue_description": "Changes slider value",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "slider observable selector",
    "createSliderObservableSelector": "slider observable selector",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Creates the selector of an observable for a slider",
    "sliderObservableSelectorEnum": "slider observable selector enum",
    "bitbybit.babylon.gui.slider.getBorderColor": "get border color",
    "getBorderColor": "get border color",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Gets the slider border color",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "get background color",
    "getBackgroundColor": "get background color",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Gets the slider background color",
    "bitbybit.babylon.gui.slider.getMaximum": "get maximum",
    "getMaximum": "get maximum",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Gets the slider maximum value",
    "bitbybit.babylon.gui.slider.getMinimum": "get minimum",
    "getMinimum": "get minimum",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Gets the slider minimum value",
    "bitbybit.babylon.gui.slider.getStep": "get step",
    "getStep": "get step",
    "bitbybit.babylon.gui.slider.getStep_description": "Gets the slider step value",
    "bitbybit.babylon.gui.slider.getValue": "get value",
    "getValue": "get value",
    "bitbybit.babylon.gui.slider.getValue_description": "Gets the slider value",
    "bitbybit.babylon.gui.slider.getThumbColor": "get thumb color",
    "getThumbColor": "get thumb color",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Gets the slider thumb color",
    "bitbybit.babylon.gui.slider.getThumbWidth": "get thumb width",
    "getThumbWidth": "get thumb width",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Gets the slider thumb width",
    "bitbybit.babylon.gui.slider.getIsVertical": "get is vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Gets the slider is vertical",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "get display thumb",
    "getDisplayThumb": "get display thumb",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Gets the slider display thumb",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "get is thumb circle",
    "getIsThumbCircle": "get is thumb circle",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Gets the slider is thumb circle",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "get is thumb clamped",
    "getIsThumbClamped": "get is thumb clamped",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Gets the slider is thumb clamped",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "text block",
    "textBlock": "text block",
    "createTextBlock": "text block",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "creates text block",
    "bitbybit.babylon.gui.textBlock.alignText": "align text",
    "alignText": "align text",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Change the alignment for the text",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "set text outline",
    "setTextOutline": "set text outline",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Change the text outline for the text",
    "BABYLON.GUI.TextBlock": "babylon gui text block",
    "outlineWidth": "outline width",
    "outlineColor": "outline color",
    "bitbybit.babylon.gui.textBlock.setText": "set text",
    "setText": "set text",
    "bitbybit.babylon.gui.textBlock.setText_description": "Sets the new text to the text block",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "set resize to fit",
    "setRsizeToFit": "set resize to fit",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Enable or disable resize to fit",
    "resizeToFit": "resize to fit",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "set text wrapping",
    "setTextWrapping": "set text wrapping",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Sets the new text wrapping to the text block",
    "textWrapping": "text wrapping",
    "boolean | BABYLON.GUI.TextWrapping": "boolean or babylon gui text wrapping",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "set line spacing",
    "setLineSpacing": "set line spacing",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Sets the line spacing of the text",
    "lineSpacing": "line spacing",
    "bitbybit.babylon.gui.textBlock.getText": "get text",
    "getText": "get text",
    "bitbybit.babylon.gui.textBlock.getText_description": "Gets the text of the text block",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "get text wrapping",
    "getTextWrapping": "get text wrapping",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Gets the text wrapping of the text block",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "get line spacing",
    "getLineSpacing": "get line spacing",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Gets the line spacing of the text block",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "get outline width",
    "getOutlineWidth": "get outline width",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Gets the outline width of the text block",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "get resize to fit",
    "getResizeToFit": "get resize to fit",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Gets the resize to fit of the text block",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "get text horizontal alignment",
    "getTextHorizontalAlignment": "get text horizontal alignment",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Gets the text horizontal alignment of the text block",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "get text vertical alignment",
    "getTextVerticalAlignment": "get text vertical alignment",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Gets the text vertical alignment of the text block",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "text block observable selector",
    "createTextBlockObservableSelector": "text block observable selector",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Creates the selector of an observable for a text block",
    "textBlockObservableSelectorEnum": "text block observable selector enum",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "radio button",
    "radioButton": "radio button",
    "createRadioButton": "radio button",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "creates radio button",
    "group": "group",
    "isChecked": "is checked",
    "checkSizeRatio": "check size ratio",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "set check size ratio",
    "setCheckSizeRatio": "set check size ratio",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Sets the radio button check size ratio",
    "BABYLON.GUI.RadioButton": "babylon gui radio button",
    "bitbybit.babylon.gui.radioButton.setGroup": "set group",
    "setGroup": "set group",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Sets the radio button group",
    "bitbybit.babylon.gui.radioButton.setBackground": "set background",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Sets the radio button background",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "get check size ratio",
    "getCheckSizeRatio": "get check size ratio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Gets the radio button check size ratio",
    "bitbybit.babylon.gui.radioButton.getGroup": "get group",
    "getGroup": "get group",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Gets the radio button group",
    "bitbybit.babylon.gui.radioButton.getBackground": "get background",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Gets the radio button background",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "radio button observable selector",
    "createRadioButtonObservableSelector": "radio button observable selector",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Creates the selector of an observable for the radio button",
    "radioButtonObservableSelectorEnum": "radio button observable selector enum",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "checkbox",
    "checkbox": "checkbox",
    "createCheckbox": "checkbox",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "creates checkbox",
    "bitbybit.babylon.gui.checkbox.setBackground": "set background",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Sets the checkbox background",
    "BABYLON.GUI.Checkbox": "babylon gui checkbox",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "set check size ratio",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Sets the checkbox check size ratio",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "set is checked",
    "setIsChecked": "set is checked",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Sets the checkbox is checked",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "get check size ratio",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Gets the check size ratio",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "get is checked",
    "getIsChecked": "get is checked",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Gets the is checked",
    "bitbybit.babylon.gui.checkbox.getBackground": "get background",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Gets the background",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "checkbox observable selector",
    "createCheckboxObservableSelector": "checkbox observable selector",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Creates the selector of an observable for the checkbox",
    "checkboxObservableSelectorEnum": "checkbox observable selector enum",
    "bitbybit.babylon.gui.inputText.createInputText": "input text",
    "inputText": "input text",
    "createInputText": "input text",
    "bitbybit.babylon.gui.inputText.createInputText_description": "creates input text",
    "placeholder": "placeholder",
    "bitbybit.babylon.gui.inputText.setBackground": "set background",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Sets the input text background",
    "BABYLON.GUI.InputText": "babylon gui input text",
    "bitbybit.babylon.gui.inputText.setText": "set text",
    "bitbybit.babylon.gui.inputText.setText_description": "Sets the input text text",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "set placeholder",
    "setPlaceholder": "set placeholder",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Sets the input text placeholder",
    "bitbybit.babylon.gui.inputText.getBackground": "get background",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Gets the input text background",
    "bitbybit.babylon.gui.inputText.getText": "get text",
    "bitbybit.babylon.gui.inputText.getText_description": "Gets the input text text",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "get placeholder",
    "getPlaceholder": "get placeholder",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Gets the input text placeholder",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "input text observable selector",
    "createInputTextObservableSelector": "input text observable selector",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Creates the selector of an observable for the input text",
    "inputTextObservableSelectorEnum": "input text observable selector enum",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "color picker",
    "colorPicker": "color picker",
    "createColorPicker": "color picker",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "creates color picker",
    "defaultColor": "default color",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "set color picker value",
    "setColorPickerValue": "set color picker value",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Sets color picker value color",
    "BABYLON.GUI.ColorPicker": "babylon gui color picker",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "set color picker size",
    "setColorPickerSize": "set color picker size",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Sets color picker size (width and height)",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "get color picker value",
    "getColorPickerValue": "get color picker value",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Gets color picker value color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "get color picker size",
    "getColorPickerSize": "get color picker size",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "gets color picker size",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "color picker observable selector",
    "createColorPickerObservableSelector": "color picker observable selector",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Creates the selector of an observable for color picker",
    "colorPickerObservableSelectorEnum": "color picker observable selector enum",
    "bitbybit.babylon.gui.image.createImage": "image",
    "image": "image",
    "createImage": "image",
    "bitbybit.babylon.gui.image.createImage_description": "creates image",
    "bitbybit.babylon.gui.image.setSourceUrl": "set source url",
    "setSourceUrl": "set source url",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "sets image source url",
    "BABYLON.GUI.Image": "babylon gui image",
    "bitbybit.babylon.gui.image.getSourceUrl": "get source url",
    "getSourceUrl": "get source url",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "gets image source url",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gizmo manager",
    "gizmo": "gizmo",
    "manager": "manager",
    "createGizmoManager": "gizmo manager",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Create gizmo manager",
    "positionGizmoEnabled": "position gizmo enabled",
    "rotationGizmoEnabled": "rotation gizmo enabled",
    "scaleGizmoEnabled": "scale gizmo enabled",
    "boundingBoxGizmoEnabled": "bounding box gizmo enabled",
    "usePointerToAttachGizmos": "use pointer to attach gizmos",
    "clearGizmoOnEmptyPointerEvent": "clear gizmo on empty pointer event",
    "scaleRatio": "scale ratio",
    "attachableMeshes": "attachable meshes",
    "BABYLON.AbstractMesh[]": "babylon abstract mesh array",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "get position gizmo",
    "getPositionGizmo": "get position gizmo",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Get position gizmo",
    "gizmoManager": "gizmo manager",
    "BABYLON.GizmoManager": "babylon gizmo manager",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "get rotation gizmo",
    "getRotationGizmo": "get rotation gizmo",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Get rotation gizmo",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "get scale gizmo",
    "getScaleGizmo": "get scale gizmo",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Get scale gizmo",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "get bounding box gizmo",
    "getBoundingBoxGizmo": "get bounding box gizmo",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Get bounding box gizmo",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "attach to mesh",
    "attachToMesh": "attach to mesh",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Attach gizmo manager to mesh",
    "update": "update",
    "bitbybit.babylon.gizmo.manager.detachMesh": "detach mesh",
    "detachMesh": "detach mesh",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Detach gizmo manager from mesh",
    "bitbybit.babylon.gizmo.base.scaleRatio": "set scale ratio",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Set gizmo scale ratio",
    "BABYLON.IGizmo": "babylon i gizmo",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "get scale ratio",
    "getScaleRatio": "get scale ratio",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Gets scale ratio",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "set planar gizmo enabled",
    "positionGizmo": "position gizmo",
    "planarGizmoEnabled": "planar gizmo enabled",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Set planar gizmo enabled",
    "BABYLON.IPositionGizmo": "babylon i position gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "set snap distance",
    "snapDistance": "snap distance",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Set position gizmo snap distance",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "get attached mesh",
    "getAttachedMesh": "get attached mesh",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Get attached mesh",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "get attached node",
    "getAttachedNode": "get attached node",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Get attached node",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "get x gizmo",
    "getXGizmo": "get x gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Get x gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "get y gizmo",
    "getYGizmo": "get y gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Get y gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "get z gizmo",
    "getZGizmo": "get z gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Get z gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "get x plane gizmo",
    "getXPlaneGizmo": "get x plane gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Get x plane gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "get y plane gizmo",
    "getYPlaneGizmo": "get y plane gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Get y plane gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "get z plane gizmo",
    "getZPlaneGizmo": "get z plane gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Get z plane gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "get planar gizmo enabled",
    "getPlanarGizmoEnabled": "get planar gizmo enabled",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Get if planar gizmo enabled",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "get snap distance",
    "getSnapDistance": "get snap distance",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Get snap distance",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "get is dragging",
    "getIsDragging": "get is dragging",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Get if is dragging",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "position gizmo observable selector",
    "createPositionGizmoObservableSelector": "position gizmo observable selector",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Creates the selector of an observable for a position gizmo",
    "positionGizmoObservableSelectorEnum": "position gizmo observable selector enum",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "set snap distance",
    "rotationGizmo": "rotation gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Set rotation gizmo snap distance",
    "BABYLON.IRotationGizmo": "babylon i rotation gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "set sensitivity",
    "sensitivity": "sensitivity",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Set rotation gizmo sensitivity",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "get attached mesh",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Get attached mesh",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "get attached node",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Get attached node",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "get x gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Get x gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "get y gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Get y gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "get z gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Get z gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "get snap distance",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Get snap distance",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "get sensitivity",
    "getSensitivity": "get sensitivity",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Get sensitivity",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "rotation gizmo observable selector",
    "createRotationGizmoObservableSelector": "rotation gizmo observable selector",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Creates the selector of an observable for a rotation gizmo",
    "rotationGizmoObservableSelectorEnum": "rotation gizmo observable selector enum",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "get x gizmo",
    "scaleGizmo": "scale gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Get x gizmo",
    "BABYLON.IScaleGizmo": "babylon i scale gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "get y gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Get y gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "get z gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Get z gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "set snap distance",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Set scale gizmo snap distance",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "set incremental snap",
    "setIncrementalSnap": "set incremental snap",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Set scale gizmo incremental snap",
    "incrementalSnap": "incremental snap",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "set sensitivity",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Set scale gizmo sensitivity",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "get incremental snap",
    "getIncrementalSnap": "get incremental snap",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Get incremental snap",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "get snap distance",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Get snap distance",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "get sensitivity",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Get sensitivity",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "scale gizmo observable selector",
    "createScaleGizmoObservableSelector": "scale gizmo observable selector",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Creates the selector of an observable for a scale gizmo",
    "scaleGizmoObservableSelectorEnum": "scale gizmo observable selector enum",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "set rotation sphere size",
    "boundingBoxGizmo": "bounding box gizmo",
    "setRotationSphereSize": "set rotation sphere size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Set bounding box gizmo rotation sphere size",
    "BABYLON.BoundingBoxGizmo": "babylon bounding box gizmo",
    "rotationSphereSize": "rotation sphere size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "set fixed drag mesh screen size",
    "setFixedDragMeshScreenSize": "set fixed drag mesh screen size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "If set, the rotation anchors and scale boxes will increase in size based on the distance away from the camera to have a consistent screen size (Default: false) Note : fixedDragMeshScreenSize takes precedence over fixedDragMeshBoundsSize if both are true",
    "fixedDragMeshScreenSize": "fixed drag mesh screen size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "set fixed drag mesh bounds size",
    "setFixedDragMeshBoundsSize": "set fixed drag mesh bounds size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Set bounding box gizmo fixed drag mesh bounds size",
    "fixedDragMeshBoundsSize": "fixed drag mesh bounds size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "set fixed drag mesh screen size distance factor",
    "setFixedDragMeshScreenSizeDistanceFactor": "set fixed drag mesh screen size distance factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "The distance away from the object which the draggable meshes should appear world sized when fixedDragMeshScreenSize is set to true (default: 10)",
    "fixedDragMeshScreenSizeDistanceFactor": "fixed drag mesh screen size distance factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "set scaling snap distance",
    "setScalingSnapDistance": "set scaling snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Set bounding box gizmo scaling snap distance. Drag distance in babylon units that the gizmo will snap scaling to when dragged.",
    "scalingSnapDistance": "scaling snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "set rotation snap distance",
    "setRotationSnapDistance": "set rotation snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Set bounding box gizmo rotation snap distance. Drag distance in babylon units that the gizmo will snap rotation to when dragged.",
    "rotationSnapDistance": "rotation snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "set scale box size",
    "setScaleBoxSize": "set scale box size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Set bounding box gizmo scale box size",
    "scaleBoxSize": "scale box size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "set incremental snap",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Set bounding box gizmo incremental snap. Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "set scale pivot",
    "setScalePivot": "set scale pivot",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Set bounding box gizmo scale pivot. Relative bounding box pivot used when scaling the attached node. When null object with scale from the opposite corner. 0.5,0.5,0.5 for center and 0.5,0,0.5 for bottom (Default: null)",
    "scalePivot": "scale pivot",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "set axis factor",
    "setAxisFactor": "set axis factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Set bounding box gizmo axis factor. Set custom sensitivity value for each axis",
    "axisFactor": "axis factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "set scale drag speed",
    "setScaleDragSpeed": "set scale drag speed",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Set bounding box gizmo scale drag speed",
    "scaleDragSpeed": "scale drag speed",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "get rotation sphere size",
    "getRotationSphereSize": "get rotation sphere size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Get rotation sphere size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "get scale box size",
    "getScaleBoxSize": "get scale box size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Get scale box size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "get fixed drag mesh screen size",
    "getFixedDragMeshScreenSize": "get fixed drag mesh screen size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Get fixed drag mesh screen size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "get fixed drag mesh bounds size",
    "getFixedDragMeshBoundsSize": "get fixed drag mesh bounds size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Get fixed drag mesh bounds size",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "get fixed drag mesh screen size distance factor",
    "getFixedDragMeshScreenSizeDistanceFactor": "get fixed drag mesh screen size distance factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Get fixed drag mesh screen size distance factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "get scaling snap distance",
    "getScalingSnapDistance": "get scaling snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Get scaling snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "get rotation snap distance",
    "getRotationSnapDistance": "get rotation snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Get rotation snap distance",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "get incremental snap",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Get incremental snap",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "get scale pivot",
    "getScalePivot": "get scale pivot",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Get scale pivot",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "get axis factor",
    "getAxisFactor": "get axis factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Get axis factor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "get scale drag speed",
    "getScaleDragSpeed": "get scale drag speed",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Get scale drag speed",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "bounding box gizmo observable selector",
    "createBoundingBoxGizmoObservableSelector": "bounding box gizmo observable selector",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Creates the selector of an observable for a bounding box gizmo",
    "boundingBoxGizmoObservableSelectorEnum": "bounding box gizmo observable selector enum",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "set is enabled",
    "axisDragGizmo": "axis drag gizmo",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Sets if axis is enabled or not",
    "BABYLON.IAxisDragGizmo": "babylon i axis drag gizmo",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "get is enabled",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Checks if axis is enabled",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "set is enabled",
    "axisScaleGizmo": "axis scale gizmo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Sets if axis is enabled or not",
    "BABYLON.IAxisScaleGizmo": "babylon i axis scale gizmo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "get is enabled",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Checks if axis is enabled",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "set is enabled",
    "planeDragGizmo": "plane drag gizmo",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Sets if plane is enabled or not",
    "BABYLON.IPlaneDragGizmo": "babylon i plane drag gizmo",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "get is enabled",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Checks if plane is enabled",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "set is enabled",
    "planeRotationGizmo": "plane rotation gizmo",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Sets if plane is enabled or not",
    "BABYLON.IPlaneRotationGizmo": "babylon i plane rotation gizmo",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "get is enabled",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Checks if plane is enabled",
    "bitbybit.vector.removeAllDuplicateVectors": "remove all duplicate vectors",
    "vector": "vector",
    "removeAllDuplicateVectors": "remove all duplicate vectors",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Removes all duplicate vectors from the input array (keeps only unique vectors). Example: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]]  [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "remove",
    "vectors": "vectors",
    "number[][]": "number array array",
    "tolerance": "tolerance",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "remove consecutive duplicate vectors",
    "removeConsecutiveDuplicateVectors": "remove consecutive duplicate vectors",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Removes consecutive duplicate vectors from the input array (only removes duplicates that appear next to each other). Example: [[1,2], [1,2], [3,4], [1,2]]  [[1,2], [3,4], [1,2]] (only removed consecutive duplicate)",
    "checkFirstAndLast": "check first and last",
    "bitbybit.vector.angleBetween": "angle between",
    "angleBetween": "angle between",
    "bitbybit.vector.angleBetween_description": "Measures the angle between two vectors in degrees (always returns positive angle 0-180). Example: [1,0,0] and [0,1,0]  90 (perpendicular vectors)",
    "angles": "angles",
    "first": "first",
    "second": "second",
    "bitbybit.vector.angleBetweenNormalized2d": "angle between normalized 2d",
    "angleBetweenNormalized2d": "angle between normalized 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Measures the normalized 2D angle between two vectors in degrees (considers direction, can be negative). Example: [1,0] to [0,1]  90, [0,1] to [1,0]  -90",
    "bitbybit.vector.positiveAngleBetween": "positive angle between",
    "positiveAngleBetween": "positive angle between",
    "bitbybit.vector.positiveAngleBetween_description": "Measures a positive angle between two vectors given the reference vector in degrees (always 0-360). Example: converts negative signed angles to positive by adding 360 when needed",
    "reference": "reference",
    "bitbybit.vector.addAll": "add all",
    "addAll": "add all",
    "bitbybit.vector.addAll_description": "Adds all vector xyz values together element-wise and creates a new vector. Example: [[1,2,3], [4,5,6], [7,8,9]]  [12,15,18] (sums each column)",
    "sum": "sum",
    "bitbybit.vector.add": "add",
    "add": "add",
    "bitbybit.vector.add_description": "Adds two vectors together element-wise. Example: [1,2,3] + [4,5,6]  [5,7,9]",
    "bitbybit.vector.all": "all",
    "all": "all",
    "bitbybit.vector.all_description": "Checks if the boolean array contains only true values, returns false if there's a single false. Example: [true, true, true]  true, [true, false, true]  false",
    "boolean[]": "boolean array",
    "bitbybit.vector.cross": "cross",
    "cross": "cross",
    "bitbybit.vector.cross_description": "Computes the cross product of two 3D vectors (perpendicular vector to both inputs). Example: [1,0,0]  [0,1,0]  [0,0,1] (right-hand rule)",
    "bitbybit.vector.distSquared": "dist squared",
    "distSquared": "dist squared",
    "bitbybit.vector.distSquared_description": "Calculates squared distance between two vectors (faster than distance, avoids sqrt). Example: [0,0,0] to [3,4,0]  25 (distance 5 squared)",
    "bitbybit.vector.dist": "dist",
    "dist": "dist",
    "bitbybit.vector.dist_description": "Calculates the Euclidean distance between two vectors. Example: [0,0,0] to [3,4,0]  5, [1,1] to [4,5]  5",
    "bitbybit.vector.div": "div",
    "div": "div",
    "bitbybit.vector.div_description": "Divides each element of the vector by a scalar value. Example: [10,20,30]  2  [5,10,15]",
    "scalar": "scalar",
    "bitbybit.vector.domain": "domain",
    "domain": "domain",
    "bitbybit.vector.domain_description": "Computes the domain (range) between minimum and maximum values of the vector. Example: [1,3,5,9]  8 (difference between last and first: 9-1)",
    "bitbybit.vector.dot": "dot",
    "dot": "dot",
    "bitbybit.vector.dot_description": "Calculates the dot product between two vectors (measures similarityprojection). Example: [1,2,3]  [4,5,6]  32 (14 + 25 + 36), perpendicular vectors  0",
    "bitbybit.vector.finite": "finite",
    "finite": "finite",
    "bitbybit.vector.finite_description": "Checks if each element in the vector is finite and returns a boolean array. Example: [1, 2, Infinity, 3]  [true, true, false, true]",
    "validate": "validate",
    "bitbybit.vector.isZero": "is zero",
    "isZero": "is zero",
    "bitbybit.vector.isZero_description": "Checks if the vector has zero length (all elements are zero). Example: [0,0,0]  true, [0,0,0.001]  false",
    "bitbybit.vector.lerp": "lerp",
    "lerp": "lerp",
    "bitbybit.vector.lerp_description": "Finds an interpolated vector between two vectors using a fraction (linear interpolation). Example: [0,0,0] to [10,10,10] at 0.5  [5,5,5], fraction=0  first, fraction=1  second",
    "fraction": "fraction",
    "bitbybit.vector.max": "max",
    "max": "max",
    "bitbybit.vector.max_description": "Finds the maximum (largest) value in the vector. Example: [3, 7, 2, 9, 1]  9",
    "extract": "extract",
    "bitbybit.vector.min": "min",
    "min": "min",
    "bitbybit.vector.min_description": "Finds the minimum (smallest) value in the vector. Example: [3, 7, 2, 9, 1]  1",
    "bitbybit.vector.mul": "mul",
    "mul": "mul",
    "bitbybit.vector.mul_description": "Multiplies each element of the vector by a scalar value. Example: [2,3,4]  5  [10,15,20]",
    "bitbybit.vector.neg": "neg",
    "neg": "neg",
    "bitbybit.vector.neg_description": "Negates the vector (flips the sign of each element). Example: [5,-3,2]  [-5,3,-2]",
    "bitbybit.vector.normSquared": "norm squared",
    "normSquared": "norm squared",
    "bitbybit.vector.normSquared_description": "Computes the squared norm (squared magnitudelength) of the vector. Example: [3,4,0]  25 (length 5 squared)",
    "bitbybit.vector.norm": "norm",
    "norm": "norm",
    "bitbybit.vector.norm_description": "Calculates the norm (magnitudelength) of the vector. Example: [3,4,0]  5, [1,0,0]  1",
    "bitbybit.vector.normalized": "normalized",
    "normalized": "normalized",
    "bitbybit.vector.normalized_description": "Normalizes the vector into a unit vector that has a length of 1 (maintains direction, scales magnitude to 1). Example: [3,4,0]  [0.6,0.8,0], [10,0,0]  [1,0,0]",
    "bitbybit.vector.onRay": "on ray",
    "onRay": "on ray",
    "bitbybit.vector.onRay_description": "Finds a point on a ray at a given distance from the origin along the direction vector. Example: Point [0,0,0] + direction [1,0,0] at distance 5  [5,0,0]",
    "bitbybit.vector.vectorXYZ": "vector xyz",
    "vectorXYZ": "vector xyz",
    "bitbybit.vector.vectorXYZ_description": "Creates a 3D vector from x, y, z coordinates. Example: x=1, y=2, z=3  [1,2,3]",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vector xy",
    "vectorXY": "vector xy",
    "bitbybit.vector.vectorXY_description": "Creates a 2D vector from x, y coordinates. Example: x=3, y=4  [3,4]",
    "bitbybit.vector.range": "range",
    "range": "range",
    "bitbybit.vector.range_description": "Creates a vector of integers from 0 to max (exclusive). Example: max=5  [0,1,2,3,4], max=3  [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "signed angle between",
    "signedAngleBetween": "signed angle between",
    "bitbybit.vector.signedAngleBetween_description": "Computes signed angle between two vectors using a reference vector (determines rotation direction). Example: Returns positive or negative angle depending on rotation direction relative to reference",
    "bitbybit.vector.span": "span",
    "span": "span",
    "bitbybit.vector.span_description": "Creates a vector containing numbers from min to max at a given step increment. Example: min=0, max=10, step=2  [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "span ease items",
    "spanEaseItems": "span ease items",
    "bitbybit.vector.spanEaseItems_description": "Creates a vector with numbers from min to max using an easing function for non-linear distribution. Example: min=0, max=100, nrItems=5, ease='easeInQuad'  creates accelerating intervals",
    "nrItems": "nr items",
    "ease": "ease",
    "Math.easeEnum": "math ease enum",
    "intervals": "intervals",
    "bitbybit.vector.spanLinearItems": "span linear items",
    "spanLinearItems": "span linear items",
    "bitbybit.vector.spanLinearItems_description": "Creates a vector with evenly spaced numbers from min to max with a specified number of items. Example: min=0, max=10, nrItems=5  [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "sub",
    "sub": "sub",
    "bitbybit.vector.sub_description": "Subtracts the second vector from the first element-wise. Example: [10,20,30] - [1,2,3]  [9,18,27]",
    "bitbybit.vector.sum": "sum",
    "bitbybit.vector.sum_description": "Sums all values in the vector and returns a single number. Example: [1,2,3,4]  10, [5,10,15]  30",
    "bitbybit.point.transformPoint": "transform point",
    "transformPoint": "transform point",
    "bitbybit.point.transformPoint_description": "Applies transformation matrix to a single point (rotates, scales, or translates). Example: point=[0,0,0] with translation [5,5,0]  [5,5,0]",
    "transformation": "transformation",
    "Base.TransformMatrixes": "base transform matrixes",
    "bitbybit.point.transformPoints": "transform points",
    "transformPoints": "transform points",
    "bitbybit.point.transformPoints_description": "Applies same transformation matrix to multiple points (batch transform). Example: 5 points with rotation 90  all 5 points rotated together",
    "points": "points",
    "bitbybit.point.transformsForPoints": "transforms for points",
    "transformsForPoints": "transforms for points",
    "bitbybit.point.transformsForPoints_description": "Applies different transformation matrices to corresponding points (one transform per point). Arrays must have equal length. Example: 3 points with 3 different translations  each point moved independently",
    "Base.TransformMatrixes[]": "base transform matrixes array",
    "bitbybit.point.translatePoints": "translate points",
    "translatePoints": "translate points",
    "bitbybit.point.translatePoints_description": "Moves multiple points by a translation vector (same offset for all points). Example: points=[[0,0,0], [1,0,0]], translation=[5,5,0]  [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "translate points with vectors",
    "translatePointsWithVectors": "translate points with vectors",
    "bitbybit.point.translatePointsWithVectors_description": "Moves multiple points by corresponding translation vectors (one vector per point). Arrays must have equal length. Example: 3 points with 3 different vectors  each point moved by its corresponding vector",
    "bitbybit.point.translateXYZPoints": "translate xyz points",
    "translateXYZPoints": "translate xyz points",
    "bitbybit.point.translateXYZPoints_description": "Moves multiple points by separate X, Y, Z values (convenience method for translation). Example: points=[[0,0,0]], x=10, y=5, z=0  [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "scale points center xyz",
    "scalePointsCenterXYZ": "scale points center xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "Scales multiple points around a center point with different factors per axis. Example: points=[[10,0,0]], center=[5,0,0], scaleXyz=[2,1,1]  [[15,0,0]] (doubles X distance from center)",
    "bitbybit.point.rotatePointsCenterAxis": "rotate points center axis",
    "rotatePointsCenterAxis": "rotate points center axis",
    "bitbybit.point.rotatePointsCenterAxis_description": "Rotates multiple points around a center point along a custom axis. Example: points=[[10,0,0]], center=[0,0,0], axis=[0,1,0], angle=90  [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "closest point from points distance",
    "closestPointFromPointsDistance": "closest point from points distance",
    "bitbybit.point.closestPointFromPointsDistance_description": "Calculates distance to the nearest point in a collection. Example: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]]  3 (distance to [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "closest point from points index",
    "closestPointFromPointsIndex": "closest point from points index",
    "bitbybit.point.closestPointFromPointsIndex_description": "Finds array index of the nearest point in a collection (1-based index, not 0-based). Example: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]]  3 (index of [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "closest point from points",
    "closestPointFromPoints": "closest point from points",
    "bitbybit.point.closestPointFromPoints_description": "Finds the nearest point in a collection to a reference point. Example: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]]  [3,0,0]",
    "bitbybit.point.distance": "distance",
    "bitbybit.point.distance_description": "Calculates Euclidean distance between two points. Example: start=[0,0,0], end=[3,4,0]  5 (using Pythagorean theorem: (3+4))",
    "measure": "measure",
    "startPoint": "start point",
    "endPoint": "end point",
    "bitbybit.point.distancesToPoints": "distances to points",
    "distancesToPoints": "distances to points",
    "bitbybit.point.distancesToPoints_description": "Calculates distances from a start point to multiple end points. Example: start=[0,0,0], endPoints=[[3,0,0], [0,4,0], [5,0,0]]  [3, 4, 5]",
    "endPoints": "end points",
    "bitbybit.point.multiplyPoint": "multiply point",
    "multiplyPoint": "multiply point",
    "bitbybit.point.multiplyPoint_description": "Duplicates a point N times (creates array with N copies of the same point). Example: point=[5,5,0], amountOfPoints=3  [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "amount of points",
    "bitbybit.point.getX": "get x",
    "getX": "get x",
    "bitbybit.point.getX_description": "Extracts X coordinate from a point. Example: point=[5,10,3]  5",
    "bitbybit.point.getY": "get y",
    "getY": "get y",
    "bitbybit.point.getY_description": "Extracts Y coordinate from a point. Example: point=[5,10,3]  10",
    "bitbybit.point.getZ": "get z",
    "getZ": "get z",
    "bitbybit.point.getZ_description": "Extracts Z coordinate from a point. Example: point=[5,10,3]  3",
    "bitbybit.point.averagePoint": "average point",
    "averagePoint": "average point",
    "bitbybit.point.averagePoint_description": "Calculates centroid (average position) of multiple points. Example: points=[[0,0,0], [10,0,0], [10,10,0]]  [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "point xyz",
    "pointXYZ": "point xyz",
    "bitbybit.point.pointXYZ_description": "Creates a 3D point from X, Y, Z coordinates. Example: x=10, y=5, z=3  [10,5,3]",
    "bitbybit.point.pointXY": "point xy",
    "pointXY": "point xy",
    "bitbybit.point.pointXY_description": "Creates a 2D point from X, Y coordinates. Example: x=10, y=5  [10,5]",
    "bitbybit.point.spiral": "spiral",
    "spiral": "spiral",
    "bitbybit.point.spiral_description": "Creates logarithmic spiral points using golden angle or custom widening factor. Generates natural spiral patterns common in nature (sunflower, nautilus shell). Example: numberPoints=100, radius=10, phi=1.618  100 points forming outward spiral",
    "phi": "phi",
    "numberPoints": "number points",
    "widening": "widening",
    "factor": "factor",
    "bitbybit.point.hexGrid": "hex grid",
    "hexGrid": "hex grid",
    "bitbybit.point.hexGrid_description": "Creates hexagonal grid center points on XY plane (honeycomb pattern). Grid size controlled by number of hexagons, not widthheight. Example: radiusHexagon=1, nrHexagonsX=3, nrHexagonsY=3  9 hex centers in grid pattern",
    "nrHexagonsY": "nr hexagons y",
    "nrHexagonsX": "nr hexagons x",
    "radiusHexagon": "radius hexagon",
    "orientOnCenter": "orient on center",
    "pointsOnGround": "points on ground",
    "bitbybit.point.removeConsecutiveDuplicates": "remove consecutive duplicates",
    "removeConsecutiveDuplicates": "remove consecutive duplicates",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Removes consecutive duplicate points from array within tolerance. Example: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]]  [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "clean",
    "bitbybit.line.convertToNurbsCurve": "convert to nurbs curve",
    "line": "line",
    "convertToNurbsCurve": "convert to nurbs curve",
    "bitbybit.line.convertToNurbsCurve_description": "converts line to nurbs curve",
    "LinePointsDto": "line points dto",
    "bitbybit.line.convertLinesToNurbsCurves": "convert lines to nurbs curves",
    "convertLinesToNurbsCurves": "convert lines to nurbs curves",
    "bitbybit.line.convertLinesToNurbsCurves_description": "converts lines to nurbs curves array",
    "lines": "lines",
    "LinePointsDto[]": "line points dto array",
    "bitbybit.line.getStartPoint": "get start point",
    "getStartPoint": "get start point",
    "bitbybit.line.getStartPoint_description": "Extracts start point from a line. Example: line={start:[0,0,0], end:[10,5,0]}  [0,0,0]",
    "bitbybit.line.getEndPoint": "get end point",
    "getEndPoint": "get end point",
    "bitbybit.line.getEndPoint_description": "Extracts end point from a line. Example: line={start:[0,0,0], end:[10,5,0]}  [10,5,0]",
    "bitbybit.line.length": "length",
    "bitbybit.line.length_description": "Calculates length (distance) of a line segment. Example: line={start:[0,0,0], end:[3,4,0]}  5 (using Pythagorean theorem)",
    "bitbybit.line.reverse": "reverse line",
    "reverse": "reverse",
    "bitbybit.line.reverse_description": "Reverses line direction by swapping start and end points. Example: line={start:[0,0,0], end:[10,5,0]}  {start:[10,5,0], end:[0,0,0]}",
    "bitbybit.line.transformLine": "transform line",
    "transformLine": "transform line",
    "bitbybit.line.transformLine_description": "Applies transformation matrix to line (rotates, scales, or translates both endpoints). Example: line={start:[0,0,0], end:[10,0,0]} with translation [5,5,0]  {start:[5,5,0], end:[15,5,0]}",
    "bitbybit.line.transformsForLines": "transforms for lines",
    "transformsForLines": "transforms for lines",
    "bitbybit.line.transformsForLines_description": "Applies multiple transformations to multiple lines (one transform per line). Example: 3 lines with 3 different translation matrices  each line moved independently",
    "bitbybit.line.create": "line",
    "bitbybit.line.create_description": "Creates a line from two points (line object with start and end properties). Example: start=[0,0,0], end=[10,5,0]  {start:[0,0,0], end:[10,5,0]}",
    "bitbybit.line.createAsync": "async",
    "createAsync": "async",
    "bitbybit.line.createAsync_description": "creates line from async points",
    "bitbybit.line.getPointOnLine": "get point on line",
    "getPointOnLine": "get point on line",
    "bitbybit.line.getPointOnLine_description": "Calculates point at parameter t along line segment (0=start, 1=end, linear interpolation). Example: line={start:[0,0,0], end:[10,0,0]}, param=0.5  [5,0,0] (midpoint)",
    "param": "param",
    "bitbybit.line.linesBetweenPoints": "lines between points",
    "linesBetweenPoints": "lines between points",
    "bitbybit.line.linesBetweenPoints_description": "Creates line segments connecting consecutive points in a list (forms a polyline path). Example: points=[[0,0,0], [5,0,0], [5,5,0]]  2 lines: [05] and [55,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "lines between start and end points",
    "linesBetweenStartAndEndPoints": "lines between start and end points",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Creates lines by pairing corresponding start and end points from two arrays. Filters out zero-length lines. Example: starts=[[0,0,0], [5,0,0]], ends=[[0,5,0], [5,5,0]]  2 lines connecting paired points",
    "startPoints": "start points",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "lines between start and end points async",
    "linesBetweenStartAndEndPointsAsync": "lines between start and end points async",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "creates lines between start and end points with async inputs",
    "bitbybit.polyline.convertToNurbsCurve": "convert to nurbs curve",
    "polyline": "polyline",
    "bitbybit.polyline.convertToNurbsCurve_description": "converts polyline to nurbs curve",
    "PolylinePropertiesDto": "polyline properties dto",
    "bitbybit.polyline.length": "length",
    "bitbybit.polyline.length_description": "Calculates total length of polyline by summing distances between consecutive points. Example: points=[[0,0,0], [3,0,0], [3,4,0]]  3 + 4 = 7",
    "bitbybit.polyline.countPoints": "count points",
    "countPoints": "count points",
    "bitbybit.polyline.countPoints_description": "Counts number of points in polyline. Example: polyline with points=[[0,0,0], [1,0,0], [1,1,0]]  3",
    "bitbybit.polyline.getPoints": "get points",
    "getPoints": "get points",
    "bitbybit.polyline.getPoints_description": "Extracts points array from polyline object. Example: polyline={points:[[0,0,0], [1,0,0]]}  [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "reverse polyline",
    "bitbybit.polyline.reverse_description": "Reverses point order of polyline (flips direction). Example: points=[[0,0,0], [1,0,0], [2,0,0]]  [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "transform polyline",
    "transformPolyline": "transform polyline",
    "bitbybit.polyline.transformPolyline_description": "Applies transformation matrix to all points in polyline (rotates, scales, or translates). Example: polyline with 4 points, translation [5,0,0]  all points moved +5 in X direction",
    "bitbybit.polyline.create": "polyline",
    "bitbybit.polyline.create_description": "Creates a polyline from points array with optional isClosed flag. Example: points=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true  {points:..., isClosed:true}",
    "isClosed": "is closed",
    "string | number[]": "string or number array",
    "bitbybit.occt.deleteShape": "delete shape",
    "occt": "occt",
    "deleteShape": "delete shape",
    "bitbybit.occt.deleteShape_description": "Deletes shape from the cache to keep memory usage low",
    "bitbybit.occt.deleteShapes": "delete shapes",
    "deleteShapes": "delete shapes",
    "bitbybit.occt.deleteShapes_description": "Deletes shapes from the cache to keep memory usage low",
    "shapes": "shapes",
    "T[]": "t array",
    "bitbybit.occt.cleanAllCache": "clean all cache",
    "cleanAllCache": "clean all cache",
    "bitbybit.occt.cleanAllCache_description": "Cleans all cache and all shapes from the memory",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "vertex from xyz",
    "vertex": "vertex",
    "vertexFromXYZ": "vertex from xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Creates vertex shape from x y z coordinates",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "vertex from point",
    "vertexFromPoint": "vertex from point",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Creates vertex shape from point",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "vertices from points",
    "verticesFromPoints": "vertices from points",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "creates vertices from points",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "vertices compound from points",
    "verticesCompoundFromPoints": "vertices compound from points",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Creates compound shape containing multiple vertices. This simply speeds up rendering and allows to apply occt transformations easily on vertex groups.",
    "bitbybit.occt.shapes.vertex.getVertices": "get vertices",
    "getVertices": "get vertices",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Get all vertices in the list of a shape",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "get vertices as points",
    "getVerticesAsPoints": "get vertices as points",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Get all vertices in the list of a shape as points",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "vertices to points",
    "verticesToPoints": "vertices to points",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforms vertices to points",
    "transform": "transform",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "vertex to point",
    "vertexToPoint": "vertex to point",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Transform vertex to point",
    "bitbybit.occt.shapes.vertex.projectPoints": "project points",
    "projectPoints": "project points",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "Project points on a shape and return the projected points - length of the vector is essential",
    "place": "place",
    "projectionType": "projection type",
    "pointProjectionTypeEnum": "point projection type enum",
    "bitbybit.occt.shapes.edge.line": "line",
    "edge": "edge",
    "bitbybit.occt.shapes.edge.line_description": "creates linear edge between two points",
    "primitives": "primitives",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arc through three points",
    "arcThroughThreePoints": "arc through three points",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Creates arc edge between three points",
    "middle": "middle",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arc through two points and tangent",
    "arcThroughTwoPointsAndTangent": "arc through two points and tangent",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Creates arc edge between two points given the tangent direction vector on first point.",
    "tangentVec": "tangent vector",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arc from circle and two points",
    "arcFromCircleAndTwoPoints": "arc from circle and two points",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Creates an arc edge between two points on a circle",
    "circle": "circle",
    "sense": "sense",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arc from circle and two angles",
    "arcFromCircleAndTwoAngles": "arc from circle and two angles",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Creates an arc edge between two alpha angles on a circle",
    "alphaAngle1": "alpha angle 1",
    "alphaAngle2": "alpha angle 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arc from circle point and angle",
    "arcFromCirclePointAndAngle": "arc from circle point and angle",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Creates an arc edge between the point on a circle and a given alpha angle",
    "alphaAngle": "alpha angle",
    "bitbybit.occt.shapes.edge.createCircleEdge": "circle edge",
    "createCircleEdge": "circle edge",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "creates opencascade circle edge",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "ellipse edge",
    "createEllipseEdge": "ellipse edge",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "creates opencascade ellipse edge",
    "radiusMinor": "radius minor",
    "radiusMajor": "radius major",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "remove internal edges",
    "removeInternalEdges": "remove internal edges",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Removes internal faces for the shape",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "make edge from geom 2d curve and surface",
    "makeEdgeFromGeom2dCurveAndSurface": "make edge from geom 2d curve and surface",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Creates an edge from geom curve and geom surface",
    "curve": "curve",
    "surface": "surface",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "get edge",
    "getEdge": "get edge",
    "bitbybit.occt.shapes.edge.getEdge_description": "Gets the edge by providing an index from the shape",
    "index": "index",
    "bitbybit.occt.shapes.edge.getEdges": "get edges",
    "getEdges": "get edges",
    "bitbybit.occt.shapes.edge.getEdges_description": "Gets the edges of a shape in a list",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "get edges along wire",
    "getEdgesAlongWire": "get edges along wire",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Gets the edges of a wire ordered along the direction of the wire",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "get circular edges along wire",
    "getCircularEdgesAlongWire": "get circular edges along wire",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Gets circular edges of a wire ordered along the direction of the wire",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "get linear edges along wire",
    "getLinearEdgesAlongWire": "get linear edges along wire",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Gets linear edges of a wire ordered along the direction of the wire",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "get corner points of edges for shape",
    "getCornerPointsOfEdgesForShape": "get corner points of edges for shape",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Gets corner points of edges for a shape. There's no order guarantee here. All duplicates are removed, so when three edges form one corner, that will be represented by a single point in the list.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "get edge length",
    "getEdgeLength": "get edge length",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Gets the edge length",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "get edge lengths of shape",
    "getEdgeLengthsOfShape": "get edge lengths of shape",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Gets the edge lengths of the shape",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "get edges lengths",
    "getEdgesLengths": "get edges lengths",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Gets the lengths of the edges",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "get edge center of mass",
    "getEdgeCenterOfMass": "get edge center of mass",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Gets the center of mass for the edge",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "get edges centers of mass",
    "getEdgesCentersOfMass": "get edges centers of mass",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Gets the centers of mass for the edges",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "get circular edge center point",
    "getCircularEdgeCenterPoint": "get circular edge center point",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Gets the center point of the circular edge. If edge is not circular, point will not be returned.",
    "get circular edge": "get circular edge",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "get circular edge radius",
    "getCircularEdgeRadius": "get circular edge radius",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Gets the radius of the circular edge. If edge is not circular, radius will not be returned.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "get circular edge plane direction",
    "getCircularEdgePlaneDirection": "get circular edge plane direction",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Gets the direction vector of the plane of the circular edge. If edge is not circular, direction vector will not be returned.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "point on edge at param",
    "pointOnEdgeAtParam": "point on edge at param",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Gets the point on edge at param",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "points on edges at param",
    "pointsOnEdgesAtParam": "points on edges at param",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Gets the points on edges at param",
    "bitbybit.occt.shapes.edge.edgesToPoints": "edges to points",
    "edgesToPoints": "edges to points",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Gets the points of all edges from a shape in separate lists for each edge",
    "angularDeflection": "angular deflection",
    "curvatureDeflection": "curvature deflection",
    "minimumOfPoints": "minimum of points",
    "uTolerance": "u tolerance",
    "minimumLength": "minimum length",
    "bitbybit.occt.shapes.edge.reversedEdge": "reversed edge",
    "reversedEdge": "reversed edge",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Computes reversed edge from input edge",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangent on edge at param",
    "tangentOnEdgeAtParam": "tangent on edge at param",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Gets the tangent vector on edge at param",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangents on edges at param",
    "tangentsOnEdgesAtParam": "tangents on edges at param",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Gets the tangent vectors on edges at param",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "point on edge at length",
    "pointOnEdgeAtLength": "point on edge at length",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Gets the point on edge at length",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "points on edges at length",
    "pointsOnEdgesAtLength": "points on edges at length",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Gets the points on edges at length",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangent on edge at length",
    "tangentOnEdgeAtLength": "tangent on edge at length",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Gets the tangent vector on edge at length",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangents on edges at length",
    "tangentsOnEdgesAtLength": "tangents on edges at length",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Gets the tangent vectors on edges at length",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "start point on edge",
    "startPointOnEdge": "start point on edge",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Gets the start point on edge",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "start points on edges",
    "startPointsOnEdges": "start points on edges",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Gets the start points on edges",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "end point on edge",
    "endPointOnEdge": "end point on edge",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Gets the end point on edge",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "end points on edges",
    "endPointsOnEdges": "end points on edges",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Gets the end points on edges",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "divide edge by params to points",
    "divideEdgeByParamsToPoints": "divide edge by params to points",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divides edge by params to points",
    "nrOfDivisions": "nr of divisions",
    "removeStartPoint": "remove start point",
    "removeEndPoint": "remove end point",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "divide edges by params to points",
    "divideEdgesByParamsToPoints": "divide edges by params to points",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divides edges by params to points",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "divide edge by equal distance to points",
    "divideEdgeByEqualDistanceToPoints": "divide edge by equal distance to points",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divides edge by length to points",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "divide edges by equal distance to points",
    "divideEdgesByEqualDistanceToPoints": "divide edges by equal distance to points",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divides edges by length to points",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "constraint tan lines from two pts to circle",
    "constraintTanLinesFromTwoPtsToCircle": "constraint tan lines from two pts to circle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Creates lines from two given points till circle tangent locations",
    "constraint": "constraint",
    "point1": "point 1",
    "point2": "point 2",
    "positionResult": "position result",
    "positionResultEnum": "position result enum",
    "circleRemainder": "circle remainder",
    "circleInclusionEnum": "circle inclusion enum",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "constraint tan lines from pt to circle",
    "constraintTanLinesFromPtToCircle": "constraint tan lines from pt to circle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Creates lines from a given point till circle tangent locations",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "constraint tan lines on two circles",
    "constraintTanLinesOnTwoCircles": "constraint tan lines on two circles",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Creates tangent lines between two circles.",
    "circle1": "circle 1",
    "circle2": "circle 2",
    "circleRemainders": "circle remainders",
    "twoCircleInclusionEnum": "two circle inclusion enum",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "constraint tan circles on two circles",
    "constraintTanCirclesOnTwoCircles": "constraint tan circles on two circles",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Creates tangent circles between two circles.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "constraint tan circles on circle and pnt",
    "constraintTanCirclesOnCircleAndPnt": "constraint tan circles on circle and pnt",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Creates tangent circles between a point and a circle.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "is edge linear",
    "isEdgeLinear": "is edge linear",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Checks whether an edge is linear",
    "is": "is",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "is edge circular",
    "isEdgeCircular": "is edge circular",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Checks whether an edge is circular",
    "bitbybit.occt.shapes.wire.createPolygonWire": "polygon wire",
    "wire": "wire",
    "createPolygonWire": "polygon wire",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "creates opencascade polygon wire",
    "via points": "via points",
    "bitbybit.occt.shapes.wire.createPolygons": "polygons",
    "createPolygons": "polygons",
    "bitbybit.occt.shapes.wire.createPolygons_description": "creates opencascade polygons",
    "multiple": "multiple",
    "polygons": "polygons",
    "PolygonDto[]": "polygon dto array",
    "returnCompound": "return compound",
    "bitbybit.occt.shapes.wire.createLineWire": "line wire",
    "createLineWire": "line wire",
    "bitbybit.occt.shapes.wire.createLineWire_description": "creates opencascade line wire",
    "bitbybit.occt.shapes.wire.createLines": "lines",
    "createLines": "lines",
    "bitbybit.occt.shapes.wire.createLines_description": "creates opencascade lines",
    "LineDto[]": "line dto array",
    "bitbybit.occt.shapes.wire.splitOnPoints": "split on points",
    "splitOnPoints": "split on points",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Splits a wire on a set of given points",
    "bitbybit.occt.shapes.wire.wiresToPoints": "wires to points",
    "wiresToPoints": "wires to points",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Transform shape wires to points ordered in lists. This also removes duplicated points between start end end points of consecutive edges on the wire",
    "bitbybit.occt.shapes.wire.createPolylineWire": "polyline wire",
    "createPolylineWire": "polyline wire",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "creates opencascade polyline wire",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zig zag between two wires",
    "createZigZagBetweenTwoWires": "zig zag between two wires",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "creates zig zag between two wires",
    "via wires": "via wires",
    "wire1": "wire 1",
    "wire2": "wire 2",
    "nrZigZags": "nr zig zags",
    "inverse": "inverse",
    "divideByEqualDistance": "divide by equal distance",
    "zigZagsPerEdge": "zig zags per edge",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "wire from two circles tan",
    "createWireFromTwoCirclesTan": "wire from two circles tan",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Creates a tangent wire enclosing two planar circles",
    "keepLines": "keep lines",
    "twoSidesStrictEnum": "two sides strict enum",
    "fourSidesStrictEnum": "four sides strict enum",
    "bitbybit.occt.shapes.wire.createPolylines": "polylines",
    "createPolylines": "polylines",
    "bitbybit.occt.shapes.wire.createPolylines_description": "creates opencascade polyline wires",
    "polylines": "polylines",
    "PolylineDto[]": "polyline dto array",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "creates opencascade bezier wire",
    "bitbybit.occt.shapes.wire.createBezierWeights": "bezier weights",
    "createBezierWeights": "bezier weights",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "creates opencascade bezier wire with weights",
    "weights": "weights",
    "bitbybit.occt.shapes.wire.createBezierWires": "bezier wires",
    "createBezierWires": "bezier wires",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "creates opencascade bezier wires",
    "bezierWires": "bezier wires",
    "BezierDto[]": "bezier dto array",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpolate points",
    "interpolatePoints": "interpolate points",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Creates OpenCascade BSpline wire from points. This method can be used to create nicely shaped (periodic) loops.",
    "periodic": "periodic",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpolate wires",
    "interpolateWires": "interpolate wires",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Creates OpenCascade multiple interpolated wires",
    "interpolations": "interpolations",
    "InterpolationDto[]": "interpolation dto array",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "creates opencascade bspline wire",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "creates opencascade bspline wires",
    "bSplines": "bsplines",
    "BSplineDto[]": "bspline dto array",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combine edges and wires into a wire",
    "combineEdgesAndWiresIntoAWire": "combine edges and wires into a wire",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Combines OpenCascade edges and wires into a single wire",
    "build": "build",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "wire from edge",
    "createWireFromEdge": "wire from edge",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "creates wire from edge",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "add edges and wires to wire",
    "addEdgesAndWiresToWire": "add edges and wires to wire",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Adds OpenCascade edges and wires into another wire",
    "U[]": "u array",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "divide wire by params to points",
    "divideWireByParamsToPoints": "divide wire by params to points",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Divides OpenCascade wire to points blindly following its parametric space",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "divide wires by params to points",
    "divideWiresByParamsToPoints": "divide wires by params to points",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Divides OpenCascade wires to points blindly following its parametric space",
    "extract from wires": "extract from wires",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "divide wire by equal distance to points",
    "divideWireByEqualDistanceToPoints": "divide wire by equal distance to points",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Divides OpenCascade wire to equal distance points",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "divide wires by equal distance to points",
    "divideWiresByEqualDistanceToPoints": "divide wires by equal distance to points",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Divides OpenCascade wires to equal distance points",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "point on wire at param",
    "pointOnWireAtParam": "point on wire at param",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Evaluates point on a wire at parameter value between 0 and 1, being start and end points",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "point on wire at length",
    "pointOnWireAtLength": "point on wire at length",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Evaluates point on a wire at certain length",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "points on wire at lengths",
    "pointsOnWireAtLengths": "points on wire at lengths",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Evaluates points on a wire at certain lengths",
    "lengths": "lengths",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "points on wire at equal length",
    "pointsOnWireAtEqualLength": "points on wire at equal length",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Evaluates points on a wire at equal length",
    "tryNext": "try next",
    "includeFirst": "include first",
    "includeLast": "include last",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "points on wire at pattern of lengths",
    "pointsOnWireAtPatternOfLengths": "points on wire at pattern of lengths",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Evaluates points on a wire at pattern of lengths",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangent on wire at param",
    "tangentOnWireAtParam": "tangent on wire at param",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Evaluates tangent vector on a wire at parameter value between 0 and 1, being start and end points",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangent on wire at length",
    "tangentOnWireAtLength": "tangent on wire at length",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Evaluates tangent vector on a wire at certain length",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "derivatives on wire at length",
    "derivativesOnWireAtLength": "derivatives on wire at length",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Computes 3 derivative vectors of a curve at a given length",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "derivatives on wire at param",
    "derivativesOnWireAtParam": "derivatives on wire at param",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Computes 3 derivative vectors of a curve on parameter between 0 and 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "start point on wire",
    "startPointOnWire": "start point on wire",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Computes the start point on the wire at param 0",
    "bitbybit.occt.shapes.wire.endPointOnWire": "end point on wire",
    "endPointOnWire": "end point on wire",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Computes the end point on the wire at param 1",
    "bitbybit.occt.shapes.wire.createCircleWire": "circle wire",
    "createCircleWire": "circle wire",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "creates opencascade circle wire",
    "bitbybit.occt.shapes.wire.createSquareWire": "square wire",
    "createSquareWire": "square wire",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "creates opencascade square wire",
    "bitbybit.occt.shapes.wire.createStarWire": "star wire",
    "createStarWire": "star wire",
    "bitbybit.occt.shapes.wire.createStarWire_description": "creates opencascade star wire",
    "numRays": "num rays",
    "outerRadius": "outer radius",
    "innerRadius": "inner radius",
    "offsetOuterEdges": "offset outer edges",
    "half": "half",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "christmas tree wire",
    "createChristmasTreeWire": "christmas tree wire",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "creates christmas tree wire",
    "innerDist": "inner dist",
    "outerDist": "outer dist",
    "nrSkirts": "nr skirts",
    "trunkHeight": "trunk height",
    "trunkWidth": "trunk width",
    "bitbybit.occt.shapes.wire.createNGonWire": "ngon wire",
    "createNGonWire": "ngon wire",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Creates OpenCascade n-gon wire",
    "nrCorners": "nr corners",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "parallelogram wire",
    "createParallelogramWire": "parallelogram wire",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Creates n parallelogram wire",
    "aroundCenter": "around center",
    "bitbybit.occt.shapes.wire.createHeartWire": "heart wire",
    "createHeartWire": "heart wire",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Creates a heart wire",
    "sizeApprox": "size approx",
    "bitbybit.occt.shapes.wire.createRectangleWire": "rectangle wire",
    "createRectangleWire": "rectangle wire",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "creates opencascade rectangle wire",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "L polygon wire",
    "createLPolygonWire": "L polygon wire",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "creates opencascade L polygon wire",
    "widthFirst": "width first",
    "lengthFirst": "length first",
    "widthSecond": "width second",
    "lengthSecond": "length second",
    "align": "align",
    "directionEnum": "direction enum",
    "bitbybit.occt.shapes.wire.createEllipseWire": "ellipse wire",
    "createEllipseWire": "ellipse wire",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "creates opencascade ellipse wire",
    "bitbybit.occt.shapes.wire.textWires": "text wires",
    "textWires": "text wires",
    "bitbybit.occt.shapes.wire.textWires_description": "Creates OpenCascade text wires based on simplex font created by Dr. A. V. Hershey",
    "xOffset": "x offset",
    "yOffset": "y offset",
    "letterSpacing": "letter spacing",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "extrude offset",
    "bitbybit.occt.shapes.wire.getWire": "get wire",
    "getWire": "get wire",
    "bitbybit.occt.shapes.wire.getWire_description": "Gets the wire by providing an index from the shape",
    "bitbybit.occt.shapes.wire.getWires": "get wires",
    "getWires": "get wires",
    "bitbybit.occt.shapes.wire.getWires_description": "Gets all the wires from the shape",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "get wire center of mass",
    "getWireCenterOfMass": "get wire center of mass",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Get the wire center of mass point",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "get wires centers of mass",
    "getWiresCentersOfMass": "get wires centers of mass",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Get the wires centers of mass point",
    "bitbybit.occt.shapes.wire.reversedWire": "reversed wire",
    "reversedWire": "reversed wire",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Computes reversed wire from input wire",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "reversed wire from reversed edges",
    "reversedWireFromReversedEdges": "reversed wire from reversed edges",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Computes reversed wire by reversing all edges and combining them into a new wire",
    "bitbybit.occt.shapes.wire.isWireClosed": "is wire closed",
    "isWireClosed": "is wire closed",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Checks whether wire is closed",
    "bitbybit.occt.shapes.wire.getWireLength": "get wire length",
    "getWireLength": "get wire length",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Gets the wire length",
    "bitbybit.occt.shapes.wire.getWiresLengths": "get wires lengths",
    "getWiresLengths": "get wires lengths",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Gets the lengths of wires",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "place wire on face",
    "placeWireOnFace": "place wire on face",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Places a wire on the face by mapping it's 2d coordinates to UV space. Wire must be positioned on the ground XZ plane for this to work.",
    "face": "face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "place wires on face",
    "placeWiresOnFace": "place wires on face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Places multiple wires on the face by mapping it's 2d coordinates to UV space. Wires must be positioned on the ground XZ plane for this to work.",
    "wires": "wires",
    "bitbybit.occt.shapes.wire.closeOpenWire": "close open wire",
    "closeOpenWire": "close open wire",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Closes the open wire with additional straight edge joining start and end points",
    "bitbybit.occt.shapes.wire.project": "project",
    "project": "project",
    "bitbybit.occt.shapes.wire.project_description": "Project wire on the shape",
    "bitbybit.occt.shapes.wire.projectWires": "project wires",
    "projectWires": "project wires",
    "bitbybit.occt.shapes.wire.projectWires_description": "Project multiple wires on the shape",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "faces from wires on face",
    "createFacesFromWiresOnFace": "faces from wires on face",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Creates a faces from wires on face",
    "inside": "inside",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "face from wire on face",
    "createFaceFromWireOnFace": "face from wire on face",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Creates a face from wire on face",
    "bitbybit.occt.shapes.face.createFaceFromWire": "face from wire",
    "createFaceFromWire": "face from wire",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Creates a face from wire",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "face from wires",
    "createFaceFromWires": "face from wires",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Creates a face from wires. This can produce hollow faces.",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "face from wires on face",
    "createFaceFromWiresOnFace": "face from wires on face",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Creates a face from wires on the guiding face. This can produce hollow faces.",
    "bitbybit.occt.shapes.face.createFacesFromWires": "faces from wires",
    "createFacesFromWires": "faces from wires",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "creates faces from wires",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "face from multiple circle tan wires",
    "createFaceFromMultipleCircleTanWires": "face from multiple circle tan wires",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "creates face from multiple circle tangent wires",
    "circles": "circles",
    "combination": "combination",
    "combinationCirclesForFaceEnum": "combination circles for face enum",
    "unify": "unify",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "face from multiple circle tan wire collections",
    "createFaceFromMultipleCircleTanWireCollections": "face from multiple circle tan wire collections",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "creates face from multiple circle tangent wire collections",
    "listsOfCircles": "lists of circles",
    "T[][]": "t array array",
    "bitbybit.occt.shapes.face.faceFromSurface": "face from surface",
    "faceFromSurface": "face from surface",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Creates a face from the surface",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "face from surface and wire",
    "faceFromSurfaceAndWire": "face from surface and wire",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Creates a face from the surface and a wire",
    "bitbybit.occt.shapes.face.createPolygonFace": "polygon face",
    "createPolygonFace": "polygon face",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "creates opencascade polygon face",
    "bitbybit.occt.shapes.face.createCircleFace": "circle face",
    "createCircleFace": "circle face",
    "bitbybit.occt.shapes.face.createCircleFace_description": "creates opencascade circle face",
    "bitbybit.occt.shapes.face.createEllipseFace": "ellipse face",
    "createEllipseFace": "ellipse face",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "creates opencascade ellipse face",
    "bitbybit.occt.shapes.face.createSquareFace": "square face",
    "createSquareFace": "square face",
    "bitbybit.occt.shapes.face.createSquareFace_description": "creates opencascade square face",
    "bitbybit.occt.shapes.face.createRectangleFace": "rectangle face",
    "createRectangleFace": "rectangle face",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "creates opencascade rectangle face",
    "bitbybit.occt.shapes.face.getFace": "get face",
    "getFace": "get face",
    "bitbybit.occt.shapes.face.getFace_description": "Gets the face by providing an index from the shape",
    "bitbybit.occt.shapes.face.getFaces": "get faces",
    "getFaces": "get faces",
    "bitbybit.occt.shapes.face.getFaces_description": "Gets the faces of the shape in a list",
    "bitbybit.occt.shapes.face.reversedFace": "reversed face",
    "reversedFace": "reversed face",
    "bitbybit.occt.shapes.face.reversedFace_description": "Computes reversed face from input face",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdivide to points",
    "subdivideToPoints": "subdivide to points",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Subdivides a face to point grid",
    "nrDivisionsU": "nr divisions u",
    "nrDivisionsV": "nr divisions v",
    "shiftHalfStepU": "shift half step u",
    "removeStartEdgeU": "remove start edge u",
    "removeEndEdgeU": "remove end edge u",
    "shiftHalfStepV": "shift half step v",
    "removeStartEdgeV": "remove start edge v",
    "removeEndEdgeV": "remove end edge v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdivide to wires",
    "subdivideToWires": "subdivide to wires",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Subdivides a face to wires",
    "nrDivisions": "nr divisions",
    "isU": "is u",
    "shiftHalfStep": "shift half step",
    "removeStart": "remove start",
    "removeEnd": "remove end",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdivide to rectangle wires",
    "subdivideToRectangleWires": "subdivide to rectangle wires",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Subdivides a face to rectangle wires",
    "patterns": "patterns",
    "nrRectanglesU": "nr rectangles u",
    "nrRectanglesV": "nr rectangles v",
    "scalePatternU": "scale pattern u",
    "scalePatternV": "scale pattern v",
    "filletPattern": "fillet pattern",
    "inclusionPattern": "inclusion pattern",
    "offsetFromBorderU": "offset from border u",
    "offsetFromBorderV": "offset from border v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdivide to rectangle holes",
    "subdivideToRectangleHoles": "subdivide to rectangle holes",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Subdivides a face to rectangle wires",
    "holesToFaces": "holes to faces",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdivide to points controlled",
    "subdivideToPointsControlled": "subdivide to points controlled",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Subdivides a face to point grid with shifts and removals on nth uv rows or columns",
    "shiftHalfStepNthU": "shift half step nth u",
    "shiftHalfStepUOffsetN": "shift half step u offset n",
    "removeStartEdgeNthU": "remove start edge nth u",
    "removeStartEdgeUOffsetN": "remove start edge u offset n",
    "removeEndEdgeNthU": "remove end edge nth u",
    "removeEndEdgeUOffsetN": "remove end edge u offset n",
    "shiftHalfStepNthV": "shift half step nth v",
    "shiftHalfStepVOffsetN": "shift half step v offset n",
    "removeStartEdgeNthV": "remove start edge nth v",
    "removeStartEdgeVOffsetN": "remove start edge v offset n",
    "removeEndEdgeNthV": "remove end edge nth v",
    "removeEndEdgeVOffsetN": "remove end edge v offset n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdivide to normals",
    "subdivideToNormals": "subdivide to normals",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Subdivides a face to normals grid",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdivide to uv",
    "subdivideToUV": "subdivide to uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Subdivides a face to uv grid",
    "bitbybit.occt.shapes.face.pointOnUV": "point on uv",
    "pointOnUV": "point on uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Get point on UV where U and V are described between 0 and 1. These will be mapped to real bounds.",
    "paramU": "param u",
    "paramV": "param v",
    "bitbybit.occt.shapes.face.normalOnUV": "normal on uv",
    "normalOnUV": "normal on uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Get normal on UV where U and V are described between 0 and 1. These will be mapped to real bounds.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "points on uvs",
    "pointsOnUVs": "points on uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Get points on UVs where U and V are described between 0 and 1 in two dimensional arrays. These will be mapped to real bounds.",
    "paramsUV": "params uv",
    "[number, number][]": "number pair array",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normals on uvs",
    "normalsOnUVs": "normals on uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Get normals on UVs where U and V are described between 0 and 1 in two dimensional arrays. These will be mapped to real bounds.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdivide to points on param",
    "subdivideToPointsOnParam": "subdivide to points on param",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Subdivides a face to points along a line on parameter",
    "nrPoints": "nr points",
    "bitbybit.occt.shapes.face.wireAlongParam": "wire along param",
    "wireAlongParam": "wire along param",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Gets the wire along the parameter on the face",
    "bitbybit.occt.shapes.face.wiresAlongParams": "wires along params",
    "wiresAlongParams": "wires along params",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Gets the wires along the parameters on the face",
    "params": "params",
    "bitbybit.occt.shapes.face.getUMinBound": "get u min bound",
    "getUMinBound": "get u min bound",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Gets the U min bound of the face",
    "bitbybit.occt.shapes.face.getUMaxBound": "get u max bound",
    "getUMaxBound": "get u max bound",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Gets the U max bound of the face",
    "bitbybit.occt.shapes.face.getVMinBound": "get v min bound",
    "getVMinBound": "get v min bound",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Gets the V min bound of the face",
    "bitbybit.occt.shapes.face.getVMaxBound": "get v max bound",
    "getVMaxBound": "get v max bound",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Gets the V max bound of the face",
    "bitbybit.occt.shapes.face.getFaceArea": "get face area",
    "getFaceArea": "get face area",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Get the area of the face",
    "bitbybit.occt.shapes.face.getFacesAreas": "get faces areas",
    "getFacesAreas": "get faces areas",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Get the areas of the faces",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "get face center of mass",
    "getFaceCenterOfMass": "get face center of mass",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Get the face center of mass point",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "get faces centers of mass",
    "getFacesCentersOfMass": "get faces centers of mass",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Get the center of mass points for faces",
    "bitbybit.occt.shapes.face.filterFacePoints": "filter face points",
    "filterFacePoints": "filter face points",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filters points on face",
    "filter": "filter",
    "useBndBox": "use bnd box",
    "gapTolerance": "gap tolerance",
    "keepIn": "keep in",
    "keepOn": "keep on",
    "keepOut": "keep out",
    "keepUnknown": "keep unknown",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filter faces points",
    "filterFacesPoints": "filter faces points",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filters points on faces",
    "flatPointsArray": "flat points array",
    "bitbybit.occt.shapes.shell.sewFaces": "sew faces",
    "shell": "shell",
    "sewFaces": "sew faces",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Creates a shell from faces",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "get shell surface area",
    "getShellSurfaceArea": "get shell surface area",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Get shell surface area",
    "bitbybit.occt.shapes.solid.fromClosedShell": "from closed shell",
    "solid": "solid",
    "fromClosedShell": "from closed shell",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Creates Solid From shell that must be closed",
    "bitbybit.occt.shapes.solid.createBox": "box",
    "bitbybit.occt.shapes.solid.createBox_description": "creates opencascade box",
    "originOnCenter": "origin on center",
    "bitbybit.occt.shapes.solid.createCube": "cube",
    "bitbybit.occt.shapes.solid.createCube_description": "creates opencascade cube",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "box from corner",
    "createBoxFromCorner": "box from corner",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "creates opencascade box from corner",
    "corner": "corner",
    "bitbybit.occt.shapes.solid.createCylinder": "cylinder",
    "bitbybit.occt.shapes.solid.createCylinder_description": "creates opencascade cylinder",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cylinders on lines",
    "createCylindersOnLines": "cylinders on lines",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Creates OpenCascade Cylinders on simple bit by bit lines represented by two points",
    "Base.Line3[]": "base line3 array",
    "bitbybit.occt.shapes.solid.createSphere": "sphere",
    "bitbybit.occt.shapes.solid.createSphere_description": "creates opencascade sphere",
    "bitbybit.occt.shapes.solid.createCone": "cone",
    "createCone": "cone",
    "bitbybit.occt.shapes.solid.createCone_description": "creates opencascade cone",
    "radius1": "radius 1",
    "radius2": "radius 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "get solid surface area",
    "getSolidSurfaceArea": "get solid surface area",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Get solid surface area",
    "bitbybit.occt.shapes.solid.getSolidVolume": "get solid volume",
    "getSolidVolume": "get solid volume",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Get solid volume",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "get solids volumes",
    "getSolidsVolumes": "get solids volumes",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Get solids volumes",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "get solid center of mass",
    "getSolidCenterOfMass": "get solid center of mass",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Get solid center of mass",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "get solids centers of mass",
    "getSolidsCentersOfMass": "get solids centers of mass",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Get centers of mass of solids",
    "bitbybit.occt.shapes.solid.getSolids": "get solids",
    "getSolids": "get solids",
    "bitbybit.occt.shapes.solid.getSolids_description": "Gets the solids of the shape in a list",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filter solid points",
    "filterSolidPoints": "filter solid points",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Filters collection of points based on relationship with the solid. You can choose whether to output in, on or out points.",
    "bitbybit.occt.shapes.compound.makeCompound": "make compound",
    "compound": "compound",
    "makeCompound": "make compound",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Makes the compound shape, which can include any kind of shapes",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "get shapes of compound",
    "getShapesOfCompound": "get shapes of compound",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Gets the shapes that compound is made of",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "purge internal edges",
    "purgeInternalEdges": "purge internal edges",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Remove internal edges that are not connected to any face in the shape",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unify same domain",
    "unifySameDomain": "unify same domain",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Unifies faces, edges in the same domain and has possibility to concatinate bsplines",
    "unifyEdges": "unify edges",
    "unifyFaces": "unify faces",
    "concatBSplines": "concat bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "is closed",
    "bitbybit.occt.shapes.shape.isClosed_description": "Check if the shape is closed",
    "analysis": "analysis",
    "bitbybit.occt.shapes.shape.isConvex": "is convex",
    "isConvex": "is convex",
    "bitbybit.occt.shapes.shape.isConvex_description": "Check if the shape is convex",
    "bitbybit.occt.shapes.shape.isChecked": "is checked",
    "bitbybit.occt.shapes.shape.isChecked_description": "Check if the shape is checked",
    "bitbybit.occt.shapes.shape.isFree": "is free",
    "isFree": "is free",
    "bitbybit.occt.shapes.shape.isFree_description": "Check if the shape is free",
    "bitbybit.occt.shapes.shape.isInfinite": "is infinite",
    "isInfinite": "is infinite",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Check if the shape is infinite",
    "bitbybit.occt.shapes.shape.isModified": "is modified",
    "isModified": "is modified",
    "bitbybit.occt.shapes.shape.isModified_description": "Check if the shape is modified",
    "bitbybit.occt.shapes.shape.isLocked": "is locked",
    "isLocked": "is locked",
    "bitbybit.occt.shapes.shape.isLocked_description": "Check if the shape is locked",
    "bitbybit.occt.shapes.shape.isNull": "is null",
    "isNull": "is null",
    "bitbybit.occt.shapes.shape.isNull_description": "Check if the shape is null",
    "bitbybit.occt.shapes.shape.isEqual": "is equal",
    "isEqual": "is equal",
    "bitbybit.occt.shapes.shape.isEqual_description": "Check if the shape is equal to other shape",
    "otherShape": "other shape",
    "bitbybit.occt.shapes.shape.isNotEqual": "is not equal",
    "isNotEqual": "is not equal",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Check if the shape is not equal to other shape",
    "bitbybit.occt.shapes.shape.isPartner": "is partner",
    "isPartner": "is partner",
    "bitbybit.occt.shapes.shape.isPartner_description": "Check if the shape is partner to other shape",
    "bitbybit.occt.shapes.shape.isSame": "is same",
    "isSame": "is same",
    "bitbybit.occt.shapes.shape.isSame_description": "Check if the shape is the same as the other shape",
    "bitbybit.occt.shapes.shape.getOrientation": "get orientation",
    "getOrientation": "get orientation",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Get the shape orientation",
    "bitbybit.occt.shapes.shape.getShapeType": "get shape type",
    "getShapeType": "get shape type",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Get the shape type",
    "bitbybit.occt.geom.curves.geom2dEllipse": "geom 2d ellipse",
    "geom": "geom",
    "curves": "curves",
    "geom2dEllipse": "geom 2d ellipse",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Creates a 2d ellipse. Be sure to use this geometry only for constructive purposes of modeling, but not for representation. You need to transform these curves to edges in order to draw them.",
    "Base.Point2": "base point 2",
    "Base.Vector2": "base vector 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "geom 2d trimmed curve",
    "geom2dTrimmedCurve": "geom 2d trimmed curve",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Creates a trimmed curve from the basis curve limited between U1 and U2. This curve can't be drawn.",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "adjust periodic",
    "bitbybit.occt.geom.curves.geom2dSegment": "geom 2d segment",
    "geom2dSegment": "geom 2d segment",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Creates a trimmed 2d curve segment between two 2d points. This curve can't be drawn.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "get 2d point from 2d curve on param",
    "get2dPointFrom2dCurveOnParam": "get 2d point from 2d curve on param",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Gets 2d point represented by [number, number] on a curve at parameter.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "geom circle curve",
    "geomCircleCurve": "geom circle curve",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Creates a circle geom curve",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "geom ellipse curve",
    "geomEllipseCurve": "geom ellipse curve",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Creates an ellipse geom curve",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "cylindrical surface",
    "surfaces": "surfaces",
    "cylindricalSurface": "cylindrical surface",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Creates an infinite cylindrical surface that can not be drawn. Be sure to use this geometry only for constructive purposes of modeling, but not for representation.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "surface from face",
    "surfaceFromFace": "surface from face",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Creates a surface from the face",
    "bitbybit.occt.fillets.filletEdges": "fillet edges",
    "fillets": "fillets",
    "filletEdges": "fillet edges",
    "bitbybit.occt.fillets.filletEdges_description": "fillets opencascade shapes",
    "3d fillets": "3d fillets",
    "radiusList": "radius list",
    "indexes": "indexes",
    "bitbybit.occt.fillets.filletEdgesList": "fillet edges list",
    "filletEdgesList": "fillet edges list",
    "bitbybit.occt.fillets.filletEdgesList_description": "Fillets edges list with different radius on each edge.",
    "edges": "edges",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "fillet edges list one radius",
    "filletEdgesListOneRadius": "fillet edges list one radius",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Fillets edges list with the single radius on all edges.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "fillet edge variable radius",
    "filletEdgeVariableRadius": "fillet edge variable radius",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Fillets a single edge with variable radius list on given u params. You need to provide a list of params to identify on which U param to apply the radius on.",
    "paramsU": "params u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "fillet edges same variable radius",
    "filletEdgesSameVariableRadius": "fillet edges same variable radius",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Fillets multiple provided edges with the same variable radiuses on u params for each edge.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "fillet edges variable radius",
    "filletEdgesVariableRadius": "fillet edges variable radius",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Fillets multiple provided edges with variable radius lists on given params lists. You need to provide a list of params to identify on which U param to apply the radius on.",
    "radiusLists": "radius lists",
    "paramsULists": "params u lists",
    "bitbybit.occt.fillets.fillet3DWire": "fillet 3d wire",
    "fillet3DWire": "fillet 3d wire",
    "bitbybit.occt.fillets.fillet3DWire_description": "Fillets OpenCascade 3d wire, this algorithm takes one guiding direction for fillets to be formed. It does not respect tangent directions on each filleted corner. This algorithm is based on extruding wire along the given direction to form a shell, then filleting the shell and finally extracting the filleted wire from the shell itself. Make sure you provide a direction that is not parallel to the wire and that forms high enough extrusion for the fillet to succeed.",
    "bitbybit.occt.fillets.fillet3DWires": "fillet 3d wires",
    "fillet3DWires": "fillet 3d wires",
    "bitbybit.occt.fillets.fillet3DWires_description": "Fillets OpenCascade 3d wires, this algorithm takes one guiding direction for fillets to be formed. It does not respect tangent directions on each filleted corner. This algorithm is based on extruding wires along the given direction to form a shell, then filleting the shell and finally extracting the filleted wire from the shell itself. Make sure you provide a direction that is not parallel to the wire and that forms high enough extrusion for the fillet to succeed.",
    "bitbybit.occt.fillets.chamferEdges": "chamfer edges",
    "chamferEdges": "chamfer edges",
    "bitbybit.occt.fillets.chamferEdges_description": "Chamfer OpenCascade Shape edges",
    "3d chamfers": "3d chamfers",
    "distanceList": "distance list",
    "bitbybit.occt.fillets.chamferEdgesList": "chamfer edges list",
    "chamferEdgesList": "chamfer edges list",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Chamfers edges list with different distance on each edge.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "chamfer edge two distances",
    "chamferEdgeTwoDistances": "chamfer edge two distances",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Chamfers edge by a by two distances. Face indicates the first distance to be applied",
    "F": "f",
    "distance1": "distance 1",
    "distance2": "distance 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "chamfer edges two distances",
    "chamferEdgesTwoDistances": "chamfer edges two distances",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Chamfers edges by a by two distances. Face indicates the first distance to be applied",
    "faces": "faces",
    "F[]": "f array",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "chamfer edges two distances lists",
    "chamferEdgesTwoDistancesLists": "chamfer edges two distances lists",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Chamfers edges by two distances. Face indicates the first distance to be applied",
    "distances1": "distances 1",
    "distances2": "distances 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "chamfer edge dist angle",
    "chamferEdgeDistAngle": "chamfer edge dist angle",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Chamfers edge by a given distance and angle from the face",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "chamfer edges dist angle",
    "chamferEdgesDistAngle": "chamfer edges dist angle",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Chamfers multiple edges by a given distance and angle from the faces",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "chamfer edges dists angles",
    "chamferEdgesDistsAngles": "chamfer edges dists angles",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Chamfers edges by a given distances and angles from the faces",
    "distances": "distances",
    "bitbybit.occt.fillets.fillet2d": "fillet 2d",
    "fillet2d": "fillet 2d",
    "bitbybit.occt.fillets.fillet2d_description": "fillets 2d wire or face",
    "2d fillets": "2d fillets",
    "bitbybit.occt.fillets.fillet2dShapes": "fillet 2d shapes",
    "fillet2dShapes": "fillet 2d shapes",
    "bitbybit.occt.fillets.fillet2dShapes_description": "fillets 2d wires or faces",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "fillet two edges in plane into a wire",
    "filletTwoEdgesInPlaneIntoAWire": "fillet two edges in plane into a wire",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Fillets two planar edges into a wire by providing a radius, plane, edges and possible solution index if more than one result exists",
    "edge1": "edge 1",
    "edge2": "edge 2",
    "planeOrigin": "plane origin",
    "planeDirection": "plane direction",
    "solution": "solution",
    "bitbybit.occt.transforms.transform": "transform",
    "bitbybit.occt.transforms.transform_description": "Transforms the shape",
    "on single shape": "on single shape",
    "rotationAxis": "rotation axis",
    "rotationAngle": "rotation angle",
    "scaleFactor": "scale factor",
    "bitbybit.occt.transforms.rotate": "rotate",
    "bitbybit.occt.transforms.rotate_description": "Rotate the shape",
    "bitbybit.occt.transforms.rotateAroundCenter": "rotate around center",
    "rotateAroundCenter": "rotate around center",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Rotate the shape around the provided center",
    "bitbybit.occt.transforms.align": "align",
    "bitbybit.occt.transforms.align_description": "Align the shape",
    "fromOrigin": "from origin",
    "fromDirection": "from direction",
    "toOrigin": "to origin",
    "toDirection": "to direction",
    "bitbybit.occt.transforms.alignAndTranslate": "align and translate",
    "alignAndTranslate": "align and translate",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Align and translates the shape",
    "bitbybit.occt.transforms.translate": "translate",
    "bitbybit.occt.transforms.translate_description": "Translates the shape",
    "bitbybit.occt.transforms.scale": "scale",
    "bitbybit.occt.transforms.scale_description": "Scales the shape",
    "bitbybit.occt.transforms.scale3d": "scale 3d",
    "scale3d": "scale 3d",
    "bitbybit.occt.transforms.scale3d_description": "Scales the shape in 3D",
    "bitbybit.occt.transforms.mirror": "mirror",
    "mirror": "mirror",
    "bitbybit.occt.transforms.mirror_description": "Mirrors the shape",
    "bitbybit.occt.transforms.mirrorAlongNormal": "mirror along normal",
    "mirrorAlongNormal": "mirror along normal",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Mirrors the shape along the normal and origin",
    "normal": "normal",
    "bitbybit.occt.transforms.transformShapes": "transform shapes",
    "transformShapes": "transform shapes",
    "bitbybit.occt.transforms.transformShapes_description": "Transforms the array of shapes with transformations",
    "on shapes": "on shapes",
    "rotationAxes": "rotation axes",
    "rotationAngles": "rotation angles",
    "scaleFactors": "scale factors",
    "bitbybit.occt.transforms.rotateShapes": "rotate shapes",
    "rotateShapes": "rotate shapes",
    "bitbybit.occt.transforms.rotateShapes_description": "Rotate the shapes with rotations",
    "axes": "axes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "rotate around center shapes",
    "rotateAroundCenterShapes": "rotate around center shapes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Rotate the shapes around the center and an axis",
    "centers": "centers",
    "bitbybit.occt.transforms.alignShapes": "align shapes",
    "alignShapes": "align shapes",
    "bitbybit.occt.transforms.alignShapes_description": "Align the shapes with alignments",
    "fromOrigins": "from origins",
    "fromDirections": "from directions",
    "toOrigins": "to origins",
    "toDirections": "to directions",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "align and translate shapes",
    "alignAndTranslateShapes": "align and translate shapes",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Align and translate the shapes",
    "directions": "directions",
    "bitbybit.occt.transforms.translateShapes": "translate shapes",
    "translateShapes": "translate shapes",
    "bitbybit.occt.transforms.translateShapes_description": "Translates the shapes with translations",
    "bitbybit.occt.transforms.scaleShapes": "scale shapes",
    "scaleShapes": "scale shapes",
    "bitbybit.occt.transforms.scaleShapes_description": "Scales the shapes with scale factors",
    "factors": "factors",
    "bitbybit.occt.transforms.scale3dShapes": "scale 3d shapes",
    "scale3dShapes": "scale 3d shapes",
    "bitbybit.occt.transforms.scale3dShapes_description": "Scales the shape in 3D",
    "scales": "scales",
    "bitbybit.occt.transforms.mirrorShapes": "mirror shapes",
    "mirrorShapes": "mirror shapes",
    "bitbybit.occt.transforms.mirrorShapes_description": "Mirrors the shapes with multiple mirrors",
    "origins": "origins",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "mirror along normal shapes",
    "mirrorAlongNormalShapes": "mirror along normal shapes",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Mirrors the shapes along the normal and origin",
    "normals": "normals",
    "bitbybit.occt.operations.loft": "loft",
    "operations": "operations",
    "loft": "loft",
    "bitbybit.occt.operations.loft_description": "Lofts wires into a shell",
    "lofts": "lofts",
    "makeSolid": "make solid",
    "bitbybit.occt.operations.loftAdvanced": "loft advanced",
    "loftAdvanced": "loft advanced",
    "bitbybit.occt.operations.loftAdvanced_description": "Lofts wires into a shell by using many advanced options",
    "straight": "straight",
    "nrPeriodicSections": "nr periodic sections",
    "useSmoothing": "use smoothing",
    "maxUDegree": "max u degree",
    "parType": "par type",
    "approxParametrizationTypeEnum": "approx parametrization type enum",
    "startVertex": "start vertex",
    "endVertex": "end vertex",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "closest points between two shapes",
    "closestPointsBetweenTwoShapes": "closest points between two shapes",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Computes two closest points between two shapes",
    "closest pts": "closest pts",
    "shape1": "shape 1",
    "shape2": "shape 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "closest points on shape from points",
    "closestPointsOnShapeFromPoints": "closest points on shape from points",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Computes closest points between a list of points and a given shape",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "closest points on shapes from points",
    "closestPointsOnShapesFromPoints": "closest points on shapes from points",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Computes closest points between a list of points and shapes",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distances to shape from points",
    "distancesToShapeFromPoints": "distances to shape from points",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Computes distances between a list of points and a corresponding closest points on shapes.",
    "bitbybit.occt.operations.boundingBoxOfShape": "bbox of shape",
    "boundingBoxOfShape": "bbox of shape",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Computes bounding box parameters of the shape",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "bbox min of shape",
    "boundingBoxMinOfShape": "bbox min of shape",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Get min point of the bounding box of the shape",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "bbox max of shape",
    "boundingBoxMaxOfShape": "bbox max of shape",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Get max point of the bounding box of the shape",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "bbox center of shape",
    "boundingBoxCenterOfShape": "bbox center of shape",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Get center point of the bounding box of the shape",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "bbox size of shape",
    "boundingBoxSizeOfShape": "bbox size of shape",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Get size point of the bounding box of the shape",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "bbox shape of shape",
    "boundingBoxShapeOfShape": "bbox shape of shape",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Get bounding box shape of the shape",
    "bitbybit.occt.operations.boundingSphereOfShape": "bsphere of shape",
    "boundingSphereOfShape": "bsphere of shape",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Computes bounding sphere parameters of the shape",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "bsphere center of shape",
    "boundingSphereCenterOfShape": "bsphere center of shape",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Get center point of the bounding sphere of the shape",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "bsphere radius of shape",
    "boundingSphereRadiusOfShape": "bsphere radius of shape",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Get radius of the bounding sphere of the shape",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "bsphere shape of shape",
    "boundingSphereShapeOfShape": "bsphere shape of shape",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Get bounding sphere shape of the shape",
    "bitbybit.occt.operations.extrude": "extrude",
    "extrude": "extrude",
    "bitbybit.occt.operations.extrude_description": "Extrudes the shape along direction - wire will produce shell, face will produce solid",
    "extrusions": "extrusions",
    "bitbybit.occt.operations.extrudeShapes": "extrude shapes",
    "extrudeShapes": "extrude shapes",
    "bitbybit.occt.operations.extrudeShapes_description": "Extrudes the shapes along direction",
    "bitbybit.occt.operations.splitShapeWithShapes": "split shape with shapes",
    "splitShapeWithShapes": "split shape with shapes",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Splits the shape with shapes",
    "divisions": "divisions",
    "localFuzzyTolerance": "local fuzzy tolerance",
    "nonDestructive": "non destructive",
    "bitbybit.occt.operations.revolve": "revolve",
    "revolve": "revolve",
    "bitbybit.occt.operations.revolve_description": "Revolves the shape around the given direction",
    "revolutions": "revolutions",
    "copy": "copy",
    "bitbybit.occt.operations.rotatedExtrude": "rotated extrude",
    "rotatedExtrude": "rotated extrude",
    "bitbybit.occt.operations.rotatedExtrude_description": "Rotated extrude that is perofrmed on the shape",
    "bitbybit.occt.operations.pipe": "pipe",
    "pipe": "pipe",
    "bitbybit.occt.operations.pipe_description": "Pipe shapes along the wire",
    "pipeing": "piping",
    "bitbybit.occt.operations.pipePolylineWireNGon": "pipe polyline wire ngon",
    "pipePolylineWireNGon": "pipe polyline wire ngon",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Pipes polyline wire with ngon profile.",
    "trihedronEnum": "trihedron enum",
    "geomFillTrihedronEnum": "geom fill trihedron enum",
    "forceApproxC1": "force approx c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "pipe wires cylindrical",
    "pipeWiresCylindrical": "pipe wires cylindrical",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Pipe wires with cylindrical shape",
    "bitbybit.occt.operations.pipeWireCylindrical": "pipe wire cylindrical",
    "pipeWireCylindrical": "pipe wire cylindrical",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Pipe wire with cylindrical shape",
    "bitbybit.occt.operations.offset": "offset",
    "bitbybit.occt.operations.offset_description": "Offset for various shapes",
    "offsets": "offsets",
    "bitbybit.occt.operations.offsetAdv": "offset advanced",
    "offsetAdv": "offset advanced",
    "bitbybit.occt.operations.offsetAdv_description": "Offset advanced that give more options for offset, such as joinType for edges and corners",
    "joinType": "join type",
    "joinTypeEnum": "join type enum",
    "removeIntEdges": "remove int edges",
    "bitbybit.occt.operations.makeThickSolidSimple": "make thick solid simple",
    "makeThickSolidSimple": "make thick solid simple",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Thickens the shape into a solid by an offset distance",
    "bitbybit.occt.operations.makeThickSolidByJoin": "make thick solid by join",
    "makeThickSolidByJoin": "make thick solid by join",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Thickens the shape into a solid by joining",
    "intersection": "intersection",
    "selfIntersection": "self intersection",
    "bitbybit.occt.operations.slice": "slice",
    "slice": "slice",
    "bitbybit.occt.operations.slice_description": "Slices the shape",
    "bitbybit.occt.operations.sliceInStepPattern": "slice in step pattern",
    "sliceInStepPattern": "slice in step pattern",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Slices the shape in step pattern",
    "steps": "steps",
    "bitbybit.occt.operations.offset3DWire": "offset 3d wire",
    "offset3DWire": "offset 3d wire",
    "bitbybit.occt.operations.offset3DWire_description": "Offset the 3D wire. When using this method consider using it on filleted wires that do not contain sharp corners. You can use fillet 3D on it.",
    "bitbybit.occt.booleans.union": "union",
    "booleans": "booleans",
    "union": "union",
    "bitbybit.occt.booleans.union_description": "Joins separate objects",
    "keepEdges": "keep edges",
    "bitbybit.occt.booleans.difference": "difference",
    "difference": "difference",
    "bitbybit.occt.booleans.difference_description": "Does boolean difference operation between a main shape and given shapes",
    "bitbybit.occt.booleans.intersection": "intersection",
    "bitbybit.occt.booleans.intersection_description": "Does boolean intersection operation between a main shape and given shapes",
    "bitbybit.occt.shapeFix.basicShapeRepair": "basic shape repair",
    "shapeFix": "shape fix",
    "basicShapeRepair": "basic shape repair",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Performs the basic shape repair",
    "maxTolerance": "max tolerance",
    "minTolerance": "min tolerance",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "fix small edge on wire",
    "fixSmallEdgeOnWire": "fix small edge on wire",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Fix small edge on wire",
    "lockvtx": "lock vtx",
    "precsmall": "prec small",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "fix edge orientations along wire",
    "fixEdgeOrientationsAlongWire": "fix edge orientations along wire",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Fix edge orientations along wire",
    "bitbybit.occt.io.saveShapeSTEP": "save shape step",
    "saveShapeSTEP": "save shape step",
    "bitbybit.occt.io.saveShapeSTEP_description": "Saves the step file",
    "adjustYtoZ": "adjust y to z",
    "tryDownload": "try download",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "save shape step and return",
    "saveShapeSTEPAndReturn": "save shape step and return",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Saves the step file and returns the text value",
    "bitbybit.occt.io.saveShapeStl": "save shape stl",
    "saveShapeStl": "save shape stl",
    "bitbybit.occt.io.saveShapeStl_description": "Saves the stl file",
    "binary": "binary",
    "bitbybit.occt.io.saveShapeStlAndReturn": "save shape stl and return",
    "saveShapeStlAndReturn": "save shape stl and return",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Saves the stl file and returns",
    "bitbybit.occt.io.loadSTEPorIGES": "load step or iges",
    "loadSTEPorIGES": "load step or iges",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Imports the step or iges asset file",
    "adjustZtoY": "adjust z to y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "load step or iges from text",
    "loadSTEPorIGESFromText": "load step or iges from text",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Imports the step or iges asset file from text",
    "fileType": "file type",
    "fileTypeEnum": "file type enum",
    "bitbybit.advanced.text3d.create": "text 3d",
    "advanced": "advanced",
    "text3d": "text 3d",
    "bitbybit.advanced.text3d.create_description": "Creates a 3d text",
    "fontType": "font type",
    "fontsEnum": "fonts enum",
    "fontVariant": "font variant",
    "fontVariantsEnum": "font variants enum",
    "Inputs.Base.Vector3": "inputs base vector 3",
    "originAlignment": "origin alignment",
    "recAlignmentEnum": "rec alignment enum",
    "bitbybit.advanced.text3d.createTextOnFace": "text on face",
    "createTextOnFace": "text on face",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Creates a 3d text on the face",
    "facePlanar": "face planar",
    "faceTextVar": "face text var",
    "faceTextVarEnum": "face text var enum",
    "originParamU": "origin param u",
    "originParamV": "origin param v",
    "bitbybit.advanced.text3d.createTextsOnFace": "texts on face",
    "createTextsOnFace": "texts on face",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Creates 3d texts on the face from multiple definitions",
    "definitions": "definitions",
    "Text3DFaceDefinitionDto[]": "text 3d face definition dto array",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "definition 3d text on face",
    "definition3dTextOnFace": "definition 3d text on face",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Creates 3d text that will be used on the face defintion",
    "bitbybit.advanced.text3d.getCompoundShape": "get compound shape",
    "getCompoundShape": "get compound shape",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Gets compounded shape of the 3d text result",
    "model": "model",
    "Text3DData<T>": "text 3d data t",
    "bitbybit.advanced.text3d.getCharacterShape": "get character shape",
    "getCharacterShape": "get character shape",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Gets the character shape at particular index",
    "bitbybit.advanced.text3d.getCharacterShapes": "get character shapes",
    "getCharacterShapes": "get character shapes",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Gets character shapes of the 3d text result",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "get character center coordinates",
    "getCharacterCenterCoordinates": "get character center coordinates",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Gets the center of mass coordinates of all characters",
    "bitbybit.advanced.text3d.getFaceCutout": "get face cutout",
    "getFaceCutout": "get face cutout",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Gets the face cutout from text 3d that was created on the face",
    "get from face": "get from face",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "get all faces of cutout",
    "getAllFacesOfCutout": "get all faces of cutout",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Gets all of the face cutouts from text 3d that was created on the original face",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "get cutouts inside characters",
    "getCutoutsInsideCharacters": "get cutouts inside characters",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Gets character face cutouts from text 3d that was created on the original face",
    "bitbybit.advanced.text3d.getAdvanceWidth": "get advance width",
    "getAdvanceWidth": "get advance width",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Get advance width",
    "dimensions": "dimensions",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pyramid simple",
    "facePatterns": "face patterns",
    "pyramidSimple": "pyramid simple",
    "createPyramidSimple": "pyramid simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Creates a simple pyramid pattern on faces",
    "uNumber": "u number",
    "vNumber": "v number",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "pyramid simple affectors",
    "createPyramidSimpleAffectors": "pyramid simple affectors",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Creates a simple pyramid pattern on faces with affectors that change the height",
    "affectorPoints": "affector points",
    "Inputs.Base.Point3[]": "inputs base point 3 array",
    "affectorRadiusList": "affector radius list",
    "affectorFactors": "affector factors",
    "defaultHeight": "default height",
    "affectMinHeight": "affect min height",
    "affectMaxHeight": "affect max height",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "get compound shape",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Gets the compound shape of all the pyramids",
    "get shapes": "get shapes",
    "PyramidSimpleData<T>": "pyramid simple data t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "get compound shape on face",
    "getCompoundShapeOnFace": "get compound shape on face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Gets the compound shape on the face",
    "faceIndex": "face index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "get compound shape cell on face",
    "getCompoundShapeCellOnFace": "get compound shape cell on face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Gets the compound shape of the pyramid on the face at particular index",
    "uIndex": "u index",
    "vIndex": "v index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "get all pyramid cells",
    "getAllPyramidCells": "get all pyramid cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Gets all of the pyramid cells. This is usually in between action to then read particular information of the cells themselves.",
    "get cells": "get cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "get all pyramid cells on face",
    "getAllPyramidCellsOnFace": "get all pyramid cells on face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Gets pyramid cells on the face. This is usually in between action to then read particular information of the cells themselves.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "get all pyramid u cells on face",
    "getAllPyramidUCellsOnFace": "get all pyramid u cells on face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Gets pyramid cells on the face. This is usually in between action to then read particular information of the cells themselves.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "get all pyramid u cells on face at u",
    "getAllPyramidUCellsOnFaceAtU": "get all pyramid u cells on face at u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Gets pyramid cells on the face at u index along v direction. This is usually in between action to then read particular information of the cells themselves.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "get all pyramid u cells on face at v",
    "getAllPyramidUCellsOnFaceAtV": "get all pyramid u cells on face at v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Gets pyramid cells on the face at v index along u direction. This is usually in between action to then read particular information of the cells themselves.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "get cell on index",
    "getCellOnIndex": "get cell on index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Gets pyramid cell on the face at u and v index. This is usually in between action to then read particular information of the cell itself.",
    "get cell": "get cell",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "get top points of cells",
    "getTopPointsOfCells": "get top points of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Gets the top points of cells",
    "get from cells": "get from cells",
    "cells": "cells",
    "PyramidSimpleCellPart<T>[]": "pyramid simple cell part t array",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "get center points of cells",
    "getCenterPointsOfCells": "get center points of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Gets the center point between cell corners",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "get corner points of cells",
    "getCornerPointsOfCells": "get corner points of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Gets the corner points of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "get corner point of cells",
    "getCornerPointOfCells": "get corner point of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Gets the corner points of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "get corner normal of cells",
    "getCornerNormalOfCells": "get corner normal of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Gets the corner normal of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "get corner normals of cells",
    "getCornerNormalsOfCells": "get corner normals of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Gets the corner normals of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "get compound shapes of cells",
    "getCompoundShapesOfCells": "get compound shapes of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Gets the compound shapes of the pyramid cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "get face shapes of cells",
    "getFaceShapesOfCells": "get face shapes of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Gets the face shapes of the pyramid cells provided",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "get wire shapes of cells",
    "getWireShapesOfCells": "get wire shapes of cells",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Gets the face shapes of the pyramid cells provided",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "get start polyline wire u",
    "getStartPolylineWireU": "get start polyline wire u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Gets the polyline wire along the start edge of the face's U direction",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "get end polyline wire u",
    "getEndPolylineWireU": "get end polyline wire u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Gets the polyline wire along the end edge of the face's U direction",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "get start polyline wire v",
    "getStartPolylineWireV": "get start polyline wire v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Gets the polyline wire along the start edge of the face's V direction",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "get end polyline wire v",
    "getEndPolylineWireV": "get end polyline wire v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Gets the polyline wire along the end edge of the face's V direction",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "get polyline wires u compound",
    "getPolylineWiresUCompound": "get polyline wires u compound",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Gets the polyline wires along U direction",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "get polyline wires v compound",
    "getPolylineWiresVCompound": "get polyline wires v compound",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Gets the polyline wires along V direction",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "wingtip villa",
    "things": "things",
    "kidsCorner": "kids corner",
    "birdhouses": "birdhouses",
    "wingtipVilla": "wingtip villa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Creates a wingtip villa birdhouse with a 45 degree roof",
    "birdhouse": "birdhouse",
    "interiorWidth": "interior width",
    "interiorLength": "interior length",
    "interiorHeight": "interior height",
    "holeDiameter": "hole diameter",
    "holeDistToBottom": "hole dist to bottom",
    "stickLength": "stick length",
    "stickDiameter": "stick diameter",
    "baseAttachmentHeight": "base attachment height",
    "roofOverhang": "roof overhang",
    "chimneyHeight": "chimney height",
    "Inputs.Base.Point3": "inputs base point 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chirpy chalet",
    "chirpyChalet": "chirpy chalet",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Creates a chirpy chalet birdhouse with a 45 degree roof",
    "roofAngle": "roof angle",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "serenity swirl",
    "threeDPrinting": "3D printing",
    "vases": "vases",
    "serenitySwirl": "serenity swirl",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Creates a serenity swirl",
    "swirl": "swirl",
    "addRadiusNarrow": "add radius narrow",
    "addRadiusWide": "add radius wide",
    "addMiddleHeight": "add middle height",
    "addTopHeight": "add top height",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arabic archway",
    "arabicArchway": "arabic archway",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Creates a arabic archway vase",
    "profilePoints": "profile points",
    "nrOfSides": "nr of sides",
    "nrOfVerticalArches": "nr of vertical arches",
    "archCenterThickness": "arch center thickness",
    "edgesThickness": "edges thickness",
    "baseHeight": "base height",
    "patchHoles": "patch holes",
    "lod": "lod",
    "Things.Enums.lodEnum": "things enums lod enum",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "eternal love",
    "medals": "medals",
    "eternalLove": "eternal love",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Creates a eternal love medal model",
    "textHeading": "text heading",
    "textName": "text name",
    "fullModel": "full model",
    "decorationThickness": "decoration thickness",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "calm cup",
    "cups": "cups",
    "calmCup": "calm cup",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Creates a cup model for your calm moments",
    "radiusTopOffset": "radius top offset",
    "fillet": "fillet",
    "nrOfHandles": "nr of handles",
    "handleDist": "handle dist",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "dragon cup",
    "dragonCup": "dragon cup",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Creates a cup model for your inner dragon",
    "radiusMidOffset": "radius mid offset",
    "rotationTopAngle": "rotation top angle",
    "rotationMidAngle": "rotation mid angle",
    "nrSkinCellsVertical": "nr skin cells vertical",
    "nrSkinCellsHorizontal": "nr skin cells horizontal",
    "nrSkinCellDivisionsTop": "nr skin cell divisions top",
    "nrSkinCellDivisionsBottom": "nr skin cell divisions bottom",
    "skinCellOuterHeight": "skin cell outer height",
    "skinCellInnerHeight": "skin cell inner height",
    "skinCellBottomHeight": "skin cell bottom height",
    "skinCellTopHeight": "skin cell top height",
    "bottomThickness": "bottom thickness",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "get compound shape",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Gets the compound shape of the dragon cup",
    "DragonCupData<T>": "dragon cup data t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "phone nest",
    "desktop": "desktop",
    "phoneNest": "phone nest",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Creates a phone nest model",
    "heightBottom": "height bottom",
    "heightTop": "height top",
    "widthBack": "width back",
    "widthFront": "width front",
    "backOffset": "back offset",
    "applyOrnaments": "apply ornaments",
    "filletRadius": "fillet radius",
    "phoneHeight": "phone height",
    "phoneWidth": "phone width",
    "phoneThickness": "phone thickness",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "get compound shape",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Gets the compound shape of the phone nest",
    "PhoneNestData<T>": "phone nest data t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "draw options",
    "drawOptions": "draw options",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "creates draw options for model",
    "mainMaterial": "main material",
    "phoneMaterial": "phone material",
    "Inputs.Base.Color": "inputs base color",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "droplets phone holder",
    "laserCutting": "laser cutting",
    "gadgets": "gadgets",
    "dropletsPhoneHolder": "droplets phone holder",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "creates droplets phone holder",
    "title": "title",
    "subtitle": "subtitle",
    "includeLogo": "include logo",
    "kerf": "kerf",
    "backLength": "back length",
    "offsetAroundPhone": "offset around phone",
    "penShelf": "pen shelf",
    "phoneLockHeight": "phone lock height",
    "includePattern": "include pattern",
    "densityPattern": "density pattern",
    "holesForWire": "holes for wire",
    "wireInputThickness": "wire input thickness",
    "includeModel": "include model",
    "includeDrawings": "include drawings",
    "spacingDrawings": "spacing drawings",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "get compound shape",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Gets the compound shape of the droplets phone holder",
    "DropletsPhoneHolderData<T>": "droplets phone holder data t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "get cut wires compound",
    "getCutWiresCompound": "get cut wires compound",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Gets the cut wires compound",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "get engraving wires compound",
    "getEngravingWiresCompound": "get engraving wires compound",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Gets the engraving wires compound",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "download dxf drawings",
    "downloadDXFDrawings": "download dxf drawings",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "downloads dxf drawing",
    "download": "download",
    "cutWiresColor": "cut wires color",
    "engravingWiresColor": "engraving wires color",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "download step drawings",
    "downloadSTEPDrawings": "download step drawings",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "downloads step drawing",
    "adjustYZ": "adjust yz",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "download 3d step model",
    "download3dSTEPModel": "download 3d step model",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "downloads step 3d model",
    "bitbybit.things.architecture.houses.zenHideout.create": "zen hideout",
    "architecture": "architecture",
    "houses": "houses",
    "zenHideout": "zen hideout",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Creates a zen hideout",
    "widthFirstWing": "width first wing",
    "lengthFirstWing": "length first wing",
    "terraceWidth": "terrace width",
    "widthSecondWing": "width second wing",
    "lengthSecondWing": "length second wing",
    "heightWalls": "height walls",
    "roofAngleFirstWing": "roof angle first wing",
    "roofAngleSecondWing": "roof angle second wing",
    "roofOffset": "roof offset",
    "roofInsideOverhang": "roof inside overhang",
    "roofMaxDistAttachmentBeams": "roof max dist attachment beams",
    "roofAttachmentBeamWidth": "roof attachment beam width",
    "roofAttachmentBeamHeight": "roof attachment beam height",
    "roofOutsideOverhang": "roof outside overhang",
    "columnSize": "column size",
    "ceilingBeamHeight": "ceiling beam height",
    "ceilingBeamWidth": "ceiling beam width",
    "nrCeilingBeamsBetweenColumns": "nr ceiling beams between columns",
    "distBetweenColumns": "dist between columns",
    "floorHeight": "floor height",
    "groundLevel": "ground level",
    "facadePanelThickness": "facade panel thickness",
    "windowWidthOffset": "window width offset",
    "windowHeightOffset": "window height offset",
    "windowFrameThickness": "window frame thickness",
    "windowGlassFrameThickness": "window glass frame thickness",
    "skinOpacity": "skin opacity",
    "bitbybit.things.furniture.chairs.snakeChair.create": "snake chair",
    "furniture": "furniture",
    "chairs": "chairs",
    "snakeChair": "snake chair",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Creates a snake chair model",
    "sittingHeight": "sitting height",
    "backRestOffset": "back rest offset",
    "backRestHeight": "back rest height",
    "nrOrnamentPlanks": "nr ornament planks",
    "ornamentDepth": "ornament depth",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "get compound shape",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Gets the compound shape of the chair",
    "SnakeChairData<T>": "snake chair data t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "get sitting wire shape",
    "getSittingWireShape": "get sitting wire shape",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Gets the wire shape of the chair sitting area",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "get sitting area center point",
    "getSittingAreaCenterPoint": "get sitting area center point",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Gets the center point of the chair sitting area",
    "get points": "get points",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "draw options",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "creates draw options for snake chair",
    "bitbybit.things.furniture.tables.elegantTable.create": "elegant table",
    "tables": "tables",
    "elegantTable": "elegant table",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Creates an elegant table model",
    "topThickness": "top thickness",
    "topOffset": "top offset",
    "minFillet": "min fillet",
    "radiusLegTop": "radius leg top",
    "radiusLegBottom": "radius leg bottom",
    "nrLegPairs": "nr leg pairs",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "get compound shape",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Gets the compound shape of the table",
    "ElegantTableData<T>": "elegant table data t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "get leg shapes",
    "getLegShapes": "get leg shapes",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Gets the leg shapes as a list",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "get leg shape by index",
    "getLegShapeByIndex": "get leg shape by index",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Gets the leg shape by index",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "get top panel shape",
    "getTopPanelShape": "get top panel shape",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Gets the table top panel shape",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "get top panel wire shape",
    "getTopPanelWireShape": "get top panel wire shape",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Gets the table top panel wire shape",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "get bottom panel wire shape",
    "getBottomPanelWireShape": "get bottom panel wire shape",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Gets the table bottom panel wire shape",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "get bottom panel shape",
    "getBottomPanelShape": "get bottom panel shape",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Gets the table bottom panel shape",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "get legs compound shape",
    "getLegsCompoundShape": "get legs compound shape",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Gets the leg shapes as a compound shape",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "get table top center point",
    "getTableTopCenterPoint": "get table top center point",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Gets the top center point",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "get table bottom center point",
    "getTableBottomCenterPoint": "get table bottom center point",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Gets the bottom center point",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "get leg bottom points",
    "getLegBottomPoints": "get leg bottom points",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Gets the leg bottom points",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "get leg top points",
    "getLegTopPoints": "get leg top points",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Gets the leg top points",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "draw options",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "creates draw options for elegant table",
    "topMaterial": "top material",
    "topBaseMaterial": "top base material",
    "legsMaterial": "legs material",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "good coffee table",
    "goodCoffeeTable": "good coffee table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Creates an good coffee table model",
    "chamfer": "chamfer",
    "topGlassOffset": "top glass offset",
    "glassThickness": "glass thickness",
    "glassHolderLength": "glass holder length",
    "shelfTopOffset": "shelf top offset",
    "shelfThickness": "shelf thickness",
    "legWidth": "leg width",
    "legDepth": "leg depth",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "get compound shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Gets the compound shape of the table",
    "GoodCoffeeTableData<T>": "good coffee table data t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "get leg shapes",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Gets the leg shapes as a list",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "get leg shape by index",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Gets the leg shape by index",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "get top panel shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Gets the table top panel shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "get top panel wire shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Gets the table top panel wire shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "get glass panel shape",
    "getGlassPanelShape": "get glass panel shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Gets the table glass panel shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "get glass panel wire shape",
    "getGlassPanelWireShape": "get glass panel wire shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Gets the table glass panel wire shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "get shelf shape",
    "getShelfShape": "get shelf shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Gets the table shelf shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "get shelf top wire shape",
    "getShelfTopWireShape": "get shelf top wire shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Gets the table shelf top wire shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "get legs compound shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Gets the leg shapes as a compound shape",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "get table top center point",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Gets the top center point",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "get table shelf top center point",
    "getTableShelfTopCenterPoint": "get table shelf top center point",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Gets the top center point of the shelf",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "get leg bottom points",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Gets the leg bottom points",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "get leg top points",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Gets the leg top points",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "draw options",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "creates draw options for good coffee table",
    "topGlassMaterial": "top glass material",
    "shelfMaterial": "shelf material",
    "bitbybit.things.furniture.tables.snakeTable.create": "snake table",
    "snakeTable": "snake table",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Creates a snake table model",
    "supportLength": "support length",
    "shelfHeight": "shelf height",
    "glassOffset": "glass offset",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "get compound shape",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Gets the compound shape of the table",
    "SnakeTableData<T>": "snake table data t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "get glass shape",
    "getGlassShape": "get glass shape",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Gets the glass shape of the table",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "get main shape",
    "getMainShape": "get main shape",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Gets the main solid shape of the table",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "get top center point",
    "getTopCenterPoint": "get top center point",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Gets the center point of the table top",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "draw options",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "creates draw options for snake table",
    "glassMaterial": "glass material",
    "bitbybit.things.enums.lodEnum": "lod enum",
    "enums": "enums",
    "lodEnum": "lod enum",
    "bitbybit.things.enums.lodEnum_description": "Creates a level of detail enumeration value",
    "bitbybit.jscad.transformSolids": "transform solids",
    "jscad": "jscad",
    "transformSolids": "transform solids",
    "bitbybit.jscad.transformSolids_description": "Transforms the Jscad solid meshes with a given list of transformations.",
    "JSCADEntity[]": "jscad entity array",
    "bitbybit.jscad.transformSolid": "transform solid",
    "transformSolid": "transform solid",
    "bitbybit.jscad.transformSolid_description": "Transforms the Jscad solid mesh with a given list of transformations.",
    "JSCADEntity": "jscad entity",
    "bitbybit.jscad.downloadSolidSTL": "download solid stl",
    "downloadSolidSTL": "download solid stl",
    "bitbybit.jscad.downloadSolidSTL_description": "Downloads the binary STL file from a 3D solid",
    "bitbybit.jscad.downloadSolidsSTL": "download solids stl",
    "downloadSolidsSTL": "download solids stl",
    "bitbybit.jscad.downloadSolidsSTL_description": "Downloads the binary STL file from a 3D solids",
    "bitbybit.jscad.downloadGeometryDxf": "download geometry dxf",
    "downloadGeometryDxf": "download geometry dxf",
    "bitbybit.jscad.downloadGeometryDxf_description": "Downloads the dxf file from jscad geometry. Supports paths and meshes in array.",
    "geometry": "geometry",
    "JSCADEntity | JSCADEntity[]": "jscad entity or array",
    "bitbybit.jscad.downloadGeometry3MF": "download geometry 3mf",
    "downloadGeometry3MF": "download geometry 3mf",
    "bitbybit.jscad.downloadGeometry3MF_description": "Downloads the 3MF file from jscad geometry.",
    "bitbybit.jscad.booleans.intersect": "intersect",
    "intersect": "intersect",
    "bitbybit.jscad.booleans.intersect_description": "Intersect multiple solid mesh objects",
    "bitbybit.jscad.booleans.subtract": "subtract",
    "subtract": "subtract",
    "bitbybit.jscad.booleans.subtract_description": "Subtract multiple solid mesh objects",
    "bitbybit.jscad.booleans.union": "union",
    "bitbybit.jscad.booleans.union_description": "Union multiple solid mesh objects",
    "bitbybit.jscad.booleans.intersectTwo": "intersect two",
    "intersectTwo": "intersect two",
    "bitbybit.jscad.booleans.intersectTwo_description": "Intersect two solid mesh objects",
    "bitbybit.jscad.booleans.subtractTwo": "subtract two",
    "subtractTwo": "subtract two",
    "bitbybit.jscad.booleans.subtractTwo_description": "Subtract two solid mesh objects",
    "bitbybit.jscad.booleans.unionTwo": "union two",
    "unionTwo": "union two",
    "bitbybit.jscad.booleans.unionTwo_description": "Union two solid mesh objects",
    "bitbybit.jscad.booleans.subtractFrom": "subtract from",
    "subtractFrom": "subtract from",
    "bitbybit.jscad.booleans.subtractFrom_description": "Subtract multiple meshes from one mesh object",
    "bitbybit.jscad.expansions.expand": "expand",
    "expansions": "expansions",
    "expand": "expand",
    "bitbybit.jscad.expansions.expand_description": "Expand geometries of solid category",
    "expansion": "expansion",
    "delta": "delta",
    "corners": "corners",
    "solidCornerTypeEnum": "solid corner type enum",
    "bitbybit.jscad.expansions.offset": "offset",
    "bitbybit.jscad.expansions.offset_description": "Offset 2d geometries of solid category",
    "bitbybit.jscad.extrusions.extrudeLinear": "extrude linear",
    "extrudeLinear": "extrude linear",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Linear extrude 2D geometries of solid category",
    "twistAngle": "twist angle",
    "twistSteps": "twist steps",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extrude rectangular",
    "extrudeRectangular": "extrude rectangular",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Rectangular extrude 2D geometries of solid category. Creates a wall-type extrusion of certain height and size.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extrude rectangular points",
    "extrudeRectangularPoints": "extrude rectangular points",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Rectangular extrude a list of 2D points. Creates a wall-type extrusion of certain height and size.",
    "bitbybit.jscad.extrusions.extrudeRotate": "extrude rotate",
    "extrudeRotate": "extrude rotate",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Rectangular extrude a list of 2D points. Creates a wall-type extrusion of certain height and size.",
    "polygon": "polygon",
    "startAngle": "start angle",
    "bitbybit.jscad.hulls.hullChain": "hull chain",
    "hulls": "hulls",
    "hullChain": "hull chain",
    "bitbybit.jscad.hulls.hullChain_description": "Hull chain connects solids or 2d geometries by filling an empty space in between objects in order. Geometries need to be of the same type.",
    "bitbybit.jscad.hulls.hull": "hull",
    "hull": "hull",
    "bitbybit.jscad.hulls.hull_description": "Convex hull connects solids or 2d geometries by filling an empty space in between without following order. Geometries need to be of the same type.",
    "bitbybit.jscad.path.createFromPoints": "from points",
    "createFromPoints": "from points",
    "bitbybit.jscad.path.createFromPoints_description": "Create a 2D path from a list of points",
    "Base.Point2[]": "base point 2 array",
    "bitbybit.jscad.path.createPathsFromPoints": "paths from points",
    "createPathsFromPoints": "paths from points",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Create 2D paths from a lists of points",
    "pointsLists": "points lists",
    "Base.Point3[][] | Base.Point2[][]": "base point 3 or 2 array",
    "bitbybit.jscad.path.createFromPolyline": "from polyline",
    "createFromPolyline": "from polyline",
    "bitbybit.jscad.path.createFromPolyline_description": "Create a 2D path from a polyline",
    "bitbybit.jscad.path.createEmpty": "empty",
    "createEmpty": "empty",
    "bitbybit.jscad.path.createEmpty_description": "Create empty 2D path",
    "bitbybit.jscad.path.close": "close",
    "close": "close",
    "bitbybit.jscad.path.close_description": "Closes an open 2D path",
    "bitbybit.jscad.path.appendPoints": "append points",
    "appendPoints": "append points",
    "bitbybit.jscad.path.appendPoints_description": "Append the path with 2D points",
    "append": "append",
    "bitbybit.jscad.path.appendPolyline": "append polyline",
    "appendPolyline": "append polyline",
    "bitbybit.jscad.path.appendPolyline_description": "Append the path with polyline",
    "bitbybit.jscad.path.appendArc": "append arc",
    "appendArc": "append arc",
    "bitbybit.jscad.path.appendArc_description": "Append the arc to the path",
    "xAxisRotation": "x axis rotation",
    "clockwise": "clockwise",
    "large": "large",
    "bitbybit.jscad.polygon.createFromPoints": "from points",
    "bitbybit.jscad.polygon.createFromPoints_description": "Create a 2D polygon from a list of points",
    "bitbybit.jscad.polygon.createFromPolyline": "from polyline",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Create a 2D polygon from a polyline",
    "bitbybit.jscad.polygon.createFromCurve": "from curve",
    "createFromCurve": "from curve",
    "bitbybit.jscad.polygon.createFromCurve_description": "Create a 2D polygon from a curve",
    "bitbybit.jscad.polygon.createFromPath": "from path",
    "createFromPath": "from path",
    "bitbybit.jscad.polygon.createFromPath_description": "Create a 2D polygon from a path",
    "bitbybit.jscad.polygon.circle": "circle",
    "bitbybit.jscad.polygon.circle_description": "Create a 2D polygon circle",
    "bitbybit.jscad.polygon.ellipse": "ellipse",
    "ellipse": "ellipse",
    "bitbybit.jscad.polygon.ellipse_description": "Create a 2D polygon ellipse",
    "bitbybit.jscad.polygon.rectangle": "rectangle",
    "rectangle": "rectangle",
    "bitbybit.jscad.polygon.rectangle_description": "Create a 2D polygon rectangle",
    "bitbybit.jscad.polygon.roundedRectangle": "rounded rectangle",
    "roundedRectangle": "rounded rectangle",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Create a 2D rounded rectangle",
    "roundRadius": "round radius",
    "bitbybit.jscad.polygon.square": "square",
    "square": "square",
    "bitbybit.jscad.polygon.square_description": "Create a 2D polygon square",
    "bitbybit.jscad.polygon.star": "star",
    "star": "star",
    "bitbybit.jscad.polygon.star_description": "Create a 2D polygon star",
    "vertices": "vertices",
    "bitbybit.jscad.shapes.cube": "cube",
    "cube": "cube",
    "bitbybit.jscad.shapes.cube_description": "Create a 3D cube shape",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubes on center points",
    "cubesOnCenterPoints": "cubes on center points",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Create a 3D cubes on multiple center points",
    "primitives on centers": "primitives on centers",
    "bitbybit.jscad.shapes.cuboid": "cuboid",
    "cuboid": "cuboid",
    "bitbybit.jscad.shapes.cuboid_description": "Create a 3D cuboid shape",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "cuboids on center points",
    "cuboidsOnCenterPoints": "cuboids on center points",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Create a 3D cuboids on multiple center points",
    "bitbybit.jscad.shapes.cylinderElliptic": "cylinder elliptic",
    "cylinderElliptic": "cylinder elliptic",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Create a 3D elliptic cylinder solid",
    "startRadius": "start radius",
    "endRadius": "end radius",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cylinder elliptic on center points",
    "cylinderEllipticOnCenterPoints": "cylinder elliptic on center points",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Create a 3D elliptic cylinders on multiple center points",
    "bitbybit.jscad.shapes.cylinder": "cylinder",
    "cylinder": "cylinder",
    "bitbybit.jscad.shapes.cylinder_description": "Create a 3D cylinder solid",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cylinders on center points",
    "cylindersOnCenterPoints": "cylinders on center points",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Create a 3D cylinders on multiple center points",
    "bitbybit.jscad.shapes.ellipsoid": "ellipsoid",
    "ellipsoid": "ellipsoid",
    "bitbybit.jscad.shapes.ellipsoid_description": "Create a 3D ellipsoid solid",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "ellipsoids on center points",
    "ellipsoidsOnCenterPoints": "ellipsoids on center points",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Create a 3D ellipsoids on multiple center points",
    "bitbybit.jscad.shapes.geodesicSphere": "geodesic sphere",
    "geodesicSphere": "geodesic sphere",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Create a 3D geodesic sphere solid",
    "frequency": "frequency",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "geodesic spheres on center points",
    "geodesicSpheresOnCenterPoints": "geodesic spheres on center points",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Create a 3D geodesic spheres on multiple center points",
    "bitbybit.jscad.shapes.roundedCuboid": "rounded cuboid",
    "roundedCuboid": "rounded cuboid",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Create a 3D rounded cuboid solid",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "rounded cuboids on center points",
    "roundedCuboidsOnCenterPoints": "rounded cuboids on center points",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Create a 3D rounded cuboids on multiple center points",
    "bitbybit.jscad.shapes.roundedCylinder": "rounded cylinder",
    "roundedCylinder": "rounded cylinder",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Create a 3D rounded cylinder solid",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "rounded cylinders on center points",
    "roundedCylindersOnCenterPoints": "rounded cylinders on center points",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Create a 3D rounded cylinders on multiple center points",
    "bitbybit.jscad.shapes.sphere": "sphere",
    "sphere": "sphere",
    "bitbybit.jscad.shapes.sphere_description": "Create a 3D sphere solid",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "spheres on center points",
    "spheresOnCenterPoints": "spheres on center points",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Create a 3D sphere on multiple center points",
    "bitbybit.jscad.shapes.torus": "torus",
    "torus": "torus",
    "bitbybit.jscad.shapes.torus_description": "Create a 3D torus solid",
    "innerSegments": "inner segments",
    "outerSegments": "outer segments",
    "innerRotation": "inner rotation",
    "outerRotation": "outer rotation",
    "bitbybit.jscad.shapes.fromPolygonPoints": "from polygon points",
    "fromPolygonPoints": "from polygon points",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Create a 3D shape from poylgon points that have to be nested arrays of points",
    "polygonPoints": "polygon points",
    "Base.Point3[][]": "base point 3 array",
    "bitbybit.jscad.text.cylindricalText": "cylindrical text",
    "cylindricalText": "cylindrical text",
    "bitbybit.jscad.text.cylindricalText_description": "Creates a text that is based on chain hulling cylinders",
    "extrusionHeight": "extrusion height",
    "extrusionSize": "extrusion size",
    "jscadTextAlignEnum": "jscad text align enum",
    "bitbybit.jscad.text.sphericalText": "spherical text",
    "sphericalText": "spherical text",
    "bitbybit.jscad.text.sphericalText_description": "Creates a text that is based on chain hulling spheres",
    "bitbybit.jscad.text.createVectorText": "vector text",
    "createVectorText": "vector text",
    "bitbybit.jscad.text.createVectorText_description": "Creates a vector text",
    "bitbybit.jscad.colors.colorize": "colorize",
    "colors": "colors",
    "colorize": "colorize",
    "bitbybit.jscad.colors.colorize_description": "Colorizes geometry of jscad. If geometry is in the array it will colorize all items and return them. If geometry is a single item it will return a single item. Keep in mind that colorized geometry in jscad will always be drawn in that color even if you try to change it via draw options.",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold to mesh pointer",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold to mesh pointer",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Turns manifold shape into a mesh pointer that lives in worker's memory. This pointer can be used with bitbybit.manifold.mesh functions",
    "meshing": "meshing",
    "normalIdx": "normal idx",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "decompose manifold or cross section",
    "decomposeManifoldOrCrossSection": "decompose manifold or cross section",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Decomposes manifold or cross section shape into a mesh or simple polygons",
    "decompose": "decompose",
    "manifoldOrCrossSection": "manifold or cross section",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "decompose manifolds or cross sections",
    "decomposeManifoldsOrCrossSections": "decompose manifolds or cross sections",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Decomposes manifold or cross section shape into a mesh or simple polygons",
    "manifoldsOrCrossSections": "manifolds or cross sections",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "delete manifold or cross section",
    "deleteManifoldOrCrossSection": "delete manifold or cross section",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Delete manifold or cross section from memory",
    "cleanup": "cleanup",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "delete manifolds or cross sections",
    "deleteManifoldsOrCrossSections": "delete manifolds or cross sections",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Delete manifolds or cross sections from memory",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold to mesh",
    "manifoldToMesh": "manifold to mesh",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Turns manifold shape into a mesh",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds to meshes",
    "manifoldsToMeshes": "manifolds to meshes",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "turns manifold shapes into meshes",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold from mesh",
    "manifoldFromMesh": "manifold from mesh",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Convert a Mesh into a Manifold, retaining its properties and merging only the positions according to the merge vectors. Will throw an error if the result is not an oriented 2-manifold. Will collapse degenerate triangles and unnecessary vertices. All fields are read, making this structure suitable for a lossless round-trip of data from manifoldToMesh(). For multi-material input, use reserveIDs() to set a unique originalID for each material, and sort the materials into triangle runs.",
    "DecomposedManifoldMeshDto": "decomposed manifold mesh dto",
    "bitbybit.manifold.manifold.shapes.cube": "cube",
    "bitbybit.manifold.manifold.shapes.cube_description": "Create a 3D cube shape",
    "bitbybit.manifold.manifold.shapes.sphere": "sphere",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Create a 3D sphere shape",
    "circularSegments": "circular segments",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tetrahedron",
    "tetrahedron": "tetrahedron",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Create a 3D tetrahedron shape",
    "bitbybit.manifold.manifold.shapes.cylinder": "cylinder",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Create a 3D cylinder shape",
    "radiusLow": "radius low",
    "radiusHigh": "radius high",
    "bitbybit.manifold.manifold.booleans.subtract": "subtract",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Subtract two manifold shapes",
    "a to b": "a to b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "add",
    "bitbybit.manifold.manifold.booleans.add_description": "Add two manifold shapes",
    "bitbybit.manifold.manifold.booleans.intersect": "intersect",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Intersect two manifold shapes",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "difference two",
    "differenceTwo": "difference two",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "difference of two manifold shapes",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "union two",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "union of two manifold shapes",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "intersection two",
    "intersectionTwo": "intersection two",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "intersection of two manifold shapes",
    "bitbybit.manifold.manifold.booleans.difference": "difference",
    "bitbybit.manifold.manifold.booleans.difference_description": "difference of multiple manifold shapes",
    "bitbybit.manifold.manifold.booleans.union": "union",
    "bitbybit.manifold.manifold.booleans.union_description": "union of multiple manifold shapes",
    "bitbybit.manifold.manifold.booleans.intersection": "intersection",
    "bitbybit.manifold.manifold.booleans.intersection_description": "intersection of multiple manifold shapes",
    "bitbybit.manifold.manifold.booleans.split": "split",
    "split": "split",
    "bitbybit.manifold.manifold.booleans.split_description": "Split manifold by another manifold",
    "manifoldToSplit": "manifold to split",
    "manifoldCutter": "manifold cutter",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "split by plane",
    "splitByPlane": "split by plane",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Split manifold by plane",
    "originOffset": "origin offset",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "split by plane on offsets",
    "splitByPlaneOnOffsets": "split by plane on offsets",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Split manifold by plane on various offsets",
    "originOffsets": "origin offsets",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "trim by plane",
    "trimByPlane": "trim by plane",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Trim manifold by plane",
    "trim": "trim",
    "bitbybit.manifold.manifold.operations.hull": "hull",
    "bitbybit.manifold.manifold.operations.hull_description": "Computes convex hull of the manifold shape provided",
    "bitbybit.manifold.manifold.operations.hullPoints": "hull points",
    "hullPoints": "hull points",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Hull points or manifolds",
    "bitbybit.manifold.manifold.operations.slice": "slice",
    "bitbybit.manifold.manifold.operations.slice_description": "Returns the cross section of this object parallel to the X-Y plane at the specified height. Using a height equal to the bottom of the bounding box will return the bottom faces, while using a height equal to the top of the bounding box will return empty.",
    "cross sections": "cross sections",
    "bitbybit.manifold.manifold.operations.project": "project",
    "bitbybit.manifold.manifold.operations.project_description": "Creates a projection on xy plane from the shape outline",
    "bitbybit.manifold.manifold.operations.setTolerance": "set tolerance",
    "setTolerance": "set tolerance",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Return a copy of the manifold with the set tolerance value. This performs mesh simplification when the tolerance value is increased.",
    "basic": "basic",
    "bitbybit.manifold.manifold.operations.reserveIds": "reserve ids",
    "reserveIds": "reserve ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Returns the first of n sequential new unique mesh IDs for marking sets of triangles that can be looked up after further operations. Assign to Mesh.runOriginalID vector.",
    "count": "count",
    "bitbybit.manifold.manifold.operations.asOriginal": "as original",
    "asOriginal": "as original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "If you copy a manifold, but you want this new copy to have new properties (e.g. a different UV mapping), you can reset its IDs to a new original, meaning it will now be referenced by its descendants instead of the meshes it was built from, allowing you to differentiate the copies when applying your properties to the final result. This function also condenses all coplanar faces in the relation, and collapses those edges. If you want to have inconsistent properties across these faces, meaning you want to preserve some of these edges, you should instead call GetMesh(), calculate your properties and use these to construct a new manifold.",
    "bitbybit.manifold.manifold.operations.compose": "compose",
    "compose": "compose",
    "bitbybit.manifold.manifold.operations.compose_description": "Constructs a new manifold from a list of other manifolds. This is a purely topological operation, so care should be taken to avoid creating overlapping results. It is the inverse operation of Decompose().",
    "composition": "composition",
    "bitbybit.manifold.manifold.operations.decompose": "decompose",
    "bitbybit.manifold.manifold.operations.decompose_description": "This operation returns a vector of Manifolds that are topologically disconnected. If everything is connected, the vector is length one, containing a copy of the original. It is the inverse operation of Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calculate normals",
    "calculateNormals": "calculate normals",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Fills in vertex properties for normal vectors, calculated from the mesh geometry. Flat faces composed of three or more triangles will remain flat.",
    "adjustments": "adjustments",
    "minSharpAngle": "min sharp angle",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calculate curvature",
    "calculateCurvature": "calculate curvature",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "Curvature is the inverse of the radius of curvature, and signed such that positive is convex and negative is concave. There are two orthogonal principal curvatures at any point on a manifold, with one maximum and the other minimum. Gaussian curvature is their product, while mean curvature is their sum. This approximates them for every vertex and assigns them as vertex properties on the given channels.",
    "gaussianIdx": "gaussian idx",
    "meanIdx": "mean idx",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "refine to tolerance",
    "refineToTolerance": "refine to tolerance",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Increase the density of the mesh by splitting each edge into pieces such that any point on the resulting triangles is roughly within tolerance of the smoothly curved surface defined by the tangent vectors. This means tightly curving regions will be divided more finely than smoother regions. If halfedgeTangents are not present, the result will simply be a copy of the original. Quads will ignore their interior triangle bisector.",
    "bitbybit.manifold.manifold.operations.refineToLength": "refine to length",
    "refineToLength": "refine to length",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Increase the density of the mesh by splitting each edge into pieces of roughly the input length. Interior verts are added to keep the rest of the triangulation edges also of roughly the same length. If halfedgeTangents are present (e.g. from the Smooth() constructor), the new vertices will be moved to the interpolated surface according to their barycentric coordinates.",
    "bitbybit.manifold.manifold.operations.refine": "refine",
    "refine": "refine",
    "bitbybit.manifold.manifold.operations.refine_description": "Increase the density of the mesh by splitting every edge into n pieces. For instance, with n = 2, each triangle will be split into 4 triangles. These will all be coplanar (and will not be immediately collapsed) unless the MeshManifold has halfedgeTangents specified (e.g. from the Smooth() constructor), in which case the new vertices will be moved to the interpolated surface according to their barycentric coordinates.",
    "bitbybit.manifold.manifold.operations.smoothOut": "smooth out",
    "smoothOut": "smooth out",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Smooths out the Manifold by filling in the halfedgeTangent vectors. The geometry will remain unchanged until Refine or RefineToLength is called to interpolate the surface. This version uses the geometry of the triangles and pseudo-normals to define the tangent vectors.",
    "minSmoothness": "min smoothness",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "smooth by normals",
    "smoothByNormals": "smooth by normals",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Smooths out the Manifold by filling in the halfedgeTangent vectors. The geometry will remain unchanged until Refine or RefineToLength is called to interpolate the surface. This version uses the supplied vertex normal properties to define the tangent vectors.",
    "bitbybit.manifold.manifold.transforms.scale3D": "scale 3d",
    "scale3D": "scale 3d",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Scales a manifold shape with 3D vector",
    "bitbybit.manifold.manifold.transforms.scale": "scale",
    "bitbybit.manifold.manifold.transforms.scale_description": "Scales a manifold shape with single factor",
    "bitbybit.manifold.manifold.transforms.mirror": "mirror",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Mirrors a manifold shape over a plane defined by a normal vector",
    "bitbybit.manifold.manifold.transforms.translate": "translate",
    "bitbybit.manifold.manifold.transforms.translate_description": "Translates a manifold shape along the vector",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "translate by vectors",
    "translateByVectors": "translate by vectors",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Translates a manifold shape along by multiple vectors",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "translate xyz",
    "translateXYZ": "translate xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Translates a manifold shape along x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "rotate",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Rotates a manifold shape along the vector containing euler angles",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "rotate xyz",
    "rotateXYZ": "rotate xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Rotates a manifold shape along the x y z euler angles",
    "bitbybit.manifold.manifold.transforms.transform": "transform",
    "bitbybit.manifold.manifold.transforms.transform_description": "Transforms a manifold shape by using the 4x4 transformation matrix",
    "matrix": "matrix",
    "Base.TransformMatrix": "base transform matrix",
    "bitbybit.manifold.manifold.transforms.transforms": "transforms",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Transforms a manifold shape by using the 4x4 transformation matrixes",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "surface area",
    "evaluate": "evaluate",
    "surfaceArea": "surface area",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Get surface area of manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volume",
    "volume": "volume",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Get volume of manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "is empty",
    "isEmpty": "is empty",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Check if manifold contains triangles",
    "bitbybit.manifold.manifold.evaluate.numVert": "num vert",
    "numVert": "num vert",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Get number of vertices in manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "num tri",
    "numTri": "num tri",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Get number of triangles in manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "num edge",
    "numEdge": "num edge",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Get number of edges in manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "num prop",
    "numProp": "num prop",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Get number of properties in manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "num prop vert",
    "numPropVert": "num prop vert",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "The number of property vertices in the Manifold. This will always be >= numVert, as some physical vertices may be duplicated to account for different properties on different neighboring triangles.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "bounding box",
    "boundingBox": "bounding box",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Returns the axis-aligned bounding box of all the Manifold's vertices.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolerance",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Returns the tolerance of this Manifold's vertices, which tracks the approximate rounding error over all the transforms and operations that have led to this state. Any triangles that are colinear within this tolerance are considered degenerate and removed. This is the value of &epsilon; defining [&epsilon;-valid](https:github.comelalishmanifoldwikiManifold-Library#definition-of-%CE%B5-valid).",
    "bitbybit.manifold.manifold.evaluate.genus": "genus",
    "genus": "genus",
    "bitbybit.manifold.manifold.evaluate.genus_description": "The genus is a topological property of the manifold, representing the number of handles. A sphere is 0, torus 1, etc. It is only meaningful for a single mesh, so it is best to call Decompose() first.",
    "bitbybit.manifold.manifold.evaluate.minGap": "min gap",
    "minGap": "min gap",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Returns the minimum gap between two manifolds. Returns a float between 0 and searchLength.",
    "searchLength": "search length",
    "bitbybit.manifold.manifold.evaluate.originalID": "original id",
    "originalID": "original id",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "If this mesh is an original, this returns its ID that can be referenced by product manifolds. If this manifold is a product, this returns -1.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "cross section to polygons",
    "crossSection": "cross section",
    "crossSectionToPolygons": "cross section to polygons",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "turns cross section into polygons",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "cross sections to polygons",
    "crossSectionsToPolygons": "cross sections to polygons",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "turns cross sections into polygons",
    "crossSections": "cross sections",
    "bitbybit.manifold.crossSection.shapes.create": "create",
    "bitbybit.manifold.crossSection.shapes.create_description": "Create a 2d cross-section from a set of contours (complex polygons). A boolean union operation (with Positive filling rule by default) is performed to combine overlapping polygons and ensure the resulting CrossSection is free of intersections.",
    "Base.Vector2[][]": "base vector 2 array",
    "fillRule": "fill rule",
    "fillRuleEnum": "fill rule enum",
    "bitbybit.manifold.crossSection.shapes.square": "square",
    "bitbybit.manifold.crossSection.shapes.square_description": "Create a 2D square cross section",
    "bitbybit.manifold.crossSection.shapes.circle": "circle",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Create a 2D circle cross section",
    "bitbybit.manifold.crossSection.shapes.rectangle": "rectangle",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Create a 2D rectangle cross section",
    "bitbybit.manifold.crossSection.operations.hull": "hull",
    "bitbybit.manifold.crossSection.operations.hull_description": "Compute convex hull for the cross section",
    "bitbybit.manifold.crossSection.operations.extrude": "extrude",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Extrude the cross section to create a 3D shape",
    "nDivisions": "n divisions",
    "twistDegrees": "twist degrees",
    "scaleTopX": "scale top x",
    "scaleTopY": "scale top y",
    "bitbybit.manifold.crossSection.operations.revolve": "revolve",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Revolve the cross section to create a 3D shape",
    "revolveDegrees": "revolve degrees",
    "matchProfile": "match profile",
    "bitbybit.manifold.crossSection.operations.offset": "offset",
    "bitbybit.manifold.crossSection.operations.offset_description": "Offsets the cross section to create a new cross section with a given delta (uses Clipper2 algorithm behind).",
    "manifoldJoinTypeEnum": "manifold join type enum",
    "miterLimit": "miter limit",
    "bitbybit.manifold.crossSection.operations.simplify": "simplify",
    "simplify": "simplify",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Remove vertices from the contours in this CrossSection that are less than the specified distance epsilon from an imaginary line that passes through its two adjacent vertices. Near duplicate vertices and collinear points will be removed at lower epsilons, with elimination of line segments becoming increasingly aggressive with larger epsilons. It is recommended to apply this function following Offset, in order to clean up any spurious tiny line segments introduced that do not improve offseting operations are to be performed, which would compound the issue.",
    "epsilon": "epsilon",
    "bitbybit.manifold.crossSection.operations.compose": "compose",
    "bitbybit.manifold.crossSection.operations.compose_description": "Composes multiple cross sections or polygons into a single cross section",
    "bitbybit.manifold.crossSection.operations.decompose": "decompose",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Decompose cross sections that are topologically disconnected, each containing one outline contour with zero or more holes.",
    "bitbybit.manifold.crossSection.booleans.subtract": "subtract",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Subtract two cross sections",
    "crossSection1": "cross section 1",
    "crossSection2": "cross section 2",
    "bitbybit.manifold.crossSection.booleans.add": "add",
    "bitbybit.manifold.crossSection.booleans.add_description": "Add two cross sections",
    "bitbybit.manifold.crossSection.booleans.intersect": "intersect",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Intersect two cross sections",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "difference two",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "difference of two cross sections",
    "2 cross sections": "2 cross sections",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "union two",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "union of two cross sections",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "intersection two",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "intersection of two cross sections",
    "bitbybit.manifold.crossSection.booleans.difference": "difference",
    "bitbybit.manifold.crossSection.booleans.difference_description": "difference of multiple cross sections",
    "bitbybit.manifold.crossSection.booleans.union": "union",
    "bitbybit.manifold.crossSection.booleans.union_description": "union of multiple cross sections",
    "bitbybit.manifold.crossSection.booleans.intersection": "intersection",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "intersection of multiple cross sections",
    "bitbybit.manifold.crossSection.transforms.scale2D": "scale 2d",
    "scale2D": "scale 2d",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Scales a cross section shape with 2D vector",
    "bitbybit.manifold.crossSection.transforms.scale": "scale",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Scales a cross section shape with single factor",
    "bitbybit.manifold.crossSection.transforms.mirror": "mirror",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Mirrors a cross section shape over a plane defined by a normal vector",
    "bitbybit.manifold.crossSection.transforms.translate": "translate",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Translates a cross section shape along the vector",
    "bitbybit.manifold.crossSection.transforms.translateXY": "translate xy",
    "translateXY": "translate xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Translates a cross section shape along x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "rotate",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Rotates a cross section shape along the containing degrees",
    "degrees": "degrees",
    "bitbybit.manifold.crossSection.transforms.transform": "transform",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Transforms a cross section shape by using the 3x3 transformation matrix",
    "Base.TransformMatrix3x3": "base transform matrix 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "area",
    "area": "area",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Get area of cross section",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "is empty",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Check if cross section is empty",
    "bitbybit.manifold.crossSection.evaluate.numVert": "num vert",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Get number of vertices in cross section",
    "bitbybit.manifold.crossSection.evaluate.numContour": "num contour",
    "numContour": "num contour",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Get number of contours in cross section",
    "bitbybit.manifold.crossSection.evaluate.bounds": "bounds",
    "bounds": "bounds",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Get the bounds of the contour as a rectangle. Output is given in two vec2 points in the array. First array is the min point and second array is the max point.",
    "bitbybit.manifold.mesh.operations.merge": "merge",
    "merge": "merge",
    "bitbybit.manifold.mesh.operations.merge_description": "Updates the mergeFromVert and mergeToVert vectors in order to create a manifold solid. If the MeshGL is already manifold, no change will occur and the function will return false. Otherwise, this will merge verts along open edges within tolerance (the maximum of the MeshGL tolerance and the baseline bounding-box tolerance), keeping any from the existing merge vectors. There is no guarantee the result will be manifold - this is a best-effort helper function designed primarily to aid in the case where a manifold multi-material MeshGL was produced, but its merge vectors were lost due to a round-trip through a file format. Constructing a Manifold from the result will report a Status if it is not manifold.",
    "bitbybit.manifold.mesh.evaluate.position": "position",
    "bitbybit.manifold.mesh.evaluate.position_description": "Get position on mesh vertex index",
    "vertexIndex": "vertex index",
    "bitbybit.manifold.mesh.evaluate.verts": "verts",
    "verts": "verts",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Gets the three vertex indices of this triangle in CCW order.",
    "triangleIndex": "triangle index",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangent",
    "tangent": "tangent",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Gets the tangent vector starting at verts(tri)[j] pointing to the next Bezier point along the CCW edge. The fourth value is its weight.",
    "halfEdgeIndex": "half edge index",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Gets any other properties associated with this vertex.",
    "bitbybit.manifold.mesh.evaluate.transform": "transform",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Gets the column-major 4x4 matrix transform from the original mesh to these related triangles.",
    "bitbybit.manifold.mesh.evaluate.numProp": "num prop",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Number of properties per vertex, always >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "num vert",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Number of property vertices",
    "bitbybit.manifold.mesh.evaluate.numTri": "num tri",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Get number of triangles on mesh",
    "bitbybit.manifold.mesh.evaluate.numRun": "num run",
    "numRun": "num run",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Number of triangle runs. Each triangle run is a set of consecutive triangles that all come from the same instance of the same input mesh.",
    "bitbybit.logic.boolean": "boolean",
    "logic": "logic",
    "bitbybit.logic.boolean_description": "Creates and returns a boolean value (pass-through for boolean input). Example: true  true, false  false",
    "bitbybit.logic.randomBooleans": "random booleans",
    "randomBooleans": "random booleans",
    "bitbybit.logic.randomBooleans_description": "Generates a random boolean list where each value has a threshold chance of being true. Example: length=5, threshold=0.7  might produce [true, true, false, true, true]",
    "trueThreshold": "true threshold",
    "bitbybit.logic.twoThresholdRandomGradient": "two threshold random gradient",
    "twoThresholdRandomGradient": "two threshold random gradient",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Converts numbers to booleans using two thresholds with gradient randomization between them. Values below trueThreshold  always true, above falseThreshold  always false. Between thresholds  probability gradient (closer to false threshold = higher chance of false). Example: [0.1, 0.4, 0.6, 0.9] with thresholds [0.3, 0.7]  [true, gradient, gradient, false]",
    "numbers": "numbers",
    "thresholdTotalTrue": "threshold total true",
    "thresholdTotalFalse": "threshold total false",
    "nrLevels": "nr levels",
    "bitbybit.logic.thresholdBooleanList": "threshold boolean list",
    "thresholdBooleanList": "threshold boolean list",
    "bitbybit.logic.thresholdBooleanList_description": "Converts numbers to booleans based on a threshold (below threshold  true, above  false). Can be inverted to flip the logic. Example: [0.3, 0.7, 0.5] with threshold=0.6  [true, false, true]",
    "threshold": "threshold",
    "bitbybit.logic.thresholdGapsBooleanList": "threshold gaps boolean list",
    "thresholdGapsBooleanList": "threshold gaps boolean list",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Converts numbers to booleans using multiple range thresholds (gaps define true ranges). Values within any gap range  true, outside all gaps  false. Can be inverted. Example: [0.2, 0.5, 0.8] with gaps [[0.3, 0.6], [0.7, 0.9]]  [false, true, true]",
    "gapThresholds": "gap thresholds",
    "Base.Vector2[]": "base vector 2 array",
    "bitbybit.logic.not": "not",
    "not": "not",
    "bitbybit.logic.not_description": "Applies NOT operator to flip a boolean value. Example: true  false, false  true",
    "bitbybit.logic.notList": "not list",
    "notList": "not list",
    "bitbybit.logic.notList_description": "Applies NOT operator to flip all boolean values in a list. Example: [true, false, true]  [false, true, false]",
    "bitbybit.logic.compare": "compare",
    "compare": "compare",
    "bitbybit.logic.compare_description": "Compares two values using various operators (==, !=, ===, !==, <, <=, >, >=). Example: 5 > 3  true, 'hello' === 'world'  false",
    "operator": "operator",
    "BooleanOperatorsEnum": "boolean operators enum",
    "bitbybit.logic.valueGate": "value gate",
    "valueGate": "value gate",
    "bitbybit.logic.valueGate_description": "Conditionally passes a value through if boolean is true, otherwise returns undefined. Example: value=42, boolean=true  42, value=42, boolean=false  undefined",
    "bitbybit.logic.firstDefinedValueGate": "first defined value gate",
    "firstDefinedValueGate": "first defined value gate",
    "bitbybit.logic.firstDefinedValueGate_description": "Returns the first defined (non-undefined) value from two options (fallback pattern). Example: value1=42, value2=10  42, value1=undefined, value2=10  10",
    "value1": "value 1",
    "value2": "value 2",
    "bitbybit.math.number": "number",
    "math": "math",
    "bitbybit.math.number_description": "Creates and returns a number value (pass-through for number input). Example: Input 42  42, Input 3.14  3.14",
    "bitbybit.math.twoNrOperation": "two nr operation",
    "twoNrOperation": "two nr operation",
    "bitbybit.math.twoNrOperation_description": "Performs basic arithmetic operations on two numbers (add, subtract, multiply, divide, power, modulus). Example: 5 + 3  8, 10 % 3  1, 2 ^ 3  8",
    "operation": "operation",
    "mathTwoNrOperatorEnum": "math two nr operator enum",
    "bitbybit.math.modulus": "modulus",
    "modulus": "modulus",
    "bitbybit.math.modulus_description": "Calculates the remainder after division (modulus operation). Example: 10 % 3  1, 17 % 5  2",
    "bitbybit.math.roundToDecimals": "round to decimals",
    "roundToDecimals": "round to decimals",
    "bitbybit.math.roundToDecimals_description": "Rounds a number to specified decimal places. Example: 1.32156 with 3 decimals returns 1.322",
    "decimalPlaces": "decimal places",
    "bitbybit.math.oneNrOperation": "one nr operation",
    "oneNrOperation": "one nr operation",
    "bitbybit.math.oneNrOperation_description": "Performs mathematical operations on a single number (absolute, negate, sqrt, trig functions, logarithms, etc.). Example: sqrt(5)  2.236, abs(-3)  3, sin(2)  1",
    "mathOneNrOperatorEnum": "math one nr operator enum",
    "bitbybit.math.remap": "remap",
    "remap": "remap",
    "bitbybit.math.remap_description": "Maps a number from one range to another range proportionally. Example: 5 from [0,10] to [0,100]  50, 0.5 from [0,1] to [-10,10]  0",
    "fromLow": "from low",
    "fromHigh": "from high",
    "toLow": "to low",
    "toHigh": "to high",
    "bitbybit.math.random": "random",
    "random": "random",
    "bitbybit.math.random_description": "Generates a random decimal number between 0 (inclusive) and 1 (exclusive). Example: Outputs like 0.342, 0.891, or any value in [0, 1)",
    "generate": "generate",
    "bitbybit.math.randomNumber": "random number",
    "randomNumber": "random number",
    "bitbybit.math.randomNumber_description": "Generates a random number within a specified range (low to high). Example: Range [0, 10]  outputs like 3.7, 8.2, or any value between 0 and 10",
    "low": "low",
    "high": "high",
    "bitbybit.math.randomNumbers": "random numbers",
    "randomNumbers": "random numbers",
    "bitbybit.math.randomNumbers_description": "Generates multiple random numbers within a specified range. Example: Range [0, 10] with 3 items  [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "Returns the mathematical constant  (pi)  3.14159. Example: Outputs 3.141592653589793",
    "bitbybit.math.toFixed": "to fixed",
    "toFixed": "to fixed",
    "bitbybit.math.toFixed_description": "Formats a number as a string with a fixed number of decimal places (always shows trailing zeros). Example: 3.14159 with 2 decimals  '3.14', 5 with 3 decimals  '5.000'",
    "bitbybit.math.add": "add",
    "bitbybit.math.add_description": "Adds two numbers together. Example: 5 + 3  8, -2 + 7  5",
    "basics": "basics",
    "bitbybit.math.subtract": "subtract",
    "bitbybit.math.subtract_description": "Subtracts the second number from the first. Example: 10 - 3  7, 5 - 8  -3",
    "bitbybit.math.multiply": "multiply",
    "bitbybit.math.multiply_description": "Multiplies two numbers together. Example: 5  3  15, -2  4  -8",
    "bitbybit.math.divide": "divide",
    "divide": "divide",
    "bitbybit.math.divide_description": "Divides the first number by the second. Example: 10  2  5, 7  2  3.5",
    "bitbybit.math.power": "power",
    "power": "power",
    "bitbybit.math.power_description": "Raises the first number to the power of the second (exponentiation). Example: 2  8, 5  25, 10  0.1",
    "bitbybit.math.sqrt": "sqrt",
    "sqrt": "sqrt",
    "bitbybit.math.sqrt_description": "Calculates the square root of a number. Example: 9  3, 2  1.414, 16  4",
    "bitbybit.math.abs": "abs",
    "abs": "abs",
    "bitbybit.math.abs_description": "Returns the absolute value (removes negative sign, always positive or zero). Example: |-5|  5, |3|  3, |0|  0",
    "bitbybit.math.round": "round",
    "round": "round",
    "bitbybit.math.round_description": "Rounds a number to the nearest integer. Example: 3.7  4, 2.3  2, 5.5  6",
    "bitbybit.math.floor": "floor",
    "floor": "floor",
    "bitbybit.math.floor_description": "Rounds a number down to the nearest integer (toward negative infinity). Example: 3.7  3, -2.3  -3, 5  5",
    "bitbybit.math.ceil": "ceil",
    "ceil": "ceil",
    "bitbybit.math.ceil_description": "Rounds a number up to the nearest integer (toward positive infinity). Example: 3.2  4, -2.8  -2, 5  5",
    "bitbybit.math.negate": "negate",
    "negate": "negate",
    "bitbybit.math.negate_description": "Negates a number (flips its sign: positive becomes negative, negative becomes positive). Example: 5  -5, -3  3, 0  0",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "Calculates the natural logarithm (base e) of a number. Example: ln(2.718)  ~1, ln(7.389)  ~2, ln(1)  0",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "Calculates the base 10 logarithm of a number. Example: log(100)  2, log(1000)  3, log(10)  1",
    "bitbybit.math.tenPow": "ten pow",
    "tenPow": "ten pow",
    "bitbybit.math.tenPow_description": "Raises 10 to the power of the input number. Example: 10  100, 10  1000, 10  0.1",
    "bitbybit.math.sin": "sin",
    "sin": "sin",
    "bitbybit.math.sin_description": "Calculates the sine of an angle in radians. Example: sin(0)  0, sin(2)  1, sin()  ~0",
    "bitbybit.math.cos": "cos",
    "cos": "cos",
    "bitbybit.math.cos_description": "Calculates the cosine of an angle in radians. Example: cos(0)  1, cos(2)  ~0, cos()  -1",
    "bitbybit.math.tan": "tan",
    "tan": "tan",
    "bitbybit.math.tan_description": "Calculates the tangent of an angle in radians. Example: tan(0)  0, tan(4)  ~1, tan(2)  infinity",
    "bitbybit.math.asin": "asin",
    "asin": "asin",
    "bitbybit.math.asin_description": "Calculates the arcsine (inverse sine) in radians, returns angle whose sine is the input. Example: asin(0)  0, asin(1)  2 (~1.57), asin(0.5)  6 (~0.524)",
    "bitbybit.math.acos": "acos",
    "acos": "acos",
    "bitbybit.math.acos_description": "Calculates the arccosine (inverse cosine) in radians, returns angle whose cosine is the input. Example: acos(1)  0, acos(0)  2 (~1.57), acos(-1)   (~3.14)",
    "bitbybit.math.atan": "atan",
    "atan": "atan",
    "bitbybit.math.atan_description": "Calculates the arctangent (inverse tangent) in radians, returns angle whose tangent is the input. Example: atan(0)  0, atan(1)  4 (~0.785), atan(-1)  -4",
    "bitbybit.math.exp": "exp",
    "exp": "exp",
    "bitbybit.math.exp_description": "Calculates e raised to the power of the input (exponential function). Example: e  1, e  ~2.718, e  ~7.389",
    "bitbybit.math.degToRad": "deg to rad",
    "degToRad": "deg to rad",
    "bitbybit.math.degToRad_description": "Converts an angle from degrees to radians. Example: 180   (~3.14159), 90  2 (~1.5708), 360  2",
    "bitbybit.math.radToDeg": "rad to deg",
    "radToDeg": "rad to deg",
    "bitbybit.math.radToDeg_description": "Converts an angle from radians to degrees. Example:   180, 2  90, 2  360",
    "bitbybit.math.ease": "ease",
    "bitbybit.math.ease_description": "Applies an easing function to interpolate smoothly between min and max values. Example: x=0.5 from [0,100] with easeInQuad  applies quadratic acceleration curve Useful for smooth animations with various accelerationdeceleration curves.",
    "easeEnum": "ease enum",
    "bitbybit.lists.getItem": "get item",
    "lists": "lists",
    "getItem": "get item",
    "bitbybit.lists.getItem_description": "Gets an item from the list at a specific position using zero-based indexing. Example: From [10, 20, 30, 40], getting index 2 returns 30",
    "list": "list",
    "bitbybit.lists.randomGetThreshold": "random get threshold",
    "randomGetThreshold": "random get threshold",
    "bitbybit.lists.randomGetThreshold_description": "Randomly keeps items from the list based on a probability threshold (0 to 1). Example: From [1, 2, 3, 4, 5] with threshold 0.5, might return [1, 3, 5] (50% chance for each item)",
    "bitbybit.lists.getSubList": "get sub list",
    "getSubList": "get sub list",
    "bitbybit.lists.getSubList_description": "Extracts a portion of the list between start and end positions (end is exclusive). Example: From [10, 20, 30, 40, 50] with start=1 and end=4, returns [20, 30, 40]",
    "indexStart": "index start",
    "indexEnd": "index end",
    "bitbybit.lists.getNthItem": "get nth item",
    "getNthItem": "get nth item",
    "bitbybit.lists.getNthItem_description": "Gets every nth item from the list, starting from an optional offset position. Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with nth=3 and offset=0, returns [0, 3, 6] Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with nth=2 and offset=1, returns [1, 3, 5, 7]",
    "nth": "nth",
    "bitbybit.lists.getByPattern": "get by pattern",
    "getByPattern": "get by pattern",
    "bitbybit.lists.getByPattern_description": "Filters items from the list using a repeating truefalse pattern. Example: From [0, 1, 2, 3, 4, 5] with pattern [true, true, false], returns [0, 1, 3, 4] (keeps items where pattern is true)",
    "pattern": "pattern",
    "bitbybit.lists.mergeElementsOfLists": "merge elements of lists",
    "mergeElementsOfLists": "merge elements of lists",
    "bitbybit.lists.mergeElementsOfLists_description": "Merges elements from multiple lists at a specific nesting level, grouping elements by position. Example: From [[0, 1, 2], [3, 4, 5]] at level 0, returns [[0, 3], [1, 4], [2, 5]]",
    "level": "level",
    "bitbybit.lists.getLongestListLength": "get longest list length",
    "getLongestListLength": "get longest list length",
    "bitbybit.lists.getLongestListLength_description": "Finds the length of the longest list among multiple lists. Example: From [[1, 2], [3, 4, 5, 6], [7]], returns 4 (length of [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "reverse",
    "bitbybit.lists.reverse_description": "Reverses the order of items in the list. Example: From [1, 2, 3, 4, 5], returns [5, 4, 3, 2, 1]",
    "bitbybit.lists.flipLists": "flip lists",
    "flipLists": "flip lists",
    "bitbybit.lists.flipLists_description": "Transposes a 2D list by swapping rows and columns (all sublists must be equal length). Example: From [[0, 1, 2], [3, 4, 5]], returns [[0, 3], [1, 4], [2, 5]]",
    "bitbybit.lists.groupNth": "group nth",
    "groupNth": "group nth",
    "bitbybit.lists.groupNth_description": "Splits the list into smaller lists of n elements each. Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with n=3, returns [[0, 1, 2], [3, 4, 5], [6, 7, 8]] Example: From [0, 1, 2, 3, 4] with n=2 and keepRemainder=true, returns [[0, 1], [2, 3], [4]]",
    "nrElements": "nr elements",
    "keepRemainder": "keep remainder",
    "bitbybit.lists.getListDepth": "get list depth",
    "getListDepth": "get list depth",
    "bitbybit.lists.getListDepth_description": "Determines the maximum nesting level (depth) of a list structure. Example: [1, 2, 3] has depth 1, [[1, 2], [3, 4]] has depth 2, [[[1]]] has depth 3",
    "bitbybit.lists.listLength": "list length",
    "listLength": "list length",
    "bitbybit.lists.listLength_description": "Returns the number of items in the list. Example: [10, 20, 30, 40, 50] returns 5, [] returns 0",
    "bitbybit.lists.addItemAtIndex": "add item at index",
    "addItemAtIndex": "add item at index",
    "bitbybit.lists.addItemAtIndex_description": "Inserts an item at a specific position in the list. Example: In [10, 20, 30, 40], adding 99 at index 2 gives [10, 20, 99, 30, 40]",
    "item": "item",
    "bitbybit.lists.addItemAtIndexes": "add item at indexes",
    "addItemAtIndexes": "add item at indexes",
    "bitbybit.lists.addItemAtIndexes_description": "Inserts the same item at multiple specified positions in the list. Example: In [10, 20, 30], adding 99 at indexes [0, 2] gives [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "add items at indexes",
    "addItemsAtIndexes": "add items at indexes",
    "bitbybit.lists.addItemsAtIndexes_description": "Inserts multiple items at corresponding positions (first item at first index, second item at second index, etc.). Example: In [10, 20, 30], adding items [88, 99] at indexes [1, 2] gives [10, 88, 20, 99, 30]",
    "items": "items",
    "bitbybit.lists.removeItemAtIndex": "remove item at index",
    "removeItemAtIndex": "remove item at index",
    "bitbybit.lists.removeItemAtIndex_description": "Removes the item at a specific position in the list. Example: From [10, 20, 30, 40, 50], removing index 2 gives [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "remove items at indexes",
    "removeItemsAtIndexes": "remove items at indexes",
    "bitbybit.lists.removeItemsAtIndexes_description": "Removes items at multiple specified positions from the list. Example: From [10, 20, 30, 40, 50], removing indexes [1, 3] gives [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "remove all items",
    "removeAllItems": "remove all items",
    "bitbybit.lists.removeAllItems_description": "Clears all items from the list, resulting in an empty list. Example: From [10, 20, 30, 40], returns []",
    "bitbybit.lists.removeNthItem": "remove nth item",
    "removeNthItem": "remove nth item",
    "bitbybit.lists.removeNthItem_description": "Removes every nth item from the list, starting from an optional offset position. Example: From [0, 1, 2, 3, 4, 5, 6, 7, 8] with nth=3 and offset=0, returns [1, 2, 4, 5, 7, 8] (removes 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "random remove threshold",
    "randomRemoveThreshold": "random remove threshold",
    "bitbybit.lists.randomRemoveThreshold_description": "Randomly removes items from the list based on a probability threshold (0 to 1). Example: From [1, 2, 3, 4, 5] with threshold 0.5, might return [2, 4] (50% chance to remove each item)",
    "bitbybit.lists.removeDuplicateNumbers": "remove duplicate numbers",
    "removeDuplicateNumbers": "remove duplicate numbers",
    "bitbybit.lists.removeDuplicateNumbers_description": "Removes duplicate numbers from the list, keeping only the first occurrence of each value. Example: From [1, 2, 3, 2, 4, 3, 5], returns [1, 2, 3, 4, 5]",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "remove duplicate numbers tolerance",
    "removeDuplicateNumbersTolerance": "remove duplicate numbers tolerance",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Removes duplicate numbers that are within a specified tolerance range of each other. Example: From [1.0, 1.001, 2.0, 2.002, 3.0] with tolerance 0.01, returns [1.0, 2.0, 3.0]",
    "bitbybit.lists.addItem": "add item",
    "addItem": "add item",
    "bitbybit.lists.addItem_description": "Appends an item to the end of the list. Example: To [10, 20, 30], adding 40 gives [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "prepend item",
    "prependItem": "prepend item",
    "bitbybit.lists.prependItem_description": "Adds an item to the beginning of the list. Example: To [10, 20, 30], prepending 5 gives [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "add item first last",
    "addItemFirstLast": "add item first last",
    "bitbybit.lists.addItemFirstLast_description": "Adds an item either at the beginning or end of the list based on the position parameter. Example: To [10, 20, 30], adding 5 at 'first' gives [5, 10, 20, 30], at 'last' gives [10, 20, 30, 5]",
    "firstLastEnum": "first last enum",
    "bitbybit.lists.createEmptyList": "empty list",
    "createEmptyList": "empty list",
    "bitbybit.lists.createEmptyList_description": "Creates a new empty list with no items. Example: Returns []",
    "bitbybit.lists.repeat": "repeat",
    "repeat": "repeat",
    "bitbybit.lists.repeat_description": "Creates a new list by repeating an item a specified number of times. Example: Repeating 5 three times returns [5, 5, 5]",
    "times": "times",
    "bitbybit.lists.repeatInPattern": "repeat in pattern",
    "repeatInPattern": "repeat in pattern",
    "bitbybit.lists.repeatInPattern_description": "Repeats a pattern of items cyclically until reaching a target list length. Example: Pattern [1, 2, 3] with length 7 returns [1, 2, 3, 1, 2, 3, 1]",
    "lengthLimit": "length limit",
    "bitbybit.lists.sortNumber": "sort number",
    "sortNumber": "sort number",
    "bitbybit.lists.sortNumber_description": "Sorts numbers in ascending (lowest to highest) or descending (highest to lowest) order. Example: [5, 2, 8, 1, 9] ascending returns [1, 2, 5, 8, 9], descending returns [9, 8, 5, 2, 1]",
    "sorting": "sorting",
    "orderAsc": "order asc",
    "bitbybit.lists.sortTexts": "sort texts",
    "sortTexts": "sort texts",
    "bitbybit.lists.sortTexts_description": "Sorts text strings alphabetically in ascending (A to Z) or descending (Z to A) order. Example: ['dog', 'apple', 'cat', 'banana'] ascending returns ['apple', 'banana', 'cat', 'dog']",
    "bitbybit.lists.sortByPropValue": "sort by prop value",
    "sortByPropValue": "sort by prop value",
    "bitbybit.lists.sortByPropValue_description": "Sorts objects by comparing numeric values of a specified property. Example: [{age: 30}, {age: 20}, {age: 25}] sorted by 'age' ascending returns [{age: 20}, {age: 25}, {age: 30}]",
    "property": "property",
    "bitbybit.color.hexColor": "hex color",
    "hexColor": "hex color",
    "bitbybit.color.hexColor_description": "Creates and returns a hex color string (pass-through for color input). Example: '#FF5733'  '#FF5733'",
    "bitbybit.color.hexToRgb": "hex to rgb",
    "hexToRgb": "hex to rgb",
    "bitbybit.color.hexToRgb_description": "Converts hex color to RGB object with r, g, b values (0-255 range). Example: '#FF5733'  {r: 255, g: 87, b: 51}",
    "convert": "convert",
    "bitbybit.color.rgbToHex": "rgb to hex",
    "rgbToHex": "rgb to hex",
    "bitbybit.color.rgbToHex_description": "Converts RGB values to hex color string (supports custom minmax ranges, auto-remaps to 0-255). Example: r=255, g=87, b=51 with range [0,255]  '#ff5733' Example: r=1, g=0.5, b=0.2 with range [0,1]  '#ff7f33'",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "rgb obj to hex",
    "rgbObjToHex": "rgb obj to hex",
    "bitbybit.color.rgbObjToHex_description": "Converts RGB object to hex color string (supports custom minmax ranges). Example: {r: 1, g: 0.5, b: 0.2} with range [0,1]  '#ff7f33'",
    "rgb": "rgb",
    "Base.ColorRGB": "base color rgb",
    "bitbybit.color.hexToRgbMapped": "hex to rgb mapped",
    "hexToRgbMapped": "hex to rgb mapped",
    "bitbybit.color.hexToRgbMapped_description": "Converts hex color to RGB and remaps values to a custom range. Example: '#FF5733' mapped to [0,1]  {r: 1, g: 0.341, b: 0.2} Example: '#FF5733' mapped to [0,100]  {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "get red param",
    "getRedParam": "get red param",
    "bitbybit.color.getRedParam_description": "Extracts the red channel value from hex color (can be mapped to custom range). Example: '#FF5733' with range [0,1]  1",
    "hex to": "hex to",
    "bitbybit.color.getGreenParam": "get green param",
    "getGreenParam": "get green param",
    "bitbybit.color.getGreenParam_description": "Extracts the green channel value from hex color (can be mapped to custom range). Example: '#FF5733' with range [0,1]  0.341",
    "bitbybit.color.getBlueParam": "get blue param",
    "getBlueParam": "get blue param",
    "bitbybit.color.getBlueParam_description": "Extracts the blue channel value from hex color (can be mapped to custom range). Example: '#FF5733' with range [0,1]  0.2",
    "bitbybit.color.rgbToRed": "rgb to red",
    "rgbToRed": "rgb to red",
    "bitbybit.color.rgbToRed_description": "Extracts the red channel value from RGB object. Example: {r: 255, g: 87, b: 51}  255",
    "rgb to": "rgb to",
    "bitbybit.color.rgbToGreen": "rgb to green",
    "rgbToGreen": "rgb to green",
    "bitbybit.color.rgbToGreen_description": "Extracts the green channel value from RGB object. Example: {r: 255, g: 87, b: 51}  87",
    "bitbybit.color.rgbToBlue": "rgb to blue",
    "rgbToBlue": "rgb to blue",
    "bitbybit.color.rgbToBlue_description": "Extracts the blue channel value from RGB object. Example: {r: 255, g: 87, b: 51}  51",
    "bitbybit.color.invert": "invert",
    "invert": "invert",
    "bitbybit.color.invert_description": "Inverts a hex color (flips RGB channels: 255-r, 255-g, 255-b). With blackAndWhite=true  returns '#000000' or '#ffffff' based on brightness. Example: '#FF5733'  '#00a8cc', '#FF5733' with blackAndWhite=true  '#ffffff'",
    "blackAndWhite": "black and white",
    "bitbybit.text.create": "create",
    "bitbybit.text.create_description": "Creates and returns a text string (pass-through for text input). Example: text='Hello World'  'Hello World'",
    "bitbybit.text.split": "split",
    "bitbybit.text.split_description": "Splits text into multiple pieces using a separator string. Example: text='apple,banana,cherry', separator=','  ['apple', 'banana', 'cherry']",
    "separator": "separator",
    "bitbybit.text.replaceAll": "replace all",
    "replaceAll": "replace all",
    "bitbybit.text.replaceAll_description": "Replaces all occurrences of a search string with a replacement string. Example: text='hello hello', search='hello', replaceWith='hi'  'hi hi'",
    "search": "search",
    "replaceWith": "replace with",
    "bitbybit.text.join": "join",
    "join": "join",
    "bitbybit.text.join_description": "Joins multiple items into a single text string using a separator. Example: list=['apple', 'banana', 'cherry'], separator=', '  'apple, banana, cherry'",
    "string[]": "string array",
    "bitbybit.text.toString": "to string",
    "toString": "to string",
    "bitbybit.text.toString_description": "Transform any item to text",
    "bitbybit.text.toStringEach": "to string each",
    "toStringEach": "to string each",
    "bitbybit.text.toStringEach_description": "Transform each item in list to text",
    "bitbybit.text.format": "format",
    "format": "format",
    "bitbybit.text.format_description": "Formats text with placeholder values using {0}, {1}, etc. syntax. Example: text='Point: ({0}, {1})', values=[10, 5]  'Point: (10, 5)'",
    "values": "values",
    "bitbybit.text.vectorChar": "vector char",
    "vectorChar": "vector char",
    "bitbybit.text.vectorChar_description": "Converts a character to vector paths (polylines) with width and height data for rendering. Uses simplex stroke font to generate 2D line segments representing the character shape. Example: char='A', height=10  {width:8, height:10, paths:[[points forming A shape]]}",
    "char": "char",
    "bitbybit.text.vectorText": "vector text",
    "vectorText": "vector text",
    "bitbybit.text.vectorText_description": "Converts multi-line text to vector paths (polylines) with alignment and spacing controls. Supports line breaks, letter spacing, line spacing, horizontal alignment, and origin centering. Example: text='Hello\nWorld', height=10, align=center  [{line1 chars}, {line2 chars}]",
    "bitbybit.dates.toDateString": "to date string",
    "dates": "dates",
    "toDateString": "to date string",
    "bitbybit.dates.toDateString_description": "Converts date to human-readable date string (excludes time). Example: Date(2024,0,15,14,30)  'Mon Jan 15 2024'",
    "date": "date",
    "Date": "date",
    "bitbybit.dates.toISOString": "to iso string",
    "toISOString": "to iso string",
    "bitbybit.dates.toISOString_description": "Converts date to ISO 8601 format string (standard format for APIs and data interchange). Example: Date(2024,0,15,14,30,45)  '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "to json",
    "toJSON": "to json",
    "bitbybit.dates.toJSON_description": "Converts date to JSON-compatible string (same as ISO format, used in JSON.stringify). Example: Date(2024,0,15,14,30)  '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "to string",
    "bitbybit.dates.toString_description": "Converts date to full locale-specific string (includes date, time, and timezone). Example: Date(2024,0,15,14,30)  'Mon Jan 15 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "to time string",
    "toTimeString": "to time string",
    "bitbybit.dates.toTimeString_description": "Converts date to time string (excludes date, includes timezone). Example: Date(2024,0,15,14,30,45)  '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "to utc string",
    "toUTCString": "to utc string",
    "bitbybit.dates.toUTCString_description": "Converts date to UTC string format (Universal Coordinated Time, no timezone offset). Example: Date(2024,0,15,14,30)  'Mon, 15 Jan 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "now",
    "now": "now",
    "bitbybit.dates.now_description": "Returns the current date and time at the moment of execution. Example: calling now()  Date object representing current moment (e.g., '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "create date",
    "createDate": "create date",
    "bitbybit.dates.createDate_description": "Creates a new date from individual components using local time. Month is 0-indexed: 0=January, 11=December. Example: year=2024, month=0, day=15, hours=14, minutes=30  Date(Jan 15, 2024 14:30)",
    "year": "year",
    "month": "month",
    "day": "day",
    "hours": "hours",
    "minutes": "minutes",
    "seconds": "seconds",
    "milliseconds": "milliseconds",
    "bitbybit.dates.createDateUTC": "create date utc",
    "createDateUTC": "create date utc",
    "bitbybit.dates.createDateUTC_description": "Creates a new date from individual components using UTC (ignores timezone). Returns milliseconds since Unix epoch (Jan 1, 1970 00:00:00 UTC). Example: year=2024, month=0, day=15  Date representing Jan 15, 2024 00:00 UTC",
    "bitbybit.dates.createFromUnixTimeStamp": "create from unix time stamp",
    "createFromUnixTimeStamp": "create from unix time stamp",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Creates a date from Unix timestamp (milliseconds since Jan 1, 1970 UTC). Example: unixTimeStamp=1705329000000  Date(Jan 15, 2024 14:30:00)",
    "unixTimeStamp": "unix time stamp",
    "bitbybit.dates.parseDate": "parse date",
    "parseDate": "parse date",
    "bitbybit.dates.parseDate_description": "Parses a date string and returns Unix timestamp (milliseconds since Jan 1, 1970 UTC). Example: dateString='2024-01-15'  1705276800000",
    "parse": "parse",
    "dateString": "date string",
    "bitbybit.dates.getDayOfMonth": "get day of month",
    "getDayOfMonth": "get day of month",
    "bitbybit.dates.getDayOfMonth_description": "Extracts day of the month from date (1-31) using local time. Example: Date(2024,0,15)  15",
    "bitbybit.dates.getWeekday": "get weekday",
    "getWeekday": "get weekday",
    "bitbybit.dates.getWeekday_description": "Extracts day of the week from date (0=Sunday, 6=Saturday) using local time. Example: Date(2024,0,15)  1 (Monday)",
    "bitbybit.dates.getYear": "get year",
    "getYear": "get year",
    "bitbybit.dates.getYear_description": "Extracts full year from date using local time. Example: Date(2024,0,15)  2024",
    "bitbybit.dates.getMonth": "get month",
    "getMonth": "get month",
    "bitbybit.dates.getMonth_description": "Extracts month from date (0=January, 11=December) using local time. Example: Date(2024,0,15)  0 (January)",
    "bitbybit.dates.getHours": "get hours",
    "getHours": "get hours",
    "bitbybit.dates.getHours_description": "Extracts hours from date (0-23) using local time. Example: Date(2024,0,15,14,30)  14",
    "bitbybit.dates.getMinutes": "get minutes",
    "getMinutes": "get minutes",
    "bitbybit.dates.getMinutes_description": "Extracts minutes from date (0-59) using local time. Example: Date(2024,0,15,14,30)  30",
    "bitbybit.dates.getSeconds": "get seconds",
    "getSeconds": "get seconds",
    "bitbybit.dates.getSeconds_description": "Extracts seconds from date (0-59) using local time. Example: Date(2024,0,15,14,30,45)  45",
    "bitbybit.dates.getMilliseconds": "get milliseconds",
    "getMilliseconds": "get milliseconds",
    "bitbybit.dates.getMilliseconds_description": "Extracts milliseconds from date (0-999) using local time. Example: Date(2024,0,15,14,30,45,123)  123",
    "bitbybit.dates.getTime": "get time",
    "getTime": "get time",
    "bitbybit.dates.getTime_description": "Converts date to Unix timestamp (milliseconds since Jan 1, 1970 UTC). Example: Date(2024,0,15,14,30)  1705329000000",
    "bitbybit.dates.getUTCYear": "get utc year",
    "getUTCYear": "get utc year",
    "bitbybit.dates.getUTCYear_description": "Extracts full year from date using UTC (ignores timezone). Example: Date(2024,0,15)  2024",
    "bitbybit.dates.getUTCMonth": "get utc month",
    "getUTCMonth": "get utc month",
    "bitbybit.dates.getUTCMonth_description": "Extracts month from date (0=January, 11=December) using UTC. Example: Date.UTC(2024,0,15)  0 (January)",
    "bitbybit.dates.getUTCDay": "get utc day",
    "getUTCDay": "get utc day",
    "bitbybit.dates.getUTCDay_description": "Extracts day of the month from date (1-31) using UTC. Example: Date.UTC(2024,0,15)  15",
    "bitbybit.dates.getUTCHours": "get utc hours",
    "getUTCHours": "get utc hours",
    "bitbybit.dates.getUTCHours_description": "Extracts hours from date (0-23) using UTC. Example: Date.UTC(2024,0,15,14)  14",
    "bitbybit.dates.getUTCMinutes": "get utc minutes",
    "getUTCMinutes": "get utc minutes",
    "bitbybit.dates.getUTCMinutes_description": "Extracts minutes from date (0-59) using UTC. Example: Date.UTC(2024,0,15,14,30)  30",
    "bitbybit.dates.getUTCSeconds": "get utc seconds",
    "getUTCSeconds": "get utc seconds",
    "bitbybit.dates.getUTCSeconds_description": "Extracts seconds from date (0-59) using UTC. Example: Date.UTC(2024,0,15,14,30,45)  45",
    "bitbybit.dates.getUTCMilliseconds": "get utc milliseconds",
    "getUTCMilliseconds": "get utc milliseconds",
    "bitbybit.dates.getUTCMilliseconds_description": "Extracts milliseconds from date (0-999) using UTC. Example: Date.UTC(2024,0,15,14,30,45,123)  123",
    "bitbybit.dates.setYear": "set year",
    "setYear": "set year",
    "bitbybit.dates.setYear_description": "Creates new date with modified year (returns new date, original unchanged). Example: Date(2024,0,15) with year=2025  Date(2025,0,15)",
    "bitbybit.dates.setMonth": "set month",
    "setMonth": "set month",
    "bitbybit.dates.setMonth_description": "Creates new date with modified month (0=January, 11=December, returns new date). Example: Date(2024,0,15) with month=5  Date(2024,5,15) (June 15)",
    "bitbybit.dates.setDayOfMonth": "set day of month",
    "setDayOfMonth": "set day of month",
    "bitbybit.dates.setDayOfMonth_description": "Creates new date with modified day of month (1-31, returns new date). Example: Date(2024,0,15) with day=20  Date(2024,0,20)",
    "bitbybit.dates.setHours": "set hours",
    "setHours": "set hours",
    "bitbybit.dates.setHours_description": "Sets the hour value in the Date object using local time.",
    "bitbybit.dates.setMinutes": "set minutes",
    "setMinutes": "set minutes",
    "bitbybit.dates.setMinutes_description": "Sets the minutes value in the Date object using local time.",
    "bitbybit.dates.setSeconds": "set seconds",
    "setSeconds": "set seconds",
    "bitbybit.dates.setSeconds_description": "Sets the seconds value in the Date object using local time.",
    "bitbybit.dates.setMilliseconds": "set milliseconds",
    "setMilliseconds": "set milliseconds",
    "bitbybit.dates.setMilliseconds_description": "Sets the milliseconds value in the Date object using local time.",
    "bitbybit.dates.setTime": "set time",
    "setTime": "set time",
    "bitbybit.dates.setTime_description": "Sets the date and time value in the Date object.",
    "time": "time",
    "bitbybit.dates.setUTCYear": "set utc year",
    "setUTCYear": "set utc year",
    "bitbybit.dates.setUTCYear_description": "Sets the year value in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMonth": "set utc month",
    "setUTCMonth": "set utc month",
    "bitbybit.dates.setUTCMonth_description": "Sets the month value in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCDay": "set utc day",
    "setUTCDay": "set utc day",
    "bitbybit.dates.setUTCDay_description": "Sets the numeric day of the month in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCHours": "set utc hours",
    "setUTCHours": "set utc hours",
    "bitbybit.dates.setUTCHours_description": "Sets the hours value in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMinutes": "set utc minutes",
    "setUTCMinutes": "set utc minutes",
    "bitbybit.dates.setUTCMinutes_description": "Sets the minutes value in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCSeconds": "set utc seconds",
    "setUTCSeconds": "set utc seconds",
    "bitbybit.dates.setUTCSeconds_description": "Sets the seconds value in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "set utc milliseconds",
    "setUTCMilliseconds": "set utc milliseconds",
    "bitbybit.dates.setUTCMilliseconds_description": "Sets the milliseconds value in the Date object using Universal Coordinated Time (UTC).",
    "bitbybit.json.stringify": "stringify",
    "json": "json",
    "stringify": "stringify",
    "bitbybit.json.stringify_description": "Stringifies the input value",
    "bitbybit.json.parse": "parse",
    "bitbybit.json.parse_description": "Parses the input value",
    "bitbybit.json.query": "query",
    "query": "query",
    "bitbybit.json.query_description": "Queries the input value",
    "jsonpath": "jsonpath",
    "bitbybit.json.setValueOnProp": "set value on prop",
    "setValueOnProp": "set value on prop",
    "bitbybit.json.setValueOnProp_description": "Sets value on given property of the given json",
    "props": "props",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "get json from array by first prop match",
    "getJsonFromArrayByFirstPropMatch": "get json from array by first prop match",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Gets json from array by first property match. This is very simplistic search and only returns the first match. If you need more complex search, you can use jsonpath query with filters.",
    "jsonArray": "json array",
    "any[]": "any array",
    "match": "match",
    "bitbybit.json.getValueOnProp": "get value on prop",
    "getValueOnProp": "get value on prop",
    "bitbybit.json.getValueOnProp_description": "Gets value of the property in the given json",
    "bitbybit.json.setValue": "set value",
    "bitbybit.json.setValue_description": "Sets value to the json by providing a path",
    "prop": "prop",
    "bitbybit.json.setValuesOnPaths": "set values on paths",
    "setValuesOnPaths": "set values on paths",
    "bitbybit.json.setValuesOnPaths_description": "Sets multiple values to the json by providing paths",
    "paths": "paths",
    "bitbybit.json.paths": "paths",
    "bitbybit.json.paths_description": "Find paths to elements in object matching path expression",
    "bitbybit.json.createEmpty": "empty",
    "bitbybit.json.createEmpty_description": "Creates an empty JavaScript object",
    "bitbybit.json.previewAndSaveJson": "preview and save json",
    "previewAndSaveJson": "preview and save json",
    "bitbybit.json.previewAndSaveJson_description": "Previews json and gives option to save it",
    "preview": "preview",
    "bitbybit.json.previewJson": "preview json",
    "previewJson": "preview json",
    "bitbybit.json.previewJson_description": "previews json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "curve by knots control points weights",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "curve by knots control points weights",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Creates a Nurbs curve by providing knots, control points & weights",
    "degree": "degree",
    "knots": "knots",
    "bitbybit.verb.curve.createCurveByPoints": "curve by points",
    "createCurveByPoints": "curve by points",
    "bitbybit.verb.curve.createCurveByPoints_description": "Creates a Nurbs curve by providing control points",
    "bitbybit.verb.curve.createBezierCurve": "bezier curve",
    "createBezierCurve": "bezier curve",
    "bitbybit.verb.curve.createBezierCurve_description": "Creates a Bezier Nurbs curve by providing control points and weights",
    "bitbybit.verb.curve.clone": "clone",
    "bitbybit.verb.curve.clone_description": "Clone the Nurbs curve",
    "bitbybit.verb.curve.closestParam": "closest param",
    "closestParam": "closest param",
    "bitbybit.verb.curve.closestParam_description": "Finds the closest param on the Nurbs curve from the point",
    "bitbybit.verb.curve.closestParams": "closest params",
    "closestParams": "closest params",
    "bitbybit.verb.curve.closestParams_description": "Finds the closest params on the Nurbs curve from the points",
    "bitbybit.verb.curve.closestPoint": "closest point",
    "closestPoint": "closest point",
    "bitbybit.verb.curve.closestPoint_description": "Finds the closest point on the Nurbs curve from the point",
    "bitbybit.verb.curve.closestPoints": "closest points",
    "closestPoints": "closest points",
    "bitbybit.verb.curve.closestPoints_description": "Finds the closest points on the Nurbs curve from the list of points",
    "bitbybit.verb.curve.controlPoints": "control points",
    "controlPoints": "control points",
    "bitbybit.verb.curve.controlPoints_description": "Finds the control points of the Nurbs curve",
    "bitbybit.verb.curve.degree": "degree",
    "bitbybit.verb.curve.degree_description": "Finds the degree of the Nurbs curve",
    "bitbybit.verb.curve.derivatives": "derivatives",
    "derivatives": "derivatives",
    "bitbybit.verb.curve.derivatives_description": "Finds the derivatives of the Nurbs curve at parameter",
    "numDerivatives": "num derivatives",
    "parameter": "parameter",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "divide by equal arc length to params",
    "divideByEqualArcLengthToParams": "divide by equal arc length to params",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Divides the curve by equal arc length to parameters",
    "subdivision": "subdivision",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "divide by equal arc length to points",
    "divideByEqualArcLengthToPoints": "divide by equal arc length to points",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Divides the curve by equal arc length to points",
    "bitbybit.verb.curve.divideByArcLengthToParams": "divide by arc length to params",
    "divideByArcLengthToParams": "divide by arc length to params",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Divides the curve by arc length to parameters",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "divide by arc length to points",
    "divideByArcLengthToPoints": "divide by arc length to points",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Divides the curve by arc length to points",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "divide curves by equal arc length to points",
    "divideCurvesByEqualArcLengthToPoints": "divide curves by equal arc length to points",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divides multiple curves by equal arc length to points",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "divide curves by arc length to points",
    "divideCurvesByArcLengthToPoints": "divide curves by arc length to points",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divides multiple curves by arc length to points",
    "bitbybit.verb.curve.domain": "domain",
    "bitbybit.verb.curve.domain_description": "Finds the domain interval of the curve parameters",
    "bitbybit.verb.curve.startPoint": "start point",
    "bitbybit.verb.curve.startPoint_description": "Start point of the curve",
    "bitbybit.verb.curve.endPoint": "end point",
    "bitbybit.verb.curve.endPoint_description": "End point of the curve",
    "bitbybit.verb.curve.startPoints": "start points",
    "bitbybit.verb.curve.startPoints_description": "Start points of the curves",
    "bitbybit.verb.curve.endPoints": "end points",
    "bitbybit.verb.curve.endPoints_description": "End points of the curves",
    "bitbybit.verb.curve.knots": "knots",
    "bitbybit.verb.curve.knots_description": "Finds the knots of the Nurbs curve",
    "bitbybit.verb.curve.lengthAtParam": "length at param",
    "lengthAtParam": "length at param",
    "bitbybit.verb.curve.lengthAtParam_description": "Gets the length of the Nurbs curve at specific parameter",
    "bitbybit.verb.curve.length": "length",
    "bitbybit.verb.curve.length_description": "Gets the length of the Nurbs curve",
    "bitbybit.verb.curve.paramAtLength": "param at length",
    "paramAtLength": "param at length",
    "bitbybit.verb.curve.paramAtLength_description": "Gets the param at specified length on the Nurbs curve",
    "bitbybit.verb.curve.pointAtParam": "point at param",
    "pointAtParam": "point at param",
    "bitbybit.verb.curve.pointAtParam_description": "Gets the point at specified parameter on the Nurbs curve",
    "bitbybit.verb.curve.pointsAtParam": "points at param",
    "pointsAtParam": "points at param",
    "bitbybit.verb.curve.pointsAtParam_description": "Gets the points at specified parameter on the Nurbs curves",
    "bitbybit.verb.curve.reverse": "reverse",
    "bitbybit.verb.curve.reverse_description": "Reverses the Nurbs curve",
    "bitbybit.verb.curve.split": "split",
    "bitbybit.verb.curve.split_description": "Splits the Nurbs curve in two at a given parameter",
    "bitbybit.verb.curve.tangent": "tangent",
    "bitbybit.verb.curve.tangent_description": "Tangent of the Nurbs curve at a given parameter",
    "bitbybit.verb.curve.tessellate": "tessellate",
    "tessellate": "tessellate",
    "bitbybit.verb.curve.tessellate_description": "Tessellates the Nurbs curve into a list of points",
    "bitbybit.verb.curve.transform": "transform",
    "bitbybit.verb.curve.transform_description": "Transforms the Nurbs curve",
    "bitbybit.verb.curve.transformCurves": "transform curves",
    "transformCurves": "transform curves",
    "bitbybit.verb.curve.transformCurves_description": "Transforms the Nurbs curves",
    "bitbybit.verb.curve.weights": "weights",
    "bitbybit.verb.curve.weights_description": "Weights of the Nurbs curve",
    "bitbybit.verb.curve.circle.createCircle": "circle",
    "createCircle": "circle",
    "bitbybit.verb.curve.circle.createCircle_description": "Creates the circle Nurbs curve",
    "xAxis": "x axis",
    "yAxis": "y axis",
    "bitbybit.verb.curve.circle.createArc": "arc",
    "createArc": "arc",
    "bitbybit.verb.curve.circle.createArc_description": "Creates the arc Nurbs curve",
    "minAngle": "min angle",
    "maxAngle": "max angle",
    "bitbybit.verb.curve.circle.center": "center",
    "bitbybit.verb.curve.circle.center_description": "Gets the center point of the circle or an arc",
    "bitbybit.verb.curve.circle.radius": "radius",
    "bitbybit.verb.curve.circle.radius_description": "Gets the radius of the circle or an arc",
    "bitbybit.verb.curve.circle.maxAngle": "max angle",
    "bitbybit.verb.curve.circle.maxAngle_description": "Gets the max angle of the arc in degrees",
    "bitbybit.verb.curve.circle.minAngle": "min angle",
    "bitbybit.verb.curve.circle.minAngle_description": "Gets the min angle of the arc in degrees",
    "bitbybit.verb.curve.circle.xAxis": "x axis",
    "bitbybit.verb.curve.circle.xAxis_description": "Gets the x angle of the arc",
    "bitbybit.verb.curve.circle.yAxis": "y axis",
    "bitbybit.verb.curve.circle.yAxis_description": "Gets the y angle of the arc",
    "bitbybit.verb.curve.ellipse.createEllipse": "ellipse",
    "createEllipse": "ellipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Creates the ellipse Nurbs curve",
    "bitbybit.verb.curve.ellipse.createArc": "arc",
    "bitbybit.verb.curve.ellipse.createArc_description": "Creates the ellipse arc Nurbs curve",
    "bitbybit.verb.curve.ellipse.center": "center",
    "bitbybit.verb.curve.ellipse.center_description": "Gets the center point of the ellipse or an arc",
    "bitbybit.verb.curve.ellipse.maxAngle": "max angle",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Gets the max angle of the arc in degrees",
    "bitbybit.verb.curve.ellipse.minAngle": "min angle",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Gets the min angle of the arc in degrees",
    "bitbybit.verb.curve.ellipse.xAxis": "x axis",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Gets the x angle of the arc or an ellipse",
    "bitbybit.verb.curve.ellipse.yAxis": "y axis",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Gets the y angle of the arc or an ellipse",
    "bitbybit.verb.surface.boundaries": "boundaries",
    "boundaries": "boundaries",
    "bitbybit.verb.surface.boundaries_description": "Gets the boundary edge Nurbs curves of the surface in a list",
    "bitbybit.verb.surface.createSurfaceByCorners": "surface by corners",
    "createSurfaceByCorners": "surface by corners",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Creates the surface by providing 4 points as corners",
    "point3": "point 3",
    "point4": "point 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "surface by knots control points weights",
    "createSurfaceByKnotsControlPointsWeights": "surface by knots control points weights",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Creates the Nurbs surface by providing uv knots, uv degrees, points and weights",
    "degreeU": "degree u",
    "degreeV": "degree v",
    "knotsU": "knots u",
    "knotsV": "knots v",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "surface by lofting curves",
    "createSurfaceByLoftingCurves": "surface by lofting curves",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Creates the Nurbs surface by lofting curves",
    "bitbybit.verb.surface.clone": "clone",
    "bitbybit.verb.surface.clone_description": "Clone the Nurbs surface",
    "bitbybit.verb.surface.closestParam": "closest param",
    "bitbybit.verb.surface.closestParam_description": "Finds the closest parameter on the surface from the point",
    "bitbybit.verb.surface.closestPoint": "closest point",
    "bitbybit.verb.surface.closestPoint_description": "Finds the closest point on the surface from the point",
    "bitbybit.verb.surface.controlPoints": "control points",
    "bitbybit.verb.surface.controlPoints_description": "Gets the control points on the surface",
    "bitbybit.verb.surface.degreeU": "degree u",
    "bitbybit.verb.surface.degreeU_description": "Gets the U degree of the surface",
    "bitbybit.verb.surface.degreeV": "degree v",
    "bitbybit.verb.surface.degreeV_description": "Gets the V degree of the surface",
    "bitbybit.verb.surface.derivatives": "derivatives",
    "bitbybit.verb.surface.derivatives_description": "Gets the derivatives of the surface at specified uv coordinate",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "domain u",
    "domainU": "domain u",
    "bitbybit.verb.surface.domainU_description": "Gets the U domain of the surface",
    "bitbybit.verb.surface.domainV": "domain v",
    "domainV": "domain v",
    "bitbybit.verb.surface.domainV_description": "Gets the V domain of the surface",
    "bitbybit.verb.surface.isocurve": "isocurve",
    "isocurve": "isocurve",
    "bitbybit.verb.surface.isocurve_description": "Gets the Nurbs isocurve on the surface",
    "useV": "use v",
    "bitbybit.verb.surface.isocurvesSubdivision": "isocurves subdivision",
    "isocurvesSubdivision": "isocurves subdivision",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Subdivides surface into preferred number of isocurves",
    "isocurveSegments": "isocurve segments",
    "bitbybit.verb.surface.isocurvesAtParams": "isocurves at params",
    "isocurvesAtParams": "isocurves at params",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Subdivides surface into isocurves on specified array of parameters",
    "parameters": "parameters",
    "bitbybit.verb.surface.knotsU": "knots u",
    "bitbybit.verb.surface.knotsU_description": "Gets the U knots of the surface",
    "bitbybit.verb.surface.knotsV": "knots v",
    "bitbybit.verb.surface.knotsV_description": "Gets the V knots of the surface",
    "bitbybit.verb.surface.normal": "normal",
    "bitbybit.verb.surface.normal_description": "Gets the normal on the surface at uv coordinate",
    "bitbybit.verb.surface.point": "point",
    "bitbybit.verb.surface.point_description": "Gets the point on the surface at uv coordinate",
    "bitbybit.verb.surface.reverse": "reverse",
    "bitbybit.verb.surface.reverse_description": "Reverse the Nurbs surface. This will reverse the UV origin and isocurve directions",
    "bitbybit.verb.surface.split": "split",
    "bitbybit.verb.surface.split_description": "Splits the Nurbs surface in two halfs.",
    "bitbybit.verb.surface.transformSurface": "transform surface",
    "transformSurface": "transform surface",
    "bitbybit.verb.surface.transformSurface_description": "Transforms the Nurbs surface with a given list of transformations.",
    "bitbybit.verb.surface.weights": "weights",
    "bitbybit.verb.surface.weights_description": "Gets the weights of the surface",
    "bitbybit.verb.surface.cone.create": "create",
    "cone": "cone",
    "bitbybit.verb.surface.cone.create_description": "Creates the conical Nurbs surface",
    "bitbybit.verb.surface.cone.axis": "axis",
    "bitbybit.verb.surface.cone.axis_description": "Get cone axis",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "Get cone base",
    "bitbybit.verb.surface.cone.height": "height",
    "bitbybit.verb.surface.cone.height_description": "Get cone height",
    "bitbybit.verb.surface.cone.radius": "radius",
    "bitbybit.verb.surface.cone.radius_description": "Get cone radius",
    "bitbybit.verb.surface.cone.xAxis": "x axis",
    "bitbybit.verb.surface.cone.xAxis_description": "Get cone x axis",
    "bitbybit.verb.surface.cylinder.create": "create",
    "bitbybit.verb.surface.cylinder.create_description": "Creates the cylindrical Nurbs surface",
    "bitbybit.verb.surface.cylinder.axis": "axis",
    "bitbybit.verb.surface.cylinder.axis_description": "Get cylinder axis",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "Get cylinder base",
    "bitbybit.verb.surface.cylinder.height": "height",
    "bitbybit.verb.surface.cylinder.height_description": "Get cylinder height",
    "bitbybit.verb.surface.cylinder.radius": "radius",
    "bitbybit.verb.surface.cylinder.radius_description": "Get cylinder radius",
    "bitbybit.verb.surface.cylinder.xAxis": "x axis",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Get cylinder x axis",
    "bitbybit.verb.surface.extrusion.create": "create",
    "extrusion": "extrusion",
    "bitbybit.verb.surface.extrusion.create_description": "Creates the Nurbs surface extrusion from the curve",
    "profile": "profile",
    "bitbybit.verb.surface.extrusion.direction": "direction",
    "bitbybit.verb.surface.extrusion.direction_description": "Gets the direction vector of the extrusion",
    "bitbybit.verb.surface.extrusion.profile": "profile",
    "bitbybit.verb.surface.extrusion.profile_description": "Gets the profile Nurbs curve of the extrusion",
    "bitbybit.verb.surface.sphere.create": "create",
    "bitbybit.verb.surface.sphere.create_description": "Creates the spherical Nurbs surface",
    "bitbybit.verb.surface.sphere.radius": "radius",
    "bitbybit.verb.surface.sphere.radius_description": "Get the radius of the spherical Nurbs surface",
    "bitbybit.verb.surface.sphere.center": "center",
    "bitbybit.verb.surface.sphere.center_description": "Get the center of the spherical Nurbs surface",
    "bitbybit.verb.surface.revolved.create": "create",
    "revolved": "revolved",
    "bitbybit.verb.surface.revolved.create_description": "Creates the revolved Nurbs surface",
    "bitbybit.verb.surface.revolved.profile": "profile",
    "bitbybit.verb.surface.revolved.profile_description": "Get the profile Nurbs curve of the revolved Nurbs surface",
    "revolution": "revolution",
    "bitbybit.verb.surface.revolved.center": "center",
    "bitbybit.verb.surface.revolved.center_description": "Get the center Nurbs curve of the revolved Nurbs surface",
    "bitbybit.verb.surface.revolved.axis": "axis",
    "bitbybit.verb.surface.revolved.axis_description": "Get the rotation axis of the revolved Nurbs surface",
    "bitbybit.verb.surface.revolved.angle": "angle",
    "bitbybit.verb.surface.revolved.angle_description": "Get the angle of rotation from revolved Nurbs surface",
    "bitbybit.verb.surface.sweep.create": "create",
    "sweep": "sweep",
    "bitbybit.verb.surface.sweep.create_description": "Creates the sweep Nurbs surface",
    "rail": "rail",
    "bitbybit.verb.surface.sweep.profile": "profile",
    "bitbybit.verb.surface.sweep.profile_description": "Get the profile Nurbs curve of the swept Nurbs surface",
    "bitbybit.verb.surface.sweep.rail": "rail",
    "bitbybit.verb.surface.sweep.rail_description": "Get the rail Nurbs curve of the swept Nurbs surface",
    "bitbybit.verb.intersect.curves": "curves",
    "bitbybit.verb.intersect.curves_description": "Intersects two verb Nurbs curves together and returns intersection results",
    "firstCurve": "first curve",
    "secondCurve": "second curve",
    "bitbybit.verb.intersect.curveAndSurface": "curve and surface",
    "curveAndSurface": "curve and surface",
    "bitbybit.verb.intersect.curveAndSurface_description": "intersects curve and surface",
    "bitbybit.verb.intersect.surfaces": "surfaces",
    "bitbybit.verb.intersect.surfaces_description": "intersects two surfaces",
    "firstSurface": "first surface",
    "secondSurface": "second surface",
    "bitbybit.verb.intersect.curveCurveFirstParams": "curve curve first params",
    "curveCurveFirstParams": "curve curve first params",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Gets intersection parameters on the first curve from curve-curve intersection",
    "intersections": "intersections",
    "BaseTypes.CurveCurveIntersection[]": "base types curve curve intersection array",
    "bitbybit.verb.intersect.curveCurveSecondParams": "curve curve second params",
    "curveCurveSecondParams": "curve curve second params",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Gets intersection parameters on the second curve from curve-curve intersection",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "curve curve first points",
    "curveCurveFirstPoints": "curve curve first points",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Gets intersection points on the first curve from curve-curve intersection",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "curve curve second points",
    "curveCurveSecondPoints": "curve curve second points",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Gets intersection points on the second curve from curve-curve intersection",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "curve surface curve params",
    "curveSurfaceCurveParams": "curve surface curve params",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Gets intersection parameters on the curve from curve-surface intersection",
    "BaseTypes.CurveSurfaceIntersection[]": "base types curve surface intersection array",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "curve surface surface params",
    "curveSurfaceSurfaceParams": "curve surface surface params",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Gets intersection parameters on the surface from curve-surface intersection",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "curve surface curve points",
    "curveSurfaceCurvePoints": "curve surface curve points",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Gets intersection points on the curve from curve-surface intersection",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "curve surface surface points",
    "curveSurfaceSurfacePoints": "curve surface surface points",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Gets intersection points on the surface from curve-surface intersection",
    "bitbybit.tag.create": "create",
    "tag": "tag",
    "bitbybit.tag.create_description": "Creates a tag dto",
    "adaptDepth": "adapt depth",
    "needsUpdate": "needs update",
    "bitbybit.time.registerRenderFunction": "register render function",
    "registerRenderFunction": "register render function",
    "bitbybit.time.registerRenderFunction_description": "Registers a function to render loop",
    "bitbybit.asset.getFile": "get file",
    "asset": "asset",
    "getFile": "get file",
    "bitbybit.asset.getFile_description": "Gets the asset file",
    "bitbybit.asset.getLocalFile": "get local file",
    "getLocalFile": "get local file",
    "bitbybit.asset.getLocalFile_description": "Gets the local asset file stored in your browser.",
    "bitbybit.asset.fetchBlob": "fetch blob",
    "fetchBlob": "fetch blob",
    "bitbybit.asset.fetchBlob_description": "Fetches the blob from the given url, must be CORS enabled accessible endpoint",
    "fetch": "fetch",
    "bitbybit.asset.fetchFile": "fetch file",
    "fetchFile": "fetch file",
    "bitbybit.asset.fetchFile_description": "Fetches the file from the given url, must be CORS enabled accessible endpoint",
    "bitbybit.asset.fetchJSON": "fetch json",
    "fetchJSON": "fetch json",
    "bitbybit.asset.fetchJSON_description": "Fetches the json from the given url, must be CORS enabled accessible endpoint",
    "bitbybit.asset.fetchText": "fetch text",
    "fetchText": "fetch text",
    "bitbybit.asset.fetchText_description": "Fetches the json from the given url, must be CORS enabled accessible endpoint",
    "bitbybit.asset.createObjectURL": "object url",
    "createObjectURL": "object url",
    "bitbybit.asset.createObjectURL_description": "Gets and creates the url string path to your file stored in your memory.",
    "file": "file",
    "File | Blob": "file or blob",
    "bitbybit.asset.createObjectURLs": "object urls",
    "createObjectURLs": "object urls",
    "bitbybit.asset.createObjectURLs_description": "Gets and creates the url string paths to your files stored in your memory.",
    "files": "files",
    "(File | Blob)[]": "file or blob array",
    "exec": "exec",
    "Visible": "Visible",
    "Hidden": "Hidden",
    "flatten": "flatten",
    "force exec": "force exec",
    "console log": "console log",
    "preview data": "preview data",
    "flow": "flow",
    "code": "code",
    "runner": "runner",
    "counters": "counters",
    "actions": "actions",
    "loops": "loops",
    "interval": "interval",
    "delay": "delay",
    "expire": "expire",
    "timeout": "timeout",
    "counter min max": "counter min max",
    "counter steps": "counter steps",
    "reset": "reset",
    "trigger": "trigger",
    "mouse": "mouse",
    "mouse click": "mouse click",
    "key": "key",
    "pointer": "pointer",
    "pick info": "pick info",
    "down": "down",
    "wheel": "wheel",
    "tap": "tap",
    "double tap": "double tap",
    "render": "render",
    "passed ms": "passed ms",
    "babylon observable listener": "babylon observable listener",
    "object": "object",
    "observable selector": "observable selector",
    "get event data": "get event data",
    "exec click": "exec click",
    "exec down": "exec down",
    "toggle": "toggle",
    "flip flop": "flip flop",
    "boolean gate": "boolean gate",
    "boolean gate silent": "boolean gate silent",
    "is undefined": "is undefined",
    "for loop": "for loop",
    "last": "last",
    "for each loop": "for each loop",
    "element": "element",
    "body": "body",
    "complete": "complete",
    "editors": "editors",
    "inputs": "inputs",
    "outputs": "outputs",
    "recent": "recent",
    "Clear": "Clear",
    "Run": "Run",
    "Swap Canvas": "Swap Canvas",
    "Local Assets": "Local Assets",
    "Import": "Import",
    "Export": "Export",
    "Copy to Clipboard": "Copy to Clipboard",
    "Paste from Clipboard": "Paste from Clipboard",
    "Export to runner": "Export to runner",
    "Clean Cache": "Clean Cache",
    "Community": "Community",
    "Sponsors and Partners": "Sponsors and Partners",
    "API Documentation": "API Documentation",
    "About": "About",
    "Toolbox": "Toolbox",
    "More": "More",
    "bitbybit.code.typeScriptEditor": "typescript editor",
    "bitbybit.code.typeScriptEditor_description": "Allows to write TypeScript code with full bitbybit intellisense in one function. Whatever start function returns it will be seen as an output of the component.",
    "bitbybit.code.javaScriptEditor": "javascript editor",
    "bitbybit.code.javaScriptEditor_description": "Allows to write JavaScript code in one function. Whatever start function returns it will be seen as an output of the component.",
    "bitbybit.code.jsonEditor": "json editor",
    "bitbybit.code.jsonEditor_description": "Allows to write JSON code. Whatever start function returns it will be seen as an output of the component.",
    "bitbybit.flow.actions.keyboard": "keyboard",
    "bitbybit.flow.actions.keyboard_description": "Will execute on keyboard events by clicking the buttons.",
    "bitbybit.flow.actions.mouseClick": "mouse click",
    "bitbybit.flow.actions.mouseClick_description": "Will execute on mouse events by clicking the buttons.",
    "bitbybit.flow.actions.start": "start",
    "bitbybit.flow.actions.start_description": "Starts the control flow and triggers executions.",
    "bitbybit.flow.actions.trigger": "trigger",
    "bitbybit.flow.actions.trigger_description": "Triggers the execution by clicking the button.",
    "bitbybit.flow.babylon.gui.button": "button",
    "bitbybit.flow.babylon.gui.button_description": "Will execute on various pointer events by clicking the left mouse button on babylonjs canvas.",
    "bitbybit.flow.babylon.scene.pointerEvents": "pointer",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Will execute on various pointer events by clicking the left mouse button on babylonjs canvas.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "get event data",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Gets event data from observed result of the observable listener.",
    "bitbybit.flow.babylon.observableListener": "babylon observable listener",
    "bitbybit.flow.babylon.observableListener_description": "Will subscribe and listen to any of the babylonjs observables.",
    "bitbybit.flow.babylon.render": "render",
    "bitbybit.flow.babylon.render_description": "Executes on each babylonjs render frame.",
    "bitbybit.flow.counters.counterMinMax": "counter min max",
    "bitbybit.flow.counters.counterMinMax_description": "Counts the number of flow executions between min and max values. When max is reached it resets",
    "bitbybit.flow.counters.counterSteps": "counter steps",
    "bitbybit.flow.counters.counterSteps_description": "Counts the number of flow executions by starting on given count value and increasing at each execution by given step from the list, till steps are finished. When end is reached it resets",
    "bitbybit.flow.counters.counter": "counter",
    "bitbybit.flow.counters.counter_description": "Counts the number of flow executions.",
    "bitbybit.flow.logic.booleanGateSilent": "boolean gate silent",
    "bitbybit.flow.logic.booleanGateSilent_description": "Triggers different execution events based on the value of boolean provided, but executes only when boolean changes its value, this prevents from multiple events firing constantly even though no change happened.",
    "bitbybit.flow.logic.booleanGate": "boolean gate",
    "bitbybit.flow.logic.booleanGate_description": "Triggers different execution events based on the value of boolean provided.",
    "bitbybit.flow.logic.flipFlop": "flip flop",
    "bitbybit.flow.logic.flipFlop_description": "Every time an event is executed a different event will fire, in essence creating a toggle functionality.",
    "bitbybit.flow.logic.isUndefined": "is undefined",
    "bitbybit.flow.logic.isUndefined_description": "Checks whether the value provided is undefined and triggers true or false event.",
    "bitbybit.flow.loops.forEach": "for each loop",
    "bitbybit.flow.loops.forEach_description": "For each loop that walks through all the elements in the list.",
    "bitbybit.flow.loops.for": "for loop",
    "bitbybit.flow.loops.for_description": "For loop that executes body between two values.",
    "bitbybit.flow.time.delay": "delay",
    "bitbybit.flow.time.delay_description": "Delays execution by given timeout in ms.",
    "bitbybit.flow.time.interval": "interval",
    "bitbybit.flow.time.interval_description": "Executes the flow every given interval in ms.",
    "bitbybit.lists.createList": "create list",
    "bitbybit.lists.createList_description": "Creates a list from the given elements.",
    "bitbybit.lists.flatten": "flatten",
    "bitbybit.lists.flatten_description": "Flattens the list of lists into a single list.",
    "bitbybit.lists.passThrough": "pass through",
    "bitbybit.lists.passThrough_description": "Casts value to 'any' type and passes the input to output without any changes.",
    "bitbybit.math.numberSlider": "number slider",
    "bitbybit.math.numberSlider_description": "Creates a number with a slider. You can set up min, mac and step values.",
    "bitbybit.consoleLog": "console log",
    "bitbybit.consoleLog_description": "Logs the input to the browser console.",
    "bitbybit.previewData": "preview data",
    "bitbybit.previewData_description": "Shows the input data in a preview overview area. It can be text, numbers, json objects, arrays, etc. Circular Javascript objects not allowed.",
    "bitbybit.runner.getRunnerInputValue": "get runner input value",
    "bitbybit.runner.getRunnerInputValue_description": "Get the runner input value from the inputs JSON. This component will always return an undefined value in the editor context.",
    "bitbybit.runner.getRunnerInputs": "get runner inputs",
    "bitbybit.runner.getRunnerInputs_description": "Get the runner inputs in JSON. This component will always return empty object in the editor context.",
    "bitbybit.runner.run": "run",
    "bitbybit.runner.run_description": "Runs runner javascript code",
    "bitbybit.runner.setRunnerResult": "set runner result",
    "bitbybit.runner.setRunnerResult_description": "Sets the complete JSON result for the runner. Keep in mind that it is safer to set values as this method will overwrite the whole result object with the value provided.",
    "bitbybit.runner.setRunnerResultArrayValue": "set runner result array value",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Sets the runner result value on the proiperty of JSON object. Each value will be added to an array, that is the value of the property.",
    "bitbybit.runner.setRunnerResultValue": "set runner result value",
    "bitbybit.runner.setRunnerResultValue_description": "Sets the runner result value on the proiperty of JSON object.",
    "bitbybit.text.areaCreate": "text area",
    "bitbybit.text.areaCreate_description": "Creates a text area in the editor. You can set up the text, width and height of the area.",
    "update on drag": "update on drag",
    "paste": "paste",
    "duplicate": "duplicate",
    "delete": "delete",
    "keyboard": "keyboard",
    "data": "data",
    "observables": "observables",
    "buttons": "buttons",
    "variables": "variables",
    "functions": "functions",
    "loop": "loop",
    "apply": "apply",
    "async context": "async context",
    "async context description": "Create asynchronous context that can use await components, simplifying asynchronous code execution and readability.",
    "then": "then",
    "await": "await",
    "await description": "Waits for the promise to be resolved and returns the value.",
    "when the": "when the",
    "error": "error",
    "happens in the promise": "happens in the promise",
    "catch": "catch",
    "catch description": "Catches the error that may happen while running asynchronous code. User can choose to handle errors appropriately.",
    "cancel the interval execution": "cancel the interval execution",
    "cancel the interval description": "Cancels the interval execution by providing the handler.",
    "cancel the timeout execution": "cancel the timeout execution",
    "cancel the timeout description": "Cancels the timeout execution by providing the handler.",
    "key down": "key down",
    "key down descritpion": "Triggeres code when key down event happens.",
    "key up": "key up",
    "key up description": "Triggeres code when key up event happens.",
    "key press": "key press",
    "key press description": "Triggeres code when key press event happens.",
    "is key pressed": "is key pressed",
    "block_validation_required": "must be provided",
    "block_validation_of_length": "must contain item count of",
    "block_validation_higher_or_equal": "must be higher or equal to",
    "block_validation_lower_or_equal": "must be lower or equal to",
    "block_validation_range": "must be in range",
    "block_validation_smaller_than": "must be smaller than",
    "block_validation_smaller_or_equal_than": "must be smaller or equal than",
    "block_validation_larger_than": "must be larger than",
    "block_validation_larger_or_equal_than": "must be larger or equal than",
    "save text to file": "save text to file",
    "save text to file description": "Saves text to a file and allows you to choose the name and extension. This component does not preview the text and can be used in situations where text may be too big to edit in text area field.",
    "print text on screen": "print text on screen",
    "print text on screen description": "Prints text on screen. This component is useful for debugging purposes.",
    "preview text and save to file": "preview text and save to file",
    "preview text and save to file description": "Prints text on screen and allows you to save it to a file. This component is useful for debugging purposes.",
    "register render loop listener": "register render loop listener",
    "and update": "and update",
    "register render loop listener description": "Runs the statment in the render loop and indicates how much time has passed since last frame in timeElapsedFromPreviousFrame variable.",
    "timeElapsedFromPreviousFrame_var": "timeElapsedFromPreviousFrame",
    "computing": "computing",
    "result": "result",
    "of promise is returned": "of promise is returned",
    "on pointer up": "on pointer up",
    "on pointer move": "on pointer move",
    "on pointer down": "on pointer down",
    "of babylonjs observable object": "of babylonjs observable object",
    "observable name": "observable name",
    "is key pressed description": "Checks whether the key is pressed and returns true or false.",
    "execute code after": "execute code after",
    "execute code after description": "Executes the code after given timeout in seconds.",
    "execute code every": "execute code every",
    "second(s)": "second(s)",
    "execute code every description": "Executes the code every given interval in seconds.",
    "handler": "handler",
    "workers initialising": "workers initialising",
    "Assets": "Assets",
    "Local assets stored in browser cache:": "Local assets stored in browser cache:",
    "Asset Name": "Asset Name",
    "Name is required": "Name is required",
    "Asset with this name already exists, choose a different one": "Asset with this name already exists, choose a different one",
    "Allowed file formats:": "Allowed file formats:",
    "You must select an asset file": "You must select an asset file",
    "Upload Local Asset": "Upload Local Asset",
    "File Name": "File Name",
    "File Size": "File Size",
    "Your browser does not support indexDB and you can't upload local asset files.": "Your browser does not support indexDB and you can't upload local asset files.",
    "Upload": "Upload",
    "elements": "elements",
    "bitbybit.vector.vectorsTheSame": "vectors the same",
    "vectorsTheSame": "vectors the same",
    "bitbybit.vector.vectorsTheSame_description": "Checks if two vectors are the same within a given tolerance (accounts for floating point precision). Example: [1,2,3] vs [1.0001,2.0001,3.0001] with tolerance 0.001  true",
    "vec1": "vector 1",
    "vec2": "vector 2",
    "bitbybit.point.boundingBoxOfPoints": "bounding box of points",
    "boundingBoxOfPoints": "bounding box of points",
    "bitbybit.point.boundingBoxOfPoints_description": "Calculates axis-aligned bounding box containing all points (min, max, center, width, height, length). Example: points=[[0,0,0], [10,5,3]]  {min:[0,0,0], max:[10,5,3], center:[5,2.5,1.5], width:10, height:5, length:3}",
    "bitbybit.point.normalFromThreePoints": "normal from three points",
    "normalFromThreePoints": "normal from three points",
    "bitbybit.point.normalFromThreePoints_description": "Calculates normal vector from three points using cross product (perpendicular to plane). Example: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0]  [0,0,1] (pointing up from XY plane)",
    "reverseNormal": "reverse normal",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "line wire with extensions",
    "createLineWireWithExtensions": "line wire with extensions",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Creates OpenCascade line wire with extensions",
    "extensionStart": "ext start",
    "extensionEnd": "ext end",
    "bitbybit.occt.shapes.wire.midPointOnWire": "mid point on wire",
    "midPointOnWire": "mid point on wire",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Computes the middle point on the wire at param 0.5",
    "centerOnOrigin": "center on origin",
    "bitbybit.occt.shapes.wire.textWiresWithData": "text wires with data",
    "textWiresWithData": "text wires with data",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Creates OpenCascade compound out of text wires and returns additional information based on simplex font created by Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "align normal and axis",
    "alignNormAndAxis": "align normal and axis",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Align the shape with normal and axis",
    "fromNorm": "from normal",
    "fromAx": "from axis",
    "toNorm": "to normal",
    "toAx": "to axis",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "simple linear length dimension",
    "simpleLinearLengthDimension": "simple linear length dimension",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Creates simple linear length dimension between two points - measuring units. You decide what kind of units you re using by providing a suffix.",
    "offsetFromPoints": "offset from points",
    "crossingSize": "crossing size",
    "labelSuffix": "label suffix",
    "labelSize": "label size",
    "labelOffset": "label offset",
    "bitbybit.occt.dimensions.simpleAngularDimension": "simple angular dimension",
    "simpleAngularDimension": "simple angular dimension",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Creates simple angular dimension. By default we output degrees, but you can opt to use radians.",
    "direction1": "direction 1",
    "direction2": "direction 2",
    "offsetFromCenter": "offset from center",
    "extraSize": "extra size",
    "radians": "radians",
    "bitbybit.occt.dimensions.pinWithLabel": "pin with label",
    "pinWithLabel": "pin with label",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Creates pin label. It can be used to explain things about the models or mark things in the 3D scene.",
    "offsetFromStart": "offset from start",
    "bitbybit.vector.lengthSq": "length squared",
    "lengthSq": "length squared",
    "bitbybit.vector.lengthSq_description": "Computes the squared length (squared magnitude) of a 3D vector. Example: [3,4,0]  25 (length 5 squared)",
    "bitbybit.point.twoPointsAlmostEqual": "two points equal",
    "twoPointsAlmostEqual": "two points equal",
    "bitbybit.point.twoPointsAlmostEqual_description": "Checks if two points are approximately equal within tolerance (distance-based comparison). Example: point1=[1.0000001, 2.0, 3.0], point2=[1.0, 2.0, 3.0], tolerance=1e-6  true",
    "bitbybit.line.lineToSegment": "line to segment",
    "lineToSegment": "line to segment",
    "bitbybit.line.lineToSegment_description": "Converts line object to segment array format. Example: {start:[0,0,0], end:[10,5,0]}  [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "lines to segments",
    "linesToSegments": "lines to segments",
    "bitbybit.line.linesToSegments_description": "Converts multiple line objects to segment array format (batch conversion). Example: 3 line objects  3 segment arrays [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "segment to line",
    "segmentToLine": "segment to line",
    "bitbybit.line.segmentToLine_description": "Converts segment array to line object format. Example: [[0,0,0], [10,5,0]]  {start:[0,0,0], end:[10,5,0]}",
    "segment": "segment",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segments to lines",
    "segmentsToLines": "segments to lines",
    "bitbybit.line.segmentsToLines_description": "Converts multiple segment arrays to line object format (batch conversion). Example: 3 segment arrays  3 line objects with startend properties",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "sort segments to polylines",
    "sortSegmentsIntoPolylines": "sort segments to polylines",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Sorts scrambled segments into connected polylines by matching endpoints. Uses spatial hashing for efficient connection finding. Example: 10 random segments that form 2 connected paths  2 polylines",
    "sort": "sort",
    "bitbybit.mesh.signedDistanceToPlane": "signed distance to plane",
    "signedDistanceToPlane": "signed distance to plane",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calculates signed distance from a point to a plane (positive=above plane, negative=below). Example: point=[0,5,0], plane={normal:[0,1,0], d:0}  5 (point is 5 units above XZ plane)",
    "plane": "plane",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calculate triangle plane",
    "calculateTrianglePlane": "calculate triangle plane",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calculates plane equation from triangle vertices (normal vector and distance from origin). Returns undefined if triangle is degenerate (zero area, collinear points). Example: triangle=[[0,0,0], [1,0,0], [0,1,0]]  {normal:[0,0,1], d:0} (XY plane)",
    "triangle": "triangle",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "triangle triangle intersection",
    "triangleTriangleIntersection": "triangle triangle intersection",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calculates intersection segment of two triangles (line segment where they cross). Returns undefined if triangles don't intersect, are parallel, or are coplanar. Example: triangle1=[[0,0,0], [2,0,0], [1,2,0]], triangle2=[[1,-1,1], [1,1,1], [1,1,-1]]  [[1,0,0], [1,1,0]]",
    "triangle1": "triangle 1",
    "triangle2": "triangle 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "mesh mesh intersection segments",
    "meshMeshIntersectionSegments": "mesh mesh intersection segments",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calculates all intersection segments between two triangle meshes (pairwise triangle tests). Returns array of line segments where mesh surfaces intersect. Example: cube mesh intersecting with sphere mesh  multiple segments forming intersection curve",
    "mesh1": "mesh 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "mesh 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "mesh mesh intersection polylines",
    "meshMeshIntersectionPolylines": "mesh mesh intersection polylines",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calculates intersection polylines between two meshes by sorting segments into connected paths. Segments are joined end-to-end to form continuous or closed curves. Example: cube-sphere intersection  closed polyline loops where surfaces meet",
    "bitbybit.occt.shapeFacesToPolygonPoints": "shape faces to polygon points",
    "shapeFacesToPolygonPoints": "shape faces to polygon points",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Creates polygon points from the shape faces",
    "reversedPoints": "reversed points",
    "bitbybit.occt.shapeToMesh": "shape to mesh",
    "shapeToMesh": "shape to mesh",
    "bitbybit.occt.shapeToMesh_description": "Creates mesh from the shape",
    "bitbybit.occt.shapesToMeshes": "shapes to meshes",
    "shapesToMeshes": "shapes to meshes",
    "bitbybit.occt.shapesToMeshes_description": "Creates mesh from the shape",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "from polygon points",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Create a Manifold from a set of polygon points describing triangles.",
    "traingle": "traingle",
    "bitbybit.point.stretchPointsDirFromCenter": "stretch points dir from center",
    "stretchPointsDirFromCenter": "stretch points dir from center",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Stretches multiple points along a direction from a center point (directional scaling). Example: points=[[10,0,0]], center=[0,0,0], direction=[1,0,0], scale=2  [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "hex grid scaled to fit",
    "hexGridScaledToFit": "hex grid scaled to fit",
    "bitbybit.point.hexGridScaledToFit_description": "Creates hexagonal grid scaled to fit within specified widthheight bounds (auto-calculates hex size). Returns center points and hex vertices. Supports pointy-top or flat-top orientation. Example: width=10, height=10, nrHexagonsInHeight=3  hex grid filling 1010 area with 3 rows",
    "nrHexagonsU": "nr hexagons u",
    "nrHexagonsV": "nr hexagons v",
    "extendTop": "extend top",
    "extendBottom": "extend bottom",
    "extendLeft": "extend left",
    "extendRight": "extend right",
    "centerGrid": "center grid",
    "bitbybit.point.sortPoints": "sort points",
    "sortPoints": "sort points",
    "bitbybit.point.sortPoints_description": "Sorts points lexicographically (by X, then Y, then Z coordinates). Example: [[5,0,0], [1,0,0], [3,0,0]]  [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "line line intersection",
    "lineLineIntersection": "line line intersection",
    "bitbybit.line.lineLineIntersection_description": "Calculates intersection point of two lines (or segments if checkSegmentsOnly=true). Returns undefined if lines are parallel, skew, or segments don't overlap. Example: line1={start:[0,0,0], end:[10,0,0]}, line2={start:[5,-5,0], end:[5,5,0]}  [5,0,0]",
    "line1": "line 1",
    "line2": "line 2",
    "checkSegmentsOnly": "check segments only",
    "bitbybit.polyline.polylineToLines": "polyline to lines",
    "polylineToLines": "polyline to lines",
    "bitbybit.polyline.polylineToLines_description": "Converts polyline to line segments (each segment as line object with startend). Closed polylines include closing segment. Example: 3 points  2 or 3 lines (depending on isClosed)",
    "bitbybit.polyline.polylineToSegments": "polyline to segments",
    "polylineToSegments": "polyline to segments",
    "bitbybit.polyline.polylineToSegments_description": "Converts polyline to segment arrays (each segment as [point1, point2]). Closed polylines include closing segment if endpoints differ. Example: 4 points, closed  4 segments connecting all points in a loop",
    "bitbybit.polyline.polylineSelfIntersection": "polyline self intersection",
    "polylineSelfIntersection": "polyline self intersection",
    "bitbybit.polyline.polylineSelfIntersection_description": "Finds points where polyline crosses itself (self-intersection points). Skips adjacent segments and deduplicates close points. Example: figure-8 shaped polyline  returns center crossing point",
    "bitbybit.polyline.twoPolylineIntersection": "two polyline intersection",
    "twoPolylineIntersection": "two polyline intersection",
    "bitbybit.polyline.twoPolylineIntersection_description": "Finds intersection points between two polylines (all segment-segment crossings). Tests all segment pairs and deduplicates close points. Example: crossing polylines forming an X  returns center intersection point",
    "polyline1": "polyline 1",
    "polyline2": "polyline 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdivide to hexagon wires",
    "subdivideToHexagonWires": "subdivide to hexagon wires",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivides a face to hexagon wires",
    "extendUUp": "extend u up",
    "extendUBottom": "extend u bottom",
    "extendVUp": "extend v up",
    "extendVBottom": "extend v bottom",
    "nrHexagonsInHeight": "nr hexagons in height",
    "nrHexagonsInWidth": "nr hexagons in width",
    "bitbybit.vector.length": "vector length",
    "bitbybit.vector.length_description": "Computes the length (magnitude) of a 3D vector. Example: [3,4,0]  5, [1,0,0]  1",
    "bitbybit.point.maxFilletRadius": "max fillet radius",
    "maxFilletRadius": "max fillet radius",
    "bitbybit.point.maxFilletRadius_description": "Calculates the maximum possible fillet radius at a corner formed by two line segments sharing an endpoint (C), such that the fillet arc is tangent to both segments and lies entirely within them.",
    "bitbybit.point.maxFilletRadiusHalfLine": "max fillet radius half line",
    "maxFilletRadiusHalfLine": "max fillet radius half line",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calculates the maximum possible fillet radius at a corner C, such that the fillet arc is tangent to both segments (P1-C, P2-C) and the tangent points lie within the first half of each segment (measured from C).",
    "bitbybit.point.maxFilletsHalfLine": "max fillets half line",
    "maxFilletsHalfLine": "max fillets half line",
    "bitbybit.point.maxFilletsHalfLine_description": "Calculates the maximum possible fillet radius at each corner of a polyline formed by formed by a series of points. The fillet radius is calculated for each internal corner and optionally for the closing corners if the polyline is closed.",
    "checkLastWithFirst": "check last with first",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "safest points max fillet half line",
    "safestPointsMaxFilletHalfLine": "safest points max fillet half line",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calculates the single safest maximum fillet radius that can be applied uniformly to all corners of collection of points, based on the 'half-line' constraint. This is determined by finding the minimum of the maximum possible fillet radii calculated for each individual corner.",
    "bitbybit.polyline.maxFilletsHalfLine": "max fillets half line",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calculates the maximum possible half-line fillet radius for each corner of a given polyline. For a closed polyline, it includes the corners connecting the last segment back to the first. The calculation uses the 'half-line' constraint, meaning the fillet's tangent points must lie within the first half of each segment connected to the corner.",
    "bitbybit.polyline.safestFilletRadius": "safest fillet radius",
    "safestFilletRadius": "safest fillet radius",
    "bitbybit.polyline.safestFilletRadius_description": "Calculates the single safest maximum fillet radius that can be applied uniformly to all corners of a polyline, based on the 'half-line' constraint. This is determined by finding the minimum of the maximum possible fillet radii calculated for each individual corner.",
    "flatTop": "flat top",
    "bitbybit.mesh.meshMeshIntersectionPoints": "mesh mesh intersection points",
    "meshMeshIntersectionPoints": "mesh mesh intersection points",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calculates intersection points between two meshes as point arrays (one array per polyline). Closed polylines have first point duplicated at end. Example: cube-sphere intersection  arrays of points defining intersection curves",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexagons in grid",
    "hexagonsInGrid": "hexagons in grid",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Creates OpenCascade hexagon wires in grid",
    "scalePatternWidth": "scale pattern width",
    "scalePatternHeight": "scale pattern height",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "mesh mesh intersection wires",
    "meshMeshIntersectionWires": "mesh mesh intersection wires",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Does mesh mesh intersection operation between two shapes - both shapes can have their own  meshing precision. This algorithm intersects the meshes and returns the wires of the intersection, which are polylines or polygons.",
    "mesh based": "mesh based",
    "precision1": "precision 1",
    "precision2": "precision 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "mesh mesh intersection points",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Does mesh mesh intersection operation between two shapes - both shapes can have their own  meshing precision. This algorithm intersects the meshes and returns the points of the intersection, which are polylines or polygons.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "mesh mesh intersection to wires",
    "meshMeshIntersectionOfShapesWires": "mesh mesh intersection to wires",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Does mesh mesh intersection operation between the shape and multiple other shapes - all shapes can have their own meshing precision. This algorithm intersects the meshes and returns the wires of the intersection, which are polylines or polygons.",
    "precisionShapes": "precision shapes",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "mesh mesh intersection to points",
    "meshMeshIntersectionOfShapesPoints": "mesh mesh intersection to points",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Does mesh mesh intersection operation between the shape and multiple other shapes - all shapes can have their own meshing precision. This algorithm intersects the meshes and returns the points of the intersection.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexagons in grid",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Creates OpenCascade hexagons in grid",
    "bitbybit.jscad.toPolygonPoints": "to polygon points",
    "toPolygonPoints": "to polygon points",
    "bitbybit.jscad.toPolygonPoints_description": "Converts the Jscad mesh to polygon points representing triangles of the mesh.",
    "conversions": "conversions",
    "bitbybit.manifold.toPolygonPoints": "to polygon points",
    "bitbybit.manifold.toPolygonPoints_description": "Turns manifold shape into a collection of polygon points representing the mesh.",
    "flatU": "flat u",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdivide to hexagon holes",
    "subdivideToHexagonHoles": "subdivide to hexagon holes",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivides a face to hexagon holes",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "convert lines to nurbs curves",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Converts lines to NURBS curves Returns array of the verbnurbs Line objects",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "convert line to nurbs curve",
    "convertLineToNurbsCurve": "convert line to nurbs curve",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Converts line to NURBS curve Returns the verbnurbs Line object",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "convert polyline to nurbs curve",
    "convertPolylineToNurbsCurve": "convert polyline to nurbs curve",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Converts a polyline to a NURBS curve Returns the verbnurbs NurbsCurve object",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "convert polylines to nurbs curves",
    "convertPolylinesToNurbsCurves": "convert polylines to nurbs curves",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Converts a polylines to a NURBS curves Returns the verbnurbs NurbsCurve objects",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segment",
    "createSegment": "segment",
    "bitbybit.line.createSegment_description": "Creates a segment from two points (array format: [start, end]). Example: start=[0,0,0], end=[10,5,0]  [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "edge from base line",
    "fromBaseLine": "from base line",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Creates linear edge from base line format {start: Point3, end: Point3}",
    "from base": "from base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "edge from base lines",
    "fromBaseLines": "from base lines",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Creates linear edges from base lines format {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "edge from base segment",
    "fromBaseSegment": "from base segment",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Creates linear edge from base segment format [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "edges from base segments",
    "fromBaseSegments": "from base segments",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Creates linear edge from base segments format [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "edges from points",
    "fromPoints": "fromPoints",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Creates linear edges from collection of points",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "edges from base polyline",
    "fromBasePolyline": "from base polyline",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Creates linear edges from polyline definition",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "edges from base triangle",
    "fromBaseTriangle": "from base triangle",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Creates linear edges from triangle definition",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "edges from base mesh",
    "fromBaseMesh": "edges from base mesh",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Creates linear edges from mesh definition",
    "bitbybit.occt.shapes.wire.fromBaseLine": "wire from base line",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Creates linear wire from base line format {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "wires from base lines",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Creates linear wires from base lines format {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "wire from base segment",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Creates linear wire from base segment format [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "wires from base segments",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Creates linear wires from base segments format [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "wire from points",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Creates wire from collection of points",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "wire from base polyline",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Creates wire from polyline definition",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "wire from base triangle",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Creates wire from triangle definition",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "wires from base mesh",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Creates wires from mesh definition",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "face from base triangle",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Creates face from triangle definition",
    "bitbybit.occt.shapes.face.fromBaseMesh": "faces from base mesh",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Creates faces from mesh definition",
    "fromRightHanded": "from right handed",
    "bitbybit.advanced.text3d.createWithUrl": "text with url",
    "createWithUrl": "text with url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Creates a 3d text with a font URL This is useful when you want to use a custom font that is not included in the library. The font will be loaded from the provided URL and used to generate the 3d text. Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts. Font formats supported are: ttf, otf, woff. Please note that Woff2 is not supported by opentype.js as it is a compressed format.",
    "fontUrl": "font url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "text on face url",
    "createTextOnFaceUrl": "text on face url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Creates a 3d text on the face using a font URL. This is useful when you want to use a custom font that is not included in the library. The font will be loaded from the provided URL and used to generate the 3d text. Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts. Font formats supported are: ttf, otf, woff. Please note that Woff2 is not supported by opentype.js as it is a compressed format.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "texts on face url",
    "createTextsOnFaceUrl": "texts on face url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Creates 3d texts on the face from multiple url definitions This is useful when you want to use a custom font that is not included in the library. The font will be loaded from the provided URL and used to generate the 3d text. Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts. Font formats supported are: ttf, otf, woff. Please note that Woff2 is not supported by opentype.js as it is a compressed format.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "definition 3d text on face url",
    "definition3dTextOnFaceUrl": "definition 3d text on face url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Creates 3d text that will be used on the face url defintion This is useful when you want to use a custom font that is not included in the library. The font will be loaded from the provided URL and used to generate the 3d text. Make sure that fonts do not contain self intersection and other bad characters - that is common issue with custom fonts. Font formats supported are: ttf, otf, woff. Please note that Woff2 is not supported by opentype.js as it is a compressed format.",
    "bitbybit.advanced.navigation.pointOfInterest": "point of interest",
    "navigation": "navigation",
    "pointOfInterest": "point of interest",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Creates point of interest - clickable indicator in 3D space that can be used to fly the camera to a specific location with predefined camera position and target. Point of interest can be styled with PointOfInterestStyleDto and animated with pulse effect. Point of interest can also have a text label.",
    "cameraTarget": "camera target",
    "cameraPosition": "camera position",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "points of interest system",
    "pointsOfInterestSystem": "points of interest system",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "points of interest",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "point of interest",
    "style": "style",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "point of interest style",
    "pointOfInterestStyle": "point of interest style",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Create point of interest style - used to style point of interest indicators in 3D space. You can customize point size, color, hover color, pulse effect, text label color and size.",
    "pointSize": "point size",
    "pointColor": "point color",
    "hoverPointColor": "hover point color",
    "pulseColor": "pulse color",
    "hoverPulseColor": "hover pulse color",
    "pulseMinSize": "pulse min size",
    "pulseMaxSize": "pulse max size",
    "pulseThickness": "pulse thickness",
    "pulseSpeed": "pulse speed",
    "textColor": "text color",
    "hoverTextColor": "hover text color",
    "textSize": "text size",
    "hideSkybox": "hide skybox",
    "textureUrl": "texture url",
    "hdrTexture": "hdr texture",
    "textureSize": "texture size",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "enable skybox custom texture",
    "enableSkyboxCustomTexture": "enable skybox custom texture",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Enables skybox with custom texture",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "canvas css background image",
    "canvasCSSBackgroundImage": "canvas css background image",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Changes the scene background to a css background image for 3D space",
    "cssBackgroundImage": "css background image",
    "bitbybit.babylon.scene.twoColorLinearGradient": "two color linear gradient",
    "twoColorLinearGradient": "two color linear gradient",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Creates a two-color linear gradient background for 3D space",
    "colorFrom": "color from",
    "colorTo": "color to",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "stop from",
    "stopTo": "stop to",
    "bitbybit.babylon.scene.twoColorRadialGradient": "two color radial gradient",
    "twoColorRadialGradient": "two color radial gradient",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Creates a two-color radial gradient background for 3D space",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "multi color linear gradient",
    "multiColorLinearGradient": "multi color linear gradient",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Creates a multi-color linear gradient background for 3D space",
    "Base.Color[]": "Base.Color[]",
    "stops": "stops",
    "bitbybit.babylon.scene.multiColorRadialGradient": "multi color radial gradient",
    "multiColorRadialGradient": "multi color radial gradient",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Creates a multi-color radial gradient background for 3D space",
    "bitbybit.babylon.scene.canvasBackgroundImage": "canvas background image",
    "canvasBackgroundImage": "canvas background image",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Sets a background image with various customization options for 3D space",
    "imageUrl": "image url",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "attachment",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "clip",
    "labelRotation": "label rotation",
    "bitbybit.advanced.dimensions.linearDimension": "linear dimension",
    "linearDimension": "linear dimension",
    "bitbybit.advanced.dimensions.linearDimension_description": "Creates linear dimension - a measurement line between two points with extension lines and text label. The dimension shows the distance between the points and can be styled with DimensionStyleDto.",
    "linear dimension": "linear dimension",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "angular dimension",
    "angularDimension": "angular dimension",
    "bitbybit.advanced.dimensions.angularDimension_description": "Creates angular dimension - a measurement arc between two direction vectors with extension lines and text label. The dimension shows the angle between the directions and can be styled with DimensionStyleDto.",
    "angular dimension": "angular dimension",
    "centerPoint": "center point",
    "bitbybit.advanced.dimensions.dimensionStyle": "dimension style",
    "dimensionStyle": "dimension style",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Create dimension style - used to style dimension lines, arrows, and text in 3D space. You can customize line colors, thickness, text size, arrow size, and background colors.",
    "dimension style": "dimension style",
    "lineColor": "line color",
    "lineThickness": "line thickness",
    "extensionLineLength": "extension line length",
    "textBackgroundColor": "text background color",
    "textBackgroundOpacity": "text background opacity",
    "arrowSize": "arrow size",
    "arrowColor": "arrow color",
    "textRenderMode": "text render mode",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "text billboard",
    "occlusionCheckInterval": "occlusion check interval",
    "arrowTailLength": "arrow tail length",
    "showArrows": "show arrows",
    "labelOverwrite": "label overwrite",
    "bitbybit.advanced.dimensions.radialDimension": "radial dimension",
    "radialDimension": "radial dimension",
    "bitbybit.advanced.dimensions.radialDimension_description": "Creates radial dimension - a measurement line from center to perimeter showing radius or diameter. Shows 'R' prefix for radius or '' prefix for diameter with optional center mark.",
    "radial dimension": "radial dimension",
    "radiusPoint": "radius point",
    "showDiameter": "show diameter",
    "showCenterMark": "show center mark",
    "bitbybit.advanced.dimensions.diametralDimension": "diametral dimension",
    "diametralDimension": "diametral dimension",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Creates diametral dimension - a measurement line spanning full diameter of circular features. Shows '' prefix with optional center mark and arrows at both ends.",
    "diametral dimension": "diametral dimension",
    "bitbybit.advanced.dimensions.ordinateDimension": "ordinate dimension",
    "ordinateDimension": "ordinate dimension",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Creates ordinate dimension - shows X, Y, or Z coordinate from a reference point with leader line. Useful for coordinate annotations and datum referencing in technical drawings.",
    "ordinate dimension": "ordinate dimension",
    "measurementPoint": "measurement point",
    "referencePoint": "reference point",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "show leader line",
    "viewMode": "view mode",
    "schema": "schema",
    "json schema": "json schema",
    "metadata": "metadata",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "two color linear gradient background",
    "twoColorLinearGradientBackground": "two color linear gradient background",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Creates a two-color linear gradient background for 3D space",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "two color radial gradient background",
    "twoColorRadialGradientBackground": "two color radial gradient background",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Creates a two-color radial gradient background for 3D space",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "multi color linear gradient background",
    "multiColorLinearGradientBackground": "multi color linear gradient background",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Creates a multi-color linear gradient background for 3D space",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "multi color radial gradient background",
    "multiColorRadialGradientBackground": "multi color radial gradient background",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Creates a multi-color radial gradient background for 3D space",
    "textBackgroundStroke": "text background stroke",
    "textBackgroundRadius": "text background radius",
    "stableSize": "stable size",
    "alwaysOnTop": "always on top",
    "textStableSize": "text stable size",
    "bitbybit.occt.io.shapeToDxfPaths": "shape to dxf paths",
    "shapeToDxfPaths": "shape to dxf paths",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Creates DXF paths from an OCCT shape Important - shapes containing wires must lie on XZ plane (Y=0) for correct 2D DXF export.",
    "dxf": "dxf",
    "bitbybit.occt.io.dxfPathsWithLayer": "dxf paths with layer",
    "dxfPathsWithLayer": "dxf paths with layer",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Adds layer and color information to DXF paths Important - shapes containing wires must lie on XZ plane (Y=0) for correct 2D DXF export.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "layer",
    "bitbybit.occt.io.dxfCreate": "dxf create",
    "dxfCreate": "dxf create",
    "bitbybit.occt.io.dxfCreate_description": "Assembles multiple path parts into a complete DXF file. Important - shapes containing wires must lie on XZ plane (Y=0) for correct 2D DXF export.",
    "pathsParts": "paths parts",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "text font weight",
    "textPosition": "text position",
    "textBackgroundStrokeThickness": "stroke thickness",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Clear",
    "recompute": "Recompute",
    "clear tooltip": "Clear all cache and components",
    "recompute tooltip": "Clears cache and recomputes",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "I beam profile wire",
    "createIBeamProfileWire": "I beam profile wire",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Creates OpenCascade I-beam profile wire",
    "beam profiles": "beam profiles",
    "webThickness": "web thickness",
    "flangeThickness": "flange thickness",
    "alignment": "alignment",
    "Base.basicAlignmentEnum": "Base.basicAlignmentEnum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "H beam profile wire",
    "createHBeamProfileWire": "H beam profile wire",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Creates OpenCascade H-beam profile wire",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "T beam profile wire",
    "createTBeamProfileWire": "T beam profile wire",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Creates OpenCascade T-beam profile wire",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "U beam profile wire",
    "createUBeamProfileWire": "U beam profile wire",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Creates OpenCascade U-beam profile wire",
    "flangeWidth": "flange width",
    "bitbybit.occt.shapes.face.createLPolygonFace": "L polygon face",
    "createLPolygonFace": "L polygon face",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Creates OpenCascade L-polygon face",
    "bitbybit.occt.shapes.face.createStarFace": "star face",
    "createStarFace": "star face",
    "bitbybit.occt.shapes.face.createStarFace_description": "Creates OpenCascade star face",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "christmas tree face",
    "createChristmasTreeFace": "christmas tree face",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Creates OpenCascade christmas tree face",
    "bitbybit.occt.shapes.face.createParallelogramFace": "parallelogram face",
    "createParallelogramFace": "parallelogram face",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Creates OpenCascade parallelogram face",
    "bitbybit.occt.shapes.face.createHeartFace": "heart face",
    "createHeartFace": "heart face",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Creates OpenCascade heart face",
    "bitbybit.occt.shapes.face.createNGonFace": "n-gon face",
    "createNGonFace": "n-gon face",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Creates OpenCascade n-gon face",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "I beam profile face",
    "createIBeamProfileFace": "I beam profile face",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Creates OpenCascade I-beam profile face",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "H beam profile face",
    "createHBeamProfileFace": "H beam profile face",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Creates OpenCascade H-beam profile face",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "T beam profile face",
    "createTBeamProfileFace": "T beam profile face",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Creates OpenCascade T-beam profile face",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "U beam profile face",
    "createUBeamProfileFace": "U beam profile face",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Creates OpenCascade U-beam profile face",
    "bitbybit.occt.shapes.solid.createStarSolid": "star solid",
    "createStarSolid": "star solid",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Creates OpenCascade star solid",
    "extrusionLengthFront": "extrusion length front",
    "extrusionLengthBack": "extrusion length back",
    "bitbybit.occt.shapes.solid.createNGonSolid": "n-gon solid",
    "createNGonSolid": "n-gon solid",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Creates OpenCascade n-gon solid",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "parallelogram solid",
    "createParallelogramSolid": "parallelogram solid",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Creates OpenCascade parallelogram solid",
    "bitbybit.occt.shapes.solid.createHeartSolid": "heart solid",
    "createHeartSolid": "heart solid",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Creates OpenCascade heart solid",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "christmas tree solid",
    "createChristmasTreeSolid": "christmas tree solid",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Creates OpenCascade christmas tree solid",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "L polygon solid",
    "createLPolygonSolid": "L polygon solid",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Creates OpenCascade L-polygon solid",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "I beam profile solid",
    "createIBeamProfileSolid": "I beam profile solid",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Creates OpenCascade I-beam profile solid",
    "beam": "beam",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "H beam profile solid",
    "createHBeamProfileSolid": "H beam profile solid",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Creates OpenCascade H-beam profile solid",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "T beam profile solid",
    "createTBeamProfileSolid": "T beam profile solid",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Creates OpenCascade T-beam profile solid",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "U beam profile solid",
    "createUBeamProfileSolid": "U beam profile solid",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Creates OpenCascade U-beam profile solid",
    "endType": "end type",
    "dimensionEndTypeEnum": "dimensionEndTypeEnum",
    "arrowAngle": "arrow angle",
    "arrowsFlipped": "arrows flipped",
    "colorFormat": "color format",
    "dxfColorFormatEnum": "dxfColorFormatEnum",
    "acadVersion": "acad version",
    "dxfAcadVersionEnum": "dxfAcadVersionEnum",
    "bitbybit.advanced.navigation.zoomOn": "zoom on",
    "zoomOn": "zoom on",
    "bitbybit.advanced.navigation.zoomOn_description": "Zoom camera to fit specified meshes in the scene with smooth animation. Works only with ArcRotateCamera. Animation can be interrupted if called multiple times.",
    "animationSpeed": "animation speed",
    "doNotUpdateMaxZ": "do not update max z",
    "bitbybit.advanced.navigation.focusFromAngle": "focus from angle",
    "focusFromAngle": "focus from angle",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Focus camera on specified meshes from a specific angle with smooth animation. Computes the center of the bounding box of all meshes and positions the camera at the specified orientation vector to look at the center. Works only with ArcRotateCamera. Animation can be interrupted if called multiple times.",
    "padding": "padding",
    "shadowRefreshRate": "shadow refresh rate",
    "labelFlipHorizontal": "label flip horizontal",
    "labelFlipVertical": "label flip vertical",
    "bitbybit.advanced.navigation.zoomOnAspect": "zoom on aspect",
    "zoomOnAspect": "zoom on aspect",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Zoom camera to fit specified meshes in the scene with smooth animation, considering exact screen aspect ratio. Unlike zoomOn, this method precisely calculates camera distance based on viewport dimensions and mesh bounding box to ensure better fit at padding=0. Works only with ArcRotateCamera. Animation can be interrupted if called multiple times.",
    "bitbybit.vector.parseNumbers": "parse numbers",
    "parseNumbers": "parse numbers",
    "bitbybit.vector.parseNumbers_description": "Converts an array of stringified numbers to actual numbers. Example: ['1', '2.5', '3']  [1, 2.5, 3], ['10', '-5', '0.1']  [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "simplify",
    "bitbybit.manifold.manifold.operations.simplify_description": "Return a copy of the manifold simplified to the given tolerance, but with its actual tolerance value unchanged. The result will contain a subset of the original verts and all surfaces will have moved by less than tolerance.",
    "bitbybit.manifold.manifold.operations.setProperties": "set properties",
    "setProperties": "set properties",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Create a new copy of this manifold with updated vertex properties by supplying a function that takes the existing position and properties as input. You may specify any number of output properties, allowing creation and removal of channels. Note: undefined behavior will result if you read past the number of input properties or write past the number of output properties.",
    "propFunc": "prop func",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "warp",
    "warp": "warp",
    "bitbybit.manifold.manifold.transforms.warp_description": "Move the vertices of this Manifold (creating a new one) according to any arbitrary input function. It is easy to create a function that warps a geometrically valid object into one which overlaps, but that is not checked here, so it is up to the user to choose their function with discretion.",
    "warpFunc": "warp func",
    "(vert: Base.Vector3) => void": "(vert: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "status",
    "status": "status",
    "bitbybit.manifold.manifold.evaluate.status_description": "Returns the reason for an input Mesh producing an empty Manifold. This Status will carry on through operations like NaN propogation, ensuring an errored mesh doesn't get mysteriously lost. Empty meshes may still show NoError, for instance the intersection of non-overlapping meshes.",
    "bitbybit.manifold.crossSection.transforms.warp": "warp",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Move the vertices of this CrossSection (creating a new one) according to any arbitrary input function, followed by a union operation (with a Positive fill rule) that ensures any introduced intersections are not included in the result.",
    "(vert: Base.Vector2) => void": "(vert: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "round and remove trailing zeros",
    "roundAndRemoveTrailingZeros": "round and remove trailing zeros",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Rounds a number to specified decimal places and removes trailing zeros. Example: 1.32156 with 3 decimals returns 1.322, but 1.320000001 returns 1.32, and 1.000 returns 1",
    "bitbybit.math.clamp": "clamp",
    "clamp": "clamp",
    "bitbybit.math.clamp_description": "Constrains a value between a minimum and maximum value. Example: clamp(5, 0, 3) returns 3, clamp(-1, 0, 3) returns 0, clamp(1.5, 0, 3) returns 1.5",
    "bitbybit.math.lerp": "lerp",
    "bitbybit.math.lerp_description": "Linear interpolation between two values using parameter t (0 to 1). Example: From 0 to 100 at t=0.5  50, From 10 to 20 at t=0.25  12.5 When t=0 returns start, when t=1 returns end. Useful for smooth transitions.",
    "t": "t",
    "bitbybit.math.inverseLerp": "inverse lerp",
    "inverseLerp": "inverse lerp",
    "bitbybit.math.inverseLerp_description": "Calculates the interpolation parameter t for a value between start and end (reverse of lerp). Example: Value 5 in range [0,10]  t=0.5, Value 2.5 in range [0,10]  t=0.25 Returns what t value would produce the given value in a lerp. Useful for finding relative position.",
    "bitbybit.math.smoothstep": "smooth step",
    "smoothstep": "smooth step",
    "bitbybit.math.smoothstep_description": "Hermite interpolation with smooth acceleration and deceleration (smoother than linear lerp). Example: x=0  0, x=0.5  0.5, x=1  1 (but with smooth S-curve in between) Input is automatically clamped to [0,1]. Output eases in and out smoothly. Great for animations.",
    "bitbybit.math.sign": "sign",
    "sign": "sign",
    "bitbybit.math.sign_description": "Returns the sign of a number: -1 for negative, 0 for zero, 1 for positive. Example: -5  -1, 0  0, 3.14  1 Useful for determining direction or polarity.",
    "bitbybit.math.fract": "fract",
    "fract": "fract",
    "bitbybit.math.fract_description": "Returns the fractional part of a number (removes integer part, keeps decimals). Example: 3.14  0.14, 5.9  0.9, -2.3  0.7 Useful for wrapping values and creating repeating patterns.",
    "bitbybit.math.wrap": "wrap",
    "bitbybit.math.wrap_description": "Wraps a number within a specified range (creates repeating cycle). Example: 1.5 in range [0,1)  0.5, -0.3 in range [0,1)  0.7, 370 in range [0,360)  10 Useful for angles, UVs, or any repeating domain. Like modulo but handles negatives properly.",
    "bitbybit.math.pingPong": "ping pong",
    "pingPong": "ping pong",
    "bitbybit.math.pingPong_description": "Creates a ping-pong (back-and-forth) effect that bounces a value between 0 and length. The value goes from 0length, then back length0, repeating this cycle. Example: With length=1: t=00, t=0.50.5, t=11 (peak), t=1.50.5, t=20, t=2.50.5 (repeats) Useful for creating bouncing animations like a ball or oscillating motion.",
    "bitbybit.math.moveTowards": "move towards",
    "moveTowards": "move towards",
    "bitbybit.math.moveTowards_description": "Moves a value toward a target by a maximum delta amount (never overshooting). Example: From 0 toward 10 by max 3  3, From 8 toward 10 by max 3  10 (reached) Useful for smooth movement with maximum speed limits.",
    "current": "current",
    "maxDelta": "max delta",
    "bitbybit.lists.getFirstItem": "get first item",
    "getFirstItem": "get first item",
    "bitbybit.lists.getFirstItem_description": "Gets the first item from the list. Example: From [10, 20, 30, 40], returns 10",
    "bitbybit.lists.getLastItem": "get last item",
    "getLastItem": "get last item",
    "bitbybit.lists.getLastItem_description": "Gets the last item from the list. Example: From [10, 20, 30, 40], returns 40",
    "bitbybit.lists.shuffle": "shuffle",
    "shuffle": "shuffle",
    "bitbybit.lists.shuffle_description": "Randomly rearranges all items in the list (using Fisher-Yates algorithm). Example: From [1, 2, 3, 4, 5], might return [3, 1, 5, 2, 4] (order varies each time)",
    "bitbybit.lists.includes": "includes",
    "includes": "includes",
    "bitbybit.lists.includes_description": "Checks whether the list contains a specific item. Example: List [10, 20, 30, 40] with item 30 returns true, with item 50 returns false",
    "bitbybit.lists.findIndex": "find index",
    "findIndex": "find index",
    "bitbybit.lists.findIndex_description": "Finds the position (index) of the first occurrence of an item in the list. Example: In [10, 20, 30, 20, 40], finding 20 returns 1 (first occurrence), finding 50 returns -1 (not found)",
    "bitbybit.lists.removeFirstItem": "remove first item",
    "removeFirstItem": "remove first item",
    "bitbybit.lists.removeFirstItem_description": "Removes the first item from the list. Example: From [10, 20, 30, 40], returns [20, 30, 40]",
    "bitbybit.lists.removeLastItem": "remove last item",
    "removeLastItem": "remove last item",
    "bitbybit.lists.removeLastItem_description": "Removes the last item from the list. Example: From [10, 20, 30, 40], returns [10, 20, 30]",
    "bitbybit.lists.removeItemAtIndexFromEnd": "remove item at index from end",
    "removeItemAtIndexFromEnd": "remove item at index from end",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Removes an item counting from the end of the list (index 0 = last item, 1 = second-to-last, etc.). Example: From [10, 20, 30, 40, 50], removing index 1 from end gives [10, 20, 30, 50] (removes 40)",
    "bitbybit.lists.removeDuplicates": "remove duplicates",
    "removeDuplicates": "remove duplicates",
    "bitbybit.lists.removeDuplicates_description": "Removes duplicate items from the list using strict equality comparison (works with any type). Example: From ['a', 'b', 'c', 'a', 'd', 'b'], returns ['a', 'b', 'c', 'd']",
    "bitbybit.lists.concatenate": "concatenate",
    "concatenate": "concatenate",
    "bitbybit.lists.concatenate_description": "Combines multiple lists into a single list by joining them end-to-end. Example: From [[1, 2], [3, 4], [5, 6]], returns [1, 2, 3, 4, 5, 6]",
    "bitbybit.lists.interleave": "interleave",
    "interleave": "interleave",
    "bitbybit.lists.interleave_description": "Combines multiple lists by alternating elements from each list (first from list1, first from list2, second from list1, etc.). Example: From [[0, 1, 2], [3, 4, 5]], returns [0, 3, 1, 4, 2, 5]",
    "bitbybit.text.includes": "includes",
    "bitbybit.text.includes_description": "Checks if text contains a search string. Example: text='hello world', search='world'  true",
    "bitbybit.text.startsWith": "starts with",
    "startsWith": "starts with",
    "bitbybit.text.startsWith_description": "Checks if text starts with a search string. Example: text='hello world', search='hello'  true",
    "bitbybit.text.endsWith": "ends with",
    "endsWith": "ends with",
    "bitbybit.text.endsWith_description": "Checks if text ends with a search string. Example: text='hello world', search='world'  true",
    "bitbybit.text.indexOf": "index of",
    "indexOf": "index of",
    "bitbybit.text.indexOf_description": "Returns the index of the first occurrence of a search string. Example: text='hello world', search='world'  6",
    "bitbybit.text.lastIndexOf": "last index of",
    "lastIndexOf": "last index of",
    "bitbybit.text.lastIndexOf_description": "Returns the index of the last occurrence of a search string. Example: text='hello world hello', search='hello'  12",
    "bitbybit.text.substring": "substring",
    "substring": "substring",
    "bitbybit.text.substring_description": "Extracts a section of text between two indices. Example: text='hello world', start=0, end=5  'hello'",
    "bitbybit.text.slice": "slice",
    "bitbybit.text.slice_description": "Extracts a section of text and returns a new string. Example: text='hello world', start=0, end=5  'hello'",
    "bitbybit.text.charAt": "char at",
    "charAt": "char at",
    "bitbybit.text.charAt_description": "Returns the character at the specified index. Example: text='hello', index=1  'e'",
    "bitbybit.text.trim": "trim",
    "bitbybit.text.trim_description": "Removes whitespace from both ends of text. Example: text='  hello  '  'hello'",
    "bitbybit.text.trimStart": "trim start",
    "trimStart": "trim start",
    "bitbybit.text.trimStart_description": "Removes whitespace from the start of text. Example: text='  hello  '  'hello  '",
    "bitbybit.text.trimEnd": "trim end",
    "trimEnd": "trim end",
    "bitbybit.text.trimEnd_description": "Removes whitespace from the end of text. Example: text='  hello  '  '  hello'",
    "bitbybit.text.padStart": "pad start",
    "padStart": "pad start",
    "bitbybit.text.padStart_description": "Pads text from the start to reach target length. Example: text='x', length=3, padString='a'  'aax'",
    "padString": "pad string",
    "bitbybit.text.padEnd": "pad end",
    "padEnd": "pad end",
    "bitbybit.text.padEnd_description": "Pads text from the end to reach target length. Example: text='x', length=3, padString='a'  'xaa'",
    "bitbybit.text.toUpperCase": "to upper case",
    "toUpperCase": "to upper case",
    "bitbybit.text.toUpperCase_description": "Converts text to uppercase. Example: text='hello'  'HELLO'",
    "bitbybit.text.toLowerCase": "to lower case",
    "toLowerCase": "to lower case",
    "bitbybit.text.toLowerCase_description": "Converts text to lowercase. Example: text='HELLO'  'hello'",
    "bitbybit.text.toUpperCaseFirst": "to upper case first",
    "toUpperCaseFirst": "to upper case first",
    "bitbybit.text.toUpperCaseFirst_description": "Capitalizes the first character of text. Example: text='hello world'  'Hello world'",
    "bitbybit.text.toLowerCaseFirst": "to lower case first",
    "toLowerCaseFirst": "to lower case first",
    "bitbybit.text.toLowerCaseFirst_description": "Lowercases the first character of text. Example: text='Hello World'  'hello World'",
    "bitbybit.text.repeat": "repeat",
    "bitbybit.text.repeat_description": "Repeats text a specified number of times. Example: text='ha', count=3  'hahaha'",
    "bitbybit.text.reverse": "reverse",
    "bitbybit.text.reverse_description": "Reverses the characters in text. Example: text='hello'  'olleh'",
    "bitbybit.text.length": "length",
    "bitbybit.text.length_description": "Returns the length of text. Example: text='hello'  5",
    "bitbybit.text.isEmpty": "is empty",
    "bitbybit.text.isEmpty_description": "Checks if text is empty or only whitespace. Example: text='   '  true",
    "bitbybit.text.concat": "concat",
    "concat": "concat",
    "bitbybit.text.concat_description": "Concatenates multiple text strings. Example: texts=['hello', ' ', 'world']  'hello world'",
    "texts": "texts",
    "bitbybit.text.regexTest": "regex test",
    "regexTest": "regex test",
    "bitbybit.text.regexTest_description": "Tests if text matches a regular expression pattern. Example: text='hello123', pattern='[0-9]+'  true",
    "regex": "regex",
    "flags": "flags",
    "bitbybit.text.regexMatch": "regex match",
    "regexMatch": "regex match",
    "bitbybit.text.regexMatch_description": "Matches text against a regular expression and returns matches. Example: text='hello123world456', pattern='[0-9]+', flags='g'  ['123', '456']",
    "bitbybit.text.regexReplace": "regex replace",
    "regexReplace": "regex replace",
    "bitbybit.text.regexReplace_description": "Replaces text matching a regular expression pattern. Example: text='hello123world456', pattern='[0-9]+', flags='g', replaceWith='X'  'helloXworldX'",
    "bitbybit.text.regexSearch": "regex search",
    "regexSearch": "regex search",
    "bitbybit.text.regexSearch_description": "Searches text for a regular expression pattern and returns the index. Example: text='hello123', pattern='[0-9]+'  5",
    "bitbybit.text.regexSplit": "regex split",
    "regexSplit": "regex split",
    "bitbybit.text.regexSplit_description": "Splits text using a regular expression pattern. Example: text='a1b2c3', pattern='[0-9]+'  ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "parse to array",
    "csv": "csv",
    "parseToArray": "parse to array",
    "bitbybit.csv.parseToArray_description": "Parses CSV text to a 2D array of strings (rows and columns). Example: csv='a,b,c\n1,2,3'  [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "row separator",
    "columnSeparator": "column separator",
    "bitbybit.csv.parseToJson": "parse to json",
    "parseToJson": "parse to json",
    "bitbybit.csv.parseToJson_description": "Parses CSV text to an array of JSON objects using headers. Example: csv='name,age\nJohn,30\nJane,25', headerRow=0, dataStartRow=1  [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headerRow": "header row",
    "dataStartRow": "data start row",
    "numberColumns": "number columns",
    "bitbybit.csv.parseToJsonWithHeaders": "parse to json with headers",
    "parseToJsonWithHeaders": "parse to json with headers",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Parses CSV text to JSON using custom headers (ignores CSV headers if present). Example: csv='John,30\nJane,25', headers=['name','age']  [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headers": "headers",
    "bitbybit.csv.queryColumn": "query column",
    "queryColumn": "query column",
    "bitbybit.csv.queryColumn_description": "Queries CSV data by columnheader name and returns all values in that column. Example: csv='name,age\nJohn,30\nJane,25', column='name'  ['John', 'Jane']",
    "column": "column",
    "asNumber": "as number",
    "bitbybit.csv.queryRowsByValue": "query rows by value",
    "queryRowsByValue": "query rows by value",
    "bitbybit.csv.queryRowsByValue_description": "Queries CSV data and filters rows where a column matches a value. Example: csv='name,age\nJohn,30\nJane,25', column='age', value='30'  [{'name':'John','age':'30'}]",
    "bitbybit.csv.arrayToCsv": "array to csv",
    "arrayToCsv": "array to csv",
    "bitbybit.csv.arrayToCsv_description": "Converts a 2D array to CSV text. Example: array=[['name','age'], ['John','30']]  'name,age\nJohn,30'",
    "array": "array",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "json to csv",
    "jsonToCsv": "json to csv",
    "bitbybit.csv.jsonToCsv_description": "Converts an array of JSON objects to CSV text. Example: json=[{'name':'John','age':'30'}], headers=['name','age']  'name,age\nJohn,30'",
    "includeHeaders": "include headers",
    "bitbybit.csv.jsonToCsvAuto": "json to csv auto",
    "jsonToCsvAuto": "json to csv auto",
    "bitbybit.csv.jsonToCsvAuto_description": "Converts an array of JSON objects to CSV text using object keys as headers. Example: json=[{'name':'John','age':'30'}]  'name,age\nJohn,30'",
    "bitbybit.csv.getHeaders": "get headers",
    "getHeaders": "get headers",
    "bitbybit.csv.getHeaders_description": "Gets the headers from a CSV file. Example: csv='name,age\nJohn,30', headerRow=0  ['name', 'age']",
    "bitbybit.csv.getRowCount": "get row count",
    "getRowCount": "get row count",
    "bitbybit.csv.getRowCount_description": "Gets the number of rows in a CSV file (excluding headers if specified). Example: csv='name,age\nJohn,30\nJane,25', headerRow=0  2",
    "hasHeaders": "has headers",
    "bitbybit.csv.getColumnCount": "get column count",
    "getColumnCount": "get column count",
    "bitbybit.csv.getColumnCount_description": "Gets the number of columns in a CSV file. Example: csv='name,age,city\nJohn,30,NYC'  3",
    "removeTrailingZeros": "remove trailing zeros",
    "bitbybit.asset.getTextFile": "get text file",
    "getTextFile": "get text file",
    "bitbybit.asset.getTextFile_description": "Gets the text from asset file stored in your cloud account.",
    "bitbybit.asset.getLocalTextFile": "get local text file",
    "getLocalTextFile": "get local text file",
    "bitbybit.asset.getLocalTextFile_description": "Gets the text from asset file stored in your browser.",
    "bitbybit.asset.download": "download",
    "bitbybit.asset.download_description": "Downloads a file with the given content, extension, and content type.",
    "content": "content",
    "string | Blob": "string | Blob",
    "extension": "extension",
    "contentType": "content type",
    "preview csv": "preview csv",
    "startRow": "start row",
    "maxRows": "max rows",
    "colorMapStrategy": "color map strategy",
    "Base.colorMapStrategyEnum": "Base.colorMapStrategyEnum",
    "drawTwoSided": "draw two sided",
    "backFaceColour": "back face colour",
    "backFaceOpacity": "back face opacity",
    "edgeArrowSize": "edge arrow size",
    "edgeArrowAngle": "edge arrow angle",
    "bitbybit.draw.createTexture": "create texture",
    "createTexture": "create texture",
    "bitbybit.draw.createTexture_description": "Creates a generic texture that can be used with PBR materials. This method provides a cross-engine compatible way to create textures.",
    "bitbybit.draw.createPBRMaterial": "create pbr material",
    "createPBRMaterial": "create pbr material",
    "bitbybit.draw.createPBRMaterial_description": "Creates a generic PBR (Physically Based Rendering) material. This method provides a cross-engine compatible way to create materials that can be used with draw options for OCCT shapes and other geometry.",
    "emissiveIntensity": "emissive intensity",
    "zOffsetUnits": "z offset units",
    "baseColorTexture": "base color texture",
    "Base.Texture": "Base.Texture",
    "metallicRoughnessTexture": "metallic roughness texture",
    "normalTexture": "normal texture",
    "emissiveTexture": "emissive texture",
    "occlusionTexture": "occlusion texture",
    "alphaMode": "alpha mode",
    "alphaModeEnum": "alpha mode enum",
    "alphaCutoff": "alpha cutoff",
    "doubleSided": "double sided",
    "wireframe": "wireframe",
    "unlit": "unlit",
    "bitbybit.babylon.mesh.setLocalScale": "set local scale",
    "setLocalScale": "set local scale",
    "bitbybit.babylon.mesh.setLocalScale_description": "Scales the BabylonJS mesh or instanced mesh in place by a given factor",
    "transparencyShadow": "transparency shadow",
    "bitbybit.manifold.crossSection.crossSectionFromPoints": "cross section from points",
    "crossSectionFromPoints": "cross section from points",
    "bitbybit.manifold.crossSection.crossSectionFromPoints_description": "Creates a cross section from a single polygon points",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons": "cross section from polygons",
    "crossSectionFromPolygons": "cross section from polygons",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons_description": "Creates a cross section from multiple polygons points",
    "bitbybit.manifold.crossSection.crossSectionToPoints": "cross section to points",
    "crossSectionToPoints": "cross section to points",
    "bitbybit.manifold.crossSection.crossSectionToPoints_description": "Extracts points from a cross section",
    "bitbybit.manifold.crossSection.crossSectionsToPoints": "cross sections to points",
    "crossSectionsToPoints": "cross sections to points",
    "bitbybit.manifold.crossSection.crossSectionsToPoints_description": "Extracts points from cross sections",
    "bitbybit.previewCSV": "preview csv",
    "bitbybit.occt.shapes.wire.createHelixWire": "create helix wire",
    "createHelixWire": "create helix wire",
    "bitbybit.occt.shapes.wire.createHelixWire_description": "Creates a 3D helix wire",
    "bitbybit.occt.shapes.wire.createHelixWireByTurns": "create helix wire by turns",
    "createHelixWireByTurns": "create helix wire by turns",
    "bitbybit.occt.shapes.wire.createHelixWireByTurns_description": "Creates a 3D helix wire by specifying the number of turns",
    "numTurns": "num turns",
    "bitbybit.occt.shapes.wire.createTaperedHelixWire": "create tapered helix wire",
    "createTaperedHelixWire": "create tapered helix wire",
    "bitbybit.occt.shapes.wire.createTaperedHelixWire_description": "Creates a conical (tapered) helix wire with varying radius",
    "bitbybit.occt.shapes.wire.createFlatSpiralWire": "create flat spiral wire",
    "createFlatSpiralWire": "create flat spiral wire",
    "bitbybit.occt.shapes.wire.createFlatSpiralWire_description": "Creates a flat (Archimedean) spiral wire lying in a plane",
    "bitbybit.occt.shapes.solid.createTorus": "create torus",
    "bitbybit.occt.shapes.solid.createTorus_description": "Creates OpenCascade Torus",
    "majorRadius": "major radius",
    "minorRadius": "minor radius"
}