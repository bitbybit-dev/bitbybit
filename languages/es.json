{
    "bitbybit.draw.drawAnyAsyncNoReturn": "dibujar cualquier asíncrono sin retorno",
    "bitbybit": "bitbybit",
    "draw": "dibujar",
    "drawAnyAsyncNoReturn": "dibujar cualquier asíncrono sin retorno",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "dibuja cualquier geometría sin retornar nada",
    "draw async": "dibujar asíncrono",
    "entity": "entidad",
    "Entity": "entidad",
    "options": "opciones",
    "DrawOptions": "opciones de dibujo",
    "babylonMesh": "malla de babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "malla de babylon o malla de líneas",
    "bitbybit.draw.drawAnyAsync": "dibujar cualquier asíncrono",
    "drawAnyAsync": "dibujar cualquier asíncrono",
    "bitbybit.draw.drawAnyAsync_description": "dibuja cualquier geometría y retorna una malla de babylon",
    "bitbybit.draw.drawAnyNoReturn": "dibujar cualquier sin retorno",
    "drawAnyNoReturn": "dibujar cualquier sin retorno",
    "bitbybit.draw.drawAnyNoReturn_description": "dibuja geometría síncrona, no para formas occt o jscad",
    "draw sync": "dibujar síncrono",
    "bitbybit.draw.drawAny": "dibujar cualquier",
    "drawAny": "dibujar cualquier",
    "bitbybit.draw.drawAny_description": "dibuja geometría síncrona, no para formas occt o jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "dibujar malla de cuadrícula sin retorno",
    "drawGridMeshNoReturn": "dibujar malla de cuadrícula sin retorno",
    "bitbybit.draw.drawGridMeshNoReturn_description": "dibuja una malla de cuadrícula en el suelo para ayudar a la orientación",
    "grid": "cuadrícula",
    "width": "ancho",
    "number": "número",
    "height": "altura",
    "subdivisions": "subdivisiones",
    "majorUnitFrequency": "frecuencia de unidad mayor",
    "minorUnitVisibility": "visibilidad de unidad menor",
    "gridRatio": "ratio de cuadrícula",
    "opacity": "opacidad",
    "backFaceCulling": "descarte de cara trasera",
    "boolean": "booleano",
    "mainColor": "color principal",
    "Base.Color": "color base",
    "secondaryColor": "color secundario",
    "bitbybit.draw.drawGridMesh": "dibujar malla de cuadrícula",
    "drawGridMesh": "dibujar malla de cuadrícula",
    "bitbybit.draw.drawGridMesh_description": "dibuja una malla de cuadrícula en el suelo para ayudar a la orientación",
    "bitbybit.draw.optionsSimple": "opciones simples",
    "optionsSimple": "opciones simples",
    "bitbybit.draw.optionsSimple_description": "establece opciones de dibujo para geometría básica como puntos y líneas",
    "colours": "colores",
    "string | string[]": "cadena o array de cadenas",
    "size": "tamaño",
    "updatable": "actualizable",
    "hidden": "oculto",
    "bitbybit.draw.optionsOcctShape": "opciones de forma occt",
    "optionsOcctShape": "opciones de forma occt",
    "bitbybit.draw.optionsOcctShape_description": "establece opciones de dibujo para formas occt como aristas y sólidos",
    "faceOpacity": "opacidad de cara",
    "edgeOpacity": "opacidad de arista",
    "edgeColour": "color de arista",
    "faceColour": "color de cara",
    "vertexColour": "color de vértice",
    "faceMaterial": "material de cara",
    "Base.Material": "material base",
    "edgeWidth": "ancho de arista",
    "vertexSize": "tamaño de vértice",
    "drawEdges": "dibujar aristas",
    "drawFaces": "dibujar caras",
    "drawVertices": "dibujar vértices",
    "precision": "precisión",
    "drawEdgeIndexes": "dibujar índices de arista",
    "edgeIndexHeight": "altura de índice de arista",
    "edgeIndexColour": "color de índice de arista",
    "drawFaceIndexes": "dibujar índices de cara",
    "faceIndexHeight": "altura de índice de cara",
    "faceIndexColour": "color de índice de cara",
    "bitbybit.draw.optionsOcctShapeSimple": "opciones simples de forma occt",
    "optionsOcctShapeSimple": "opciones simples de forma occt",
    "bitbybit.draw.optionsOcctShapeSimple_description": "establece opciones de dibujo simples para formas occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "opciones de material de forma occt",
    "optionsOcctShapeMaterial": "opciones de material de forma occt",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "establece opciones de dibujo con material de cara personalizado para formas occt",
    "any": "cualquier",
    "bitbybit.draw.optionsManifoldShapeMaterial": "opciones de material de forma manifold",
    "optionsManifoldShapeMaterial": "opciones de material de forma manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "establece opciones de dibujo para geometría manifold",
    "crossSectionColour": "color de sección transversal",
    "crossSectionWidth": "ancho de sección transversal",
    "crossSectionOpacity": "opacidad de sección transversal",
    "computeNormals": "calcular normales",
    "bitbybit.draw.optionsBabylonNode": "opciones de nodo babylon",
    "optionsBabylonNode": "opciones de nodo babylon",
    "bitbybit.draw.optionsBabylonNode_description": "establece opciones de dibujo para nodos de babylon js",
    "colorX": "color x",
    "colorY": "color y",
    "colorZ": "color z",
    "bitbybit.babylon.mesh.dispose": "eliminar malla",
    "babylon": "babylon",
    "mesh": "malla",
    "dispose": "eliminar",
    "bitbybit.babylon.mesh.dispose_description": "elimina la malla dibujada de la escena",
    "memory": "memoria",
    "BABYLON.Mesh": "malla de babylon",
    "bitbybit.babylon.mesh.updateDrawn": "actualizar dibujado",
    "updateDrawn": "actualizar dibujado",
    "bitbybit.babylon.mesh.updateDrawn_description": "actualiza la malla de babylon js sin eliminarla",
    "updates": "actualizaciones",
    "position": "posición",
    "Base.Point3": "punto base 3",
    "rotation": "rotación",
    "Base.Vector3": "vector base 3",
    "scaling": "escalado",
    "bitbybit.babylon.mesh.setVisibility": "establecer visibilidad",
    "setVisibility": "establecer visibilidad",
    "bitbybit.babylon.mesh.setVisibility_description": "cambia la visibilidad de la malla de babylon js",
    "visibility": "visibilidad",
    "includeChildren": "incluir hijos",
    "bitbybit.babylon.mesh.hide": "ocultar",
    "hide": "ocultar",
    "bitbybit.babylon.mesh.hide_description": "oculta la malla",
    "bitbybit.babylon.mesh.show": "mostrar",
    "show": "mostrar",
    "bitbybit.babylon.mesh.show_description": "muestra la malla",
    "bitbybit.babylon.mesh.setParent": "establecer padre",
    "setParent": "establecer padre",
    "bitbybit.babylon.mesh.setParent_description": "cambia el padre de la malla dibujada",
    "set": "establecer",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "malla de babylon o malla instanciada o malla abstracta",
    "parentMesh": "malla padre",
    "bitbybit.babylon.mesh.getParent": "obtener padre",
    "getParent": "obtener padre",
    "bitbybit.babylon.mesh.getParent_description": "obtiene el padre de la malla dibujada",
    "get": "obtener",
    "bitbybit.babylon.mesh.setCheckCollisions": "establecer comprobación de colisiones",
    "setCheckCollisions": "establecer comprobación de colisiones",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "cambia la propiedad de comprobación de colisiones de la malla dibujada",
    "checkCollisions": "comprobar colisiones",
    "bitbybit.babylon.mesh.getCheckCollisions": "obtener comprobación de colisiones",
    "getCheckCollisions": "obtener comprobación de colisiones",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "obtiene la propiedad de comprobación de colisiones de la malla dibujada",
    "bitbybit.babylon.mesh.setPickable": "establecer seleccionable",
    "setPickable": "establecer seleccionable",
    "bitbybit.babylon.mesh.setPickable_description": "cambia la propiedad seleccionable de la malla dibujada",
    "pickable": "seleccionable",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "habilitar eventos de movimiento de puntero",
    "enablePointerMoveEvents": "habilitar eventos de movimiento de puntero",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "hace la malla seleccionable por eventos de movimiento de puntero, afecta al rendimiento",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "deshabilitar eventos de movimiento de puntero",
    "disablePointerMoveEvents": "deshabilitar eventos de movimiento de puntero",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "hace que la malla ignore los eventos de movimiento de puntero",
    "bitbybit.babylon.mesh.getPickable": "obtener seleccionable",
    "getPickable": "obtener seleccionable",
    "bitbybit.babylon.mesh.getPickable_description": "obtiene la propiedad seleccionable de la malla dibujada",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "obtener mallas donde el nombre contiene",
    "getMeshesWhereNameContains": "obtener mallas donde el nombre contiene",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "obtiene mallas con nombres que contienen el texto dado",
    "name": "nombre",
    "string": "cadena",
    "bitbybit.babylon.mesh.getChildMeshes": "obtener mallas hijas",
    "getChildMeshes": "obtener mallas hijas",
    "bitbybit.babylon.mesh.getChildMeshes_description": "obtiene las mallas hijas",
    "directDescendantsOnly": "solo descendientes directos",
    "bitbybit.babylon.mesh.getMeshesOfId": "obtener mallas por id",
    "getMeshesOfId": "obtener mallas por id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "obtiene mallas por id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "obtener malla por id",
    "getMeshOfId": "obtener malla por id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "obtiene malla por id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "obtener malla por id único",
    "getMeshOfUniqueId": "obtener malla por id único",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "obtiene malla por id único",
    "uniqueId": "id único",
    "bitbybit.babylon.mesh.mergeMeshes": "fusionar mallas",
    "mergeMeshes": "fusionar mallas",
    "bitbybit.babylon.mesh.mergeMeshes_description": "fusiona múltiples mallas en una",
    "edit": "editar",
    "arrayOfMeshes": "array de mallas",
    "BABYLON.Mesh[]": "array de mallas de babylon",
    "disposeSource": "eliminar fuente",
    "allow32BitsIndices": "permitir índices de 32 bits",
    "meshSubclass": "subclase de malla",
    "subdivideWithSubMeshes": "subdividir con submallas",
    "multiMultiMaterials": "múltiples materiales múltiples",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "convertir a malla con sombreado plano",
    "convertToFlatShadedMesh": "convertir a malla con sombreado plano",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "convierte la malla a malla con sombreado plano",
    "bitbybit.babylon.mesh.clone": "clonar",
    "clone": "clonar",
    "bitbybit.babylon.mesh.clone_description": "clona la malla",
    "bitbybit.babylon.mesh.cloneToPositions": "clonar a posiciones",
    "cloneToPositions": "clonar a posiciones",
    "bitbybit.babylon.mesh.cloneToPositions_description": "clona la malla a múltiples posiciones",
    "positions": "posiciones",
    "Base.Point3[]": "array de puntos base 3",
    "bitbybit.babylon.mesh.setId": "establecer id",
    "setId": "establecer id",
    "bitbybit.babylon.mesh.setId_description": "cambia el id de la malla dibujada",
    "bitbybit.babylon.mesh.getId": "obtener id",
    "getId": "obtener id",
    "bitbybit.babylon.mesh.getId_description": "obtiene el id de la malla dibujada",
    "bitbybit.babylon.mesh.getUniqueId": "obtener id único",
    "getUniqueId": "obtener id único",
    "bitbybit.babylon.mesh.getUniqueId_description": "obtiene el id único de la malla dibujada",
    "bitbybit.babylon.mesh.setName": "establecer nombre",
    "setName": "establecer nombre",
    "bitbybit.babylon.mesh.setName_description": "cambia el nombre de la malla dibujada",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "obtener vértices como puntos de polígono",
    "getVerticesAsPolygonPoints": "obtener vértices como puntos de polígono",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "obtiene vértices como puntos de polígono para la construcción de mallas, requiere triangulación",
    "bitbybit.babylon.mesh.getName": "obtener nombre",
    "getName": "obtener nombre",
    "bitbybit.babylon.mesh.getName_description": "obtiene el nombre de la malla de babylon",
    "bitbybit.babylon.mesh.setMaterial": "establecer material",
    "setMaterial": "establecer material",
    "bitbybit.babylon.mesh.setMaterial_description": "cambia el material de la malla dibujada",
    "material": "material",
    "BABYLON.Material": "material de babylon",
    "bitbybit.babylon.mesh.getMaterial": "obtener material",
    "getMaterial": "obtener material",
    "bitbybit.babylon.mesh.getMaterial_description": "obtiene el material de la malla de babylon",
    "bitbybit.babylon.mesh.getPosition": "obtener posición",
    "getPosition": "obtener posición",
    "bitbybit.babylon.mesh.getPosition_description": "obtiene la posición como punto de la malla de babylon js",
    "bitbybit.babylon.mesh.getAbsolutePosition": "obtener posición absoluta",
    "getAbsolutePosition": "obtener posición absoluta",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "obtiene la posición absoluta en el mundo como punto de la malla de babylon js",
    "bitbybit.babylon.mesh.getRotation": "obtener rotación",
    "getRotation": "obtener rotación",
    "bitbybit.babylon.mesh.getRotation_description": "obtiene el vector de rotación de la malla de babylon js",
    "bitbybit.babylon.mesh.getScale": "obtener escala",
    "getScale": "obtener escala",
    "bitbybit.babylon.mesh.getScale_description": "obtiene el vector de escala de la malla de babylon js",
    "bitbybit.babylon.mesh.moveForward": "mover adelante",
    "moveForward": "mover adelante",
    "bitbybit.babylon.mesh.moveForward_description": "mueve la malla de babylon js hacia adelante en el espacio local",
    "move": "mover",
    "distance": "distancia",
    "bitbybit.babylon.mesh.moveBackward": "mover atrás",
    "moveBackward": "mover atrás",
    "bitbybit.babylon.mesh.moveBackward_description": "mueve la malla de babylon js hacia atrás en el espacio local",
    "bitbybit.babylon.mesh.moveUp": "mover arriba",
    "moveUp": "mover arriba",
    "bitbybit.babylon.mesh.moveUp_description": "mueve la malla de babylon js hacia arriba en el espacio local",
    "bitbybit.babylon.mesh.moveDown": "mover abajo",
    "moveDown": "mover abajo",
    "bitbybit.babylon.mesh.moveDown_description": "mueve la malla de babylon js hacia abajo en el espacio local",
    "bitbybit.babylon.mesh.moveRight": "mover derecha",
    "moveRight": "mover derecha",
    "bitbybit.babylon.mesh.moveRight_description": "mueve la malla de babylon js hacia la derecha en el espacio local",
    "bitbybit.babylon.mesh.moveLeft": "mover izquierda",
    "moveLeft": "mover izquierda",
    "bitbybit.babylon.mesh.moveLeft_description": "mueve la malla de babylon js hacia la izquierda en el espacio local",
    "bitbybit.babylon.mesh.yaw": "guiñada",
    "yaw": "guiñada",
    "bitbybit.babylon.mesh.yaw_description": "rota la malla de babylon js alrededor del eje Y local",
    "rotate": "rotar",
    "bitbybit.babylon.mesh.pitch": "cabeceo",
    "pitch": "cabeceo",
    "bitbybit.babylon.mesh.pitch_description": "rota la malla de babylon js alrededor del eje X local",
    "bitbybit.babylon.mesh.roll": "balanceo",
    "roll": "balanceo",
    "bitbybit.babylon.mesh.roll_description": "rota la malla de babylon js alrededor del eje Z local",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "rotar alrededor de eje con posición",
    "rotateAroundAxisWithPosition": "rotar alrededor de eje con posición",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "rota la malla alrededor de un eje y una posición por un ángulo",
    "axis": "eje",
    "angle": "ángulo",
    "bitbybit.babylon.mesh.setPosition": "establecer posición",
    "setPosition": "establecer posición",
    "bitbybit.babylon.mesh.setPosition_description": "actualiza la posición de la malla de babylon js o malla instanciada",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "malla de babylon o malla instanciada",
    "bitbybit.babylon.mesh.setRotation": "establecer rotación",
    "setRotation": "establecer rotación",
    "bitbybit.babylon.mesh.setRotation_description": "actualiza la rotación de la malla de babylon js o malla instanciada",
    "bitbybit.babylon.mesh.setScale": "establecer escala",
    "setScale": "establecer escala",
    "bitbybit.babylon.mesh.setScale_description": "actualiza la escala de la malla de babylon js o malla instanciada",
    "scale": "escala",
    "bitbybit.babylon.mesh.intersectsMesh": "interseca malla",
    "intersectsMesh": "interseca malla",
    "bitbybit.babylon.mesh.intersectsMesh_description": "comprueba si la malla interseca otra malla",
    "intersects": "interseca",
    "babylonMesh2": "malla de babylon 2",
    "precise": "preciso",
    "includeDescendants": "incluir descendientes",
    "bitbybit.babylon.mesh.intersectsPoint": "interseca punto",
    "intersectsPoint": "interseca punto",
    "bitbybit.babylon.mesh.intersectsPoint_description": "comprueba si la malla interseca un punto",
    "point": "punto",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instancia de malla y transformar sin retorno",
    "createMeshInstanceAndTransformNoReturn": "instancia de malla y transformar sin retorno",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "crea una instancia de malla con hijos para renderizado optimizado, sin retorno",
    "instance": "instancia",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instancia de malla y transformar",
    "createMeshInstanceAndTransform": "instancia de malla y transformar",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "crea una instancia de malla con hijos para renderizado optimizado, retorna la malla",
    "bitbybit.babylon.mesh.createMeshInstance": "instancia de malla",
    "createMeshInstance": "instancia de malla",
    "bitbybit.babylon.mesh.createMeshInstance_description": "crea una instancia de malla para renderizado optimizado con hijos",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussiano",
    "gaussianSplatting": "splatting gaussiano",
    "create": "crear",
    "bitbybit.babylon.gaussianSplatting.create_description": "crea una malla de splatting gaussiano",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "clonar splatting gaussiano",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clona la malla de splatting gaussiano",
    "multiply": "multiplicar",
    "BABYLON.GaussianSplattingMesh": "malla de splatting gaussiano de babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "obtener posiciones de splat",
    "getSplatPositions": "obtener posiciones de splat",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "obtiene las posiciones de splat de la malla de splatting gaussiano",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "congelar matriz de proyección",
    "camera": "cámara",
    "freezeProjectionMatrix": "congelar matriz de proyección",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "congela la matriz de proyección de la cámara",
    "adjust": "ajustar",
    "BABYLON.Camera": "cámara de babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "descongelar matriz de proyección",
    "unfreezeProjectionMatrix": "descongelar matriz de proyección",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "descongela la matriz de proyección de la cámara",
    "bitbybit.babylon.camera.setPosition": "establecer posición",
    "bitbybit.babylon.camera.setPosition_description": "cambia la posición de la cámara",
    "BABYLON.TargetCamera": "cámara de objetivo de babylon",
    "bitbybit.babylon.camera.getPosition": "obtener posición",
    "bitbybit.babylon.camera.getPosition_description": "obtiene la posición de la cámara",
    "bitbybit.babylon.camera.setTarget": "establecer objetivo",
    "setTarget": "establecer objetivo",
    "bitbybit.babylon.camera.setTarget_description": "cambia el objetivo de la cámara",
    "target": "objetivo",
    "bitbybit.babylon.camera.getTarget": "obtener objetivo",
    "getTarget": "obtener objetivo",
    "bitbybit.babylon.camera.getTarget_description": "obtiene el objetivo de la cámara",
    "bitbybit.babylon.camera.setSpeed": "establecer velocidad",
    "setSpeed": "establecer velocidad",
    "bitbybit.babylon.camera.setSpeed_description": "cambia la velocidad de la cámara",
    "speed": "velocidad",
    "bitbybit.babylon.camera.getSpeed": "obtener velocidad",
    "getSpeed": "obtener velocidad",
    "bitbybit.babylon.camera.getSpeed_description": "obtiene la velocidad de la cámara",
    "bitbybit.babylon.camera.setMinZ": "establecer z mínimo",
    "setMinZ": "establecer z mínimo",
    "bitbybit.babylon.camera.setMinZ_description": "cambia el z mínimo de la cámara",
    "minZ": "z mínimo",
    "bitbybit.babylon.camera.setMaxZ": "establecer z máximo",
    "setMaxZ": "establecer z máximo",
    "bitbybit.babylon.camera.setMaxZ_description": "cambia el z máximo de la cámara",
    "maxZ": "z máximo",
    "bitbybit.babylon.camera.makeCameraOrthographic": "hacer cámara ortográfica",
    "makeCameraOrthographic": "hacer cámara ortográfica",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "establece la cámara en modo ortográfico",
    "orthoLeft": "orto izquierda",
    "orthoRight": "orto derecha",
    "orthoBottom": "orto abajo",
    "orthoTop": "orto arriba",
    "bitbybit.babylon.camera.makeCameraPerspective": "hacer cámara perspectiva",
    "makeCameraPerspective": "hacer cámara perspectiva",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "establece la cámara en modo perspectiva",
    "bitbybit.babylon.camera.free.create": "cámara libre",
    "free": "libre",
    "bitbybit.babylon.camera.free.create_description": "crea una cámara libre",
    "bitbybit.babylon.camera.arcRotate.create": "cámara de rotación en arco",
    "arcRotate": "rotación en arco",
    "bitbybit.babylon.camera.arcRotate.create_description": "crea una cámara que rota alrededor del objetivo en una trayectoria de arco, predeterminada para bitbybit",
    "radius": "radio",
    "alpha": "alfa",
    "beta": "beta",
    "lowerRadiusLimit": "límite inferior de radio",
    "upperRadiusLimit": "límite superior de radio",
    "lowerAlphaLimit": "límite inferior de alfa",
    "upperAlphaLimit": "límite superior de alfa",
    "lowerBetaLimit": "límite inferior de beta",
    "upperBetaLimit": "límite superior de beta",
    "angularSensibilityX": "sensibilidad angular x",
    "angularSensibilityY": "sensibilidad angular y",
    "panningSensibility": "sensibilidad de paneo",
    "wheelPrecision": "precisión de rueda",
    "bitbybit.babylon.camera.target.create": "cámara de objetivo",
    "bitbybit.babylon.camera.target.create_description": "crea una cámara de objetivo",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "experiencia ar inmersiva",
    "webXr": "web xr",
    "simple": "simple",
    "createImmersiveARExperience": "experiencia ar inmersiva",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "crea una experiencia xr predeterminada en modo ar inmersivo",
    "scene": "escena",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "experiencia xr predeterminada con teletransporte",
    "createDefaultXRExperienceWithTeleportation": "experiencia xr predeterminada con teletransporte",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "crea una experiencia xr básica con teletransporte",
    "groundMeshes": "mallas de suelo",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "experiencia xr predeterminada con teletransporte con retorno",
    "createDefaultXRExperienceWithTeleportationReturn": "experiencia xr predeterminada con teletransporte con retorno",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "crea una experiencia xr básica con teletransporte, retorna el resultado",
    "bitbybit.babylon.node.drawNode": "dibujar nodo",
    "node": "nodo",
    "drawNode": "dibujar nodo",
    "bitbybit.babylon.node.drawNode_description": "dibuja un nodo con tamaño y colores de eje",
    "BABYLON.TransformNode": "nodo de transformación de babylon",
    "bitbybit.babylon.node.drawNodes": "dibujar nodos",
    "drawNodes": "dibujar nodos",
    "bitbybit.babylon.node.drawNodes_description": "dibuja múltiples nodos con tamaño y colores de eje",
    "nodes": "nodos",
    "BABYLON.TransformNode[]": "array de nodos de transformación de babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "nodo desde rotación",
    "createNodeFromRotation": "nodo desde rotación",
    "bitbybit.babylon.node.createNodeFromRotation_description": "crea un nodo en el origen con rotaciones en el espacio del padre",
    "parent": "padre",
    "BABYLON.TransformNode | null": "nodo de transformación de babylon o nulo",
    "origin": "origen",
    "bitbybit.babylon.node.createWorldNode": "nodo mundial",
    "createWorldNode": "nodo mundial",
    "bitbybit.babylon.node.createWorldNode_description": "crea un nodo con la raíz como padre",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "obtener vector adelante absoluto",
    "getAbsoluteForwardVector": "obtener vector adelante absoluto",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "obtiene el vector adelante absoluto en el espacio mundial",
    "bitbybit.babylon.node.getAbsoluteRightVector": "obtener vector derecha absoluto",
    "getAbsoluteRightVector": "obtener vector derecha absoluto",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "obtiene el vector derecha absoluto en el espacio mundial",
    "bitbybit.babylon.node.getAbsoluteUpVector": "obtener vector arriba absoluto",
    "getAbsoluteUpVector": "obtener vector arriba absoluto",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "obtiene el vector arriba absoluto en el espacio mundial",
    "bitbybit.babylon.node.getAbsolutePosition": "obtener posición absoluta",
    "bitbybit.babylon.node.getAbsolutePosition_description": "obtiene la posición absoluta del nodo en el espacio mundial",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "obtener transformación de rotación absoluta",
    "getAbsoluteRotationTransformation": "obtener transformación de rotación absoluta",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "obtiene la rotación absoluta como matriz de transformación (16 números)",
    "bitbybit.babylon.node.getRotationTransformation": "obtener transformación de rotación",
    "getRotationTransformation": "obtener transformación de rotación",
    "bitbybit.babylon.node.getRotationTransformation_description": "obtiene la rotación local como matriz de transformación (16 números)",
    "bitbybit.babylon.node.getChildren": "obtener hijos",
    "getChildren": "obtener hijos",
    "bitbybit.babylon.node.getChildren_description": "obtiene los hijos del nodo",
    "bitbybit.babylon.node.getParent": "obtener padre",
    "bitbybit.babylon.node.getParent_description": "obtiene el padre del nodo",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "obtener posición en espacio local",
    "getPositionExpressedInLocalSpace": "obtener posición en espacio local",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "obtiene la posición del nodo en el espacio local",
    "bitbybit.babylon.node.getRootNode": "obtener nodo raíz",
    "getRootNode": "obtener nodo raíz",
    "bitbybit.babylon.node.getRootNode_description": "obtiene el nodo raíz",
    "bitbybit.babylon.node.getRotation": "obtener rotación",
    "bitbybit.babylon.node.getRotation_description": "obtiene las rotaciones euler del nodo",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "rotar alrededor de eje con posición",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "rota el nodo alrededor de un eje y una posición por un ángulo",
    "bitbybit.babylon.node.rotate": "rotar",
    "bitbybit.babylon.node.rotate_description": "rota el nodo alrededor del origen y un eje",
    "bitbybit.babylon.node.setAbsolutePosition": "establecer posición absoluta",
    "setAbsolutePosition": "establecer posición absoluta",
    "bitbybit.babylon.node.setAbsolutePosition_description": "establece la posición absoluta del nodo",
    "bitbybit.babylon.node.setDirection": "establecer dirección",
    "setDirection": "establecer dirección",
    "bitbybit.babylon.node.setDirection_description": "establece la dirección del nodo",
    "direction": "dirección",
    "number[]": "array de números",
    "bitbybit.babylon.node.setParent": "establecer padre",
    "bitbybit.babylon.node.setParent_description": "establece un nuevo padre para el nodo",
    "parentNode": "nodo padre",
    "bitbybit.babylon.node.translate": "trasladar",
    "translate": "trasladar",
    "bitbybit.babylon.node.translate_description": "mueve el nodo por un vector de dirección y una distancia",
    "bitbybit.babylon.scene.backgroundColour": "color de fondo",
    "backgroundColour": "color de fondo",
    "bitbybit.babylon.scene.backgroundColour_description": "cambia el color de fondo de la escena en el espacio 3d",
    "environment": "entorno",
    "colour": "color",
    "bitbybit.babylon.scene.activateCamera": "activar cámara",
    "activateCamera": "activar cámara",
    "bitbybit.babylon.scene.activateCamera_description": "establece la cámara como activa, reemplazando la actual",
    "bitbybit.babylon.scene.useRightHandedSystem": "usar sistema de mano derecha",
    "useRightHandedSystem": "usar sistema de mano derecha",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "cambia al sistema de coordenadas de mano derecha",
    "system": "sistema",
    "use": "usar",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "dibujar luz puntual sin retorno",
    "drawPointLightNoReturn": "dibujar luz puntual sin retorno",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "añade una luz puntual a la escena, sin salida",
    "lights": "luces",
    "intensity": "intensidad",
    "diffuse": "difuso",
    "specular": "especular",
    "shadowGeneratorMapSize": "tamaño del mapa del generador de sombras",
    "enableShadows": "habilitar sombras",
    "shadowDarkness": "oscuridad de la sombra",
    "shadowUsePercentageCloserFiltering": "sombra usar filtrado de porcentaje más cercano",
    "shadowContactHardeningLightSizeUVRatio": "sombra endurecimiento de contacto tamaño luz ratio uv",
    "shadowBias": "sesgo de sombra",
    "shadowNormalBias": "sesgo normal de sombra",
    "shadowMaxZ": "z máximo de sombra",
    "shadowMinZ": "z mínimo de sombra",
    "bitbybit.babylon.scene.getShadowGenerators": "obtener generadores de sombras",
    "getShadowGenerators": "obtener generadores de sombras",
    "bitbybit.babylon.scene.getShadowGenerators_description": "obtiene los generadores de sombras de las luces de bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "dibujar luz puntual",
    "drawPointLight": "dibujar luz puntual",
    "bitbybit.babylon.scene.drawPointLight_description": "añade una luz puntual a la escena",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "dibujar luz direccional sin retorno",
    "drawDirectionalLightNoReturn": "dibujar luz direccional sin retorno",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "añade una luz direccional a la escena, sin salida",
    "bitbybit.babylon.scene.drawDirectionalLight": "dibujar luz direccional",
    "drawDirectionalLight": "dibujar luz direccional",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "añade una luz direccional a la escena",
    "bitbybit.babylon.scene.getActiveCamera": "obtener cámara activa",
    "getActiveCamera": "obtener cámara activa",
    "bitbybit.babylon.scene.getActiveCamera_description": "obtiene la cámara activa actual en la escena",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "ajustar cámara activa de rotación en arco",
    "adjustActiveArcRotateCamera": "ajustar cámara activa de rotación en arco",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "ajusta la configuración de la cámara activa de rotación en arco",
    "lookAt": "mirar a",
    "bitbybit.babylon.scene.clearAllDrawn": "limpiar todo lo dibujado",
    "clearAllDrawn": "limpiar todo lo dibujado",
    "bitbybit.babylon.scene.clearAllDrawn_description": "elimina todos los objetos dibujados de la escena 3d",
    "bitbybit.babylon.scene.enableSkybox": "habilitar skybox",
    "enableSkybox": "habilitar skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "activa el skybox en la escena",
    "skybox": "skybox",
    "Base.skyboxEnum": "enum de skybox base",
    "blur": "desenfoque",
    "environmentIntensity": "intensidad del entorno",
    "bitbybit.babylon.scene.fog": "niebla",
    "fog": "niebla",
    "bitbybit.babylon.scene.fog_description": "activa el modo niebla en la escena",
    "mode": "modo",
    "Base.fogModeEnum": "enum de modo de niebla base",
    "color": "color",
    "density": "densidad",
    "start": "inicio",
    "end": "fin",
    "bitbybit.babylon.transforms.rotationCenterAxis": "eje de rotación central",
    "transforms": "transformaciones",
    "rotationCenterAxis": "eje de rotación central",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "crea una transformación de rotación alrededor del centro y un eje",
    "center": "centro",
    "bitbybit.babylon.transforms.rotationCenterX": "rotación centro x",
    "rotationCenterX": "rotación centro x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "crea una transformación de rotación alrededor del centro y el eje x",
    "bitbybit.babylon.transforms.rotationCenterY": "rotación centro y",
    "rotationCenterY": "rotación centro y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "crea una transformación de rotación alrededor del centro y el eje y",
    "bitbybit.babylon.transforms.rotationCenterZ": "rotación centro z",
    "rotationCenterZ": "rotación centro z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "crea una transformación de rotación alrededor del centro y el eje z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "rotación centro guiñada cabeceo balanceo",
    "rotationCenterYawPitchRoll": "rotación centro guiñada cabeceo balanceo",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "crea una transformación de rotación con guiñada, cabeceo y balanceo",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "escala centro xyz",
    "scaleCenterXYZ": "escala centro xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "crea una transformación de escala alrededor del centro en xyz",
    "scaleXyz": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "escala xyz",
    "scaleXYZ": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "crea una transformación de escala en las direcciones x, y, z",
    "bitbybit.babylon.transforms.uniformScale": "escala uniforme",
    "uniformScale": "escala uniforme",
    "bitbybit.babylon.transforms.uniformScale_description": "crea una transformación de escala uniforme",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "escala uniforme desde el centro",
    "uniformScaleFromCenter": "escala uniforme desde el centro",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "crea una transformación de escala uniforme desde el centro",
    "bitbybit.babylon.transforms.translationXYZ": "traslación xyz",
    "translationXYZ": "traslación xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "crea una transformación de traslación",
    "translation": "traslación",
    "bitbybit.babylon.transforms.translationsXYZ": "traslaciones xyz",
    "translationsXYZ": "traslaciones xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "crea múltiples transformaciones de traslación",
    "translations": "traslaciones",
    "Base.Vector3[]": "array de vectores base 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "cargar activo en escena",
    "io": "io",
    "loadAssetIntoScene": "cargar activo en escena",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "importa malla desde el activo del proyecto cargado",
    "load": "cargar",
    "assetFile": "archivo de activo",
    "File": "archivo",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "cargar activo en escena sin retorno",
    "loadAssetIntoSceneNoReturn": "cargar activo en escena sin retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "importa malla desde el activo del proyecto cargado, sin salida",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "cargar activo en escena desde url raíz",
    "loadAssetIntoSceneFromRootUrl": "cargar activo en escena desde url raíz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "importa malla desde una url web pública, requiere cors",
    "rootUrl": "url raíz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "cargar activo en escena desde url raíz sin retorno",
    "loadAssetIntoSceneFromRootUrlNoReturn": "cargar activo en escena desde url raíz sin retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "importa malla desde una url web pública, sin salida, requiere cors",
    "bitbybit.babylon.io.exportBabylon": "exportar babylon",
    "exportBabylon": "exportar babylon",
    "bitbybit.babylon.io.exportBabylon_description": "exporta la escena a formato .babylon para edición",
    "export": "exportar",
    "fileName": "nombre de archivo",
    "bitbybit.babylon.io.exportGLB": "exportar glb",
    "exportGLB": "exportar glb",
    "bitbybit.babylon.io.exportGLB_description": "exporta la escena a formato .glb, estándar web",
    "discardSkyboxAndGrid": "descartar skybox y cuadrícula",
    "bitbybit.babylon.io.exportMeshToStl": "exportar malla a stl",
    "exportMeshToStl": "exportar malla a stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "exporta la malla y sus hijos a stl",
    "bitbybit.babylon.io.exportMeshesToStl": "exportar mallas a stl",
    "exportMeshesToStl": "exportar mallas a stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "exporta múltiples mallas a stl",
    "meshes": "mallas",
    "bitbybit.babylon.ray.createPickingRay": "rayo de selección",
    "ray": "rayo",
    "createPickingRay": "rayo de selección",
    "bitbybit.babylon.ray.createPickingRay_description": "crea un rayo de selección desde la posición del ratón en la cámara activa",
    "bitbybit.babylon.ray.createRay": "rayo",
    "createRay": "rayo",
    "bitbybit.babylon.ray.createRay_description": "crea un rayo desde el origen con dirección y longitud opcional",
    "length": "longitud",
    "bitbybit.babylon.ray.createRayFromTo": "rayo desde hasta",
    "createRayFromTo": "rayo desde hasta",
    "bitbybit.babylon.ray.createRayFromTo_description": "crea un rayo entre dos puntos",
    "from": "desde",
    "to": "hasta",
    "bitbybit.babylon.ray.getOrigin": "obtener origen",
    "getOrigin": "obtener origen",
    "bitbybit.babylon.ray.getOrigin_description": "obtiene el origen del rayo",
    "BABYLON.Ray": "rayo de babylon",
    "bitbybit.babylon.ray.getDirection": "obtener dirección",
    "getDirection": "obtener dirección",
    "bitbybit.babylon.ray.getDirection_description": "obtiene la dirección del rayo",
    "bitbybit.babylon.ray.getLength": "obtener longitud",
    "getLength": "obtener longitud",
    "bitbybit.babylon.ray.getLength_description": "obtiene la longitud del rayo",
    "bitbybit.babylon.pick.pickWithRay": "seleccionar con rayo",
    "pick": "seleccionar",
    "pickWithRay": "seleccionar con rayo",
    "bitbybit.babylon.pick.pickWithRay_description": "obtiene el resultado de impacto de la selección con rayo",
    "bitbybit.babylon.pick.pickWithPickingRay": "seleccionar con rayo de selección",
    "pickWithPickingRay": "seleccionar con rayo de selección",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "selecciona con un rayo desde la posición del ratón en la cámara activa",
    "bitbybit.babylon.pick.getDistance": "obtener distancia",
    "getDistance": "obtener distancia",
    "bitbybit.babylon.pick.getDistance_description": "obtiene la distancia al objeto si se seleccionó",
    "get from pick info": "obtener desde info de selección",
    "pickInfo": "info de selección",
    "BABYLON.PickingInfo": "info de selección de babylon",
    "bitbybit.babylon.pick.getPickedMesh": "obtener malla seleccionada",
    "getPickedMesh": "obtener malla seleccionada",
    "bitbybit.babylon.pick.getPickedMesh_description": "obtiene la malla que fue seleccionada",
    "bitbybit.babylon.pick.getPickedPoint": "obtener punto seleccionado",
    "getPickedPoint": "obtener punto seleccionado",
    "bitbybit.babylon.pick.getPickedPoint_description": "obtiene el punto que fue seleccionado",
    "bitbybit.babylon.pick.hit": "impacto",
    "hit": "impacto",
    "bitbybit.babylon.pick.hit_description": "comprueba si el rayo impactó algo en la escena",
    "bitbybit.babylon.pick.getSubMeshId": "obtener id de submalla",
    "getSubMeshId": "obtener id de submalla",
    "bitbybit.babylon.pick.getSubMeshId_description": "obtiene el id único de la submalla si se seleccionó",
    "bitbybit.babylon.pick.getSubMeshFaceId": "obtener id de cara de submalla",
    "getSubMeshFaceId": "obtener id de cara de submalla",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "obtiene el id único de la cara de la submalla si se seleccionó",
    "bitbybit.babylon.pick.getBU": "obtener bu",
    "getBU": "obtener bu",
    "bitbybit.babylon.pick.getBU_description": "obtiene u baricéntrico para colisión de textura",
    "bitbybit.babylon.pick.getBV": "obtener bv",
    "getBV": "obtener bv",
    "bitbybit.babylon.pick.getBV_description": "obtiene v baricéntrico para colisión de textura",
    "bitbybit.babylon.pick.getPickedSprite": "obtener sprite seleccionado",
    "getPickedSprite": "obtener sprite seleccionado",
    "bitbybit.babylon.pick.getPickedSprite_description": "obtiene el sprite seleccionado",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr metálico rugoso",
    "pbrMetallicRoughness": "pbr metálico rugoso",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "crea un material pbr metálico rugoso",
    "baseColor": "color base",
    "emissiveColor": "color emisivo",
    "metallic": "metálico",
    "roughness": "rugosidad",
    "zOffset": "desplazamiento z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "establecer color base",
    "setBaseColor": "establecer color base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "establece el color base del material",
    "BABYLON.PBRMetallicRoughnessMaterial": "material pbr metálico rugoso de babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "establecer metálico",
    "setMetallic": "establecer metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "establece la propiedad metálica del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "establecer rugosidad",
    "setRoughness": "establecer rugosidad",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "establece la rugosidad del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "establecer alfa",
    "setAlpha": "establecer alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "establece el alfa del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "establecer descarte de cara trasera",
    "setBackFaceCulling": "establecer descarte de cara trasera",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "establece el descarte de cara trasera del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "establecer textura base",
    "setBaseTexture": "establecer textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "establece la textura del material",
    "baseTexture": "textura base",
    "BABYLON.Texture": "textura de babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "obtener color base",
    "getBaseColor": "obtener color base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "obtiene el color base del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "obtener metálico",
    "getMetallic": "obtener metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "obtiene la propiedad metálica del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "obtener rugosidad",
    "getRoughness": "obtener rugosidad",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "obtiene la rugosidad del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "obtener alfa",
    "getAlpha": "obtener alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "obtiene el alfa del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "obtener descarte de cara trasera",
    "getBackFaceCulling": "obtener descarte de cara trasera",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "obtiene el descarte de cara trasera del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "obtener textura base",
    "getBaseTexture": "obtener textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "obtiene la textura base del material",
    "bitbybit.babylon.material.skyMaterial.create": "material de cielo",
    "skyMaterial": "material de cielo",
    "bitbybit.babylon.material.skyMaterial.create_description": "crea un material de cielo",
    "luminance": "luminancia",
    "turbidity": "turbidez",
    "rayleigh": "rayleigh",
    "mieCoefficient": "coeficiente mie",
    "mieDirectionalG": "g direccional mie",
    "inclination": "inclinación",
    "azimuth": "azimut",
    "sunPosition": "posición del sol",
    "useSunPosition": "usar posición del sol",
    "cameraOffset": "desplazamiento de cámara",
    "up": "arriba",
    "dithering": "tramado",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "establecer luminancia",
    "setLuminance": "establecer luminancia",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "establece la luminancia del material de cielo",
    "MATERIALS.SkyMaterial": "material de cielo de materiales",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "establecer turbidez",
    "setTurbidity": "establecer turbidez",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "establece la turbidez del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "establecer rayleigh",
    "setRayleigh": "establecer rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "establece el rayleigh del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "establecer coeficiente mie",
    "setMieCoefficient": "establecer coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "establece el coeficiente mie del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "establecer g direccional mie",
    "setMieDirectionalG": "establecer g direccional mie",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "establece el g direccional mie del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setDistance": "establecer distancia",
    "setDistance": "establecer distancia",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "establece la distancia del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setInclination": "establecer inclinación",
    "setInclination": "establecer inclinación",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "establece la inclinación del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "establecer azimut",
    "setAzimuth": "establecer azimut",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "establece el azimut del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "establecer posición del sol",
    "setSunPosition": "establecer posición del sol",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "establece la posición del sol del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "establecer usar posición del sol",
    "setUseSunPosition": "establecer usar posición del sol",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "establece el uso de la posición del sol del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "establecer desplazamiento de cámara",
    "setCameraOffset": "establecer desplazamiento de cámara",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "establece el desplazamiento de cámara del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setUp": "establecer arriba",
    "setUp": "establecer arriba",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "establece la dirección arriba del material de cielo",
    "bitbybit.babylon.material.skyMaterial.setDithering": "establecer tramado",
    "setDithering": "establecer tramado",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "establece el tramado del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "obtener luminancia",
    "getLuminance": "obtener luminancia",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "obtiene la luminancia del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "obtener turbidez",
    "getTurbidity": "obtener turbidez",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "obtiene la turbidez del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "obtener rayleigh",
    "getRayleigh": "obtener rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "obtiene el rayleigh del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "obtener coeficiente mie",
    "getMieCoefficient": "obtener coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "obtiene el coeficiente mie del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "obtener g direccional mie",
    "getMieDirectionalG": "obtener g direccional mie",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "obtiene el g direccional mie del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getDistance": "obtener distancia",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "obtiene la distancia del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getInclination": "obtener inclinación",
    "getInclination": "obtener inclinación",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "obtiene la inclinación del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "obtener azimut",
    "getAzimuth": "obtener azimut",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "obtiene el azimut del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "obtener posición del sol",
    "getSunPosition": "obtener posición del sol",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "obtiene la posición del sol del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "obtener usar posición del sol",
    "getUseSunPosition": "obtener usar posición del sol",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "obtiene el uso de la posición del sol del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "obtener desplazamiento de cámara",
    "getCameraOffset": "obtener desplazamiento de cámara",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "obtiene el desplazamiento de cámara del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getUp": "obtener arriba",
    "getUp": "obtener arriba",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "obtiene la dirección arriba del material de cielo",
    "bitbybit.babylon.material.skyMaterial.getDithering": "obtener tramado",
    "getDithering": "obtener tramado",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "obtiene el tramado del material de cielo",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "establecer dirección al objetivo",
    "shadowLight": "luz de sombra",
    "setDirectionToTarget": "establecer dirección al objetivo",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "establece la dirección de la luz de sombra",
    "BABYLON.ShadowLight": "luz de sombra de babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "establecer posición",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "establece la posición de la luz de sombra",
    "bitbybit.babylon.meshBuilder.createBox": "caja",
    "meshBuilder": "constructor de mallas",
    "createBox": "caja",
    "bitbybit.babylon.meshBuilder.createBox_description": "crea una malla de caja",
    "create simple": "crear simple",
    "depth": "profundidad",
    "sideOrientation": "orientación lateral",
    "BabylonMesh.sideOrientationEnum": "enum de orientación lateral de malla de babylon",
    "bitbybit.babylon.meshBuilder.createCube": "cubo",
    "createCube": "cubo",
    "bitbybit.babylon.meshBuilder.createCube_description": "crea una malla de cubo",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "plano cuadrado",
    "createSquarePlane": "plano cuadrado",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "crea una malla de plano cuadrado",
    "bitbybit.babylon.meshBuilder.createSphere": "esfera",
    "createSphere": "esfera",
    "bitbybit.babylon.meshBuilder.createSphere_description": "crea una malla de esfera",
    "diameter": "diámetro",
    "segments": "segmentos",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "icoesfera",
    "createIcoSphere": "icoesfera",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "crea una malla de icoesfera",
    "radiusX": "radio x",
    "radiusY": "radio y",
    "radiusZ": "radio z",
    "flat": "plano",
    "bitbybit.babylon.meshBuilder.createDisc": "disco",
    "createDisc": "disco",
    "bitbybit.babylon.meshBuilder.createDisc_description": "crea una malla de disco",
    "tessellation": "teselación",
    "arc": "arco",
    "bitbybit.babylon.meshBuilder.createTorus": "toro",
    "createTorus": "toro",
    "bitbybit.babylon.meshBuilder.createTorus_description": "crea una malla de toro",
    "thickness": "grosor",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "nudo toroidal",
    "createTorusKnot": "nudo toroidal",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "crea una malla de nudo toroidal",
    "tube": "tubo",
    "radialSegments": "segmentos radiales",
    "tubularSegments": "segmentos tubulares",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polígono",
    "createPolygon": "polígono",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "crea una malla de polígono",
    "shape": "forma",
    "holes": "agujeros",
    "Base.Vector3[][]": "array de array de vectores base 3",
    "smoothingThreshold": "umbral de suavizado",
    "wrap": "envolver",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extruir polígono",
    "extrudePolygon": "extruir polígono",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "crea una malla de polígono extruido",
    "bitbybit.babylon.meshBuilder.createTube": "tubo",
    "createTube": "tubo",
    "bitbybit.babylon.meshBuilder.createTube_description": "crea una malla de tubo",
    "path": "ruta",
    "cap": "tapa",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "poliedro",
    "createPolyhedron": "poliedro",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "crea una malla de poliedro",
    "type": "tipo",
    "sizeX": "tamaño x",
    "sizeY": "tamaño y",
    "sizeZ": "tamaño z",
    "custom": "personalizado",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodésico",
    "createGeodesic": "geodésico",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "crea una malla geodésica",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "crea una malla goldberg",
    "bitbybit.babylon.meshBuilder.createCapsule": "cápsula",
    "createCapsule": "cápsula",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "crea una malla de cápsula",
    "orientation": "orientación",
    "capSubdivisions": "subdivisiones de tapa",
    "radiusTop": "radio superior",
    "radiusBottom": "radio inferior",
    "topCapSubdivisions": "subdivisiones de tapa superior",
    "bottomCapSubdivisions": "subdivisiones de tapa inferior",
    "bitbybit.babylon.meshBuilder.createCylinder": "cilindro",
    "createCylinder": "cilindro",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "crea una malla de cilindro",
    "diameterTop": "diámetro superior",
    "diameterBottom": "diámetro inferior",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "forma extruida",
    "createExtrudedSahpe": "forma extruida",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "crea una malla de forma extruida",
    "closeShape": "cerrar forma",
    "closePath": "cerrar ruta",
    "bitbybit.babylon.meshBuilder.createRibbon": "cinta",
    "createRibbon": "cinta",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "crea una malla de cinta",
    "pathArray": "array de rutas",
    "closeArray": "cerrar array",
    "offset": "desplazamiento",
    "bitbybit.babylon.meshBuilder.createLathe": "torno",
    "createLathe": "torno",
    "bitbybit.babylon.meshBuilder.createLathe_description": "crea una malla de torno",
    "closed": "cerrado",
    "bitbybit.babylon.meshBuilder.createGround": "suelo",
    "createGround": "suelo",
    "bitbybit.babylon.meshBuilder.createGround_description": "crea una malla de suelo",
    "subdivisionsX": "subdivisiones x",
    "subdivisionsY": "subdivisiones y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "plano rectangular",
    "createRectanglePlane": "plano rectangular",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "crea una malla de plano rectangular",
    "bitbybit.babylon.texture.createSimple": "textura simple",
    "texture": "textura",
    "createSimple": "simple",
    "bitbybit.babylon.texture.createSimple_description": "crea una textura desde url con opciones básicas",
    "invertY": "invertir y",
    "invertZ": "invertir z",
    "wAng": "ángulo w",
    "uScale": "escala u",
    "vScale": "escala v",
    "uOffset": "desplazamiento u",
    "vOffset": "desplazamiento v",
    "samplingMode": "modo de muestreo",
    "samplingModeEnum": "enum de modo de muestreo",
    "bitbybit.babylon.tools.createScreenshot": "captura de pantalla",
    "tools": "herramientas",
    "createScreenshot": "captura de pantalla",
    "bitbybit.babylon.tools.createScreenshot_description": "captura una captura de pantalla de la escena",
    "screenshots": "capturas de pantalla",
    "mimeType": "tipo mime",
    "quality": "calidad",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "captura de pantalla y descargar",
    "createScreenshotAndDownload": "captura de pantalla y descargar",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "captura y descarga una captura de pantalla de la escena",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interfaz de usuario a pantalla completa",
    "gui": "gui",
    "advancedDynamicTexture": "textura dinámica avanzada",
    "createFullScreenUI": "interfaz de usuario a pantalla completa",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "crea una interfaz de usuario a pantalla completa",
    "spaces": "espacios",
    "foreground": "primer plano",
    "adaptiveScaling": "escalado adaptativo",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "para malla",
    "createForMesh": "para malla",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "crea una textura para la malla",
    "BABYLON.AbstractMesh": "malla abstracta de babylon",
    "supportPointerMove": "soportar movimiento de puntero",
    "onlyAlphaTesting": "solo prueba alfa",
    "sampling": "muestreo",
    "BabylonTexture.samplingModeEnum": "enum de modo de muestreo de textura de babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "cambiar relleno de control",
    "control": "control",
    "changeControlPadding": "cambiar relleno de control",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "establece el relleno del control",
    "positioning": "posicionamiento",
    "BABYLON.GUI.Control": "control gui de babylon",
    "paddingLeft": "relleno izquierdo",
    "number | string": "número o cadena",
    "paddingRight": "relleno derecho",
    "paddingTop": "relleno superior",
    "paddingBottom": "relleno inferior",
    "bitbybit.babylon.gui.control.changeControlAlignment": "cambiar alineación de control",
    "changeControlAlignment": "cambiar alineación de control",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "establece la alineación del control",
    "T": "t",
    "horizontalAlignment": "alineación horizontal",
    "horizontalAlignmentEnum": "enum de alineación horizontal",
    "verticalAlignment": "alineación vertical",
    "verticalAlignmentEnum": "enum de alineación vertical",
    "bitbybit.babylon.gui.control.cloneControl": "clonar control",
    "cloneControl": "clonar control",
    "bitbybit.babylon.gui.control.cloneControl_description": "clona el control",
    "container": "contenedor",
    "BABYLON.GUI.Container": "contenedor gui de babylon",
    "host": "host",
    "BABYLON.GUI.AdvancedDynamicTexture": "textura dinámica avanzada gui de babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "selector observable de control",
    "createControlObservableSelector": "selector observable de control",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "crea un selector observable para el control",
    "selector": "selector",
    "controlObservableSelectorEnum": "enum de selector observable de control",
    "bitbybit.babylon.gui.control.getControlByName": "obtener control por nombre",
    "getControlByName": "obtener control por nombre",
    "bitbybit.babylon.gui.control.getControlByName_description": "obtiene el control por nombre",
    "bitbybit.babylon.gui.control.setIsVisible": "establecer es visible",
    "setIsVisible": "establecer es visible",
    "bitbybit.babylon.gui.control.setIsVisible_description": "establece la visibilidad del control",
    "isVisible": "es visible",
    "bitbybit.babylon.gui.control.setIsReadonly": "establecer solo lectura",
    "setIsReadonly": "establecer solo lectura",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "establece el control como solo lectura",
    "isReadOnly": "es solo lectura",
    "bitbybit.babylon.gui.control.setIsEnabled": "establecer habilitado",
    "setIsEnabled": "establecer habilitado",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "establece el control como habilitado",
    "isEnabled": "está habilitado",
    "bitbybit.babylon.gui.control.setHeight": "establecer altura",
    "setHeight": "establecer altura",
    "bitbybit.babylon.gui.control.setHeight_description": "establece la altura del control",
    "bitbybit.babylon.gui.control.setWidth": "establecer ancho",
    "setWidth": "establecer ancho",
    "bitbybit.babylon.gui.control.setWidth_description": "establece el ancho del control",
    "bitbybit.babylon.gui.control.setColor": "establecer color",
    "setColor": "establecer color",
    "bitbybit.babylon.gui.control.setColor_description": "establece el color del control",
    "bitbybit.babylon.gui.control.setFontSize": "establecer tamaño de fuente",
    "setFontSize": "establecer tamaño de fuente",
    "bitbybit.babylon.gui.control.setFontSize_description": "establece el tamaño de fuente del control",
    "fontSize": "tamaño de fuente",
    "bitbybit.babylon.gui.control.getHeight": "obtener altura",
    "getHeight": "obtener altura",
    "bitbybit.babylon.gui.control.getHeight_description": "obtiene la altura del control",
    "bitbybit.babylon.gui.control.getWidth": "obtener ancho",
    "getWidth": "obtener ancho",
    "bitbybit.babylon.gui.control.getWidth_description": "obtiene el ancho del control",
    "bitbybit.babylon.gui.control.getColor": "obtener color",
    "getColor": "obtener color",
    "bitbybit.babylon.gui.control.getColor_description": "obtiene el color del control",
    "bitbybit.babylon.gui.control.getFontSize": "obtener tamaño de fuente",
    "getFontSize": "obtener tamaño de fuente",
    "bitbybit.babylon.gui.control.getFontSize_description": "obtiene el tamaño de fuente del control",
    "bitbybit.babylon.gui.control.getIsVisible": "obtener es visible",
    "getIsVisible": "obtener es visible",
    "bitbybit.babylon.gui.control.getIsVisible_description": "obtiene la visibilidad del control",
    "bitbybit.babylon.gui.control.getIsReadonly": "obtener es solo lectura",
    "getIsReadonly": "obtener es solo lectura",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "obtiene el estado de solo lectura del control",
    "bitbybit.babylon.gui.control.getIsEnabled": "obtener está habilitado",
    "getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "obtiene el estado de habilitado del control",
    "bitbybit.babylon.gui.container.addControls": "añadir controles",
    "addControls": "añadir controles",
    "bitbybit.babylon.gui.container.addControls_description": "añade controles al contenedor en orden",
    "controls": "controles",
    "BABYLON.GUI.Control[]": "array de control gui de babylon",
    "clearControlsFirst": "limpiar controles primero",
    "bitbybit.babylon.gui.container.setBackground": "establecer fondo",
    "setBackground": "establecer fondo",
    "bitbybit.babylon.gui.container.setBackground_description": "establece el fondo del contenedor",
    "background": "fondo",
    "bitbybit.babylon.gui.container.setIsReadonly": "establecer solo lectura",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "establece el contenedor como solo lectura",
    "bitbybit.babylon.gui.container.getBackground": "obtener fondo",
    "getBackground": "obtener fondo",
    "bitbybit.babylon.gui.container.getBackground_description": "obtiene el fondo del contenedor",
    "bitbybit.babylon.gui.container.getIsReadonly": "obtener es solo lectura",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "obtiene el estado de solo lectura del contenedor",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "panel de apilamiento",
    "stackPanel": "panel de apilamiento",
    "createStackPanel": "panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "crea un panel de apilamiento",
    "isVertical": "es vertical",
    "spacing": "espaciado",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "establecer es vertical",
    "setIsVertical": "establecer es vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "establece el panel de apilamiento vertical",
    "BABYLON.GUI.StackPanel": "panel de apilamiento gui de babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "establecer espaciado",
    "setSpacing": "establecer espaciado",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "establece el espaciado del panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.setWidth": "establecer ancho",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "establece el ancho del panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.setHeight": "establecer altura",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "establece la altura del panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "obtener es vertical",
    "getIsVertical": "obtener es vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "obtiene el estado vertical del panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "obtener espaciado",
    "getSpacing": "obtener espaciado",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "obtiene el espaciado del panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.getWidth": "obtener ancho",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "obtiene el ancho del panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.getHeight": "obtener altura",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "obtiene la altura del panel de apilamiento",
    "bitbybit.babylon.gui.button.createSimpleButton": "botón simple",
    "button": "botón",
    "createSimpleButton": "botón simple",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "crea un botón simple",
    "label": "etiqueta",
    "bitbybit.babylon.gui.button.setButtonText": "establecer texto de botón",
    "setButtonText": "establecer texto de botón",
    "bitbybit.babylon.gui.button.setButtonText_description": "establece el texto del botón",
    "BABYLON.GUI.Button": "botón gui de babylon",
    "text": "texto",
    "bitbybit.babylon.gui.button.getButtonText": "obtener texto de botón",
    "getButtonText": "obtener texto de botón",
    "bitbybit.babylon.gui.button.getButtonText_description": "obtiene el texto del botón",
    "bitbybit.babylon.gui.slider.createSlider": "deslizador",
    "slider": "deslizador",
    "createSlider": "deslizador",
    "bitbybit.babylon.gui.slider.createSlider_description": "crea un deslizador",
    "minimum": "mínimo",
    "maximum": "máximo",
    "value": "valor",
    "step": "paso",
    "displayThumb": "mostrar pulgar",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "cambiar pulgar del deslizador",
    "changeSliderThumb": "cambiar pulgar del deslizador",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "cambia las propiedades del pulgar del deslizador",
    "BABYLON.GUI.Slider": "deslizador gui de babylon",
    "isThumbCircle": "es pulgar circular",
    "thumbColor": "color del pulgar",
    "thumbWidth": "ancho del pulgar",
    "string | number": "cadena o número",
    "isThumbClamped": "está pulgar limitado",
    "bitbybit.babylon.gui.slider.setBorderColor": "establecer color de borde",
    "setBorderColor": "establecer color de borde",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "establece el color de borde del deslizador",
    "borderColor": "color de borde",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "establecer color de fondo",
    "setBackgroundColor": "establecer color de fondo",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "establece el color de fondo del deslizador",
    "backgroundColor": "color de fondo",
    "bitbybit.babylon.gui.slider.setMaximum": "establecer máximo",
    "setMaximum": "establecer máximo",
    "bitbybit.babylon.gui.slider.setMaximum_description": "establece el valor máximo del deslizador",
    "bitbybit.babylon.gui.slider.setMinimum": "establecer mínimo",
    "setMinimum": "establecer mínimo",
    "bitbybit.babylon.gui.slider.setMinimum_description": "establece el valor mínimo del deslizador",
    "bitbybit.babylon.gui.slider.setStep": "establecer paso",
    "setStep": "establecer paso",
    "bitbybit.babylon.gui.slider.setStep_description": "establece el valor de paso del deslizador",
    "bitbybit.babylon.gui.slider.setValue": "establecer valor",
    "setValue": "establecer valor",
    "bitbybit.babylon.gui.slider.setValue_description": "establece el valor del deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "selector observable de deslizador",
    "createSliderObservableSelector": "selector observable de deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "crea un selector observable para el deslizador",
    "sliderObservableSelectorEnum": "enum de selector observable de deslizador",
    "bitbybit.babylon.gui.slider.getBorderColor": "obtener color de borde",
    "getBorderColor": "obtener color de borde",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "obtiene el color de borde del deslizador",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "obtener color de fondo",
    "getBackgroundColor": "obtener color de fondo",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "obtiene el color de fondo del deslizador",
    "bitbybit.babylon.gui.slider.getMaximum": "obtener máximo",
    "getMaximum": "obtener máximo",
    "bitbybit.babylon.gui.slider.getMaximum_description": "obtiene el valor máximo del deslizador",
    "bitbybit.babylon.gui.slider.getMinimum": "obtener mínimo",
    "getMinimum": "obtener mínimo",
    "bitbybit.babylon.gui.slider.getMinimum_description": "obtiene el valor mínimo del deslizador",
    "bitbybit.babylon.gui.slider.getStep": "obtener paso",
    "getStep": "obtener paso",
    "bitbybit.babylon.gui.slider.getStep_description": "obtiene el valor de paso del deslizador",
    "bitbybit.babylon.gui.slider.getValue": "obtener valor",
    "getValue": "obtener valor",
    "bitbybit.babylon.gui.slider.getValue_description": "obtiene el valor del deslizador",
    "bitbybit.babylon.gui.slider.getThumbColor": "obtener color del pulgar",
    "getThumbColor": "obtener color del pulgar",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "obtiene el color del pulgar del deslizador",
    "bitbybit.babylon.gui.slider.getThumbWidth": "obtener ancho del pulgar",
    "getThumbWidth": "obtener ancho del pulgar",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "obtiene el ancho del pulgar del deslizador",
    "bitbybit.babylon.gui.slider.getIsVertical": "obtener es vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "obtiene el estado vertical del deslizador",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "obtener mostrar pulgar",
    "getDisplayThumb": "obtener mostrar pulgar",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "obtiene el estado de mostrar pulgar del deslizador",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "obtener es pulgar circular",
    "getIsThumbCircle": "obtener es pulgar circular",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "obtiene el estado de pulgar circular del deslizador",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "obtener está pulgar limitado",
    "getIsThumbClamped": "obtener está pulgar limitado",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "obtiene el estado de pulgar limitado del deslizador",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "bloque de texto",
    "textBlock": "bloque de texto",
    "createTextBlock": "bloque de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "crea un bloque de texto",
    "bitbybit.babylon.gui.textBlock.alignText": "alinear texto",
    "alignText": "alinear texto",
    "bitbybit.babylon.gui.textBlock.alignText_description": "establece la alineación del texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "establecer contorno de texto",
    "setTextOutline": "establecer contorno de texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "establece el contorno del texto",
    "BABYLON.GUI.TextBlock": "bloque de texto gui de babylon",
    "outlineWidth": "ancho de contorno",
    "outlineColor": "color de contorno",
    "bitbybit.babylon.gui.textBlock.setText": "establecer texto",
    "setText": "establecer texto",
    "bitbybit.babylon.gui.textBlock.setText_description": "establece el texto del bloque de texto",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "establecer redimensionar para ajustar",
    "setRsizeToFit": "establecer redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "establece redimensionar para ajustar",
    "resizeToFit": "redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "establecer ajuste de texto",
    "setTextWrapping": "establecer ajuste de texto",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "establece el ajuste de texto",
    "textWrapping": "ajuste de texto",
    "boolean | BABYLON.GUI.TextWrapping": "booleano o ajuste de texto gui de babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "establecer interlineado",
    "setLineSpacing": "establecer interlineado",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "establece el interlineado del texto",
    "lineSpacing": "interlineado",
    "bitbybit.babylon.gui.textBlock.getText": "obtener texto",
    "getText": "obtener texto",
    "bitbybit.babylon.gui.textBlock.getText_description": "obtiene el texto del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "obtener ajuste de texto",
    "getTextWrapping": "obtener ajuste de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "obtiene el ajuste de texto",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "obtener interlineado",
    "getLineSpacing": "obtener interlineado",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "obtiene el interlineado del texto",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "obtener ancho de contorno",
    "getOutlineWidth": "obtener ancho de contorno",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "obtiene el ancho del contorno del texto",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "obtener redimensionar para ajustar",
    "getResizeToFit": "obtener redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "obtiene el estado de redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "obtener alineación horizontal de texto",
    "getTextHorizontalAlignment": "obtener alineación horizontal de texto",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "obtiene la alineación horizontal del texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "obtener alineación vertical de texto",
    "getTextVerticalAlignment": "obtener alineación vertical de texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "obtiene la alineación vertical del texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "selector observable de bloque de texto",
    "createTextBlockObservableSelector": "selector observable de bloque de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "crea un selector observable para el bloque de texto",
    "textBlockObservableSelectorEnum": "enum de selector observable de bloque de texto",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "botón de radio",
    "radioButton": "botón de radio",
    "createRadioButton": "botón de radio",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "crea un botón de radio",
    "group": "grupo",
    "isChecked": "está marcado",
    "checkSizeRatio": "ratio de tamaño de marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "establecer ratio de tamaño de marca",
    "setCheckSizeRatio": "establecer ratio de tamaño de marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "establece el ratio de tamaño de marca del botón de radio",
    "BABYLON.GUI.RadioButton": "botón de radio gui de babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "establecer grupo",
    "setGroup": "establecer grupo",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "establece el grupo del botón de radio",
    "bitbybit.babylon.gui.radioButton.setBackground": "establecer fondo",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "establece el fondo del botón de radio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "obtener ratio de tamaño de marca",
    "getCheckSizeRatio": "obtener ratio de tamaño de marca",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "obtiene el ratio de tamaño de marca del botón de radio",
    "bitbybit.babylon.gui.radioButton.getGroup": "obtener grupo",
    "getGroup": "obtener grupo",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "obtiene el grupo del botón de radio",
    "bitbybit.babylon.gui.radioButton.getBackground": "obtener fondo",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "obtiene el fondo del botón de radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "selector observable de botón de radio",
    "createRadioButtonObservableSelector": "selector observable de botón de radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "crea un selector observable para el botón de radio",
    "radioButtonObservableSelectorEnum": "enum de selector observable de botón de radio",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "casilla de verificación",
    "checkbox": "casilla de verificación",
    "createCheckbox": "casilla de verificación",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "crea una casilla de verificación",
    "bitbybit.babylon.gui.checkbox.setBackground": "establecer fondo",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "establece el fondo de la casilla de verificación",
    "BABYLON.GUI.Checkbox": "casilla de verificación gui de babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "establecer ratio de tamaño de marca",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "establece el ratio de tamaño de marca de la casilla de verificación",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "establecer está marcado",
    "setIsChecked": "establecer está marcado",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "establece la casilla de verificación como marcada",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "obtener ratio de tamaño de marca",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "obtiene el ratio de tamaño de marca de la casilla de verificación",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "obtener está marcado",
    "getIsChecked": "obtener está marcado",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "obtiene el estado de marcado de la casilla de verificación",
    "bitbybit.babylon.gui.checkbox.getBackground": "obtener fondo",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "obtiene el fondo de la casilla de verificación",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "selector observable de casilla de verificación",
    "createCheckboxObservableSelector": "selector observable de casilla de verificación",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "crea un selector observable para la casilla de verificación",
    "checkboxObservableSelectorEnum": "enum de selector observable de casilla de verificación",
    "bitbybit.babylon.gui.inputText.createInputText": "entrada de texto",
    "inputText": "entrada de texto",
    "createInputText": "entrada de texto",
    "bitbybit.babylon.gui.inputText.createInputText_description": "crea una entrada de texto",
    "placeholder": "marcador de posición",
    "bitbybit.babylon.gui.inputText.setBackground": "establecer fondo",
    "bitbybit.babylon.gui.inputText.setBackground_description": "establece el fondo de la entrada de texto",
    "BABYLON.GUI.InputText": "entrada de texto gui de babylon",
    "bitbybit.babylon.gui.inputText.setText": "establecer texto",
    "bitbybit.babylon.gui.inputText.setText_description": "establece el texto de la entrada de texto",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "establecer marcador de posición",
    "setPlaceholder": "establecer marcador de posición",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "establece el marcador de posición de la entrada de texto",
    "bitbybit.babylon.gui.inputText.getBackground": "obtener fondo",
    "bitbybit.babylon.gui.inputText.getBackground_description": "obtiene el fondo de la entrada de texto",
    "bitbybit.babylon.gui.inputText.getText": "obtener texto",
    "bitbybit.babylon.gui.inputText.getText_description": "obtiene el texto de la entrada de texto",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "obtener marcador de posición",
    "getPlaceholder": "obtener marcador de posición",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "obtiene el marcador de posición de la entrada de texto",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "selector observable de entrada de texto",
    "createInputTextObservableSelector": "selector observable de entrada de texto",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "crea un selector observable para la entrada de texto",
    "inputTextObservableSelectorEnum": "enum de selector observable de entrada de texto",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "selector de color",
    "colorPicker": "selector de color",
    "createColorPicker": "selector de color",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "crea un selector de color",
    "defaultColor": "color predeterminado",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "establecer valor de selector de color",
    "setColorPickerValue": "establecer valor de selector de color",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "establece el valor del selector de color",
    "BABYLON.GUI.ColorPicker": "selector de color gui de babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "establecer tamaño de selector de color",
    "setColorPickerSize": "establecer tamaño de selector de color",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "establece el tamaño del selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "obtener valor de selector de color",
    "getColorPickerValue": "obtener valor de selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "obtiene el valor del selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "obtener tamaño de selector de color",
    "getColorPickerSize": "obtener tamaño de selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "obtiene el tamaño del selector de color",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "selector observable de selector de color",
    "createColorPickerObservableSelector": "selector observable de selector de color",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "crea un selector observable para el selector de color",
    "colorPickerObservableSelectorEnum": "enum de selector observable de selector de color",
    "bitbybit.babylon.gui.image.createImage": "imagen",
    "image": "imagen",
    "createImage": "imagen",
    "bitbybit.babylon.gui.image.createImage_description": "crea una imagen",
    "bitbybit.babylon.gui.image.setSourceUrl": "establecer url de origen",
    "setSourceUrl": "establecer url de origen",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "establece la url de origen de la imagen",
    "BABYLON.GUI.Image": "imagen gui de babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "obtener url de origen",
    "getSourceUrl": "obtener url de origen",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "obtiene la url de origen de la imagen",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gestor de gizmo",
    "gizmo": "gizmo",
    "manager": "gestor",
    "createGizmoManager": "gestor de gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "crea un gestor de gizmo",
    "positionGizmoEnabled": "gizmo de posición habilitado",
    "rotationGizmoEnabled": "gizmo de rotación habilitado",
    "scaleGizmoEnabled": "gizmo de escala habilitado",
    "boundingBoxGizmoEnabled": "gizmo de caja delimitadora habilitado",
    "usePointerToAttachGizmos": "usar puntero para adjuntar gizmos",
    "clearGizmoOnEmptyPointerEvent": "limpiar gizmo en evento de puntero vacío",
    "scaleRatio": "ratio de escala",
    "attachableMeshes": "mallas adjuntables",
    "BABYLON.AbstractMesh[]": "array de malla abstracta de babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "obtener gizmo de posición",
    "getPositionGizmo": "obtener gizmo de posición",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "obtiene el gizmo de posición",
    "gizmoManager": "gestor de gizmo",
    "BABYLON.GizmoManager": "gestor de gizmo de babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "obtener gizmo de rotación",
    "getRotationGizmo": "obtener gizmo de rotación",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "obtiene el gizmo de rotación",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "obtener gizmo de escala",
    "getScaleGizmo": "obtener gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "obtiene el gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "obtener gizmo de caja delimitadora",
    "getBoundingBoxGizmo": "obtener gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "obtiene el gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "adjuntar a malla",
    "attachToMesh": "adjuntar a malla",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "adjunta el gestor de gizmo a la malla",
    "update": "actualizar",
    "bitbybit.babylon.gizmo.manager.detachMesh": "desadjuntar malla",
    "detachMesh": "desadjuntar malla",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "desadjunta el gestor de gizmo de la malla",
    "bitbybit.babylon.gizmo.base.scaleRatio": "establecer ratio de escala",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "establece el ratio de escala del gizmo",
    "BABYLON.IGizmo": "i gizmo de babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "obtener ratio de escala",
    "getScaleRatio": "obtener ratio de escala",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "obtiene el ratio de escala del gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "establecer gizmo planar habilitado",
    "positionGizmo": "gizmo de posición",
    "planarGizmoEnabled": "gizmo planar habilitado",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "establece el gizmo planar como habilitado",
    "BABYLON.IPositionGizmo": "i gizmo de posición de babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "establecer distancia de ajuste",
    "snapDistance": "distancia de ajuste",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "establece la distancia de ajuste del gizmo de posición",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "obtener malla adjunta",
    "getAttachedMesh": "obtener malla adjunta",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "obtiene la malla adjunta",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "obtener nodo adjunto",
    "getAttachedNode": "obtener nodo adjunto",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "obtiene el nodo adjunto",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "obtener gizmo x",
    "getXGizmo": "obtener gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "obtiene el gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "obtener gizmo y",
    "getYGizmo": "obtener gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "obtiene el gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "obtener gizmo z",
    "getZGizmo": "obtener gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "obtiene el gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "obtener gizmo de plano x",
    "getXPlaneGizmo": "obtener gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "obtiene el gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "obtener gizmo de plano y",
    "getYPlaneGizmo": "obtener gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "obtiene el gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "obtener gizmo de plano z",
    "getZPlaneGizmo": "obtener gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "obtiene el gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "obtener gizmo planar habilitado",
    "getPlanarGizmoEnabled": "obtener gizmo planar habilitado",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "obtiene el estado de habilitado del gizmo planar",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "obtener distancia de ajuste",
    "getSnapDistance": "obtener distancia de ajuste",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "obtiene la distancia de ajuste",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "obtener está arrastrando",
    "getIsDragging": "obtener está arrastrando",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "obtiene el estado de arrastre",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "selector observable de gizmo de posición",
    "createPositionGizmoObservableSelector": "selector observable de gizmo de posición",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "crea un selector observable para el gizmo de posición",
    "positionGizmoObservableSelectorEnum": "enum de selector observable de gizmo de posición",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "establecer distancia de ajuste",
    "rotationGizmo": "gizmo de rotación",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "establece la distancia de ajuste del gizmo de rotación",
    "BABYLON.IRotationGizmo": "i gizmo de rotación de babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "establecer sensibilidad",
    "sensitivity": "sensibilidad",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "establece la sensibilidad del gizmo de rotación",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "obtener malla adjunta",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "obtiene la malla adjunta",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "obtener nodo adjunto",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "obtiene el nodo adjunto",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "obtener gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "obtiene el gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "obtener gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "obtiene el gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "obtener gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "obtiene el gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "obtener distancia de ajuste",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "obtiene la distancia de ajuste",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "obtener sensibilidad",
    "getSensitivity": "obtener sensibilidad",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "obtiene la sensibilidad",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "selector observable de gizmo de rotación",
    "createRotationGizmoObservableSelector": "selector observable de gizmo de rotación",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "crea un selector observable para el gizmo de rotación",
    "rotationGizmoObservableSelectorEnum": "enum de selector observable de gizmo de rotación",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "obtener gizmo x",
    "scaleGizmo": "gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "obtiene el gizmo x",
    "BABYLON.IScaleGizmo": "i gizmo de escala de babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "obtener gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "obtiene el gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "obtener gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "obtiene el gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "establecer distancia de ajuste",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "establece la distancia de ajuste del gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "establecer ajuste incremental",
    "setIncrementalSnap": "establecer ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "establece el ajuste incremental del gizmo de escala",
    "incrementalSnap": "ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "establecer sensibilidad",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "establece la sensibilidad del gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "obtener ajuste incremental",
    "getIncrementalSnap": "obtener ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "obtiene el ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "obtener distancia de ajuste",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "obtiene la distancia de ajuste",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "obtener sensibilidad",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "obtiene la sensibilidad",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "selector observable de gizmo de escala",
    "createScaleGizmoObservableSelector": "selector observable de gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "crea un selector observable para el gizmo de escala",
    "scaleGizmoObservableSelectorEnum": "enum de selector observable de gizmo de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "establecer tamaño de esfera de rotación",
    "boundingBoxGizmo": "gizmo de caja delimitadora",
    "setRotationSphereSize": "establecer tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "establece el tamaño de la esfera de rotación del gizmo de caja delimitadora",
    "BABYLON.BoundingBoxGizmo": "gizmo de caja delimitadora de babylon",
    "rotationSphereSize": "tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "establecer tamaño de pantalla de malla de arrastre fijo",
    "setFixedDragMeshScreenSize": "establecer tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "establece el tamaño de pantalla de malla de arrastre fijo para un escalado consistente",
    "fixedDragMeshScreenSize": "tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "establecer tamaño de límites de malla de arrastre fijo",
    "setFixedDragMeshBoundsSize": "establecer tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "establece el tamaño de los límites de la malla de arrastre fija",
    "fixedDragMeshBoundsSize": "tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "establecer factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "setFixedDragMeshScreenSizeDistanceFactor": "establecer factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "establece el factor de distancia para el tamaño de pantalla de la malla de arrastre fija",
    "fixedDragMeshScreenSizeDistanceFactor": "factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "establecer distancia de ajuste de escala",
    "setScalingSnapDistance": "establecer distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "establece la distancia de ajuste de escala del gizmo de caja delimitadora",
    "scalingSnapDistance": "distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "establecer distancia de ajuste de rotación",
    "setRotationSnapDistance": "establecer distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "establece la distancia de ajuste de rotación del gizmo de caja delimitadora",
    "rotationSnapDistance": "distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "establecer tamaño de caja de escala",
    "setScaleBoxSize": "establecer tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "establece el tamaño de la caja de escala del gizmo de caja delimitadora",
    "scaleBoxSize": "tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "establecer ajuste incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "establece el ajuste incremental del gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "establecer pivote de escala",
    "setScalePivot": "establecer pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "establece el pivote de escala del gizmo de caja delimitadora",
    "scalePivot": "pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "establecer factor de eje",
    "setAxisFactor": "establecer factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "establece el factor de eje del gizmo de caja delimitadora",
    "axisFactor": "factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "establecer velocidad de arrastre de escala",
    "setScaleDragSpeed": "establecer velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "establece la velocidad de arrastre de escala del gizmo de caja delimitadora",
    "scaleDragSpeed": "velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "obtener tamaño de esfera de rotación",
    "getRotationSphereSize": "obtener tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "obtiene el tamaño de la esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "obtener tamaño de caja de escala",
    "getScaleBoxSize": "obtener tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "obtiene el tamaño de la caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "obtener tamaño de pantalla de malla de arrastre fijo",
    "getFixedDragMeshScreenSize": "obtener tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "obtiene el tamaño de pantalla de la malla de arrastre fija",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "obtener tamaño de límites de malla de arrastre fijo",
    "getFixedDragMeshBoundsSize": "obtener tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "obtiene el tamaño de los límites de la malla de arrastre fija",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "obtener factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "getFixedDragMeshScreenSizeDistanceFactor": "obtener factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "obtiene el factor de distancia del tamaño de pantalla de la malla de arrastre fija",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "obtener distancia de ajuste de escala",
    "getScalingSnapDistance": "obtener distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "obtiene la distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "obtener distancia de ajuste de rotación",
    "getRotationSnapDistance": "obtener distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "obtiene la distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "obtener ajuste incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "obtiene el ajuste incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "obtener pivote de escala",
    "getScalePivot": "obtener pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "obtiene el pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "obtener factor de eje",
    "getAxisFactor": "obtener factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "obtiene el factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "obtener velocidad de arrastre de escala",
    "getScaleDragSpeed": "obtener velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "obtiene la velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "selector observable de gizmo de caja delimitadora",
    "createBoundingBoxGizmoObservableSelector": "selector observable de gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "crea un selector observable para el gizmo de caja delimitadora",
    "boundingBoxGizmoObservableSelectorEnum": "enum de selector observable de gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "establecer habilitado",
    "axisDragGizmo": "gizmo de arrastre de eje",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "establece el eje como habilitado",
    "BABYLON.IAxisDragGizmo": "i gizmo de arrastre de eje de babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "obtiene el estado de habilitado del eje",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "establecer habilitado",
    "axisScaleGizmo": "gizmo de escala de eje",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "establece el eje como habilitado",
    "BABYLON.IAxisScaleGizmo": "i gizmo de escala de eje de babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "obtiene el estado de habilitado del eje",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "establecer habilitado",
    "planeDragGizmo": "gizmo de arrastre de plano",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "establece el plano como habilitado",
    "BABYLON.IPlaneDragGizmo": "i gizmo de arrastre de plano de babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "obtiene el estado de habilitado del plano",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "establecer habilitado",
    "planeRotationGizmo": "gizmo de rotación de plano",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "establece el plano como habilitado",
    "BABYLON.IPlaneRotationGizmo": "i gizmo de rotación de plano de babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "obtiene el estado de habilitado del plano",
    "bitbybit.vector.removeAllDuplicateVectors": "eliminar todos los vectores duplicados",
    "vector": "vector",
    "removeAllDuplicateVectors": "eliminar todos los vectores duplicados",
    "bitbybit.vector.removeAllDuplicateVectors_description": "elimina todos los vectores duplicados del array",
    "remove": "eliminar",
    "vectors": "vectores",
    "number[][]": "array de array de números",
    "tolerance": "tolerancia",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "eliminar vectores duplicados consecutivos",
    "removeConsecutiveDuplicateVectors": "eliminar vectores duplicados consecutivos",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "elimina vectores duplicados consecutivos del array",
    "checkFirstAndLast": "comprobar primero y último",
    "bitbybit.vector.angleBetween": "ángulo entre",
    "angleBetween": "ángulo entre",
    "bitbybit.vector.angleBetween_description": "mide el ángulo entre dos vectores en grados",
    "angles": "ángulos",
    "first": "primero",
    "second": "segundo",
    "bitbybit.vector.angleBetweenNormalized2d": "ángulo entre normalizados 2d",
    "angleBetweenNormalized2d": "ángulo entre normalizados 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "mide el ángulo 2d normalizado entre dos vectores en grados",
    "bitbybit.vector.positiveAngleBetween": "ángulo positivo entre",
    "positiveAngleBetween": "ángulo positivo entre",
    "bitbybit.vector.positiveAngleBetween_description": "mide el ángulo positivo entre dos vectores con referencia en grados",
    "reference": "referencia",
    "bitbybit.vector.addAll": "sumar todos",
    "addAll": "sumar todos",
    "bitbybit.vector.addAll_description": "suma todos los valores xyz del vector en un nuevo vector",
    "sum": "suma",
    "bitbybit.vector.add": "sumar",
    "add": "sumar",
    "bitbybit.vector.add_description": "suma dos vectores",
    "bitbybit.vector.all": "todos",
    "all": "todos",
    "bitbybit.vector.all_description": "comprueba si todos los elementos del array booleano son verdaderos",
    "boolean[]": "array booleano",
    "bitbybit.vector.cross": "producto vectorial",
    "cross": "producto vectorial",
    "bitbybit.vector.cross_description": "calcula el producto vectorial de dos vectores",
    "bitbybit.vector.distSquared": "distancia al cuadrado",
    "distSquared": "distancia al cuadrado",
    "bitbybit.vector.distSquared_description": "distancia al cuadrado entre dos vectores",
    "bitbybit.vector.dist": "distancia",
    "dist": "distancia",
    "bitbybit.vector.dist_description": "distancia entre dos vectores",
    "bitbybit.vector.div": "dividir",
    "div": "dividir",
    "bitbybit.vector.div_description": "divide el vector por un escalar",
    "scalar": "escalar",
    "bitbybit.vector.domain": "dominio",
    "domain": "dominio",
    "bitbybit.vector.domain_description": "calcula el dominio entre el mínimo y el máximo del vector",
    "bitbybit.vector.dot": "producto escalar",
    "dot": "producto escalar",
    "bitbybit.vector.dot_description": "producto escalar de dos vectores",
    "bitbybit.vector.finite": "finito",
    "finite": "finito",
    "bitbybit.vector.finite_description": "comprueba si los números del vector son finitos",
    "validate": "validar",
    "bitbybit.vector.isZero": "es cero",
    "isZero": "es cero",
    "bitbybit.vector.isZero_description": "comprueba si la longitud del vector es cero",
    "bitbybit.vector.lerp": "interpolación lineal",
    "lerp": "interpolación lineal",
    "bitbybit.vector.lerp_description": "encuentra el vector entre dos vectores por fracción",
    "fraction": "fracción",
    "bitbybit.vector.max": "máximo",
    "max": "máximo",
    "bitbybit.vector.max_description": "encuentra el valor máximo en el vector",
    "extract": "extraer",
    "bitbybit.vector.min": "mínimo",
    "min": "mínimo",
    "bitbybit.vector.min_description": "encuentra el valor mínimo en el vector",
    "bitbybit.vector.mul": "multiplicar",
    "mul": "multiplicar",
    "bitbybit.vector.mul_description": "multiplica el vector por un escalar",
    "bitbybit.vector.neg": "negar",
    "neg": "negar",
    "bitbybit.vector.neg_description": "niega el vector",
    "bitbybit.vector.normSquared": "norma al cuadrado",
    "normSquared": "norma al cuadrado",
    "bitbybit.vector.normSquared_description": "calcula la norma al cuadrado",
    "bitbybit.vector.norm": "norma",
    "norm": "norma",
    "bitbybit.vector.norm_description": "calcula la norma del vector",
    "bitbybit.vector.normalized": "normalizado",
    "normalized": "normalizado",
    "bitbybit.vector.normalized_description": "normaliza el vector a longitud unitaria",
    "bitbybit.vector.onRay": "en rayo",
    "onRay": "en rayo",
    "bitbybit.vector.onRay_description": "encuentra un punto en el rayo a una distancia dada",
    "bitbybit.vector.vectorXYZ": "vector xyz",
    "vectorXYZ": "vector xyz",
    "bitbybit.vector.vectorXYZ_description": "crea un vector xyz",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vector xy",
    "vectorXY": "vector xy",
    "bitbybit.vector.vectorXY_description": "crea un vector xy 2d",
    "bitbybit.vector.range": "rango",
    "range": "rango",
    "bitbybit.vector.range_description": "crea un vector de enteros desde 0 hasta max",
    "bitbybit.vector.signedAngleBetween": "ángulo con signo entre",
    "signedAngleBetween": "ángulo con signo entre",
    "bitbybit.vector.signedAngleBetween_description": "calcula el ángulo con signo entre dos vectores con referencia",
    "bitbybit.vector.span": "intervalo",
    "span": "intervalo",
    "bitbybit.vector.span_description": "crea un vector que abarca desde min hasta max con un paso",
    "bitbybit.vector.spanEaseItems": "intervalo con elementos suavizados",
    "spanEaseItems": "intervalo con elementos suavizados",
    "bitbybit.vector.spanEaseItems_description": "crea un vector que abarca desde min hasta max con función de suavizado",
    "nrItems": "número de elementos",
    "ease": "suavizado",
    "Math.easeEnum": "enum de suavizado matemático",
    "intervals": "intervalos",
    "bitbybit.vector.spanLinearItems": "intervalo con elementos lineales",
    "spanLinearItems": "intervalo con elementos lineales",
    "bitbybit.vector.spanLinearItems_description": "crea un vector que abarca desde min hasta max con un número de elementos",
    "bitbybit.vector.sub": "restar",
    "sub": "restar",
    "bitbybit.vector.sub_description": "resta dos vectores",
    "bitbybit.vector.sum": "suma",
    "bitbybit.vector.sum_description": "suma los valores del vector",
    "bitbybit.point.transformPoint": "transformar punto",
    "transformPoint": "transformar punto",
    "bitbybit.point.transformPoint_description": "transforma un solo punto",
    "transformation": "transformación",
    "Base.TransformMatrixes": "matrices de transformación base",
    "bitbybit.point.transformPoints": "transformar puntos",
    "transformPoints": "transformar puntos",
    "bitbybit.point.transformPoints_description": "transforma múltiples puntos",
    "points": "puntos",
    "bitbybit.point.transformsForPoints": "transformaciones para puntos",
    "transformsForPoints": "transformaciones para puntos",
    "bitbybit.point.transformsForPoints_description": "transforma múltiples puntos con múltiples transformaciones",
    "Base.TransformMatrixes[]": "array de matrices de transformación base",
    "bitbybit.point.translatePoints": "trasladar puntos",
    "translatePoints": "trasladar puntos",
    "bitbybit.point.translatePoints_description": "traslada múltiples puntos",
    "bitbybit.point.translatePointsWithVectors": "trasladar puntos con vectores",
    "translatePointsWithVectors": "trasladar puntos con vectores",
    "bitbybit.point.translatePointsWithVectors_description": "traslada múltiples puntos con vectores",
    "bitbybit.point.translateXYZPoints": "trasladar puntos xyz",
    "translateXYZPoints": "trasladar puntos xyz",
    "bitbybit.point.translateXYZPoints_description": "traslada múltiples puntos por valores xyz",
    "bitbybit.point.scalePointsCenterXYZ": "escalar puntos centro xyz",
    "scalePointsCenterXYZ": "escalar puntos centro xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "escala múltiples puntos desde el centro con factores xyz",
    "bitbybit.point.rotatePointsCenterAxis": "rotar puntos centro eje",
    "rotatePointsCenterAxis": "rotar puntos centro eje",
    "bitbybit.point.rotatePointsCenterAxis_description": "rota múltiples puntos alrededor del centro y un eje",
    "bitbybit.point.closestPointFromPointsDistance": "distancia al punto más cercano desde puntos",
    "closestPointFromPointsDistance": "distancia al punto más cercano desde puntos",
    "bitbybit.point.closestPointFromPointsDistance_description": "mide la distancia más cercana a los puntos",
    "bitbybit.point.closestPointFromPointsIndex": "índice del punto más cercano desde puntos",
    "closestPointFromPointsIndex": "índice del punto más cercano desde puntos",
    "bitbybit.point.closestPointFromPointsIndex_description": "encuentra el índice del punto más cercano comenzando en 1",
    "bitbybit.point.closestPointFromPoints": "punto más cercano desde puntos",
    "closestPointFromPoints": "punto más cercano desde puntos",
    "bitbybit.point.closestPointFromPoints_description": "encuentra el punto más cercano en la colección",
    "bitbybit.point.distance": "distancia",
    "bitbybit.point.distance_description": "mide la distancia entre dos puntos",
    "measure": "medir",
    "startPoint": "punto de inicio",
    "endPoint": "punto final",
    "bitbybit.point.distancesToPoints": "distancias a puntos",
    "distancesToPoints": "distancias a puntos",
    "bitbybit.point.distancesToPoints_description": "mide las distancias desde el inicio a múltiples puntos finales",
    "endPoints": "puntos finales",
    "bitbybit.point.multiplyPoint": "multiplicar punto",
    "multiplyPoint": "multiplicar punto",
    "bitbybit.point.multiplyPoint_description": "multiplica el punto por una cantidad",
    "amountOfPoints": "cantidad de puntos",
    "bitbybit.point.getX": "obtener x",
    "getX": "obtener x",
    "bitbybit.point.getX_description": "obtiene la coordenada x del punto",
    "bitbybit.point.getY": "obtener y",
    "getY": "obtener y",
    "bitbybit.point.getY_description": "obtiene la coordenada y del punto",
    "bitbybit.point.getZ": "obtener z",
    "getZ": "obtener z",
    "bitbybit.point.getZ_description": "obtiene la coordenada z del punto",
    "bitbybit.point.averagePoint": "punto promedio",
    "averagePoint": "punto promedio",
    "bitbybit.point.averagePoint_description": "obtiene el punto promedio de los puntos",
    "bitbybit.point.pointXYZ": "punto xyz",
    "pointXYZ": "punto xyz",
    "bitbybit.point.pointXYZ_description": "crea un punto xyz",
    "bitbybit.point.pointXY": "punto xy",
    "pointXY": "punto xy",
    "bitbybit.point.pointXY_description": "crea un punto xy",
    "bitbybit.point.spiral": "espiral",
    "spiral": "espiral",
    "bitbybit.point.spiral_description": "crea una espiral a partir de múltiples puntos",
    "phi": "phi",
    "numberPoints": "número de puntos",
    "widening": "ensanchamiento",
    "factor": "factor",
    "bitbybit.point.hexGrid": "cuadrícula hexagonal",
    "hexGrid": "cuadrícula hexagonal",
    "bitbybit.point.hexGrid_description": "crea una cuadrícula hexagonal plana en el plano xy",
    "nrHexagonsY": "núm hexágonos y",
    "nrHexagonsX": "núm hexágonos x",
    "radiusHexagon": "radio hexágono",
    "orientOnCenter": "orientar en centro",
    "pointsOnGround": "puntos en el suelo",
    "bitbybit.point.removeConsecutiveDuplicates": "eliminar duplicados consecutivos",
    "removeConsecutiveDuplicates": "eliminar duplicados consecutivos",
    "bitbybit.point.removeConsecutiveDuplicates_description": "elimina duplicados consecutivos del array de puntos",
    "clean": "limpiar",
    "bitbybit.line.convertToNurbsCurve": "convertir a curva nurbs",
    "line": "línea",
    "convertToNurbsCurve": "convertir a curva nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "convierte la línea a curva nurbs",
    "LinePointsDto": "dto puntos línea",
    "bitbybit.line.convertLinesToNurbsCurves": "convertir líneas a curvas nurbs",
    "convertLinesToNurbsCurves": "convertir líneas a curvas nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "convierte las líneas a un array de curvas nurbs",
    "lines": "líneas",
    "LinePointsDto[]": "array dto puntos línea",
    "bitbybit.line.getStartPoint": "obtener punto inicial",
    "getStartPoint": "obtener punto inicial",
    "bitbybit.line.getStartPoint_description": "obtiene el punto inicial de la línea",
    "bitbybit.line.getEndPoint": "obtener punto final",
    "getEndPoint": "obtener punto final",
    "bitbybit.line.getEndPoint_description": "obtiene el punto final de la línea",
    "bitbybit.line.length": "longitud",
    "bitbybit.line.length_description": "obtiene la longitud de la línea",
    "bitbybit.line.reverse": "invertir",
    "reverse": "invertir",
    "bitbybit.line.reverse_description": "invierte los puntos finales de la línea",
    "bitbybit.line.transformLine": "transformar línea",
    "transformLine": "transformar línea",
    "bitbybit.line.transformLine_description": "transforma la línea",
    "bitbybit.line.transformsForLines": "transformaciones para líneas",
    "transformsForLines": "transformaciones para líneas",
    "bitbybit.line.transformsForLines_description": "transforma múltiples líneas",
    "bitbybit.line.create": "crear",
    "bitbybit.line.create_description": "crea una línea",
    "bitbybit.line.createAsync": "asíncrono",
    "createAsync": "asíncrono",
    "bitbybit.line.createAsync_description": "crea una línea a partir de puntos asíncronos",
    "bitbybit.line.getPointOnLine": "obtener punto en línea",
    "getPointOnLine": "obtener punto en línea",
    "bitbybit.line.getPointOnLine_description": "obtiene un punto en la línea en el parámetro",
    "param": "parámetro",
    "bitbybit.line.linesBetweenPoints": "líneas entre puntos",
    "linesBetweenPoints": "líneas entre puntos",
    "bitbybit.line.linesBetweenPoints_description": "crea segmentos de línea entre puntos",
    "bitbybit.line.linesBetweenStartAndEndPoints": "líneas entre puntos iniciales y finales",
    "linesBetweenStartAndEndPoints": "líneas entre puntos iniciales y finales",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "crea líneas entre listas de puntos iniciales y finales",
    "startPoints": "puntos iniciales",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "líneas entre puntos iniciales y finales asíncrono",
    "linesBetweenStartAndEndPointsAsync": "líneas entre puntos iniciales y finales asíncrono",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "crea líneas entre puntos iniciales y finales con entradas asíncronas",
    "bitbybit.polyline.convertToNurbsCurve": "convertir a curva nurbs",
    "polyline": "polilínea",
    "bitbybit.polyline.convertToNurbsCurve_description": "convierte la polilínea a curva nurbs",
    "PolylinePropertiesDto": "dto propiedades polilínea",
    "bitbybit.polyline.length": "longitud",
    "bitbybit.polyline.length_description": "obtiene la longitud de la polilínea",
    "bitbybit.polyline.countPoints": "contar puntos",
    "countPoints": "contar puntos",
    "bitbybit.polyline.countPoints_description": "obtiene el recuento de puntos de la polilínea",
    "bitbybit.polyline.getPoints": "obtener puntos",
    "getPoints": "obtener puntos",
    "bitbybit.polyline.getPoints_description": "obtiene los puntos de la polilínea",
    "bitbybit.polyline.reverse": "invertir",
    "bitbybit.polyline.reverse_description": "invierte los puntos de la polilínea",
    "bitbybit.polyline.transformPolyline": "transformar polilínea",
    "transformPolyline": "transformar polilínea",
    "bitbybit.polyline.transformPolyline_description": "transforma la polilínea",
    "bitbybit.polyline.create": "crear",
    "bitbybit.polyline.create_description": "crea una polilínea",
    "isClosed": "está cerrado",
    "string | number[]": "cadena o array de números",
    "bitbybit.occt.deleteShape": "eliminar forma",
    "occt": "occt",
    "deleteShape": "eliminar forma",
    "bitbybit.occt.deleteShape_description": "elimina la forma de la caché",
    "bitbybit.occt.deleteShapes": "eliminar formas",
    "deleteShapes": "eliminar formas",
    "bitbybit.occt.deleteShapes_description": "elimina las formas de la caché",
    "shapes": "formas",
    "T[]": "array t",
    "bitbybit.occt.cleanAllCache": "limpiar toda la caché",
    "cleanAllCache": "limpiar toda la caché",
    "bitbybit.occt.cleanAllCache_description": "limpia toda la caché y las formas de la memoria",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "vértice desde xyz",
    "vertex": "vértice",
    "vertexFromXYZ": "vértice desde xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "crea un vértice a partir de coordenadas xyz",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "vértice desde punto",
    "vertexFromPoint": "vértice desde punto",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "crea un vértice a partir de un punto",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "vértices desde puntos",
    "verticesFromPoints": "vértices desde puntos",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "crea vértices a partir de puntos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "compuesto de vértices desde puntos",
    "verticesCompoundFromPoints": "compuesto de vértices desde puntos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "crea una forma compuesta de vértices",
    "bitbybit.occt.shapes.vertex.getVertices": "obtener vértices",
    "getVertices": "obtener vértices",
    "bitbybit.occt.shapes.vertex.getVertices_description": "obtiene todos los vértices de la forma",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "obtener vértices como puntos",
    "getVerticesAsPoints": "obtener vértices como puntos",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "obtiene todos los vértices como puntos",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "vértices a puntos",
    "verticesToPoints": "vértices a puntos",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforma vértices a puntos",
    "transform": "transformar",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "vértice a punto",
    "vertexToPoint": "vértice a punto",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "transforma vértice a punto",
    "bitbybit.occt.shapes.vertex.projectPoints": "proyectar puntos",
    "projectPoints": "proyectar puntos",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "proyecta puntos sobre la forma",
    "place": "colocar",
    "projectionType": "tipo de proyección",
    "pointProjectionTypeEnum": "enum tipo proyección punto",
    "bitbybit.occt.shapes.edge.line": "línea",
    "edge": "arista",
    "bitbybit.occt.shapes.edge.line_description": "crea una arista lineal entre dos puntos",
    "primitives": "primitivas",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arco por tres puntos",
    "arcThroughThreePoints": "arco por tres puntos",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "crea una arista de arco a través de tres puntos",
    "middle": "medio",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arco por dos puntos y tangente",
    "arcThroughTwoPointsAndTangent": "arco por dos puntos y tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "crea una arista de arco con tangente en el primer punto",
    "tangentVec": "vector tangente",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arco desde círculo y dos puntos",
    "arcFromCircleAndTwoPoints": "arco desde círculo y dos puntos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "crea una arista de arco en el círculo entre dos puntos",
    "circle": "círculo",
    "sense": "sentido",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arco desde círculo y dos ángulos",
    "arcFromCircleAndTwoAngles": "arco desde círculo y dos ángulos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "crea una arista de arco en el círculo entre dos ángulos",
    "alphaAngle1": "ángulo alfa 1",
    "alphaAngle2": "ángulo alfa 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arco desde círculo punto y ángulo",
    "arcFromCirclePointAndAngle": "arco desde círculo punto y ángulo",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "crea una arista de arco en el círculo desde un punto hasta un ángulo",
    "alphaAngle": "ángulo alfa",
    "bitbybit.occt.shapes.edge.createCircleEdge": "arista de círculo",
    "createCircleEdge": "arista de círculo",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "crea una arista de círculo de opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "arista de elipse",
    "createEllipseEdge": "arista de elipse",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "crea una arista de elipse de opencascade",
    "radiusMinor": "radio menor",
    "radiusMajor": "radio mayor",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "eliminar aristas internas",
    "removeInternalEdges": "eliminar aristas internas",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "elimina las aristas internas de la forma",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "hacer arista desde curva geom 2d y superficie",
    "makeEdgeFromGeom2dCurveAndSurface": "hacer arista desde curva geom 2d y superficie",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "crea una arista a partir de una curva geom y una superficie",
    "curve": "curva",
    "surface": "superficie",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "obtener arista",
    "getEdge": "obtener arista",
    "bitbybit.occt.shapes.edge.getEdge_description": "obtiene la arista por índice de la forma",
    "index": "índice",
    "bitbybit.occt.shapes.edge.getEdges": "obtener aristas",
    "getEdges": "obtener aristas",
    "bitbybit.occt.shapes.edge.getEdges_description": "obtiene las aristas de la forma",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "obtener aristas a lo largo del alambre",
    "getEdgesAlongWire": "obtener aristas a lo largo del alambre",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "obtiene las aristas a lo largo de la dirección del alambre",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "obtener aristas circulares a lo largo del alambre",
    "getCircularEdgesAlongWire": "obtener aristas circulares a lo largo del alambre",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "obtiene las aristas circulares a lo largo de la dirección del alambre",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "obtener aristas lineales a lo largo del alambre",
    "getLinearEdgesAlongWire": "obtener aristas lineales a lo largo del alambre",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "obtiene las aristas lineales a lo largo de la dirección del alambre",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "obtener puntos de esquina de aristas para forma",
    "getCornerPointsOfEdgesForShape": "obtener puntos de esquina de aristas para forma",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "obtiene los puntos de esquina únicos de las aristas",
    "bitbybit.occt.shapes.edge.getEdgeLength": "obtener longitud de arista",
    "getEdgeLength": "obtener longitud de arista",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "obtiene la longitud de la arista",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "obtener longitudes de arista de forma",
    "getEdgeLengthsOfShape": "obtener longitudes de arista de forma",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "obtiene las longitudes de las aristas de la forma",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "obtener longitudes de aristas",
    "getEdgesLengths": "obtener longitudes de aristas",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "obtiene las longitudes de las aristas",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "obtener centro de masa de arista",
    "getEdgeCenterOfMass": "obtener centro de masa de arista",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "obtiene el centro de masa de la arista",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "obtener centros de masa de aristas",
    "getEdgesCentersOfMass": "obtener centros de masa de aristas",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "obtiene los centros de masa de las aristas",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "obtener punto central de arista circular",
    "getCircularEdgeCenterPoint": "obtener punto central de arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "obtiene el punto central de la arista circular",
    "get circular edge": "obtener arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "obtener radio de arista circular",
    "getCircularEdgeRadius": "obtener radio de arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "obtiene el radio de la arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "obtener dirección de plano de arista circular",
    "getCircularEdgePlaneDirection": "obtener dirección de plano de arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "obtiene la dirección del plano de la arista circular",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "punto en arista en parámetro",
    "pointOnEdgeAtParam": "punto en arista en parámetro",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "obtiene un punto en la arista en el parámetro",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "puntos en aristas en parámetro",
    "pointsOnEdgesAtParam": "puntos en aristas en parámetro",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "obtiene puntos en las aristas en el parámetro",
    "bitbybit.occt.shapes.edge.edgesToPoints": "aristas a puntos",
    "edgesToPoints": "aristas a puntos",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "obtiene los puntos de las aristas en listas separadas",
    "angularDeflection": "deflexión angular",
    "curvatureDeflection": "deflexión de curvatura",
    "minimumOfPoints": "mínimo de puntos",
    "uTolerance": "tolerancia u",
    "minimumLength": "longitud mínima",
    "bitbybit.occt.shapes.edge.reversedEdge": "arista invertida",
    "reversedEdge": "arista invertida",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "calcula la arista invertida",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangente en arista en parámetro",
    "tangentOnEdgeAtParam": "tangente en arista en parámetro",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "obtiene el vector tangente en la arista en el parámetro",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangentes en aristas en parámetro",
    "tangentsOnEdgesAtParam": "tangentes en aristas en parámetro",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "obtiene los vectores tangentes en las aristas en el parámetro",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "punto en arista en longitud",
    "pointOnEdgeAtLength": "punto en arista en longitud",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "obtiene un punto en la arista en la longitud",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "puntos en aristas en longitud",
    "pointsOnEdgesAtLength": "puntos en aristas en longitud",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "obtiene puntos en las aristas en la longitud",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangente en arista en longitud",
    "tangentOnEdgeAtLength": "tangente en arista en longitud",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "obtiene el vector tangente en la arista en la longitud",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangentes en aristas en longitud",
    "tangentsOnEdgesAtLength": "tangentes en aristas en longitud",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "obtiene los vectores tangentes en las aristas en la longitud",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "punto inicial en arista",
    "startPointOnEdge": "punto inicial en arista",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "obtiene el punto inicial en la arista",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "puntos iniciales en aristas",
    "startPointsOnEdges": "puntos iniciales en aristas",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "obtiene los puntos iniciales en las aristas",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "punto final en arista",
    "endPointOnEdge": "punto final en arista",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "obtiene el punto final en la arista",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "puntos finales en aristas",
    "endPointsOnEdges": "puntos finales en aristas",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "obtiene los puntos finales en las aristas",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "dividir arista por parámetros a puntos",
    "divideEdgeByParamsToPoints": "dividir arista por parámetros a puntos",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divide la arista por parámetros a puntos",
    "nrOfDivisions": "núm de divisiones",
    "removeStartPoint": "eliminar punto inicial",
    "removeEndPoint": "eliminar punto final",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "dividir aristas por parámetros a puntos",
    "divideEdgesByParamsToPoints": "dividir aristas por parámetros a puntos",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divide las aristas por parámetros a puntos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "dividir arista por distancia igual a puntos",
    "divideEdgeByEqualDistanceToPoints": "dividir arista por distancia igual a puntos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divide la arista por longitud a puntos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "dividir aristas por distancia igual a puntos",
    "divideEdgesByEqualDistanceToPoints": "dividir aristas por distancia igual a puntos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divide las aristas por longitud a puntos",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "restringir líneas tangentes desde dos puntos a círculo",
    "constraintTanLinesFromTwoPtsToCircle": "restringir líneas tangentes desde dos puntos a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "crea líneas desde dos puntos hasta las tangentes del círculo",
    "constraint": "restricción",
    "point1": "punto 1",
    "point2": "punto 2",
    "positionResult": "resultado de posición",
    "positionResultEnum": "enum resultado posición",
    "circleRemainder": "resto del círculo",
    "circleInclusionEnum": "enum inclusión círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "restringir líneas tangentes desde punto a círculo",
    "constraintTanLinesFromPtToCircle": "restringir líneas tangentes desde punto a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "crea líneas desde un punto hasta las tangentes del círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "restringir líneas tangentes en dos círculos",
    "constraintTanLinesOnTwoCircles": "restringir líneas tangentes en dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "crea líneas tangentes entre dos círculos",
    "circle1": "círculo 1",
    "circle2": "círculo 2",
    "circleRemainders": "restos de círculo",
    "twoCircleInclusionEnum": "enum inclusión dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "restringir círculos tangentes en dos círculos",
    "constraintTanCirclesOnTwoCircles": "restringir círculos tangentes en dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "crea círculos tangentes entre dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "restringir círculos tangentes en círculo y punto",
    "constraintTanCirclesOnCircleAndPnt": "restringir círculos tangentes en círculo y punto",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "crea círculos tangentes entre un punto y un círculo",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "es arista lineal",
    "isEdgeLinear": "es arista lineal",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "comprueba si la arista es lineal",
    "is": "es",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "es arista circular",
    "isEdgeCircular": "es arista circular",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "comprueba si la arista es circular",
    "bitbybit.occt.shapes.wire.createPolygonWire": "alambre poligonal",
    "wire": "alambre",
    "createPolygonWire": "alambre poligonal",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "crea un alambre poligonal de opencascade",
    "via points": "vía puntos",
    "bitbybit.occt.shapes.wire.createPolygons": "polígonos",
    "createPolygons": "polígonos",
    "bitbybit.occt.shapes.wire.createPolygons_description": "crea polígonos de opencascade",
    "multiple": "múltiple",
    "polygons": "polígonos",
    "PolygonDto[]": "array dto polígono",
    "returnCompound": "retornar compuesto",
    "bitbybit.occt.shapes.wire.createLineWire": "alambre de línea",
    "createLineWire": "alambre de línea",
    "bitbybit.occt.shapes.wire.createLineWire_description": "crea un alambre de línea de opencascade",
    "bitbybit.occt.shapes.wire.createLines": "líneas",
    "createLines": "líneas",
    "bitbybit.occt.shapes.wire.createLines_description": "crea líneas de opencascade",
    "LineDto[]": "array dto línea",
    "bitbybit.occt.shapes.wire.splitOnPoints": "dividir en puntos",
    "splitOnPoints": "dividir en puntos",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "divide el alambre en los puntos dados",
    "bitbybit.occt.shapes.wire.wiresToPoints": "alambres a puntos",
    "wiresToPoints": "alambres a puntos",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "transforma alambres a puntos en listas ordenadas",
    "bitbybit.occt.shapes.wire.createPolylineWire": "alambre de polilínea",
    "createPolylineWire": "alambre de polilínea",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "crea un alambre de polilínea de opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zig zag entre dos alambres",
    "createZigZagBetweenTwoWires": "zig zag entre dos alambres",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "crea un zig zag entre dos alambres",
    "via wires": "vía alambres",
    "wire1": "alambre 1",
    "wire2": "alambre 2",
    "nrZigZags": "núm zig zags",
    "inverse": "inverso",
    "divideByEqualDistance": "dividir por distancia igual",
    "zigZagsPerEdge": "zig zags por arista",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "alambre desde dos círculos tangentes",
    "createWireFromTwoCirclesTan": "alambre desde dos círculos tangentes",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "crea un alambre tangente que encierra dos círculos planares",
    "keepLines": "mantener líneas",
    "twoSidesStrictEnum": "enum estricto dos lados",
    "fourSidesStrictEnum": "enum estricto cuatro lados",
    "bitbybit.occt.shapes.wire.createPolylines": "polilíneas",
    "createPolylines": "polilíneas",
    "bitbybit.occt.shapes.wire.createPolylines_description": "crea alambres de polilínea de opencascade",
    "polylines": "polilíneas",
    "PolylineDto[]": "array dto polilínea",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "crea un alambre bezier de opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "pesos bezier",
    "createBezierWeights": "pesos bezier",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "crea un alambre bezier de opencascade con pesos",
    "weights": "pesos",
    "bitbybit.occt.shapes.wire.createBezierWires": "alambres bezier",
    "createBezierWires": "alambres bezier",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "crea alambres bezier de opencascade",
    "bezierWires": "alambres bezier",
    "BezierDto[]": "array dto bezier",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpolar puntos",
    "interpolatePoints": "interpolar puntos",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "crea un alambre bspline de opencascade a partir de puntos",
    "periodic": "periódico",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpolar alambres",
    "interpolateWires": "interpolar alambres",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "crea múltiples alambres interpolados de opencascade",
    "interpolations": "interpolaciones",
    "InterpolationDto[]": "array dto interpolación",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "crea un alambre bspline de opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "crea alambres bspline de opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "array dto bspline",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combinar aristas y alambres en un alambre",
    "combineEdgesAndWiresIntoAWire": "combinar aristas y alambres en un alambre",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "combina aristas y alambres en un solo alambre",
    "build": "construir",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "alambre desde arista",
    "createWireFromEdge": "alambre desde arista",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "crea un alambre a partir de una arista",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "añadir aristas y alambres al alambre",
    "addEdgesAndWiresToWire": "añadir aristas y alambres al alambre",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "añade aristas y alambres al alambre",
    "U[]": "array u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "dividir alambre por parámetros a puntos",
    "divideWireByParamsToPoints": "dividir alambre por parámetros a puntos",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "divide el alambre en puntos por parámetros",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "dividir alambres por parámetros a puntos",
    "divideWiresByParamsToPoints": "dividir alambres por parámetros a puntos",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "divide los alambres en puntos por parámetros",
    "extract from wires": "extraer de alambres",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "dividir alambre por distancia igual a puntos",
    "divideWireByEqualDistanceToPoints": "dividir alambre por distancia igual a puntos",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "divide el alambre en puntos equidistantes",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "dividir alambres por distancia igual a puntos",
    "divideWiresByEqualDistanceToPoints": "dividir alambres por distancia igual a puntos",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "divide los alambres en puntos equidistantes",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "punto en alambre en parámetro",
    "pointOnWireAtParam": "punto en alambre en parámetro",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "obtiene un punto en el alambre en el parámetro",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "punto en alambre en longitud",
    "pointOnWireAtLength": "punto en alambre en longitud",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "obtiene un punto en el alambre en la longitud",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "puntos en alambre en longitudes",
    "pointsOnWireAtLengths": "puntos en alambre en longitudes",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "obtiene puntos en el alambre en las longitudes",
    "lengths": "longitudes",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "puntos en alambre en longitud igual",
    "pointsOnWireAtEqualLength": "puntos en alambre en longitud igual",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "obtiene puntos en el alambre en longitud igual",
    "tryNext": "probar siguiente",
    "includeFirst": "incluir primero",
    "includeLast": "incluir último",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "puntos en alambre en patrón de longitudes",
    "pointsOnWireAtPatternOfLengths": "puntos en alambre en patrón de longitudes",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "obtiene puntos en el alambre en un patrón de longitudes",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangente en alambre en parámetro",
    "tangentOnWireAtParam": "tangente en alambre en parámetro",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "obtiene el vector tangente en el alambre en el parámetro",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangente en alambre en longitud",
    "tangentOnWireAtLength": "tangente en alambre en longitud",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "obtiene el vector tangente en el alambre en la longitud",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "derivadas en alambre en longitud",
    "derivativesOnWireAtLength": "derivadas en alambre en longitud",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "calcula 3 derivadas en el alambre en la longitud",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "derivadas en alambre en parámetro",
    "derivativesOnWireAtParam": "derivadas en alambre en parámetro",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "calcula 3 derivadas en el alambre en el parámetro",
    "bitbybit.occt.shapes.wire.startPointOnWire": "punto inicial en alambre",
    "startPointOnWire": "punto inicial en alambre",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "obtiene el punto inicial en el alambre",
    "bitbybit.occt.shapes.wire.endPointOnWire": "punto final en alambre",
    "endPointOnWire": "punto final en alambre",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "obtiene el punto final en el alambre",
    "bitbybit.occt.shapes.wire.createCircleWire": "alambre de círculo",
    "createCircleWire": "alambre de círculo",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "crea un alambre de círculo de opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "alambre cuadrado",
    "createSquareWire": "alambre cuadrado",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "crea un alambre cuadrado de opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "alambre de estrella",
    "createStarWire": "alambre de estrella",
    "bitbybit.occt.shapes.wire.createStarWire_description": "crea un alambre de estrella de opencascade",
    "numRays": "núm rayos",
    "outerRadius": "radio exterior",
    "innerRadius": "radio interior",
    "offsetOuterEdges": "desplazar aristas exteriores",
    "half": "mitad",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "alambre de árbol de navidad",
    "createChristmasTreeWire": "alambre de árbol de navidad",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "crea un alambre de árbol de navidad",
    "innerDist": "distancia interior",
    "outerDist": "distancia exterior",
    "nrSkirts": "núm faldones",
    "trunkHeight": "altura tronco",
    "trunkWidth": "ancho tronco",
    "bitbybit.occt.shapes.wire.createNGonWire": "alambre de n-gono",
    "createNGonWire": "alambre de n-gono",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "crea un alambre de n-gono de opencascade",
    "nrCorners": "núm esquinas",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "alambre de paralelogramo",
    "createParallelogramWire": "alambre de paralelogramo",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "crea un alambre de paralelogramo",
    "aroundCenter": "alrededor del centro",
    "bitbybit.occt.shapes.wire.createHeartWire": "alambre de corazón",
    "createHeartWire": "alambre de corazón",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "crea un alambre de corazón",
    "sizeApprox": "tamaño aprox",
    "bitbybit.occt.shapes.wire.createRectangleWire": "alambre de rectángulo",
    "createRectangleWire": "alambre de rectángulo",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "crea un alambre de rectángulo de opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "alambre de polígono L",
    "createLPolygonWire": "alambre de polígono L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "crea un alambre de polígono L de opencascade",
    "widthFirst": "ancho primero",
    "lengthFirst": "longitud primero",
    "widthSecond": "ancho segundo",
    "lengthSecond": "longitud segundo",
    "align": "alinear",
    "directionEnum": "enum dirección",
    "bitbybit.occt.shapes.wire.createEllipseWire": "alambre de elipse",
    "createEllipseWire": "alambre de elipse",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "crea un alambre de elipse de opencascade",
    "bitbybit.occt.shapes.wire.textWires": "Contornos de texto",
    "textWires": "Contornos de texto",
    "bitbybit.occt.shapes.wire.textWires_description": "Crea contornos de texto OpenCascade basados en la fuente simplex creada por el Dr. A. V. Hershey.",
    "xOffset": "desplazamiento x",
    "yOffset": "desplazamiento y",
    "letterSpacing": "espaciado entre letras",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "desplazamiento de extrusión",
    "bitbybit.occt.shapes.wire.getWire": "obtener alambre",
    "getWire": "obtener alambre",
    "bitbybit.occt.shapes.wire.getWire_description": "obtiene el alambre por índice de la forma",
    "bitbybit.occt.shapes.wire.getWires": "obtener alambres",
    "getWires": "obtener alambres",
    "bitbybit.occt.shapes.wire.getWires_description": "obtiene todos los alambres de la forma",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "obtener centro de masa del alambre",
    "getWireCenterOfMass": "obtener centro de masa del alambre",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "obtiene el punto del centro de masa del alambre",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "obtener centros de masa de alambres",
    "getWiresCentersOfMass": "obtener centros de masa de alambres",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "obtiene los puntos de los centros de masa de los alambres",
    "bitbybit.occt.shapes.wire.reversedWire": "alambre invertido",
    "reversedWire": "alambre invertido",
    "bitbybit.occt.shapes.wire.reversedWire_description": "calcula el alambre invertido",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "alambre invertido desde aristas invertidas",
    "reversedWireFromReversedEdges": "alambre invertido desde aristas invertidas",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "calcula el alambre invertido a partir de aristas invertidas",
    "bitbybit.occt.shapes.wire.isWireClosed": "está alambre cerrado",
    "isWireClosed": "está alambre cerrado",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "comprueba si el alambre está cerrado",
    "bitbybit.occt.shapes.wire.getWireLength": "obtener longitud de alambre",
    "getWireLength": "obtener longitud de alambre",
    "bitbybit.occt.shapes.wire.getWireLength_description": "obtiene la longitud del alambre",
    "bitbybit.occt.shapes.wire.getWiresLengths": "obtener longitudes de alambres",
    "getWiresLengths": "obtener longitudes de alambres",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "obtiene las longitudes de los alambres",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "colocar alambre en cara",
    "placeWireOnFace": "colocar alambre en cara",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "coloca el alambre en la cara usando el espacio uv",
    "face": "cara",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "colocar alambres en cara",
    "placeWiresOnFace": "colocar alambres en cara",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "coloca múltiples alambres en la cara usando el espacio uv",
    "wires": "alambres",
    "bitbybit.occt.shapes.wire.closeOpenWire": "cerrar alambre abierto",
    "closeOpenWire": "cerrar alambre abierto",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "cierra un alambre abierto con una arista recta",
    "bitbybit.occt.shapes.wire.project": "proyectar",
    "project": "proyectar",
    "bitbybit.occt.shapes.wire.project_description": "proyecta el alambre sobre la forma",
    "bitbybit.occt.shapes.wire.projectWires": "proyectar alambres",
    "projectWires": "proyectar alambres",
    "bitbybit.occt.shapes.wire.projectWires_description": "proyecta múltiples alambres sobre la forma",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "caras desde alambres en cara",
    "createFacesFromWiresOnFace": "caras desde alambres en cara",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "crea caras a partir de alambres en una cara",
    "inside": "interior",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "cara desde alambre en cara",
    "createFaceFromWireOnFace": "cara desde alambre en cara",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "crea una cara a partir de un alambre en una cara",
    "bitbybit.occt.shapes.face.createFaceFromWire": "cara desde alambre",
    "createFaceFromWire": "cara desde alambre",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "crea una cara a partir de un alambre",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "cara desde alambres",
    "createFaceFromWires": "cara desde alambres",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "crea una cara a partir de alambres",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "cara desde alambres en cara",
    "createFaceFromWiresOnFace": "cara desde alambres en cara",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "crea una cara a partir de alambres en una cara guía",
    "bitbybit.occt.shapes.face.createFacesFromWires": "caras desde alambres",
    "createFacesFromWires": "caras desde alambres",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "crea caras a partir de alambres",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "cara desde múltiples alambres tangentes a círculos",
    "createFaceFromMultipleCircleTanWires": "cara desde múltiples alambres tangentes a círculos",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "crea una cara a partir de múltiples alambres tangentes a círculos",
    "circles": "círculos",
    "combination": "combinación",
    "combinationCirclesForFaceEnum": "enum combinación círculos para cara",
    "unify": "unificar",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "cara desde múltiples colecciones de alambres tangentes a círculos",
    "createFaceFromMultipleCircleTanWireCollections": "cara desde múltiples colecciones de alambres tangentes a círculos",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "crea una cara a partir de múltiples colecciones de alambres tangentes a círculos",
    "listsOfCircles": "listas de círculos",
    "T[][]": "array de array t",
    "bitbybit.occt.shapes.face.faceFromSurface": "cara desde superficie",
    "faceFromSurface": "cara desde superficie",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "crea una cara a partir de una superficie",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "cara desde superficie y alambre",
    "faceFromSurfaceAndWire": "cara desde superficie y alambre",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "crea una cara a partir de una superficie y un alambre",
    "bitbybit.occt.shapes.face.createPolygonFace": "cara poligonal",
    "createPolygonFace": "cara poligonal",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "crea una cara poligonal de opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "cara circular",
    "createCircleFace": "cara circular",
    "bitbybit.occt.shapes.face.createCircleFace_description": "crea una cara circular de opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "cara elíptica",
    "createEllipseFace": "cara elíptica",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "crea una cara elíptica de opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "cara cuadrada",
    "createSquareFace": "cara cuadrada",
    "bitbybit.occt.shapes.face.createSquareFace_description": "crea una cara cuadrada de opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "cara rectangular",
    "createRectangleFace": "cara rectangular",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "crea una cara rectangular de opencascade",
    "bitbybit.occt.shapes.face.getFace": "obtener cara",
    "getFace": "obtener cara",
    "bitbybit.occt.shapes.face.getFace_description": "obtiene la cara por índice de la forma",
    "bitbybit.occt.shapes.face.getFaces": "obtener caras",
    "getFaces": "obtener caras",
    "bitbybit.occt.shapes.face.getFaces_description": "obtiene las caras de la forma",
    "bitbybit.occt.shapes.face.reversedFace": "cara invertida",
    "reversedFace": "cara invertida",
    "bitbybit.occt.shapes.face.reversedFace_description": "calcula la cara invertida",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdividir en puntos",
    "subdivideToPoints": "subdividir en puntos",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "subdivide la cara en una cuadrícula de puntos",
    "nrDivisionsU": "núm divisiones u",
    "nrDivisionsV": "núm divisiones v",
    "shiftHalfStepU": "desplazar medio paso u",
    "removeStartEdgeU": "eliminar arista inicial u",
    "removeEndEdgeU": "eliminar arista final u",
    "shiftHalfStepV": "desplazar medio paso v",
    "removeStartEdgeV": "eliminar arista inicial v",
    "removeEndEdgeV": "eliminar arista final v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdividir en alambres",
    "subdivideToWires": "subdividir en alambres",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "subdivide la cara en alambres",
    "nrDivisions": "núm divisiones",
    "isU": "es u",
    "shiftHalfStep": "desplazar medio paso",
    "removeStart": "eliminar inicio",
    "removeEnd": "eliminar fin",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdividir en alambres rectangulares",
    "subdivideToRectangleWires": "subdividir en alambres rectangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "subdivide la cara en alambres rectangulares",
    "patterns": "patrones",
    "nrRectanglesU": "núm rectángulos u",
    "nrRectanglesV": "núm rectángulos v",
    "scalePatternU": "patrón de escala u",
    "scalePatternV": "patrón de escala v",
    "filletPattern": "patrón de redondeo",
    "inclusionPattern": "patrón de inclusión",
    "offsetFromBorderU": "desplazamiento desde borde u",
    "offsetFromBorderV": "desplazamiento desde borde v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdividir en agujeros rectangulares",
    "subdivideToRectangleHoles": "subdividir en agujeros rectangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "subdivide la cara en agujeros rectangulares",
    "holesToFaces": "agujeros a caras",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdividir en puntos controlados",
    "subdivideToPointsControlled": "subdividir en puntos controlados",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "subdivide la cara en una cuadrícula de puntos con desplazamientos controlados",
    "shiftHalfStepNthU": "desplazar medio paso enésimo u",
    "shiftHalfStepUOffsetN": "desplazar medio paso u desplazamiento n",
    "removeStartEdgeNthU": "eliminar arista inicial enésima u",
    "removeStartEdgeUOffsetN": "eliminar arista inicial u desplazamiento n",
    "removeEndEdgeNthU": "eliminar arista final enésima u",
    "removeEndEdgeUOffsetN": "eliminar arista final u desplazamiento n",
    "shiftHalfStepNthV": "desplazar medio paso enésimo v",
    "shiftHalfStepVOffsetN": "desplazar medio paso v desplazamiento n",
    "removeStartEdgeNthV": "eliminar arista inicial enésima v",
    "removeStartEdgeVOffsetN": "eliminar arista inicial v desplazamiento n",
    "removeEndEdgeNthV": "eliminar arista final enésima v",
    "removeEndEdgeVOffsetN": "eliminar arista final v desplazamiento n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdividir en normales",
    "subdivideToNormals": "subdividir en normales",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "subdivide la cara en una cuadrícula de normales",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdividir en uv",
    "subdivideToUV": "subdividir en uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "subdivide la cara en una cuadrícula uv",
    "bitbybit.occt.shapes.face.pointOnUV": "punto en uv",
    "pointOnUV": "punto en uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "obtiene un punto en uv mapeado a los límites",
    "paramU": "parámetro u",
    "paramV": "parámetro v",
    "bitbybit.occt.shapes.face.normalOnUV": "normal en uv",
    "normalOnUV": "normal en uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "obtiene la normal en uv mapeada a los límites",
    "bitbybit.occt.shapes.face.pointsOnUVs": "puntos en uvs",
    "pointsOnUVs": "puntos en uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "obtiene puntos en uvs mapeados a los límites",
    "paramsUV": "parámetros uv",
    "[number, number][]": "array de pares de números",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normales en uvs",
    "normalsOnUVs": "normales en uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "obtiene normales en uvs mapeadas a los límites",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdividir en puntos en parámetro",
    "subdivideToPointsOnParam": "subdividir en puntos en parámetro",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "subdivide la cara en puntos en el parámetro",
    "nrPoints": "núm puntos",
    "bitbybit.occt.shapes.face.wireAlongParam": "alambre a lo largo de parámetro",
    "wireAlongParam": "alambre a lo largo de parámetro",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "obtiene un alambre a lo largo del parámetro en la cara",
    "bitbybit.occt.shapes.face.wiresAlongParams": "alambres a lo largo de parámetros",
    "wiresAlongParams": "alambres a lo largo de parámetros",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "obtiene alambres a lo largo de los parámetros en la cara",
    "params": "parámetros",
    "bitbybit.occt.shapes.face.getUMinBound": "obtener límite mínimo u",
    "getUMinBound": "obtener límite mínimo u",
    "bitbybit.occt.shapes.face.getUMinBound_description": "obtiene el límite mínimo u de la cara",
    "bitbybit.occt.shapes.face.getUMaxBound": "obtener límite máximo u",
    "getUMaxBound": "obtener límite máximo u",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "obtiene el límite máximo u de la cara",
    "bitbybit.occt.shapes.face.getVMinBound": "obtener límite mínimo v",
    "getVMinBound": "obtener límite mínimo v",
    "bitbybit.occt.shapes.face.getVMinBound_description": "obtiene el límite mínimo v de la cara",
    "bitbybit.occt.shapes.face.getVMaxBound": "obtener límite máximo v",
    "getVMaxBound": "obtener límite máximo v",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "obtiene el límite máximo v de la cara",
    "bitbybit.occt.shapes.face.getFaceArea": "obtener área de cara",
    "getFaceArea": "obtener área de cara",
    "bitbybit.occt.shapes.face.getFaceArea_description": "obtiene el área de la cara",
    "bitbybit.occt.shapes.face.getFacesAreas": "obtener áreas de caras",
    "getFacesAreas": "obtener áreas de caras",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "obtiene las áreas de las caras",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "obtener centro de masa de cara",
    "getFaceCenterOfMass": "obtener centro de masa de cara",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "obtiene el punto del centro de masa de la cara",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "obtener centros de masa de caras",
    "getFacesCentersOfMass": "obtener centros de masa de caras",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "obtiene los centros de masa de las caras",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtrar puntos de cara",
    "filterFacePoints": "filtrar puntos de cara",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtra puntos en la cara",
    "filter": "filtrar",
    "useBndBox": "usar caja delimitadora",
    "gapTolerance": "tolerancia de hueco",
    "keepIn": "mantener dentro",
    "keepOn": "mantener sobre",
    "keepOut": "mantener fuera",
    "keepUnknown": "mantener desconocido",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtrar puntos de caras",
    "filterFacesPoints": "filtrar puntos de caras",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtra puntos en las caras",
    "flatPointsArray": "array de puntos plano",
    "bitbybit.occt.shapes.shell.sewFaces": "coser caras",
    "shell": "shell",
    "sewFaces": "coser caras",
    "bitbybit.occt.shapes.shell.sewFaces_description": "crea un shell a partir de caras",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "obtener área superficial del shell",
    "getShellSurfaceArea": "obtener área superficial del shell",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "obtiene el área superficial del shell",
    "bitbybit.occt.shapes.solid.fromClosedShell": "desde shell cerrado",
    "solid": "sólido",
    "fromClosedShell": "desde shell cerrado",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "crea un sólido a partir de un shell cerrado",
    "bitbybit.occt.shapes.solid.createBox": "caja",
    "bitbybit.occt.shapes.solid.createBox_description": "crea una caja de opencascade",
    "originOnCenter": "origen en el centro",
    "bitbybit.occt.shapes.solid.createCube": "cubo",
    "bitbybit.occt.shapes.solid.createCube_description": "crea un cubo de opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "caja desde esquina",
    "createBoxFromCorner": "caja desde esquina",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "crea una caja de opencascade desde una esquina",
    "corner": "esquina",
    "bitbybit.occt.shapes.solid.createCylinder": "cilindro",
    "bitbybit.occt.shapes.solid.createCylinder_description": "crea un cilindro de opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cilindros en líneas",
    "createCylindersOnLines": "cilindros en líneas",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "crea cilindros de opencascade en líneas",
    "Base.Line3[]": "array de línea base 3",
    "bitbybit.occt.shapes.solid.createSphere": "esfera",
    "bitbybit.occt.shapes.solid.createSphere_description": "crea una esfera de opencascade",
    "bitbybit.occt.shapes.solid.createCone": "cono",
    "createCone": "cono",
    "bitbybit.occt.shapes.solid.createCone_description": "crea un cono de opencascade",
    "radius1": "radio 1",
    "radius2": "radio 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "obtener área superficial del sólido",
    "getSolidSurfaceArea": "obtener área superficial del sólido",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "obtiene el área superficial del sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume": "obtener volumen del sólido",
    "getSolidVolume": "obtener volumen del sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "obtiene el volumen del sólido",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "obtener volúmenes de sólidos",
    "getSolidsVolumes": "obtener volúmenes de sólidos",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "obtiene los volúmenes de los sólidos",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "obtener centro de masa del sólido",
    "getSolidCenterOfMass": "obtener centro de masa del sólido",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "obtiene el centro de masa del sólido",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "obtener centros de masa de sólidos",
    "getSolidsCentersOfMass": "obtener centros de masa de sólidos",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "obtiene los centros de masa de los sólidos",
    "bitbybit.occt.shapes.solid.getSolids": "obtener sólidos",
    "getSolids": "obtener sólidos",
    "bitbybit.occt.shapes.solid.getSolids_description": "obtiene los sólidos de la forma",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtrar puntos de sólido",
    "filterSolidPoints": "filtrar puntos de sólido",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "filtra puntos según la relación con el sólido",
    "bitbybit.occt.shapes.compound.makeCompound": "hacer compuesto",
    "compound": "compuesto",
    "makeCompound": "hacer compuesto",
    "bitbybit.occt.shapes.compound.makeCompound_description": "hace una forma compuesta a partir de formas",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "obtener formas de compuesto",
    "getShapesOfCompound": "obtener formas de compuesto",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "obtiene las formas del compuesto",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "purgar aristas internas",
    "purgeInternalEdges": "purgar aristas internas",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "elimina las aristas internas de la forma",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unificar mismo dominio",
    "unifySameDomain": "unificar mismo dominio",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "unifica caras y aristas en el mismo dominio",
    "unifyEdges": "unificar aristas",
    "unifyFaces": "unificar caras",
    "concatBSplines": "concatenar bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "está cerrado",
    "bitbybit.occt.shapes.shape.isClosed_description": "comprueba si la forma está cerrada",
    "analysis": "análisis",
    "bitbybit.occt.shapes.shape.isConvex": "es convexo",
    "isConvex": "es convexo",
    "bitbybit.occt.shapes.shape.isConvex_description": "comprueba si la forma es convexa",
    "bitbybit.occt.shapes.shape.isChecked": "está comprobado",
    "bitbybit.occt.shapes.shape.isChecked_description": "comprueba si la forma está comprobada",
    "bitbybit.occt.shapes.shape.isFree": "es libre",
    "isFree": "es libre",
    "bitbybit.occt.shapes.shape.isFree_description": "comprueba si la forma es libre",
    "bitbybit.occt.shapes.shape.isInfinite": "es infinito",
    "isInfinite": "es infinito",
    "bitbybit.occt.shapes.shape.isInfinite_description": "comprueba si la forma es infinita",
    "bitbybit.occt.shapes.shape.isModified": "está modificado",
    "isModified": "está modificado",
    "bitbybit.occt.shapes.shape.isModified_description": "comprueba si la forma está modificada",
    "bitbybit.occt.shapes.shape.isLocked": "está bloqueado",
    "isLocked": "está bloqueado",
    "bitbybit.occt.shapes.shape.isLocked_description": "comprueba si la forma está bloqueada",
    "bitbybit.occt.shapes.shape.isNull": "es nulo",
    "isNull": "es nulo",
    "bitbybit.occt.shapes.shape.isNull_description": "comprueba si la forma es nula",
    "bitbybit.occt.shapes.shape.isEqual": "es igual",
    "isEqual": "es igual",
    "bitbybit.occt.shapes.shape.isEqual_description": "comprueba si la forma es igual a otra forma",
    "otherShape": "otra forma",
    "bitbybit.occt.shapes.shape.isNotEqual": "no es igual",
    "isNotEqual": "no es igual",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "comprueba si la forma difiere de otra forma",
    "bitbybit.occt.shapes.shape.isPartner": "es pareja",
    "isPartner": "es pareja",
    "bitbybit.occt.shapes.shape.isPartner_description": "comprueba si la forma es pareja de otra forma",
    "bitbybit.occt.shapes.shape.isSame": "es la misma",
    "isSame": "es la misma",
    "bitbybit.occt.shapes.shape.isSame_description": "comprueba si la forma es la misma que otra forma",
    "bitbybit.occt.shapes.shape.getOrientation": "obtener orientación",
    "getOrientation": "obtener orientación",
    "bitbybit.occt.shapes.shape.getOrientation_description": "obtiene la orientación de la forma",
    "bitbybit.occt.shapes.shape.getShapeType": "obtener tipo de forma",
    "getShapeType": "obtener tipo de forma",
    "bitbybit.occt.shapes.shape.getShapeType_description": "obtiene el tipo de forma",
    "bitbybit.occt.geom.curves.geom2dEllipse": "geometría elipse 2d",
    "geom": "geom",
    "curves": "curvas",
    "geom2dEllipse": "geometría elipse 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "crea una elipse 2d para modelado",
    "Base.Point2": "punto base 2",
    "Base.Vector2": "vector base 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "geometría curva recortada 2d",
    "geom2dTrimmedCurve": "geometría curva recortada 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "crea una curva recortada entre u1 y u2",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "ajustar periódico",
    "bitbybit.occt.geom.curves.geom2dSegment": "geometría segmento 2d",
    "geom2dSegment": "geometría segmento 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "crea un segmento de curva 2d entre dos puntos",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "obtener punto 2d de curva 2d en parámetro",
    "get2dPointFrom2dCurveOnParam": "obtener punto 2d de curva 2d en parámetro",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "obtiene un punto 2d en la curva en el parámetro",
    "bitbybit.occt.geom.curves.geomCircleCurve": "geometría curva circular",
    "geomCircleCurve": "geometría curva circular",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "crea una curva geométrica circular",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "geometría curva elíptica",
    "geomEllipseCurve": "geometría curva elíptica",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "crea una curva geométrica elíptica",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "superficie cilíndrica",
    "surfaces": "superficies",
    "cylindricalSurface": "superficie cilíndrica",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "crea una superficie cilíndrica infinita para modelado",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "superficie desde cara",
    "surfaceFromFace": "superficie desde cara",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "crea una superficie a partir de una cara",
    "bitbybit.occt.fillets.filletEdges": "redondear aristas",
    "fillets": "redondeos",
    "filletEdges": "redondear aristas",
    "bitbybit.occt.fillets.filletEdges_description": "redondea formas de opencascade",
    "3d fillets": "redondeos 3d",
    "radiusList": "lista de radios",
    "indexes": "índices",
    "bitbybit.occt.fillets.filletEdgesList": "lista de redondeo de aristas",
    "filletEdgesList": "lista de redondeo de aristas",
    "bitbybit.occt.fillets.filletEdgesList_description": "redondea aristas con diferentes radios",
    "edges": "aristas",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "lista de redondeo de aristas un radio",
    "filletEdgesListOneRadius": "lista de redondeo de aristas un radio",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "redondea aristas con un solo radio",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "redondear arista radio variable",
    "filletEdgeVariableRadius": "redondear arista radio variable",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "redondea la arista con radio variable en parámetros u",
    "paramsU": "parámetros u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "redondear aristas mismo radio variable",
    "filletEdgesSameVariableRadius": "redondear aristas mismo radio variable",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "redondea aristas con los mismos radios variables",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "redondear aristas radio variable",
    "filletEdgesVariableRadius": "redondear aristas radio variable",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "redondea aristas con radios variables en parámetros",
    "radiusLists": "listas de radios",
    "paramsULists": "listas de parámetros u",
    "bitbybit.occt.fillets.fillet3DWire": "redondear alambre 3d",
    "fillet3DWire": "redondear alambre 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "redondea un alambre 3d con dirección guía",
    "bitbybit.occt.fillets.fillet3DWires": "redondear alambres 3d",
    "fillet3DWires": "redondear alambres 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "redondea alambres 3d con dirección guía",
    "bitbybit.occt.fillets.chamferEdges": "achaflanar aristas",
    "chamferEdges": "achaflanar aristas",
    "bitbybit.occt.fillets.chamferEdges_description": "achaflana las aristas de la forma de opencascade",
    "3d chamfers": "achaflanados 3d",
    "distanceList": "lista de distancias",
    "bitbybit.occt.fillets.chamferEdgesList": "lista de achaflanado de aristas",
    "chamferEdgesList": "lista de achaflanado de aristas",
    "bitbybit.occt.fillets.chamferEdgesList_description": "achaflana aristas con diferentes distancias",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "achaflanar arista dos distancias",
    "chamferEdgeTwoDistances": "achaflanar arista dos distancias",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "achaflana la arista con dos distancias",
    "F": "f",
    "distance1": "distancia 1",
    "distance2": "distancia 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "achaflanar aristas dos distancias",
    "chamferEdgesTwoDistances": "achaflanar aristas dos distancias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "achaflana aristas con dos distancias",
    "faces": "caras",
    "F[]": "array f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "achaflanar aristas listas dos distancias",
    "chamferEdgesTwoDistancesLists": "achaflanar aristas listas dos distancias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "achaflana aristas con dos listas de distancias",
    "distances1": "distancias 1",
    "distances2": "distancias 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "achaflanar arista dist ángulo",
    "chamferEdgeDistAngle": "achaflanar arista dist ángulo",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "achaflana la arista con distancia y ángulo",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "achaflanar aristas dist ángulo",
    "chamferEdgesDistAngle": "achaflanar aristas dist ángulo",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "achaflana aristas con distancia y ángulo",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "achaflanar aristas dists ángulos",
    "chamferEdgesDistsAngles": "achaflanar aristas dists ángulos",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "achaflana aristas con distancias y ángulos",
    "distances": "distancias",
    "bitbybit.occt.fillets.fillet2d": "redondeo 2d",
    "fillet2d": "redondeo 2d",
    "bitbybit.occt.fillets.fillet2d_description": "redondea alambre o cara 2d",
    "2d fillets": "redondeos 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "redondear formas 2d",
    "fillet2dShapes": "redondear formas 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "redondea alambres o caras 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "redondear dos aristas en plano en un alambre",
    "filletTwoEdgesInPlaneIntoAWire": "redondear dos aristas en plano en un alambre",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "redondea dos aristas planares en un alambre",
    "edge1": "arista 1",
    "edge2": "arista 2",
    "planeOrigin": "origen del plano",
    "planeDirection": "dirección del plano",
    "solution": "solución",
    "bitbybit.occt.transforms.transform": "transformar",
    "bitbybit.occt.transforms.transform_description": "transforma la forma",
    "on single shape": "en forma única",
    "rotationAxis": "eje de rotación",
    "rotationAngle": "ángulo de rotación",
    "scaleFactor": "factor de escala",
    "bitbybit.occt.transforms.rotate": "rotar",
    "bitbybit.occt.transforms.rotate_description": "rota la forma",
    "bitbybit.occt.transforms.rotateAroundCenter": "rotar alrededor del centro",
    "rotateAroundCenter": "rotar alrededor del centro",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "rota la forma alrededor del centro",
    "bitbybit.occt.transforms.align": "alinear",
    "bitbybit.occt.transforms.align_description": "alinea la forma",
    "fromOrigin": "desde origen",
    "fromDirection": "desde dirección",
    "toOrigin": "a origen",
    "toDirection": "a dirección",
    "bitbybit.occt.transforms.alignAndTranslate": "alinear y trasladar",
    "alignAndTranslate": "alinear y trasladar",
    "bitbybit.occt.transforms.alignAndTranslate_description": "alinea y traslada la forma",
    "bitbybit.occt.transforms.translate": "trasladar",
    "bitbybit.occt.transforms.translate_description": "traslada la forma",
    "bitbybit.occt.transforms.scale": "escalar",
    "bitbybit.occt.transforms.scale_description": "escala la forma",
    "bitbybit.occt.transforms.scale3d": "escalar 3d",
    "scale3d": "escalar 3d",
    "bitbybit.occt.transforms.scale3d_description": "escala la forma en 3d",
    "bitbybit.occt.transforms.mirror": "reflejar",
    "mirror": "reflejar",
    "bitbybit.occt.transforms.mirror_description": "refleja la forma",
    "bitbybit.occt.transforms.mirrorAlongNormal": "reflejar a lo largo de normal",
    "mirrorAlongNormal": "reflejar a lo largo de normal",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "refleja la forma a lo largo de la normal y el origen",
    "normal": "normal",
    "bitbybit.occt.transforms.transformShapes": "transformar formas",
    "transformShapes": "transformar formas",
    "bitbybit.occt.transforms.transformShapes_description": "transforma un array de formas",
    "on shapes": "en formas",
    "rotationAxes": "ejes de rotación",
    "rotationAngles": "ángulos de rotación",
    "scaleFactors": "factores de escala",
    "bitbybit.occt.transforms.rotateShapes": "rotar formas",
    "rotateShapes": "rotar formas",
    "bitbybit.occt.transforms.rotateShapes_description": "rota las formas",
    "axes": "ejes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "rotar alrededor del centro formas",
    "rotateAroundCenterShapes": "rotar alrededor del centro formas",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "rota las formas alrededor del centro y el eje",
    "centers": "centros",
    "bitbybit.occt.transforms.alignShapes": "alinear formas",
    "alignShapes": "alinear formas",
    "bitbybit.occt.transforms.alignShapes_description": "alinea las formas",
    "fromOrigins": "desde orígenes",
    "fromDirections": "desde direcciones",
    "toOrigins": "a orígenes",
    "toDirections": "a direcciones",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "alinear y trasladar formas",
    "alignAndTranslateShapes": "alinear y trasladar formas",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "alinea y traslada las formas",
    "directions": "direcciones",
    "bitbybit.occt.transforms.translateShapes": "trasladar formas",
    "translateShapes": "trasladar formas",
    "bitbybit.occt.transforms.translateShapes_description": "traslada las formas",
    "bitbybit.occt.transforms.scaleShapes": "escalar formas",
    "scaleShapes": "escalar formas",
    "bitbybit.occt.transforms.scaleShapes_description": "escala las formas",
    "factors": "factores",
    "bitbybit.occt.transforms.scale3dShapes": "escalar formas 3d",
    "scale3dShapes": "escalar formas 3d",
    "bitbybit.occt.transforms.scale3dShapes_description": "escala las formas en 3d",
    "scales": "escalas",
    "bitbybit.occt.transforms.mirrorShapes": "reflejar formas",
    "mirrorShapes": "reflejar formas",
    "bitbybit.occt.transforms.mirrorShapes_description": "refleja las formas",
    "origins": "orígenes",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "reflejar a lo largo de normal formas",
    "mirrorAlongNormalShapes": "reflejar a lo largo de normal formas",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "refleja las formas a lo largo de la normal y el origen",
    "normals": "normales",
    "bitbybit.occt.operations.loft": "loft",
    "operations": "operaciones",
    "loft": "loft",
    "bitbybit.occt.operations.loft_description": "crea un loft de alambres en un shell",
    "lofts": "lofts",
    "makeSolid": "hacer sólido",
    "bitbybit.occt.operations.loftAdvanced": "loft avanzado",
    "loftAdvanced": "loft avanzado",
    "bitbybit.occt.operations.loftAdvanced_description": "crea un loft de alambres en un shell con opciones",
    "straight": "recto",
    "nrPeriodicSections": "núm secciones periódicas",
    "useSmoothing": "usar suavizado",
    "maxUDegree": "grado u máximo",
    "parType": "tipo par",
    "approxParametrizationTypeEnum": "enum tipo parametrización aprox",
    "startVertex": "vértice inicial",
    "endVertex": "vértice final",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "puntos más cercanos entre dos formas",
    "closestPointsBetweenTwoShapes": "puntos más cercanos entre dos formas",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "calcula los puntos más cercanos entre dos formas",
    "closest pts": "puntos más cercanos",
    "shape1": "forma 1",
    "shape2": "forma 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "puntos más cercanos en forma desde puntos",
    "closestPointsOnShapeFromPoints": "puntos más cercanos en forma desde puntos",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "calcula los puntos más cercanos desde puntos a la forma",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "puntos más cercanos en formas desde puntos",
    "closestPointsOnShapesFromPoints": "puntos más cercanos en formas desde puntos",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "calcula los puntos más cercanos desde puntos a las formas",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distancias a forma desde puntos",
    "distancesToShapeFromPoints": "distancias a forma desde puntos",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "calcula las distancias desde puntos a la forma",
    "bitbybit.occt.operations.boundingBoxOfShape": "caja delimitadora de la forma",
    "boundingBoxOfShape": "caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Calcula los parámetros de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "mínimo de la caja delimitadora de la forma",
    "boundingBoxMinOfShape": "mínimo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Obtiene el punto mínimo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "máximo de la caja delimitadora de la forma",
    "boundingBoxMaxOfShape": "máximo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Obtiene el punto máximo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "centro de la caja delimitadora de la forma",
    "boundingBoxCenterOfShape": "centro de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Obtiene el punto central de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "tamaño de la caja delimitadora de la forma",
    "boundingBoxSizeOfShape": "tamaño de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Obtiene el punto de tamaño de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "forma de la caja delimitadora de la forma",
    "boundingBoxShapeOfShape": "forma de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Obtiene la forma de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereOfShape": "esfera delimitadora de la forma",
    "boundingSphereOfShape": "esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Calcula los parámetros de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "centro de la esfera delimitadora de la forma",
    "boundingSphereCenterOfShape": "centro de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Obtiene el punto central de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "radio de la esfera delimitadora de la forma",
    "boundingSphereRadiusOfShape": "radio de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Obtiene el radio de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "forma de la esfera delimitadora de la forma",
    "boundingSphereShapeOfShape": "forma de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Obtiene la forma de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.extrude": "extruir",
    "extrude": "extruir",
    "bitbybit.occt.operations.extrude_description": "extruye la forma a lo largo de la dirección",
    "extrusions": "extrusiones",
    "bitbybit.occt.operations.extrudeShapes": "extruir formas",
    "extrudeShapes": "extruir formas",
    "bitbybit.occt.operations.extrudeShapes_description": "extruye las formas a lo largo de la dirección",
    "bitbybit.occt.operations.splitShapeWithShapes": "dividir forma con formas",
    "splitShapeWithShapes": "dividir forma con formas",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "divide la forma con formas",
    "divisions": "divisiones",
    "localFuzzyTolerance": "tolerancia difusa local",
    "nonDestructive": "no destructivo",
    "bitbybit.occt.operations.revolve": "revolucionar",
    "revolve": "revolucionar",
    "bitbybit.occt.operations.revolve_description": "revoluciona la forma alrededor de la dirección",
    "revolutions": "revoluciones",
    "copy": "copiar",
    "bitbybit.occt.operations.rotatedExtrude": "extrusión rotada",
    "rotatedExtrude": "extrusión rotada",
    "bitbybit.occt.operations.rotatedExtrude_description": "realiza una extrusión rotada en la forma",
    "bitbybit.occt.operations.pipe": "tubo",
    "pipe": "tubo",
    "bitbybit.occt.operations.pipe_description": "crea tubos de formas a lo largo de un alambre",
    "pipeing": "entubado",
    "bitbybit.occt.operations.pipePolylineWireNGon": "tubo alambre polilínea n-gono",
    "pipePolylineWireNGon": "tubo alambre polilínea n-gono",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "crea un tubo de alambre de polilínea con perfil de n-gono",
    "trihedronEnum": "enum triedro",
    "geomFillTrihedronEnum": "enum triedro relleno geom",
    "forceApproxC1": "forzar aprox c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "tubo alambres cilíndrico",
    "pipeWiresCylindrical": "tubo alambres cilíndrico",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "crea tubos de alambres con forma cilíndrica",
    "bitbybit.occt.operations.pipeWireCylindrical": "tubo alambre cilíndrico",
    "pipeWireCylindrical": "tubo alambre cilíndrico",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "crea un tubo de alambre con forma cilíndrica",
    "bitbybit.occt.operations.offset": "desplazamiento",
    "bitbybit.occt.operations.offset_description": "desplaza formas",
    "offsets": "desplazamientos",
    "bitbybit.occt.operations.offsetAdv": "desplazamiento avanzado",
    "offsetAdv": "desplazamiento avanzado",
    "bitbybit.occt.operations.offsetAdv_description": "desplaza con opciones avanzadas",
    "joinType": "tipo de unión",
    "joinTypeEnum": "enum tipo unión",
    "removeIntEdges": "eliminar aristas int",
    "bitbybit.occt.operations.makeThickSolidSimple": "hacer sólido grueso simple",
    "makeThickSolidSimple": "hacer sólido grueso simple",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "engrosa la forma en un sólido",
    "bitbybit.occt.operations.makeThickSolidByJoin": "hacer sólido grueso por unión",
    "makeThickSolidByJoin": "hacer sólido grueso por unión",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "engrosa la forma en un sólido uniéndola",
    "intersection": "intersección",
    "selfIntersection": "autointersección",
    "bitbybit.occt.operations.slice": "rebanar",
    "slice": "rebanar",
    "bitbybit.occt.operations.slice_description": "rebana la forma",
    "bitbybit.occt.operations.sliceInStepPattern": "rebanar en patrón de pasos",
    "sliceInStepPattern": "rebanar en patrón de pasos",
    "bitbybit.occt.operations.sliceInStepPattern_description": "rebana la forma en un patrón de pasos",
    "steps": "pasos",
    "bitbybit.occt.operations.offset3DWire": "desplazamiento alambre 3d",
    "offset3DWire": "desplazamiento alambre 3d",
    "bitbybit.occt.operations.offset3DWire_description": "desplaza el alambre 3d",
    "bitbybit.occt.booleans.union": "unión",
    "booleans": "booleanos",
    "union": "unión",
    "bitbybit.occt.booleans.union_description": "une objetos",
    "keepEdges": "mantener aristas",
    "bitbybit.occt.booleans.difference": "diferencia",
    "difference": "diferencia",
    "bitbybit.occt.booleans.difference_description": "realiza diferencia booleana",
    "bitbybit.occt.booleans.intersection": "intersección",
    "bitbybit.occt.booleans.intersection_description": "realiza intersección booleana",
    "bitbybit.occt.shapeFix.basicShapeRepair": "reparación básica de forma",
    "shapeFix": "reparación de forma",
    "basicShapeRepair": "reparación básica de forma",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "repara la forma",
    "maxTolerance": "tolerancia máxima",
    "minTolerance": "tolerancia mínima",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "corregir arista pequeña en alambre",
    "fixSmallEdgeOnWire": "corregir arista pequeña en alambre",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "corrige una arista pequeña en el alambre",
    "lockvtx": "bloquear vtx",
    "precsmall": "prec pequeña",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "corregir orientaciones de arista a lo largo del alambre",
    "fixEdgeOrientationsAlongWire": "corregir orientaciones de arista a lo largo del alambre",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "corrige las orientaciones de las aristas a lo largo del alambre",
    "bitbybit.occt.io.saveShapeSTEP": "guardar forma step",
    "saveShapeSTEP": "guardar forma step",
    "bitbybit.occt.io.saveShapeSTEP_description": "guarda archivo step",
    "adjustYtoZ": "ajustar y a z",
    "tryDownload": "intentar descargar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "guardar forma step y retornar",
    "saveShapeSTEPAndReturn": "guardar forma step y retornar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "guarda archivo step y retorna texto",
    "bitbybit.occt.io.saveShapeStl": "guardar forma stl",
    "saveShapeStl": "guardar forma stl",
    "bitbybit.occt.io.saveShapeStl_description": "guarda archivo stl",
    "binary": "binario",
    "bitbybit.occt.io.saveShapeStlAndReturn": "guardar forma stl y retornar",
    "saveShapeStlAndReturn": "guardar forma stl y retornar",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "guarda archivo stl y retorna",
    "bitbybit.occt.io.loadSTEPorIGES": "cargar step o iges",
    "loadSTEPorIGES": "cargar step o iges",
    "bitbybit.occt.io.loadSTEPorIGES_description": "importa archivo step o iges",
    "adjustZtoY": "ajustar z a y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "cargar step o iges desde texto",
    "loadSTEPorIGESFromText": "cargar step o iges desde texto",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "importa step o iges desde texto",
    "fileType": "tipo de archivo",
    "fileTypeEnum": "enum tipo archivo",
    "bitbybit.advanced.text3d.create": "texto 3d",
    "advanced": "avanzado",
    "text3d": "texto 3d",
    "bitbybit.advanced.text3d.create_description": "crea texto 3d",
    "fontType": "tipo de fuente",
    "fontsEnum": "enum fuentes",
    "fontVariant": "variante de fuente",
    "fontVariantsEnum": "enum variantes fuente",
    "Inputs.Base.Vector3": "entradas vector base 3",
    "originAlignment": "alineación origen",
    "recAlignmentEnum": "enum alineación rec",
    "bitbybit.advanced.text3d.createTextOnFace": "texto en cara",
    "createTextOnFace": "texto en cara",
    "bitbybit.advanced.text3d.createTextOnFace_description": "crea texto 3d en una cara",
    "facePlanar": "cara planar",
    "faceTextVar": "var texto cara",
    "faceTextVarEnum": "enum var texto cara",
    "originParamU": "origen parámetro u",
    "originParamV": "origen parámetro v",
    "bitbybit.advanced.text3d.createTextsOnFace": "textos en cara",
    "createTextsOnFace": "textos en cara",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "crea textos 3d en una cara",
    "definitions": "definiciones",
    "Text3DFaceDefinitionDto[]": "array dto definición cara texto 3d",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "definición texto 3d en cara",
    "definition3dTextOnFace": "definición texto 3d en cara",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "crea texto 3d para definición de cara",
    "bitbybit.advanced.text3d.getCompoundShape": "obtener forma compuesta",
    "getCompoundShape": "obtener forma compuesta",
    "bitbybit.advanced.text3d.getCompoundShape_description": "obtiene la forma compuesta del texto 3d",
    "model": "modelo",
    "Text3DData<T>": "datos texto 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "obtener forma de carácter",
    "getCharacterShape": "obtener forma de carácter",
    "bitbybit.advanced.text3d.getCharacterShape_description": "obtiene la forma del carácter en el índice",
    "bitbybit.advanced.text3d.getCharacterShapes": "obtener formas de caracteres",
    "getCharacterShapes": "obtener formas de caracteres",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "obtiene las formas de los caracteres del texto 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "obtener coordenadas centrales de carácter",
    "getCharacterCenterCoordinates": "obtener coordenadas centrales de carácter",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "obtiene las coordenadas centrales de los caracteres",
    "bitbybit.advanced.text3d.getFaceCutout": "obtener recorte de cara",
    "getFaceCutout": "obtener recorte de cara",
    "bitbybit.advanced.text3d.getFaceCutout_description": "obtiene el recorte de cara del texto 3d en la cara",
    "get from face": "obtener de cara",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "obtener todas las caras del recorte",
    "getAllFacesOfCutout": "obtener todas las caras del recorte",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "obtiene todos los recortes de cara del texto 3d",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "obtener recortes dentro de caracteres",
    "getCutoutsInsideCharacters": "obtener recortes dentro de caracteres",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "obtiene los recortes de cara de los caracteres del texto 3d",
    "bitbybit.advanced.text3d.getAdvanceWidth": "obtener ancho de avance",
    "getAdvanceWidth": "obtener ancho de avance",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "obtiene el ancho de avance",
    "dimensions": "dimensiones",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pirámide simple",
    "facePatterns": "patrones de cara",
    "pyramidSimple": "pirámide simple",
    "createPyramidSimple": "pirámide simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "crea un patrón de pirámide simple en las caras",
    "uNumber": "número u",
    "vNumber": "número v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "afectores de pirámide simple",
    "createPyramidSimpleAffectors": "afectores de pirámide simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "crea un patrón de pirámide con afectores",
    "affectorPoints": "puntos afectores",
    "Inputs.Base.Point3[]": "array de punto base 3 de entradas",
    "affectorRadiusList": "lista de radios afectores",
    "affectorFactors": "factores afectores",
    "defaultHeight": "altura predeterminada",
    "affectMinHeight": "altura mínima afectada",
    "affectMaxHeight": "altura máxima afectada",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "obtener forma compuesta",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "obtiene la forma compuesta de las pirámides",
    "get shapes": "obtener formas",
    "PyramidSimpleData<T>": "datos pirámide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "obtener forma compuesta en cara",
    "getCompoundShapeOnFace": "obtener forma compuesta en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "obtiene la forma compuesta en la cara",
    "faceIndex": "índice de cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "obtener celda de forma compuesta en cara",
    "getCompoundShapeCellOnFace": "obtener celda de forma compuesta en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "obtiene la forma de la pirámide en la cara en el índice",
    "uIndex": "índice u",
    "vIndex": "índice v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "obtener todas las celdas de pirámide",
    "getAllPyramidCells": "obtener todas las celdas de pirámide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "obtiene todas las celdas de pirámide",
    "get cells": "obtener celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "obtener todas las celdas de pirámide en cara",
    "getAllPyramidCellsOnFace": "obtener todas las celdas de pirámide en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "obtiene las celdas de pirámide en la cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "obtener todas las celdas u de pirámide en cara",
    "getAllPyramidUCellsOnFace": "obtener todas las celdas u de pirámide en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "obtiene las celdas u de pirámide en la cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "obtener todas las celdas u de pirámide en cara en u",
    "getAllPyramidUCellsOnFaceAtU": "obtener todas las celdas u de pirámide en cara en u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "obtiene las celdas de pirámide en la cara en u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "obtener todas las celdas u de pirámide en cara en v",
    "getAllPyramidUCellsOnFaceAtV": "obtener todas las celdas u de pirámide en cara en v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "obtiene las celdas de pirámide en la cara en v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "obtener celda en índice",
    "getCellOnIndex": "obtener celda en índice",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "obtiene la celda de pirámide en la cara en u y v",
    "get cell": "obtener celda",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obtener puntos superiores de celdas",
    "getTopPointsOfCells": "obtener puntos superiores de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "obtiene los puntos superiores de las celdas",
    "get from cells": "obtener de celdas",
    "cells": "celdas",
    "PyramidSimpleCellPart<T>[]": "array de parte de celda pirámide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "obtener puntos centrales de celdas",
    "getCenterPointsOfCells": "obtener puntos centrales de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "obtiene los puntos centrales de las celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "obtener puntos de esquina de celdas",
    "getCornerPointsOfCells": "obtener puntos de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "obtiene los puntos de esquina de las celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "obtener punto de esquina de celdas",
    "getCornerPointOfCells": "obtener punto de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "obtiene el punto de esquina de las celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "obtener normal de esquina de celdas",
    "getCornerNormalOfCells": "obtener normal de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "obtiene la normal de esquina de las celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "obtener normales de esquina de celdas",
    "getCornerNormalsOfCells": "obtener normales de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "obtiene las normales de esquina de las celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "obtener formas compuestas de celdas",
    "getCompoundShapesOfCells": "obtener formas compuestas de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "obtiene las formas compuestas de las celdas de pirámide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "obtener formas de cara de celdas",
    "getFaceShapesOfCells": "obtener formas de cara de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "obtiene las formas de cara de las celdas de pirámide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "obtener formas de alambre de celdas",
    "getWireShapesOfCells": "obtener formas de alambre de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "obtiene las formas de alambre de las celdas de pirámide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "obtener alambre de polilínea inicial u",
    "getStartPolylineWireU": "obtener alambre de polilínea inicial u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "obtiene el alambre de polilínea a lo largo de la arista inicial u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "obtener alambre de polilínea final u",
    "getEndPolylineWireU": "obtener alambre de polilínea final u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "obtiene el alambre de polilínea a lo largo de la arista final u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "obtener alambre de polilínea inicial v",
    "getStartPolylineWireV": "obtener alambre de polilínea inicial v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "obtiene el alambre de polilínea a lo largo de la arista inicial v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "obtener alambre de polilínea final v",
    "getEndPolylineWireV": "obtener alambre de polilínea final v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "obtiene el alambre de polilínea a lo largo de la arista final v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "obtener compuesto de alambres de polilínea u",
    "getPolylineWiresUCompound": "obtener compuesto de alambres de polilínea u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "obtiene los alambres de polilínea a lo largo de u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "obtener compuesto de alambres de polilínea v",
    "getPolylineWiresVCompound": "obtener compuesto de alambres de polilínea v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "obtiene los alambres de polilínea a lo largo de v",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "villa ala delta",
    "things": "cosas",
    "kidsCorner": "rincón infantil",
    "birdhouses": "casas para pájaros",
    "wingtipVilla": "villa ala delta",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "crea la casa para pájaros villa ala delta",
    "birdhouse": "casa para pájaros",
    "interiorWidth": "ancho interior",
    "interiorLength": "longitud interior",
    "interiorHeight": "altura interior",
    "holeDiameter": "diámetro agujero",
    "holeDistToBottom": "distancia agujero a base",
    "stickLength": "longitud palo",
    "stickDiameter": "diámetro palo",
    "baseAttachmentHeight": "altura fijación base",
    "roofOverhang": "voladizo techo",
    "chimneyHeight": "altura chimenea",
    "Inputs.Base.Point3": "entradas punto base 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chalet chirriante",
    "chirpyChalet": "chalet chirriante",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "crea la casa para pájaros chalet chirriante",
    "roofAngle": "ángulo techo",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "remolino serenidad",
    "threeDPrinting": "impresión 3d",
    "vases": "jarrones",
    "serenitySwirl": "remolino serenidad",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "crea el jarrón remolino serenidad",
    "swirl": "remolino",
    "addRadiusNarrow": "añadir radio estrecho",
    "addRadiusWide": "añadir radio ancho",
    "addMiddleHeight": "añadir altura media",
    "addTopHeight": "añadir altura superior",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arco árabe",
    "arabicArchway": "arco árabe",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "crea el jarrón arco árabe",
    "profilePoints": "puntos de perfil",
    "nrOfSides": "núm lados",
    "nrOfVerticalArches": "núm arcos verticales",
    "archCenterThickness": "grosor centro arco",
    "edgesThickness": "grosor aristas",
    "baseHeight": "altura base",
    "patchHoles": "parchear agujeros",
    "lod": "nivel detalle",
    "Things.Enums.lodEnum": "enum nivel detalle cosas",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "amor eterno",
    "medals": "medallas",
    "eternalLove": "amor eterno",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "crea la medalla amor eterno",
    "textHeading": "texto encabezado",
    "textName": "texto nombre",
    "fullModel": "modelo completo",
    "decorationThickness": "grosor decoración",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "taza calma",
    "cups": "tazas",
    "calmCup": "taza calma",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "crea el modelo de taza calma",
    "radiusTopOffset": "desplazamiento radio superior",
    "fillet": "redondeo",
    "nrOfHandles": "núm asas",
    "handleDist": "distancia asa",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "taza dragón",
    "dragonCup": "taza dragón",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "crea el modelo de taza dragón",
    "radiusMidOffset": "desplazamiento radio medio",
    "rotationTopAngle": "ángulo rotación superior",
    "rotationMidAngle": "ángulo rotación medio",
    "nrSkinCellsVertical": "núm celdas piel vertical",
    "nrSkinCellsHorizontal": "núm celdas piel horizontal",
    "nrSkinCellDivisionsTop": "núm divisiones celda piel superior",
    "nrSkinCellDivisionsBottom": "núm divisiones celda piel inferior",
    "skinCellOuterHeight": "altura exterior celda piel",
    "skinCellInnerHeight": "altura interior celda piel",
    "skinCellBottomHeight": "altura inferior celda piel",
    "skinCellTopHeight": "altura superior celda piel",
    "bottomThickness": "grosor base",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "obtiene la forma compuesta de la taza dragón",
    "DragonCupData<T>": "datos taza dragón t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "nido teléfono",
    "desktop": "escritorio",
    "phoneNest": "nido teléfono",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "crea el modelo nido teléfono",
    "heightBottom": "altura inferior",
    "heightTop": "altura superior",
    "widthBack": "ancho trasero",
    "widthFront": "ancho frontal",
    "backOffset": "desplazamiento trasero",
    "applyOrnaments": "aplicar ornamentos",
    "filletRadius": "radio redondeo",
    "phoneHeight": "altura teléfono",
    "phoneWidth": "ancho teléfono",
    "phoneThickness": "grosor teléfono",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "obtiene la forma compuesta del nido teléfono",
    "PhoneNestData<T>": "datos nido teléfono t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "opciones dibujo",
    "drawOptions": "opciones dibujo",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "crea opciones de dibujo para el modelo",
    "mainMaterial": "material principal",
    "phoneMaterial": "material teléfono",
    "Inputs.Base.Color": "entradas color base",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "soporte teléfono gotas",
    "laserCutting": "corte láser",
    "gadgets": "gadgets",
    "dropletsPhoneHolder": "soporte teléfono gotas",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "crea el soporte para teléfono gotas",
    "title": "título",
    "subtitle": "subtítulo",
    "includeLogo": "incluir logo",
    "kerf": "corte",
    "backLength": "longitud trasera",
    "offsetAroundPhone": "desplazamiento alrededor teléfono",
    "penShelf": "estante bolígrafo",
    "phoneLockHeight": "altura bloqueo teléfono",
    "includePattern": "incluir patrón",
    "densityPattern": "densidad patrón",
    "holesForWire": "agujeros para cable",
    "wireInputThickness": "grosor entrada cable",
    "includeModel": "incluir modelo",
    "includeDrawings": "incluir dibujos",
    "spacingDrawings": "espaciado dibujos",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "obtiene la forma compuesta del soporte teléfono gotas",
    "DropletsPhoneHolderData<T>": "datos soporte teléfono gotas t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "obtener compuesto alambres corte",
    "getCutWiresCompound": "obtener compuesto alambres corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "obtiene el compuesto de alambres de corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "obtener compuesto alambres grabado",
    "getEngravingWiresCompound": "obtener compuesto alambres grabado",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "obtiene el compuesto de alambres de grabado",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "descargar dibujos dxf",
    "downloadDXFDrawings": "descargar dibujos dxf",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "descarga el dibujo dxf",
    "download": "descargar",
    "cutWiresColor": "color alambres corte",
    "engravingWiresColor": "color alambres grabado",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "descargar dibujos step",
    "downloadSTEPDrawings": "descargar dibujos step",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "descarga el dibujo step",
    "adjustYZ": "ajustar yz",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "descargar modelo step 3d",
    "download3dSTEPModel": "descargar modelo step 3d",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "descarga el modelo 3d step",
    "bitbybit.things.architecture.houses.zenHideout.create": "refugio zen",
    "architecture": "arquitectura",
    "houses": "casas",
    "zenHideout": "refugio zen",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "crea el refugio zen",
    "widthFirstWing": "ancho primera ala",
    "lengthFirstWing": "longitud primera ala",
    "terraceWidth": "ancho terraza",
    "widthSecondWing": "ancho segunda ala",
    "lengthSecondWing": "longitud segunda ala",
    "heightWalls": "altura muros",
    "roofAngleFirstWing": "ángulo techo primera ala",
    "roofAngleSecondWing": "ángulo techo segunda ala",
    "roofOffset": "desplazamiento techo",
    "roofInsideOverhang": "voladizo interior techo",
    "roofMaxDistAttachmentBeams": "dist máx vigas fijación techo",
    "roofAttachmentBeamWidth": "ancho viga fijación techo",
    "roofAttachmentBeamHeight": "altura viga fijación techo",
    "roofOutsideOverhang": "voladizo exterior techo",
    "columnSize": "tamaño columna",
    "ceilingBeamHeight": "altura viga techo",
    "ceilingBeamWidth": "ancho viga techo",
    "nrCeilingBeamsBetweenColumns": "núm vigas techo entre columnas",
    "distBetweenColumns": "dist entre columnas",
    "floorHeight": "altura suelo",
    "groundLevel": "nivel suelo",
    "facadePanelThickness": "grosor panel fachada",
    "windowWidthOffset": "desplazamiento ancho ventana",
    "windowHeightOffset": "desplazamiento altura ventana",
    "windowFrameThickness": "grosor marco ventana",
    "windowGlassFrameThickness": "grosor marco vidrio ventana",
    "skinOpacity": "opacidad piel",
    "bitbybit.things.furniture.chairs.snakeChair.create": "silla serpiente",
    "furniture": "mobiliario",
    "chairs": "sillas",
    "snakeChair": "silla serpiente",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "crea el modelo de silla serpiente",
    "sittingHeight": "altura asiento",
    "backRestOffset": "desplazamiento respaldo",
    "backRestHeight": "altura respaldo",
    "nrOrnamentPlanks": "núm tablones ornamento",
    "ornamentDepth": "profundidad ornamento",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "obtiene la forma compuesta de la silla",
    "SnakeChairData<T>": "datos silla serpiente t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "obtener forma alambre asiento",
    "getSittingWireShape": "obtener forma alambre asiento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "obtiene la forma de alambre del área de asiento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "obtener punto central área asiento",
    "getSittingAreaCenterPoint": "obtener punto central área asiento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "obtiene el punto central del área de asiento",
    "get points": "obtener puntos",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "crea opciones de dibujo para la silla serpiente",
    "bitbybit.things.furniture.tables.elegantTable.create": "mesa elegante",
    "tables": "mesas",
    "elegantTable": "mesa elegante",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "crea el modelo de mesa elegante",
    "topThickness": "grosor tablero",
    "topOffset": "desplazamiento tablero",
    "minFillet": "redondeo mín",
    "radiusLegTop": "radio pata superior",
    "radiusLegBottom": "radio pata inferior",
    "nrLegPairs": "núm pares patas",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "obtiene la forma compuesta de la mesa",
    "ElegantTableData<T>": "datos mesa elegante t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "obtener formas pata",
    "getLegShapes": "obtener formas pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "obtiene las formas de las patas como lista",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "obtener forma pata por índice",
    "getLegShapeByIndex": "obtener forma pata por índice",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "obtiene la forma de la pata por índice",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "obtener forma panel superior",
    "getTopPanelShape": "obtener forma panel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "obtiene la forma del panel superior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "obtener forma alambre panel superior",
    "getTopPanelWireShape": "obtener forma alambre panel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "obtiene la forma de alambre del panel superior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "obtener forma alambre panel inferior",
    "getBottomPanelWireShape": "obtener forma alambre panel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "obtiene la forma de alambre del panel inferior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "obtener forma panel inferior",
    "getBottomPanelShape": "obtener forma panel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "obtiene la forma del panel inferior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "obtener forma compuesta patas",
    "getLegsCompoundShape": "obtener forma compuesta patas",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "obtiene las formas de las patas como forma compuesta",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "obtener punto central tablero mesa",
    "getTableTopCenterPoint": "obtener punto central tablero mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "obtiene el punto central superior",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "obtener punto central base mesa",
    "getTableBottomCenterPoint": "obtener punto central base mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "obtiene el punto central inferior",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "obtener puntos inferiores pata",
    "getLegBottomPoints": "obtener puntos inferiores pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "obtiene los puntos inferiores de las patas",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obtener puntos superiores pata",
    "getLegTopPoints": "obtener puntos superiores pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "obtiene los puntos superiores de las patas",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "crea opciones de dibujo para la mesa elegante",
    "topMaterial": "material tablero",
    "topBaseMaterial": "material base tablero",
    "legsMaterial": "material patas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "buena mesa café",
    "goodCoffeeTable": "buena mesa café",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "crea el modelo de buena mesa de café",
    "chamfer": "chaflán",
    "topGlassOffset": "desplazamiento vidrio superior",
    "glassThickness": "grosor vidrio",
    "glassHolderLength": "longitud soporte vidrio",
    "shelfTopOffset": "desplazamiento superior estante",
    "shelfThickness": "grosor estante",
    "legWidth": "ancho pata",
    "legDepth": "profundidad pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "obtiene la forma compuesta de la mesa",
    "GoodCoffeeTableData<T>": "datos buena mesa café t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "obtener formas pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "obtiene las formas de las patas como lista",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "obtener forma pata por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "obtiene la forma de la pata por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "obtener forma panel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "obtiene la forma del panel superior de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "obtener forma alambre panel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "obtiene la forma de alambre del panel superior de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "obtener forma panel vidrio",
    "getGlassPanelShape": "obtener forma panel vidrio",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "obtiene la forma del panel de vidrio de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "obtener forma alambre panel vidrio",
    "getGlassPanelWireShape": "obtener forma alambre panel vidrio",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "obtiene la forma de alambre del panel de vidrio de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "obtener forma estante",
    "getShelfShape": "obtener forma estante",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "obtiene la forma del estante de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "obtener forma alambre superior estante",
    "getShelfTopWireShape": "obtener forma alambre superior estante",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "obtiene la forma de alambre superior del estante de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "obtener forma compuesta patas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "obtiene las formas de las patas como forma compuesta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "obtener punto central tablero mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "obtiene el punto central superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "obtener punto central superior estante mesa",
    "getTableShelfTopCenterPoint": "obtener punto central superior estante mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "obtiene el punto central superior del estante de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "obtener puntos inferiores pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "obtiene los puntos inferiores de las patas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obtener puntos superiores pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "obtiene los puntos superiores de las patas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "crea opciones de dibujo para la buena mesa de café",
    "topGlassMaterial": "material vidrio superior",
    "shelfMaterial": "material estante",
    "bitbybit.things.furniture.tables.snakeTable.create": "mesa serpiente",
    "snakeTable": "mesa serpiente",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "crea el modelo de mesa serpiente",
    "supportLength": "longitud soporte",
    "shelfHeight": "altura estante",
    "glassOffset": "desplazamiento vidrio",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "obtiene la forma compuesta de la mesa",
    "SnakeTableData<T>": "datos mesa serpiente t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "obtener forma vidrio",
    "getGlassShape": "obtener forma vidrio",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "obtiene la forma de vidrio de la mesa",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "obtener forma principal",
    "getMainShape": "obtener forma principal",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "obtiene la forma sólida principal de la mesa",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "obtener punto central superior",
    "getTopCenterPoint": "obtener punto central superior",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "obtiene el punto central del tablero de la mesa",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "crea opciones de dibujo para la mesa serpiente",
    "glassMaterial": "material vidrio",
    "bitbybit.things.enums.lodEnum": "enum nivel detalle",
    "enums": "enums",
    "lodEnum": "enum nivel detalle",
    "bitbybit.things.enums.lodEnum_description": "crea un valor enum de nivel de detalle",
    "bitbybit.jscad.transformSolids": "transformar sólidos",
    "jscad": "jscad",
    "transformSolids": "transformar sólidos",
    "bitbybit.jscad.transformSolids_description": "transforma mallas sólidas jscad con transformaciones",
    "JSCADEntity[]": "array entidad jscad",
    "bitbybit.jscad.transformSolid": "transformar sólido",
    "transformSolid": "transformar sólido",
    "bitbybit.jscad.transformSolid_description": "transforma malla sólida jscad con transformaciones",
    "JSCADEntity": "entidad jscad",
    "bitbybit.jscad.downloadSolidSTL": "descargar stl sólido",
    "downloadSolidSTL": "descargar stl sólido",
    "bitbybit.jscad.downloadSolidSTL_description": "descarga archivo stl binario desde sólido 3d",
    "bitbybit.jscad.downloadSolidsSTL": "descargar stl sólidos",
    "downloadSolidsSTL": "descargar stl sólidos",
    "bitbybit.jscad.downloadSolidsSTL_description": "descarga archivo stl binario desde sólidos 3d",
    "bitbybit.jscad.downloadGeometryDxf": "descargar geometría dxf",
    "downloadGeometryDxf": "descargar geometría dxf",
    "bitbybit.jscad.downloadGeometryDxf_description": "descarga archivo dxf desde geometría jscad",
    "geometry": "geometría",
    "JSCADEntity | JSCADEntity[]": "entidad jscad o array",
    "bitbybit.jscad.downloadGeometry3MF": "descargar geometría 3mf",
    "downloadGeometry3MF": "descargar geometría 3mf",
    "bitbybit.jscad.downloadGeometry3MF_description": "descarga archivo 3mf desde geometría jscad",
    "bitbybit.jscad.booleans.intersect": "intersecar",
    "intersect": "intersecar",
    "bitbybit.jscad.booleans.intersect_description": "interseca múltiples objetos de malla sólida",
    "bitbybit.jscad.booleans.subtract": "restar",
    "subtract": "restar",
    "bitbybit.jscad.booleans.subtract_description": "resta múltiples objetos de malla sólida",
    "bitbybit.jscad.booleans.union": "unir",
    "bitbybit.jscad.booleans.union_description": "une múltiples objetos de malla sólida",
    "bitbybit.jscad.booleans.intersectTwo": "intersecar dos",
    "intersectTwo": "intersecar dos",
    "bitbybit.jscad.booleans.intersectTwo_description": "interseca dos objetos de malla sólida",
    "bitbybit.jscad.booleans.subtractTwo": "restar dos",
    "subtractTwo": "restar dos",
    "bitbybit.jscad.booleans.subtractTwo_description": "resta dos objetos de malla sólida",
    "bitbybit.jscad.booleans.unionTwo": "unir dos",
    "unionTwo": "unir dos",
    "bitbybit.jscad.booleans.unionTwo_description": "une dos objetos de malla sólida",
    "bitbybit.jscad.booleans.subtractFrom": "restar de",
    "subtractFrom": "restar de",
    "bitbybit.jscad.booleans.subtractFrom_description": "resta múltiples mallas de una malla",
    "bitbybit.jscad.expansions.expand": "expandir",
    "expansions": "expansiones",
    "expand": "expandir",
    "bitbybit.jscad.expansions.expand_description": "expande geometrías sólidas",
    "expansion": "expansión",
    "delta": "delta",
    "corners": "esquinas",
    "solidCornerTypeEnum": "enum tipo esquina sólido",
    "bitbybit.jscad.expansions.offset": "desplazamiento",
    "bitbybit.jscad.expansions.offset_description": "desplaza geometrías 2d",
    "bitbybit.jscad.extrusions.extrudeLinear": "extruir lineal",
    "extrudeLinear": "extruir lineal",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "extruye linealmente geometrías 2d",
    "twistAngle": "ángulo torsión",
    "twistSteps": "pasos torsión",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extruir rectangular",
    "extrudeRectangular": "extruir rectangular",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "extruye rectangularmente geometrías 2d",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extruir puntos rectangulares",
    "extrudeRectangularPoints": "extruir puntos rectangulares",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "extruye rectangularmente puntos 2d",
    "bitbybit.jscad.extrusions.extrudeRotate": "extruir rotar",
    "extrudeRotate": "extruir rotar",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "rota y extruye puntos 2d",
    "polygon": "polígono",
    "startAngle": "ángulo inicial",
    "bitbybit.jscad.hulls.hullChain": "casco cadena",
    "hulls": "cascos",
    "hullChain": "casco cadena",
    "bitbybit.jscad.hulls.hullChain_description": "conecta sólidos o geometrías 2d en orden",
    "bitbybit.jscad.hulls.hull": "casco",
    "hull": "casco",
    "bitbybit.jscad.hulls.hull_description": "casco convexo conecta sólidos o geometrías 2d",
    "bitbybit.jscad.path.createFromPoints": "desde puntos",
    "createFromPoints": "desde puntos",
    "bitbybit.jscad.path.createFromPoints_description": "crea ruta 2d desde puntos",
    "Base.Point2[]": "array punto base 2",
    "bitbybit.jscad.path.createPathsFromPoints": "rutas desde puntos",
    "createPathsFromPoints": "rutas desde puntos",
    "bitbybit.jscad.path.createPathsFromPoints_description": "crea rutas 2d desde listas de puntos",
    "pointsLists": "listas puntos",
    "Base.Point3[][] | Base.Point2[][]": "array array punto base 3 o 2",
    "bitbybit.jscad.path.createFromPolyline": "desde polilínea",
    "createFromPolyline": "desde polilínea",
    "bitbybit.jscad.path.createFromPolyline_description": "crea ruta 2d desde polilínea",
    "bitbybit.jscad.path.createEmpty": "vacío",
    "createEmpty": "vacío",
    "bitbybit.jscad.path.createEmpty_description": "crea ruta 2d vacía",
    "bitbybit.jscad.path.close": "cerrar",
    "close": "cerrar",
    "bitbybit.jscad.path.close_description": "cierra ruta 2d abierta",
    "bitbybit.jscad.path.appendPoints": "añadir puntos",
    "appendPoints": "añadir puntos",
    "bitbybit.jscad.path.appendPoints_description": "añade puntos 2d a la ruta",
    "append": "añadir",
    "bitbybit.jscad.path.appendPolyline": "añadir polilínea",
    "appendPolyline": "añadir polilínea",
    "bitbybit.jscad.path.appendPolyline_description": "añade polilínea a la ruta",
    "bitbybit.jscad.path.appendArc": "añadir arco",
    "appendArc": "añadir arco",
    "bitbybit.jscad.path.appendArc_description": "añade arco a la ruta",
    "xAxisRotation": "rotación eje x",
    "clockwise": "sentido horario",
    "large": "grande",
    "bitbybit.jscad.polygon.createFromPoints": "desde puntos",
    "bitbybit.jscad.polygon.createFromPoints_description": "crea polígono 2d desde puntos",
    "bitbybit.jscad.polygon.createFromPolyline": "desde polilínea",
    "bitbybit.jscad.polygon.createFromPolyline_description": "crea polígono 2d desde polilínea",
    "bitbybit.jscad.polygon.createFromCurve": "desde curva",
    "createFromCurve": "desde curva",
    "bitbybit.jscad.polygon.createFromCurve_description": "crea polígono 2d desde curva",
    "bitbybit.jscad.polygon.createFromPath": "desde ruta",
    "createFromPath": "desde ruta",
    "bitbybit.jscad.polygon.createFromPath_description": "crea polígono 2d desde ruta",
    "bitbybit.jscad.polygon.circle": "círculo",
    "bitbybit.jscad.polygon.circle_description": "crea círculo polígono 2d",
    "bitbybit.jscad.polygon.ellipse": "elipse",
    "ellipse": "elipse",
    "bitbybit.jscad.polygon.ellipse_description": "crea elipse polígono 2d",
    "bitbybit.jscad.polygon.rectangle": "rectángulo",
    "rectangle": "rectángulo",
    "bitbybit.jscad.polygon.rectangle_description": "crea rectángulo polígono 2d",
    "bitbybit.jscad.polygon.roundedRectangle": "rectángulo redondeado",
    "roundedRectangle": "rectángulo redondeado",
    "bitbybit.jscad.polygon.roundedRectangle_description": "crea rectángulo redondeado 2d",
    "roundRadius": "radio redondeo",
    "bitbybit.jscad.polygon.square": "cuadrado",
    "square": "cuadrado",
    "bitbybit.jscad.polygon.square_description": "crea cuadrado polígono 2d",
    "bitbybit.jscad.polygon.star": "estrella",
    "star": "estrella",
    "bitbybit.jscad.polygon.star_description": "crea estrella polígono 2d",
    "vertices": "vértices",
    "bitbybit.jscad.shapes.cube": "cubo",
    "cube": "cubo",
    "bitbybit.jscad.shapes.cube_description": "crea forma cubo 3d",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubos en puntos centrales",
    "cubesOnCenterPoints": "cubos en puntos centrales",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "crea cubos 3d en puntos centrales",
    "primitives on centers": "primitivas en centros",
    "bitbybit.jscad.shapes.cuboid": "cuboide",
    "cuboid": "cuboide",
    "bitbybit.jscad.shapes.cuboid_description": "crea forma cuboide 3d",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "cuboides en puntos centrales",
    "cuboidsOnCenterPoints": "cuboides en puntos centrales",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "crea cuboides 3d en puntos centrales",
    "bitbybit.jscad.shapes.cylinderElliptic": "cilindro elíptico",
    "cylinderElliptic": "cilindro elíptico",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "crea sólido cilindro elíptico 3d",
    "startRadius": "radio inicial",
    "endRadius": "radio final",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cilindro elíptico en puntos centrales",
    "cylinderEllipticOnCenterPoints": "cilindro elíptico en puntos centrales",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "crea cilindros elípticos 3d en puntos centrales",
    "bitbybit.jscad.shapes.cylinder": "cilindro",
    "cylinder": "cilindro",
    "bitbybit.jscad.shapes.cylinder_description": "crea sólido cilindro 3d",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cilindros en puntos centrales",
    "cylindersOnCenterPoints": "cilindros en puntos centrales",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "crea cilindros 3d en puntos centrales",
    "bitbybit.jscad.shapes.ellipsoid": "elipsoide",
    "ellipsoid": "elipsoide",
    "bitbybit.jscad.shapes.ellipsoid_description": "crea sólido elipsoide 3d",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "elipsoides en puntos centrales",
    "ellipsoidsOnCenterPoints": "elipsoides en puntos centrales",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "crea elipsoides 3d en puntos centrales",
    "bitbybit.jscad.shapes.geodesicSphere": "esfera geodésica",
    "geodesicSphere": "esfera geodésica",
    "bitbybit.jscad.shapes.geodesicSphere_description": "crea sólido esfera geodésica 3d",
    "frequency": "frecuencia",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "esferas geodésicas en puntos centrales",
    "geodesicSpheresOnCenterPoints": "esferas geodésicas en puntos centrales",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "crea esferas geodésicas 3d en puntos centrales",
    "bitbybit.jscad.shapes.roundedCuboid": "cuboide redondeado",
    "roundedCuboid": "cuboide redondeado",
    "bitbybit.jscad.shapes.roundedCuboid_description": "crea sólido cuboide redondeado 3d",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "cuboides redondeados en puntos centrales",
    "roundedCuboidsOnCenterPoints": "cuboides redondeados en puntos centrales",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "crea cuboides redondeados 3d en puntos centrales",
    "bitbybit.jscad.shapes.roundedCylinder": "cilindro redondeado",
    "roundedCylinder": "cilindro redondeado",
    "bitbybit.jscad.shapes.roundedCylinder_description": "crea sólido cilindro redondeado 3d",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "cilindros redondeados en puntos centrales",
    "roundedCylindersOnCenterPoints": "cilindros redondeados en puntos centrales",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "crea cilindros redondeados 3d en puntos centrales",
    "bitbybit.jscad.shapes.sphere": "esfera",
    "sphere": "esfera",
    "bitbybit.jscad.shapes.sphere_description": "crea sólido esfera 3d",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "esferas en puntos centrales",
    "spheresOnCenterPoints": "esferas en puntos centrales",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "crea esferas 3d en puntos centrales",
    "bitbybit.jscad.shapes.torus": "toro",
    "torus": "toro",
    "bitbybit.jscad.shapes.torus_description": "crea sólido toro 3d",
    "innerSegments": "segmentos interiores",
    "outerSegments": "segmentos exteriores",
    "innerRotation": "rotación interior",
    "outerRotation": "rotación exterior",
    "bitbybit.jscad.shapes.fromPolygonPoints": "desde puntos polígono",
    "fromPolygonPoints": "desde puntos polígono",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "crea forma 3d desde puntos polígono anidados",
    "polygonPoints": "puntos polígono",
    "Base.Point3[][]": "array array punto base 3",
    "bitbybit.jscad.text.cylindricalText": "texto cilíndrico",
    "cylindricalText": "texto cilíndrico",
    "bitbybit.jscad.text.cylindricalText_description": "crea texto con cascos de cadena cilíndricos",
    "extrusionHeight": "altura extrusión",
    "extrusionSize": "tamaño extrusión",
    "jscadTextAlignEnum": "enum alineación texto jscad",
    "bitbybit.jscad.text.sphericalText": "texto esférico",
    "sphericalText": "texto esférico",
    "bitbybit.jscad.text.sphericalText_description": "crea texto con cascos de cadena esféricos",
    "bitbybit.jscad.text.createVectorText": "crear texto vectorial",
    "createVectorText": "crear texto vectorial",
    "bitbybit.jscad.text.createVectorText_description": "crea texto vectorial",
    "bitbybit.jscad.colors.colorize": "colorear",
    "colors": "colores",
    "colorize": "colorear",
    "bitbybit.jscad.colors.colorize_description": "colorea geometría jscad",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold a puntero malla",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold a puntero malla",
    "bitbybit.manifold.manifoldToMeshPointer_description": "convierte forma manifold en puntero malla",
    "meshing": "mallado",
    "normalIdx": "índice normal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "descomponer manifold o sección transversal",
    "decomposeManifoldOrCrossSection": "descomponer manifold o sección transversal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "descompone manifold o sección transversal en malla o polígonos",
    "decompose": "descomponer",
    "manifoldOrCrossSection": "manifold o sección transversal",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "descomponer manifolds o secciones transversales",
    "decomposeManifoldsOrCrossSections": "descomponer manifolds o secciones transversales",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "descompone manifolds o secciones transversales en mallas o polígonos",
    "manifoldsOrCrossSections": "manifolds o secciones transversales",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "eliminar manifold o sección transversal",
    "deleteManifoldOrCrossSection": "eliminar manifold o sección transversal",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "elimina manifold o sección transversal de la memoria",
    "cleanup": "limpieza",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "eliminar manifolds o secciones transversales",
    "deleteManifoldsOrCrossSections": "eliminar manifolds o secciones transversales",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "elimina manifolds o secciones transversales de la memoria",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold a malla",
    "manifoldToMesh": "manifold a malla",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "convierte forma manifold en malla",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds a mallas",
    "manifoldsToMeshes": "manifolds a mallas",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "convierte formas manifold en mallas",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold desde malla",
    "manifoldFromMesh": "manifold desde malla",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "convierte malla en manifold",
    "DecomposedManifoldMeshDto": "dto malla manifold descompuesta",
    "bitbybit.manifold.manifold.shapes.cube": "cubo",
    "bitbybit.manifold.manifold.shapes.cube_description": "crea forma cubo 3d",
    "bitbybit.manifold.manifold.shapes.sphere": "esfera",
    "bitbybit.manifold.manifold.shapes.sphere_description": "crea forma esfera 3d",
    "circularSegments": "segmentos circulares",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tetraedro",
    "tetrahedron": "tetraedro",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "crea forma tetraedro 3d",
    "bitbybit.manifold.manifold.shapes.cylinder": "cilindro",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "crea forma cilindro 3d",
    "radiusLow": "radio bajo",
    "radiusHigh": "radio alto",
    "bitbybit.manifold.manifold.booleans.subtract": "restar",
    "bitbybit.manifold.manifold.booleans.subtract_description": "resta dos formas manifold",
    "a to b": "a a b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "sumar",
    "bitbybit.manifold.manifold.booleans.add_description": "suma dos formas manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "intersecar",
    "bitbybit.manifold.manifold.booleans.intersect_description": "interseca dos formas manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "diferencia dos",
    "differenceTwo": "diferencia dos",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "diferencia de dos formas manifold",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "unión dos",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "unión de dos formas manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "intersección dos",
    "intersectionTwo": "intersección dos",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "intersección de dos formas manifold",
    "bitbybit.manifold.manifold.booleans.difference": "diferencia",
    "bitbybit.manifold.manifold.booleans.difference_description": "diferencia de múltiples formas manifold",
    "bitbybit.manifold.manifold.booleans.union": "unión",
    "bitbybit.manifold.manifold.booleans.union_description": "unión de múltiples formas manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "intersección",
    "bitbybit.manifold.manifold.booleans.intersection_description": "intersección de múltiples formas manifold",
    "bitbybit.manifold.manifold.booleans.split": "dividir",
    "split": "dividir",
    "bitbybit.manifold.manifold.booleans.split_description": "divide manifold por otro manifold",
    "manifoldToSplit": "manifold a dividir",
    "manifoldCutter": "cortador manifold",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "dividir por plano",
    "splitByPlane": "dividir por plano",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "divide manifold por plano",
    "originOffset": "desplazamiento origen",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "dividir por plano en desplazamientos",
    "splitByPlaneOnOffsets": "dividir por plano en desplazamientos",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "divide manifold por plano en desplazamientos",
    "originOffsets": "desplazamientos origen",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "recortar por plano",
    "trimByPlane": "recortar por plano",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "recorta manifold por plano",
    "trim": "recortar",
    "bitbybit.manifold.manifold.operations.hull": "casco",
    "bitbybit.manifold.manifold.operations.hull_description": "calcula el casco convexo de la forma manifold",
    "bitbybit.manifold.manifold.operations.hullPoints": "casco puntos",
    "hullPoints": "casco puntos",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "crea cascos de puntos o manifolds",
    "bitbybit.manifold.manifold.operations.slice": "rebanar",
    "bitbybit.manifold.manifold.operations.slice_description": "retorna sección transversal del objeto a la altura",
    "cross sections": "secciones transversales",
    "bitbybit.manifold.manifold.operations.project": "proyectar",
    "bitbybit.manifold.manifold.operations.project_description": "crea proyección en plano xy desde contorno forma",
    "bitbybit.manifold.manifold.operations.setTolerance": "establecer tolerancia",
    "setTolerance": "establecer tolerancia",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "establece valor tolerancia para manifold",
    "basic": "básico",
    "bitbybit.manifold.manifold.operations.reserveIds": "reservar ids",
    "reserveIds": "reservar ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "reserva ids de malla secuenciales",
    "count": "contar",
    "bitbybit.manifold.manifold.operations.asOriginal": "como original",
    "asOriginal": "como original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "restablece ids manifold como originales",
    "bitbybit.manifold.manifold.operations.compose": "componer",
    "compose": "componer",
    "bitbybit.manifold.manifold.operations.compose_description": "construye manifold desde lista de manifolds",
    "composition": "composición",
    "bitbybit.manifold.manifold.operations.decompose": "descomponer",
    "bitbybit.manifold.manifold.operations.decompose_description": "descompone manifold en partes desconectadas",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calcular normales",
    "calculateNormals": "calcular normales",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "calcula normales de vértice",
    "adjustments": "ajustes",
    "minSharpAngle": "ángulo agudo mín",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calcular curvatura",
    "calculateCurvature": "calcular curvatura",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "calcula curvatura para vértices",
    "gaussianIdx": "índice gaussiano",
    "meanIdx": "índice medio",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "refinar a tolerancia",
    "refineToTolerance": "refinar a tolerancia",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "refina malla a tolerancia",
    "bitbybit.manifold.manifold.operations.refineToLength": "refinar a longitud",
    "refineToLength": "refinar a longitud",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "refina malla a longitud",
    "bitbybit.manifold.manifold.operations.refine": "refinar",
    "refine": "refinar",
    "bitbybit.manifold.manifold.operations.refine_description": "refina malla dividiendo aristas",
    "bitbybit.manifold.manifold.operations.smoothOut": "suavizar",
    "smoothOut": "suavizar",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "suaviza manifold con vectores tangentes",
    "minSmoothness": "suavidad mín",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "suavizar por normales",
    "smoothByNormals": "suavizar por normales",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "suaviza manifold usando normales de vértice",
    "bitbybit.manifold.manifold.transforms.scale3D": "escalar 3d",
    "scale3D": "escalar 3d",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "escala manifold con vector 3d",
    "bitbybit.manifold.manifold.transforms.scale": "escalar",
    "bitbybit.manifold.manifold.transforms.scale_description": "escala manifold con factor único",
    "bitbybit.manifold.manifold.transforms.mirror": "reflejar",
    "bitbybit.manifold.manifold.transforms.mirror_description": "refleja manifold sobre plano",
    "bitbybit.manifold.manifold.transforms.translate": "trasladar",
    "bitbybit.manifold.manifold.transforms.translate_description": "traslada manifold a lo largo de vector",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "trasladar por vectores",
    "translateByVectors": "trasladar por vectores",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "traslada manifold por múltiples vectores",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "trasladar xyz",
    "translateXYZ": "trasladar xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "traslada manifold a lo largo de x y z",
    "bitbybit.manifold.manifold.transforms.rotate": "rotar",
    "bitbybit.manifold.manifold.transforms.rotate_description": "rota manifold con ángulos euler",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "rotar xyz",
    "rotateXYZ": "rotar xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "rota manifold a lo largo de ángulos euler x y z",
    "bitbybit.manifold.manifold.transforms.transform": "transformar",
    "bitbybit.manifold.manifold.transforms.transform_description": "transforma manifold con matriz 4x4",
    "matrix": "matriz",
    "Base.TransformMatrix": "matriz transformación base",
    "bitbybit.manifold.manifold.transforms.transforms": "transformaciones",
    "bitbybit.manifold.manifold.transforms.transforms_description": "transforma manifold con múltiples matrices 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "área superficial",
    "evaluate": "evaluar",
    "surfaceArea": "área superficial",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "obtiene área superficial de manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volumen",
    "volume": "volumen",
    "bitbybit.manifold.manifold.evaluate.volume_description": "obtiene volumen de manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "está vacío",
    "isEmpty": "está vacío",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "comprueba si manifold tiene triángulos",
    "bitbybit.manifold.manifold.evaluate.numVert": "núm vértices",
    "numVert": "núm vértices",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "obtiene número de vértices en manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "núm triángulos",
    "numTri": "núm triángulos",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "obtiene número de triángulos en manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "núm aristas",
    "numEdge": "núm aristas",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "obtiene número de aristas en manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "núm prop",
    "numProp": "núm prop",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "obtiene número de propiedades en manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "núm prop vértice",
    "numPropVert": "núm prop vértice",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "obtiene número de vértices propiedad en manifold",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "caja delimitadora",
    "boundingBox": "caja delimitadora",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "obtiene caja delimitadora alineada ejes de manifold",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolerancia",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "obtiene tolerancia vértices manifold",
    "bitbybit.manifold.manifold.evaluate.genus": "género",
    "genus": "género",
    "bitbybit.manifold.manifold.evaluate.genus_description": "obtiene género de manifold",
    "bitbybit.manifold.manifold.evaluate.minGap": "hueco mín",
    "minGap": "hueco mín",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "obtiene hueco mínimo entre dos manifolds",
    "searchLength": "longitud búsqueda",
    "bitbybit.manifold.manifold.evaluate.originalID": "id original",
    "originalID": "id original",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "obtiene id original de manifold",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "sección transversal a polígonos",
    "crossSection": "sección transversal",
    "crossSectionToPolygons": "sección transversal a polígonos",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "convierte sección transversal en polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "secciones transversales a polígonos",
    "crossSectionsToPolygons": "secciones transversales a polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "convierte secciones transversales en polígonos",
    "crossSections": "secciones transversales",
    "bitbybit.manifold.crossSection.shapes.create": "crear",
    "bitbybit.manifold.crossSection.shapes.create_description": "crea sección transversal 2d desde contornos",
    "Base.Vector2[][]": "array de array de vector base 2",
    "fillRule": "regla relleno",
    "fillRuleEnum": "enum regla relleno",
    "bitbybit.manifold.crossSection.shapes.square": "cuadrado",
    "bitbybit.manifold.crossSection.shapes.square_description": "crea sección transversal cuadrada 2d",
    "bitbybit.manifold.crossSection.shapes.circle": "círculo",
    "bitbybit.manifold.crossSection.shapes.circle_description": "crea sección transversal circular 2d",
    "bitbybit.manifold.crossSection.shapes.rectangle": "rectángulo",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "crea sección transversal rectangular 2d",
    "bitbybit.manifold.crossSection.operations.hull": "casco",
    "bitbybit.manifold.crossSection.operations.hull_description": "calcula casco convexo para sección transversal",
    "bitbybit.manifold.crossSection.operations.extrude": "extruir",
    "bitbybit.manifold.crossSection.operations.extrude_description": "extruye sección transversal a forma 3d",
    "nDivisions": "n divisiones",
    "twistDegrees": "grados torsión",
    "scaleTopX": "escala sup x",
    "scaleTopY": "escala sup y",
    "bitbybit.manifold.crossSection.operations.revolve": "revolucionar",
    "bitbybit.manifold.crossSection.operations.revolve_description": "revoluciona sección transversal a forma 3d",
    "revolveDegrees": "grados revolución",
    "matchProfile": "coincidir perfil",
    "bitbybit.manifold.crossSection.operations.offset": "desplazamiento",
    "bitbybit.manifold.crossSection.operations.offset_description": "desplaza sección transversal con delta",
    "manifoldJoinTypeEnum": "enum tipo unión manifold",
    "miterLimit": "límite inglete",
    "bitbybit.manifold.crossSection.operations.simplify": "simplificar",
    "simplify": "simplificar",
    "bitbybit.manifold.crossSection.operations.simplify_description": "simplifica contornos sección transversal",
    "epsilon": "épsilon",
    "bitbybit.manifold.crossSection.operations.compose": "componer",
    "bitbybit.manifold.crossSection.operations.compose_description": "compone múltiples secciones transversales en una",
    "bitbybit.manifold.crossSection.operations.decompose": "descomponer",
    "bitbybit.manifold.crossSection.operations.decompose_description": "descompone secciones transversales en partes",
    "bitbybit.manifold.crossSection.booleans.subtract": "restar",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "resta dos secciones transversales",
    "crossSection1": "sección transversal 1",
    "crossSection2": "sección transversal 2",
    "bitbybit.manifold.crossSection.booleans.add": "sumar",
    "bitbybit.manifold.crossSection.booleans.add_description": "suma dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.intersect": "intersecar",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "interseca dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "diferencia dos",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "diferencia de dos secciones transversales",
    "2 cross sections": "2 secciones transversales",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "unión dos",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "unión de dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "intersección dos",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "intersección de dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.difference": "diferencia",
    "bitbybit.manifold.crossSection.booleans.difference_description": "diferencia de múltiples secciones transversales",
    "bitbybit.manifold.crossSection.booleans.union": "unión",
    "bitbybit.manifold.crossSection.booleans.union_description": "unión de múltiples secciones transversales",
    "bitbybit.manifold.crossSection.booleans.intersection": "intersección",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "intersección de múltiples secciones transversales",
    "bitbybit.manifold.crossSection.transforms.scale2D": "escalar 2d",
    "scale2D": "escalar 2d",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "escala sección transversal con vector 2d",
    "bitbybit.manifold.crossSection.transforms.scale": "escalar",
    "bitbybit.manifold.crossSection.transforms.scale_description": "escala sección transversal con factor único",
    "bitbybit.manifold.crossSection.transforms.mirror": "reflejar",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "refleja sección transversal sobre plano",
    "bitbybit.manifold.crossSection.transforms.translate": "trasladar",
    "bitbybit.manifold.crossSection.transforms.translate_description": "traslada sección transversal a lo largo de vector",
    "bitbybit.manifold.crossSection.transforms.translateXY": "trasladar xy",
    "translateXY": "trasladar xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "traslada sección transversal a lo largo de x y",
    "bitbybit.manifold.crossSection.transforms.rotate": "rotar",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "rota sección transversal con grados",
    "degrees": "grados",
    "bitbybit.manifold.crossSection.transforms.transform": "transformar",
    "bitbybit.manifold.crossSection.transforms.transform_description": "transforma sección transversal con matriz 3x3",
    "Base.TransformMatrix3x3": "matriz transformación base 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "área",
    "area": "área",
    "bitbybit.manifold.crossSection.evaluate.area_description": "obtiene área de sección transversal",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "está vacío",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "comprueba si sección transversal está vacía",
    "bitbybit.manifold.crossSection.evaluate.numVert": "núm vértices",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "obtiene número de vértices en sección transversal",
    "bitbybit.manifold.crossSection.evaluate.numContour": "núm contorno",
    "numContour": "núm contorno",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "obtiene número de contornos en sección transversal",
    "bitbybit.manifold.crossSection.evaluate.bounds": "límites",
    "bounds": "límites",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "obtiene límites de contorno como rectángulo",
    "bitbybit.manifold.mesh.operations.merge": "fusionar",
    "merge": "fusionar",
    "bitbybit.manifold.mesh.operations.merge_description": "fusiona vértices a sólido manifold",
    "bitbybit.manifold.mesh.evaluate.position": "posición",
    "bitbybit.manifold.mesh.evaluate.position_description": "obtiene posición en índice vértice malla",
    "vertexIndex": "índice vértice",
    "bitbybit.manifold.mesh.evaluate.verts": "vértices",
    "verts": "vértices",
    "bitbybit.manifold.mesh.evaluate.verts_description": "obtiene tres índices vértice de triángulo",
    "triangleIndex": "índice triángulo",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangente",
    "tangent": "tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "obtiene vector tangente de media arista",
    "halfEdgeIndex": "índice media arista",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "obtiene propiedades extra de vértice",
    "bitbybit.manifold.mesh.evaluate.transform": "transformar",
    "bitbybit.manifold.mesh.evaluate.transform_description": "obtiene matriz transformación 4x4 de malla",
    "bitbybit.manifold.mesh.evaluate.numProp": "núm prop",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "obtiene número de propiedades por vértice",
    "bitbybit.manifold.mesh.evaluate.numVert": "núm vértices",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "obtiene número de vértices propiedad",
    "bitbybit.manifold.mesh.evaluate.numTri": "núm triángulos",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "obtiene número de triángulos en malla",
    "bitbybit.manifold.mesh.evaluate.numRun": "núm ejecución",
    "numRun": "núm ejecución",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "obtiene número de ejecuciones triángulo",
    "bitbybit.logic.boolean": "booleano",
    "logic": "lógica",
    "bitbybit.logic.boolean_description": "crea valor booleano",
    "bitbybit.logic.randomBooleans": "booleanos aleatorios",
    "randomBooleans": "booleanos aleatorios",
    "bitbybit.logic.randomBooleans_description": "crea lista booleana aleatoria",
    "trueThreshold": "umbral verdadero",
    "bitbybit.logic.twoThresholdRandomGradient": "gradiente aleatorio dos umbrales",
    "twoThresholdRandomGradient": "gradiente aleatorio dos umbrales",
    "bitbybit.logic.twoThresholdRandomGradient_description": "crea lista booleana aleatoria con umbrales",
    "numbers": "números",
    "thresholdTotalTrue": "umbral total verdadero",
    "thresholdTotalFalse": "umbral total falso",
    "nrLevels": "núm niveles",
    "bitbybit.logic.thresholdBooleanList": "lista booleana umbral",
    "thresholdBooleanList": "lista booleana umbral",
    "bitbybit.logic.thresholdBooleanList_description": "crea lista booleana con umbral",
    "threshold": "umbral",
    "bitbybit.logic.thresholdGapsBooleanList": "lista booleana umbral huecos",
    "thresholdGapsBooleanList": "lista booleana umbral huecos",
    "bitbybit.logic.thresholdGapsBooleanList_description": "crea lista booleana con umbrales hueco",
    "gapThresholds": "umbrales hueco",
    "Base.Vector2[]": "array vector base 2",
    "bitbybit.logic.not": "no",
    "not": "no",
    "bitbybit.logic.not_description": "aplica operador no en booleano",
    "bitbybit.logic.notList": "no lista",
    "notList": "no lista",
    "bitbybit.logic.notList_description": "aplica operador no en lista booleana",
    "bitbybit.logic.compare": "comparar",
    "compare": "comparar",
    "bitbybit.logic.compare_description": "compara dos valores",
    "operator": "operador",
    "BooleanOperatorsEnum": "enum operadores booleanos",
    "bitbybit.logic.valueGate": "puerta valor",
    "valueGate": "puerta valor",
    "bitbybit.logic.valueGate_description": "transmite valor si booleano es verdadero",
    "bitbybit.logic.firstDefinedValueGate": "puerta primer valor definido",
    "firstDefinedValueGate": "puerta primer valor definido",
    "bitbybit.logic.firstDefinedValueGate_description": "retorna primer valor definido",
    "value1": "valor 1",
    "value2": "valor 2",
    "bitbybit.math.number": "número",
    "math": "matemáticas",
    "bitbybit.math.number_description": "crea un número",
    "bitbybit.math.twoNrOperation": "operación dos núm",
    "twoNrOperation": "operación dos núm",
    "bitbybit.math.twoNrOperation_description": "realiza operaciones matemáticas básicas",
    "operation": "operación",
    "mathTwoNrOperatorEnum": "enum operador matemáticas dos núm",
    "bitbybit.math.modulus": "módulo",
    "modulus": "módulo",
    "bitbybit.math.modulus_description": "realiza operación módulo",
    "bitbybit.math.roundToDecimals": "redondear a decimales",
    "roundToDecimals": "redondear a decimales",
    "bitbybit.math.roundToDecimals_description": "redondea a decimales",
    "decimalPlaces": "lugares decimales",
    "bitbybit.math.oneNrOperation": "operación un núm",
    "oneNrOperation": "operación un núm",
    "bitbybit.math.oneNrOperation_description": "realiza matemáticas en un número",
    "mathOneNrOperatorEnum": "enum operador matemáticas un núm",
    "bitbybit.math.remap": "remapear",
    "remap": "remapear",
    "bitbybit.math.remap_description": "remapea número entre rangos",
    "fromLow": "desde bajo",
    "fromHigh": "desde alto",
    "toLow": "a bajo",
    "toHigh": "a alto",
    "bitbybit.math.random": "aleatorio",
    "random": "aleatorio",
    "bitbybit.math.random_description": "crea número aleatorio 0 a 1",
    "generate": "generar",
    "bitbybit.math.randomNumber": "número aleatorio",
    "randomNumber": "número aleatorio",
    "bitbybit.math.randomNumber_description": "crea número aleatorio en rango",
    "low": "bajo",
    "high": "alto",
    "bitbybit.math.randomNumbers": "números aleatorios",
    "randomNumbers": "números aleatorios",
    "bitbybit.math.randomNumbers_description": "crea números aleatorios en rango",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "crea número pi",
    "bitbybit.math.toFixed": "a fijo",
    "toFixed": "a fijo",
    "bitbybit.math.toFixed_description": "redondea número a decimales",
    "bitbybit.math.add": "sumar",
    "bitbybit.math.add_description": "suma dos números",
    "basics": "básicos",
    "bitbybit.math.subtract": "restar",
    "bitbybit.math.subtract_description": "resta dos números",
    "bitbybit.math.multiply": "multiplicar",
    "bitbybit.math.multiply_description": "multiplica dos números",
    "bitbybit.math.divide": "dividir",
    "divide": "dividir",
    "bitbybit.math.divide_description": "divide dos números",
    "bitbybit.math.power": "potencia",
    "power": "potencia",
    "bitbybit.math.power_description": "eleva número a potencia",
    "bitbybit.math.sqrt": "raíz cuadrada",
    "sqrt": "raíz cuadrada",
    "bitbybit.math.sqrt_description": "obtiene raíz cuadrada",
    "bitbybit.math.abs": "absoluto",
    "abs": "absoluto",
    "bitbybit.math.abs_description": "obtiene valor absoluto",
    "bitbybit.math.round": "redondear",
    "round": "redondear",
    "bitbybit.math.round_description": "redondea un número",
    "bitbybit.math.floor": "suelo",
    "floor": "suelo",
    "bitbybit.math.floor_description": "redondea número hacia abajo",
    "bitbybit.math.ceil": "techo",
    "ceil": "techo",
    "bitbybit.math.ceil_description": "redondea número hacia arriba",
    "bitbybit.math.negate": "negar",
    "negate": "negar",
    "bitbybit.math.negate_description": "niega un número",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "obtiene logaritmo natural",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "obtiene logaritmo base 10",
    "bitbybit.math.tenPow": "diez pot",
    "tenPow": "diez pot",
    "bitbybit.math.tenPow_description": "eleva 10 a potencia",
    "bitbybit.math.sin": "seno",
    "sin": "seno",
    "bitbybit.math.sin_description": "obtiene seno",
    "bitbybit.math.cos": "coseno",
    "cos": "coseno",
    "bitbybit.math.cos_description": "obtiene coseno",
    "bitbybit.math.tan": "tangente",
    "tan": "tangente",
    "bitbybit.math.tan_description": "obtiene tangente",
    "bitbybit.math.asin": "arcsen",
    "asin": "arcsen",
    "bitbybit.math.asin_description": "obtiene arcoseno",
    "bitbybit.math.acos": "arccos",
    "acos": "arccos",
    "bitbybit.math.acos_description": "obtiene arcocoseno",
    "bitbybit.math.atan": "arctan",
    "atan": "arctan",
    "bitbybit.math.atan_description": "obtiene arcotangente",
    "bitbybit.math.exp": "exp",
    "exp": "exp",
    "bitbybit.math.exp_description": "obtiene exponente natural",
    "bitbybit.math.degToRad": "grados a rad",
    "degToRad": "grados a rad",
    "bitbybit.math.degToRad_description": "convierte grados a radianes",
    "bitbybit.math.radToDeg": "rad a grados",
    "radToDeg": "rad a grados",
    "bitbybit.math.radToDeg_description": "convierte radianes a grados",
    "bitbybit.math.ease": "suavizar",
    "bitbybit.math.ease_description": "suaviza número con rango",
    "easeEnum": "enum suavizado",
    "bitbybit.lists.getItem": "obtener elemento",
    "lists": "listas",
    "getItem": "obtener elemento",
    "bitbybit.lists.getItem_description": "obtiene elemento de lista por índice",
    "list": "lista",
    "bitbybit.lists.randomGetThreshold": "obtener umbral aleatorio",
    "randomGetThreshold": "obtener umbral aleatorio",
    "bitbybit.lists.randomGetThreshold_description": "obtiene elementos aleatoriamente con umbral",
    "bitbybit.lists.getSubList": "obtener sublista",
    "getSubList": "obtener sublista",
    "bitbybit.lists.getSubList_description": "obtiene sublista entre índices",
    "indexStart": "índice inicio",
    "indexEnd": "índice fin",
    "bitbybit.lists.getNthItem": "obtener enésimo elemento",
    "getNthItem": "obtener enésimo elemento",
    "bitbybit.lists.getNthItem_description": "obtiene enésimo elemento en lista",
    "nth": "enésimo",
    "bitbybit.lists.getByPattern": "obtener por patrón",
    "getByPattern": "obtener por patrón",
    "bitbybit.lists.getByPattern_description": "obtiene elementos por patrón",
    "pattern": "patrón",
    "bitbybit.lists.mergeElementsOfLists": "fusionar elementos de listas",
    "mergeElementsOfLists": "fusionar elementos de listas",
    "bitbybit.lists.mergeElementsOfLists_description": "fusiona elementos de listas en nivel",
    "level": "nivel",
    "bitbybit.lists.getLongestListLength": "obtener longitud lista más larga",
    "getLongestListLength": "obtener longitud lista más larga",
    "bitbybit.lists.getLongestListLength_description": "obtiene longitud lista más larga",
    "bitbybit.lists.reverse": "invertir",
    "bitbybit.lists.reverse_description": "invierte lista",
    "bitbybit.lists.flipLists": "voltear listas",
    "flipLists": "voltear listas",
    "bitbybit.lists.flipLists_description": "voltea listas 2d",
    "bitbybit.lists.groupNth": "agrupar enésimo",
    "groupNth": "agrupar enésimo",
    "bitbybit.lists.groupNth_description": "agrupa lista en n elementos",
    "nrElements": "núm elementos",
    "keepRemainder": "mantener resto",
    "bitbybit.lists.getListDepth": "obtener profundidad lista",
    "getListDepth": "obtener profundidad lista",
    "bitbybit.lists.getListDepth_description": "obtiene profundidad de lista",
    "bitbybit.lists.listLength": "longitud lista",
    "listLength": "longitud lista",
    "bitbybit.lists.listLength_description": "obtiene longitud de lista",
    "bitbybit.lists.addItemAtIndex": "añadir elemento en índice",
    "addItemAtIndex": "añadir elemento en índice",
    "bitbybit.lists.addItemAtIndex_description": "añade elemento a lista en índice",
    "item": "elemento",
    "bitbybit.lists.addItemAtIndexes": "añadir elemento en índices",
    "addItemAtIndexes": "añadir elemento en índices",
    "bitbybit.lists.addItemAtIndexes_description": "añade elemento a lista en índices",
    "bitbybit.lists.addItemsAtIndexes": "añadir elementos en índices",
    "addItemsAtIndexes": "añadir elementos en índices",
    "bitbybit.lists.addItemsAtIndexes_description": "añade elementos a lista en índices",
    "items": "elementos",
    "bitbybit.lists.removeItemAtIndex": "eliminar elemento en índice",
    "removeItemAtIndex": "eliminar elemento en índice",
    "bitbybit.lists.removeItemAtIndex_description": "elimina elemento de lista en índice",
    "bitbybit.lists.removeItemsAtIndexes": "eliminar elementos en índices",
    "removeItemsAtIndexes": "eliminar elementos en índices",
    "bitbybit.lists.removeItemsAtIndexes_description": "elimina elementos de lista en índices",
    "bitbybit.lists.removeAllItems": "eliminar todos elementos",
    "removeAllItems": "eliminar todos elementos",
    "bitbybit.lists.removeAllItems_description": "elimina todos elementos de lista",
    "bitbybit.lists.removeNthItem": "eliminar enésimo elemento",
    "removeNthItem": "eliminar enésimo elemento",
    "bitbybit.lists.removeNthItem_description": "elimina enésimo elemento de lista",
    "bitbybit.lists.randomRemoveThreshold": "eliminar umbral aleatorio",
    "randomRemoveThreshold": "eliminar umbral aleatorio",
    "bitbybit.lists.randomRemoveThreshold_description": "elimina elementos aleatoriamente con umbral",
    "bitbybit.lists.removeDuplicateNumbers": "eliminar números duplicados",
    "removeDuplicateNumbers": "eliminar números duplicados",
    "bitbybit.lists.removeDuplicateNumbers_description": "elimina números duplicados de lista",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "eliminar números duplicados tolerancia",
    "removeDuplicateNumbersTolerance": "eliminar números duplicados tolerancia",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "elimina números duplicados con tolerancia",
    "bitbybit.lists.addItem": "añadir elemento",
    "addItem": "añadir elemento",
    "bitbybit.lists.addItem_description": "añade elemento al final de lista",
    "bitbybit.lists.prependItem": "añadir elemento al inicio",
    "prependItem": "añadir elemento al inicio",
    "bitbybit.lists.prependItem_description": "añade elemento al inicio de lista",
    "bitbybit.lists.addItemFirstLast": "añadir elemento inicio fin",
    "addItemFirstLast": "añadir elemento inicio fin",
    "bitbybit.lists.addItemFirstLast_description": "añade elemento al inicio o fin de lista",
    "firstLastEnum": "enum inicio fin",
    "bitbybit.lists.createEmptyList": "lista vacía",
    "createEmptyList": "lista vacía",
    "bitbybit.lists.createEmptyList_description": "crea lista vacía",
    "bitbybit.lists.repeat": "repetir",
    "repeat": "repetir",
    "bitbybit.lists.repeat_description": "repite elemento en nueva lista",
    "times": "veces",
    "bitbybit.lists.repeatInPattern": "repetir en patrón",
    "repeatInPattern": "repetir en patrón",
    "bitbybit.lists.repeatInPattern_description": "repite elementos lista hasta límite longitud",
    "lengthLimit": "límite longitud",
    "bitbybit.lists.sortNumber": "ordenar número",
    "sortNumber": "ordenar número",
    "bitbybit.lists.sortNumber_description": "ordena lista de números",
    "sorting": "ordenación",
    "orderAsc": "orden asc",
    "bitbybit.lists.sortTexts": "ordenar textos",
    "sortTexts": "ordenar textos",
    "bitbybit.lists.sortTexts_description": "ordena lista de textos alfabéticamente",
    "bitbybit.lists.sortByPropValue": "ordenar por valor prop",
    "sortByPropValue": "ordenar por valor prop",
    "bitbybit.lists.sortByPropValue_description": "ordena por propiedad json numérica",
    "property": "propiedad",
    "bitbybit.color.hexColor": "color hex",
    "hexColor": "color hex",
    "bitbybit.color.hexColor_description": "crea color hex",
    "bitbybit.color.hexToRgb": "hex a rgb",
    "hexToRgb": "hex a rgb",
    "bitbybit.color.hexToRgb_description": "crea rgb desde hex",
    "convert": "convertir",
    "bitbybit.color.rgbToHex": "rgb a hex",
    "rgbToHex": "rgb a hex",
    "bitbybit.color.rgbToHex_description": "crea hex desde rgb",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "obj rgb a hex",
    "rgbObjToHex": "obj rgb a hex",
    "bitbybit.color.rgbObjToHex_description": "crea hex desde objeto rgb",
    "rgb": "rgb",
    "Base.ColorRGB": "color base rgb",
    "bitbybit.color.hexToRgbMapped": "hex a rgb mapeado",
    "hexToRgbMapped": "hex a rgb mapeado",
    "bitbybit.color.hexToRgbMapped_description": "crea rgb desde hex con mapeo rango",
    "bitbybit.color.getRedParam": "obtener param rojo",
    "getRedParam": "obtener param rojo",
    "bitbybit.color.getRedParam_description": "obtiene param rojo",
    "hex to": "hex a",
    "bitbybit.color.getGreenParam": "obtener param verde",
    "getGreenParam": "obtener param verde",
    "bitbybit.color.getGreenParam_description": "obtiene param verde",
    "bitbybit.color.getBlueParam": "obtener param azul",
    "getBlueParam": "obtener param azul",
    "bitbybit.color.getBlueParam_description": "obtiene param azul",
    "bitbybit.color.rgbToRed": "rgb a rojo",
    "rgbToRed": "rgb a rojo",
    "bitbybit.color.rgbToRed_description": "obtiene rojo desde rgb",
    "rgb to": "rgb a",
    "bitbybit.color.rgbToGreen": "rgb a verde",
    "rgbToGreen": "rgb a verde",
    "bitbybit.color.rgbToGreen_description": "obtiene verde desde rgb",
    "bitbybit.color.rgbToBlue": "rgb a azul",
    "rgbToBlue": "rgb a azul",
    "bitbybit.color.rgbToBlue_description": "obtiene azul desde rgb",
    "bitbybit.color.invert": "invertir",
    "invert": "invertir",
    "bitbybit.color.invert_description": "invierte color",
    "blackAndWhite": "blanco y negro",
    "bitbybit.text.create": "crear",
    "bitbybit.text.create_description": "crea texto",
    "bitbybit.text.split": "dividir",
    "bitbybit.text.split_description": "divide texto por separador",
    "separator": "separador",
    "bitbybit.text.replaceAll": "reemplazar todo",
    "replaceAll": "reemplazar todo",
    "bitbybit.text.replaceAll_description": "reemplaza todas ocurrencias texto",
    "search": "buscar",
    "replaceWith": "reemplazar con",
    "bitbybit.text.join": "unir",
    "join": "unir",
    "bitbybit.text.join_description": "une elementos en texto con separador",
    "string[]": "array cadena",
    "bitbybit.text.toString": "a cadena",
    "toString": "a cadena",
    "bitbybit.text.toString_description": "convierte elemento a texto",
    "bitbybit.text.toStringEach": "a cadena cada",
    "toStringEach": "a cadena cada",
    "bitbybit.text.toStringEach_description": "convierte cada elemento lista a texto",
    "bitbybit.text.format": "formato",
    "format": "formato",
    "bitbybit.text.format_description": "formatea texto con valores",
    "values": "valores",
    "bitbybit.text.vectorChar": "carácter vectorial",
    "vectorChar": "carácter vectorial",
    "bitbybit.text.vectorChar_description": "Crea segmentos vectoriales para un carácter e incluye información de anchura y altura.",
    "char": "carácter",
    "bitbybit.text.vectorText": "texto vectorial",
    "vectorText": "texto vectorial",
    "bitbybit.text.vectorText_description": "Crea líneas de texto vectoriales para un texto dado e incluye información de anchura y altura.",
    "bitbybit.dates.toDateString": "a cadena de fecha",
    "dates": "fechas",
    "toDateString": "a cadena de fecha",
    "bitbybit.dates.toDateString_description": "Devuelve una fecha como un valor de cadena.",
    "date": "fecha",
    "Date": "fecha",
    "bitbybit.dates.toISOString": "a cadena ISO",
    "toISOString": "a cadena ISO",
    "bitbybit.dates.toISOString_description": "Devuelve una fecha como un valor de cadena en formato ISO.",
    "bitbybit.dates.toJSON": "a JSON",
    "toJSON": "a JSON",
    "bitbybit.dates.toJSON_description": "Devuelve una fecha como un valor de cadena en formato JSON.",
    "bitbybit.dates.toString": "a cadena",
    "bitbybit.dates.toString_description": "Devuelve una representación de cadena de una fecha. El formato de la cadena depende de la configuración regional.",
    "bitbybit.dates.toTimeString": "a cadena de hora",
    "toTimeString": "a cadena de hora",
    "bitbybit.dates.toTimeString_description": "Devuelve una hora como un valor de cadena.",
    "bitbybit.dates.toUTCString": "a cadena UTC",
    "toUTCString": "a cadena UTC",
    "bitbybit.dates.toUTCString_description": "Devuelve una fecha convertida a cadena usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.now": "ahora",
    "now": "ahora",
    "bitbybit.dates.now_description": "Devuelve la fecha y hora actuales.",
    "bitbybit.dates.createDate": "crear fecha",
    "createDate": "crear fecha",
    "bitbybit.dates.createDate_description": "Crea un nuevo objeto de fecha utilizando los parámetros de fecha proporcionados.",
    "year": "año",
    "month": "mes",
    "day": "día",
    "hours": "horas",
    "minutes": "minutos",
    "seconds": "segundos",
    "milliseconds": "milisegundos",
    "bitbybit.dates.createDateUTC": "crear fecha UTC",
    "createDateUTC": "crear fecha UTC",
    "bitbybit.dates.createDateUTC_description": "Devuelve el número de milisegundos entre la medianoche del 1 de enero de 1970, Tiempo Universal Coordinado (UTC) (o GMT) y la fecha especificada.",
    "bitbybit.dates.createFromUnixTimeStamp": "crear desde marca de tiempo unix",
    "createFromUnixTimeStamp": "crear desde marca de tiempo unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Crea un nuevo objeto de fecha utilizando la marca de tiempo unix proporcionada.",
    "unixTimeStamp": "marca de tiempo unix",
    "bitbybit.dates.parseDate": "analizar fecha",
    "parseDate": "analizar fecha",
    "bitbybit.dates.parseDate_description": "Analiza una cadena que contiene una fecha y devuelve el número de milisegundos entre esa fecha y la medianoche del 1 de enero de 1970.",
    "parse": "analizar",
    "dateString": "cadena de fecha",
    "bitbybit.dates.getDayOfMonth": "obtener día del mes",
    "getDayOfMonth": "obtener día del mes",
    "bitbybit.dates.getDayOfMonth_description": "Obtiene el día del mes, usando la hora local.",
    "bitbybit.dates.getWeekday": "obtener día de la semana",
    "getWeekday": "obtener día de la semana",
    "bitbybit.dates.getWeekday_description": "Obtiene el día de la semana, usando la hora local.",
    "bitbybit.dates.getYear": "obtener año",
    "getYear": "obtener año",
    "bitbybit.dates.getYear_description": "Obtiene el año, usando la hora local.",
    "bitbybit.dates.getMonth": "obtener mes",
    "getMonth": "obtener mes",
    "bitbybit.dates.getMonth_description": "Obtiene el mes, usando la hora local.",
    "bitbybit.dates.getHours": "obtener horas",
    "getHours": "obtener horas",
    "bitbybit.dates.getHours_description": "Obtiene las horas en una fecha, usando la hora local.",
    "bitbybit.dates.getMinutes": "obtener minutos",
    "getMinutes": "obtener minutos",
    "bitbybit.dates.getMinutes_description": "Obtiene los minutos de un objeto Date, usando la hora local.",
    "bitbybit.dates.getSeconds": "obtener segundos",
    "getSeconds": "obtener segundos",
    "bitbybit.dates.getSeconds_description": "Obtiene los segundos de un objeto Date, usando la hora local.",
    "bitbybit.dates.getMilliseconds": "obtener milisegundos",
    "getMilliseconds": "obtener milisegundos",
    "bitbybit.dates.getMilliseconds_description": "Obtiene los milisegundos de un objeto Date, usando la hora local.",
    "bitbybit.dates.getTime": "obtener tiempo",
    "getTime": "obtener tiempo",
    "bitbybit.dates.getTime_description": "Devuelve el valor de tiempo almacenado en milisegundos desde la medianoche del 1 de enero de 1970 UTC.",
    "bitbybit.dates.getUTCYear": "obtener año UTC",
    "getUTCYear": "obtener año UTC",
    "bitbybit.dates.getUTCYear_description": "Obtiene el año usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.getUTCMonth": "obtener mes UTC",
    "getUTCMonth": "obtener mes UTC",
    "bitbybit.dates.getUTCMonth_description": "Obtiene el mes de un objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.getUTCDay": "obtener día UTC",
    "getUTCDay": "obtener día UTC",
    "bitbybit.dates.getUTCDay_description": "Obtiene el día del mes, usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.getUTCHours": "obtener horas UTC",
    "getUTCHours": "obtener horas UTC",
    "bitbybit.dates.getUTCHours_description": "Obtiene el valor de las horas en un objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.getUTCMinutes": "obtener minutos UTC",
    "getUTCMinutes": "obtener minutos UTC",
    "bitbybit.dates.getUTCMinutes_description": "Obtiene los minutos de un objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.getUTCSeconds": "obtener segundos UTC",
    "getUTCSeconds": "obtener segundos UTC",
    "bitbybit.dates.getUTCSeconds_description": "Obtiene los segundos de un objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.getUTCMilliseconds": "obtener milisegundos UTC",
    "getUTCMilliseconds": "obtener milisegundos UTC",
    "bitbybit.dates.getUTCMilliseconds_description": "Obtiene los milisegundos de un objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setYear": "establecer año",
    "setYear": "establecer año",
    "bitbybit.dates.setYear_description": "Establece el año del objeto Date usando la hora local.",
    "bitbybit.dates.setMonth": "establecer mes",
    "setMonth": "establecer mes",
    "bitbybit.dates.setMonth_description": "Establece el valor del mes en el objeto Date usando la hora local.",
    "bitbybit.dates.setDayOfMonth": "establecer día del mes",
    "setDayOfMonth": "establecer día del mes",
    "bitbybit.dates.setDayOfMonth_description": "Establece el valor numérico del día del mes del objeto Date usando la hora local.",
    "bitbybit.dates.setHours": "establecer horas",
    "setHours": "establecer horas",
    "bitbybit.dates.setHours_description": "Establece el valor de la hora en el objeto Date usando la hora local.",
    "bitbybit.dates.setMinutes": "establecer minutos",
    "setMinutes": "establecer minutos",
    "bitbybit.dates.setMinutes_description": "Establece el valor de los minutos en el objeto Date usando la hora local.",
    "bitbybit.dates.setSeconds": "establecer segundos",
    "setSeconds": "establecer segundos",
    "bitbybit.dates.setSeconds_description": "Establece el valor de los segundos en el objeto Date usando la hora local.",
    "bitbybit.dates.setMilliseconds": "establecer milisegundos",
    "setMilliseconds": "establecer milisegundos",
    "bitbybit.dates.setMilliseconds_description": "Establece el valor de los milisegundos en el objeto Date usando la hora local.",
    "bitbybit.dates.setTime": "establecer tiempo",
    "setTime": "establecer tiempo",
    "bitbybit.dates.setTime_description": "Establece el valor de fecha y hora en el objeto Date.",
    "time": "tiempo",
    "bitbybit.dates.setUTCYear": "establecer año UTC",
    "setUTCYear": "establecer año UTC",
    "bitbybit.dates.setUTCYear_description": "Establece el valor del año en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCMonth": "establecer mes UTC",
    "setUTCMonth": "establecer mes UTC",
    "bitbybit.dates.setUTCMonth_description": "Establece el valor del mes en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCDay": "establecer día UTC",
    "setUTCDay": "establecer día UTC",
    "bitbybit.dates.setUTCDay_description": "Establece el día numérico del mes en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCHours": "establecer horas UTC",
    "setUTCHours": "establecer horas UTC",
    "bitbybit.dates.setUTCHours_description": "Establece el valor de las horas en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCMinutes": "establecer minutos UTC",
    "setUTCMinutes": "establecer minutos UTC",
    "bitbybit.dates.setUTCMinutes_description": "Establece el valor de los minutos en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCSeconds": "establecer segundos UTC",
    "setUTCSeconds": "establecer segundos UTC",
    "bitbybit.dates.setUTCSeconds_description": "Establece el valor de los segundos en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "establecer milisegundos UTC",
    "setUTCMilliseconds": "establecer milisegundos UTC",
    "bitbybit.dates.setUTCMilliseconds_description": "Establece el valor de los milisegundos en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.json.stringify": "convertir a cadena",
    "json": "json",
    "stringify": "convertir a cadena",
    "bitbybit.json.stringify_description": "convierte valor entrada a cadena",
    "bitbybit.json.parse": "analizar",
    "bitbybit.json.parse_description": "analiza valor entrada",
    "bitbybit.json.query": "consulta",
    "query": "consulta",
    "bitbybit.json.query_description": "consulta valor entrada",
    "jsonpath": "jsonpath",
    "bitbybit.json.setValueOnProp": "establecer valor en prop",
    "setValueOnProp": "establecer valor en prop",
    "bitbybit.json.setValueOnProp_description": "establece valor en propiedad json",
    "props": "props",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "obtener json de array por primera coincidencia prop",
    "getJsonFromArrayByFirstPropMatch": "obtener json de array por primera coincidencia prop",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "obtiene json de array por primera coincidencia propiedad",
    "jsonArray": "array json",
    "any[]": "array cualquier",
    "match": "coincidencia",
    "bitbybit.json.getValueOnProp": "obtener valor en prop",
    "getValueOnProp": "obtener valor en prop",
    "bitbybit.json.getValueOnProp_description": "obtiene valor de propiedad en json",
    "bitbybit.json.setValue": "establecer valor",
    "bitbybit.json.setValue_description": "establece valor a json por ruta",
    "prop": "prop",
    "bitbybit.json.setValuesOnPaths": "establecer valores en rutas",
    "setValuesOnPaths": "establecer valores en rutas",
    "bitbybit.json.setValuesOnPaths_description": "establece múltiples valores a json por rutas",
    "paths": "rutas",
    "bitbybit.json.paths": "rutas",
    "bitbybit.json.paths_description": "encuentra rutas a elementos en objeto",
    "bitbybit.json.createEmpty": "vacío",
    "bitbybit.json.createEmpty_description": "crea objeto javascript vacío",
    "bitbybit.json.previewAndSaveJson": "previsualizar y guardar json",
    "previewAndSaveJson": "previsualizar y guardar json",
    "bitbybit.json.previewAndSaveJson_description": "previsualiza json y ofrece opción guardar",
    "preview": "previsualizar",
    "bitbybit.json.previewJson": "previsualizar json",
    "previewJson": "previsualizar json",
    "bitbybit.json.previewJson_description": "previsualiza json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "curva por nudos puntos control pesos",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "curva por nudos puntos control pesos",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "crea curva nurbs con nudos puntos control pesos",
    "degree": "grado",
    "knots": "nudos",
    "bitbybit.verb.curve.createCurveByPoints": "curva por puntos",
    "createCurveByPoints": "curva por puntos",
    "bitbybit.verb.curve.createCurveByPoints_description": "crea curva nurbs con puntos control",
    "bitbybit.verb.curve.createBezierCurve": "curva bezier",
    "createBezierCurve": "curva bezier",
    "bitbybit.verb.curve.createBezierCurve_description": "crea curva nurbs bezier con puntos control y pesos",
    "bitbybit.verb.curve.clone": "clonar",
    "bitbybit.verb.curve.clone_description": "clona curva nurbs",
    "bitbybit.verb.curve.closestParam": "param más cercano",
    "closestParam": "param más cercano",
    "bitbybit.verb.curve.closestParam_description": "encuentra param más cercano en curva nurbs desde punto",
    "bitbybit.verb.curve.closestParams": "params más cercanos",
    "closestParams": "params más cercanos",
    "bitbybit.verb.curve.closestParams_description": "encuentra params más cercanos en curva nurbs desde puntos",
    "bitbybit.verb.curve.closestPoint": "punto más cercano",
    "closestPoint": "punto más cercano",
    "bitbybit.verb.curve.closestPoint_description": "encuentra punto más cercano en curva nurbs desde punto",
    "bitbybit.verb.curve.closestPoints": "puntos más cercanos",
    "closestPoints": "puntos más cercanos",
    "bitbybit.verb.curve.closestPoints_description": "encuentra puntos más cercanos en curva nurbs desde puntos",
    "bitbybit.verb.curve.controlPoints": "puntos control",
    "controlPoints": "puntos control",
    "bitbybit.verb.curve.controlPoints_description": "encuentra puntos control de curva nurbs",
    "bitbybit.verb.curve.degree": "grado",
    "bitbybit.verb.curve.degree_description": "encuentra grado de curva nurbs",
    "bitbybit.verb.curve.derivatives": "derivadas",
    "derivatives": "derivadas",
    "bitbybit.verb.curve.derivatives_description": "encuentra derivadas de curva nurbs en parámetro",
    "numDerivatives": "núm derivadas",
    "parameter": "parámetro",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "dividir por longitud arco igual a params",
    "divideByEqualArcLengthToParams": "dividir por longitud arco igual a params",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "divide curva por longitud arco igual a params",
    "subdivision": "subdivisión",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "dividir por longitud arco igual a puntos",
    "divideByEqualArcLengthToPoints": "dividir por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "divide curva por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideByArcLengthToParams": "dividir por longitud arco a params",
    "divideByArcLengthToParams": "dividir por longitud arco a params",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "divide curva por longitud arco a params",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "dividir por longitud arco a puntos",
    "divideByArcLengthToPoints": "dividir por longitud arco a puntos",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "divide curva por longitud arco a puntos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "dividir curvas por longitud arco igual a puntos",
    "divideCurvesByEqualArcLengthToPoints": "dividir curvas por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divide múltiples curvas por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "dividir curvas por longitud arco a puntos",
    "divideCurvesByArcLengthToPoints": "dividir curvas por longitud arco a puntos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divide múltiples curvas por longitud arco a puntos",
    "bitbybit.verb.curve.domain": "dominio",
    "bitbybit.verb.curve.domain_description": "encuentra intervalo dominio de params curva",
    "bitbybit.verb.curve.startPoint": "punto inicio",
    "bitbybit.verb.curve.startPoint_description": "punto inicio de curva",
    "bitbybit.verb.curve.endPoint": "punto fin",
    "bitbybit.verb.curve.endPoint_description": "punto fin de curva",
    "bitbybit.verb.curve.startPoints": "puntos inicio",
    "bitbybit.verb.curve.startPoints_description": "puntos inicio de curvas",
    "bitbybit.verb.curve.endPoints": "puntos fin",
    "bitbybit.verb.curve.endPoints_description": "puntos fin de curvas",
    "bitbybit.verb.curve.knots": "nudos",
    "bitbybit.verb.curve.knots_description": "encuentra nudos de curva nurbs",
    "bitbybit.verb.curve.lengthAtParam": "longitud en param",
    "lengthAtParam": "longitud en param",
    "bitbybit.verb.curve.lengthAtParam_description": "obtiene longitud de curva nurbs en param",
    "bitbybit.verb.curve.length": "longitud",
    "bitbybit.verb.curve.length_description": "obtiene longitud de curva nurbs",
    "bitbybit.verb.curve.paramAtLength": "param en longitud",
    "paramAtLength": "param en longitud",
    "bitbybit.verb.curve.paramAtLength_description": "obtiene param en longitud en curva nurbs",
    "bitbybit.verb.curve.pointAtParam": "punto en param",
    "pointAtParam": "punto en param",
    "bitbybit.verb.curve.pointAtParam_description": "obtiene punto en param en curva nurbs",
    "bitbybit.verb.curve.pointsAtParam": "puntos en param",
    "pointsAtParam": "puntos en param",
    "bitbybit.verb.curve.pointsAtParam_description": "obtiene puntos en param en curvas nurbs",
    "bitbybit.verb.curve.reverse": "invertir",
    "bitbybit.verb.curve.reverse_description": "invierte curva nurbs",
    "bitbybit.verb.curve.split": "dividir",
    "bitbybit.verb.curve.split_description": "divide curva nurbs en param",
    "bitbybit.verb.curve.tangent": "tangente",
    "bitbybit.verb.curve.tangent_description": "tangente de curva nurbs en param",
    "bitbybit.verb.curve.tessellate": "teselar",
    "tessellate": "teselar",
    "bitbybit.verb.curve.tessellate_description": "tesela curva nurbs en puntos",
    "bitbybit.verb.curve.transform": "transformar",
    "bitbybit.verb.curve.transform_description": "transforma curva nurbs",
    "bitbybit.verb.curve.transformCurves": "transformar curvas",
    "transformCurves": "transformar curvas",
    "bitbybit.verb.curve.transformCurves_description": "transforma curvas nurbs",
    "bitbybit.verb.curve.weights": "pesos",
    "bitbybit.verb.curve.weights_description": "pesos de curva nurbs",
    "bitbybit.verb.curve.circle.createCircle": "círculo",
    "createCircle": "círculo",
    "bitbybit.verb.curve.circle.createCircle_description": "crea curva nurbs circular",
    "xAxis": "eje x",
    "yAxis": "eje y",
    "bitbybit.verb.curve.circle.createArc": "arco",
    "createArc": "arco",
    "bitbybit.verb.curve.circle.createArc_description": "crea curva nurbs de arco",
    "minAngle": "ángulo mín",
    "maxAngle": "ángulo máx",
    "bitbybit.verb.curve.circle.center": "centro",
    "bitbybit.verb.curve.circle.center_description": "obtiene centro de círculo o arco",
    "bitbybit.verb.curve.circle.radius": "radio",
    "bitbybit.verb.curve.circle.radius_description": "obtiene radio de círculo o arco",
    "bitbybit.verb.curve.circle.maxAngle": "ángulo máx",
    "bitbybit.verb.curve.circle.maxAngle_description": "obtiene ángulo máx de arco en grados",
    "bitbybit.verb.curve.circle.minAngle": "ángulo mín",
    "bitbybit.verb.curve.circle.minAngle_description": "obtiene ángulo mín de arco en grados",
    "bitbybit.verb.curve.circle.xAxis": "eje x",
    "bitbybit.verb.curve.circle.xAxis_description": "obtiene eje x de arco",
    "bitbybit.verb.curve.circle.yAxis": "eje y",
    "bitbybit.verb.curve.circle.yAxis_description": "obtiene eje y de arco",
    "bitbybit.verb.curve.ellipse.createEllipse": "elipse",
    "createEllipse": "elipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "crea curva nurbs elíptica",
    "bitbybit.verb.curve.ellipse.createArc": "arco",
    "bitbybit.verb.curve.ellipse.createArc_description": "crea curva nurbs de arco elíptico",
    "bitbybit.verb.curve.ellipse.center": "centro",
    "bitbybit.verb.curve.ellipse.center_description": "obtiene centro de elipse o arco",
    "bitbybit.verb.curve.ellipse.maxAngle": "ángulo máx",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "obtiene ángulo máx de arco en grados",
    "bitbybit.verb.curve.ellipse.minAngle": "ángulo mín",
    "bitbybit.verb.curve.ellipse.minAngle_description": "obtiene ángulo mín de arco en grados",
    "bitbybit.verb.curve.ellipse.xAxis": "eje x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "obtiene eje x de arco o elipse",
    "bitbybit.verb.curve.ellipse.yAxis": "eje y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "obtiene eje y de arco o elipse",
    "bitbybit.verb.surface.boundaries": "límites",
    "boundaries": "límites",
    "bitbybit.verb.surface.boundaries_description": "obtiene curvas nurbs de arista límite de superficie",
    "bitbybit.verb.surface.createSurfaceByCorners": "superficie por esquinas",
    "createSurfaceByCorners": "superficie por esquinas",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "crea superficie con 4 puntos de esquina",
    "point3": "punto 3",
    "point4": "punto 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "superficie por nudos puntos control pesos",
    "createSurfaceByKnotsControlPointsWeights": "superficie por nudos puntos control pesos",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "crea superficie nurbs con nudos uv grados puntos pesos",
    "degreeU": "grado u",
    "degreeV": "grado v",
    "knotsU": "nudos u",
    "knotsV": "nudos v",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "superficie por loft curvas",
    "createSurfaceByLoftingCurves": "superficie por loft curvas",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "crea superficie nurbs por loft curvas",
    "bitbybit.verb.surface.clone": "clonar",
    "bitbybit.verb.surface.clone_description": "clona superficie nurbs",
    "bitbybit.verb.surface.closestParam": "param más cercano",
    "bitbybit.verb.surface.closestParam_description": "encuentra param más cercano en superficie desde punto",
    "bitbybit.verb.surface.closestPoint": "punto más cercano",
    "bitbybit.verb.surface.closestPoint_description": "encuentra punto más cercano en superficie desde punto",
    "bitbybit.verb.surface.controlPoints": "puntos control",
    "bitbybit.verb.surface.controlPoints_description": "obtiene puntos control en superficie",
    "bitbybit.verb.surface.degreeU": "grado u",
    "bitbybit.verb.surface.degreeU_description": "obtiene grado u de superficie",
    "bitbybit.verb.surface.degreeV": "grado v",
    "bitbybit.verb.surface.degreeV_description": "obtiene grado v de superficie",
    "bitbybit.verb.surface.derivatives": "derivadas",
    "bitbybit.verb.surface.derivatives_description": "obtiene derivadas de superficie en uv",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "dominio u",
    "domainU": "dominio u",
    "bitbybit.verb.surface.domainU_description": "obtiene dominio u de superficie",
    "bitbybit.verb.surface.domainV": "dominio v",
    "domainV": "dominio v",
    "bitbybit.verb.surface.domainV_description": "obtiene dominio v de superficie",
    "bitbybit.verb.surface.isocurve": "isocurva",
    "isocurve": "isocurva",
    "bitbybit.verb.surface.isocurve_description": "obtiene isocurva nurbs en superficie",
    "useV": "usar v",
    "bitbybit.verb.surface.isocurvesSubdivision": "subdivisión isocurvas",
    "isocurvesSubdivision": "subdivisión isocurvas",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "subdivide superficie en isocurvas",
    "isocurveSegments": "segmentos isocurva",
    "bitbybit.verb.surface.isocurvesAtParams": "isocurvas en params",
    "isocurvesAtParams": "isocurvas en params",
    "bitbybit.verb.surface.isocurvesAtParams_description": "subdivide superficie en isocurvas en params",
    "parameters": "parámetros",
    "bitbybit.verb.surface.knotsU": "nudos u",
    "bitbybit.verb.surface.knotsU_description": "obtiene nudos u de superficie",
    "bitbybit.verb.surface.knotsV": "nudos v",
    "bitbybit.verb.surface.knotsV_description": "obtiene nudos v de superficie",
    "bitbybit.verb.surface.normal": "normal",
    "bitbybit.verb.surface.normal_description": "obtiene normal en superficie en uv",
    "bitbybit.verb.surface.point": "punto",
    "bitbybit.verb.surface.point_description": "obtiene punto en superficie en uv",
    "bitbybit.verb.surface.reverse": "invertir",
    "bitbybit.verb.surface.reverse_description": "invierte uv e isocurvas de superficie nurbs",
    "bitbybit.verb.surface.split": "dividir",
    "bitbybit.verb.surface.split_description": "divide superficie nurbs en dos",
    "bitbybit.verb.surface.transformSurface": "transformar superficie",
    "transformSurface": "transformar superficie",
    "bitbybit.verb.surface.transformSurface_description": "transforma superficie nurbs con transformaciones",
    "bitbybit.verb.surface.weights": "pesos",
    "bitbybit.verb.surface.weights_description": "obtiene pesos de superficie",
    "bitbybit.verb.surface.cone.create": "crear",
    "cone": "cono",
    "bitbybit.verb.surface.cone.create_description": "crea superficie nurbs cónica",
    "bitbybit.verb.surface.cone.axis": "eje",
    "bitbybit.verb.surface.cone.axis_description": "obtiene eje cono",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "obtiene base cono",
    "bitbybit.verb.surface.cone.height": "altura",
    "bitbybit.verb.surface.cone.height_description": "obtiene altura cono",
    "bitbybit.verb.surface.cone.radius": "radio",
    "bitbybit.verb.surface.cone.radius_description": "obtiene radio cono",
    "bitbybit.verb.surface.cone.xAxis": "eje x",
    "bitbybit.verb.surface.cone.xAxis_description": "obtiene eje x cono",
    "bitbybit.verb.surface.cylinder.create": "crear",
    "bitbybit.verb.surface.cylinder.create_description": "crea superficie nurbs cilíndrica",
    "bitbybit.verb.surface.cylinder.axis": "eje",
    "bitbybit.verb.surface.cylinder.axis_description": "obtiene eje cilindro",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "obtiene base cilindro",
    "bitbybit.verb.surface.cylinder.height": "altura",
    "bitbybit.verb.surface.cylinder.height_description": "obtiene altura cilindro",
    "bitbybit.verb.surface.cylinder.radius": "radio",
    "bitbybit.verb.surface.cylinder.radius_description": "obtiene radio cilindro",
    "bitbybit.verb.surface.cylinder.xAxis": "eje x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "obtiene eje x cilindro",
    "bitbybit.verb.surface.extrusion.create": "crear",
    "extrusion": "extrusión",
    "bitbybit.verb.surface.extrusion.create_description": "crea extrusión superficie nurbs desde curva",
    "profile": "perfil",
    "bitbybit.verb.surface.extrusion.direction": "dirección",
    "bitbybit.verb.surface.extrusion.direction_description": "obtiene vector dirección de extrusión",
    "bitbybit.verb.surface.extrusion.profile": "perfil",
    "bitbybit.verb.surface.extrusion.profile_description": "obtiene curva nurbs perfil de extrusión",
    "bitbybit.verb.surface.sphere.create": "crear",
    "bitbybit.verb.surface.sphere.create_description": "crea superficie nurbs esférica",
    "bitbybit.verb.surface.sphere.radius": "radio",
    "bitbybit.verb.surface.sphere.radius_description": "obtiene radio de superficie nurbs esférica",
    "bitbybit.verb.surface.sphere.center": "centro",
    "bitbybit.verb.surface.sphere.center_description": "obtiene centro de superficie nurbs esférica",
    "bitbybit.verb.surface.revolved.create": "crear",
    "revolved": "revolucionado",
    "bitbybit.verb.surface.revolved.create_description": "crea superficie nurbs revolucionada",
    "bitbybit.verb.surface.revolved.profile": "perfil",
    "bitbybit.verb.surface.revolved.profile_description": "obtiene curva nurbs perfil de superficie revolucionada",
    "revolution": "revolución",
    "bitbybit.verb.surface.revolved.center": "centro",
    "bitbybit.verb.surface.revolved.center_description": "obtiene curva nurbs centro de superficie revolucionada",
    "bitbybit.verb.surface.revolved.axis": "eje",
    "bitbybit.verb.surface.revolved.axis_description": "obtiene eje rotación de superficie revolucionada",
    "bitbybit.verb.surface.revolved.angle": "ángulo",
    "bitbybit.verb.surface.revolved.angle_description": "obtiene ángulo de rotación de superficie revolucionada",
    "bitbybit.verb.surface.sweep.create": "crear",
    "sweep": "barrido",
    "bitbybit.verb.surface.sweep.create_description": "crea superficie nurbs de barrido",
    "rail": "raíl",
    "bitbybit.verb.surface.sweep.profile": "perfil",
    "bitbybit.verb.surface.sweep.profile_description": "obtiene curva nurbs perfil de superficie barrida",
    "bitbybit.verb.surface.sweep.rail": "raíl",
    "bitbybit.verb.surface.sweep.rail_description": "obtiene curva nurbs raíl de superficie barrida",
    "bitbybit.verb.intersect.curves": "curvas",
    "bitbybit.verb.intersect.curves_description": "interseca dos curvas nurbs verb",
    "firstCurve": "primera curva",
    "secondCurve": "segunda curva",
    "bitbybit.verb.intersect.curveAndSurface": "curva y superficie",
    "curveAndSurface": "curva y superficie",
    "bitbybit.verb.intersect.curveAndSurface_description": "interseca curva y superficie",
    "bitbybit.verb.intersect.surfaces": "superficies",
    "bitbybit.verb.intersect.surfaces_description": "interseca dos superficies",
    "firstSurface": "primera superficie",
    "secondSurface": "segunda superficie",
    "bitbybit.verb.intersect.curveCurveFirstParams": "curva curva primeros params",
    "curveCurveFirstParams": "curva curva primeros params",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "obtiene params intersección en primera curva",
    "intersections": "intersecciones",
    "BaseTypes.CurveCurveIntersection[]": "array intersección curva curva tipos base",
    "bitbybit.verb.intersect.curveCurveSecondParams": "curva curva segundos params",
    "curveCurveSecondParams": "curva curva segundos params",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "obtiene params intersección en segunda curva",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "curva curva primeros puntos",
    "curveCurveFirstPoints": "curva curva primeros puntos",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "obtiene puntos intersección en primera curva",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "curva curva segundos puntos",
    "curveCurveSecondPoints": "curva curva segundos puntos",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "obtiene puntos intersección en segunda curva",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "curva superficie curva params",
    "curveSurfaceCurveParams": "curva superficie curva params",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "obtiene params intersección en curva",
    "BaseTypes.CurveSurfaceIntersection[]": "array intersección curva superficie tipos base",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "curva superficie superficie params",
    "curveSurfaceSurfaceParams": "curva superficie superficie params",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "obtiene params intersección en superficie",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "curva superficie curva puntos",
    "curveSurfaceCurvePoints": "curva superficie curva puntos",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "obtiene puntos intersección en curva",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "curva superficie superficie puntos",
    "curveSurfaceSurfacePoints": "curva superficie superficie puntos",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "obtiene puntos intersección en superficie",
    "bitbybit.tag.create": "crear",
    "tag": "etiqueta",
    "bitbybit.tag.create_description": "crea dto etiqueta",
    "adaptDepth": "adaptar profundidad",
    "needsUpdate": "necesita actualizar",
    "bitbybit.time.registerRenderFunction": "registrar función renderizado",
    "registerRenderFunction": "registrar función renderizado",
    "bitbybit.time.registerRenderFunction_description": "registra función en bucle renderizado",
    "bitbybit.asset.getFile": "obtener archivo",
    "asset": "activo",
    "getFile": "obtener archivo",
    "bitbybit.asset.getFile_description": "obtiene archivo activo",
    "bitbybit.asset.getLocalFile": "obtener archivo local",
    "getLocalFile": "obtener archivo local",
    "bitbybit.asset.getLocalFile_description": "obtiene archivo activo local desde navegador",
    "bitbybit.asset.fetchBlob": "obtener blob",
    "fetchBlob": "obtener blob",
    "bitbybit.asset.fetchBlob_description": "obtiene blob desde url cors",
    "fetch": "obtener",
    "bitbybit.asset.fetchFile": "obtener archivo",
    "fetchFile": "obtener archivo",
    "bitbybit.asset.fetchFile_description": "obtiene archivo desde url cors",
    "bitbybit.asset.fetchJSON": "obtener json",
    "fetchJSON": "obtener json",
    "bitbybit.asset.fetchJSON_description": "obtiene json desde url cors",
    "bitbybit.asset.fetchText": "obtener texto",
    "fetchText": "obtener texto",
    "bitbybit.asset.fetchText_description": "obtiene texto desde url cors",
    "bitbybit.asset.createObjectURL": "url objeto",
    "createObjectURL": "url objeto",
    "bitbybit.asset.createObjectURL_description": "crea url a archivo en memoria",
    "file": "archivo",
    "File | Blob": "archivo o blob",
    "bitbybit.asset.createObjectURLs": "urls objeto",
    "createObjectURLs": "urls objeto",
    "bitbybit.asset.createObjectURLs_description": "crea urls a archivos en memoria",
    "files": "archivos",
    "(File | Blob)[]": "array archivo o blob",
    "exec": "ejec",
    "Visible": "Visible",
    "Hidden": "Oculto",
    "flatten": "aplanar",
    "force exec": "forzar ejec",
    "console log": "log consola",
    "preview data": "vista previa datos",
    "flow": "flujo",
    "code": "código",
    "runner": "ejecutor",
    "counters": "contadores",
    "actions": "acciones",
    "loops": "bucles",
    "interval": "intervalo",
    "delay": "retraso",
    "expire": "expirar",
    "timeout": "tiempo espera",
    "counter min max": "contador mín máx",
    "counter steps": "contador pasos",
    "reset": "reiniciar",
    "trigger": "disparador",
    "mouse": "ratón",
    "mouse click": "clic ratón",
    "key": "tecla",
    "pointer": "puntero",
    "pick info": "info selección",
    "down": "abajo",
    "wheel": "rueda",
    "tap": "toque",
    "double tap": "doble toque",
    "render": "renderizar",
    "passed ms": "ms pasados",
    "babylon observable listener": "escuchador observable babylon",
    "object": "objeto",
    "observable selector": "selector observable",
    "get event data": "obtener datos evento",
    "exec click": "ejec clic",
    "exec down": "ejec abajo",
    "toggle": "alternar",
    "flip flop": "flip flop",
    "boolean gate": "puerta booleana",
    "boolean gate silent": "puerta booleana silenciosa",
    "is undefined": "es indefinido",
    "for loop": "bucle for",
    "last": "último",
    "for each loop": "bucle for each",
    "element": "elemento",
    "body": "cuerpo",
    "complete": "completo",
    "editors": "editores",
    "inputs": "entradas",
    "outputs": "salidas",
    "recent": "reciente",
    "Clear": "Limpiar",
    "Run": "Ejecutar",
    "Swap Canvas": "Cambiar Lienzo",
    "Local Assets": "Activos Locales",
    "Import": "Importar",
    "Copy to Clipboard": "Copiar al Portapapeles",
    "Paste from Clipboard": "Pegar del Portapapeles",
    "Export": "Exportar",
    "Export to runner": "Exportar a ejecutor",
    "Clean Cache": "Limpiar Caché",
    "Community": "Comunidad",
    "Sponsors and Partners": "Patrocinadores y Socios",
    "API Documentation": "Documentación API",
    "About": "Acerca de",
    "Toolbox": "Caja de Herramientas",
    "More": "Más",
    "bitbybit.code.typeScriptEditor": "editor typescript",
    "bitbybit.code.typeScriptEditor_description": "Permite escribir código TypeScript con intellisense completo de bitbybit en una función. Lo que retorne la función start se verá como salida del componente.",
    "bitbybit.code.javaScriptEditor": "editor javascript",
    "bitbybit.code.javaScriptEditor_description": "Permite escribir código JavaScript en una función. Lo que retorne la función start se verá como salida del componente.",
    "bitbybit.code.jsonEditor": "editor json",
    "bitbybit.code.jsonEditor_description": "Permite escribir código JSON. Lo que retorne la función start se verá como salida del componente.",
    "bitbybit.flow.actions.keyboard": "teclado",
    "bitbybit.flow.actions.keyboard_description": "Se ejecutará en eventos de teclado al hacer clic en los botones.",
    "bitbybit.flow.actions.mouseClick": "clic ratón",
    "bitbybit.flow.actions.mouseClick_description": "Se ejecutará en eventos de ratón al hacer clic en los botones.",
    "bitbybit.flow.actions.start": "inicio",
    "bitbybit.flow.actions.start_description": "Inicia el flujo de control y dispara ejecuciones.",
    "bitbybit.flow.actions.trigger": "disparador",
    "bitbybit.flow.actions.trigger_description": "Dispara la ejecución al hacer clic en el botón.",
    "bitbybit.flow.babylon.gui.button": "botón",
    "bitbybit.flow.babylon.gui.button_description": "Se ejecutará en varios eventos de puntero al hacer clic con el botón izquierdo del ratón en el lienzo babylonjs.",
    "bitbybit.flow.babylon.scene.pointerEvents": "puntero",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Se ejecutará en varios eventos de puntero al hacer clic con el botón izquierdo del ratón en el lienzo babylonjs.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "obtener datos evento",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Obtiene datos de evento del resultado observado del escuchador observable.",
    "bitbybit.flow.babylon.observableListener": "escuchador observable babylon",
    "bitbybit.flow.babylon.observableListener_description": "Se suscribirá y escuchará a cualquiera de los observables babylonjs.",
    "bitbybit.flow.babylon.render": "renderizar",
    "bitbybit.flow.babylon.render_description": "Se ejecuta en cada fotograma de renderizado babylonjs.",
    "bitbybit.flow.counters.counterMinMax": "contador mín máx",
    "bitbybit.flow.counters.counterMinMax_description": "Cuenta el número de ejecuciones de flujo entre valores mín y máx. Cuando se alcanza máx, se reinicia",
    "bitbybit.flow.counters.counterSteps": "contador pasos",
    "bitbybit.flow.counters.counterSteps_description": "Cuenta el número de ejecuciones de flujo comenzando en valor dado y aumentando en cada ejecución por paso dado de la lista, hasta que terminen los pasos. Cuando se alcanza el final, se reinicia",
    "bitbybit.flow.counters.counter": "contador",
    "bitbybit.flow.counters.counter_description": "Cuenta el número de ejecuciones de flujo.",
    "bitbybit.flow.logic.booleanGateSilent": "puerta booleana silenciosa",
    "bitbybit.flow.logic.booleanGateSilent_description": "Dispara diferentes eventos de ejecución según el valor booleano proporcionado, pero se ejecuta solo cuando el booleano cambia su valor, esto evita que se disparen múltiples eventos constantemente aunque no haya habido cambios.",
    "bitbybit.flow.logic.booleanGate": "puerta booleana",
    "bitbybit.flow.logic.booleanGate_description": "Dispara diferentes eventos de ejecución según el valor booleano proporcionado.",
    "bitbybit.flow.logic.flipFlop": "flip flop",
    "bitbybit.flow.logic.flipFlop_description": "Cada vez que se ejecuta un evento, se disparará un evento diferente, creando esencialmente una funcionalidad de alternancia.",
    "bitbybit.flow.logic.isUndefined": "es indefinido",
    "bitbybit.flow.logic.isUndefined_description": "Comprueba si el valor proporcionado es indefinido y dispara evento verdadero o falso.",
    "bitbybit.flow.loops.forEach": "bucle for each",
    "bitbybit.flow.loops.forEach_description": "Bucle for each que recorre todos los elementos de la lista.",
    "bitbybit.flow.loops.for": "bucle for",
    "bitbybit.flow.loops.for_description": "Bucle for que ejecuta cuerpo entre dos valores.",
    "bitbybit.flow.time.delay": "retraso",
    "bitbybit.flow.time.delay_description": "Retrasa ejecución por tiempo espera dado en ms.",
    "bitbybit.flow.time.interval": "intervalo",
    "bitbybit.flow.time.interval_description": "Ejecuta el flujo cada intervalo dado en ms.",
    "bitbybit.lists.createList": "crear lista",
    "bitbybit.lists.createList_description": "Crea una lista a partir de los elementos dados.",
    "bitbybit.lists.flatten": "aplanar",
    "bitbybit.lists.flatten_description": "Aplana la lista de listas en una sola lista.",
    "bitbybit.lists.passThrough": "pasar a través",
    "bitbybit.lists.passThrough_description": "Convierte el valor al tipo 'any' y pasa la entrada a la salida sin cambios.",
    "bitbybit.math.numberSlider": "deslizador número",
    "bitbybit.math.numberSlider_description": "Crea un número con un deslizador. Puede configurar valores mín, máx y paso.",
    "bitbybit.consoleLog": "log consola",
    "bitbybit.consoleLog_description": "Registra la entrada en la consola del navegador.",
    "bitbybit.previewData": "vista previa datos",
    "bitbybit.previewData_description": "Muestra los datos de entrada en un área de vista previa. Pueden ser texto, números, objetos json, arrays, etc. No se permiten objetos Javascript circulares.",
    "bitbybit.runner.getRunnerInputValue": "obtener valor entrada ejecutor",
    "bitbybit.runner.getRunnerInputValue_description": "Obtiene el valor de entrada del ejecutor desde el JSON de entradas. Este componente siempre retornará un valor indefinido en el contexto del editor.",
    "bitbybit.runner.getRunnerInputs": "obtener entradas ejecutor",
    "bitbybit.runner.getRunnerInputs_description": "Obtiene las entradas del ejecutor en JSON. Este componente siempre retornará un objeto vacío en el contexto del editor.",
    "bitbybit.runner.run": "ejecutar",
    "bitbybit.runner.run_description": "Ejecuta código javascript del ejecutor",
    "bitbybit.runner.setRunnerResult": "establecer resultado ejecutor",
    "bitbybit.runner.setRunnerResult_description": "Establece el resultado JSON completo para el ejecutor. Tenga en cuenta que es más seguro establecer valores ya que este método sobrescribirá todo el objeto resultado con el valor proporcionado.",
    "bitbybit.runner.setRunnerResultArrayValue": "establecer valor array resultado ejecutor",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Establece el valor resultado del ejecutor en la propiedad del objeto JSON. Cada valor se añadirá a un array, que es el valor de la propiedad.",
    "bitbybit.runner.setRunnerResultValue": "establecer valor resultado ejecutor",
    "bitbybit.runner.setRunnerResultValue_description": "Establece el valor resultado del ejecutor en la propiedad del objeto JSON.",
    "bitbybit.text.areaCreate": "área texto",
    "bitbybit.text.areaCreate_description": "Crea un área de texto en el editor. Puede configurar el texto, ancho y alto del área.",
    "update on drag": "actualizar al arrastrar",
    "paste": "pegar",
    "duplicate": "duplicar",
    "delete": "eliminar",
    "keyboard": "teclado",
    "data": "datos",
    "observables": "observables",
    "buttons": "botones",
    "variables": "variables",
    "functions": "funciones",
    "loop": "bucle",
    "apply": "aplicar",
    "async context": "contexto asíncrono",
    "async context description": "Crea contexto asíncrono que puede usar componentes await, simplificando la ejecución y legibilidad del código asíncrono.",
    "then": "entonces",
    "await": "esperar",
    "await description": "Espera a que la promesa se resuelva y retorna el valor.",
    "when the": "cuando el",
    "error": "error",
    "happens in the promise": "ocurre en la promesa",
    "catch": "capturar",
    "catch description": "Captura el error que pueda ocurrir al ejecutar código asíncrono. El usuario puede elegir manejar los errores apropiadamente.",
    "cancel the interval execution": "cancelar ejecución intervalo",
    "cancel the interval description": "Cancela la ejecución del intervalo proporcionando el manejador.",
    "cancel the timeout execution": "cancelar ejecución tiempo espera",
    "cancel the timeout description": "Cancela la ejecución del tiempo de espera proporcionando el manejador.",
    "key down": "tecla abajo",
    "key down descritpion": "Dispara código cuando ocurre evento tecla abajo.",
    "key up": "tecla arriba",
    "key up description": "Dispara código cuando ocurre evento tecla arriba.",
    "key press": "pulsación tecla",
    "key press description": "Dispara código cuando ocurre evento pulsación tecla.",
    "is key pressed": "está tecla pulsada",
    "block_validation_required": "debe ser proporcionado",
    "block_validation_of_length": "debe contener recuento de elementos de",
    "block_validation_higher_or_equal": "debe ser mayor o igual a",
    "block_validation_lower_or_equal": "debe ser menor o igual a",
    "block_validation_range": "debe estar en rango",
    "block_validation_smaller_than": "debe ser menor que",
    "block_validation_smaller_or_equal_than": "debe ser menor o igual que",
    "block_validation_larger_than": "debe ser mayor que",
    "block_validation_larger_or_equal_than": "debe ser mayor o igual que",
    "save text to file": "guardar texto en archivo",
    "save text to file description": "Guarda texto en un archivo y permite elegir nombre y extensión. Este componente no previsualiza el texto y puede usarse en situaciones donde el texto sea demasiado grande para editar en área de texto.",
    "print text on screen": "imprimir texto en pantalla",
    "print text on screen description": "Imprime texto en pantalla. Este componente es útil para depuración.",
    "preview text and save to file": "previsualizar texto y guardar en archivo",
    "preview text and save to file description": "Imprime texto en pantalla y permite guardarlo en un archivo. Este componente es útil para depuración.",
    "register render loop listener": "registrar escuchador bucle renderizado",
    "and update": "y actualizar",
    "register render loop listener description": "Ejecuta la declaración en el bucle de renderizado e indica cuánto tiempo ha pasado desde el último fotograma en la variable timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "timeElapsedFromPreviousFrame",
    "computing": "calculando",
    "result": "resultado",
    "of promise is returned": "de la promesa es retornado",
    "on pointer up": "al soltar puntero",
    "on pointer move": "al mover puntero",
    "on pointer down": "al presionar puntero",
    "of babylonjs observable object": "del objeto observable babylonjs",
    "observable name": "nombre observable",
    "is key pressed description": "Comprueba si la tecla está presionada y retorna verdadero o falso.",
    "execute code after": "ejecutar código después de",
    "execute code after description": "Ejecuta el código después del tiempo de espera dado en segundos.",
    "execute code every": "ejecutar código cada",
    "second(s)": "segundo(s)",
    "execute code every description": "Ejecuta el código cada intervalo dado en segundos.",
    "handler": "manejador",
    "workers initialising": "inicializando workers",
    "Assets": "Activos",
    "Local assets stored in browser cache:": "Activos locales almacenados en caché del navegador:",
    "Asset Name": "Nombre Activo",
    "Name is required": "El nombre es requerido",
    "Asset with this name already exists, choose a different one": "Ya existe un activo con este nombre, elija uno diferente",
    "Allowed file formats:": "Formatos de archivo permitidos:",
    "You must select an asset file": "Debe seleccionar un archivo de activo",
    "Upload Local Asset": "Subir Activo Local",
    "File Name": "Nombre Archivo",
    "File Size": "Tamaño Archivo",
    "Your browser does not support indexDB and you can't upload local asset files.": "Su navegador no soporta indexDB y no puede subir archivos de activos locales.",
    "Upload": "Subir",
    "elements": "elementos",
    "bitbybit.vector.vectorsTheSame": "vectores iguales",
    "vectorsTheSame": "vectores iguales",
    "bitbybit.vector.vectorsTheSame_description": "Comprueba si dos vectores son iguales dentro de una tolerancia dada",
    "vec1": "vector 1",
    "vec2": "vector 2",
    "bitbybit.point.boundingBoxOfPoints": "caja delimitadora de puntos",
    "boundingBoxOfPoints": "caja delimitadora de puntos",
    "bitbybit.point.boundingBoxOfPoints_description": "Obtiene una caja delimitadora de los puntos",
    "bitbybit.point.normalFromThreePoints": "normal a partir de tres puntos",
    "normalFromThreePoints": "normal a partir de tres puntos",
    "bitbybit.point.normalFromThreePoints_description": "Crea un vector normal a partir de 3 puntos",
    "reverseNormal": "normal invertida",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "contorno de línea con extensiones",
    "createLineWireWithExtensions": "contorno de línea con extensiones",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Crea un contorno de línea OpenCascade con extensiones",
    "extensionStart": "inicio ext.",
    "extensionEnd": "fin ext.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "punto medio en contorno",
    "midPointOnWire": "punto medio en contorno",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Calcula el punto medio en el contorno en el parámetro 0.5",
    "centerOnOrigin": "centrar en origen",
    "bitbybit.occt.shapes.wire.textWiresWithData": "contornos de texto con datos",
    "textWiresWithData": "contornos de texto con datos",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Crea un compuesto OpenCascade a partir de contornos de texto y devuelve información adicional basada en la fuente simplex creada por el Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "alinear normal y eje",
    "alignNormAndAxis": "alinear normal y eje",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Alinea la forma con la normal y el eje",
    "fromNorm": "desde normal",
    "fromAx": "desde eje",
    "toNorm": "a normal",
    "toAx": "a eje",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "cota de longitud lineal simple",
    "simpleLinearLengthDimension": "cota de longitud lineal simple",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Crea una cota de longitud lineal simple entre dos puntos - unidades de medida",
    "offsetFromPoints": "desplazamiento desde puntos",
    "crossingSize": "tamaño de cruce",
    "labelSuffix": "sufijo de etiqueta",
    "labelSize": "tamaño de etiqueta",
    "labelOffset": "desplazamiento de etiqueta",
    "bitbybit.occt.dimensions.simpleAngularDimension": "dimensión angular simple",
    "simpleAngularDimension": "dimensión angular simple",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Crea una dimensión angular simple. Por defecto, se muestran grados, pero puedes optar por usar radianes.",
    "direction1": "dirección 1",
    "direction2": "dirección 2",
    "offsetFromCenter": "desplazamiento desde el centro",
    "extraSize": "tamaño extra",
    "radians": "radianes",
    "bitbybit.occt.dimensions.pinWithLabel": "pin con etiqueta",
    "pinWithLabel": "pin con etiqueta",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Crea un pin con etiqueta. Se puede usar para explicar cosas sobre los modelos o marcar elementos importantes en la escena 3D.",
    "offsetFromStart": "desplazamiento desde el inicio",
    "bitbybit.vector.lengthSq": "longitud al cuadrado",
    "lengthSq": "longitud al cuadrado",
    "bitbybit.vector.lengthSq_description": "Calcula la longitud al cuadrado del vector",
    "bitbybit.point.twoPointsAlmostEqual": "dos puntos iguales",
    "twoPointsAlmostEqual": "dos puntos iguales",
    "bitbybit.point.twoPointsAlmostEqual_description": "Comprueba si dos puntos son casi iguales",
    "bitbybit.line.lineToSegment": "línea a segmento",
    "lineToSegment": "línea a segmento",
    "bitbybit.line.lineToSegment_description": "Convierte la línea a segmento",
    "bitbybit.line.linesToSegments": "líneas a segmentos",
    "linesToSegments": "líneas a segmentos",
    "bitbybit.line.linesToSegments_description": "Convierte las líneas a segmentos",
    "bitbybit.line.segmentToLine": "segmento a línea",
    "segmentToLine": "segmento a línea",
    "bitbybit.line.segmentToLine_description": "Convierte el segmento a línea",
    "segment": "segmento",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segmentos a líneas",
    "segmentsToLines": "segmentos a líneas",
    "bitbybit.line.segmentsToLines_description": "Convierte los segmentos a líneas",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "ordenar segmentos en polilíneas",
    "sortSegmentsIntoPolylines": "ordenar segmentos en polilíneas",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Crea las polilíneas a partir de segmentos que están potencialmente conectados pero mezclados aleatoriamente",
    "sort": "ordenar",
    "bitbybit.mesh.signedDistanceToPlane": "distancia con signo al plano",
    "signedDistanceToPlane": "distancia con signo al plano",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calcula la distancia con signo desde un punto a un plano.",
    "plane": "plano",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calcular plano del triángulo",
    "calculateTrianglePlane": "calcular plano del triángulo",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calcula el plano del triángulo a partir del triángulo.",
    "triangle": "triángulo",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "intersección triángulo-triángulo",
    "triangleTriangleIntersection": "intersección triángulo-triángulo",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calcula la intersección de dos triángulos.",
    "triangle1": "triángulo 1",
    "triangle2": "triángulo 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segmentos de intersección malla-malla",
    "meshMeshIntersectionSegments": "segmentos de intersección malla-malla",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calcula los segmentos de intersección de dos mallas.",
    "mesh1": "malla 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "malla 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polilíneas de intersección malla-malla",
    "meshMeshIntersectionPolylines": "polilíneas de intersección malla-malla",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calcula las polilíneas de intersección de dos mallas.",
    "bitbybit.occt.shapeFacesToPolygonPoints": "caras de forma a puntos de polígono",
    "shapeFacesToPolygonPoints": "caras de forma a puntos de polígono",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Crea puntos de polígono a partir de las caras de la forma",
    "reversedPoints": "puntos invertidos",
    "bitbybit.occt.shapeToMesh": "forma a malla",
    "shapeToMesh": "forma a malla",
    "bitbybit.occt.shapeToMesh_description": "Crea una malla a partir de la forma",
    "bitbybit.occt.shapesToMeshes": "formas a mallas",
    "shapesToMeshes": "formas a mallas",
    "bitbybit.occt.shapesToMeshes_description": "Crea una malla a partir de la forma",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "desde puntos de polígono",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Crear un Manifold a partir de un conjunto de puntos de polígono que describen triángulos.",
    "traingle": "triángulo",
    "bitbybit.point.stretchPointsDirFromCenter": "estirar puntos en dirección desde el centro",
    "stretchPointsDirFromCenter": "estirar puntos en dirección desde el centro",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Estira múltiples puntos proporcionando un punto central, dirección y factor de escala uniforme",
    "bitbybit.point.hexGridScaledToFit": "rejilla hexagonal escalada para ajustar",
    "hexGridScaledToFit": "rejilla hexagonal escalada para ajustar",
    "bitbybit.point.hexGridScaledToFit_description": "Crea una rejilla hexagonal de punta superior, escalando los hexágonos para ajustarse exactamente a las dimensiones especificadas. Devuelve tanto los puntos centrales como los vértices de cada hexágono (potencialmente escalado). Los hexágonos se ordenan primero por columna y luego por fila.",
    "nrHexagonsU": "nº hexágonos U",
    "nrHexagonsV": "nº hexágonos V",
    "extendTop": "extender arriba",
    "extendBottom": "extender abajo",
    "extendLeft": "extender izquierda",
    "extendRight": "extender derecha",
    "centerGrid": "centrar rejilla",
    "bitbybit.point.sortPoints": "ordenar puntos",
    "sortPoints": "ordenar puntos",
    "bitbybit.point.sortPoints_description": "Ordena los puntos lexicográficamente (X, luego Y, luego Z)",
    "bitbybit.line.lineLineIntersection": "intersección línea-línea",
    "lineLineIntersection": "intersección línea-línea",
    "bitbybit.line.lineLineIntersection_description": "Si dos líneas se intersecan, devuelve el punto de intersección",
    "line1": "línea 1",
    "line2": "línea 2",
    "checkSegmentsOnly": "comprobar solo segmentos",
    "bitbybit.polyline.polylineToLines": "polilínea a líneas",
    "polylineToLines": "polilínea a líneas",
    "bitbybit.polyline.polylineToLines_description": "Crea las líneas a partir de la polilínea",
    "bitbybit.polyline.polylineToSegments": "polilínea a segmentos",
    "polylineToSegments": "polilínea a segmentos",
    "bitbybit.polyline.polylineToSegments_description": "Crea los segmentos a partir de la polilínea",
    "bitbybit.polyline.polylineSelfIntersection": "autointersección de polilínea",
    "polylineSelfIntersection": "autointersección de polilínea",
    "bitbybit.polyline.polylineSelfIntersection_description": "Encuentra los puntos de autointersección de la polilínea",
    "bitbybit.polyline.twoPolylineIntersection": "intersección de dos polilíneas",
    "twoPolylineIntersection": "intersección de dos polilíneas",
    "bitbybit.polyline.twoPolylineIntersection_description": "Encuentra los puntos de intersección entre dos polilíneas.",
    "polyline1": "polilínea 1",
    "polyline2": "polilínea 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdividir en alambres hexagonales",
    "subdivideToHexagonWires": "subdividir en alambres hexagonales",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivide una cara en alambres hexagonales",
    "extendUUp": "extender U arriba",
    "extendUBottom": "extender U abajo",
    "extendVUp": "extender V arriba",
    "extendVBottom": "extender V abajo",
    "nrHexagonsInHeight": "nº hexágonos en altura",
    "nrHexagonsInWidth": "nº hexágonos en anchura",
    "bitbybit.vector.length": "longitud del vector",
    "bitbybit.vector.length_description": "Calcula la longitud del vector",
    "bitbybit.point.maxFilletRadius": "radio máximo de redondeo",
    "maxFilletRadius": "radio máximo de redondeo",
    "bitbybit.point.maxFilletRadius_description": "Calcula el radio máximo de redondeo posible en una esquina formada por dos segmentos de línea que comparten un punto final (C), de modo que el arco de redondeo sea tangente a ambos segmentos y se encuentre completamente dentro de ellos.",
    "bitbybit.point.maxFilletRadiusHalfLine": "radio máximo de redondeo media línea",
    "maxFilletRadiusHalfLine": "radio máximo de redondeo media línea",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calcula el radio máximo de redondeo posible en una esquina C, de modo que el arco de redondeo sea tangente a ambos segmentos (P1-C, P2-C) y los puntos tangentes se encuentren dentro de la primera mitad de cada segmento (medido desde C).",
    "bitbybit.point.maxFilletsHalfLine": "redondeos máximos media línea",
    "maxFilletsHalfLine": "redondeos máximos media línea",
    "bitbybit.point.maxFilletsHalfLine_description": "Calcula el radio máximo de redondeo posible en cada esquina de una polilínea formada por una serie de puntos. El radio de redondeo se calcula para cada esquina interna y opcionalmente para las esquinas de cierre si la polilínea está cerrada.",
    "checkLastWithFirst": "comprobar último con primero",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "radio máximo de redondeo más seguro (puntos, media línea)",
    "safestPointsMaxFilletHalfLine": "radio máximo de redondeo más seguro (puntos, media línea)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calcula el único radio máximo de redondeo más seguro que se puede aplicar uniformemente a todas las esquinas de una colección de puntos, basado en la restricción de 'media línea'. Esto se determina encontrando el mínimo de los radios máximos de redondeo posibles calculados para cada esquina individual.",
    "bitbybit.polyline.maxFilletsHalfLine": "redondeos máximos media línea",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calcula el radio máximo de redondeo de media línea posible para cada esquina de una polilínea dada. Para una polilínea cerrada, incluye las esquinas que conectan el último segmento con el primero. El cálculo utiliza la restricción de 'media línea', lo que significa que los puntos tangentes del redondeo deben estar dentro de la primera mitad de cada segmento conectado a la esquina.",
    "bitbybit.polyline.safestFilletRadius": "radio de redondeo más seguro",
    "safestFilletRadius": "radio de redondeo más seguro",
    "bitbybit.polyline.safestFilletRadius_description": "Calcula el único radio máximo de redondeo más seguro que se puede aplicar uniformemente a todas las esquinas de una polilínea, basado en la restricción de 'media línea'. Esto se determina encontrando el mínimo de los radios máximos de redondeo posibles calculados para cada esquina individual.",
    "flatTop": "parte superior plana",
    "bitbybit.mesh.meshMeshIntersectionPoints": "puntos de intersección malla-malla",
    "meshMeshIntersectionPoints": "puntos de intersección malla-malla",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calcula los puntos de intersección de dos mallas.",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexágonos en rejilla",
    "hexagonsInGrid": "hexágonos en rejilla",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Crea alambres hexagonales de OpenCascade en una rejilla",
    "scalePatternWidth": "escalar anchura del patrón",
    "scalePatternHeight": "escalar altura del patrón",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "alambres de intersección malla-malla",
    "meshMeshIntersectionWires": "alambres de intersección malla-malla",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Realiza una operación de intersección malla-malla entre dos formas; ambas formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los alambres de la intersección, que son polilíneas o polígonos.",
    "mesh based": "basado en malla",
    "precision1": "precisión 1",
    "precision2": "precisión 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "puntos de intersección malla-malla",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Realiza una operación de intersección malla-malla entre dos formas; ambas formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los puntos de la intersección.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "intersección malla-malla a alambres",
    "meshMeshIntersectionOfShapesWires": "intersección malla-malla a alambres",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Realiza una operación de intersección malla-malla entre la forma y múltiples otras formas; todas las formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los alambres de la intersección, que son polilíneas o polígonos.",
    "precisionShapes": "precisión formas",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "intersección malla-malla a puntos",
    "meshMeshIntersectionOfShapesPoints": "intersección malla-malla a puntos",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Realiza una operación de intersección malla-malla entre la forma y múltiples otras formas; todas las formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los puntos de la intersección.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexágonos en rejilla",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Crea hexágonos de OpenCascade en una rejilla (caras)",
    "bitbybit.jscad.toPolygonPoints": "a puntos de polígono",
    "toPolygonPoints": "a puntos de polígono",
    "bitbybit.jscad.toPolygonPoints_description": "Convierte la forma jscad en una colección de puntos de polígono que representan la malla",
    "conversions": "conversiones",
    "bitbybit.manifold.toPolygonPoints": "a puntos de polígono",
    "bitbybit.manifold.toPolygonPoints_description": "Convierte la forma manifold en una colección de puntos de polígono que representan la malla.",
    "flatU": "plano U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdividir en agujeros hexagonales",
    "subdivideToHexagonHoles": "subdividir en agujeros hexagonales",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivide una cara en agujeros hexagonales",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "convertir líneas a curvas NURBS",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Convierte líneas en curvas NURBS. Devuelve un array de objetos verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "convertir línea a curva NURBS",
    "convertLineToNurbsCurve": "convertir línea a curva NURBS",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Convierte una línea en una curva NURBS. Devuelve el objeto verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "convertir polilínea a curva NURBS",
    "convertPolylineToNurbsCurve": "convertir polilínea a curva NURBS",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Convierte una polilínea en una curva NURBS. Devuelve el objeto verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "convertir polilíneas a curvas NURBS",
    "convertPolylinesToNurbsCurves": "convertir polilíneas a curvas NURBS",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Convierte polilíneas en curvas NURBS. Devuelve los objetos verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segmento",
    "createSegment": "segmento",
    "bitbybit.line.createSegment_description": "Crear el segmento",
    "bitbybit.occt.shapes.edge.fromBaseLine": "arista desde línea base",
    "fromBaseLine": "desde línea base",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Crea una arista lineal desde el formato de línea base {start: Point3, end: Point3}",
    "from base": "desde base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "arista desde líneas base",
    "fromBaseLines": "desde líneas base",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Crea aristas lineales desde el formato de líneas base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "arista desde segmento base",
    "fromBaseSegment": "desde segmento base",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Crea una arista lineal desde el formato de segmento base [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "aristas desde segmentos base",
    "fromBaseSegments": "desde segmentos base",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Crea una arista lineal desde el formato de segmentos base [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "aristas desde puntos",
    "fromPoints": "desde puntos",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Crea aristas lineales desde una colección de puntos",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "aristas desde polilínea base",
    "fromBasePolyline": "desde polilínea base",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Crea aristas lineales desde la definición de polilínea",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "aristas desde triángulo base",
    "fromBaseTriangle": "desde triángulo base",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Crea aristas lineales desde la definición de triángulo",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "aristas desde malla base",
    "fromBaseMesh": "desde malla base",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Crea aristas lineales desde la definición de malla",
    "bitbybit.occt.shapes.wire.fromBaseLine": "alambre desde línea base",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Crea un alambre lineal desde el formato de línea base {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "alambres desde líneas base",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Crea alambres lineales desde el formato de líneas base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "alambre desde segmento base",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Crea un alambre lineal desde el formato de segmento base [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "alambres desde segmentos base",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Crea alambres lineales desde el formato de segmentos base [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "alambre desde puntos",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Crea un alambre desde una colección de puntos",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "alambre desde polilínea base",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Crea un alambre desde la definición de polilínea",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "alambre desde triángulo base",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Crea un alambre desde la definición de triángulo",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "alambres desde malla base",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Crea alambres desde la definición de malla",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "cara desde triángulo base",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Crea una cara desde la definición de triángulo",
    "bitbybit.occt.shapes.face.fromBaseMesh": "caras desde malla base",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Crea caras desde la definición de malla",
    "fromRightHanded": "desde diestro",
     "bitbybit.advanced.text3d.createWithUrl": "texto con url",
    "createWithUrl": "texto con url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Crea un texto 3D con una URL de fuente. Esto es útil cuando se quiere utilizar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se utilizará para generar el texto 3D. Asegúrese de que las fuentes no contengan autointersecciones y otros caracteres incorrectos; es un problema común con las fuentes personalizadas. Los formatos de fuente compatibles son: ttf, otf, woff. Tenga en cuenta que Woff2 no es compatible con opentype.js ya que es un formato comprimido.",
    "fontUrl": "url de la fuente",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "texto en cara url",
    "createTextOnFaceUrl": "texto en cara url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Crea un texto 3D en la cara utilizando una URL de fuente. Esto es útil cuando se quiere utilizar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se utilizará para generar el texto 3D. Asegúrese de que las fuentes no contengan autointersecciones y otros caracteres incorrectos; es un problema común con las fuentes personalizadas. Los formatos de fuente compatibles son: ttf, otf, woff. Tenga en cuenta que Woff2 no es compatible con opentype.js ya que es un formato comprimido.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "textos en cara url",
    "createTextsOnFaceUrl": "textos en cara url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Crea textos 3D en la cara a partir de múltiples definiciones de URL. Esto es útil cuando se quiere utilizar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se utilizará para generar el texto 3D. Asegúrese de que las fuentes no contengan autointersecciones y otros caracteres incorrectos; es un problema común con las fuentes personalizadas. Los formatos de fuente compatibles son: ttf, otf, woff. Tenga en cuenta que Woff2 no es compatible con opentype.js ya que es un formato comprimido.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "definición de texto 3d en cara url",
    "definition3dTextOnFaceUrl": "definición de texto 3d en cara url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Crea un texto 3D que se utilizará en la definición de la URL de la cara. Esto es útil cuando se quiere utilizar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se utilizará para generar el texto 3D. Asegúrese de que las fuentes no contengan autointersecciones y otros caracteres incorrectos; es un problema común con las fuentes personalizadas. Los formatos de fuente compatibles son: ttf, otf, woff. Tenga en cuenta que Woff2 no es compatible con opentype.js ya que es un formato comprimido.",
    "bitbybit.advanced.navigation.pointOfInterest": "punto de interés",
    "navigation": "navegación",
    "pointOfInterest": "punto de interés",
    "bitbybit.advanced.navigation.pointOfInterest_description": "nodo de sobrevuelo",
    "cameraTarget": "objetivo de la cámara",
    "cameraPosition": "posición de la cámara",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "sistema de puntos de interés",
    "pointsOfInterestSystem": "sistema de puntos de interés",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "puntos de interés",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "punto de interés",
    "style": "estilo",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "estilo de punto de interés",
    "pointOfInterestStyle": "estilo de punto de interés",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Crear estilo de punto de interés: se utiliza para dar estilo a los indicadores de puntos de interés en el espacio 3D. Puede personalizar el tamaño del punto, el color, el color al pasar el cursor, el efecto de pulso, el color y el tamaño de la etiqueta de texto.",
    "pointSize": "tamaño del punto",
    "pointColor": "color del punto",
    "hoverPointColor": "color del punto al pasar el cursor",
    "pulseColor": "color del pulso",
    "hoverPulseColor": "color del pulso al pasar el cursor",
    "pulseMinSize": "tamaño mínimo del pulso",
    "pulseMaxSize": "tamaño máximo del pulso",
    "pulseThickness": "grosor del pulso",
    "pulseSpeed": "velocidad del pulso",
    "textColor": "color del texto",
    "hoverTextColor": "color del texto al pasar el cursor",
    "textSize": "tamaño del texto",
    "hideSkybox": "ocultar skybox",
    "textureUrl": "URL de la textura",
    "hdrTexture": "textura HDR",
    "textureSize": "tamaño de la textura",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "habilitar textura personalizada del skybox",
    "enableSkyboxCustomTexture": "habilitar textura personalizada del skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Habilita el skybox con una textura personalizada",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "imagen de fondo CSS del canvas",
    "canvasCSSBackgroundImage": "imagen de fondo CSS del canvas",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Cambia el fondo de la escena a una imagen de fondo CSS para el espacio 3D",
    "cssBackgroundImage": "imagen de fondo CSS",
    "bitbybit.babylon.scene.twoColorLinearGradient": "gradiente lineal de dos colores",
    "twoColorLinearGradient": "gradiente lineal de dos colores",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Crea un fondo de gradiente lineal de dos colores para el espacio 3D",
    "colorFrom": "color desde",
    "colorTo": "color hasta",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "parada desde",
    "stopTo": "parada hasta",
    "bitbybit.babylon.scene.twoColorRadialGradient": "gradiente radial de dos colores",
    "twoColorRadialGradient": "gradiente radial de dos colores",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Crea un fondo de gradiente radial de dos colores para el espacio 3D",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "gradiente lineal multicolor",
    "multiColorLinearGradient": "gradiente lineal multicolor",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Crea un fondo de gradiente lineal multicolor para el espacio 3D",
    "Base.Color[]": "Base.Color[]",
    "stops": "paradas",
    "bitbybit.babylon.scene.multiColorRadialGradient": "gradiente radial multicolor",
    "multiColorRadialGradient": "gradiente radial multicolor",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Crea un fondo de gradiente radial multicolor para el espacio 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "imagen de fondo del canvas",
    "canvasBackgroundImage": "imagen de fondo del canvas",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Establece una imagen de fondo con varias opciones de personalización para el espacio 3D",
    "imageUrl": "URL de imagen",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "adjunto",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "recorte",
    "labelRotation": "rotación de etiqueta",
    "bitbybit.advanced.dimensions.linearDimension": "dimensión lineal",
    "linearDimension": "dimensión lineal",
    "bitbybit.advanced.dimensions.linearDimension_description": "Crea una dimensión lineal - una línea de medida entre dos puntos con líneas de extensión y etiqueta de texto. La dimensión muestra la distancia entre los puntos y se puede estilizar con DimensionStyleDto.",
    "linear dimension": "dimensión lineal",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "dimensión angular",
    "angularDimension": "dimensión angular",
    "bitbybit.advanced.dimensions.angularDimension_description": "Crea una dimensión angular - un arco de medida entre dos vectores de dirección con líneas de extensión y etiqueta de texto. La dimensión muestra el ángulo entre las direcciones y se puede estilizar con DimensionStyleDto.",
    "angular dimension": "dimensión angular",
    "centerPoint": "punto central",
    "bitbybit.advanced.dimensions.dimensionStyle": "estilo de dimensión",
    "dimensionStyle": "estilo de dimensión",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Crear estilo de dimensión - utilizado para estilizar líneas de dimensión, flechas y texto en el espacio 3D. Puedes personalizar colores de línea, grosor, tamaño de texto, tamaño de flecha y colores de fondo.",
    "dimension style": "estilo de dimensión",
    "lineColor": "color de línea",
    "lineThickness": "grosor de línea",
    "extensionLineLength": "longitud de línea de extensión",
    "textBackgroundColor": "color de fondo del texto",
    "textBackgroundOpacity": "opacidad del fondo del texto",
    "arrowSize": "tamaño de flecha",
    "arrowColor": "color de flecha",
    "textRenderMode": "modo de renderizado de texto",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "cartelera de texto",
    "occlusionCheckInterval": "intervalo de verificación de oclusión",
    "arrowTailLength": "longitud de cola de flecha",
    "showArrows": "mostrar flechas",
    "labelOverwrite": "sobrescribir etiqueta",
    "bitbybit.advanced.dimensions.radialDimension": "dimensión radial",
    "radialDimension": "dimensión radial",
    "bitbybit.advanced.dimensions.radialDimension_description": "Crea una dimensión radial - una línea de medida desde el centro hasta el perímetro que muestra radio o diámetro. Muestra el prefijo 'R' para radio o el prefijo '⌀' para diámetro con marca central opcional.",
    "radial dimension": "dimensión radial",
    "radiusPoint": "punto de radio",
    "showDiameter": "mostrar diámetro",
    "showCenterMark": "mostrar marca central",
    "bitbybit.advanced.dimensions.diametralDimension": "dimensión diametral",
    "diametralDimension": "dimensión diametral",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Crea una dimensión diametral - una línea de medida que abarca el diámetro completo de características circulares. Muestra el prefijo '⌀' con marca central opcional y flechas en ambos extremos.",
    "diametral dimension": "dimensión diametral",
    "bitbybit.advanced.dimensions.ordinateDimension": "dimensión de ordenada",
    "ordinateDimension": "dimensión de ordenada",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Crea una dimensión de ordenada - muestra la coordenada X, Y o Z desde un punto de referencia con línea guía. Útil para anotaciones de coordenadas y referenciado de datos en dibujos técnicos.",
    "ordinate dimension": "dimensión de ordenada",
    "measurementPoint": "punto de medición",
    "referencePoint": "punto de referencia",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "mostrar línea guía",
    "viewMode": "modo de vista",
    "schema": "esquema",
    "json schema": "esquema JSON",
    "metadata": "metadatos",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "fondo de gradiente lineal de dos colores",
    "twoColorLinearGradientBackground": "fondo de gradiente lineal de dos colores",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Crea un fondo de gradiente lineal de dos colores para el espacio 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "fondo de gradiente radial de dos colores",
    "twoColorRadialGradientBackground": "fondo de gradiente radial de dos colores",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Crea un fondo de gradiente radial de dos colores para el espacio 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "fondo de gradiente lineal multicolor",
    "multiColorLinearGradientBackground": "fondo de gradiente lineal multicolor",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Crea un fondo de gradiente lineal multicolor para el espacio 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "fondo de gradiente radial multicolor",
    "multiColorRadialGradientBackground": "fondo de gradiente radial multicolor",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Crea un fondo de gradiente radial multicolor para el espacio 3D",
    "textBackgroundStroke": "trazo del fondo del texto",
    "textBackgroundRadius": "radio del fondo del texto",
    "stableSize": "tamaño estable",
    "alwaysOnTop": "siempre encima",
    "textStableSize": "tamaño de texto estable",
    "bitbybit.occt.io.shapeToDxfPaths": "forma a rutas DXF",
    "shapeToDxfPaths": "forma a rutas DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Crea rutas DXF desde una forma OCCT. Importante - las formas que contienen alambres deben estar en el plano XZ (Y=0) para una exportación DXF 2D correcta.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "rutas DXF con capa",
    "dxfPathsWithLayer": "rutas DXF con capa",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Añade información de capa y color a las rutas DXF",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "capa",
    "bitbybit.occt.io.dxfCreate": "crear DXF",
    "dxfCreate": "crear DXF",
    "bitbybit.occt.io.dxfCreate_description": "Ensambla múltiples partes de ruta en un archivo DXF completo",
    "pathsParts": "partes de rutas",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "grosor de fuente de texto",
    "textPosition": "posición del texto",
    "textBackgroundStrokeThickness": "grosor del trazo",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum"
}