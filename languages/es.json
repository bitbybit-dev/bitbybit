{
    "bitbybit.draw.drawAnyAsyncNoReturn": "dibujar cualquier asíncrono sin retorno",
    "bitbybit": "bitbybit",
    "draw": "dibujar",
    "drawAnyAsyncNoReturn": "dibujar cualquier asíncrono sin retorno",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Dibuja cualquier tipo de geometría y no devuelve nada",
    "draw async": "dibujar asíncrono",
    "entity": "entidad",
    "Entity": "entidad",
    "options": "opciones",
    "DrawOptions": "opciones de dibujo",
    "babylonMesh": "malla de babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "malla de babylon o malla de líneas",
    "bitbybit.draw.drawAnyAsync": "dibujar cualquier asíncrono",
    "drawAnyAsync": "dibujar cualquier asíncrono",
    "bitbybit.draw.drawAnyAsync_description": "Dibuja cualquier tipo de geometría y devuelve la malla de babylon",
    "bitbybit.draw.drawAnyNoReturn": "dibujar cualquier sin retorno",
    "drawAnyNoReturn": "dibujar cualquier sin retorno",
    "bitbybit.draw.drawAnyNoReturn_description": "Dibuja cualquier tipo de geometría que no necesite computación asíncrona, por lo que no se puede usar con formas provenientes de occt o jscad",
    "draw sync": "dibujar síncrono",
    "bitbybit.draw.drawAny": "dibujar cualquier",
    "drawAny": "dibujar cualquier",
    "bitbybit.draw.drawAny_description": "Dibuja cualquier tipo de geometría que no necesite computación asíncrona, por lo que no se puede usar con formas provenientes de occt o jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "dibujar malla de cuadrícula sin retorno",
    "drawGridMeshNoReturn": "dibujar malla de cuadrícula sin retorno",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Dibuja una malla de cuadrícula en el plano del suelo en el espacio 3D. Esto ayuda a orientarse en el mundo.",
    "grid": "cuadrícula",
    "width": "ancho",
    "number": "número",
    "height": "altura",
    "subdivisions": "subdivisiones",
    "majorUnitFrequency": "frecuencia de unidad mayor",
    "minorUnitVisibility": "visibilidad de unidad menor",
    "gridRatio": "ratio de cuadrícula",
    "opacity": "opacidad",
    "backFaceCulling": "descarte de cara trasera",
    "boolean": "booleano",
    "mainColor": "color principal",
    "Base.Color": "color base",
    "secondaryColor": "color secundario",
    "bitbybit.draw.drawGridMesh": "dibujar malla de cuadrícula",
    "drawGridMesh": "dibujar malla de cuadrícula",
    "bitbybit.draw.drawGridMesh_description": "Dibuja una malla de cuadrícula en el plano del suelo en el espacio 3D. Esto ayuda a orientarse en el mundo.",
    "bitbybit.draw.optionsSimple": "opciones simples",
    "optionsSimple": "opciones simples",
    "bitbybit.draw.optionsSimple_description": "Crea opciones de dibujo para tipos de geometría básicos como puntos, líneas, polilíneas, superficies y mallas jscad",
    "colours": "colores",
    "string | string[]": "cadena o array de cadenas",
    "size": "tamaño",
    "updatable": "actualizable",
    "hidden": "oculto",
    "bitbybit.draw.optionsOcctShape": "opciones de forma occt",
    "optionsOcctShape": "opciones de forma occt",
    "bitbybit.draw.optionsOcctShape_description": "Crea opciones de dibujo para geometría de forma occt como aristas, alambres, caras, cáscaras, sólidos y compuestos",
    "faceOpacity": "opacidad de cara",
    "edgeOpacity": "opacidad de arista",
    "edgeColour": "color de arista",
    "faceColour": "color de cara",
    "vertexColour": "color de vértice",
    "faceMaterial": "material de cara",
    "Base.Material": "material base",
    "edgeWidth": "ancho de arista",
    "vertexSize": "tamaño de vértice",
    "drawEdges": "dibujar aristas",
    "drawFaces": "dibujar caras",
    "drawVertices": "dibujar vértices",
    "precision": "precisión",
    "drawEdgeIndexes": "dibujar índices de arista",
    "edgeIndexHeight": "altura de índice de arista",
    "edgeIndexColour": "color de índice de arista",
    "drawFaceIndexes": "dibujar índices de cara",
    "faceIndexHeight": "altura de índice de cara",
    "faceIndexColour": "color de índice de cara",
    "bitbybit.draw.optionsOcctShapeSimple": "opciones simples de forma occt",
    "optionsOcctShapeSimple": "opciones simples de forma occt",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Crea opciones de dibujo simples para geometría de forma occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "opciones de material de forma occt",
    "optionsOcctShapeMaterial": "opciones de material de forma occt",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Crea opciones de dibujo simples con material de cara personalizado para geometría de forma occt",
    "any": "cualquier",
    "bitbybit.draw.optionsManifoldShapeMaterial": "opciones de material de forma manifold",
    "optionsManifoldShapeMaterial": "opciones de material de forma manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Crea opciones de dibujo para geometría manifold",
    "crossSectionColour": "color de sección transversal",
    "crossSectionWidth": "ancho de sección transversal",
    "crossSectionOpacity": "opacidad de sección transversal",
    "computeNormals": "calcular normales",
    "bitbybit.draw.optionsBabylonNode": "opciones de nodo babylon",
    "optionsBabylonNode": "opciones de nodo babylon",
    "bitbybit.draw.optionsBabylonNode_description": "Crea opciones de dibujo para nodos de babylon js",
    "colorX": "color x",
    "colorY": "color y",
    "colorZ": "color z",
    "bitbybit.babylon.mesh.dispose": "eliminar malla",
    "babylon": "babylon",
    "mesh": "malla",
    "dispose": "eliminar",
    "bitbybit.babylon.mesh.dispose_description": "Elimina el objeto de malla dibujado de la escena",
    "memory": "memoria",
    "BABYLON.Mesh": "malla de babylon",
    "bitbybit.babylon.mesh.updateDrawn": "actualizar dibujado",
    "updateDrawn": "actualizar dibujado",
    "bitbybit.babylon.mesh.updateDrawn_description": "Actualiza el objeto de malla de BabylonJS dibujado sin eliminarlo",
    "updates": "actualizaciones",
    "position": "posición",
    "Base.Point3": "punto base 3",
    "rotation": "rotación",
    "Base.Vector3": "vector base 3",
    "scaling": "escalado",
    "bitbybit.babylon.mesh.setVisibility": "establecer visibilidad",
    "setVisibility": "establecer visibilidad",
    "bitbybit.babylon.mesh.setVisibility_description": "Cambia la visibilidad de una malla de BabylonJS dibujada",
    "visibility": "visibilidad",
    "includeChildren": "incluir hijos",
    "bitbybit.babylon.mesh.hide": "ocultar",
    "hide": "ocultar",
    "bitbybit.babylon.mesh.hide_description": "oculta la malla",
    "bitbybit.babylon.mesh.show": "mostrar",
    "show": "mostrar",
    "bitbybit.babylon.mesh.show_description": "Muestra la malla",
    "bitbybit.babylon.mesh.setParent": "establecer padre",
    "setParent": "establecer padre",
    "bitbybit.babylon.mesh.setParent_description": "Cambia el padre de la malla dibujada",
    "set": "establecer",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "malla de babylon o malla instanciada o malla abstracta",
    "parentMesh": "malla padre",
    "bitbybit.babylon.mesh.getParent": "obtener padre",
    "getParent": "obtener padre",
    "bitbybit.babylon.mesh.getParent_description": "Obtiene el padre de la malla dibujada",
    "get": "obtener",
    "bitbybit.babylon.mesh.setCheckCollisions": "establecer comprobación de colisiones",
    "setCheckCollisions": "establecer comprobación de colisiones",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Cambia la propiedad de verificar colisiones de la malla dibujada",
    "checkCollisions": "comprobar colisiones",
    "bitbybit.babylon.mesh.getCheckCollisions": "obtener comprobación de colisiones",
    "getCheckCollisions": "obtener comprobación de colisiones",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Obtiene la propiedad de verificar colisiones de la malla dibujada",
    "bitbybit.babylon.mesh.setPickable": "establecer seleccionable",
    "setPickable": "establecer seleccionable",
    "bitbybit.babylon.mesh.setPickable_description": "Cambia la propiedad de ser seleccionable de la malla dibujada",
    "pickable": "seleccionable",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "habilitar eventos de movimiento de puntero",
    "enablePointerMoveEvents": "habilitar eventos de movimiento de puntero",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Fuerza a la malla a ser seleccionable por eventos de movimiento del puntero, el valor predeterminado es falso ya que consume mucho rendimiento",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "deshabilitar eventos de movimiento de puntero",
    "disablePointerMoveEvents": "deshabilitar eventos de movimiento de puntero",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Hace que la malla ignore los eventos de movimiento del puntero, el valor predeterminado es falso",
    "bitbybit.babylon.mesh.getPickable": "obtener seleccionable",
    "getPickable": "obtener seleccionable",
    "bitbybit.babylon.mesh.getPickable_description": "Obtiene la propiedad de ser seleccionable de la malla dibujada",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "obtener mallas donde el nombre contiene",
    "getMeshesWhereNameContains": "obtener mallas donde el nombre contiene",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Obtiene mallas que tienen nombres que contienen un texto dado",
    "name": "nombre",
    "string": "cadena",
    "bitbybit.babylon.mesh.getChildMeshes": "obtener mallas hijas",
    "getChildMeshes": "obtener mallas hijas",
    "bitbybit.babylon.mesh.getChildMeshes_description": "obtiene las mallas hijas",
    "directDescendantsOnly": "solo descendientes directos",
    "bitbybit.babylon.mesh.getMeshesOfId": "obtener mallas por id",
    "getMeshesOfId": "obtener mallas por id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Obtiene mallas de id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "obtener malla por id",
    "getMeshOfId": "obtener malla por id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Obtiene malla de id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "obtener malla por id único",
    "getMeshOfUniqueId": "obtener malla por id único",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Obtiene malla de id único",
    "uniqueId": "id único",
    "bitbybit.babylon.mesh.mergeMeshes": "fusionar mallas",
    "mergeMeshes": "fusionar mallas",
    "bitbybit.babylon.mesh.mergeMeshes_description": "fusiona múltiples mallas en una",
    "edit": "editar",
    "arrayOfMeshes": "array de mallas",
    "BABYLON.Mesh[]": "array de mallas de babylon",
    "disposeSource": "eliminar fuente",
    "allow32BitsIndices": "permitir índices de 32 bits",
    "meshSubclass": "subclase de malla",
    "subdivideWithSubMeshes": "subdividir con submallas",
    "multiMultiMaterials": "múltiples materiales múltiples",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "convertir a malla con sombreado plano",
    "convertToFlatShadedMesh": "convertir a malla con sombreado plano",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Convierte la malla a malla de sombreado plano",
    "bitbybit.babylon.mesh.clone": "clonar",
    "clone": "clonar",
    "bitbybit.babylon.mesh.clone_description": "clona la malla",
    "bitbybit.babylon.mesh.cloneToPositions": "clonar a posiciones",
    "cloneToPositions": "clonar a posiciones",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Clona la malla a posiciones",
    "positions": "posiciones",
    "Base.Point3[]": "array de puntos base 3",
    "bitbybit.babylon.mesh.setId": "establecer id",
    "setId": "establecer id",
    "bitbybit.babylon.mesh.setId_description": "Cambia el id de la malla dibujada",
    "bitbybit.babylon.mesh.getId": "obtener id",
    "getId": "obtener id",
    "bitbybit.babylon.mesh.getId_description": "Obtiene el id de la malla dibujada",
    "bitbybit.babylon.mesh.getUniqueId": "obtener id único",
    "getUniqueId": "obtener id único",
    "bitbybit.babylon.mesh.getUniqueId_description": "Obtiene el id único de la malla dibujada",
    "bitbybit.babylon.mesh.setName": "establecer nombre",
    "setName": "establecer nombre",
    "bitbybit.babylon.mesh.setName_description": "Cambia el nombre de la malla dibujada",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "obtener vértices como puntos de polígono",
    "getVerticesAsPolygonPoints": "obtener vértices como puntos de polígono",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Obtiene los vértices como puntos de polígono. Estos se pueden usar con otros métodos de construcción para crear mallas. La malla debe estar triangulada.",
    "bitbybit.babylon.mesh.getName": "obtener nombre",
    "getName": "obtener nombre",
    "bitbybit.babylon.mesh.getName_description": "Obtiene el nombre de la malla babylon",
    "bitbybit.babylon.mesh.setMaterial": "establecer material",
    "setMaterial": "establecer material",
    "bitbybit.babylon.mesh.setMaterial_description": "Cambia el material de la malla dibujada",
    "material": "material",
    "BABYLON.Material": "material de babylon",
    "bitbybit.babylon.mesh.getMaterial": "obtener material",
    "getMaterial": "obtener material",
    "bitbybit.babylon.mesh.getMaterial_description": "Obtiene el material de la malla babylon",
    "bitbybit.babylon.mesh.getPosition": "obtener posición",
    "getPosition": "obtener posición",
    "bitbybit.babylon.mesh.getPosition_description": "Obtiene la posición como punto de la malla babylonjs",
    "bitbybit.babylon.mesh.getAbsolutePosition": "obtener posición absoluta",
    "getAbsolutePosition": "obtener posición absoluta",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Obtiene la posición absoluta en el mundo como punto de la malla babylonjs",
    "bitbybit.babylon.mesh.getRotation": "obtener rotación",
    "getRotation": "obtener rotación",
    "bitbybit.babylon.mesh.getRotation_description": "Obtiene el vector de rotación de la malla babylonjs",
    "bitbybit.babylon.mesh.getScale": "obtener escala",
    "getScale": "obtener escala",
    "bitbybit.babylon.mesh.getScale_description": "Obtiene el vector de escala de la malla babylonjs",
    "bitbybit.babylon.mesh.moveForward": "mover adelante",
    "moveForward": "mover adelante",
    "bitbybit.babylon.mesh.moveForward_description": "Mueve la malla babylonjs hacia adelante en el espacio local",
    "move": "mover",
    "distance": "distancia",
    "bitbybit.babylon.mesh.moveBackward": "mover atrás",
    "moveBackward": "mover atrás",
    "bitbybit.babylon.mesh.moveBackward_description": "Mueve la malla babylonjs hacia atrás en el espacio local",
    "bitbybit.babylon.mesh.moveUp": "mover arriba",
    "moveUp": "mover arriba",
    "bitbybit.babylon.mesh.moveUp_description": "Mueve la malla babylonjs hacia arriba en el espacio local",
    "bitbybit.babylon.mesh.moveDown": "mover abajo",
    "moveDown": "mover abajo",
    "bitbybit.babylon.mesh.moveDown_description": "Mueve la malla babylonjs hacia abajo en el espacio local",
    "bitbybit.babylon.mesh.moveRight": "mover derecha",
    "moveRight": "mover derecha",
    "bitbybit.babylon.mesh.moveRight_description": "Mueve la malla babylonjs hacia la derecha en el espacio local",
    "bitbybit.babylon.mesh.moveLeft": "mover izquierda",
    "moveLeft": "mover izquierda",
    "bitbybit.babylon.mesh.moveLeft_description": "Mueve la malla babylonjs hacia la izquierda en el espacio local",
    "bitbybit.babylon.mesh.yaw": "guiñada",
    "yaw": "guiñada",
    "bitbybit.babylon.mesh.yaw_description": "Rota la malla babylonjs alrededor del eje y local",
    "rotate": "rotar",
    "bitbybit.babylon.mesh.pitch": "cabeceo",
    "pitch": "cabeceo",
    "bitbybit.babylon.mesh.pitch_description": "Rota la malla babylonjs alrededor del eje x local",
    "bitbybit.babylon.mesh.roll": "balanceo",
    "roll": "balanceo",
    "bitbybit.babylon.mesh.roll_description": "Rota la malla babylonjs alrededor del eje z local",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "rotar alrededor de eje con posición",
    "rotateAroundAxisWithPosition": "rotar alrededor de eje con posición",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Rota la malla alrededor del eje y la posición dada por un ángulo dado",
    "axis": "eje",
    "angle": "ángulo",
    "bitbybit.babylon.mesh.setPosition": "establecer posición",
    "setPosition": "establecer posición",
    "bitbybit.babylon.mesh.setPosition_description": "Actualiza la posición de la malla BabylonJS o malla instanciada",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "malla de babylon o malla instanciada",
    "bitbybit.babylon.mesh.setRotation": "establecer rotación",
    "setRotation": "establecer rotación",
    "bitbybit.babylon.mesh.setRotation_description": "Actualiza la rotación de la malla BabylonJS o malla instanciada",
    "bitbybit.babylon.mesh.setScale": "establecer escala",
    "setScale": "establecer escala",
    "bitbybit.babylon.mesh.setScale_description": "Actualiza la escala de la malla BabylonJS o malla instanciada",
    "scale": "escala",
    "bitbybit.babylon.mesh.intersectsMesh": "interseca malla",
    "intersectsMesh": "interseca malla",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Comprueba si la malla intersecta con otra malla",
    "intersects": "interseca",
    "babylonMesh2": "malla de babylon 2",
    "precise": "preciso",
    "includeDescendants": "incluir descendientes",
    "bitbybit.babylon.mesh.intersectsPoint": "interseca punto",
    "intersectsPoint": "interseca punto",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Comprueba si la malla intersecta un punto",
    "point": "punto",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instancia de malla y transformar sin retorno",
    "createMeshInstanceAndTransformNoReturn": "instancia de malla y transformar sin retorno",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Crea una instancia de malla para renderizado optimizado. Este método comprobará si la malla contiene hijos y creará instancias para cada hijo. Estos están optimizados para el máximo rendimiento al renderizar muchos objetos similares en la escena. Este método devuelve instancias como hijos en una nueva malla. Si la malla tiene hijos, cada hijo se convierte en una instancia de malla.",
    "instance": "instancia",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instancia de malla y transformar",
    "createMeshInstanceAndTransform": "instancia de malla y transformar",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Crea una instancia de malla para renderizado optimizado. Este método comprobará si la malla contiene hijos y creará instancias para cada hijo. Estos están optimizados para el máximo rendimiento al renderizar muchos objetos similares en la escena. Este método devuelve instancias como hijos en una nueva malla. Si la malla tiene hijos, cada hijo se convierte en una instancia de malla.",
    "bitbybit.babylon.mesh.createMeshInstance": "instancia de malla",
    "createMeshInstance": "instancia de malla",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Crea una instancia de malla. Estas están optimizadas para el máximo rendimiento al renderizar muchos objetos similares en la escena. Si la malla tiene hijos, entonces cada hijo obtiene una instancia de malla.",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussiano",
    "gaussianSplatting": "splatting gaussiano",
    "create": "crear",
    "bitbybit.babylon.gaussianSplatting.create_description": "crea una malla de splatting gaussiano",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "clonar splatting gaussiano",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clona la malla de splatting gaussiano",
    "multiply": "multiplicar",
    "BABYLON.GaussianSplattingMesh": "malla de splatting gaussiano de babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "obtener posiciones de splat",
    "getSplatPositions": "obtener posiciones de splat",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Obtiene las posiciones splat de la malla de gaussian splat",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "congelar matriz de proyección",
    "camera": "cámara",
    "freezeProjectionMatrix": "congelar matriz de proyección",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Congela la matriz de proyección de la cámara",
    "adjust": "ajustar",
    "BABYLON.Camera": "cámara de babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "descongelar matriz de proyección",
    "unfreezeProjectionMatrix": "descongelar matriz de proyección",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Descongela la matriz de proyección de la cámara",
    "bitbybit.babylon.camera.setPosition": "establecer posición",
    "bitbybit.babylon.camera.setPosition_description": "Cambia la posición de una cámara",
    "BABYLON.TargetCamera": "cámara de objetivo de babylon",
    "bitbybit.babylon.camera.getPosition": "obtener posición",
    "bitbybit.babylon.camera.getPosition_description": "Obtiene la posición de una cámara",
    "bitbybit.babylon.camera.setTarget": "establecer objetivo",
    "setTarget": "establecer objetivo",
    "bitbybit.babylon.camera.setTarget_description": "Cambia el objetivo de una cámara",
    "target": "objetivo",
    "bitbybit.babylon.camera.getTarget": "obtener objetivo",
    "getTarget": "obtener objetivo",
    "bitbybit.babylon.camera.getTarget_description": "Obtiene el objetivo de una cámara",
    "bitbybit.babylon.camera.setSpeed": "establecer velocidad",
    "setSpeed": "establecer velocidad",
    "bitbybit.babylon.camera.setSpeed_description": "Cambia la velocidad de una cámara",
    "speed": "velocidad",
    "bitbybit.babylon.camera.getSpeed": "obtener velocidad",
    "getSpeed": "obtener velocidad",
    "bitbybit.babylon.camera.getSpeed_description": "Obtiene la velocidad de una cámara",
    "bitbybit.babylon.camera.setMinZ": "establecer z mínimo",
    "setMinZ": "establecer z mínimo",
    "bitbybit.babylon.camera.setMinZ_description": "Cambia el minZ de una cámara",
    "minZ": "z mínimo",
    "bitbybit.babylon.camera.setMaxZ": "establecer z máximo",
    "setMaxZ": "establecer z máximo",
    "bitbybit.babylon.camera.setMaxZ_description": "Cambia el maxZ de una cámara",
    "maxZ": "z máximo",
    "bitbybit.babylon.camera.makeCameraOrthographic": "hacer cámara ortográfica",
    "makeCameraOrthographic": "hacer cámara ortográfica",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Cambia el modo de la cámara a ortográfico",
    "orthoLeft": "orto izquierda",
    "orthoRight": "orto derecha",
    "orthoBottom": "orto abajo",
    "orthoTop": "orto arriba",
    "bitbybit.babylon.camera.makeCameraPerspective": "hacer cámara perspectiva",
    "makeCameraPerspective": "hacer cámara perspectiva",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Cambia el modo de una cámara a perspectiva",
    "bitbybit.babylon.camera.free.create": "cámara libre",
    "free": "libre",
    "bitbybit.babylon.camera.free.create_description": "Crea una cámara libre",
    "bitbybit.babylon.camera.arcRotate.create": "cámara de rotación en arco",
    "arcRotate": "rotación en arco",
    "bitbybit.babylon.camera.arcRotate.create_description": "Crea una cámara que rota alrededor de un objetivo dado mientras recorre el camino del arco. Esta cámara es adecuada para navegación 3D simple y es una cámara predeterminada usada por bitbybit.",
    "radius": "radio",
    "alpha": "alfa",
    "beta": "beta",
    "lowerRadiusLimit": "límite inferior de radio",
    "upperRadiusLimit": "límite superior de radio",
    "lowerAlphaLimit": "límite inferior de alfa",
    "upperAlphaLimit": "límite superior de alfa",
    "lowerBetaLimit": "límite inferior de beta",
    "upperBetaLimit": "límite superior de beta",
    "angularSensibilityX": "sensibilidad angular x",
    "angularSensibilityY": "sensibilidad angular y",
    "panningSensibility": "sensibilidad de paneo",
    "wheelPrecision": "precisión de rueda",
    "bitbybit.babylon.camera.target.create": "cámara de objetivo",
    "bitbybit.babylon.camera.target.create_description": "Crea una cámara objetivo",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "experiencia ar inmersiva",
    "webXr": "web xr",
    "simple": "simple",
    "createImmersiveARExperience": "experiencia ar inmersiva",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Crea experiencia XR predeterminada en modo inmersivo-ar",
    "scene": "escena",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "experiencia xr predeterminada con teletransporte",
    "createDefaultXRExperienceWithTeleportation": "experiencia xr predeterminada con teletransporte",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Crea experiencia XR predeterminada con teletransportación que es muy básica y funciona para escenarios simples",
    "groundMeshes": "mallas de suelo",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "experiencia xr predeterminada con teletransporte con retorno",
    "createDefaultXRExperienceWithTeleportationReturn": "experiencia xr predeterminada con teletransporte con retorno",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Crea experiencia XR predeterminada con teletransportación que es muy básica y funciona para escenarios simples",
    "bitbybit.babylon.node.drawNode": "dibujar nodo",
    "node": "nodo",
    "drawNode": "dibujar nodo",
    "bitbybit.babylon.node.drawNode_description": "Dibuja un nodo de tamaño dado con colores dados para cada eje",
    "BABYLON.TransformNode": "nodo de transformación de babylon",
    "bitbybit.babylon.node.drawNodes": "dibujar nodos",
    "drawNodes": "dibujar nodos",
    "bitbybit.babylon.node.drawNodes_description": "Dibuja nodos de tamaño dado con colores dados para cada eje",
    "nodes": "nodos",
    "BABYLON.TransformNode[]": "array de nodos de transformación de babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "nodo desde rotación",
    "createNodeFromRotation": "nodo desde rotación",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Crea un nodo en el origen con las rotaciones dadas en el sistema de coordenadas padre",
    "parent": "padre",
    "BABYLON.TransformNode | null": "nodo de transformación de babylon o nulo",
    "origin": "origen",
    "bitbybit.babylon.node.createWorldNode": "nodo mundial",
    "createWorldNode": "nodo mundial",
    "bitbybit.babylon.node.createWorldNode_description": "Crea un nodo mundo que tiene el nodo raíz como su padre",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "obtener vector adelante absoluto",
    "getAbsoluteForwardVector": "obtener vector adelante absoluto",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Obtiene el vector absoluto orientado hacia adelante en el espacio mundial",
    "bitbybit.babylon.node.getAbsoluteRightVector": "obtener vector derecha absoluto",
    "getAbsoluteRightVector": "obtener vector derecha absoluto",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Obtiene el vector absoluto orientado hacia la derecha en el espacio mundial",
    "bitbybit.babylon.node.getAbsoluteUpVector": "obtener vector arriba absoluto",
    "getAbsoluteUpVector": "obtener vector arriba absoluto",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Obtiene el vector absoluto orientado hacia arriba en el espacio mundial",
    "bitbybit.babylon.node.getAbsolutePosition": "obtener posición absoluta",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Obtiene la posición absoluta del nodo como vector de origen en el espacio mundial",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "obtener transformación de rotación absoluta",
    "getAbsoluteRotationTransformation": "obtener transformación de rotación absoluta",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Obtiene la rotación absoluta del nodo como una matriz de transformación codificada en un array de 16 números",
    "bitbybit.babylon.node.getRotationTransformation": "obtener transformación de rotación",
    "getRotationTransformation": "obtener transformación de rotación",
    "bitbybit.babylon.node.getRotationTransformation_description": "Obtiene la rotación del nodo en el espacio de coordenadas padre local como una matriz de transformación codificada en un array de 16 números",
    "bitbybit.babylon.node.getChildren": "obtener hijos",
    "getChildren": "obtener hijos",
    "bitbybit.babylon.node.getChildren_description": "Obtiene los hijos del nodo",
    "bitbybit.babylon.node.getParent": "obtener padre",
    "bitbybit.babylon.node.getParent_description": "Obtiene el padre del nodo",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "obtener posición en espacio local",
    "getPositionExpressedInLocalSpace": "obtener posición en espacio local",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Obtiene la posición del nodo expresada en espacio local",
    "bitbybit.babylon.node.getRootNode": "obtener nodo raíz",
    "getRootNode": "obtener nodo raíz",
    "bitbybit.babylon.node.getRootNode_description": "Obtiene el nodo raíz",
    "bitbybit.babylon.node.getRotation": "obtener rotación",
    "bitbybit.babylon.node.getRotation_description": "Obtiene las rotaciones euler",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "rotar alrededor de eje con posición",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Rota el nodo alrededor del eje y la posición dada por un ángulo dado",
    "bitbybit.babylon.node.rotate": "rotar",
    "bitbybit.babylon.node.rotate_description": "Rota el nodo alrededor del origen y el eje dado",
    "bitbybit.babylon.node.setAbsolutePosition": "establecer posición absoluta",
    "setAbsolutePosition": "establecer posición absoluta",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Establece la posición absoluta del nodo",
    "bitbybit.babylon.node.setDirection": "establecer dirección",
    "setDirection": "establecer dirección",
    "bitbybit.babylon.node.setDirection_description": "Establece la dirección del nodo",
    "direction": "dirección",
    "number[]": "array de números",
    "bitbybit.babylon.node.setParent": "establecer padre",
    "bitbybit.babylon.node.setParent_description": "Establece el nuevo padre para el nodo",
    "parentNode": "nodo padre",
    "bitbybit.babylon.node.translate": "trasladar",
    "translate": "trasladar",
    "bitbybit.babylon.node.translate_description": "Traslada el nodo por un vector de dirección dado y una distancia",
    "bitbybit.babylon.scene.backgroundColour": "color de fondo",
    "backgroundColour": "color de fondo",
    "bitbybit.babylon.scene.backgroundColour_description": "Cambia el color de fondo de la escena para el espacio 3D",
    "environment": "entorno",
    "colour": "color",
    "bitbybit.babylon.scene.activateCamera": "activar cámara",
    "activateCamera": "activar cámara",
    "bitbybit.babylon.scene.activateCamera_description": "Activa la cámara sobrescribiendo la cámara activa actual",
    "bitbybit.babylon.scene.useRightHandedSystem": "usar sistema de mano derecha",
    "useRightHandedSystem": "usar sistema de mano derecha",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Usa sistema de mano derecha",
    "system": "sistema",
    "use": "usar",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "dibujar luz puntual sin retorno",
    "drawPointLightNoReturn": "dibujar luz puntual sin retorno",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Crea y dibuja una luz puntual en la escena pero no emite nada",
    "lights": "luces",
    "intensity": "intensidad",
    "diffuse": "difuso",
    "specular": "especular",
    "shadowGeneratorMapSize": "tamaño del mapa del generador de sombras",
    "enableShadows": "habilitar sombras",
    "shadowDarkness": "oscuridad de la sombra",
    "shadowUsePercentageCloserFiltering": "sombra usar filtrado de porcentaje más cercano",
    "shadowContactHardeningLightSizeUVRatio": "sombra endurecimiento de contacto tamaño luz ratio uv",
    "shadowBias": "sesgo de sombra",
    "shadowNormalBias": "sesgo normal de sombra",
    "shadowMaxZ": "z máximo de sombra",
    "shadowMinZ": "z mínimo de sombra",
    "bitbybit.babylon.scene.getShadowGenerators": "obtener generadores de sombras",
    "getShadowGenerators": "obtener generadores de sombras",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Obtiene generadores de sombras añadidos por fuentes de luz a través de bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "dibujar luz puntual",
    "drawPointLight": "dibujar luz puntual",
    "bitbybit.babylon.scene.drawPointLight_description": "Crea y dibuja una luz puntual en la escena",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "dibujar luz direccional sin retorno",
    "drawDirectionalLightNoReturn": "dibujar luz direccional sin retorno",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Crea y dibuja una luz direccional en la escena",
    "bitbybit.babylon.scene.drawDirectionalLight": "dibujar luz direccional",
    "drawDirectionalLight": "dibujar luz direccional",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Crea y dibuja una luz direccional en la escena",
    "bitbybit.babylon.scene.getActiveCamera": "obtener cámara activa",
    "getActiveCamera": "obtener cámara activa",
    "bitbybit.babylon.scene.getActiveCamera_description": "Obtiene la cámara activa de la escena",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "ajustar cámara activa de rotación en arco",
    "adjustActiveArcRotateCamera": "ajustar cámara activa de rotación en arco",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Ajusta la cámara activa de rotación de arco con parámetros de configuración",
    "lookAt": "mirar a",
    "bitbybit.babylon.scene.clearAllDrawn": "limpiar todo lo dibujado",
    "clearAllDrawn": "limpiar todo lo dibujado",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Borra todos los objetos dibujados en la escena 3D",
    "bitbybit.babylon.scene.enableSkybox": "habilitar skybox",
    "enableSkybox": "habilitar skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "Habilita skybox",
    "skybox": "skybox",
    "Base.skyboxEnum": "enum de skybox base",
    "blur": "desenfoque",
    "environmentIntensity": "intensidad del entorno",
    "bitbybit.babylon.scene.fog": "niebla",
    "fog": "niebla",
    "bitbybit.babylon.scene.fog_description": "Habilita modo niebla",
    "mode": "modo",
    "Base.fogModeEnum": "enum de modo de niebla base",
    "color": "color",
    "density": "densidad",
    "start": "inicio",
    "end": "fin",
    "bitbybit.babylon.transforms.rotationCenterAxis": "eje de rotación central",
    "transforms": "transformaciones",
    "rotationCenterAxis": "eje de rotación central",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Crea una transformación de rotación alrededor del centro y un eje",
    "center": "centro",
    "bitbybit.babylon.transforms.rotationCenterX": "rotación centro x",
    "rotationCenterX": "rotación centro x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Crea una transformación de rotación alrededor del centro y un eje X",
    "bitbybit.babylon.transforms.rotationCenterY": "rotación centro y",
    "rotationCenterY": "rotación centro y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Crea una transformación de rotación alrededor del centro y un eje Y",
    "bitbybit.babylon.transforms.rotationCenterZ": "rotación centro z",
    "rotationCenterZ": "rotación centro z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Crea una transformación de rotación alrededor del centro y un eje Z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "rotación centro guiñada cabeceo balanceo",
    "rotationCenterYawPitchRoll": "rotación centro guiñada cabeceo balanceo",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Crea transformaciones de rotación con yaw, pitch y roll",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "escala centro xyz",
    "scaleCenterXYZ": "escala centro xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Transformación de escala alrededor del centro y direcciones xyz",
    "scaleXyz": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "escala xyz",
    "scaleXYZ": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Crea la transformación de escala en direcciones x, y y z",
    "bitbybit.babylon.transforms.uniformScale": "escala uniforme",
    "uniformScale": "escala uniforme",
    "bitbybit.babylon.transforms.uniformScale_description": "Crea transformación de escala uniforme",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "escala uniforme desde el centro",
    "uniformScaleFromCenter": "escala uniforme desde el centro",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Crea transformación de escala uniforme desde el centro",
    "bitbybit.babylon.transforms.translationXYZ": "traslación xyz",
    "translationXYZ": "traslación xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "Crea la transformación de traslación",
    "translation": "traslación",
    "bitbybit.babylon.transforms.translationsXYZ": "traslaciones xyz",
    "translationsXYZ": "traslaciones xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Crea la transformación de traslación",
    "translations": "traslaciones",
    "Base.Vector3[]": "array de vectores base 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "cargar activo en escena",
    "io": "io",
    "loadAssetIntoScene": "cargar activo en escena",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Importa malla desde el activo que ha subido para el proyecto. Debe subir sus activos a su proyecto a través de la página de gestión de proyectos.",
    "load": "cargar",
    "assetFile": "archivo de activo",
    "File": "archivo",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "cargar activo en escena sin retorno",
    "loadAssetIntoSceneNoReturn": "cargar activo en escena sin retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Importa malla desde el activo que ha subido para el proyecto. Debe subir sus activos a su proyecto a través de la página de gestión de proyectos.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "cargar activo en escena desde url raíz",
    "loadAssetIntoSceneFromRootUrl": "cargar activo en escena desde url raíz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Importa malla desde la url del activo que ha subido a un almacenamiento web accesible. Tenga en cuenta que los archivos deben ser accesibles públicamente para que esto funcione, asegúrese de que el acceso CORS esté habilitado para los activos.",
    "rootUrl": "url raíz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "cargar activo en escena desde url raíz sin retorno",
    "loadAssetIntoSceneFromRootUrlNoReturn": "cargar activo en escena desde url raíz sin retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Importa malla desde la url del activo que ha subido a un almacenamiento web accesible. Tenga en cuenta que los archivos deben ser accesibles públicamente para que esto funcione, asegúrese de que el acceso CORS esté habilitado para los activos.",
    "bitbybit.babylon.io.exportBabylon": "exportar babylon",
    "exportBabylon": "exportar babylon",
    "bitbybit.babylon.io.exportBabylon_description": "Exporta toda la escena a formato de escena .babylon. Luego puede editarla más en editores babylonjs.",
    "export": "exportar",
    "fileName": "nombre de archivo",
    "bitbybit.babylon.io.exportGLB": "exportar glb",
    "exportGLB": "exportar glb",
    "bitbybit.babylon.io.exportGLB_description": "Exporta toda la escena a formato .glb. Este formato de archivo se ha convertido en el estándar de la industria para modelos web.",
    "discardSkyboxAndGrid": "descartar skybox y cuadrícula",
    "bitbybit.babylon.io.exportMeshToStl": "exportar malla a stl",
    "exportMeshToStl": "exportar malla a stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "Exporta la malla con sus hijos a stl",
    "bitbybit.babylon.io.exportMeshesToStl": "exportar mallas a stl",
    "exportMeshesToStl": "exportar mallas a stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Exporta las mallas a stl",
    "meshes": "mallas",
    "bitbybit.babylon.ray.createPickingRay": "rayo de selección",
    "ray": "rayo",
    "createPickingRay": "rayo de selección",
    "bitbybit.babylon.ray.createPickingRay_description": "Crea un rayo de selección de la posición actual del ratón en la cámara activa",
    "bitbybit.babylon.ray.createRay": "rayo",
    "createRay": "rayo",
    "bitbybit.babylon.ray.createRay_description": "Crea un rayo que comienza en el origen, tiene vector de dirección y opcionalmente longitud",
    "length": "longitud",
    "bitbybit.babylon.ray.createRayFromTo": "rayo desde hasta",
    "createRayFromTo": "rayo desde hasta",
    "bitbybit.babylon.ray.createRayFromTo_description": "Crea un rayo de un punto a otro",
    "from": "desde",
    "to": "hasta",
    "bitbybit.babylon.ray.getOrigin": "obtener origen",
    "getOrigin": "obtener origen",
    "bitbybit.babylon.ray.getOrigin_description": "Obtiene el origen del rayo",
    "BABYLON.Ray": "rayo de babylon",
    "bitbybit.babylon.ray.getDirection": "obtener dirección",
    "getDirection": "obtener dirección",
    "bitbybit.babylon.ray.getDirection_description": "Obtiene la dirección del rayo",
    "bitbybit.babylon.ray.getLength": "obtener longitud",
    "getLength": "obtener longitud",
    "bitbybit.babylon.ray.getLength_description": "Obtiene la longitud del rayo",
    "bitbybit.babylon.pick.pickWithRay": "seleccionar con rayo",
    "pick": "seleccionar",
    "pickWithRay": "seleccionar con rayo",
    "bitbybit.babylon.pick.pickWithRay_description": "Obtiene un resultado de impacto de selección con rayo",
    "bitbybit.babylon.pick.pickWithPickingRay": "seleccionar con rayo de selección",
    "pickWithPickingRay": "seleccionar con rayo de selección",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Selecciona con rayo de selección de la posición actual del ratón en la cámara activa",
    "bitbybit.babylon.pick.getDistance": "obtener distancia",
    "getDistance": "obtener distancia",
    "bitbybit.babylon.pick.getDistance_description": "Obtiene la distancia al objeto si existe resultado de selección",
    "get from pick info": "obtener desde info de selección",
    "pickInfo": "info de selección",
    "BABYLON.PickingInfo": "info de selección de babylon",
    "bitbybit.babylon.pick.getPickedMesh": "obtener malla seleccionada",
    "getPickedMesh": "obtener malla seleccionada",
    "bitbybit.babylon.pick.getPickedMesh_description": "Obtiene la malla seleccionada",
    "bitbybit.babylon.pick.getPickedPoint": "obtener punto seleccionado",
    "getPickedPoint": "obtener punto seleccionado",
    "bitbybit.babylon.pick.getPickedPoint_description": "Obtiene el punto seleccionado",
    "bitbybit.babylon.pick.hit": "impacto",
    "hit": "impacto",
    "bitbybit.babylon.pick.hit_description": "Comprueba si el rayo de selección golpeó algo en la escena o no",
    "bitbybit.babylon.pick.getSubMeshId": "obtener id de submalla",
    "getSubMeshId": "obtener id de submalla",
    "bitbybit.babylon.pick.getSubMeshId_description": "Obtiene el id único de submalla si fue seleccionada",
    "bitbybit.babylon.pick.getSubMeshFaceId": "obtener id de cara de submalla",
    "getSubMeshFaceId": "obtener id de cara de submalla",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Obtiene el id único de cara de submalla si fue seleccionada",
    "bitbybit.babylon.pick.getBU": "obtener bu",
    "getBU": "obtener bu",
    "bitbybit.babylon.pick.getBU_description": "Obtiene la coordenada baricéntrica U que se usa al calcular las coordenadas de textura de la colisión",
    "bitbybit.babylon.pick.getBV": "obtener bv",
    "getBV": "obtener bv",
    "bitbybit.babylon.pick.getBV_description": "Obtiene la coordenada baricéntrica V que se usa al calcular las coordenadas de textura de la colisión",
    "bitbybit.babylon.pick.getPickedSprite": "obtener sprite seleccionado",
    "getPickedSprite": "obtener sprite seleccionado",
    "bitbybit.babylon.pick.getPickedSprite_description": "Obtiene el sprite seleccionado",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr metálico rugoso",
    "pbrMetallicRoughness": "pbr metálico rugoso",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Crea material PBR metálico rugoso.",
    "baseColor": "color base",
    "emissiveColor": "color emisivo",
    "metallic": "metálico",
    "roughness": "rugosidad",
    "zOffset": "desplazamiento z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "establecer color base",
    "setBaseColor": "establecer color base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Establece el color base del material",
    "BABYLON.PBRMetallicRoughnessMaterial": "material pbr metálico rugoso de babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "establecer metálico",
    "setMetallic": "establecer metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Establece la propiedad metálica del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "establecer rugosidad",
    "setRoughness": "establecer rugosidad",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Establece la rugosidad del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "establecer alfa",
    "setAlpha": "establecer alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Establece el alfa del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "establecer descarte de cara trasera",
    "setBackFaceCulling": "establecer descarte de cara trasera",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Establece el recorte de cara trasera del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "establecer textura base",
    "setBaseTexture": "establecer textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Establece la textura del material",
    "baseTexture": "textura base",
    "BABYLON.Texture": "textura de babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "obtener color base",
    "getBaseColor": "obtener color base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Obtiene el color base del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "obtener metálico",
    "getMetallic": "obtener metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Obtiene la propiedad metálica del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "obtener rugosidad",
    "getRoughness": "obtener rugosidad",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Obtiene la rugosidad del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "obtener alfa",
    "getAlpha": "obtener alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Obtiene el alfa del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "obtener descarte de cara trasera",
    "getBackFaceCulling": "obtener descarte de cara trasera",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Obtiene el recorte de cara trasera del material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "obtener textura base",
    "getBaseTexture": "obtener textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Obtiene la textura base del material",
    "bitbybit.babylon.material.skyMaterial.create": "material de cielo",
    "skyMaterial": "material de cielo",
    "bitbybit.babylon.material.skyMaterial.create_description": "Crea Material de Cielo",
    "luminance": "luminancia",
    "turbidity": "turbidez",
    "rayleigh": "rayleigh",
    "mieCoefficient": "coeficiente mie",
    "mieDirectionalG": "g direccional mie",
    "inclination": "inclinación",
    "azimuth": "azimut",
    "sunPosition": "posición del sol",
    "useSunPosition": "usar posición del sol",
    "cameraOffset": "desplazamiento de cámara",
    "up": "arriba",
    "dithering": "tramado",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "establecer luminancia",
    "setLuminance": "establecer luminancia",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Establece la luminancia del material del cielo",
    "MATERIALS.SkyMaterial": "material de cielo de materiales",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "establecer turbidez",
    "setTurbidity": "establecer turbidez",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Establece la turbidez del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "establecer rayleigh",
    "setRayleigh": "establecer rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Establece el rayleigh del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "establecer coeficiente mie",
    "setMieCoefficient": "establecer coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Establece el coeficiente mie del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "establecer g direccional mie",
    "setMieDirectionalG": "establecer g direccional mie",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Establece el G direccional mie del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setDistance": "establecer distancia",
    "setDistance": "establecer distancia",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Establece la distancia del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setInclination": "establecer inclinación",
    "setInclination": "establecer inclinación",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Establece la inclinación del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "establecer azimut",
    "setAzimuth": "establecer azimut",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Establece el azimut del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "establecer posición del sol",
    "setSunPosition": "establecer posición del sol",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Establece la posición del sol del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "establecer usar posición del sol",
    "setUseSunPosition": "establecer usar posición del sol",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Establece el uso de posición del sol del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "establecer desplazamiento de cámara",
    "setCameraOffset": "establecer desplazamiento de cámara",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Establece el desplazamiento de la cámara del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setUp": "establecer arriba",
    "setUp": "establecer arriba",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Establece el arriba del material del cielo",
    "bitbybit.babylon.material.skyMaterial.setDithering": "establecer tramado",
    "setDithering": "establecer tramado",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Establece el tramado del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "obtener luminancia",
    "getLuminance": "obtener luminancia",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Obtiene la luminancia del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "obtener turbidez",
    "getTurbidity": "obtener turbidez",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Obtiene la turbidez del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "obtener rayleigh",
    "getRayleigh": "obtener rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Obtiene el rayleigh del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "obtener coeficiente mie",
    "getMieCoefficient": "obtener coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Obtiene el coeficiente mie del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "obtener g direccional mie",
    "getMieDirectionalG": "obtener g direccional mie",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Obtiene el G direccional mie del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getDistance": "obtener distancia",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Obtiene la distancia del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getInclination": "obtener inclinación",
    "getInclination": "obtener inclinación",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Obtiene la inclinación del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "obtener azimut",
    "getAzimuth": "obtener azimut",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Obtiene el azimut del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "obtener posición del sol",
    "getSunPosition": "obtener posición del sol",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Obtiene la posición del sol del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "obtener usar posición del sol",
    "getUseSunPosition": "obtener usar posición del sol",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Obtiene el uso de posición del sol del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "obtener desplazamiento de cámara",
    "getCameraOffset": "obtener desplazamiento de cámara",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Obtiene el desplazamiento de la cámara del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getUp": "obtener arriba",
    "getUp": "obtener arriba",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Obtiene el arriba del material del cielo",
    "bitbybit.babylon.material.skyMaterial.getDithering": "obtener tramado",
    "getDithering": "obtener tramado",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Obtiene el tramado del material del cielo",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "establecer dirección al objetivo",
    "shadowLight": "luz de sombra",
    "setDirectionToTarget": "establecer dirección al objetivo",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Establece la dirección de la luz de sombra",
    "BABYLON.ShadowLight": "luz de sombra de babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "establecer posición",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Establece la posición de la luz de sombra",
    "bitbybit.babylon.meshBuilder.createBox": "caja",
    "meshBuilder": "constructor de mallas",
    "createBox": "caja",
    "bitbybit.babylon.meshBuilder.createBox_description": "Crea una malla de caja",
    "create simple": "crear simple",
    "depth": "profundidad",
    "sideOrientation": "orientación lateral",
    "BabylonMesh.sideOrientationEnum": "enum de orientación lateral de malla de babylon",
    "bitbybit.babylon.meshBuilder.createCube": "cubo",
    "createCube": "cubo",
    "bitbybit.babylon.meshBuilder.createCube_description": "Crea una malla de cubo",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "plano cuadrado",
    "createSquarePlane": "plano cuadrado",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Crea una malla de plano cuadrado",
    "bitbybit.babylon.meshBuilder.createSphere": "esfera",
    "createSphere": "esfera",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Crea una malla de esfera",
    "diameter": "diámetro",
    "segments": "segmentos",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "icoesfera",
    "createIcoSphere": "icoesfera",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Crea ico esfera",
    "radiusX": "radio x",
    "radiusY": "radio y",
    "radiusZ": "radio z",
    "flat": "plano",
    "bitbybit.babylon.meshBuilder.createDisc": "disco",
    "createDisc": "disco",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Crea un disco",
    "tessellation": "teselación",
    "arc": "arco",
    "bitbybit.babylon.meshBuilder.createTorus": "toro",
    "createTorus": "toro",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Crea una malla de toro",
    "thickness": "grosor",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "nudo toroidal",
    "createTorusKnot": "nudo toroidal",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Crea una malla de nudo de toro",
    "tube": "tubo",
    "radialSegments": "segmentos radiales",
    "tubularSegments": "segmentos tubulares",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polígono",
    "createPolygon": "polígono",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Crea una malla de polígono",
    "shape": "forma",
    "holes": "agujeros",
    "Base.Vector3[][]": "array de array de vectores base 3",
    "smoothingThreshold": "umbral de suavizado",
    "wrap": "envolver",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extruir polígono",
    "extrudePolygon": "extruir polígono",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Crea malla de polígono extruido",
    "bitbybit.babylon.meshBuilder.createTube": "tubo",
    "createTube": "tubo",
    "bitbybit.babylon.meshBuilder.createTube_description": "Crea una malla de tubo",
    "path": "ruta",
    "cap": "tapa",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "poliedro",
    "createPolyhedron": "poliedro",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Crea una malla de poliedro",
    "type": "tipo",
    "sizeX": "tamaño x",
    "sizeY": "tamaño y",
    "sizeZ": "tamaño z",
    "custom": "personalizado",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodésico",
    "createGeodesic": "geodésico",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Crea malla geodésica",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Crea malla goldberg",
    "bitbybit.babylon.meshBuilder.createCapsule": "cápsula",
    "createCapsule": "cápsula",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Crea malla de cápsula",
    "orientation": "orientación",
    "capSubdivisions": "subdivisiones de tapa",
    "radiusTop": "radio superior",
    "radiusBottom": "radio inferior",
    "topCapSubdivisions": "subdivisiones de tapa superior",
    "bottomCapSubdivisions": "subdivisiones de tapa inferior",
    "bitbybit.babylon.meshBuilder.createCylinder": "cilindro",
    "createCylinder": "cilindro",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Crea una malla de cilindro",
    "diameterTop": "diámetro superior",
    "diameterBottom": "diámetro inferior",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "forma extruida",
    "createExtrudedSahpe": "forma extruida",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Crea forma extruida",
    "closeShape": "cerrar forma",
    "closePath": "cerrar ruta",
    "bitbybit.babylon.meshBuilder.createRibbon": "cinta",
    "createRibbon": "cinta",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Crea una malla de cinta",
    "pathArray": "array de rutas",
    "closeArray": "cerrar array",
    "offset": "desplazamiento",
    "bitbybit.babylon.meshBuilder.createLathe": "torno",
    "createLathe": "torno",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Crea malla de torno",
    "closed": "cerrado",
    "bitbybit.babylon.meshBuilder.createGround": "suelo",
    "createGround": "suelo",
    "bitbybit.babylon.meshBuilder.createGround_description": "Crea la malla de suelo",
    "subdivisionsX": "subdivisiones x",
    "subdivisionsY": "subdivisiones y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "plano rectangular",
    "createRectanglePlane": "plano rectangular",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Crea una malla de plano rectangular",
    "bitbybit.babylon.texture.createSimple": "textura simple",
    "texture": "textura",
    "createSimple": "simple",
    "bitbybit.babylon.texture.createSimple_description": "Crea textura desde URL con algunas opciones básicas. Si cargó el activo a través del archivo, cree object url y pásela aquí.",
    "invertY": "invertir y",
    "invertZ": "invertir z",
    "wAng": "ángulo w",
    "uScale": "escala u",
    "vScale": "escala v",
    "uOffset": "desplazamiento u",
    "vOffset": "desplazamiento v",
    "samplingMode": "modo de muestreo",
    "samplingModeEnum": "enum de modo de muestreo",
    "bitbybit.babylon.tools.createScreenshot": "captura de pantalla",
    "tools": "herramientas",
    "createScreenshot": "captura de pantalla",
    "bitbybit.babylon.tools.createScreenshot_description": "Crea una captura de pantalla de la escena",
    "screenshots": "capturas de pantalla",
    "mimeType": "tipo mime",
    "quality": "calidad",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "captura de pantalla y descargar",
    "createScreenshotAndDownload": "captura de pantalla y descargar",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Crea una captura de pantalla de la escena y descarga el archivo",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interfaz de usuario a pantalla completa",
    "gui": "gui",
    "advancedDynamicTexture": "textura dinámica avanzada",
    "createFullScreenUI": "interfaz de usuario a pantalla completa",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "crea una interfaz de usuario a pantalla completa",
    "spaces": "espacios",
    "foreground": "primer plano",
    "adaptiveScaling": "escalado adaptativo",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "para malla",
    "createForMesh": "para malla",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Crea textura dinámica avanzada para una malla",
    "BABYLON.AbstractMesh": "malla abstracta de babylon",
    "supportPointerMove": "soportar movimiento de puntero",
    "onlyAlphaTesting": "solo prueba alfa",
    "sampling": "muestreo",
    "BabylonTexture.samplingModeEnum": "enum de modo de muestreo de textura de babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "cambiar relleno de control",
    "control": "control",
    "changeControlPadding": "cambiar relleno de control",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Cambia el relleno para el control",
    "positioning": "posicionamiento",
    "BABYLON.GUI.Control": "control gui de babylon",
    "paddingLeft": "relleno izquierdo",
    "number | string": "número o cadena",
    "paddingRight": "relleno derecho",
    "paddingTop": "relleno superior",
    "paddingBottom": "relleno inferior",
    "bitbybit.babylon.gui.control.changeControlAlignment": "cambiar alineación de control",
    "changeControlAlignment": "cambiar alineación de control",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Cambia la alineación para el control",
    "T": "t",
    "horizontalAlignment": "alineación horizontal",
    "horizontalAlignmentEnum": "enum de alineación horizontal",
    "verticalAlignment": "alineación vertical",
    "verticalAlignmentEnum": "enum de alineación vertical",
    "bitbybit.babylon.gui.control.cloneControl": "clonar control",
    "cloneControl": "clonar control",
    "bitbybit.babylon.gui.control.cloneControl_description": "Clona control",
    "container": "contenedor",
    "BABYLON.GUI.Container": "contenedor gui de babylon",
    "host": "host",
    "BABYLON.GUI.AdvancedDynamicTexture": "textura dinámica avanzada gui de babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "selector observable de control",
    "createControlObservableSelector": "selector observable de control",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Crea el selector de un observable para un control",
    "selector": "selector",
    "controlObservableSelectorEnum": "enum de selector observable de control",
    "bitbybit.babylon.gui.control.getControlByName": "obtener control por nombre",
    "getControlByName": "obtener control por nombre",
    "bitbybit.babylon.gui.control.getControlByName_description": "Obtiene control por nombre",
    "bitbybit.babylon.gui.control.setIsVisible": "establecer es visible",
    "setIsVisible": "establecer es visible",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Establece si el control es visible",
    "isVisible": "es visible",
    "bitbybit.babylon.gui.control.setIsReadonly": "establecer solo lectura",
    "setIsReadonly": "establecer solo lectura",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Establece si el control es de solo lectura",
    "isReadOnly": "es solo lectura",
    "bitbybit.babylon.gui.control.setIsEnabled": "establecer habilitado",
    "setIsEnabled": "establecer habilitado",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Establece si el control está habilitado",
    "isEnabled": "está habilitado",
    "bitbybit.babylon.gui.control.setHeight": "establecer altura",
    "setHeight": "establecer altura",
    "bitbybit.babylon.gui.control.setHeight_description": "Establece la altura del control",
    "bitbybit.babylon.gui.control.setWidth": "establecer ancho",
    "setWidth": "establecer ancho",
    "bitbybit.babylon.gui.control.setWidth_description": "Establece el ancho del control",
    "bitbybit.babylon.gui.control.setColor": "establecer color",
    "setColor": "establecer color",
    "bitbybit.babylon.gui.control.setColor_description": "Establece el color del control",
    "bitbybit.babylon.gui.control.setFontSize": "establecer tamaño de fuente",
    "setFontSize": "establecer tamaño de fuente",
    "bitbybit.babylon.gui.control.setFontSize_description": "Establece tamaño de fuente",
    "fontSize": "tamaño de fuente",
    "bitbybit.babylon.gui.control.getHeight": "obtener altura",
    "getHeight": "obtener altura",
    "bitbybit.babylon.gui.control.getHeight_description": "Obtiene la altura",
    "bitbybit.babylon.gui.control.getWidth": "obtener ancho",
    "getWidth": "obtener ancho",
    "bitbybit.babylon.gui.control.getWidth_description": "Obtiene el ancho",
    "bitbybit.babylon.gui.control.getColor": "obtener color",
    "getColor": "obtener color",
    "bitbybit.babylon.gui.control.getColor_description": "Obtiene el color",
    "bitbybit.babylon.gui.control.getFontSize": "obtener tamaño de fuente",
    "getFontSize": "obtener tamaño de fuente",
    "bitbybit.babylon.gui.control.getFontSize_description": "Obtiene tamaño de fuente del control",
    "bitbybit.babylon.gui.control.getIsVisible": "obtener es visible",
    "getIsVisible": "obtener es visible",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Obtiene si el control es visible",
    "bitbybit.babylon.gui.control.getIsReadonly": "obtener es solo lectura",
    "getIsReadonly": "obtener es solo lectura",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Obtiene si el control es de solo lectura",
    "bitbybit.babylon.gui.control.getIsEnabled": "obtener está habilitado",
    "getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Obtiene si el control está habilitado",
    "bitbybit.babylon.gui.container.addControls": "añadir controles",
    "addControls": "añadir controles",
    "bitbybit.babylon.gui.container.addControls_description": "Añade controles al contenedor y mantiene el orden",
    "controls": "controles",
    "BABYLON.GUI.Control[]": "array de control gui de babylon",
    "clearControlsFirst": "limpiar controles primero",
    "bitbybit.babylon.gui.container.setBackground": "establecer fondo",
    "setBackground": "establecer fondo",
    "bitbybit.babylon.gui.container.setBackground_description": "Establece el fondo del contenedor",
    "background": "fondo",
    "bitbybit.babylon.gui.container.setIsReadonly": "establecer solo lectura",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Establece si el contenedor es de solo lectura",
    "bitbybit.babylon.gui.container.getBackground": "obtener fondo",
    "getBackground": "obtener fondo",
    "bitbybit.babylon.gui.container.getBackground_description": "Obtiene el fondo del contenedor",
    "bitbybit.babylon.gui.container.getIsReadonly": "obtener es solo lectura",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Obtiene si el contenedor es de solo lectura",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "panel de apilamiento",
    "stackPanel": "panel de apilamiento",
    "createStackPanel": "panel de apilamiento",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "crea un panel de apilamiento",
    "isVertical": "es vertical",
    "spacing": "espaciado",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "establecer es vertical",
    "setIsVertical": "establecer es vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Establece si el panel de pila es vertical",
    "BABYLON.GUI.StackPanel": "panel de apilamiento gui de babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "establecer espaciado",
    "setSpacing": "establecer espaciado",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Establece espaciado del panel de pila",
    "bitbybit.babylon.gui.stackPanel.setWidth": "establecer ancho",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Establece ancho del panel de pila",
    "bitbybit.babylon.gui.stackPanel.setHeight": "establecer altura",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Establece altura del panel de pila",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "obtener es vertical",
    "getIsVertical": "obtener es vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Obtiene si el panel de pila es vertical",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "obtener espaciado",
    "getSpacing": "obtener espaciado",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Obtiene espaciado del panel de pila",
    "bitbybit.babylon.gui.stackPanel.getWidth": "obtener ancho",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Obtiene ancho del panel de pila",
    "bitbybit.babylon.gui.stackPanel.getHeight": "obtener altura",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Obtiene altura del panel de pila",
    "bitbybit.babylon.gui.button.createSimpleButton": "botón simple",
    "button": "botón",
    "createSimpleButton": "botón simple",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "crea un botón simple",
    "label": "etiqueta",
    "bitbybit.babylon.gui.button.setButtonText": "establecer texto de botón",
    "setButtonText": "establecer texto de botón",
    "bitbybit.babylon.gui.button.setButtonText_description": "Establece texto del botón",
    "BABYLON.GUI.Button": "botón gui de babylon",
    "text": "texto",
    "bitbybit.babylon.gui.button.getButtonText": "obtener texto de botón",
    "getButtonText": "obtener texto de botón",
    "bitbybit.babylon.gui.button.getButtonText_description": "Obtiene texto del botón",
    "bitbybit.babylon.gui.slider.createSlider": "deslizador",
    "slider": "deslizador",
    "createSlider": "deslizador",
    "bitbybit.babylon.gui.slider.createSlider_description": "crea un deslizador",
    "minimum": "mínimo",
    "maximum": "máximo",
    "value": "valor",
    "step": "paso",
    "displayThumb": "mostrar pulgar",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "cambiar pulgar del deslizador",
    "changeSliderThumb": "cambiar pulgar del deslizador",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "cambia las propiedades del pulgar del deslizador",
    "BABYLON.GUI.Slider": "deslizador gui de babylon",
    "isThumbCircle": "es pulgar circular",
    "thumbColor": "color del pulgar",
    "thumbWidth": "ancho del pulgar",
    "string | number": "cadena o número",
    "isThumbClamped": "está pulgar limitado",
    "bitbybit.babylon.gui.slider.setBorderColor": "establecer color de borde",
    "setBorderColor": "establecer color de borde",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Cambia color del borde del deslizador",
    "borderColor": "color de borde",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "establecer color de fondo",
    "setBackgroundColor": "establecer color de fondo",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Cambia color de fondo del deslizador",
    "backgroundColor": "color de fondo",
    "bitbybit.babylon.gui.slider.setMaximum": "establecer máximo",
    "setMaximum": "establecer máximo",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Cambia valor máximo del deslizador",
    "bitbybit.babylon.gui.slider.setMinimum": "establecer mínimo",
    "setMinimum": "establecer mínimo",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Cambia valor mínimo del deslizador",
    "bitbybit.babylon.gui.slider.setStep": "establecer paso",
    "setStep": "establecer paso",
    "bitbybit.babylon.gui.slider.setStep_description": "Cambia valor de paso del deslizador",
    "bitbybit.babylon.gui.slider.setValue": "establecer valor",
    "setValue": "establecer valor",
    "bitbybit.babylon.gui.slider.setValue_description": "Cambia valor del deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "selector observable de deslizador",
    "createSliderObservableSelector": "selector observable de deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Crea el selector de un observable para un deslizador",
    "sliderObservableSelectorEnum": "enum de selector observable de deslizador",
    "bitbybit.babylon.gui.slider.getBorderColor": "obtener color de borde",
    "getBorderColor": "obtener color de borde",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Obtiene el color del borde del deslizador",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "obtener color de fondo",
    "getBackgroundColor": "obtener color de fondo",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Obtiene el color de fondo del deslizador",
    "bitbybit.babylon.gui.slider.getMaximum": "obtener máximo",
    "getMaximum": "obtener máximo",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Obtiene el valor máximo del deslizador",
    "bitbybit.babylon.gui.slider.getMinimum": "obtener mínimo",
    "getMinimum": "obtener mínimo",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Obtiene el valor mínimo del deslizador",
    "bitbybit.babylon.gui.slider.getStep": "obtener paso",
    "getStep": "obtener paso",
    "bitbybit.babylon.gui.slider.getStep_description": "Obtiene el valor de paso del deslizador",
    "bitbybit.babylon.gui.slider.getValue": "obtener valor",
    "getValue": "obtener valor",
    "bitbybit.babylon.gui.slider.getValue_description": "Obtiene el valor del deslizador",
    "bitbybit.babylon.gui.slider.getThumbColor": "obtener color del pulgar",
    "getThumbColor": "obtener color del pulgar",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Obtiene el color del pulgar del deslizador",
    "bitbybit.babylon.gui.slider.getThumbWidth": "obtener ancho del pulgar",
    "getThumbWidth": "obtener ancho del pulgar",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Obtiene el ancho del pulgar del deslizador",
    "bitbybit.babylon.gui.slider.getIsVertical": "obtener es vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Obtiene si el deslizador es vertical",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "obtener mostrar pulgar",
    "getDisplayThumb": "obtener mostrar pulgar",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Obtiene si mostrar pulgar del deslizador",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "obtener es pulgar circular",
    "getIsThumbCircle": "obtener es pulgar circular",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Obtiene si el pulgar del deslizador es círculo",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "obtener está pulgar limitado",
    "getIsThumbClamped": "obtener está pulgar limitado",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Obtiene si el pulgar del deslizador está restringido",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "bloque de texto",
    "textBlock": "bloque de texto",
    "createTextBlock": "bloque de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "crea un bloque de texto",
    "bitbybit.babylon.gui.textBlock.alignText": "alinear texto",
    "alignText": "alinear texto",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Cambia la alineación para el texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "establecer contorno de texto",
    "setTextOutline": "establecer contorno de texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Cambia el contorno de texto para el texto",
    "BABYLON.GUI.TextBlock": "bloque de texto gui de babylon",
    "outlineWidth": "ancho de contorno",
    "outlineColor": "color de contorno",
    "bitbybit.babylon.gui.textBlock.setText": "establecer texto",
    "setText": "establecer texto",
    "bitbybit.babylon.gui.textBlock.setText_description": "Establece el nuevo texto al bloque de texto",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "establecer redimensionar para ajustar",
    "setRsizeToFit": "establecer redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Habilita o deshabilita redimensionar para ajustar",
    "resizeToFit": "redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "establecer ajuste de texto",
    "setTextWrapping": "establecer ajuste de texto",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Establece el nuevo ajuste de texto al bloque de texto",
    "textWrapping": "ajuste de texto",
    "boolean | BABYLON.GUI.TextWrapping": "booleano o ajuste de texto gui de babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "establecer interlineado",
    "setLineSpacing": "establecer interlineado",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Establece el espaciado de línea del texto",
    "lineSpacing": "interlineado",
    "bitbybit.babylon.gui.textBlock.getText": "obtener texto",
    "getText": "obtener texto",
    "bitbybit.babylon.gui.textBlock.getText_description": "Obtiene el texto del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "obtener ajuste de texto",
    "getTextWrapping": "obtener ajuste de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Obtiene el ajuste de texto del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "obtener interlineado",
    "getLineSpacing": "obtener interlineado",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Obtiene el espaciado de línea del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "obtener ancho de contorno",
    "getOutlineWidth": "obtener ancho de contorno",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Obtiene el ancho del contorno del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "obtener redimensionar para ajustar",
    "getResizeToFit": "obtener redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Obtiene el redimensionar para ajustar del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "obtener alineación horizontal de texto",
    "getTextHorizontalAlignment": "obtener alineación horizontal de texto",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Obtiene la alineación horizontal de texto del bloque de texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "obtener alineación vertical de texto",
    "getTextVerticalAlignment": "obtener alineación vertical de texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Obtiene la alineación vertical de texto del bloque de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "selector observable de bloque de texto",
    "createTextBlockObservableSelector": "selector observable de bloque de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Crea el selector de un observable para un bloque de texto",
    "textBlockObservableSelectorEnum": "enum de selector observable de bloque de texto",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "botón de radio",
    "radioButton": "botón de radio",
    "createRadioButton": "botón de radio",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "crea un botón de radio",
    "group": "grupo",
    "isChecked": "está marcado",
    "checkSizeRatio": "ratio de tamaño de marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "establecer ratio de tamaño de marca",
    "setCheckSizeRatio": "establecer ratio de tamaño de marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Establece la proporción de tamaño de marca del botón de radio",
    "BABYLON.GUI.RadioButton": "botón de radio gui de babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "establecer grupo",
    "setGroup": "establecer grupo",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Establece el grupo del botón de radio",
    "bitbybit.babylon.gui.radioButton.setBackground": "establecer fondo",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Establece el fondo del botón de radio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "obtener ratio de tamaño de marca",
    "getCheckSizeRatio": "obtener ratio de tamaño de marca",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Obtiene la proporción de tamaño de marca del botón de radio",
    "bitbybit.babylon.gui.radioButton.getGroup": "obtener grupo",
    "getGroup": "obtener grupo",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Obtiene el grupo del botón de radio",
    "bitbybit.babylon.gui.radioButton.getBackground": "obtener fondo",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Obtiene el fondo del botón de radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "selector observable de botón de radio",
    "createRadioButtonObservableSelector": "selector observable de botón de radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Crea el selector de un observable para el botón de radio",
    "radioButtonObservableSelectorEnum": "enum de selector observable de botón de radio",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "casilla de verificación",
    "checkbox": "casilla de verificación",
    "createCheckbox": "casilla de verificación",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "crea una casilla de verificación",
    "bitbybit.babylon.gui.checkbox.setBackground": "establecer fondo",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Establece el fondo de la casilla de verificación",
    "BABYLON.GUI.Checkbox": "casilla de verificación gui de babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "establecer ratio de tamaño de marca",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Establece la proporción de tamaño de marca de la casilla de verificación",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "establecer está marcado",
    "setIsChecked": "establecer está marcado",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Establece si la casilla de verificación está marcada",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "obtener ratio de tamaño de marca",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Obtiene la proporción de tamaño de marca",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "obtener está marcado",
    "getIsChecked": "obtener está marcado",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Obtiene si está marcada",
    "bitbybit.babylon.gui.checkbox.getBackground": "obtener fondo",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Obtiene el fondo",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "selector observable de casilla de verificación",
    "createCheckboxObservableSelector": "selector observable de casilla de verificación",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Crea el selector de un observable para la casilla de verificación",
    "checkboxObservableSelectorEnum": "enum de selector observable de casilla de verificación",
    "bitbybit.babylon.gui.inputText.createInputText": "entrada de texto",
    "inputText": "entrada de texto",
    "createInputText": "entrada de texto",
    "bitbybit.babylon.gui.inputText.createInputText_description": "crea una entrada de texto",
    "placeholder": "marcador de posición",
    "bitbybit.babylon.gui.inputText.setBackground": "establecer fondo",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Establece el fondo del texto de entrada",
    "BABYLON.GUI.InputText": "entrada de texto gui de babylon",
    "bitbybit.babylon.gui.inputText.setText": "establecer texto",
    "bitbybit.babylon.gui.inputText.setText_description": "Establece el texto del texto de entrada",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "establecer marcador de posición",
    "setPlaceholder": "establecer marcador de posición",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Establece el marcador de posición del texto de entrada",
    "bitbybit.babylon.gui.inputText.getBackground": "obtener fondo",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Obtiene el fondo del texto de entrada",
    "bitbybit.babylon.gui.inputText.getText": "obtener texto",
    "bitbybit.babylon.gui.inputText.getText_description": "Obtiene el texto del texto de entrada",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "obtener marcador de posición",
    "getPlaceholder": "obtener marcador de posición",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Obtiene el marcador de posición del texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "selector observable de entrada de texto",
    "createInputTextObservableSelector": "selector observable de entrada de texto",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Crea el selector de un observable para el texto de entrada",
    "inputTextObservableSelectorEnum": "enum de selector observable de entrada de texto",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "selector de color",
    "colorPicker": "selector de color",
    "createColorPicker": "selector de color",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "crea un selector de color",
    "defaultColor": "color predeterminado",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "establecer valor de selector de color",
    "setColorPickerValue": "establecer valor de selector de color",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Establece color del valor del selector de color",
    "BABYLON.GUI.ColorPicker": "selector de color gui de babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "establecer tamaño de selector de color",
    "setColorPickerSize": "establecer tamaño de selector de color",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Establece tamaño del selector de color (ancho y alto)",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "obtener valor de selector de color",
    "getColorPickerValue": "obtener valor de selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Obtiene color del valor del selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "obtener tamaño de selector de color",
    "getColorPickerSize": "obtener tamaño de selector de color",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "obtiene el tamaño del selector de color",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "selector observable de selector de color",
    "createColorPickerObservableSelector": "selector observable de selector de color",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Crea el selector de un observable para el selector de color",
    "colorPickerObservableSelectorEnum": "enum de selector observable de selector de color",
    "bitbybit.babylon.gui.image.createImage": "imagen",
    "image": "imagen",
    "createImage": "imagen",
    "bitbybit.babylon.gui.image.createImage_description": "crea una imagen",
    "bitbybit.babylon.gui.image.setSourceUrl": "establecer url de origen",
    "setSourceUrl": "establecer url de origen",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "establece la url de origen de la imagen",
    "BABYLON.GUI.Image": "imagen gui de babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "obtener url de origen",
    "getSourceUrl": "obtener url de origen",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "obtiene la url de origen de la imagen",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gestor de gizmo",
    "gizmo": "gizmo",
    "manager": "gestor",
    "createGizmoManager": "gestor de gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Crea gestor de gizmo",
    "positionGizmoEnabled": "gizmo de posición habilitado",
    "rotationGizmoEnabled": "gizmo de rotación habilitado",
    "scaleGizmoEnabled": "gizmo de escala habilitado",
    "boundingBoxGizmoEnabled": "gizmo de caja delimitadora habilitado",
    "usePointerToAttachGizmos": "usar puntero para adjuntar gizmos",
    "clearGizmoOnEmptyPointerEvent": "limpiar gizmo en evento de puntero vacío",
    "scaleRatio": "ratio de escala",
    "attachableMeshes": "mallas adjuntables",
    "BABYLON.AbstractMesh[]": "array de malla abstracta de babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "obtener gizmo de posición",
    "getPositionGizmo": "obtener gizmo de posición",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Obtiene gizmo de posición",
    "gizmoManager": "gestor de gizmo",
    "BABYLON.GizmoManager": "gestor de gizmo de babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "obtener gizmo de rotación",
    "getRotationGizmo": "obtener gizmo de rotación",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Obtiene gizmo de rotación",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "obtener gizmo de escala",
    "getScaleGizmo": "obtener gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Obtiene gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "obtener gizmo de caja delimitadora",
    "getBoundingBoxGizmo": "obtener gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Obtiene gizmo de cuadro delimitador",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "adjuntar a malla",
    "attachToMesh": "adjuntar a malla",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Adjunta gestor de gizmo a malla",
    "update": "actualizar",
    "bitbybit.babylon.gizmo.manager.detachMesh": "desadjuntar malla",
    "detachMesh": "desadjuntar malla",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Separa gestor de gizmo de malla",
    "bitbybit.babylon.gizmo.base.scaleRatio": "establecer ratio de escala",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Establece proporción de escala de gizmo",
    "BABYLON.IGizmo": "i gizmo de babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "obtener ratio de escala",
    "getScaleRatio": "obtener ratio de escala",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Obtiene proporción de escala",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "establecer gizmo planar habilitado",
    "positionGizmo": "gizmo de posición",
    "planarGizmoEnabled": "gizmo planar habilitado",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Establece gizmo planar habilitado",
    "BABYLON.IPositionGizmo": "i gizmo de posición de babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "establecer distancia de ajuste",
    "snapDistance": "distancia de ajuste",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Establece distancia de ajuste de gizmo de posición",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "obtener malla adjunta",
    "getAttachedMesh": "obtener malla adjunta",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Obtiene malla adjunta",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "obtener nodo adjunto",
    "getAttachedNode": "obtener nodo adjunto",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Obtiene nodo adjunto",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "obtener gizmo x",
    "getXGizmo": "obtener gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Obtiene gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "obtener gizmo y",
    "getYGizmo": "obtener gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Obtiene gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "obtener gizmo z",
    "getZGizmo": "obtener gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Obtiene gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "obtener gizmo de plano x",
    "getXPlaneGizmo": "obtener gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Obtiene gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "obtener gizmo de plano y",
    "getYPlaneGizmo": "obtener gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Obtiene gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "obtener gizmo de plano z",
    "getZPlaneGizmo": "obtener gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Obtiene gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "obtener gizmo planar habilitado",
    "getPlanarGizmoEnabled": "obtener gizmo planar habilitado",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Obtiene si gizmo planar habilitado",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "obtener distancia de ajuste",
    "getSnapDistance": "obtener distancia de ajuste",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Obtiene distancia de ajuste",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "obtener está arrastrando",
    "getIsDragging": "obtener está arrastrando",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Obtiene si se está arrastrando",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "selector observable de gizmo de posición",
    "createPositionGizmoObservableSelector": "selector observable de gizmo de posición",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Crea el selector de un observable para un gizmo de posición",
    "positionGizmoObservableSelectorEnum": "enum de selector observable de gizmo de posición",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "establecer distancia de ajuste",
    "rotationGizmo": "gizmo de rotación",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Establece distancia de ajuste de gizmo de rotación",
    "BABYLON.IRotationGizmo": "i gizmo de rotación de babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "establecer sensibilidad",
    "sensitivity": "sensibilidad",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Establece sensibilidad de gizmo de rotación",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "obtener malla adjunta",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Obtiene malla adjunta",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "obtener nodo adjunto",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Obtiene nodo adjunto",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "obtener gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Obtiene gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "obtener gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Obtiene gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "obtener gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Obtiene gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "obtener distancia de ajuste",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Obtiene distancia de ajuste",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "obtener sensibilidad",
    "getSensitivity": "obtener sensibilidad",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Obtiene sensibilidad",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "selector observable de gizmo de rotación",
    "createRotationGizmoObservableSelector": "selector observable de gizmo de rotación",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Crea el selector de un observable para un gizmo de rotación",
    "rotationGizmoObservableSelectorEnum": "enum de selector observable de gizmo de rotación",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "obtener gizmo x",
    "scaleGizmo": "gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Obtiene gizmo x",
    "BABYLON.IScaleGizmo": "i gizmo de escala de babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "obtener gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Obtiene gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "obtener gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Obtiene gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "establecer distancia de ajuste",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Establece distancia de ajuste de gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "establecer ajuste incremental",
    "setIncrementalSnap": "establecer ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Establece ajuste incremental de gizmo de escala",
    "incrementalSnap": "ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "establecer sensibilidad",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Establece sensibilidad de gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "obtener ajuste incremental",
    "getIncrementalSnap": "obtener ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Obtiene ajuste incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "obtener distancia de ajuste",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Obtiene distancia de ajuste",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "obtener sensibilidad",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Obtiene sensibilidad",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "selector observable de gizmo de escala",
    "createScaleGizmoObservableSelector": "selector observable de gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Crea el selector de un observable para un gizmo de escala",
    "scaleGizmoObservableSelectorEnum": "enum de selector observable de gizmo de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "establecer tamaño de esfera de rotación",
    "boundingBoxGizmo": "gizmo de caja delimitadora",
    "setRotationSphereSize": "establecer tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Establece tamaño de esfera de rotación de gizmo de cuadro delimitador",
    "BABYLON.BoundingBoxGizmo": "gizmo de caja delimitadora de babylon",
    "rotationSphereSize": "tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "establecer tamaño de pantalla de malla de arrastre fijo",
    "setFixedDragMeshScreenSize": "establecer tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "Si se establece, los anclajes de rotación y cajas de escala aumentarán de tamaño según la distancia de la cámara para tener un tamaño de pantalla consistente (Predeterminado: false) Nota: fixedDragMeshScreenSize tiene prioridad sobre fixedDragMeshBoundsSize si ambos son verdaderos",
    "fixedDragMeshScreenSize": "tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "establecer tamaño de límites de malla de arrastre fijo",
    "setFixedDragMeshBoundsSize": "establecer tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Establece tamaño de límites de malla de arrastre fijo de gizmo de cuadro delimitador",
    "fixedDragMeshBoundsSize": "tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "establecer factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "setFixedDragMeshScreenSizeDistanceFactor": "establecer factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "La distancia del objeto a la que las mallas arrastrables deberían aparecer de tamaño mundial cuando fixedDragMeshScreenSize se establece en verdadero (predeterminado: 10)",
    "fixedDragMeshScreenSizeDistanceFactor": "factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "establecer distancia de ajuste de escala",
    "setScalingSnapDistance": "establecer distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Establece distancia de ajuste de escalado de gizmo de cuadro delimitador. Distancia de arrastre en unidades de babylon a la que el gizmo ajustará el escalado cuando se arrastre.",
    "scalingSnapDistance": "distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "establecer distancia de ajuste de rotación",
    "setRotationSnapDistance": "establecer distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Establece distancia de ajuste de rotación de gizmo de cuadro delimitador. Distancia de arrastre en unidades de babylon a la que el gizmo ajustará la rotación cuando se arrastre.",
    "rotationSnapDistance": "distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "establecer tamaño de caja de escala",
    "setScaleBoxSize": "establecer tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Establece tamaño de caja de escala de gizmo de cuadro delimitador",
    "scaleBoxSize": "tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "establecer ajuste incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Establece ajuste incremental de gizmo de cuadro delimitador. Escalado de ajuste incremental (predeterminado es falso). Cuando es verdadero, con una snapDistance de 0.1, el escalado será 1.1,1.2,1.3 en lugar de, cuando falso: 1.1,1.21,1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "establecer pivote de escala",
    "setScalePivot": "establecer pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Establece pivote de escala de gizmo de cuadro delimitador. Pivote relativo de cuadro delimitador usado al escalar el nodo adjunto. Cuando es nulo objeto con escala desde la esquina opuesta. 0.5,0.5,0.5 para centro y 0.5,0,0.5 para abajo (Predeterminado: nulo)",
    "scalePivot": "pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "establecer factor de eje",
    "setAxisFactor": "establecer factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Establece factor de eje de gizmo de cuadro delimitador. Establecer valor de sensibilidad personalizado para cada eje",
    "axisFactor": "factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "establecer velocidad de arrastre de escala",
    "setScaleDragSpeed": "establecer velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Establece velocidad de arrastre de escala de gizmo de cuadro delimitador",
    "scaleDragSpeed": "velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "obtener tamaño de esfera de rotación",
    "getRotationSphereSize": "obtener tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Obtiene tamaño de esfera de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "obtener tamaño de caja de escala",
    "getScaleBoxSize": "obtener tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Obtiene tamaño de caja de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "obtener tamaño de pantalla de malla de arrastre fijo",
    "getFixedDragMeshScreenSize": "obtener tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Obtiene tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "obtener tamaño de límites de malla de arrastre fijo",
    "getFixedDragMeshBoundsSize": "obtener tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Obtiene tamaño de límites de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "obtener factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "getFixedDragMeshScreenSizeDistanceFactor": "obtener factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Obtiene factor de distancia de tamaño de pantalla de malla de arrastre fijo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "obtener distancia de ajuste de escala",
    "getScalingSnapDistance": "obtener distancia de ajuste de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Obtiene distancia de ajuste de escalado",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "obtener distancia de ajuste de rotación",
    "getRotationSnapDistance": "obtener distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Obtiene distancia de ajuste de rotación",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "obtener ajuste incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Obtiene ajuste incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "obtener pivote de escala",
    "getScalePivot": "obtener pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Obtiene pivote de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "obtener factor de eje",
    "getAxisFactor": "obtener factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Obtiene factor de eje",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "obtener velocidad de arrastre de escala",
    "getScaleDragSpeed": "obtener velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Obtiene velocidad de arrastre de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "selector observable de gizmo de caja delimitadora",
    "createBoundingBoxGizmoObservableSelector": "selector observable de gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Crea el selector de un observable para un gizmo de cuadro delimitador",
    "boundingBoxGizmoObservableSelectorEnum": "enum de selector observable de gizmo de caja delimitadora",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "establecer habilitado",
    "axisDragGizmo": "gizmo de arrastre de eje",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Establece si el eje está habilitado o no",
    "BABYLON.IAxisDragGizmo": "i gizmo de arrastre de eje de babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Comprueba si el eje está habilitado",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "establecer habilitado",
    "axisScaleGizmo": "gizmo de escala de eje",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Establece si el eje está habilitado o no",
    "BABYLON.IAxisScaleGizmo": "i gizmo de escala de eje de babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Comprueba si el eje está habilitado",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "establecer habilitado",
    "planeDragGizmo": "gizmo de arrastre de plano",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Establece si el plano está habilitado o no",
    "BABYLON.IPlaneDragGizmo": "i gizmo de arrastre de plano de babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Comprueba si el plano está habilitado",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "establecer habilitado",
    "planeRotationGizmo": "gizmo de rotación de plano",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Establece si el plano está habilitado o no",
    "BABYLON.IPlaneRotationGizmo": "i gizmo de rotación de plano de babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "obtener está habilitado",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Comprueba si el plano está habilitado",
    "bitbybit.vector.removeAllDuplicateVectors": "eliminar todos los vectores duplicados",
    "vector": "vector",
    "removeAllDuplicateVectors": "eliminar todos los vectores duplicados",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Elimina todos los vectores duplicados del array de entrada (mantiene solo vectores únicos). Ejemplo: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]] → [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "eliminar",
    "vectors": "vectores",
    "number[][]": "array de array de números",
    "tolerance": "tolerancia",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "eliminar vectores duplicados consecutivos",
    "removeConsecutiveDuplicateVectors": "eliminar vectores duplicados consecutivos",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Elimina vectores duplicados consecutivos del array de entrada (solo elimina duplicados que aparecen uno al lado del otro). Ejemplo: [[1,2], [1,2], [3,4], [1,2]] → [[1,2], [3,4], [1,2]] (solo eliminó duplicado consecutivo)",
    "checkFirstAndLast": "comprobar primero y último",
    "bitbybit.vector.angleBetween": "ángulo entre",
    "angleBetween": "ángulo entre",
    "bitbybit.vector.angleBetween_description": "Mide el ángulo entre dos vectores en grados (siempre devuelve ángulo positivo 0-180°). Ejemplo: [1,0,0] y [0,1,0] → 90° (vectores perpendiculares)",
    "angles": "ángulos",
    "first": "primero",
    "second": "segundo",
    "bitbybit.vector.angleBetweenNormalized2d": "ángulo entre normalizados 2d",
    "angleBetweenNormalized2d": "ángulo entre normalizados 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Mide el ángulo normalizado 2D entre dos vectores en grados (considera dirección, puede ser negativo). Ejemplo: [1,0] a [0,1] → 90°, [0,1] a [1,0] → -90°",
    "bitbybit.vector.positiveAngleBetween": "ángulo positivo entre",
    "positiveAngleBetween": "ángulo positivo entre",
    "bitbybit.vector.positiveAngleBetween_description": "Mide un ángulo positivo entre dos vectores dado el vector de referencia en grados (siempre 0-360°). Ejemplo: convierte ángulos con signo negativo a positivos sumando 360° cuando es necesario",
    "reference": "referencia",
    "bitbybit.vector.addAll": "sumar todos",
    "addAll": "sumar todos",
    "bitbybit.vector.addAll_description": "Suma todos los valores xyz del vector elemento por elemento y crea un nuevo vector. Ejemplo: [[1,2,3], [4,5,6], [7,8,9]] → [12,15,18] (suma cada columna)",
    "sum": "suma",
    "bitbybit.vector.add": "sumar",
    "add": "sumar",
    "bitbybit.vector.add_description": "Suma dos vectores elemento por elemento. Ejemplo: [1,2,3] + [4,5,6] → [5,7,9]",
    "bitbybit.vector.all": "todos",
    "all": "todos",
    "bitbybit.vector.all_description": "Comprueba si el array booleano contiene solo valores verdaderos, devuelve falso si hay un solo falso. Ejemplo: [true, true, true] → true, [true, false, true] → false",
    "boolean[]": "array booleano",
    "bitbybit.vector.cross": "producto vectorial",
    "cross": "producto vectorial",
    "bitbybit.vector.cross_description": "Calcula el producto cruz de dos vectores 3D (vector perpendicular a ambas entradas). Ejemplo: [1,0,0] × [0,1,0] → [0,0,1] (regla de la mano derecha)",
    "bitbybit.vector.distSquared": "distancia al cuadrado",
    "distSquared": "distancia al cuadrado",
    "bitbybit.vector.distSquared_description": "Calcula la distancia al cuadrado entre dos vectores (más rápido que la distancia, evita raíz cuadrada). Ejemplo: [0,0,0] a [3,4,0] → 25 (distancia 5 al cuadrado)",
    "bitbybit.vector.dist": "distancia",
    "dist": "distancia",
    "bitbybit.vector.dist_description": "Calcula la distancia euclidiana entre dos vectores. Ejemplo: [0,0,0] a [3,4,0] → 5, [1,1] a [4,5] → 5",
    "bitbybit.vector.div": "dividir",
    "div": "dividir",
    "bitbybit.vector.div_description": "Divide cada elemento del vector por un valor escalar. Ejemplo: [10,20,30] ÷ 2 → [5,10,15]",
    "scalar": "escalar",
    "bitbybit.vector.domain": "dominio",
    "domain": "dominio",
    "bitbybit.vector.domain_description": "Calcula el dominio (rango) entre valores mínimos y máximos del vector. Ejemplo: [1,3,5,9] → 8 (diferencia entre último y primero: 9-1)",
    "bitbybit.vector.dot": "producto escalar",
    "dot": "producto escalar",
    "bitbybit.vector.dot_description": "Calcula el producto punto entre dos vectores (mide similitud/proyección). Ejemplo: [1,2,3] • [4,5,6] → 32 (1×4 + 2×5 + 3×6), vectores perpendiculares → 0",
    "bitbybit.vector.finite": "finito",
    "finite": "finito",
    "bitbybit.vector.finite_description": "Comprueba si cada elemento en el vector es finito y devuelve un array booleano. Ejemplo: [1, 2, Infinity, 3] → [true, true, false, true]",
    "validate": "validar",
    "bitbybit.vector.isZero": "es cero",
    "isZero": "es cero",
    "bitbybit.vector.isZero_description": "Comprueba si el vector tiene longitud cero (todos los elementos son cero). Ejemplo: [0,0,0] → true, [0,0,0.001] → false",
    "bitbybit.vector.lerp": "interpolación lineal",
    "lerp": "interpolación lineal",
    "bitbybit.vector.lerp_description": "Encuentra un vector interpolado entre dos vectores usando una fracción (interpolación lineal). Ejemplo: [0,0,0] a [10,10,10] en 0.5 → [5,5,5], fracción=0 → primero, fracción=1 → segundo",
    "fraction": "fracción",
    "bitbybit.vector.max": "máximo",
    "max": "máximo",
    "bitbybit.vector.max_description": "Encuentra el valor máximo (más grande) en el vector. Ejemplo: [3, 7, 2, 9, 1] → 9",
    "extract": "extraer",
    "bitbybit.vector.min": "mínimo",
    "min": "mínimo",
    "bitbybit.vector.min_description": "Encuentra el valor mínimo (más pequeño) en el vector. Ejemplo: [3, 7, 2, 9, 1] → 1",
    "bitbybit.vector.mul": "multiplicar",
    "mul": "multiplicar",
    "bitbybit.vector.mul_description": "Multiplica cada elemento del vector por un valor escalar. Ejemplo: [2,3,4] × 5 → [10,15,20]",
    "bitbybit.vector.neg": "negar",
    "neg": "negar",
    "bitbybit.vector.neg_description": "Niega el vector (invierte el signo de cada elemento). Ejemplo: [5,-3,2] → [-5,3,-2]",
    "bitbybit.vector.normSquared": "norma al cuadrado",
    "normSquared": "norma al cuadrado",
    "bitbybit.vector.normSquared_description": "Calcula la norma al cuadrado (magnitud/longitud al cuadrado) del vector. Ejemplo: [3,4,0] → 25 (longitud 5 al cuadrado)",
    "bitbybit.vector.norm": "norma",
    "norm": "norma",
    "bitbybit.vector.norm_description": "Calcula la norma (magnitud/longitud) del vector. Ejemplo: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.vector.normalized": "normalizado",
    "normalized": "normalizado",
    "bitbybit.vector.normalized_description": "Normaliza el vector en un vector unitario que tiene una longitud de 1 (mantiene la dirección, escala la magnitud a 1). Ejemplo: [3,4,0] → [0.6,0.8,0], [10,0,0] → [1,0,0]",
    "bitbybit.vector.onRay": "en rayo",
    "onRay": "en rayo",
    "bitbybit.vector.onRay_description": "Encuentra un punto en un rayo a una distancia dada desde el origen a lo largo del vector de dirección. Ejemplo: Punto [0,0,0] + dirección [1,0,0] a distancia 5 → [5,0,0]",
    "bitbybit.vector.vectorXYZ": "vector xyz",
    "vectorXYZ": "vector xyz",
    "bitbybit.vector.vectorXYZ_description": "Crea un vector 3D a partir de coordenadas x, y, z. Ejemplo: x=1, y=2, z=3 → [1,2,3]",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vector xy",
    "vectorXY": "vector xy",
    "bitbybit.vector.vectorXY_description": "Crea un vector 2D a partir de coordenadas x, y. Ejemplo: x=3, y=4 → [3,4]",
    "bitbybit.vector.range": "rango",
    "range": "rango",
    "bitbybit.vector.range_description": "Crea un vector de enteros de 0 a max (exclusivo). Ejemplo: max=5 → [0,1,2,3,4], max=3 → [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "ángulo con signo entre",
    "signedAngleBetween": "ángulo con signo entre",
    "bitbybit.vector.signedAngleBetween_description": "Calcula ángulo con signo entre dos vectores usando un vector de referencia (determina la dirección de rotación). Ejemplo: Devuelve ángulo positivo o negativo dependiendo de la dirección de rotación relativa a la referencia",
    "bitbybit.vector.span": "intervalo",
    "span": "intervalo",
    "bitbybit.vector.span_description": "Crea un vector conteniendo números de min a max con un incremento de paso dado. Ejemplo: min=0, max=10, step=2 → [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "intervalo con elementos suavizados",
    "spanEaseItems": "intervalo con elementos suavizados",
    "bitbybit.vector.spanEaseItems_description": "Crea un vector con números de min a max usando una función de easing para distribución no lineal. Ejemplo: min=0, max=100, nrItems=5, ease='easeInQuad' → crea intervalos acelerados",
    "nrItems": "número de elementos",
    "ease": "suavizado",
    "Math.easeEnum": "enum de suavizado matemático",
    "intervals": "intervalos",
    "bitbybit.vector.spanLinearItems": "intervalo con elementos lineales",
    "spanLinearItems": "intervalo con elementos lineales",
    "bitbybit.vector.spanLinearItems_description": "Crea un vector con números espaciados uniformemente de min a max con un número específico de elementos. Ejemplo: min=0, max=10, nrItems=5 → [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "restar",
    "sub": "restar",
    "bitbybit.vector.sub_description": "Resta el segundo vector del primero elemento por elemento. Ejemplo: [10,20,30] - [1,2,3] → [9,18,27]",
    "bitbybit.vector.sum": "suma",
    "bitbybit.vector.sum_description": "Suma todos los valores en el vector y devuelve un solo número. Ejemplo: [1,2,3,4] → 10, [5,10,15] → 30",
    "bitbybit.point.transformPoint": "transformar punto",
    "transformPoint": "transformar punto",
    "bitbybit.point.transformPoint_description": "Aplica matriz de transformación a un solo punto (rota, escala o traslada). Ejemplo: punto=[0,0,0] con traslación [5,5,0] → [5,5,0]",
    "transformation": "transformación",
    "Base.TransformMatrixes": "matrices de transformación base",
    "bitbybit.point.transformPoints": "transformar puntos",
    "transformPoints": "transformar puntos",
    "bitbybit.point.transformPoints_description": "Aplica la misma matriz de transformación a múltiples puntos (transformación por lotes). Ejemplo: 5 puntos con rotación 90° → todos los 5 puntos rotados juntos",
    "points": "puntos",
    "bitbybit.point.transformsForPoints": "transformaciones para puntos",
    "transformsForPoints": "transformaciones para puntos",
    "bitbybit.point.transformsForPoints_description": "Aplica diferentes matrices de transformación a puntos correspondientes (una transformación por punto). Los arrays deben tener igual longitud. Ejemplo: 3 puntos con 3 traslaciones diferentes → cada punto movido independientemente",
    "Base.TransformMatrixes[]": "array de matrices de transformación base",
    "bitbybit.point.translatePoints": "trasladar puntos",
    "translatePoints": "trasladar puntos",
    "bitbybit.point.translatePoints_description": "Mueve múltiples puntos por un vector de traslación (mismo desplazamiento para todos los puntos). Ejemplo: puntos=[[0,0,0], [1,0,0]], traslación=[5,5,0] → [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "trasladar puntos con vectores",
    "translatePointsWithVectors": "trasladar puntos con vectores",
    "bitbybit.point.translatePointsWithVectors_description": "Mueve múltiples puntos por vectores de traslación correspondientes (un vector por punto). Los arrays deben tener igual longitud. Ejemplo: 3 puntos con 3 vectores diferentes → cada punto movido por su vector correspondiente",
    "bitbybit.point.translateXYZPoints": "trasladar puntos xyz",
    "translateXYZPoints": "trasladar puntos xyz",
    "bitbybit.point.translateXYZPoints_description": "Mueve múltiples puntos por valores separados de X, Y, Z (método conveniente para traslación). Ejemplo: puntos=[[0,0,0]], x=10, y=5, z=0 → [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "escalar puntos centro xyz",
    "scalePointsCenterXYZ": "escalar puntos centro xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "Escala múltiples puntos alrededor de un punto central con diferentes factores por eje. Ejemplo: puntos=[[10,0,0]], centro=[5,0,0], scaleXyz=[2,1,1] → [[15,0,0]] (duplica distancia X desde el centro)",
    "bitbybit.point.rotatePointsCenterAxis": "rotar puntos centro eje",
    "rotatePointsCenterAxis": "rotar puntos centro eje",
    "bitbybit.point.rotatePointsCenterAxis_description": "Rota múltiples puntos alrededor de un punto central a lo largo de un eje personalizado. Ejemplo: puntos=[[10,0,0]], centro=[0,0,0], eje=[0,1,0], ángulo=90° → [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "distancia al punto más cercano desde puntos",
    "closestPointFromPointsDistance": "distancia al punto más cercano desde puntos",
    "bitbybit.point.closestPointFromPointsDistance_description": "Calcula la distancia al punto más cercano en una colección. Ejemplo: punto=[0,0,0], puntos=[[5,0,0], [10,0,0], [3,0,0]] → 3 (distancia a [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "índice del punto más cercano desde puntos",
    "closestPointFromPointsIndex": "índice del punto más cercano desde puntos",
    "bitbybit.point.closestPointFromPointsIndex_description": "Encuentra el índice del array del punto más cercano en una colección (índice basado en 1, no basado en 0). Ejemplo: punto=[0,0,0], puntos=[[5,0,0], [10,0,0], [3,0,0]] → 3 (índice de [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "punto más cercano desde puntos",
    "closestPointFromPoints": "punto más cercano desde puntos",
    "bitbybit.point.closestPointFromPoints_description": "Encuentra el punto más cercano en una colección a un punto de referencia. Ejemplo: punto=[0,0,0], puntos=[[5,0,0], [10,0,0], [3,0,0]] → [3,0,0]",
    "bitbybit.point.distance": "distancia",
    "bitbybit.point.distance_description": "Calcula la distancia euclidiana entre dos puntos. Ejemplo: inicio=[0,0,0], fin=[3,4,0] → 5 (usando teorema de Pitágoras: √(3²+4²))",
    "measure": "medir",
    "startPoint": "punto de inicio",
    "endPoint": "punto final",
    "bitbybit.point.distancesToPoints": "distancias a puntos",
    "distancesToPoints": "distancias a puntos",
    "bitbybit.point.distancesToPoints_description": "Calcula distancias desde un punto de inicio a múltiples puntos finales. Ejemplo: inicio=[0,0,0], puntosFinales=[[3,0,0], [0,4,0], [5,0,0]] → [3, 4, 5]",
    "endPoints": "puntos finales",
    "bitbybit.point.multiplyPoint": "multiplicar punto",
    "multiplyPoint": "multiplicar punto",
    "bitbybit.point.multiplyPoint_description": "Duplica un punto N veces (crea array con N copias del mismo punto). Ejemplo: punto=[5,5,0], cantidadPuntos=3 → [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "cantidad de puntos",
    "bitbybit.point.getX": "obtener x",
    "getX": "obtener x",
    "bitbybit.point.getX_description": "Extrae coordenada X de un punto. Ejemplo: punto=[5,10,3] → 5",
    "bitbybit.point.getY": "obtener y",
    "getY": "obtener y",
    "bitbybit.point.getY_description": "Extrae coordenada Y de un punto. Ejemplo: punto=[5,10,3] → 10",
    "bitbybit.point.getZ": "obtener z",
    "getZ": "obtener z",
    "bitbybit.point.getZ_description": "Extrae coordenada Z de un punto. Ejemplo: punto=[5,10,3] → 3",
    "bitbybit.point.averagePoint": "punto promedio",
    "averagePoint": "punto promedio",
    "bitbybit.point.averagePoint_description": "Calcula centroide (posición media) de múltiples puntos. Ejemplo: puntos=[[0,0,0], [10,0,0], [10,10,0]] → [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "punto xyz",
    "pointXYZ": "punto xyz",
    "bitbybit.point.pointXYZ_description": "Crea un punto 3D a partir de coordenadas X, Y, Z. Ejemplo: x=10, y=5, z=3 → [10,5,3]",
    "bitbybit.point.pointXY": "punto xy",
    "pointXY": "punto xy",
    "bitbybit.point.pointXY_description": "Crea un punto 2D a partir de coordenadas X, Y. Ejemplo: x=10, y=5 → [10,5]",
    "bitbybit.point.spiral": "espiral",
    "spiral": "espiral",
    "bitbybit.point.spiral_description": "Crea puntos de espiral logarítmica usando ángulo dorado o factor de ensanchamiento personalizado. Genera patrones de espiral naturales comunes en la naturaleza (girasol, concha nautilus). Ejemplo: numeroPuntos=100, radio=10, phi=1.618 → 100 puntos formando espiral hacia afuera",
    "phi": "phi",
    "numberPoints": "número de puntos",
    "widening": "ensanchamiento",
    "factor": "factor",
    "bitbybit.point.hexGrid": "cuadrícula hexagonal",
    "hexGrid": "cuadrícula hexagonal",
    "bitbybit.point.hexGrid_description": "Crea puntos centrales de cuadrícula hexagonal en plano XY (patrón de panal). Tamaño de cuadrícula controlado por número de hexágonos, no ancho/alto. Ejemplo: radioHexagono=1, nrHexagonosX=3, nrHexagonosY=3 → 9 centros hex en patrón de cuadrícula",
    "nrHexagonsY": "núm hexágonos y",
    "nrHexagonsX": "núm hexágonos x",
    "radiusHexagon": "radio hexágono",
    "orientOnCenter": "orientar en centro",
    "pointsOnGround": "puntos en el suelo",
    "bitbybit.point.removeConsecutiveDuplicates": "eliminar duplicados consecutivos",
    "removeConsecutiveDuplicates": "eliminar duplicados consecutivos",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Elimina puntos duplicados consecutivos del array dentro de tolerancia. Ejemplo: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]] → [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "limpiar",
    "bitbybit.line.convertToNurbsCurve": "convertir a curva nurbs",
    "line": "línea",
    "convertToNurbsCurve": "convertir a curva nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "convierte la línea a curva nurbs",
    "LinePointsDto": "dto puntos línea",
    "bitbybit.line.convertLinesToNurbsCurves": "convertir líneas a curvas nurbs",
    "convertLinesToNurbsCurves": "convertir líneas a curvas nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "convierte las líneas a un array de curvas nurbs",
    "lines": "líneas",
    "LinePointsDto[]": "array dto puntos línea",
    "bitbybit.line.getStartPoint": "obtener punto inicial",
    "getStartPoint": "obtener punto inicial",
    "bitbybit.line.getStartPoint_description": "Extrae punto de inicio de una línea. Ejemplo: línea={start:[0,0,0], end:[10,5,0]} → [0,0,0]",
    "bitbybit.line.getEndPoint": "obtener punto final",
    "getEndPoint": "obtener punto final",
    "bitbybit.line.getEndPoint_description": "Extrae punto final de una línea. Ejemplo: línea={start:[0,0,0], end:[10,5,0]} → [10,5,0]",
    "bitbybit.line.length": "longitud",
    "bitbybit.line.length_description": "Calcula longitud (distancia) de un segmento de línea. Ejemplo: línea={start:[0,0,0], end:[3,4,0]} → 5 (usando teorema de Pitágoras)",
    "bitbybit.line.reverse": "invertir",
    "reverse": "invertir",
    "bitbybit.line.reverse_description": "Invierte dirección de línea intercambiando puntos de inicio y fin. Ejemplo: línea={start:[0,0,0], end:[10,5,0]} → {start:[10,5,0], end:[0,0,0]}",
    "bitbybit.line.transformLine": "transformar línea",
    "transformLine": "transformar línea",
    "bitbybit.line.transformLine_description": "Aplica matriz de transformación a línea (rota, escala o traslada ambos puntos finales). Ejemplo: línea={start:[0,0,0], end:[10,0,0]} con traslación [5,5,0] → {start:[5,5,0], end:[15,5,0]}",
    "bitbybit.line.transformsForLines": "transformaciones para líneas",
    "transformsForLines": "transformaciones para líneas",
    "bitbybit.line.transformsForLines_description": "Aplica múltiples transformaciones a múltiples líneas (una transformación por línea). Ejemplo: 3 líneas con 3 matrices de transformación diferentes → cada línea movida independientemente",
    "bitbybit.line.create": "crear",
    "bitbybit.line.create_description": "Crea una línea a partir de dos puntos (objeto línea con propiedades start y end). Ejemplo: start=[0,0,0], end=[10,5,0] → {start:[0,0,0], end:[10,5,0]}",
    "bitbybit.line.createAsync": "asíncrono",
    "createAsync": "asíncrono",
    "bitbybit.line.createAsync_description": "crea una línea a partir de puntos asíncronos",
    "bitbybit.line.getPointOnLine": "obtener punto en línea",
    "getPointOnLine": "obtener punto en línea",
    "bitbybit.line.getPointOnLine_description": "Calcula punto en parámetro t a lo largo del segmento de línea (0=inicio, 1=fin, interpolación lineal). Ejemplo: línea={start:[0,0,0], end:[10,0,0]}, param=0.5 → [5,0,0] (punto medio)",
    "param": "parámetro",
    "bitbybit.line.linesBetweenPoints": "líneas entre puntos",
    "linesBetweenPoints": "líneas entre puntos",
    "bitbybit.line.linesBetweenPoints_description": "Crea segmentos de línea conectando puntos consecutivos en una lista (forma un camino de polilínea). Ejemplo: puntos=[[0,0,0], [5,0,0], [5,5,0]] → 2 líneas: [0→5] y [5→5,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "líneas entre puntos iniciales y finales",
    "linesBetweenStartAndEndPoints": "líneas entre puntos iniciales y finales",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Crea líneas emparejando puntos de inicio y fin correspondientes de dos arrays. Filtra líneas de longitud cero. Ejemplo: inicios=[[0,0,0], [5,0,0]], finales=[[0,5,0], [5,5,0]] → 2 líneas conectando puntos emparejados",
    "startPoints": "puntos iniciales",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "líneas entre puntos iniciales y finales asíncrono",
    "linesBetweenStartAndEndPointsAsync": "líneas entre puntos iniciales y finales asíncrono",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "crea líneas entre puntos iniciales y finales con entradas asíncronas",
    "bitbybit.polyline.convertToNurbsCurve": "convertir a curva nurbs",
    "polyline": "polilínea",
    "bitbybit.polyline.convertToNurbsCurve_description": "convierte la polilínea a curva nurbs",
    "PolylinePropertiesDto": "dto propiedades polilínea",
    "bitbybit.polyline.length": "longitud",
    "bitbybit.polyline.length_description": "Calcula longitud total de polilínea sumando distancias entre puntos consecutivos. Ejemplo: puntos=[[0,0,0], [3,0,0], [3,4,0]] → 3 + 4 = 7",
    "bitbybit.polyline.countPoints": "contar puntos",
    "countPoints": "contar puntos",
    "bitbybit.polyline.countPoints_description": "Cuenta número de puntos en polilínea. Ejemplo: polilínea con puntos=[[0,0,0], [1,0,0], [1,1,0]] → 3",
    "bitbybit.polyline.getPoints": "obtener puntos",
    "getPoints": "obtener puntos",
    "bitbybit.polyline.getPoints_description": "Extrae array de puntos del objeto polilínea. Ejemplo: polilínea={points:[[0,0,0], [1,0,0]]} → [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "invertir",
    "bitbybit.polyline.reverse_description": "Invierte orden de puntos de polilínea (invierte dirección). Ejemplo: puntos=[[0,0,0], [1,0,0], [2,0,0]] → [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "transformar polilínea",
    "transformPolyline": "transformar polilínea",
    "bitbybit.polyline.transformPolyline_description": "Aplica matriz de transformación a todos los puntos en polilínea (rota, escala o traslada). Ejemplo: polilínea con 4 puntos, traslación [5,0,0] → todos los puntos movidos +5 en dirección X",
    "bitbybit.polyline.create": "crear",
    "bitbybit.polyline.create_description": "Crea una polilínea desde array de puntos con bandera isClosed opcional. Ejemplo: puntos=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true → {points:..., isClosed:true}",
    "isClosed": "está cerrado",
    "string | number[]": "cadena o array de números",
    "bitbybit.occt.deleteShape": "eliminar forma",
    "occt": "occt",
    "deleteShape": "eliminar forma",
    "bitbybit.occt.deleteShape_description": "Elimina forma de la caché para mantener bajo el uso de memoria",
    "bitbybit.occt.deleteShapes": "eliminar formas",
    "deleteShapes": "eliminar formas",
    "bitbybit.occt.deleteShapes_description": "Elimina formas de la caché para mantener bajo el uso de memoria",
    "shapes": "formas",
    "T[]": "array t",
    "bitbybit.occt.cleanAllCache": "limpiar toda la caché",
    "cleanAllCache": "limpiar toda la caché",
    "bitbybit.occt.cleanAllCache_description": "Limpia toda la caché y todas las formas de la memoria",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "vértice desde xyz",
    "vertex": "vértice",
    "vertexFromXYZ": "vértice desde xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Crea forma vértice desde coordenadas x y z",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "vértice desde punto",
    "vertexFromPoint": "vértice desde punto",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Crea forma vértice desde punto",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "vértices desde puntos",
    "verticesFromPoints": "vértices desde puntos",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "crea vértices a partir de puntos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "compuesto de vértices desde puntos",
    "verticesCompoundFromPoints": "compuesto de vértices desde puntos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Crea forma compuesta conteniendo múltiples vértices. Esto simplemente acelera el renderizado y permite aplicar transformaciones occt fácilmente en grupos de vértices.",
    "bitbybit.occt.shapes.vertex.getVertices": "obtener vértices",
    "getVertices": "obtener vértices",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Obtiene todos los vértices en la lista de una forma",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "obtener vértices como puntos",
    "getVerticesAsPoints": "obtener vértices como puntos",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Obtiene todos los vértices en la lista de una forma como puntos",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "vértices a puntos",
    "verticesToPoints": "vértices a puntos",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforma vértices a puntos",
    "transform": "transformar",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "vértice a punto",
    "vertexToPoint": "vértice a punto",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Transformar vértice a punto",
    "bitbybit.occt.shapes.vertex.projectPoints": "proyectar puntos",
    "projectPoints": "proyectar puntos",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "proyecta puntos sobre la forma",
    "place": "colocar",
    "projectionType": "tipo de proyección",
    "pointProjectionTypeEnum": "enum tipo proyección punto",
    "bitbybit.occt.shapes.edge.line": "línea",
    "edge": "arista",
    "bitbybit.occt.shapes.edge.line_description": "crea una arista lineal entre dos puntos",
    "primitives": "primitivas",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arco por tres puntos",
    "arcThroughThreePoints": "arco por tres puntos",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Crea arista de arco entre tres puntos",
    "middle": "medio",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arco por dos puntos y tangente",
    "arcThroughTwoPointsAndTangent": "arco por dos puntos y tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Crea arista de arco entre dos puntos dado el vector de dirección tangente en el primer punto.",
    "tangentVec": "vector tangente",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arco desde círculo y dos puntos",
    "arcFromCircleAndTwoPoints": "arco desde círculo y dos puntos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Crea una arista de arco entre dos puntos en un círculo",
    "circle": "círculo",
    "sense": "sentido",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arco desde círculo y dos ángulos",
    "arcFromCircleAndTwoAngles": "arco desde círculo y dos ángulos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Crea una arista de arco entre dos ángulos alfa en un círculo",
    "alphaAngle1": "ángulo alfa 1",
    "alphaAngle2": "ángulo alfa 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arco desde círculo punto y ángulo",
    "arcFromCirclePointAndAngle": "arco desde círculo punto y ángulo",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Crea una arista de arco entre el punto en un círculo y un ángulo alfa dado",
    "alphaAngle": "ángulo alfa",
    "bitbybit.occt.shapes.edge.createCircleEdge": "arista de círculo",
    "createCircleEdge": "arista de círculo",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "crea una arista de círculo de opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "arista de elipse",
    "createEllipseEdge": "arista de elipse",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "crea una arista de elipse de opencascade",
    "radiusMinor": "radio menor",
    "radiusMajor": "radio mayor",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "eliminar aristas internas",
    "removeInternalEdges": "eliminar aristas internas",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Elimina caras internas para la forma",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "hacer arista desde curva geom 2d y superficie",
    "makeEdgeFromGeom2dCurveAndSurface": "hacer arista desde curva geom 2d y superficie",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Crea una arista desde curva geom y superficie geom",
    "curve": "curva",
    "surface": "superficie",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "obtener arista",
    "getEdge": "obtener arista",
    "bitbybit.occt.shapes.edge.getEdge_description": "Obtiene la arista proporcionando un índice de la forma",
    "index": "índice",
    "bitbybit.occt.shapes.edge.getEdges": "obtener aristas",
    "getEdges": "obtener aristas",
    "bitbybit.occt.shapes.edge.getEdges_description": "Obtiene las aristas de una forma en una lista",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "obtener aristas a lo largo del alambre",
    "getEdgesAlongWire": "obtener aristas a lo largo del alambre",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Obtiene las aristas de un alambre ordenadas a lo largo de la dirección del alambre",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "obtener aristas circulares a lo largo del alambre",
    "getCircularEdgesAlongWire": "obtener aristas circulares a lo largo del alambre",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Obtiene aristas circulares de un alambre ordenadas a lo largo de la dirección del alambre",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "obtener aristas lineales a lo largo del alambre",
    "getLinearEdgesAlongWire": "obtener aristas lineales a lo largo del alambre",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Obtiene aristas lineales de un alambre ordenadas a lo largo de la dirección del alambre",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "obtener puntos de esquina de aristas para forma",
    "getCornerPointsOfEdgesForShape": "obtener puntos de esquina de aristas para forma",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Obtiene puntos de esquina de aristas para una forma. No hay garantía de orden aquí. Todos los duplicados se eliminan, así que cuando tres aristas forman una esquina, eso será representado por un solo punto en la lista.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "obtener longitud de arista",
    "getEdgeLength": "obtener longitud de arista",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Obtiene la longitud de la arista",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "obtener longitudes de arista de forma",
    "getEdgeLengthsOfShape": "obtener longitudes de arista de forma",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Obtiene las longitudes de arista de la forma",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "obtener longitudes de aristas",
    "getEdgesLengths": "obtener longitudes de aristas",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Obtiene las longitudes de las aristas",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "obtener centro de masa de arista",
    "getEdgeCenterOfMass": "obtener centro de masa de arista",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Obtiene el centro de masa para la arista",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "obtener centros de masa de aristas",
    "getEdgesCentersOfMass": "obtener centros de masa de aristas",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Obtiene los centros de masa para las aristas",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "obtener punto central de arista circular",
    "getCircularEdgeCenterPoint": "obtener punto central de arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Obtiene el punto central de la arista circular. Si la arista no es circular, no se devolverá punto.",
    "get circular edge": "obtener arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "obtener radio de arista circular",
    "getCircularEdgeRadius": "obtener radio de arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Obtiene el radio de la arista circular. Si la arista no es circular, no se devolverá radio.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "obtener dirección de plano de arista circular",
    "getCircularEdgePlaneDirection": "obtener dirección de plano de arista circular",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Obtiene el vector de dirección del plano de la arista circular. Si la arista no es circular, no se devolverá vector de dirección.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "punto en arista en parámetro",
    "pointOnEdgeAtParam": "punto en arista en parámetro",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Obtiene el punto en arista en param",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "puntos en aristas en parámetro",
    "pointsOnEdgesAtParam": "puntos en aristas en parámetro",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Obtiene los puntos en aristas en param",
    "bitbybit.occt.shapes.edge.edgesToPoints": "aristas a puntos",
    "edgesToPoints": "aristas a puntos",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Obtiene los puntos de todas las aristas de una forma en listas separadas para cada arista",
    "angularDeflection": "deflexión angular",
    "curvatureDeflection": "deflexión de curvatura",
    "minimumOfPoints": "mínimo de puntos",
    "uTolerance": "tolerancia u",
    "minimumLength": "longitud mínima",
    "bitbybit.occt.shapes.edge.reversedEdge": "arista invertida",
    "reversedEdge": "arista invertida",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Calcula arista invertida desde arista de entrada",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangente en arista en parámetro",
    "tangentOnEdgeAtParam": "tangente en arista en parámetro",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Obtiene el vector tangente en arista en param",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangentes en aristas en parámetro",
    "tangentsOnEdgesAtParam": "tangentes en aristas en parámetro",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Obtiene los vectores tangentes en aristas en param",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "punto en arista en longitud",
    "pointOnEdgeAtLength": "punto en arista en longitud",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Obtiene el punto en arista en longitud",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "puntos en aristas en longitud",
    "pointsOnEdgesAtLength": "puntos en aristas en longitud",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Obtiene los puntos en aristas en longitud",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangente en arista en longitud",
    "tangentOnEdgeAtLength": "tangente en arista en longitud",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Obtiene el vector tangente en arista en longitud",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangentes en aristas en longitud",
    "tangentsOnEdgesAtLength": "tangentes en aristas en longitud",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Obtiene los vectores tangentes en aristas en longitud",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "punto inicial en arista",
    "startPointOnEdge": "punto inicial en arista",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Obtiene el punto de inicio en arista",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "puntos iniciales en aristas",
    "startPointsOnEdges": "puntos iniciales en aristas",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Obtiene los puntos de inicio en aristas",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "punto final en arista",
    "endPointOnEdge": "punto final en arista",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Obtiene el punto final en arista",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "puntos finales en aristas",
    "endPointsOnEdges": "puntos finales en aristas",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Obtiene los puntos finales en aristas",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "dividir arista por parámetros a puntos",
    "divideEdgeByParamsToPoints": "dividir arista por parámetros a puntos",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divide la arista por parámetros a puntos",
    "nrOfDivisions": "núm de divisiones",
    "removeStartPoint": "eliminar punto inicial",
    "removeEndPoint": "eliminar punto final",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "dividir aristas por parámetros a puntos",
    "divideEdgesByParamsToPoints": "dividir aristas por parámetros a puntos",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divide las aristas por parámetros a puntos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "dividir arista por distancia igual a puntos",
    "divideEdgeByEqualDistanceToPoints": "dividir arista por distancia igual a puntos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divide la arista por longitud a puntos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "dividir aristas por distancia igual a puntos",
    "divideEdgesByEqualDistanceToPoints": "dividir aristas por distancia igual a puntos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divide las aristas por longitud a puntos",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "restringir líneas tangentes desde dos puntos a círculo",
    "constraintTanLinesFromTwoPtsToCircle": "restringir líneas tangentes desde dos puntos a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Crea líneas desde dos puntos dados hasta ubicaciones tangentes de círculo",
    "constraint": "restricción",
    "point1": "punto 1",
    "point2": "punto 2",
    "positionResult": "resultado de posición",
    "positionResultEnum": "enum resultado posición",
    "circleRemainder": "resto del círculo",
    "circleInclusionEnum": "enum inclusión círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "restringir líneas tangentes desde punto a círculo",
    "constraintTanLinesFromPtToCircle": "restringir líneas tangentes desde punto a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Crea líneas desde un punto dado hasta ubicaciones tangentes de círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "restringir líneas tangentes en dos círculos",
    "constraintTanLinesOnTwoCircles": "restringir líneas tangentes en dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Crea líneas tangentes entre dos círculos.",
    "circle1": "círculo 1",
    "circle2": "círculo 2",
    "circleRemainders": "restos de círculo",
    "twoCircleInclusionEnum": "enum inclusión dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "restringir círculos tangentes en dos círculos",
    "constraintTanCirclesOnTwoCircles": "restringir círculos tangentes en dos círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Crea círculos tangentes entre dos círculos.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "restringir círculos tangentes en círculo y punto",
    "constraintTanCirclesOnCircleAndPnt": "restringir círculos tangentes en círculo y punto",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Crea círculos tangentes entre un punto y un círculo.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "es arista lineal",
    "isEdgeLinear": "es arista lineal",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Comprueba si una arista es lineal",
    "is": "es",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "es arista circular",
    "isEdgeCircular": "es arista circular",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Comprueba si una arista es circular",
    "bitbybit.occt.shapes.wire.createPolygonWire": "alambre poligonal",
    "wire": "alambre",
    "createPolygonWire": "alambre poligonal",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "crea un alambre poligonal de opencascade",
    "via points": "vía puntos",
    "bitbybit.occt.shapes.wire.createPolygons": "polígonos",
    "createPolygons": "polígonos",
    "bitbybit.occt.shapes.wire.createPolygons_description": "crea polígonos de opencascade",
    "multiple": "múltiple",
    "polygons": "polígonos",
    "PolygonDto[]": "array dto polígono",
    "returnCompound": "retornar compuesto",
    "bitbybit.occt.shapes.wire.createLineWire": "alambre de línea",
    "createLineWire": "alambre de línea",
    "bitbybit.occt.shapes.wire.createLineWire_description": "crea un alambre de línea de opencascade",
    "bitbybit.occt.shapes.wire.createLines": "líneas",
    "createLines": "líneas",
    "bitbybit.occt.shapes.wire.createLines_description": "crea líneas de opencascade",
    "LineDto[]": "array dto línea",
    "bitbybit.occt.shapes.wire.splitOnPoints": "dividir en puntos",
    "splitOnPoints": "dividir en puntos",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Divide un alambre en un conjunto de puntos dados",
    "bitbybit.occt.shapes.wire.wiresToPoints": "alambres a puntos",
    "wiresToPoints": "alambres a puntos",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Transformar alambres de forma a puntos ordenados en listas. Esto también elimina puntos duplicados entre puntos de inicio y fin de aristas consecutivas en el alambre",
    "bitbybit.occt.shapes.wire.createPolylineWire": "alambre de polilínea",
    "createPolylineWire": "alambre de polilínea",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "crea un alambre de polilínea de opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zig zag entre dos alambres",
    "createZigZagBetweenTwoWires": "zig zag entre dos alambres",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "crea un zig zag entre dos alambres",
    "via wires": "vía alambres",
    "wire1": "alambre 1",
    "wire2": "alambre 2",
    "nrZigZags": "núm zig zags",
    "inverse": "inverso",
    "divideByEqualDistance": "dividir por distancia igual",
    "zigZagsPerEdge": "zig zags por arista",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "alambre desde dos círculos tangentes",
    "createWireFromTwoCirclesTan": "alambre desde dos círculos tangentes",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Crea un alambre tangente encerrando dos círculos planos",
    "keepLines": "mantener líneas",
    "twoSidesStrictEnum": "enum estricto dos lados",
    "fourSidesStrictEnum": "enum estricto cuatro lados",
    "bitbybit.occt.shapes.wire.createPolylines": "polilíneas",
    "createPolylines": "polilíneas",
    "bitbybit.occt.shapes.wire.createPolylines_description": "crea alambres de polilínea de opencascade",
    "polylines": "polilíneas",
    "PolylineDto[]": "array dto polilínea",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "crea un alambre bezier de opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "pesos bezier",
    "createBezierWeights": "pesos bezier",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "crea un alambre bezier de opencascade con pesos",
    "weights": "pesos",
    "bitbybit.occt.shapes.wire.createBezierWires": "alambres bezier",
    "createBezierWires": "alambres bezier",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "crea alambres bezier de opencascade",
    "bezierWires": "alambres bezier",
    "BezierDto[]": "array dto bezier",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpolar puntos",
    "interpolatePoints": "interpolar puntos",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Crea alambre BSpline OpenCascade desde puntos. Este método se puede usar para crear bucles (periódicos) con buena forma.",
    "periodic": "periódico",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpolar alambres",
    "interpolateWires": "interpolar alambres",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Crea múltiples alambres interpolados OpenCascade",
    "interpolations": "interpolaciones",
    "InterpolationDto[]": "array dto interpolación",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "crea un alambre bspline de opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "crea alambres bspline de opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "array dto bspline",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combinar aristas y alambres en un alambre",
    "combineEdgesAndWiresIntoAWire": "combinar aristas y alambres en un alambre",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Combina aristas y alambres OpenCascade en un solo alambre",
    "build": "construir",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "alambre desde arista",
    "createWireFromEdge": "alambre desde arista",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "crea un alambre a partir de una arista",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "añadir aristas y alambres al alambre",
    "addEdgesAndWiresToWire": "añadir aristas y alambres al alambre",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Añade aristas y alambres OpenCascade en otro alambre",
    "U[]": "array u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "dividir alambre por parámetros a puntos",
    "divideWireByParamsToPoints": "dividir alambre por parámetros a puntos",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Divide alambre OpenCascade a puntos siguiendo ciegamente su espacio paramétrico",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "dividir alambres por parámetros a puntos",
    "divideWiresByParamsToPoints": "dividir alambres por parámetros a puntos",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Divide alambres OpenCascade a puntos siguiendo ciegamente su espacio paramétrico",
    "extract from wires": "extraer de alambres",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "dividir alambre por distancia igual a puntos",
    "divideWireByEqualDistanceToPoints": "dividir alambre por distancia igual a puntos",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Divide alambre OpenCascade a puntos de igual distancia",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "dividir alambres por distancia igual a puntos",
    "divideWiresByEqualDistanceToPoints": "dividir alambres por distancia igual a puntos",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Divide alambres OpenCascade a puntos de igual distancia",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "punto en alambre en parámetro",
    "pointOnWireAtParam": "punto en alambre en parámetro",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Evalúa punto en un alambre en valor de parámetro entre 0 y 1, siendo puntos de inicio y fin",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "punto en alambre en longitud",
    "pointOnWireAtLength": "punto en alambre en longitud",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Evalúa punto en un alambre a cierta longitud",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "puntos en alambre en longitudes",
    "pointsOnWireAtLengths": "puntos en alambre en longitudes",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Evalúa puntos en un alambre a ciertas longitudes",
    "lengths": "longitudes",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "puntos en alambre en longitud igual",
    "pointsOnWireAtEqualLength": "puntos en alambre en longitud igual",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Evalúa puntos en un alambre a igual longitud",
    "tryNext": "probar siguiente",
    "includeFirst": "incluir primero",
    "includeLast": "incluir último",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "puntos en alambre en patrón de longitudes",
    "pointsOnWireAtPatternOfLengths": "puntos en alambre en patrón de longitudes",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Evalúa puntos en un alambre a patrón de longitudes",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangente en alambre en parámetro",
    "tangentOnWireAtParam": "tangente en alambre en parámetro",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Evalúa vector tangente en un alambre en valor de parámetro entre 0 y 1, siendo puntos de inicio y fin",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangente en alambre en longitud",
    "tangentOnWireAtLength": "tangente en alambre en longitud",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Evalúa vector tangente en un alambre a cierta longitud",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "derivadas en alambre en longitud",
    "derivativesOnWireAtLength": "derivadas en alambre en longitud",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Calcula 3 vectores derivados de una curva a una longitud dada",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "derivadas en alambre en parámetro",
    "derivativesOnWireAtParam": "derivadas en alambre en parámetro",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Calcula 3 vectores derivados de una curva en parámetro entre 0 y 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "punto inicial en alambre",
    "startPointOnWire": "punto inicial en alambre",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Calcula el punto de inicio en el alambre en param 0",
    "bitbybit.occt.shapes.wire.endPointOnWire": "punto final en alambre",
    "endPointOnWire": "punto final en alambre",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Calcula el punto final en el alambre en param 1",
    "bitbybit.occt.shapes.wire.createCircleWire": "alambre de círculo",
    "createCircleWire": "alambre de círculo",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "crea un alambre de círculo de opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "alambre cuadrado",
    "createSquareWire": "alambre cuadrado",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "crea un alambre cuadrado de opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "alambre de estrella",
    "createStarWire": "alambre de estrella",
    "bitbybit.occt.shapes.wire.createStarWire_description": "crea un alambre de estrella de opencascade",
    "numRays": "núm rayos",
    "outerRadius": "radio exterior",
    "innerRadius": "radio interior",
    "offsetOuterEdges": "desplazar aristas exteriores",
    "half": "mitad",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "alambre de árbol de navidad",
    "createChristmasTreeWire": "alambre de árbol de navidad",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "crea un alambre de árbol de navidad",
    "innerDist": "distancia interior",
    "outerDist": "distancia exterior",
    "nrSkirts": "núm faldones",
    "trunkHeight": "altura tronco",
    "trunkWidth": "ancho tronco",
    "bitbybit.occt.shapes.wire.createNGonWire": "alambre de n-gono",
    "createNGonWire": "alambre de n-gono",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Crea alambre n-gon OpenCascade",
    "nrCorners": "núm esquinas",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "alambre de paralelogramo",
    "createParallelogramWire": "alambre de paralelogramo",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Crea n alambre paralelogramo",
    "aroundCenter": "alrededor del centro",
    "bitbybit.occt.shapes.wire.createHeartWire": "alambre de corazón",
    "createHeartWire": "alambre de corazón",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Crea un alambre corazón",
    "sizeApprox": "tamaño aprox",
    "bitbybit.occt.shapes.wire.createRectangleWire": "alambre de rectángulo",
    "createRectangleWire": "alambre de rectángulo",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "crea un alambre de rectángulo de opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "alambre de polígono L",
    "createLPolygonWire": "alambre de polígono L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "crea un alambre de polígono L de opencascade",
    "widthFirst": "ancho primero",
    "lengthFirst": "longitud primero",
    "widthSecond": "ancho segundo",
    "lengthSecond": "longitud segundo",
    "align": "alinear",
    "directionEnum": "enum dirección",
    "bitbybit.occt.shapes.wire.createEllipseWire": "alambre de elipse",
    "createEllipseWire": "alambre de elipse",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "crea un alambre de elipse de opencascade",
    "bitbybit.occt.shapes.wire.textWires": "Contornos de texto",
    "textWires": "Contornos de texto",
    "bitbybit.occt.shapes.wire.textWires_description": "Crea contornos de texto OpenCascade basados en la fuente simplex creada por el Dr. A. V. Hershey.",
    "xOffset": "desplazamiento x",
    "yOffset": "desplazamiento y",
    "letterSpacing": "espaciado entre letras",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "desplazamiento de extrusión",
    "bitbybit.occt.shapes.wire.getWire": "obtener alambre",
    "getWire": "obtener alambre",
    "bitbybit.occt.shapes.wire.getWire_description": "Obtiene el alambre proporcionando un índice de la forma",
    "bitbybit.occt.shapes.wire.getWires": "obtener alambres",
    "getWires": "obtener alambres",
    "bitbybit.occt.shapes.wire.getWires_description": "Obtiene todos los alambres de la forma",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "obtener centro de masa del alambre",
    "getWireCenterOfMass": "obtener centro de masa del alambre",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Obtener el punto centro de masa del alambre",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "obtener centros de masa de alambres",
    "getWiresCentersOfMass": "obtener centros de masa de alambres",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Obtener los puntos centros de masa de los alambres",
    "bitbybit.occt.shapes.wire.reversedWire": "alambre invertido",
    "reversedWire": "alambre invertido",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Calcula alambre invertido desde alambre de entrada",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "alambre invertido desde aristas invertidas",
    "reversedWireFromReversedEdges": "alambre invertido desde aristas invertidas",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Calcula alambre invertido invirtiendo todas las aristas y combinándolas en un nuevo alambre",
    "bitbybit.occt.shapes.wire.isWireClosed": "está alambre cerrado",
    "isWireClosed": "está alambre cerrado",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Comprueba si el alambre está cerrado",
    "bitbybit.occt.shapes.wire.getWireLength": "obtener longitud de alambre",
    "getWireLength": "obtener longitud de alambre",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Obtiene la longitud del alambre",
    "bitbybit.occt.shapes.wire.getWiresLengths": "obtener longitudes de alambres",
    "getWiresLengths": "obtener longitudes de alambres",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Obtiene las longitudes de alambres",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "colocar alambre en cara",
    "placeWireOnFace": "colocar alambre en cara",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Coloca un alambre en la cara mapeando sus coordenadas 2d al espacio UV. El alambre debe estar posicionado en el plano de suelo XZ para que esto funcione.",
    "face": "cara",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "colocar alambres en cara",
    "placeWiresOnFace": "colocar alambres en cara",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Coloca múltiples alambres en la cara mapeando sus coordenadas 2d al espacio UV. Los alambres deben estar posicionados en el plano de suelo XZ para que esto funcione.",
    "wires": "alambres",
    "bitbybit.occt.shapes.wire.closeOpenWire": "cerrar alambre abierto",
    "closeOpenWire": "cerrar alambre abierto",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Cierra el alambre abierto con arista recta adicional uniendo puntos de inicio y fin",
    "bitbybit.occt.shapes.wire.project": "proyectar",
    "project": "proyectar",
    "bitbybit.occt.shapes.wire.project_description": "Proyectar alambre en la forma",
    "bitbybit.occt.shapes.wire.projectWires": "proyectar alambres",
    "projectWires": "proyectar alambres",
    "bitbybit.occt.shapes.wire.projectWires_description": "Proyectar múltiples alambres en la forma",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "caras desde alambres en cara",
    "createFacesFromWiresOnFace": "caras desde alambres en cara",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Crea caras desde alambres en cara",
    "inside": "interior",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "cara desde alambre en cara",
    "createFaceFromWireOnFace": "cara desde alambre en cara",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Crea una cara desde alambre en cara",
    "bitbybit.occt.shapes.face.createFaceFromWire": "cara desde alambre",
    "createFaceFromWire": "cara desde alambre",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Crea una cara desde alambre",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "cara desde alambres",
    "createFaceFromWires": "cara desde alambres",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Crea una cara desde alambres. Esto puede producir caras huecas.",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "cara desde alambres en cara",
    "createFaceFromWiresOnFace": "cara desde alambres en cara",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Crea una cara desde alambres en la cara guía. Esto puede producir caras huecas.",
    "bitbybit.occt.shapes.face.createFacesFromWires": "caras desde alambres",
    "createFacesFromWires": "caras desde alambres",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "crea caras a partir de alambres",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "cara desde múltiples alambres tangentes a círculos",
    "createFaceFromMultipleCircleTanWires": "cara desde múltiples alambres tangentes a círculos",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "crea una cara a partir de múltiples alambres tangentes a círculos",
    "circles": "círculos",
    "combination": "combinación",
    "combinationCirclesForFaceEnum": "enum combinación círculos para cara",
    "unify": "unificar",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "cara desde múltiples colecciones de alambres tangentes a círculos",
    "createFaceFromMultipleCircleTanWireCollections": "cara desde múltiples colecciones de alambres tangentes a círculos",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "crea una cara a partir de múltiples colecciones de alambres tangentes a círculos",
    "listsOfCircles": "listas de círculos",
    "T[][]": "array de array t",
    "bitbybit.occt.shapes.face.faceFromSurface": "cara desde superficie",
    "faceFromSurface": "cara desde superficie",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Crea una cara desde la superficie",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "cara desde superficie y alambre",
    "faceFromSurfaceAndWire": "cara desde superficie y alambre",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Crea una cara desde la superficie y un alambre",
    "bitbybit.occt.shapes.face.createPolygonFace": "cara poligonal",
    "createPolygonFace": "cara poligonal",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "crea una cara poligonal de opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "cara circular",
    "createCircleFace": "cara circular",
    "bitbybit.occt.shapes.face.createCircleFace_description": "crea una cara circular de opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "cara elíptica",
    "createEllipseFace": "cara elíptica",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "crea una cara elíptica de opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "cara cuadrada",
    "createSquareFace": "cara cuadrada",
    "bitbybit.occt.shapes.face.createSquareFace_description": "crea una cara cuadrada de opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "cara rectangular",
    "createRectangleFace": "cara rectangular",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "crea una cara rectangular de opencascade",
    "bitbybit.occt.shapes.face.getFace": "obtener cara",
    "getFace": "obtener cara",
    "bitbybit.occt.shapes.face.getFace_description": "Obtiene la cara proporcionando un índice de la forma",
    "bitbybit.occt.shapes.face.getFaces": "obtener caras",
    "getFaces": "obtener caras",
    "bitbybit.occt.shapes.face.getFaces_description": "Obtiene las caras de la forma en una lista",
    "bitbybit.occt.shapes.face.reversedFace": "cara invertida",
    "reversedFace": "cara invertida",
    "bitbybit.occt.shapes.face.reversedFace_description": "Calcula cara invertida desde cara de entrada",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdividir en puntos",
    "subdivideToPoints": "subdividir en puntos",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Subdivide una cara a cuadrícula de puntos",
    "nrDivisionsU": "núm divisiones u",
    "nrDivisionsV": "núm divisiones v",
    "shiftHalfStepU": "desplazar medio paso u",
    "removeStartEdgeU": "eliminar arista inicial u",
    "removeEndEdgeU": "eliminar arista final u",
    "shiftHalfStepV": "desplazar medio paso v",
    "removeStartEdgeV": "eliminar arista inicial v",
    "removeEndEdgeV": "eliminar arista final v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdividir en alambres",
    "subdivideToWires": "subdividir en alambres",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Subdivide una cara a alambres",
    "nrDivisions": "núm divisiones",
    "isU": "es u",
    "shiftHalfStep": "desplazar medio paso",
    "removeStart": "eliminar inicio",
    "removeEnd": "eliminar fin",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdividir en alambres rectangulares",
    "subdivideToRectangleWires": "subdividir en alambres rectangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Subdivide una cara a alambres rectangulares",
    "patterns": "patrones",
    "nrRectanglesU": "núm rectángulos u",
    "nrRectanglesV": "núm rectángulos v",
    "scalePatternU": "patrón de escala u",
    "scalePatternV": "patrón de escala v",
    "filletPattern": "patrón de redondeo",
    "inclusionPattern": "patrón de inclusión",
    "offsetFromBorderU": "desplazamiento desde borde u",
    "offsetFromBorderV": "desplazamiento desde borde v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdividir en agujeros rectangulares",
    "subdivideToRectangleHoles": "subdividir en agujeros rectangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Subdivide una cara a alambres rectangulares",
    "holesToFaces": "agujeros a caras",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdividir en puntos controlados",
    "subdivideToPointsControlled": "subdividir en puntos controlados",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Subdivide una cara a cuadrícula de puntos con desplazamientos y eliminaciones en enésimas filas o columnas uv",
    "shiftHalfStepNthU": "desplazar medio paso enésimo u",
    "shiftHalfStepUOffsetN": "desplazar medio paso u desplazamiento n",
    "removeStartEdgeNthU": "eliminar arista inicial enésima u",
    "removeStartEdgeUOffsetN": "eliminar arista inicial u desplazamiento n",
    "removeEndEdgeNthU": "eliminar arista final enésima u",
    "removeEndEdgeUOffsetN": "eliminar arista final u desplazamiento n",
    "shiftHalfStepNthV": "desplazar medio paso enésimo v",
    "shiftHalfStepVOffsetN": "desplazar medio paso v desplazamiento n",
    "removeStartEdgeNthV": "eliminar arista inicial enésima v",
    "removeStartEdgeVOffsetN": "eliminar arista inicial v desplazamiento n",
    "removeEndEdgeNthV": "eliminar arista final enésima v",
    "removeEndEdgeVOffsetN": "eliminar arista final v desplazamiento n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdividir en normales",
    "subdivideToNormals": "subdividir en normales",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Subdivide una cara a cuadrícula de normales",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdividir en uv",
    "subdivideToUV": "subdividir en uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Subdivide una cara a cuadrícula uv",
    "bitbybit.occt.shapes.face.pointOnUV": "punto en uv",
    "pointOnUV": "punto en uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Obtener punto en UV donde U y V se describen entre 0 y 1. Estos se mapearán a límites reales.",
    "paramU": "parámetro u",
    "paramV": "parámetro v",
    "bitbybit.occt.shapes.face.normalOnUV": "normal en uv",
    "normalOnUV": "normal en uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Obtener normal en UV donde U y V se describen entre 0 y 1. Estos se mapearán a límites reales.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "puntos en uvs",
    "pointsOnUVs": "puntos en uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Obtener puntos en UVs donde U y V se describen entre 0 y 1 en arrays bidimensionales. Estos se mapearán a límites reales.",
    "paramsUV": "parámetros uv",
    "[number, number][]": "array de pares de números",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normales en uvs",
    "normalsOnUVs": "normales en uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Obtener normales en UVs donde U y V se describen entre 0 y 1 en arrays bidimensionales. Estos se mapearán a límites reales.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdividir en puntos en parámetro",
    "subdivideToPointsOnParam": "subdividir en puntos en parámetro",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Subdivide una cara a puntos a lo largo de una línea en parámetro",
    "nrPoints": "núm puntos",
    "bitbybit.occt.shapes.face.wireAlongParam": "alambre a lo largo de parámetro",
    "wireAlongParam": "alambre a lo largo de parámetro",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Obtiene el alambre a lo largo del parámetro en la cara",
    "bitbybit.occt.shapes.face.wiresAlongParams": "alambres a lo largo de parámetros",
    "wiresAlongParams": "alambres a lo largo de parámetros",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Obtiene los alambres a lo largo de los parámetros en la cara",
    "params": "parámetros",
    "bitbybit.occt.shapes.face.getUMinBound": "obtener límite mínimo u",
    "getUMinBound": "obtener límite mínimo u",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Obtiene el límite U min de la cara",
    "bitbybit.occt.shapes.face.getUMaxBound": "obtener límite máximo u",
    "getUMaxBound": "obtener límite máximo u",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Obtiene el límite U max de la cara",
    "bitbybit.occt.shapes.face.getVMinBound": "obtener límite mínimo v",
    "getVMinBound": "obtener límite mínimo v",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Obtiene el límite V min de la cara",
    "bitbybit.occt.shapes.face.getVMaxBound": "obtener límite máximo v",
    "getVMaxBound": "obtener límite máximo v",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Obtiene el límite V max de la cara",
    "bitbybit.occt.shapes.face.getFaceArea": "obtener área de cara",
    "getFaceArea": "obtener área de cara",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Obtener el área de la cara",
    "bitbybit.occt.shapes.face.getFacesAreas": "obtener áreas de caras",
    "getFacesAreas": "obtener áreas de caras",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Obtener las áreas de las caras",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "obtener centro de masa de cara",
    "getFaceCenterOfMass": "obtener centro de masa de cara",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Obtener el punto centro de masa de la cara",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "obtener centros de masa de caras",
    "getFacesCentersOfMass": "obtener centros de masa de caras",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Obtener los puntos centros de masa para caras",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtrar puntos de cara",
    "filterFacePoints": "filtrar puntos de cara",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtra puntos en la cara",
    "filter": "filtrar",
    "useBndBox": "usar caja delimitadora",
    "gapTolerance": "tolerancia de hueco",
    "keepIn": "mantener dentro",
    "keepOn": "mantener sobre",
    "keepOut": "mantener fuera",
    "keepUnknown": "mantener desconocido",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtrar puntos de caras",
    "filterFacesPoints": "filtrar puntos de caras",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtra puntos en las caras",
    "flatPointsArray": "array de puntos plano",
    "bitbybit.occt.shapes.shell.sewFaces": "coser caras",
    "shell": "shell",
    "sewFaces": "coser caras",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Crea una cáscara desde caras",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "obtener área superficial del shell",
    "getShellSurfaceArea": "obtener área superficial del shell",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Obtener área de superficie de cáscara",
    "bitbybit.occt.shapes.solid.fromClosedShell": "desde shell cerrado",
    "solid": "sólido",
    "fromClosedShell": "desde shell cerrado",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Crea Sólido Desde cáscara que debe estar cerrada",
    "bitbybit.occt.shapes.solid.createBox": "caja",
    "bitbybit.occt.shapes.solid.createBox_description": "crea una caja de opencascade",
    "originOnCenter": "origen en el centro",
    "bitbybit.occt.shapes.solid.createCube": "cubo",
    "bitbybit.occt.shapes.solid.createCube_description": "crea un cubo de opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "caja desde esquina",
    "createBoxFromCorner": "caja desde esquina",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "crea una caja de opencascade desde una esquina",
    "corner": "esquina",
    "bitbybit.occt.shapes.solid.createCylinder": "cilindro",
    "bitbybit.occt.shapes.solid.createCylinder_description": "crea un cilindro de opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cilindros en líneas",
    "createCylindersOnLines": "cilindros en líneas",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Crea Cilindros OpenCascade en líneas simples bit by bit representadas por dos puntos",
    "Base.Line3[]": "array de línea base 3",
    "bitbybit.occt.shapes.solid.createSphere": "esfera",
    "bitbybit.occt.shapes.solid.createSphere_description": "crea una esfera de opencascade",
    "bitbybit.occt.shapes.solid.createCone": "cono",
    "createCone": "cono",
    "bitbybit.occt.shapes.solid.createCone_description": "crea un cono de opencascade",
    "radius1": "radio 1",
    "radius2": "radio 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "obtener área superficial del sólido",
    "getSolidSurfaceArea": "obtener área superficial del sólido",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Obtener área de superficie de sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume": "obtener volumen del sólido",
    "getSolidVolume": "obtener volumen del sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Obtener volumen de sólido",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "obtener volúmenes de sólidos",
    "getSolidsVolumes": "obtener volúmenes de sólidos",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Obtener volúmenes de sólidos",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "obtener centro de masa del sólido",
    "getSolidCenterOfMass": "obtener centro de masa del sólido",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Obtener centro de masa de sólido",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "obtener centros de masa de sólidos",
    "getSolidsCentersOfMass": "obtener centros de masa de sólidos",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Obtener centros de masa de sólidos",
    "bitbybit.occt.shapes.solid.getSolids": "obtener sólidos",
    "getSolids": "obtener sólidos",
    "bitbybit.occt.shapes.solid.getSolids_description": "Obtiene los sólidos de la forma en una lista",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtrar puntos de sólido",
    "filterSolidPoints": "filtrar puntos de sólido",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Filtra colección de puntos basado en relación con el sólido. Puede elegir si emitir puntos dentro, en o fuera.",
    "bitbybit.occt.shapes.compound.makeCompound": "hacer compuesto",
    "compound": "compuesto",
    "makeCompound": "hacer compuesto",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Hace la forma compuesta, que puede incluir cualquier tipo de formas",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "obtener formas de compuesto",
    "getShapesOfCompound": "obtener formas de compuesto",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Obtiene las formas de las que está hecho el compuesto",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "purgar aristas internas",
    "purgeInternalEdges": "purgar aristas internas",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Eliminar aristas internas que no están conectadas a ninguna cara en la forma",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unificar mismo dominio",
    "unifySameDomain": "unificar mismo dominio",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Unifica caras, aristas en el mismo dominio y tiene posibilidad de concatenar bsplines",
    "unifyEdges": "unificar aristas",
    "unifyFaces": "unificar caras",
    "concatBSplines": "concatenar bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "está cerrado",
    "bitbybit.occt.shapes.shape.isClosed_description": "Comprobar si la forma está cerrada",
    "analysis": "análisis",
    "bitbybit.occt.shapes.shape.isConvex": "es convexo",
    "isConvex": "es convexo",
    "bitbybit.occt.shapes.shape.isConvex_description": "Comprobar si la forma es convexa",
    "bitbybit.occt.shapes.shape.isChecked": "está comprobado",
    "bitbybit.occt.shapes.shape.isChecked_description": "Comprobar si la forma está comprobada",
    "bitbybit.occt.shapes.shape.isFree": "es libre",
    "isFree": "es libre",
    "bitbybit.occt.shapes.shape.isFree_description": "Comprobar si la forma es libre",
    "bitbybit.occt.shapes.shape.isInfinite": "es infinito",
    "isInfinite": "es infinito",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Comprobar si la forma es infinita",
    "bitbybit.occt.shapes.shape.isModified": "está modificado",
    "isModified": "está modificado",
    "bitbybit.occt.shapes.shape.isModified_description": "Comprobar si la forma está modificada",
    "bitbybit.occt.shapes.shape.isLocked": "está bloqueado",
    "isLocked": "está bloqueado",
    "bitbybit.occt.shapes.shape.isLocked_description": "Comprobar si la forma está bloqueada",
    "bitbybit.occt.shapes.shape.isNull": "es nulo",
    "isNull": "es nulo",
    "bitbybit.occt.shapes.shape.isNull_description": "Comprobar si la forma es nula",
    "bitbybit.occt.shapes.shape.isEqual": "es igual",
    "isEqual": "es igual",
    "bitbybit.occt.shapes.shape.isEqual_description": "Comprobar si la forma es igual a otra forma",
    "otherShape": "otra forma",
    "bitbybit.occt.shapes.shape.isNotEqual": "no es igual",
    "isNotEqual": "no es igual",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Comprobar si la forma no es igual a otra forma",
    "bitbybit.occt.shapes.shape.isPartner": "es pareja",
    "isPartner": "es pareja",
    "bitbybit.occt.shapes.shape.isPartner_description": "Comprobar si la forma es socia de otra forma",
    "bitbybit.occt.shapes.shape.isSame": "es la misma",
    "isSame": "es la misma",
    "bitbybit.occt.shapes.shape.isSame_description": "Comprobar si la forma es la misma que la otra forma",
    "bitbybit.occt.shapes.shape.getOrientation": "obtener orientación",
    "getOrientation": "obtener orientación",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Obtener la orientación de la forma",
    "bitbybit.occt.shapes.shape.getShapeType": "obtener tipo de forma",
    "getShapeType": "obtener tipo de forma",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Obtener el tipo de forma",
    "bitbybit.occt.geom.curves.geom2dEllipse": "geometría elipse 2d",
    "geom": "geom",
    "curves": "curvas",
    "geom2dEllipse": "geometría elipse 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Crea una elipse 2d. Asegúrese de usar esta geometría solo para propósitos constructivos de modelado, pero no para representación. Necesita transformar estas curvas a aristas para dibujarlas.",
    "Base.Point2": "punto base 2",
    "Base.Vector2": "vector base 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "geometría curva recortada 2d",
    "geom2dTrimmedCurve": "geometría curva recortada 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Crea una curva recortada desde la curva base limitada entre U1 y U2. Esta curva no se puede dibujar.",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "ajustar periódico",
    "bitbybit.occt.geom.curves.geom2dSegment": "geometría segmento 2d",
    "geom2dSegment": "geometría segmento 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Crea un segmento de curva 2d recortado entre dos puntos 2d. Esta curva no se puede dibujar.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "obtener punto 2d de curva 2d en parámetro",
    "get2dPointFrom2dCurveOnParam": "obtener punto 2d de curva 2d en parámetro",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Obtiene punto 2d representado por [número, número] en una curva en parámetro.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "geometría curva circular",
    "geomCircleCurve": "geometría curva circular",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Crea una curva geom de círculo",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "geometría curva elíptica",
    "geomEllipseCurve": "geometría curva elíptica",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Crea una curva geom de elipse",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "superficie cilíndrica",
    "surfaces": "superficies",
    "cylindricalSurface": "superficie cilíndrica",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Crea una superficie cilíndrica infinita que no se puede dibujar. Asegúrese de usar esta geometría solo para propósitos constructivos de modelado, pero no para representación.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "superficie desde cara",
    "surfaceFromFace": "superficie desde cara",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Crea una superficie desde la cara",
    "bitbybit.occt.fillets.filletEdges": "redondear aristas",
    "fillets": "redondeos",
    "filletEdges": "redondear aristas",
    "bitbybit.occt.fillets.filletEdges_description": "redondea formas de opencascade",
    "3d fillets": "redondeos 3d",
    "radiusList": "lista de radios",
    "indexes": "índices",
    "bitbybit.occt.fillets.filletEdgesList": "lista de redondeo de aristas",
    "filletEdgesList": "lista de redondeo de aristas",
    "bitbybit.occt.fillets.filletEdgesList_description": "Redondea lista de aristas con diferente radio en cada arista.",
    "edges": "aristas",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "lista de redondeo de aristas un radio",
    "filletEdgesListOneRadius": "lista de redondeo de aristas un radio",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Redondea lista de aristas con el único radio en todas las aristas.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "redondear arista radio variable",
    "filletEdgeVariableRadius": "redondear arista radio variable",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Redondea una sola arista con lista de radio variable en params u dados. Necesita proporcionar una lista de params para identificar en qué param U aplicar el radio.",
    "paramsU": "parámetros u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "redondear aristas mismo radio variable",
    "filletEdgesSameVariableRadius": "redondear aristas mismo radio variable",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Redondea múltiples aristas proporcionadas con los mismos radios variables en params u para cada arista.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "redondear aristas radio variable",
    "filletEdgesVariableRadius": "redondear aristas radio variable",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Redondea múltiples aristas proporcionadas con listas de radio variable en listas de params dadas. Necesita proporcionar una lista de params para identificar en qué param U aplicar el radio.",
    "radiusLists": "listas de radios",
    "paramsULists": "listas de parámetros u",
    "bitbybit.occt.fillets.fillet3DWire": "redondear alambre 3d",
    "fillet3DWire": "redondear alambre 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "Redondea alambre 3d OpenCascade, este algoritmo toma una dirección guía para que se formen los redondeos. No respeta direcciones tangentes en cada esquina redondeada. Este algoritmo se basa en extruir alambre a lo largo de la dirección dada para formar una cáscara, luego redondear la cáscara y finalmente extraer el alambre redondeado de la cáscara misma. Asegúrese de proporcionar una dirección que no sea paralela al alambre y que forme una extrusión suficientemente alta para que el redondeo tenga éxito.",
    "bitbybit.occt.fillets.fillet3DWires": "redondear alambres 3d",
    "fillet3DWires": "redondear alambres 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "Redondea alambres 3d OpenCascade, este algoritmo toma una dirección guía para que se formen los redondeos. No respeta direcciones tangentes en cada esquina redondeada. Este algoritmo se basa en extruir alambres a lo largo de la dirección dada para formar una cáscara, luego redondear la cáscara y finalmente extraer el alambre redondeado de la cáscara misma. Asegúrese de proporcionar una dirección que no sea paralela al alambre y que forme una extrusión suficientemente alta para que el redondeo tenga éxito.",
    "bitbybit.occt.fillets.chamferEdges": "achaflanar aristas",
    "chamferEdges": "achaflanar aristas",
    "bitbybit.occt.fillets.chamferEdges_description": "Achaflanar aristas de Forma OpenCascade",
    "3d chamfers": "achaflanados 3d",
    "distanceList": "lista de distancias",
    "bitbybit.occt.fillets.chamferEdgesList": "lista de achaflanado de aristas",
    "chamferEdgesList": "lista de achaflanado de aristas",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Achaflana lista de aristas con diferente distancia en cada arista.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "achaflanar arista dos distancias",
    "chamferEdgeTwoDistances": "achaflanar arista dos distancias",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Achaflana arista por dos distancias. Cara indica la primera distancia a aplicar",
    "F": "f",
    "distance1": "distancia 1",
    "distance2": "distancia 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "achaflanar aristas dos distancias",
    "chamferEdgesTwoDistances": "achaflanar aristas dos distancias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Achaflana aristas por dos distancias. Cara indica la primera distancia a aplicar",
    "faces": "caras",
    "F[]": "array f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "achaflanar aristas listas dos distancias",
    "chamferEdgesTwoDistancesLists": "achaflanar aristas listas dos distancias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Achaflana aristas por dos distancias. Cara indica la primera distancia a aplicar",
    "distances1": "distancias 1",
    "distances2": "distancias 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "achaflanar arista dist ángulo",
    "chamferEdgeDistAngle": "achaflanar arista dist ángulo",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Achaflana arista por una distancia y ángulo dados desde la cara",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "achaflanar aristas dist ángulo",
    "chamferEdgesDistAngle": "achaflanar aristas dist ángulo",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Achaflana múltiples aristas por una distancia y ángulo dados desde las caras",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "achaflanar aristas dists ángulos",
    "chamferEdgesDistsAngles": "achaflanar aristas dists ángulos",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Achaflana aristas por unas distancias y ángulos dados desde las caras",
    "distances": "distancias",
    "bitbybit.occt.fillets.fillet2d": "redondeo 2d",
    "fillet2d": "redondeo 2d",
    "bitbybit.occt.fillets.fillet2d_description": "redondea alambre o cara 2d",
    "2d fillets": "redondeos 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "redondear formas 2d",
    "fillet2dShapes": "redondear formas 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "redondea alambres o caras 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "redondear dos aristas en plano en un alambre",
    "filletTwoEdgesInPlaneIntoAWire": "redondear dos aristas en plano en un alambre",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Redondea dos aristas planas en un alambre proporcionando un radio, plano, aristas y posible índice de solución si existe más de un resultado",
    "edge1": "arista 1",
    "edge2": "arista 2",
    "planeOrigin": "origen del plano",
    "planeDirection": "dirección del plano",
    "solution": "solución",
    "bitbybit.occt.transforms.transform": "transformar",
    "bitbybit.occt.transforms.transform_description": "Transforma la forma",
    "on single shape": "en forma única",
    "rotationAxis": "eje de rotación",
    "rotationAngle": "ángulo de rotación",
    "scaleFactor": "factor de escala",
    "bitbybit.occt.transforms.rotate": "rotar",
    "bitbybit.occt.transforms.rotate_description": "Rota la forma",
    "bitbybit.occt.transforms.rotateAroundCenter": "rotar alrededor del centro",
    "rotateAroundCenter": "rotar alrededor del centro",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Rota la forma alrededor del centro proporcionado",
    "bitbybit.occt.transforms.align": "alinear",
    "bitbybit.occt.transforms.align_description": "Alinea la forma",
    "fromOrigin": "desde origen",
    "fromDirection": "desde dirección",
    "toOrigin": "a origen",
    "toDirection": "a dirección",
    "bitbybit.occt.transforms.alignAndTranslate": "alinear y trasladar",
    "alignAndTranslate": "alinear y trasladar",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Alinea y traslada la forma",
    "bitbybit.occt.transforms.translate": "trasladar",
    "bitbybit.occt.transforms.translate_description": "Traslada la forma",
    "bitbybit.occt.transforms.scale": "escalar",
    "bitbybit.occt.transforms.scale_description": "Escala la forma",
    "bitbybit.occt.transforms.scale3d": "escalar 3d",
    "scale3d": "escalar 3d",
    "bitbybit.occt.transforms.scale3d_description": "Escala la forma en 3D",
    "bitbybit.occt.transforms.mirror": "reflejar",
    "mirror": "reflejar",
    "bitbybit.occt.transforms.mirror_description": "Refleja la forma",
    "bitbybit.occt.transforms.mirrorAlongNormal": "reflejar a lo largo de normal",
    "mirrorAlongNormal": "reflejar a lo largo de normal",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Refleja la forma a lo largo de la normal y origen",
    "normal": "normal",
    "bitbybit.occt.transforms.transformShapes": "transformar formas",
    "transformShapes": "transformar formas",
    "bitbybit.occt.transforms.transformShapes_description": "Transforma el array de formas con transformaciones",
    "on shapes": "en formas",
    "rotationAxes": "ejes de rotación",
    "rotationAngles": "ángulos de rotación",
    "scaleFactors": "factores de escala",
    "bitbybit.occt.transforms.rotateShapes": "rotar formas",
    "rotateShapes": "rotar formas",
    "bitbybit.occt.transforms.rotateShapes_description": "Rota las formas con rotaciones",
    "axes": "ejes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "rotar alrededor del centro formas",
    "rotateAroundCenterShapes": "rotar alrededor del centro formas",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Rota las formas alrededor del centro y un eje",
    "centers": "centros",
    "bitbybit.occt.transforms.alignShapes": "alinear formas",
    "alignShapes": "alinear formas",
    "bitbybit.occt.transforms.alignShapes_description": "Alinea las formas con alineaciones",
    "fromOrigins": "desde orígenes",
    "fromDirections": "desde direcciones",
    "toOrigins": "a orígenes",
    "toDirections": "a direcciones",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "alinear y trasladar formas",
    "alignAndTranslateShapes": "alinear y trasladar formas",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Alinea y traslada las formas",
    "directions": "direcciones",
    "bitbybit.occt.transforms.translateShapes": "trasladar formas",
    "translateShapes": "trasladar formas",
    "bitbybit.occt.transforms.translateShapes_description": "Traslada las formas con traslaciones",
    "bitbybit.occt.transforms.scaleShapes": "escalar formas",
    "scaleShapes": "escalar formas",
    "bitbybit.occt.transforms.scaleShapes_description": "Escala las formas con factores de escala",
    "factors": "factores",
    "bitbybit.occt.transforms.scale3dShapes": "escalar formas 3d",
    "scale3dShapes": "escalar formas 3d",
    "bitbybit.occt.transforms.scale3dShapes_description": "Escala la forma en 3D",
    "scales": "escalas",
    "bitbybit.occt.transforms.mirrorShapes": "reflejar formas",
    "mirrorShapes": "reflejar formas",
    "bitbybit.occt.transforms.mirrorShapes_description": "Refleja las formas con múltiples espejos",
    "origins": "orígenes",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "reflejar a lo largo de normal formas",
    "mirrorAlongNormalShapes": "reflejar a lo largo de normal formas",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Refleja las formas a lo largo de la normal y origen",
    "normals": "normales",
    "bitbybit.occt.operations.loft": "loft",
    "operations": "operaciones",
    "loft": "loft",
    "bitbybit.occt.operations.loft_description": "Soleva alambres en una cáscara",
    "lofts": "lofts",
    "makeSolid": "hacer sólido",
    "bitbybit.occt.operations.loftAdvanced": "loft avanzado",
    "loftAdvanced": "loft avanzado",
    "bitbybit.occt.operations.loftAdvanced_description": "Soleva alambres en una cáscara usando muchas opciones avanzadas",
    "straight": "recto",
    "nrPeriodicSections": "núm secciones periódicas",
    "useSmoothing": "usar suavizado",
    "maxUDegree": "grado u máximo",
    "parType": "tipo par",
    "approxParametrizationTypeEnum": "enum tipo parametrización aprox",
    "startVertex": "vértice inicial",
    "endVertex": "vértice final",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "puntos más cercanos entre dos formas",
    "closestPointsBetweenTwoShapes": "puntos más cercanos entre dos formas",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Calcula dos puntos más cercanos entre dos formas",
    "closest pts": "puntos más cercanos",
    "shape1": "forma 1",
    "shape2": "forma 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "puntos más cercanos en forma desde puntos",
    "closestPointsOnShapeFromPoints": "puntos más cercanos en forma desde puntos",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Calcula puntos más cercanos entre una lista de puntos y una forma dada",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "puntos más cercanos en formas desde puntos",
    "closestPointsOnShapesFromPoints": "puntos más cercanos en formas desde puntos",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Calcula puntos más cercanos entre una lista de puntos y formas",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distancias a forma desde puntos",
    "distancesToShapeFromPoints": "distancias a forma desde puntos",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Calcula distancias entre una lista de puntos y unos puntos más cercanos correspondientes en formas.",
    "bitbybit.occt.operations.boundingBoxOfShape": "caja delimitadora de la forma",
    "boundingBoxOfShape": "caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Calcula los parámetros de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "mínimo de la caja delimitadora de la forma",
    "boundingBoxMinOfShape": "mínimo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Obtiene el punto mínimo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "máximo de la caja delimitadora de la forma",
    "boundingBoxMaxOfShape": "máximo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Obtiene el punto máximo de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "centro de la caja delimitadora de la forma",
    "boundingBoxCenterOfShape": "centro de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Obtiene el punto central de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "tamaño de la caja delimitadora de la forma",
    "boundingBoxSizeOfShape": "tamaño de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Obtiene el punto de tamaño de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "forma de la caja delimitadora de la forma",
    "boundingBoxShapeOfShape": "forma de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Obtiene la forma de la caja delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereOfShape": "esfera delimitadora de la forma",
    "boundingSphereOfShape": "esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Calcula los parámetros de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "centro de la esfera delimitadora de la forma",
    "boundingSphereCenterOfShape": "centro de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Obtiene el punto central de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "radio de la esfera delimitadora de la forma",
    "boundingSphereRadiusOfShape": "radio de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Obtiene el radio de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "forma de la esfera delimitadora de la forma",
    "boundingSphereShapeOfShape": "forma de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Obtiene la forma de la esfera delimitadora de la forma",
    "bitbybit.occt.operations.extrude": "extruir",
    "extrude": "extruir",
    "bitbybit.occt.operations.extrude_description": "Extruye la forma a lo largo de la dirección - alambre producirá cáscara, cara producirá sólido",
    "extrusions": "extrusiones",
    "bitbybit.occt.operations.extrudeShapes": "extruir formas",
    "extrudeShapes": "extruir formas",
    "bitbybit.occt.operations.extrudeShapes_description": "Extruye las formas a lo largo de la dirección",
    "bitbybit.occt.operations.splitShapeWithShapes": "dividir forma con formas",
    "splitShapeWithShapes": "dividir forma con formas",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Divide la forma con formas",
    "divisions": "divisiones",
    "localFuzzyTolerance": "tolerancia difusa local",
    "nonDestructive": "no destructivo",
    "bitbybit.occt.operations.revolve": "revolucionar",
    "revolve": "revolucionar",
    "bitbybit.occt.operations.revolve_description": "Revoluciona la forma alrededor de la dirección dada",
    "revolutions": "revoluciones",
    "copy": "copiar",
    "bitbybit.occt.operations.rotatedExtrude": "extrusión rotada",
    "rotatedExtrude": "extrusión rotada",
    "bitbybit.occt.operations.rotatedExtrude_description": "Extrusión rotada que se realiza en la forma",
    "bitbybit.occt.operations.pipe": "tubo",
    "pipe": "tubo",
    "bitbybit.occt.operations.pipe_description": "Tuberia formas a lo largo del alambre",
    "pipeing": "entubado",
    "bitbybit.occt.operations.pipePolylineWireNGon": "tubo alambre polilínea n-gono",
    "pipePolylineWireNGon": "tubo alambre polilínea n-gono",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Tuberia alambre polilínea con perfil ngon.",
    "trihedronEnum": "enum triedro",
    "geomFillTrihedronEnum": "enum triedro relleno geom",
    "forceApproxC1": "forzar aprox c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "tubo alambres cilíndrico",
    "pipeWiresCylindrical": "tubo alambres cilíndrico",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Tuberia alambres con forma cilíndrica",
    "bitbybit.occt.operations.pipeWireCylindrical": "tubo alambre cilíndrico",
    "pipeWireCylindrical": "tubo alambre cilíndrico",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Tuberia alambre con forma cilíndrica",
    "bitbybit.occt.operations.offset": "desplazamiento",
    "bitbybit.occt.operations.offset_description": "Compensación (Offset) para varias formas",
    "offsets": "desplazamientos",
    "bitbybit.occt.operations.offsetAdv": "desplazamiento avanzado",
    "offsetAdv": "desplazamiento avanzado",
    "bitbybit.occt.operations.offsetAdv_description": "Compensación avanzada que da más opciones para compensación, como tipo de unión para aristas y esquinas",
    "joinType": "tipo de unión",
    "joinTypeEnum": "enum tipo unión",
    "removeIntEdges": "eliminar aristas int",
    "bitbybit.occt.operations.makeThickSolidSimple": "hacer sólido grueso simple",
    "makeThickSolidSimple": "hacer sólido grueso simple",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Engrosa la forma en un sólido por una distancia de compensación",
    "bitbybit.occt.operations.makeThickSolidByJoin": "hacer sólido grueso por unión",
    "makeThickSolidByJoin": "hacer sólido grueso por unión",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Engrosa la forma en un sólido uniendo",
    "intersection": "intersección",
    "selfIntersection": "autointersección",
    "bitbybit.occt.operations.slice": "rebanar",
    "slice": "rebanar",
    "bitbybit.occt.operations.slice_description": "Rebana la forma",
    "bitbybit.occt.operations.sliceInStepPattern": "rebanar en patrón de pasos",
    "sliceInStepPattern": "rebanar en patrón de pasos",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Rebana la forma en patrón de pasos",
    "steps": "pasos",
    "bitbybit.occt.operations.offset3DWire": "desplazamiento alambre 3d",
    "offset3DWire": "desplazamiento alambre 3d",
    "bitbybit.occt.operations.offset3DWire_description": "Compensación de alambre 3D. Al usar este método considere usarlo en alambres redondeados que no contengan esquinas afiladas. Puede usar redondeo 3D en él.",
    "bitbybit.occt.booleans.union": "unión",
    "booleans": "booleanos",
    "union": "unión",
    "bitbybit.occt.booleans.union_description": "Une objetos separados",
    "keepEdges": "mantener aristas",
    "bitbybit.occt.booleans.difference": "diferencia",
    "difference": "diferencia",
    "bitbybit.occt.booleans.difference_description": "Hace operación booleana de diferencia entre una forma principal y formas dadas",
    "bitbybit.occt.booleans.intersection": "intersección",
    "bitbybit.occt.booleans.intersection_description": "Hace operación booleana de intersección entre una forma principal y formas dadas",
    "bitbybit.occt.shapeFix.basicShapeRepair": "reparación básica de forma",
    "shapeFix": "reparación de forma",
    "basicShapeRepair": "reparación básica de forma",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Realiza la reparación básica de forma",
    "maxTolerance": "tolerancia máxima",
    "minTolerance": "tolerancia mínima",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "corregir arista pequeña en alambre",
    "fixSmallEdgeOnWire": "corregir arista pequeña en alambre",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Arreglar arista pequeña en alambre",
    "lockvtx": "bloquear vtx",
    "precsmall": "prec pequeña",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "corregir orientaciones de arista a lo largo del alambre",
    "fixEdgeOrientationsAlongWire": "corregir orientaciones de arista a lo largo del alambre",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Arreglar orientaciones de arista a lo largo de alambre",
    "bitbybit.occt.io.saveShapeSTEP": "guardar forma step",
    "saveShapeSTEP": "guardar forma step",
    "bitbybit.occt.io.saveShapeSTEP_description": "Guarda el archivo step",
    "adjustYtoZ": "ajustar y a z",
    "tryDownload": "intentar descargar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "guardar forma step y retornar",
    "saveShapeSTEPAndReturn": "guardar forma step y retornar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Guarda el archivo step y devuelve el valor de texto",
    "bitbybit.occt.io.saveShapeStl": "guardar forma stl",
    "saveShapeStl": "guardar forma stl",
    "bitbybit.occt.io.saveShapeStl_description": "Guarda el archivo stl",
    "binary": "binario",
    "bitbybit.occt.io.saveShapeStlAndReturn": "guardar forma stl y retornar",
    "saveShapeStlAndReturn": "guardar forma stl y retornar",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Guarda el archivo stl y devuelve",
    "bitbybit.occt.io.loadSTEPorIGES": "cargar step o iges",
    "loadSTEPorIGES": "cargar step o iges",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Importa el archivo de activo step o iges",
    "adjustZtoY": "ajustar z a y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "cargar step o iges desde texto",
    "loadSTEPorIGESFromText": "cargar step o iges desde texto",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Importa el archivo de activo step o iges desde texto",
    "fileType": "tipo de archivo",
    "fileTypeEnum": "enum tipo archivo",
    "bitbybit.advanced.text3d.create": "texto 3d",
    "advanced": "avanzado",
    "text3d": "texto 3d",
    "bitbybit.advanced.text3d.create_description": "Crea un texto 3d",
    "fontType": "tipo de fuente",
    "fontsEnum": "enum fuentes",
    "fontVariant": "variante de fuente",
    "fontVariantsEnum": "enum variantes fuente",
    "Inputs.Base.Vector3": "entradas vector base 3",
    "originAlignment": "alineación origen",
    "recAlignmentEnum": "enum alineación rec",
    "bitbybit.advanced.text3d.createTextOnFace": "texto en cara",
    "createTextOnFace": "texto en cara",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Crea un texto 3d en la cara",
    "facePlanar": "cara planar",
    "faceTextVar": "var texto cara",
    "faceTextVarEnum": "enum var texto cara",
    "originParamU": "origen parámetro u",
    "originParamV": "origen parámetro v",
    "bitbybit.advanced.text3d.createTextsOnFace": "textos en cara",
    "createTextsOnFace": "textos en cara",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Crea textos 3d en la cara desde múltiples definiciones",
    "definitions": "definiciones",
    "Text3DFaceDefinitionDto[]": "array dto definición cara texto 3d",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "definición texto 3d en cara",
    "definition3dTextOnFace": "definición texto 3d en cara",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Crea texto 3d que se usará en la definición de cara",
    "bitbybit.advanced.text3d.getCompoundShape": "obtener forma compuesta",
    "getCompoundShape": "obtener forma compuesta",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Obtiene forma compuesta del resultado de texto 3d",
    "model": "modelo",
    "Text3DData<T>": "datos texto 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "obtener forma de carácter",
    "getCharacterShape": "obtener forma de carácter",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Obtiene la forma de carácter en índice particular",
    "bitbybit.advanced.text3d.getCharacterShapes": "obtener formas de caracteres",
    "getCharacterShapes": "obtener formas de caracteres",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Obtiene formas de carácter del resultado de texto 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "obtener coordenadas centrales de carácter",
    "getCharacterCenterCoordinates": "obtener coordenadas centrales de carácter",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Obtiene las coordenadas del centro de masa de todos los caracteres",
    "bitbybit.advanced.text3d.getFaceCutout": "obtener recorte de cara",
    "getFaceCutout": "obtener recorte de cara",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Obtiene el recorte de cara del texto 3d que se creó en la cara",
    "get from face": "obtener de cara",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "obtener todas las caras del recorte",
    "getAllFacesOfCutout": "obtener todas las caras del recorte",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Obtiene todos los recortes de cara del texto 3d que se creó en la cara original",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "obtener recortes dentro de caracteres",
    "getCutoutsInsideCharacters": "obtener recortes dentro de caracteres",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Obtiene recortes de cara de carácter del texto 3d que se creó en la cara original",
    "bitbybit.advanced.text3d.getAdvanceWidth": "obtener ancho de avance",
    "getAdvanceWidth": "obtener ancho de avance",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Obtener ancho de avance",
    "dimensions": "dimensiones",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pirámide simple",
    "facePatterns": "patrones de cara",
    "pyramidSimple": "pirámide simple",
    "createPyramidSimple": "pirámide simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Crea un patrón de pirámide simple en caras",
    "uNumber": "número u",
    "vNumber": "número v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "afectores de pirámide simple",
    "createPyramidSimpleAffectors": "afectores de pirámide simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Crea un patrón de pirámide simple en caras con afectadores que cambian la altura",
    "affectorPoints": "puntos afectores",
    "Inputs.Base.Point3[]": "array de punto base 3 de entradas",
    "affectorRadiusList": "lista de radios afectores",
    "affectorFactors": "factores afectores",
    "defaultHeight": "altura predeterminada",
    "affectMinHeight": "altura mínima afectada",
    "affectMaxHeight": "altura máxima afectada",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "obtener forma compuesta",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Obtiene la forma compuesta de todas las pirámides",
    "get shapes": "obtener formas",
    "PyramidSimpleData<T>": "datos pirámide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "obtener forma compuesta en cara",
    "getCompoundShapeOnFace": "obtener forma compuesta en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Obtiene la forma compuesta en la cara",
    "faceIndex": "índice de cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "obtener celda de forma compuesta en cara",
    "getCompoundShapeCellOnFace": "obtener celda de forma compuesta en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Obtiene la forma compuesta de la pirámide en la cara en índice particular",
    "uIndex": "índice u",
    "vIndex": "índice v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "obtener todas las celdas de pirámide",
    "getAllPyramidCells": "obtener todas las celdas de pirámide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Obtiene todas las celdas de pirámide. Esto es usualmente una acción intermedia para luego leer información particular de las celdas mismas.",
    "get cells": "obtener celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "obtener todas las celdas de pirámide en cara",
    "getAllPyramidCellsOnFace": "obtener todas las celdas de pirámide en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Obtiene celdas de pirámide en la cara. Esto es usualmente una acción intermedia para luego leer información particular de las celdas mismas.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "obtener todas las celdas u de pirámide en cara",
    "getAllPyramidUCellsOnFace": "obtener todas las celdas u de pirámide en cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Obtiene celdas de pirámide en la cara. Esto es usualmente una acción intermedia para luego leer información particular de las celdas mismas.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "obtener todas las celdas u de pirámide en cara en u",
    "getAllPyramidUCellsOnFaceAtU": "obtener todas las celdas u de pirámide en cara en u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Obtiene celdas de pirámide en la cara en índice u a lo largo de dirección v. Esto es usualmente una acción intermedia para luego leer información particular de las celdas mismas.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "obtener todas las celdas u de pirámide en cara en v",
    "getAllPyramidUCellsOnFaceAtV": "obtener todas las celdas u de pirámide en cara en v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Obtiene celdas de pirámide en la cara en índice v a lo largo de dirección u. Esto es usualmente una acción intermedia para luego leer información particular de las celdas mismas.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "obtener celda en índice",
    "getCellOnIndex": "obtener celda en índice",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Obtiene celda de pirámide en la cara en índice u y v. Esto es usualmente una acción intermedia para luego leer información particular de la celda misma.",
    "get cell": "obtener celda",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obtener puntos superiores de celdas",
    "getTopPointsOfCells": "obtener puntos superiores de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Obtiene los puntos superiores de celdas",
    "get from cells": "obtener de celdas",
    "cells": "celdas",
    "PyramidSimpleCellPart<T>[]": "array de parte de celda pirámide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "obtener puntos centrales de celdas",
    "getCenterPointsOfCells": "obtener puntos centrales de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Obtiene el punto central entre esquinas de celda",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "obtener puntos de esquina de celdas",
    "getCornerPointsOfCells": "obtener puntos de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Obtiene los puntos de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "obtener punto de esquina de celdas",
    "getCornerPointOfCells": "obtener punto de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Obtiene los puntos de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "obtener normal de esquina de celdas",
    "getCornerNormalOfCells": "obtener normal de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Obtiene la normal de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "obtener normales de esquina de celdas",
    "getCornerNormalsOfCells": "obtener normales de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Obtiene las normales de esquina de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "obtener formas compuestas de celdas",
    "getCompoundShapesOfCells": "obtener formas compuestas de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Obtiene las formas compuestas de las celdas de pirámide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "obtener formas de cara de celdas",
    "getFaceShapesOfCells": "obtener formas de cara de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Obtiene las formas de cara de las celdas de pirámide proporcionadas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "obtener formas de alambre de celdas",
    "getWireShapesOfCells": "obtener formas de alambre de celdas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Obtiene las formas de cara de las celdas de pirámide proporcionadas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "obtener alambre de polilínea inicial u",
    "getStartPolylineWireU": "obtener alambre de polilínea inicial u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Obtiene el alambre polilínea a lo largo del borde de inicio de la dirección U de la cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "obtener alambre de polilínea final u",
    "getEndPolylineWireU": "obtener alambre de polilínea final u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Obtiene el alambre polilínea a lo largo del borde final de la dirección U de la cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "obtener alambre de polilínea inicial v",
    "getStartPolylineWireV": "obtener alambre de polilínea inicial v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Obtiene el alambre polilínea a lo largo del borde de inicio de la dirección V de la cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "obtener alambre de polilínea final v",
    "getEndPolylineWireV": "obtener alambre de polilínea final v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Obtiene el alambre polilínea a lo largo del borde final de la dirección V de la cara",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "obtener compuesto de alambres de polilínea u",
    "getPolylineWiresUCompound": "obtener compuesto de alambres de polilínea u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Obtiene los alambres polilínea a lo largo de dirección U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "obtener compuesto de alambres de polilínea v",
    "getPolylineWiresVCompound": "obtener compuesto de alambres de polilínea v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Obtiene los alambres polilínea a lo largo de dirección V",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "villa ala delta",
    "things": "cosas",
    "kidsCorner": "rincón infantil",
    "birdhouses": "casas para pájaros",
    "wingtipVilla": "villa ala delta",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Crea una pajarera villa de punta de ala con un techo de 45 grados",
    "birdhouse": "casa para pájaros",
    "interiorWidth": "ancho interior",
    "interiorLength": "longitud interior",
    "interiorHeight": "altura interior",
    "holeDiameter": "diámetro agujero",
    "holeDistToBottom": "distancia agujero a base",
    "stickLength": "longitud palo",
    "stickDiameter": "diámetro palo",
    "baseAttachmentHeight": "altura fijación base",
    "roofOverhang": "voladizo techo",
    "chimneyHeight": "altura chimenea",
    "Inputs.Base.Point3": "entradas punto base 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chalet chirriante",
    "chirpyChalet": "chalet chirriante",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Crea una pajarera chalet chirpy con un techo de 45 grados",
    "roofAngle": "ángulo techo",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "remolino serenidad",
    "threeDPrinting": "impresión 3d",
    "vases": "jarrones",
    "serenitySwirl": "remolino serenidad",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Crea un remolino de serenidad",
    "swirl": "remolino",
    "addRadiusNarrow": "añadir radio estrecho",
    "addRadiusWide": "añadir radio ancho",
    "addMiddleHeight": "añadir altura media",
    "addTopHeight": "añadir altura superior",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arco árabe",
    "arabicArchway": "arco árabe",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Crea un jarrón de arco árabe",
    "profilePoints": "puntos de perfil",
    "nrOfSides": "núm lados",
    "nrOfVerticalArches": "núm arcos verticales",
    "archCenterThickness": "grosor centro arco",
    "edgesThickness": "grosor aristas",
    "baseHeight": "altura base",
    "patchHoles": "parchear agujeros",
    "lod": "nivel detalle",
    "Things.Enums.lodEnum": "enum nivel detalle cosas",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "amor eterno",
    "medals": "medallas",
    "eternalLove": "amor eterno",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Crea un modelo de medalla de amor eterno",
    "textHeading": "texto encabezado",
    "textName": "texto nombre",
    "fullModel": "modelo completo",
    "decorationThickness": "grosor decoración",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "taza calma",
    "cups": "tazas",
    "calmCup": "taza calma",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Crea un modelo de taza para tus momentos de calma",
    "radiusTopOffset": "desplazamiento radio superior",
    "fillet": "redondeo",
    "nrOfHandles": "núm asas",
    "handleDist": "distancia asa",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "taza dragón",
    "dragonCup": "taza dragón",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Crea un modelo de taza para tu dragón interior",
    "radiusMidOffset": "desplazamiento radio medio",
    "rotationTopAngle": "ángulo rotación superior",
    "rotationMidAngle": "ángulo rotación medio",
    "nrSkinCellsVertical": "núm celdas piel vertical",
    "nrSkinCellsHorizontal": "núm celdas piel horizontal",
    "nrSkinCellDivisionsTop": "núm divisiones celda piel superior",
    "nrSkinCellDivisionsBottom": "núm divisiones celda piel inferior",
    "skinCellOuterHeight": "altura exterior celda piel",
    "skinCellInnerHeight": "altura interior celda piel",
    "skinCellBottomHeight": "altura inferior celda piel",
    "skinCellTopHeight": "altura superior celda piel",
    "bottomThickness": "grosor base",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Obtiene la forma compuesta de la taza dragón",
    "DragonCupData<T>": "datos taza dragón t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "nido teléfono",
    "desktop": "escritorio",
    "phoneNest": "nido teléfono",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Crea un modelo de nido de teléfono",
    "heightBottom": "altura inferior",
    "heightTop": "altura superior",
    "widthBack": "ancho trasero",
    "widthFront": "ancho frontal",
    "backOffset": "desplazamiento trasero",
    "applyOrnaments": "aplicar ornamentos",
    "filletRadius": "radio redondeo",
    "phoneHeight": "altura teléfono",
    "phoneWidth": "ancho teléfono",
    "phoneThickness": "grosor teléfono",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Obtiene la forma compuesta del nido de teléfono",
    "PhoneNestData<T>": "datos nido teléfono t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "opciones dibujo",
    "drawOptions": "opciones dibujo",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "crea opciones de dibujo para el modelo",
    "mainMaterial": "material principal",
    "phoneMaterial": "material teléfono",
    "Inputs.Base.Color": "entradas color base",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "soporte teléfono gotas",
    "laserCutting": "corte láser",
    "gadgets": "gadgets",
    "dropletsPhoneHolder": "soporte teléfono gotas",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "crea el soporte para teléfono gotas",
    "title": "título",
    "subtitle": "subtítulo",
    "includeLogo": "incluir logo",
    "kerf": "corte",
    "backLength": "longitud trasera",
    "offsetAroundPhone": "desplazamiento alrededor teléfono",
    "penShelf": "estante bolígrafo",
    "phoneLockHeight": "altura bloqueo teléfono",
    "includePattern": "incluir patrón",
    "densityPattern": "densidad patrón",
    "holesForWire": "agujeros para cable",
    "wireInputThickness": "grosor entrada cable",
    "includeModel": "incluir modelo",
    "includeDrawings": "incluir dibujos",
    "spacingDrawings": "espaciado dibujos",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Obtiene la forma compuesta del soporte de teléfono de gotas",
    "DropletsPhoneHolderData<T>": "datos soporte teléfono gotas t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "obtener compuesto alambres corte",
    "getCutWiresCompound": "obtener compuesto alambres corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Obtiene el compuesto de alambres cortados",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "obtener compuesto alambres grabado",
    "getEngravingWiresCompound": "obtener compuesto alambres grabado",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Obtiene el compuesto de alambres de grabado",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "descargar dibujos dxf",
    "downloadDXFDrawings": "descargar dibujos dxf",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "descarga el dibujo dxf",
    "download": "descargar",
    "cutWiresColor": "color alambres corte",
    "engravingWiresColor": "color alambres grabado",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "descargar dibujos step",
    "downloadSTEPDrawings": "descargar dibujos step",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "descarga el dibujo step",
    "adjustYZ": "ajustar yz",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "descargar modelo step 3d",
    "download3dSTEPModel": "descargar modelo step 3d",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "descarga el modelo 3d step",
    "bitbybit.things.architecture.houses.zenHideout.create": "refugio zen",
    "architecture": "arquitectura",
    "houses": "casas",
    "zenHideout": "refugio zen",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Crea un escondite zen",
    "widthFirstWing": "ancho primera ala",
    "lengthFirstWing": "longitud primera ala",
    "terraceWidth": "ancho terraza",
    "widthSecondWing": "ancho segunda ala",
    "lengthSecondWing": "longitud segunda ala",
    "heightWalls": "altura muros",
    "roofAngleFirstWing": "ángulo techo primera ala",
    "roofAngleSecondWing": "ángulo techo segunda ala",
    "roofOffset": "desplazamiento techo",
    "roofInsideOverhang": "voladizo interior techo",
    "roofMaxDistAttachmentBeams": "dist máx vigas fijación techo",
    "roofAttachmentBeamWidth": "ancho viga fijación techo",
    "roofAttachmentBeamHeight": "altura viga fijación techo",
    "roofOutsideOverhang": "voladizo exterior techo",
    "columnSize": "tamaño columna",
    "ceilingBeamHeight": "altura viga techo",
    "ceilingBeamWidth": "ancho viga techo",
    "nrCeilingBeamsBetweenColumns": "núm vigas techo entre columnas",
    "distBetweenColumns": "dist entre columnas",
    "floorHeight": "altura suelo",
    "groundLevel": "nivel suelo",
    "facadePanelThickness": "grosor panel fachada",
    "windowWidthOffset": "desplazamiento ancho ventana",
    "windowHeightOffset": "desplazamiento altura ventana",
    "windowFrameThickness": "grosor marco ventana",
    "windowGlassFrameThickness": "grosor marco vidrio ventana",
    "skinOpacity": "opacidad piel",
    "bitbybit.things.furniture.chairs.snakeChair.create": "silla serpiente",
    "furniture": "mobiliario",
    "chairs": "sillas",
    "snakeChair": "silla serpiente",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Crea un modelo de silla serpiente",
    "sittingHeight": "altura asiento",
    "backRestOffset": "desplazamiento respaldo",
    "backRestHeight": "altura respaldo",
    "nrOrnamentPlanks": "núm tablones ornamento",
    "ornamentDepth": "profundidad ornamento",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Obtiene la forma compuesta de la silla",
    "SnakeChairData<T>": "datos silla serpiente t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "obtener forma alambre asiento",
    "getSittingWireShape": "obtener forma alambre asiento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Obtiene la forma de alambre del área de asiento de la silla",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "obtener punto central área asiento",
    "getSittingAreaCenterPoint": "obtener punto central área asiento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Obtiene el punto central del área de asiento de la silla",
    "get points": "obtener puntos",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "crea opciones de dibujo para la silla serpiente",
    "bitbybit.things.furniture.tables.elegantTable.create": "mesa elegante",
    "tables": "mesas",
    "elegantTable": "mesa elegante",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Crea un modelo de mesa elegante",
    "topThickness": "grosor tablero",
    "topOffset": "desplazamiento tablero",
    "minFillet": "redondeo mín",
    "radiusLegTop": "radio pata superior",
    "radiusLegBottom": "radio pata inferior",
    "nrLegPairs": "núm pares patas",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Obtiene la forma compuesta de la mesa",
    "ElegantTableData<T>": "datos mesa elegante t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "obtener formas pata",
    "getLegShapes": "obtener formas pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Obtiene las formas de pata como una lista",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "obtener forma pata por índice",
    "getLegShapeByIndex": "obtener forma pata por índice",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Obtiene la forma de pata por índice",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "obtener forma panel superior",
    "getTopPanelShape": "obtener forma panel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Obtiene la forma del panel superior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "obtener forma alambre panel superior",
    "getTopPanelWireShape": "obtener forma alambre panel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Obtiene la forma de alambre del panel superior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "obtener forma alambre panel inferior",
    "getBottomPanelWireShape": "obtener forma alambre panel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Obtiene la forma de alambre del panel inferior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "obtener forma panel inferior",
    "getBottomPanelShape": "obtener forma panel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Obtiene la forma del panel inferior de la mesa",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "obtener forma compuesta patas",
    "getLegsCompoundShape": "obtener forma compuesta patas",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Obtiene las formas de pata como una forma compuesta",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "obtener punto central tablero mesa",
    "getTableTopCenterPoint": "obtener punto central tablero mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Obtiene el punto central superior",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "obtener punto central base mesa",
    "getTableBottomCenterPoint": "obtener punto central base mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Obtiene el punto central inferior",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "obtener puntos inferiores pata",
    "getLegBottomPoints": "obtener puntos inferiores pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Obtiene los puntos inferiores de la pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obtener puntos superiores pata",
    "getLegTopPoints": "obtener puntos superiores pata",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Obtiene los puntos superiores de la pata",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "crea opciones de dibujo para la mesa elegante",
    "topMaterial": "material tablero",
    "topBaseMaterial": "material base tablero",
    "legsMaterial": "material patas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "buena mesa café",
    "goodCoffeeTable": "buena mesa café",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Crea un modelo de mesa de buen café",
    "chamfer": "chaflán",
    "topGlassOffset": "desplazamiento vidrio superior",
    "glassThickness": "grosor vidrio",
    "glassHolderLength": "longitud soporte vidrio",
    "shelfTopOffset": "desplazamiento superior estante",
    "shelfThickness": "grosor estante",
    "legWidth": "ancho pata",
    "legDepth": "profundidad pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Obtiene la forma compuesta de la mesa",
    "GoodCoffeeTableData<T>": "datos buena mesa café t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "obtener formas pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Obtiene las formas de pata como una lista",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "obtener forma pata por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Obtiene la forma de pata por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "obtener forma panel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Obtiene la forma del panel superior de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "obtener forma alambre panel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Obtiene la forma de alambre del panel superior de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "obtener forma panel vidrio",
    "getGlassPanelShape": "obtener forma panel vidrio",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Obtiene la forma del panel de vidrio de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "obtener forma alambre panel vidrio",
    "getGlassPanelWireShape": "obtener forma alambre panel vidrio",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Obtiene la forma de alambre del panel de vidrio de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "obtener forma estante",
    "getShelfShape": "obtener forma estante",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Obtiene la forma del estante de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "obtener forma alambre superior estante",
    "getShelfTopWireShape": "obtener forma alambre superior estante",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Obtiene la forma de alambre superior del estante de la mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "obtener forma compuesta patas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Obtiene las formas de pata como una forma compuesta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "obtener punto central tablero mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Obtiene el punto central superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "obtener punto central superior estante mesa",
    "getTableShelfTopCenterPoint": "obtener punto central superior estante mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Obtiene el punto central superior del estante",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "obtener puntos inferiores pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Obtiene los puntos inferiores de la pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obtener puntos superiores pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Obtiene los puntos superiores de la pata",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "crea opciones de dibujo para la buena mesa de café",
    "topGlassMaterial": "material vidrio superior",
    "shelfMaterial": "material estante",
    "bitbybit.things.furniture.tables.snakeTable.create": "mesa serpiente",
    "snakeTable": "mesa serpiente",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Crea un modelo de mesa serpiente",
    "supportLength": "longitud soporte",
    "shelfHeight": "altura estante",
    "glassOffset": "desplazamiento vidrio",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "obtener forma compuesta",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Obtiene la forma compuesta de la mesa",
    "SnakeTableData<T>": "datos mesa serpiente t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "obtener forma vidrio",
    "getGlassShape": "obtener forma vidrio",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Obtiene la forma de vidrio de la mesa",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "obtener forma principal",
    "getMainShape": "obtener forma principal",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Obtiene la forma sólida principal de la mesa",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "obtener punto central superior",
    "getTopCenterPoint": "obtener punto central superior",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Obtiene el punto central de la parte superior de la mesa",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "opciones dibujo",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "crea opciones de dibujo para la mesa serpiente",
    "glassMaterial": "material vidrio",
    "bitbybit.things.enums.lodEnum": "enum nivel detalle",
    "enums": "enums",
    "lodEnum": "enum nivel detalle",
    "bitbybit.things.enums.lodEnum_description": "Crea un valor de enumeración de nivel de detalle",
    "bitbybit.jscad.transformSolids": "transformar sólidos",
    "jscad": "jscad",
    "transformSolids": "transformar sólidos",
    "bitbybit.jscad.transformSolids_description": "Transforma las mallas sólidas Jscad con una lista dada de transformaciones.",
    "JSCADEntity[]": "array entidad jscad",
    "bitbybit.jscad.transformSolid": "transformar sólido",
    "transformSolid": "transformar sólido",
    "bitbybit.jscad.transformSolid_description": "Transforma la malla sólida Jscad con una lista dada de transformaciones.",
    "JSCADEntity": "entidad jscad",
    "bitbybit.jscad.downloadSolidSTL": "descargar stl sólido",
    "downloadSolidSTL": "descargar stl sólido",
    "bitbybit.jscad.downloadSolidSTL_description": "Descarga el archivo STL binario desde un sólido 3D",
    "bitbybit.jscad.downloadSolidsSTL": "descargar stl sólidos",
    "downloadSolidsSTL": "descargar stl sólidos",
    "bitbybit.jscad.downloadSolidsSTL_description": "Descarga el archivo STL binario desde sólidos 3D",
    "bitbybit.jscad.downloadGeometryDxf": "descargar geometría dxf",
    "downloadGeometryDxf": "descargar geometría dxf",
    "bitbybit.jscad.downloadGeometryDxf_description": "Descarga el archivo dxf desde geometría jscad. Soporta rutas y mallas en array.",
    "geometry": "geometría",
    "JSCADEntity | JSCADEntity[]": "entidad jscad o array",
    "bitbybit.jscad.downloadGeometry3MF": "descargar geometría 3mf",
    "downloadGeometry3MF": "descargar geometría 3mf",
    "bitbybit.jscad.downloadGeometry3MF_description": "Descarga el archivo 3MF desde geometría jscad.",
    "bitbybit.jscad.booleans.intersect": "intersecar",
    "intersect": "intersecar",
    "bitbybit.jscad.booleans.intersect_description": "Intersectar múltiples objetos de malla sólida",
    "bitbybit.jscad.booleans.subtract": "restar",
    "subtract": "restar",
    "bitbybit.jscad.booleans.subtract_description": "Restar múltiples objetos de malla sólida",
    "bitbybit.jscad.booleans.union": "unir",
    "bitbybit.jscad.booleans.union_description": "Unir múltiples objetos de malla sólida",
    "bitbybit.jscad.booleans.intersectTwo": "intersecar dos",
    "intersectTwo": "intersecar dos",
    "bitbybit.jscad.booleans.intersectTwo_description": "Intersectar dos objetos de malla sólida",
    "bitbybit.jscad.booleans.subtractTwo": "restar dos",
    "subtractTwo": "restar dos",
    "bitbybit.jscad.booleans.subtractTwo_description": "Restar dos objetos de malla sólida",
    "bitbybit.jscad.booleans.unionTwo": "unir dos",
    "unionTwo": "unir dos",
    "bitbybit.jscad.booleans.unionTwo_description": "Unir dos objetos de malla sólida",
    "bitbybit.jscad.booleans.subtractFrom": "restar de",
    "subtractFrom": "restar de",
    "bitbybit.jscad.booleans.subtractFrom_description": "Restar múltiples mallas desde un objeto de malla",
    "bitbybit.jscad.expansions.expand": "expandir",
    "expansions": "expansiones",
    "expand": "expandir",
    "bitbybit.jscad.expansions.expand_description": "Expandir geometrías de categoría sólida",
    "expansion": "expansión",
    "delta": "delta",
    "corners": "esquinas",
    "solidCornerTypeEnum": "enum tipo esquina sólido",
    "bitbybit.jscad.expansions.offset": "desplazamiento",
    "bitbybit.jscad.expansions.offset_description": "Compensar geometrías 2d de categoría sólida",
    "bitbybit.jscad.extrusions.extrudeLinear": "extruir lineal",
    "extrudeLinear": "extruir lineal",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Extruir linealmente geometrías 2D de categoría sólida",
    "twistAngle": "ángulo torsión",
    "twistSteps": "pasos torsión",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extruir rectangular",
    "extrudeRectangular": "extruir rectangular",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Extruir rectangularmente geometrías 2D de categoría sólida. Crea una extrusión tipo pared de cierta altura y tamaño.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extruir puntos rectangulares",
    "extrudeRectangularPoints": "extruir puntos rectangulares",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Extruir rectangularmente una lista de puntos 2D. Crea una extrusión tipo pared de cierta altura y tamaño.",
    "bitbybit.jscad.extrusions.extrudeRotate": "extruir rotar",
    "extrudeRotate": "extruir rotar",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Extruir rectangularmente una lista de puntos 2D. Crea una extrusión tipo pared de cierta altura y tamaño.",
    "polygon": "polígono",
    "startAngle": "ángulo inicial",
    "bitbybit.jscad.hulls.hullChain": "casco cadena",
    "hulls": "cascos",
    "hullChain": "casco cadena",
    "bitbybit.jscad.hulls.hullChain_description": "Cadena de casco conecta sólidos o geometrías 2d llenando un espacio vacío entre objetos en orden. Las geometrías necesitan ser del mismo tipo.",
    "bitbybit.jscad.hulls.hull": "casco",
    "hull": "casco",
    "bitbybit.jscad.hulls.hull_description": "Casco convexo conecta sólidos o geometrías 2d llenando un espacio vacío entre medio sin seguir orden. Las geometrías necesitan ser del mismo tipo.",
    "bitbybit.jscad.path.createFromPoints": "desde puntos",
    "createFromPoints": "desde puntos",
    "bitbybit.jscad.path.createFromPoints_description": "Crea una ruta 2D desde una lista de puntos",
    "Base.Point2[]": "array punto base 2",
    "bitbybit.jscad.path.createPathsFromPoints": "rutas desde puntos",
    "createPathsFromPoints": "rutas desde puntos",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Crea rutas 2D desde listas de puntos",
    "pointsLists": "listas puntos",
    "Base.Point3[][] | Base.Point2[][]": "array array punto base 3 o 2",
    "bitbybit.jscad.path.createFromPolyline": "desde polilínea",
    "createFromPolyline": "desde polilínea",
    "bitbybit.jscad.path.createFromPolyline_description": "Crea una ruta 2D desde una polilínea",
    "bitbybit.jscad.path.createEmpty": "vacío",
    "createEmpty": "vacío",
    "bitbybit.jscad.path.createEmpty_description": "Crea ruta 2D vacía",
    "bitbybit.jscad.path.close": "cerrar",
    "close": "cerrar",
    "bitbybit.jscad.path.close_description": "Cierra una ruta 2D abierta",
    "bitbybit.jscad.path.appendPoints": "añadir puntos",
    "appendPoints": "añadir puntos",
    "bitbybit.jscad.path.appendPoints_description": "Añade la ruta con puntos 2D",
    "append": "añadir",
    "bitbybit.jscad.path.appendPolyline": "añadir polilínea",
    "appendPolyline": "añadir polilínea",
    "bitbybit.jscad.path.appendPolyline_description": "Añade la ruta con polilínea",
    "bitbybit.jscad.path.appendArc": "añadir arco",
    "appendArc": "añadir arco",
    "bitbybit.jscad.path.appendArc_description": "Añade el arco a la ruta",
    "xAxisRotation": "rotación eje x",
    "clockwise": "sentido horario",
    "large": "grande",
    "bitbybit.jscad.polygon.createFromPoints": "desde puntos",
    "bitbybit.jscad.polygon.createFromPoints_description": "Crea un polígono 2D desde una lista de puntos",
    "bitbybit.jscad.polygon.createFromPolyline": "desde polilínea",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Crea un polígono 2D desde una polilínea",
    "bitbybit.jscad.polygon.createFromCurve": "desde curva",
    "createFromCurve": "desde curva",
    "bitbybit.jscad.polygon.createFromCurve_description": "Crea un polígono 2D desde una curva",
    "bitbybit.jscad.polygon.createFromPath": "desde ruta",
    "createFromPath": "desde ruta",
    "bitbybit.jscad.polygon.createFromPath_description": "Crea un polígono 2D desde una ruta",
    "bitbybit.jscad.polygon.circle": "círculo",
    "bitbybit.jscad.polygon.circle_description": "Crea un círculo polígono 2D",
    "bitbybit.jscad.polygon.ellipse": "elipse",
    "ellipse": "elipse",
    "bitbybit.jscad.polygon.ellipse_description": "Crea una elipse polígono 2D",
    "bitbybit.jscad.polygon.rectangle": "rectángulo",
    "rectangle": "rectángulo",
    "bitbybit.jscad.polygon.rectangle_description": "Crea un rectángulo polígono 2D",
    "bitbybit.jscad.polygon.roundedRectangle": "rectángulo redondeado",
    "roundedRectangle": "rectángulo redondeado",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Crea un rectángulo redondeado 2D",
    "roundRadius": "radio redondeo",
    "bitbybit.jscad.polygon.square": "cuadrado",
    "square": "cuadrado",
    "bitbybit.jscad.polygon.square_description": "Crea un cuadrado polígono 2D",
    "bitbybit.jscad.polygon.star": "estrella",
    "star": "estrella",
    "bitbybit.jscad.polygon.star_description": "Crea una estrella polígono 2D",
    "vertices": "vértices",
    "bitbybit.jscad.shapes.cube": "cubo",
    "cube": "cubo",
    "bitbybit.jscad.shapes.cube_description": "Crea una forma de cubo 3D",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubos en puntos centrales",
    "cubesOnCenterPoints": "cubos en puntos centrales",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Crea cubos 3D en múltiples puntos centrales",
    "primitives on centers": "primitivas en centros",
    "bitbybit.jscad.shapes.cuboid": "cuboide",
    "cuboid": "cuboide",
    "bitbybit.jscad.shapes.cuboid_description": "Crea una forma de cuboide 3D",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "cuboides en puntos centrales",
    "cuboidsOnCenterPoints": "cuboides en puntos centrales",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Crea cuboides 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.cylinderElliptic": "cilindro elíptico",
    "cylinderElliptic": "cilindro elíptico",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Crea un sólido cilindro elíptico 3D",
    "startRadius": "radio inicial",
    "endRadius": "radio final",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cilindro elíptico en puntos centrales",
    "cylinderEllipticOnCenterPoints": "cilindro elíptico en puntos centrales",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Crea cilindros elípticos 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.cylinder": "cilindro",
    "cylinder": "cilindro",
    "bitbybit.jscad.shapes.cylinder_description": "Crea un sólido cilindro 3D",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cilindros en puntos centrales",
    "cylindersOnCenterPoints": "cilindros en puntos centrales",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Crea cilindros 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.ellipsoid": "elipsoide",
    "ellipsoid": "elipsoide",
    "bitbybit.jscad.shapes.ellipsoid_description": "Crea un sólido elipsoide 3D",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "elipsoides en puntos centrales",
    "ellipsoidsOnCenterPoints": "elipsoides en puntos centrales",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Crea elipsoides 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.geodesicSphere": "esfera geodésica",
    "geodesicSphere": "esfera geodésica",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Crea un sólido esfera geodésica 3D",
    "frequency": "frecuencia",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "esferas geodésicas en puntos centrales",
    "geodesicSpheresOnCenterPoints": "esferas geodésicas en puntos centrales",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Crea esferas geodésicas 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.roundedCuboid": "cuboide redondeado",
    "roundedCuboid": "cuboide redondeado",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Crea un sólido cuboide redondeado 3D",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "cuboides redondeados en puntos centrales",
    "roundedCuboidsOnCenterPoints": "cuboides redondeados en puntos centrales",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Crea cuboides redondeados 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.roundedCylinder": "cilindro redondeado",
    "roundedCylinder": "cilindro redondeado",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Crea un sólido cilindro redondeado 3D",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "cilindros redondeados en puntos centrales",
    "roundedCylindersOnCenterPoints": "cilindros redondeados en puntos centrales",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Crea cilindros redondeados 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.sphere": "esfera",
    "sphere": "esfera",
    "bitbybit.jscad.shapes.sphere_description": "Crea un sólido esfera 3D",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "esferas en puntos centrales",
    "spheresOnCenterPoints": "esferas en puntos centrales",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Crea una esfera 3D en múltiples puntos centrales",
    "bitbybit.jscad.shapes.torus": "toro",
    "torus": "toro",
    "bitbybit.jscad.shapes.torus_description": "Crea un sólido toro 3D",
    "innerSegments": "segmentos interiores",
    "outerSegments": "segmentos exteriores",
    "innerRotation": "rotación interior",
    "outerRotation": "rotación exterior",
    "bitbybit.jscad.shapes.fromPolygonPoints": "desde puntos polígono",
    "fromPolygonPoints": "desde puntos polígono",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Crea una forma 3D desde puntos de polígono que deben ser arrays anidados de puntos",
    "polygonPoints": "puntos polígono",
    "Base.Point3[][]": "array array punto base 3",
    "bitbybit.jscad.text.cylindricalText": "texto cilíndrico",
    "cylindricalText": "texto cilíndrico",
    "bitbybit.jscad.text.cylindricalText_description": "Crea un texto que se basa en cascos de cadena de cilindros",
    "extrusionHeight": "altura extrusión",
    "extrusionSize": "tamaño extrusión",
    "jscadTextAlignEnum": "enum alineación texto jscad",
    "bitbybit.jscad.text.sphericalText": "texto esférico",
    "sphericalText": "texto esférico",
    "bitbybit.jscad.text.sphericalText_description": "Crea un texto que se basa en cascos de cadena de esferas",
    "bitbybit.jscad.text.createVectorText": "crear texto vectorial",
    "createVectorText": "crear texto vectorial",
    "bitbybit.jscad.text.createVectorText_description": "Crea un texto vectorial",
    "bitbybit.jscad.colors.colorize": "colorear",
    "colors": "colores",
    "colorize": "colorear",
    "bitbybit.jscad.colors.colorize_description": "Colorea geometría de jscad. Si la geometría está en el array coloreará todos los elementos y los devolverá. Si la geometría es un solo elemento devolverá un solo elemento. Tenga en cuenta que la geometría coloreada en jscad siempre se dibujará en ese color incluso si intenta cambiarlo a través de opciones de dibujo.",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold a puntero malla",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold a puntero malla",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Convierte forma manifold en un puntero de malla que vive en la memoria del trabajador. Este puntero se puede usar con funciones bitbybit.manifold.mesh",
    "meshing": "mallado",
    "normalIdx": "índice normal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "descomponer manifold o sección transversal",
    "decomposeManifoldOrCrossSection": "descomponer manifold o sección transversal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Descompone forma manifold o sección transversal en una malla o polígonos simples",
    "decompose": "descomponer",
    "manifoldOrCrossSection": "manifold o sección transversal",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "descomponer manifolds o secciones transversales",
    "decomposeManifoldsOrCrossSections": "descomponer manifolds o secciones transversales",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Descompone forma manifold o sección transversal en una malla o polígonos simples",
    "manifoldsOrCrossSections": "manifolds o secciones transversales",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "eliminar manifold o sección transversal",
    "deleteManifoldOrCrossSection": "eliminar manifold o sección transversal",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Elimina manifold o sección transversal de la memoria",
    "cleanup": "limpieza",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "eliminar manifolds o secciones transversales",
    "deleteManifoldsOrCrossSections": "eliminar manifolds o secciones transversales",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Elimina manifolds o secciones transversales de la memoria",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold a malla",
    "manifoldToMesh": "manifold a malla",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Convierte forma manifold en una malla",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds a mallas",
    "manifoldsToMeshes": "manifolds a mallas",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "convierte formas manifold en mallas",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold desde malla",
    "manifoldFromMesh": "manifold desde malla",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Convierte una Malla en un Manifold, conservando sus propiedades y fusionando solo las posiciones de acuerdo con los vectores de fusión. Lanzará un error si el resultado no es un 2-manifold orientado. Colapsará triángulos degenerados y vértices innecesarios. Todos los campos se leen, haciendo esta estructura adecuada para un viaje de ida y vuelta sin pérdidas de datos desde manifoldToMesh(). Para entrada de múltiples materiales, use reserveIDs() para establecer un originalID único para cada material, y clasifique los materiales en ejecuciones de triángulo.",
    "DecomposedManifoldMeshDto": "dto malla manifold descompuesta",
    "bitbybit.manifold.manifold.shapes.cube": "cubo",
    "bitbybit.manifold.manifold.shapes.cube_description": "Crea una forma de cubo 3D",
    "bitbybit.manifold.manifold.shapes.sphere": "esfera",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Crea una forma de esfera 3D",
    "circularSegments": "segmentos circulares",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tetraedro",
    "tetrahedron": "tetraedro",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Crea una forma de tetraedro 3D",
    "bitbybit.manifold.manifold.shapes.cylinder": "cilindro",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Crea una forma de cilindro 3D",
    "radiusLow": "radio bajo",
    "radiusHigh": "radio alto",
    "bitbybit.manifold.manifold.booleans.subtract": "restar",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Resta dos formas manifold",
    "a to b": "a a b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "sumar",
    "bitbybit.manifold.manifold.booleans.add_description": "Suma dos formas manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "intersecar",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Intersecta dos formas manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "diferencia dos",
    "differenceTwo": "diferencia dos",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "diferencia de dos formas manifold",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "unión dos",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "unión de dos formas manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "intersección dos",
    "intersectionTwo": "intersección dos",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "intersección de dos formas manifold",
    "bitbybit.manifold.manifold.booleans.difference": "diferencia",
    "bitbybit.manifold.manifold.booleans.difference_description": "diferencia de múltiples formas manifold",
    "bitbybit.manifold.manifold.booleans.union": "unión",
    "bitbybit.manifold.manifold.booleans.union_description": "unión de múltiples formas manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "intersección",
    "bitbybit.manifold.manifold.booleans.intersection_description": "intersección de múltiples formas manifold",
    "bitbybit.manifold.manifold.booleans.split": "dividir",
    "split": "dividir",
    "bitbybit.manifold.manifold.booleans.split_description": "Divide manifold por otro manifold",
    "manifoldToSplit": "manifold a dividir",
    "manifoldCutter": "cortador manifold",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "dividir por plano",
    "splitByPlane": "dividir por plano",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Divide manifold por plano",
    "originOffset": "desplazamiento origen",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "dividir por plano en desplazamientos",
    "splitByPlaneOnOffsets": "dividir por plano en desplazamientos",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Divide manifold por plano en varios desplazamientos",
    "originOffsets": "desplazamientos origen",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "recortar por plano",
    "trimByPlane": "recortar por plano",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Recorta manifold por plano",
    "trim": "recortar",
    "bitbybit.manifold.manifold.operations.hull": "casco",
    "bitbybit.manifold.manifold.operations.hull_description": "Calcula casco convexo de la forma manifold proporcionada",
    "bitbybit.manifold.manifold.operations.hullPoints": "casco puntos",
    "hullPoints": "casco puntos",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Puntos de casco o manifolds",
    "bitbybit.manifold.manifold.operations.slice": "rebanar",
    "bitbybit.manifold.manifold.operations.slice_description": "Devuelve la sección transversal de este objeto paralela al plano X-Y a la altura especificada. Usar una altura igual a la parte inferior del cuadro delimitador devolverá las caras inferiores, mientras que usar una altura igual a la parte superior del cuadro delimitador devolverá vacío.",
    "cross sections": "secciones transversales",
    "bitbybit.manifold.manifold.operations.project": "proyectar",
    "bitbybit.manifold.manifold.operations.project_description": "Crea una proyección en plano xy desde el contorno de la forma",
    "bitbybit.manifold.manifold.operations.setTolerance": "establecer tolerancia",
    "setTolerance": "establecer tolerancia",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Devuelve una copia del manifold con el valor de tolerancia establecido. Esto realiza simplificación de malla cuando el valor de tolerancia aumenta.",
    "basic": "básico",
    "bitbybit.manifold.manifold.operations.reserveIds": "reservar ids",
    "reserveIds": "reservar ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Devuelve el primero de n nuevos IDs de malla únicos secuenciales para marcar conjuntos de triángulos que se pueden buscar después de operaciones adicionales. Asignar a vector Mesh.runOriginalID.",
    "count": "contar",
    "bitbybit.manifold.manifold.operations.asOriginal": "como original",
    "asOriginal": "como original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "Si copias un manifold, pero quieres que esta nueva copia tenga nuevas propiedades (por ejemplo, un mapeo UV diferente), puedes restablecer sus IDs a un nuevo original, lo que significa que ahora será referenciado por sus descendientes en lugar de las mallas de las que se construyó, permitiéndote diferenciar las copias al aplicar tus propiedades al resultado final. Esta función también condensa todas las caras coplanares en la relación, y colapsa esas aristas. Si quieres tener propiedades inconsistentes a través de estas caras, lo que significa que quieres preservar algunas de estas aristas, deberías llamar a GetMesh(), calcular tus propiedades y usarlas para construir un nuevo manifold.",
    "bitbybit.manifold.manifold.operations.compose": "componer",
    "compose": "componer",
    "bitbybit.manifold.manifold.operations.compose_description": "Construye un nuevo manifold desde una lista de otros manifolds. Esta es una operación puramente topológica, por lo que se debe tener cuidado para evitar crear resultados superpuestos. Es la operación inversa de Decompose().",
    "composition": "composición",
    "bitbybit.manifold.manifold.operations.decompose": "descomponer",
    "bitbybit.manifold.manifold.operations.decompose_description": "Esta operación devuelve un vector de Manifolds que están topológicamente desconectados. Si todo está conectado, el vector es de longitud uno, conteniendo una copia del original. Es la operación inversa de Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calcular normales",
    "calculateNormals": "calcular normales",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Rellena propiedades de vértice para vectores normales, calculados desde la geometría de la malla. Las caras planas compuestas de tres o más triángulos permanecerán planas.",
    "adjustments": "ajustes",
    "minSharpAngle": "ángulo agudo mín",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calcular curvatura",
    "calculateCurvature": "calcular curvatura",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "La curvatura es el inverso del radio de curvatura, y con signo tal que positivo es convexo y negativo es cóncavo. Hay dos curvaturas principales ortogonales en cualquier punto en un manifold, con una máxima y la otra mínima. La curvatura gaussiana es su producto, mientras que la curvatura media es su suma. Esto las aproxima para cada vértice y las asigna como propiedades de vértice en los canales dados.",
    "gaussianIdx": "índice gaussiano",
    "meanIdx": "índice medio",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "refinar a tolerancia",
    "refineToTolerance": "refinar a tolerancia",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Aumenta la densidad de la malla dividiendo cada arista en piezas de tal manera que cualquier punto en los triángulos resultantes esté aproximadamente dentro de la tolerancia de la superficie suavemente curvada definida por los vectores tangentes. Esto significa que las regiones que se curvan estrechamente se dividirán más finamente que las regiones más suaves. Si no hay tangentes de media arista presentes, el resultado será simplemente una copia del original. Los quads ignorarán su bisectriz de triángulo interior.",
    "bitbybit.manifold.manifold.operations.refineToLength": "refinar a longitud",
    "refineToLength": "refinar a longitud",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Aumenta la densidad de la malla dividiendo cada arista en piezas de aproximadamente la longitud de entrada. Se añaden vértices interiores para mantener el resto de las aristas de triangulación también de aproximadamente la misma longitud. Si hay tangentes de media arista presentes (por ejemplo, del constructor Smooth()), los nuevos vértices se moverán a la superficie interpolada de acuerdo con sus coordenadas baricéntricas.",
    "bitbybit.manifold.manifold.operations.refine": "refinar",
    "refine": "refinar",
    "bitbybit.manifold.manifold.operations.refine_description": "Aumenta la densidad de la malla dividiendo cada arista en n piezas. Por ejemplo, con n = 2, cada triángulo se dividirá en 4 triángulos. Estos serán todos coplanares (y no se colapsarán inmediatamente) a menos que el MeshManifold tenga tangentes de media arista especificadas (por ejemplo, del constructor Smooth()), en cuyo caso los nuevos vértices se moverán a la superficie interpolada de acuerdo con sus coordenadas baricéntricas.",
    "bitbybit.manifold.manifold.operations.smoothOut": "suavizar",
    "smoothOut": "suavizar",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Suaviza el Manifold rellenando los vectores tangentes de media arista. La geometría permanecerá sin cambios hasta que se llame a Refine o RefineToLength para interpolar la superficie. Esta versión usa la geometría de los triángulos y pseudo-normales para definir los vectores tangentes.",
    "minSmoothness": "suavidad mín",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "suavizar por normales",
    "smoothByNormals": "suavizar por normales",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Suaviza el Manifold rellenando los vectores tangentes de media arista. La geometría permanecerá sin cambios hasta que se llame a Refine o RefineToLength para interpolar la superficie. Esta versión usa las propiedades normales de vértice suministradas para definir los vectores tangentes.",
    "bitbybit.manifold.manifold.transforms.scale3D": "escalar 3d",
    "scale3D": "escalar 3d",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Escala una forma manifold con vector 3D",
    "bitbybit.manifold.manifold.transforms.scale": "escalar",
    "bitbybit.manifold.manifold.transforms.scale_description": "Escala una forma manifold con factor único",
    "bitbybit.manifold.manifold.transforms.mirror": "reflejar",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Refleja una forma manifold sobre un plano definido por un vector normal",
    "bitbybit.manifold.manifold.transforms.translate": "trasladar",
    "bitbybit.manifold.manifold.transforms.translate_description": "Traslada una forma manifold a lo largo del vector",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "trasladar por vectores",
    "translateByVectors": "trasladar por vectores",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Traslada una forma manifold a lo largo por múltiples vectores",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "trasladar xyz",
    "translateXYZ": "trasladar xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Traslada una forma manifold a lo largo de x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "rotar",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Rota una forma manifold a lo largo del vector conteniendo ángulos euler",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "rotar xyz",
    "rotateXYZ": "rotar xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Rota una forma manifold a lo largo de los ángulos euler x y z",
    "bitbybit.manifold.manifold.transforms.transform": "transformar",
    "bitbybit.manifold.manifold.transforms.transform_description": "Transforma una forma manifold usando la matriz de transformación 4x4",
    "matrix": "matriz",
    "Base.TransformMatrix": "matriz transformación base",
    "bitbybit.manifold.manifold.transforms.transforms": "transformaciones",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Transforma una forma manifold usando las matrices de transformación 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "área superficial",
    "evaluate": "evaluar",
    "surfaceArea": "área superficial",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Obtener área de superficie de manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volumen",
    "volume": "volumen",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Obtener volumen de manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "está vacío",
    "isEmpty": "está vacío",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Comprobar si manifold contiene triángulos",
    "bitbybit.manifold.manifold.evaluate.numVert": "núm vértices",
    "numVert": "núm vértices",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Obtener número de vértices en manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "núm triángulos",
    "numTri": "núm triángulos",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Obtener número de triángulos en manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "núm aristas",
    "numEdge": "núm aristas",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Obtener número de aristas en manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "núm prop",
    "numProp": "núm prop",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Obtener número de propiedades en manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "núm prop vértice",
    "numPropVert": "núm prop vértice",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "El número de vértices de propiedad en el Manifold. Esto siempre será >= numVert, ya que algunos vértices físicos pueden estar duplicados para tener en cuenta diferentes propiedades en diferentes triángulos vecinos.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "caja delimitadora",
    "boundingBox": "caja delimitadora",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Devuelve el cuadro delimitador alineado al eje de todos los vértices del Manifold.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolerancia",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Devuelve la tolerancia de los vértices de este Manifold, que rastrea el error de redondeo aproximado sobre todas las transformaciones y operaciones que han llevado a este estado. Cualquier triángulo que sea colineal dentro de esta tolerancia se considera degenerado y se elimina.",
    "bitbybit.manifold.manifold.evaluate.genus": "género",
    "genus": "género",
    "bitbybit.manifold.manifold.evaluate.genus_description": "El género es una propiedad topológica del manifold, representando el número de asas. Una esfera es 0, toro 1, etc. Solo es significativo para una sola malla, por lo que es mejor llamar a Decompose() primero.",
    "bitbybit.manifold.manifold.evaluate.minGap": "hueco mín",
    "minGap": "hueco mín",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Devuelve el espacio mínimo entre dos manifolds. Devuelve un flotante entre 0 y searchLength.",
    "searchLength": "longitud búsqueda",
    "bitbybit.manifold.manifold.evaluate.originalID": "id original",
    "originalID": "id original",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "Si esta malla es un original, esto devuelve su ID que puede ser referenciado por manifolds producto. Si este manifold es un producto, esto devuelve -1.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "sección transversal a polígonos",
    "crossSection": "sección transversal",
    "crossSectionToPolygons": "sección transversal a polígonos",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "convierte sección transversal en polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "secciones transversales a polígonos",
    "crossSectionsToPolygons": "secciones transversales a polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "convierte secciones transversales en polígonos",
    "crossSections": "secciones transversales",
    "bitbybit.manifold.crossSection.shapes.create": "crear",
    "bitbybit.manifold.crossSection.shapes.create_description": "Crea una sección transversal 2d desde un conjunto de contornos (polígonos complejos). Se realiza una operación de unión booleana (con regla de relleno Positiva por defecto) para combinar polígonos superpuestos y asegurar que la Sección Transversal resultante esté libre de intersecciones.",
    "Base.Vector2[][]": "array de array de vector base 2",
    "fillRule": "regla relleno",
    "fillRuleEnum": "enum regla relleno",
    "bitbybit.manifold.crossSection.shapes.square": "cuadrado",
    "bitbybit.manifold.crossSection.shapes.square_description": "Crea una sección transversal cuadrada 2D",
    "bitbybit.manifold.crossSection.shapes.circle": "círculo",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Crea una sección transversal circular 2D",
    "bitbybit.manifold.crossSection.shapes.rectangle": "rectángulo",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Crea una sección transversal rectangular 2D",
    "bitbybit.manifold.crossSection.operations.hull": "casco",
    "bitbybit.manifold.crossSection.operations.hull_description": "Calcula casco convexo para la sección transversal",
    "bitbybit.manifold.crossSection.operations.extrude": "extruir",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Extruye la sección transversal para crear una forma 3D",
    "nDivisions": "n divisiones",
    "twistDegrees": "grados torsión",
    "scaleTopX": "escala sup x",
    "scaleTopY": "escala sup y",
    "bitbybit.manifold.crossSection.operations.revolve": "revolucionar",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Revoluciona la sección transversal para crear una forma 3D",
    "revolveDegrees": "grados revolución",
    "matchProfile": "coincidir perfil",
    "bitbybit.manifold.crossSection.operations.offset": "desplazamiento",
    "bitbybit.manifold.crossSection.operations.offset_description": "Compensa la sección transversal para crear una nueva sección transversal con un delta dado (usa algoritmo Clipper2 detrás).",
    "manifoldJoinTypeEnum": "enum tipo unión manifold",
    "miterLimit": "límite inglete",
    "bitbybit.manifold.crossSection.operations.simplify": "simplificar",
    "simplify": "simplificar",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Elimina vértices de los contornos en esta Sección Transversal que están a menos de la distancia épsilon especificada de una línea imaginaria que pasa a través de sus dos vértices adyacentes. Vértices casi duplicados y puntos colineales se eliminarán en épsilones más bajos, con eliminación de segmentos de línea volviéndose cada vez más agresiva con épsilones más grandes. Se recomienda aplicar esta función después de Offset, para limpiar cualquier segmento de línea diminuto espurio introducido que no mejore las operaciones de compensación a realizar, lo que agravaría el problema.",
    "epsilon": "épsilon",
    "bitbybit.manifold.crossSection.operations.compose": "componer",
    "bitbybit.manifold.crossSection.operations.compose_description": "Compone múltiples secciones transversales o polígonos en una sola sección transversal",
    "bitbybit.manifold.crossSection.operations.decompose": "descomponer",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Descompone secciones transversales que están topológicamente desconectadas, conteniendo cada una un contorno exterior con cero o más agujeros.",
    "bitbybit.manifold.crossSection.booleans.subtract": "restar",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Resta dos secciones transversales",
    "crossSection1": "sección transversal 1",
    "crossSection2": "sección transversal 2",
    "bitbybit.manifold.crossSection.booleans.add": "sumar",
    "bitbybit.manifold.crossSection.booleans.add_description": "Suma dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.intersect": "intersecar",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Intersecta dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "diferencia dos",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "diferencia de dos secciones transversales",
    "2 cross sections": "2 secciones transversales",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "unión dos",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "unión de dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "intersección dos",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "intersección de dos secciones transversales",
    "bitbybit.manifold.crossSection.booleans.difference": "diferencia",
    "bitbybit.manifold.crossSection.booleans.difference_description": "diferencia de múltiples secciones transversales",
    "bitbybit.manifold.crossSection.booleans.union": "unión",
    "bitbybit.manifold.crossSection.booleans.union_description": "unión de múltiples secciones transversales",
    "bitbybit.manifold.crossSection.booleans.intersection": "intersección",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "intersección de múltiples secciones transversales",
    "bitbybit.manifold.crossSection.transforms.scale2D": "escalar 2d",
    "scale2D": "escalar 2d",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Escala una forma de sección transversal con vector 2D",
    "bitbybit.manifold.crossSection.transforms.scale": "escalar",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Escala una forma de sección transversal con factor único",
    "bitbybit.manifold.crossSection.transforms.mirror": "reflejar",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Refleja una forma de sección transversal sobre un plano definido por un vector normal",
    "bitbybit.manifold.crossSection.transforms.translate": "trasladar",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Traslada una forma de sección transversal a lo largo del vector",
    "bitbybit.manifold.crossSection.transforms.translateXY": "trasladar xy",
    "translateXY": "trasladar xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Traslada una forma de sección transversal a lo largo de x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "rotar",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Rota una forma de sección transversal a lo largo de los grados contenidos",
    "degrees": "grados",
    "bitbybit.manifold.crossSection.transforms.transform": "transformar",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Transforma una forma de sección transversal usando la matriz de transformación 3x3",
    "Base.TransformMatrix3x3": "matriz transformación base 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "área",
    "area": "área",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Obtener área de sección transversal",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "está vacío",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Comprobar si sección transversal está vacía",
    "bitbybit.manifold.crossSection.evaluate.numVert": "núm vértices",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Obtener número de vértices en sección transversal",
    "bitbybit.manifold.crossSection.evaluate.numContour": "núm contorno",
    "numContour": "núm contorno",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Obtener número de contornos en sección transversal",
    "bitbybit.manifold.crossSection.evaluate.bounds": "límites",
    "bounds": "límites",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Obtener los límites del contorno como un rectángulo. La salida se da en dos puntos vec2 en el array. El primer array es el punto min y el segundo array es el punto max.",
    "bitbybit.manifold.mesh.operations.merge": "fusionar",
    "merge": "fusionar",
    "bitbybit.manifold.mesh.operations.merge_description": "Actualiza los vectores mergeFromVert y mergeToVert para crear un sólido manifold. Si la MeshGL ya es manifold, no ocurrirá ningún cambio y la función devolverá falso. De lo contrario, esto fusionará vértices a lo largo de aristas abiertas dentro de tolerancia (el máximo de la tolerancia MeshGL y la tolerancia de cuadro delimitador base), manteniendo cualquiera de los vectores de fusión existentes. No hay garantía de que el resultado sea manifold - esta es una función auxiliar de mejor esfuerzo diseñada principalmente para ayudar en el caso donde se produjo una MeshGL de múltiples materiales manifold, pero sus vectores de fusión se perdieron debido a un viaje de ida y vuelta a través de un formato de archivo. Construir un Manifold a partir del resultado informará un Estado si no es manifold.",
    "bitbybit.manifold.mesh.evaluate.position": "posición",
    "bitbybit.manifold.mesh.evaluate.position_description": "Obtener posición en índice de vértice de malla",
    "vertexIndex": "índice vértice",
    "bitbybit.manifold.mesh.evaluate.verts": "vértices",
    "verts": "vértices",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Obtiene los tres índices de vértice de este triángulo en orden CCW.",
    "triangleIndex": "índice triángulo",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangente",
    "tangent": "tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Obtiene el vector tangente comenzando en verts(tri)[j] apuntando al siguiente punto Bezier a lo largo de la arista CCW. El cuarto valor es su peso.",
    "halfEdgeIndex": "índice media arista",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Obtiene cualquier otra propiedad asociada con este vértice.",
    "bitbybit.manifold.mesh.evaluate.transform": "transformar",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Obtiene la matriz de transformación 4x4 de columna mayor desde la malla original a estos triángulos relacionados.",
    "bitbybit.manifold.mesh.evaluate.numProp": "núm prop",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Número de propiedades por vértice, siempre >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "núm vértices",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Número de vértices de propiedad",
    "bitbybit.manifold.mesh.evaluate.numTri": "núm triángulos",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Obtener número de triángulos en malla",
    "bitbybit.manifold.mesh.evaluate.numRun": "núm ejecución",
    "numRun": "núm ejecución",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Número de ejecuciones de triángulo. Cada ejecución de triángulo es un conjunto de triángulos consecutivos que provienen de la misma instancia de la misma malla de entrada.",
    "bitbybit.logic.boolean": "booleano",
    "logic": "lógica",
    "bitbybit.logic.boolean_description": "Crea y devuelve un valor booleano (paso a través para entrada booleana). Ejemplo: true → true, false → false",
    "bitbybit.logic.randomBooleans": "booleanos aleatorios",
    "randomBooleans": "booleanos aleatorios",
    "bitbybit.logic.randomBooleans_description": "Genera una lista booleana aleatoria donde cada valor tiene una probabilidad umbral de ser verdadero. Ejemplo: longitud=5, umbral=0.7 → podría producir [true, true, false, true, true]",
    "trueThreshold": "umbral verdadero",
    "bitbybit.logic.twoThresholdRandomGradient": "gradiente aleatorio dos umbrales",
    "twoThresholdRandomGradient": "gradiente aleatorio dos umbrales",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Convierte números a booleanos usando dos umbrales con aleatorización de gradiente entre ellos. Valores por debajo de umbralVerdadero → siempre true, por encima de umbralFalso → siempre false. Entre umbrales → gradiente de probabilidad (más cerca al umbral falso = mayor probabilidad de false). Ejemplo: [0.1, 0.4, 0.6, 0.9] con umbrales [0.3, 0.7] → [true, gradiente, gradiente, false]",
    "numbers": "números",
    "thresholdTotalTrue": "umbral total verdadero",
    "thresholdTotalFalse": "umbral total falso",
    "nrLevels": "núm niveles",
    "bitbybit.logic.thresholdBooleanList": "lista booleana umbral",
    "thresholdBooleanList": "lista booleana umbral",
    "bitbybit.logic.thresholdBooleanList_description": "Convierte números a booleanos basados en un umbral (por debajo del umbral → true, por encima → false). Se puede invertir para cambiar la lógica. Ejemplo: [0.3, 0.7, 0.5] con umbral=0.6 → [true, false, true]",
    "threshold": "umbral",
    "bitbybit.logic.thresholdGapsBooleanList": "lista booleana umbral huecos",
    "thresholdGapsBooleanList": "lista booleana umbral huecos",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Convierte números a booleanos usando múltiples umbrales de rango (brechas definen rangos verdaderos). Valores dentro de cualquier rango de brecha → true, fuera de todas las brechas → false. Se puede invertir. Ejemplo: [0.2, 0.5, 0.8] con brechas [[0.3, 0.6], [0.7, 0.9]] → [false, true, true]",
    "gapThresholds": "umbrales hueco",
    "Base.Vector2[]": "array vector base 2",
    "bitbybit.logic.not": "no",
    "not": "no",
    "bitbybit.logic.not_description": "Aplica operador NOT para invertir un valor booleano. Ejemplo: true → false, false → true",
    "bitbybit.logic.notList": "no lista",
    "notList": "no lista",
    "bitbybit.logic.notList_description": "Aplica operador NOT para invertir todos los valores booleanos en una lista. Ejemplo: [true, false, true] → [false, true, false]",
    "bitbybit.logic.compare": "comparar",
    "compare": "comparar",
    "bitbybit.logic.compare_description": "Compara dos valores usando varios operadores (==, !=, ===, !==, <, <=, >, >=). Ejemplo: 5 > 3 → true, 'hola' === 'mundo' → false",
    "operator": "operador",
    "BooleanOperatorsEnum": "enum operadores booleanos",
    "bitbybit.logic.valueGate": "puerta valor",
    "valueGate": "puerta valor",
    "bitbybit.logic.valueGate_description": "Pasa condicionalmente un valor si booleano es true, de lo contrario devuelve undefined. Ejemplo: valor=42, booleano=true → 42, valor=42, booleano=false → undefined",
    "bitbybit.logic.firstDefinedValueGate": "puerta primer valor definido",
    "firstDefinedValueGate": "puerta primer valor definido",
    "bitbybit.logic.firstDefinedValueGate_description": "Devuelve el primer valor definido (no-undefined) de dos opciones (patrón fallback). Ejemplo: valor1=42, valor2=10 → 42, valor1=undefined, valor2=10 → 10",
    "value1": "valor 1",
    "value2": "valor 2",
    "bitbybit.math.number": "número",
    "math": "matemáticas",
    "bitbybit.math.number_description": "Crea y devuelve un valor numérico (paso a través para entrada numérica). Ejemplo: Entrada 42 → 42, Entrada 3.14 → 3.14",
    "bitbybit.math.twoNrOperation": "operación dos núm",
    "twoNrOperation": "operación dos núm",
    "bitbybit.math.twoNrOperation_description": "Realiza operaciones aritméticas básicas en dos números (sumar, restar, multiplicar, dividir, potencia, módulo). Ejemplo: 5 + 3 → 8, 10 % 3 → 1, 2 ^ 3 → 8",
    "operation": "operación",
    "mathTwoNrOperatorEnum": "enum operador matemáticas dos núm",
    "bitbybit.math.modulus": "módulo",
    "modulus": "módulo",
    "bitbybit.math.modulus_description": "Calcula el resto después de la división (operación módulo). Ejemplo: 10 % 3 → 1, 17 % 5 → 2",
    "bitbybit.math.roundToDecimals": "redondear a decimales",
    "roundToDecimals": "redondear a decimales",
    "bitbybit.math.roundToDecimals_description": "Redondea un número a decimales especificados. Ejemplo: 1.32156 con 3 decimales devuelve 1.322",
    "decimalPlaces": "lugares decimales",
    "bitbybit.math.oneNrOperation": "operación un núm",
    "oneNrOperation": "operación un núm",
    "bitbybit.math.oneNrOperation_description": "Realiza operaciones matemáticas en un solo número (absoluto, negar, raíz cuadrada, funciones trigonométricas, logaritmos, etc.). Ejemplo: sqrt(5) → 2.236, abs(-3) → 3, sin(π2) → 1",
    "mathOneNrOperatorEnum": "enum operador matemáticas un núm",
    "bitbybit.math.remap": "remapear",
    "remap": "remapear",
    "bitbybit.math.remap_description": "Mapea un número de un rango a otro rango proporcionalmente. Ejemplo: 5 de [0,10] a [0,100] → 50, 0.5 de [0,1] a [-10,10] → 0",
    "fromLow": "desde bajo",
    "fromHigh": "desde alto",
    "toLow": "a bajo",
    "toHigh": "a alto",
    "bitbybit.math.random": "aleatorio",
    "random": "aleatorio",
    "bitbybit.math.random_description": "Genera un número decimal aleatorio entre 0 (inclusivo) y 1 (exclusivo). Ejemplo: Salidas como 0.342, 0.891, o cualquier valor en [0, 1)",
    "generate": "generar",
    "bitbybit.math.randomNumber": "número aleatorio",
    "randomNumber": "número aleatorio",
    "bitbybit.math.randomNumber_description": "Genera un número aleatorio dentro de un rango especificado (bajo a alto). Ejemplo: Rango [0, 10] → salidas como 3.7, 8.2, o cualquier valor entre 0 y 10",
    "low": "bajo",
    "high": "alto",
    "bitbybit.math.randomNumbers": "números aleatorios",
    "randomNumbers": "números aleatorios",
    "bitbybit.math.randomNumbers_description": "Genera múltiples números aleatorios dentro de un rango especificado. Ejemplo: Rango [0, 10] con 3 elementos → [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "Devuelve la constante matemática π (pi) ≈ 3.14159. Ejemplo: Salidas 3.141592653589793",
    "bitbybit.math.toFixed": "a fijo",
    "toFixed": "a fijo",
    "bitbybit.math.toFixed_description": "Formatea un número como una cadena con un número fijo de lugares decimales (siempre muestra ceros finales). Ejemplo: 3.14159 con 2 decimales → '3.14', 5 con 3 decimales → '5.000'",
    "bitbybit.math.add": "sumar",
    "bitbybit.math.add_description": "Suma dos números juntos. Ejemplo: 5 + 3 → 8, -2 + 7 → 5",
    "basics": "básicos",
    "bitbybit.math.subtract": "restar",
    "bitbybit.math.subtract_description": "Resta el segundo número del primero. Ejemplo: 10 - 3 → 7, 5 - 8 → -3",
    "bitbybit.math.multiply": "multiplicar",
    "bitbybit.math.multiply_description": "Multiplica dos números juntos. Ejemplo: 5 × 3 → 15, -2 × 4 → -8",
    "bitbybit.math.divide": "dividir",
    "divide": "dividir",
    "bitbybit.math.divide_description": "Divide el primer número por el segundo. Ejemplo: 10 ÷ 2 → 5, 7 ÷ 2 → 3.5",
    "bitbybit.math.power": "potencia",
    "power": "potencia",
    "bitbybit.math.power_description": "Eleva el primer número a la potencia del segundo (exponenciación). Ejemplo: 2³ → 8, 5² → 25, 10⁻¹ → 0.1",
    "bitbybit.math.sqrt": "raíz cuadrada",
    "sqrt": "raíz cuadrada",
    "bitbybit.math.sqrt_description": "Calcula la raíz cuadrada de un número. Ejemplo: √9 → 3, √2 → 1.414, √16 → 4",
    "bitbybit.math.abs": "absoluto",
    "abs": "absoluto",
    "bitbybit.math.abs_description": "Devuelve el valor absoluto (elimina signo negativo, siempre positivo o cero). Ejemplo: |-5| → 5, |3| → 3, |0| → 0",
    "bitbybit.math.round": "redondear",
    "round": "redondear",
    "bitbybit.math.round_description": "Redondea un número al entero más cercano. Ejemplo: 3.7 → 4, 2.3 → 2, 5.5 → 6",
    "bitbybit.math.floor": "suelo",
    "floor": "suelo",
    "bitbybit.math.floor_description": "Redondea un número hacia abajo al entero más cercano (hacia infinito negativo). Ejemplo: 3.7 → 3, -2.3 → -3, 5 → 5",
    "bitbybit.math.ceil": "techo",
    "ceil": "techo",
    "bitbybit.math.ceil_description": "Redondea un número hacia arriba al entero más cercano (hacia infinito positivo). Ejemplo: 3.2 → 4, -2.8 → -2, 5 → 5",
    "bitbybit.math.negate": "negar",
    "negate": "negar",
    "bitbybit.math.negate_description": "Niega un número (invierte su signo: positivo se vuelve negativo, negativo se vuelve positivo). Ejemplo: 5 → -5, -3 → 3, 0 → 0",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "Calcula el logaritmo natural (base e) de un número. Ejemplo: ln(2.718) → ~1, ln(7.389) → ~2, ln(1) → 0",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "Calcula el logaritmo base 10 de un número. Ejemplo: log₁₀(100) → 2, log₁₀(1000) → 3, log₁₀(10) → 1",
    "bitbybit.math.tenPow": "diez pot",
    "tenPow": "diez pot",
    "bitbybit.math.tenPow_description": "Eleva 10 a la potencia del número de entrada. Ejemplo: 10² → 100, 10³ → 1000, 10⁻¹ → 0.1",
    "bitbybit.math.sin": "seno",
    "sin": "seno",
    "bitbybit.math.sin_description": "Calcula el seno de un ángulo en radianes. Ejemplo: sin(0) → 0, sin(π2) → 1, sin(π) → ~0",
    "bitbybit.math.cos": "coseno",
    "cos": "coseno",
    "bitbybit.math.cos_description": "Calcula el coseno de un ángulo en radianes. Ejemplo: cos(0) → 1, cos(π2) → ~0, cos(π) → -1",
    "bitbybit.math.tan": "tangente",
    "tan": "tangente",
    "bitbybit.math.tan_description": "Calcula la tangente de un ángulo en radianes. Ejemplo: tan(0) → 0, tan(π4) → ~1, tan(π2) → infinito",
    "bitbybit.math.asin": "arcsen",
    "asin": "arcsen",
    "bitbybit.math.asin_description": "Calcula el arcoseno (seno inverso) en radianes, devuelve ángulo cuyo seno es la entrada. Ejemplo: asin(0) → 0, asin(1) → π2 (~1.57), asin(0.5) → π6 (~0.524)",
    "bitbybit.math.acos": "arccos",
    "acos": "arccos",
    "bitbybit.math.acos_description": "Calcula el arcocoseno (coseno inverso) en radianes, devuelve ángulo cuyo coseno es la entrada. Ejemplo: acos(1) → 0, acos(0) → π2 (~1.57), acos(-1) → π (~3.14)",
    "bitbybit.math.atan": "arctan",
    "atan": "arctan",
    "bitbybit.math.atan_description": "Calcula la arcotangente (tangente inversa) en radianes, devuelve ángulo cuya tangente es la entrada. Ejemplo: atan(0) → 0, atan(1) → π4 (~0.785), atan(-1) → -π4",
    "bitbybit.math.exp": "exp",
    "exp": "exp",
    "bitbybit.math.exp_description": "Calcula e elevado a la potencia de la entrada (función exponencial). Ejemplo: e⁰ → 1, e¹ → ~2.718, e² → ~7.389",
    "bitbybit.math.degToRad": "grados a rad",
    "degToRad": "grados a rad",
    "bitbybit.math.degToRad_description": "Convierte un ángulo de grados a radianes. Ejemplo: 180° → π (~3.14159), 90° → π2 (~1.5708), 360° → 2π",
    "bitbybit.math.radToDeg": "rad a grados",
    "radToDeg": "rad a grados",
    "bitbybit.math.radToDeg_description": "Convierte un ángulo de radianes a grados. Ejemplo: π → 180°, π2 → 90°, 2π → 360°",
    "bitbybit.math.ease": "suavizar",
    "bitbybit.math.ease_description": "Aplica una función de easing para interpolar suavemente entre valores min y max. Ejemplo: x=0.5 de [0,100] con easeInQuad → aplica curva de aceleración cuadrática Útil para animaciones suaves con varias curvas de aceleración y desaceleración.",
    "easeEnum": "enum suavizado",
    "bitbybit.lists.getItem": "obtener elemento",
    "lists": "listas",
    "getItem": "obtener elemento",
    "bitbybit.lists.getItem_description": "Obtiene un elemento de la lista en una posición específica usando indexación basada en cero. Ejemplo: De [10, 20, 30, 40], obteniendo índice 2 devuelve 30",
    "list": "lista",
    "bitbybit.lists.randomGetThreshold": "obtener umbral aleatorio",
    "randomGetThreshold": "obtener umbral aleatorio",
    "bitbybit.lists.randomGetThreshold_description": "Mantiene aleatoriamente elementos de la lista basado en un umbral de probabilidad (0 a 1). Ejemplo: De [1, 2, 3, 4, 5] con umbral 0.5, podría devolver [1, 3, 5] (50% de probabilidad para cada elemento)",
    "bitbybit.lists.getSubList": "obtener sublista",
    "getSubList": "obtener sublista",
    "bitbybit.lists.getSubList_description": "Extrae una porción de la lista entre posiciones de inicio y fin (el fin es exclusivo). Ejemplo: De [10, 20, 30, 40, 50] con inicio=1 y fin=4, devuelve [20, 30, 40]",
    "indexStart": "índice inicio",
    "indexEnd": "índice fin",
    "bitbybit.lists.getNthItem": "obtener enésimo elemento",
    "getNthItem": "obtener enésimo elemento",
    "bitbybit.lists.getNthItem_description": "Obtiene cada enésimo elemento de la lista, comenzando desde una posición de desplazamiento opcional. Ejemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] con n=3 y desplazamiento=0, devuelve [0, 3, 6] Ejemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] con n=2 y desplazamiento=1, devuelve [1, 3, 5, 7]",
    "nth": "enésimo",
    "bitbybit.lists.getByPattern": "obtener por patrón",
    "getByPattern": "obtener por patrón",
    "bitbybit.lists.getByPattern_description": "Filtra elementos de la lista usando un patrón repetitivo verdadero/falso. Ejemplo: De [0, 1, 2, 3, 4, 5] con patrón [true, true, false], devuelve [0, 1, 3, 4] (mantiene elementos donde patrón es verdadero)",
    "pattern": "patrón",
    "bitbybit.lists.mergeElementsOfLists": "fusionar elementos de listas",
    "mergeElementsOfLists": "fusionar elementos de listas",
    "bitbybit.lists.mergeElementsOfLists_description": "Fusiona elementos de múltiples listas en un nivel de anidamiento específico, agrupando elementos por posición. Ejemplo: De [[0, 1, 2], [3, 4, 5]] en nivel 0, devuelve [[0, 3], [1, 4], [2, 5]]",
    "level": "nivel",
    "bitbybit.lists.getLongestListLength": "obtener longitud lista más larga",
    "getLongestListLength": "obtener longitud lista más larga",
    "bitbybit.lists.getLongestListLength_description": "Encuentra la longitud de la lista más larga entre múltiples listas. Ejemplo: De [[1, 2], [3, 4, 5, 6], [7]], devuelve 4 (longitud de [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "invertir",
    "bitbybit.lists.reverse_description": "Invierte el orden de los elementos en la lista. Ejemplo: De [1, 2, 3, 4, 5], devuelve [5, 4, 3, 2, 1]",
    "bitbybit.lists.flipLists": "voltear listas",
    "flipLists": "voltear listas",
    "bitbybit.lists.flipLists_description": "Transpone una lista 2D intercambiando filas y columnas (todas las sublistas deben tener igual longitud). Ejemplo: De [[0, 1, 2], [3, 4, 5]], devuelve [[0, 3], [1, 4], [2, 5]]",
    "bitbybit.lists.groupNth": "agrupar enésimo",
    "groupNth": "agrupar enésimo",
    "bitbybit.lists.groupNth_description": "Divide la lista en listas más pequeñas de n elementos cada una. Ejemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] con n=3, devuelve [[0, 1, 2], [3, 4, 5], [6, 7, 8]] Ejemplo: De [0, 1, 2, 3, 4] con n=2 y mantenerResto=true, devuelve [[0, 1], [2, 3], [4]]",
    "nrElements": "núm elementos",
    "keepRemainder": "mantener resto",
    "bitbybit.lists.getListDepth": "obtener profundidad lista",
    "getListDepth": "obtener profundidad lista",
    "bitbybit.lists.getListDepth_description": "Determina el nivel máximo de anidamiento (profundidad) de una estructura de lista. Ejemplo: [1, 2, 3] tiene profundidad 1, [[1, 2], [3, 4]] tiene profundidad 2, [[[1]]] tiene profundidad 3",
    "bitbybit.lists.listLength": "longitud lista",
    "listLength": "longitud lista",
    "bitbybit.lists.listLength_description": "Devuelve el número de elementos en la lista. Ejemplo: [10, 20, 30, 40, 50] devuelve 5, [] devuelve 0",
    "bitbybit.lists.addItemAtIndex": "añadir elemento en índice",
    "addItemAtIndex": "añadir elemento en índice",
    "bitbybit.lists.addItemAtIndex_description": "Inserta un elemento en una posición específica en la lista. Ejemplo: En [10, 20, 30, 40], añadiendo 99 en índice 2 da [10, 20, 99, 30, 40]",
    "item": "elemento",
    "bitbybit.lists.addItemAtIndexes": "añadir elemento en índices",
    "addItemAtIndexes": "añadir elemento en índices",
    "bitbybit.lists.addItemAtIndexes_description": "Inserta el mismo elemento en múltiples posiciones especificadas en la lista. Ejemplo: En [10, 20, 30], añadiendo 99 en índices [0, 2] da [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "añadir elementos en índices",
    "addItemsAtIndexes": "añadir elementos en índices",
    "bitbybit.lists.addItemsAtIndexes_description": "Inserta múltiples elementos en posiciones correspondientes (primer elemento en primer índice, segundo elemento en segundo índice, etc.). Ejemplo: En [10, 20, 30], añadiendo elementos [88, 99] en índices [1, 2] da [10, 88, 20, 99, 30]",
    "items": "elementos",
    "bitbybit.lists.removeItemAtIndex": "eliminar elemento en índice",
    "removeItemAtIndex": "eliminar elemento en índice",
    "bitbybit.lists.removeItemAtIndex_description": "Elimina el elemento en una posición específica en la lista. Ejemplo: De [10, 20, 30, 40, 50], eliminando índice 2 da [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "eliminar elementos en índices",
    "removeItemsAtIndexes": "eliminar elementos en índices",
    "bitbybit.lists.removeItemsAtIndexes_description": "Elimina elementos en múltiples posiciones especificadas de la lista. Ejemplo: De [10, 20, 30, 40, 50], eliminando índices [1, 3] da [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "eliminar todos elementos",
    "removeAllItems": "eliminar todos elementos",
    "bitbybit.lists.removeAllItems_description": "Borra todos los elementos de la lista, resultando en una lista vacía. Ejemplo: De [10, 20, 30, 40], devuelve []",
    "bitbybit.lists.removeNthItem": "eliminar enésimo elemento",
    "removeNthItem": "eliminar enésimo elemento",
    "bitbybit.lists.removeNthItem_description": "Elimina cada n-ésimo elemento de la lista, comenzando desde una posición de desplazamiento opcional. Ejemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] con n=3 y desplazamiento=0, devuelve [1, 2, 4, 5, 7, 8] (elimina 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "eliminar umbral aleatorio",
    "randomRemoveThreshold": "eliminar umbral aleatorio",
    "bitbybit.lists.randomRemoveThreshold_description": "Elimina aleatoriamente elementos de la lista basado en un umbral de probabilidad (0 a 1). Ejemplo: De [1, 2, 3, 4, 5] con umbral 0.5, podría devolver [2, 4] (50% de probabilidad de eliminar cada elemento)",
    "bitbybit.lists.removeDuplicateNumbers": "eliminar números duplicados",
    "removeDuplicateNumbers": "eliminar números duplicados",
    "bitbybit.lists.removeDuplicateNumbers_description": "Elimina números duplicados de la lista, manteniendo solo la primera aparición de cada valor. Ejemplo: De [1, 2, 3, 2, 4, 3, 5], devuelve [1, 2, 3, 4, 5]",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "eliminar números duplicados tolerancia",
    "removeDuplicateNumbersTolerance": "eliminar números duplicados tolerancia",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Elimina números duplicados que están dentro de un rango de tolerancia especificado uno del otro. Ejemplo: De [1.0, 1.001, 2.0, 2.002, 3.0] con tolerancia 0.01, devuelve [1.0, 2.0, 3.0]",
    "bitbybit.lists.addItem": "añadir elemento",
    "addItem": "añadir elemento",
    "bitbybit.lists.addItem_description": "Añade un elemento al final de la lista. Ejemplo: A [10, 20, 30], añadiendo 40 da [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "añadir elemento al inicio",
    "prependItem": "añadir elemento al inicio",
    "bitbybit.lists.prependItem_description": "Añade un elemento al principio de la lista. Ejemplo: A [10, 20, 30], anteponiendo 5 da [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "añadir elemento inicio fin",
    "addItemFirstLast": "añadir elemento inicio fin",
    "bitbybit.lists.addItemFirstLast_description": "Añade un elemento ya sea al principio o al final de la lista basado en el parámetro de posición. Ejemplo: A [10, 20, 30], añadiendo 5 en 'first' da [5, 10, 20, 30], en 'last' da [10, 20, 30, 5]",
    "firstLastEnum": "enum inicio fin",
    "bitbybit.lists.createEmptyList": "lista vacía",
    "createEmptyList": "lista vacía",
    "bitbybit.lists.createEmptyList_description": "Crea una nueva lista vacía sin elementos. Ejemplo: Devuelve []",
    "bitbybit.lists.repeat": "repetir",
    "repeat": "repetir",
    "bitbybit.lists.repeat_description": "Crea una nueva lista repitiendo un elemento un número especificado de veces. Ejemplo: Repitiendo 5 tres veces devuelve [5, 5, 5]",
    "times": "veces",
    "bitbybit.lists.repeatInPattern": "repetir en patrón",
    "repeatInPattern": "repetir en patrón",
    "bitbybit.lists.repeatInPattern_description": "Repite un patrón de elementos cíclicamente hasta alcanzar una longitud de lista objetivo. Ejemplo: Patrón [1, 2, 3] con longitud 7 devuelve [1, 2, 3, 1, 2, 3, 1]",
    "lengthLimit": "límite longitud",
    "bitbybit.lists.sortNumber": "ordenar número",
    "sortNumber": "ordenar número",
    "bitbybit.lists.sortNumber_description": "Ordena números en orden ascendente (menor a mayor) o descendente (mayor a menor). Ejemplo: [5, 2, 8, 1, 9] ascendente devuelve [1, 2, 5, 8, 9], descendente devuelve [9, 8, 5, 2, 1]",
    "sorting": "ordenación",
    "orderAsc": "orden asc",
    "bitbybit.lists.sortTexts": "ordenar textos",
    "sortTexts": "ordenar textos",
    "bitbybit.lists.sortTexts_description": "Ordena cadenas de texto alfabéticamente en orden ascendente (A a Z) o descendente (Z a A). Ejemplo: ['perro', 'manzana', 'gato', 'banana'] ascendente devuelve ['manzana', 'banana', 'gato', 'perro']",
    "bitbybit.lists.sortByPropValue": "ordenar por valor prop",
    "sortByPropValue": "ordenar por valor prop",
    "bitbybit.lists.sortByPropValue_description": "Ordena objetos comparando valores numéricos de una propiedad especificada. Ejemplo: [{age: 30}, {age: 20}, {age: 25}] ordenado por 'age' ascendente devuelve [{age: 20}, {age: 25}, {age: 30}]",
    "property": "propiedad",
    "bitbybit.color.hexColor": "color hex",
    "hexColor": "color hex",
    "bitbybit.color.hexColor_description": "Crea y devuelve una cadena de color hexadecimal (paso a través para entrada de color). Ejemplo: '#FF5733' → '#FF5733'",
    "bitbybit.color.hexToRgb": "hex a rgb",
    "hexToRgb": "hex a rgb",
    "bitbybit.color.hexToRgb_description": "Convierte color hexadecimal a objeto RGB con valores r, g, b (rango 0-255). Ejemplo: '#FF5733' → {r: 255, g: 87, b: 51}",
    "convert": "convertir",
    "bitbybit.color.rgbToHex": "rgb a hex",
    "rgbToHex": "rgb a hex",
    "bitbybit.color.rgbToHex_description": "Convierte valores RGB a cadena de color hexadecimal (admite rangos min/max personalizados, remapea automáticamente a 0-255). Ejemplo: r=255, g=87, b=51 con rango [0,255] → '#ff5733' Ejemplo: r=1, g=0.5, b=0.2 con rango [0,1] → '#ff7f33'",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "obj rgb a hex",
    "rgbObjToHex": "obj rgb a hex",
    "bitbybit.color.rgbObjToHex_description": "Convierte objeto RGB a cadena de color hexadecimal (admite rangos min/max personalizados). Ejemplo: {r: 1, g: 0.5, b: 0.2} con rango [0,1] → '#ff7f33'",
    "rgb": "rgb",
    "Base.ColorRGB": "color base rgb",
    "bitbybit.color.hexToRgbMapped": "hex a rgb mapeado",
    "hexToRgbMapped": "hex a rgb mapeado",
    "bitbybit.color.hexToRgbMapped_description": "Convierte color hexadecimal a RGB y remapea valores a un rango personalizado. Ejemplo: '#FF5733' mapeado a [0,1] → {r: 1, g: 0.341, b: 0.2} Ejemplo: '#FF5733' mapeado a [0,100] → {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "obtener param rojo",
    "getRedParam": "obtener param rojo",
    "bitbybit.color.getRedParam_description": "Extrae el valor del canal rojo del color hexadecimal (puede mapearse a rango personalizado). Ejemplo: '#FF5733' con rango [0,1] → 1",
    "hex to": "hex a",
    "bitbybit.color.getGreenParam": "obtener param verde",
    "getGreenParam": "obtener param verde",
    "bitbybit.color.getGreenParam_description": "Extrae el valor del canal verde del color hexadecimal (puede mapearse a rango personalizado). Ejemplo: '#FF5733' con rango [0,1] → 0.341",
    "bitbybit.color.getBlueParam": "obtener param azul",
    "getBlueParam": "obtener param azul",
    "bitbybit.color.getBlueParam_description": "Extrae el valor del canal azul del color hexadecimal (puede mapearse a rango personalizado). Ejemplo: '#FF5733' con rango [0,1] → 0.2",
    "bitbybit.color.rgbToRed": "rgb a rojo",
    "rgbToRed": "rgb a rojo",
    "bitbybit.color.rgbToRed_description": "Extrae el valor del canal rojo del objeto RGB. Ejemplo: {r: 255, g: 87, b: 51} → 255",
    "rgb to": "rgb a",
    "bitbybit.color.rgbToGreen": "rgb a verde",
    "rgbToGreen": "rgb a verde",
    "bitbybit.color.rgbToGreen_description": "Extrae el valor del canal verde del objeto RGB. Ejemplo: {r: 255, g: 87, b: 51} → 87",
    "bitbybit.color.rgbToBlue": "rgb a azul",
    "rgbToBlue": "rgb a azul",
    "bitbybit.color.rgbToBlue_description": "Extrae el valor del canal azul del objeto RGB. Ejemplo: {r: 255, g: 87, b: 51} → 51",
    "bitbybit.color.invert": "invertir",
    "invert": "invertir",
    "bitbybit.color.invert_description": "Invierte un color hexadecimal (invierte canales RGB: 255-r, 255-g, 255-b). Con blackAndWhite=true → devuelve '#000000' o '#ffffff' basado en brillo. Ejemplo: '#FF5733' → '#00a8cc', '#FF5733' con blackAndWhite=true → '#ffffff'",
    "blackAndWhite": "blanco y negro",
    "bitbybit.text.create": "crear",
    "bitbybit.text.create_description": "Crea y devuelve una cadena de texto (paso a través para entrada de texto). Ejemplo: texto='Hola Mundo' → 'Hola Mundo'",
    "bitbybit.text.split": "dividir",
    "bitbybit.text.split_description": "Divide texto en múltiples piezas usando una cadena separadora. Ejemplo: texto='manzana,banana,cereza', separador=',' → ['manzana', 'banana', 'cereza']",
    "separator": "separador",
    "bitbybit.text.replaceAll": "reemplazar todo",
    "replaceAll": "reemplazar todo",
    "bitbybit.text.replaceAll_description": "Reemplaza todas las apariciones de una cadena de búsqueda con una cadena de reemplazo. Ejemplo: texto='hola hola', búsqueda='hola', reemplazarCon='hi' → 'hi hi'",
    "search": "buscar",
    "replaceWith": "reemplazar con",
    "bitbybit.text.join": "unir",
    "join": "unir",
    "bitbybit.text.join_description": "Une múltiples elementos en una sola cadena de texto usando un separador. Ejemplo: lista=['manzana', 'banana', 'cereza'], separador=', ' → 'manzana, banana, cereza'",
    "string[]": "array cadena",
    "bitbybit.text.toString": "a cadena",
    "toString": "a cadena",
    "bitbybit.text.toString_description": "Transformar cualquier elemento a texto",
    "bitbybit.text.toStringEach": "a cadena cada",
    "toStringEach": "a cadena cada",
    "bitbybit.text.toStringEach_description": "Transformar cada elemento en lista a texto",
    "bitbybit.text.format": "formato",
    "format": "formato",
    "bitbybit.text.format_description": "Formatea texto con valores de marcador de posición usando sintaxis {0}, {1}, etc. Ejemplo: texto='Punto: ({0}, {1})', valores=[10, 5] → 'Punto: (10, 5)'",
    "values": "valores",
    "bitbybit.text.vectorChar": "carácter vectorial",
    "vectorChar": "carácter vectorial",
    "bitbybit.text.vectorChar_description": "Convierte un carácter a rutas vectoriales (polilíneas) con datos de ancho y altura para renderizado. Usa fuente de trazo simplex para generar segmentos de línea 2D representando la forma del carácter. Ejemplo: char='A', altura=10 → {width:8, height:10, paths:[[puntos formando forma A]]}",
    "char": "carácter",
    "bitbybit.text.vectorText": "texto vectorial",
    "vectorText": "texto vectorial",
    "bitbybit.text.vectorText_description": "Convierte texto multilínea a rutas vectoriales (polilíneas) con controles de alineación y espaciado. Soporta saltos de línea, espaciado de letras, espaciado de línea, alineación horizontal y centrado de origen. Ejemplo: texto='Hola Mundo', altura=10, alinear=centro → [{chars línea1}, {chars línea2}]",
    "bitbybit.dates.toDateString": "a cadena de fecha",
    "dates": "fechas",
    "toDateString": "a cadena de fecha",
    "bitbybit.dates.toDateString_description": "Convierte fecha a cadena de fecha legible por humanos (excluye hora). Ejemplo: Fecha(2024,0,15,14,30) → 'Lun Ene 15 2024'",
    "date": "fecha",
    "Date": "fecha",
    "bitbybit.dates.toISOString": "a cadena ISO",
    "toISOString": "a cadena ISO",
    "bitbybit.dates.toISOString_description": "Convierte fecha a cadena de formato ISO 8601 (formato estándar para APIs e intercambio de datos). Ejemplo: Fecha(2024,0,15,14,30,45) → '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "a JSON",
    "toJSON": "a JSON",
    "bitbybit.dates.toJSON_description": "Convierte fecha a cadena compatible con JSON (igual que formato ISO, usado en JSON.stringify). Ejemplo: Fecha(2024,0,15,14,30) → '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "a cadena",
    "bitbybit.dates.toString_description": "Convierte fecha a cadena completa específica de configuración regional (incluye fecha, hora y zona horaria). Ejemplo: Fecha(2024,0,15,14,30) → 'Lun Ene 15 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "a cadena de hora",
    "toTimeString": "a cadena de hora",
    "bitbybit.dates.toTimeString_description": "Convierte fecha a cadena de hora (excluye fecha, incluye zona horaria). Ejemplo: Fecha(2024,0,15,14,30,45) → '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "a cadena UTC",
    "toUTCString": "a cadena UTC",
    "bitbybit.dates.toUTCString_description": "Convierte fecha a formato de cadena UTC (Tiempo Universal Coordinado, sin desplazamiento de zona horaria). Ejemplo: Fecha(2024,0,15,14,30) → 'Lun, 15 Ene 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "ahora",
    "now": "ahora",
    "bitbybit.dates.now_description": "Devuelve la fecha y hora actual en el momento de la ejecución. Ejemplo: llamando a now() → Objeto Fecha representando momento actual (e.g., '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "crear fecha",
    "createDate": "crear fecha",
    "bitbybit.dates.createDate_description": "Crea una nueva fecha a partir de componentes individuales usando hora local. El mes es indexado en 0: 0=Enero, 11=Diciembre. Ejemplo: año=2024, mes=0, día=15, horas=14, minutos=30 → Fecha(Ene 15, 2024 14:30)",
    "year": "año",
    "month": "mes",
    "day": "día",
    "hours": "horas",
    "minutes": "minutos",
    "seconds": "segundos",
    "milliseconds": "milisegundos",
    "bitbybit.dates.createDateUTC": "crear fecha UTC",
    "createDateUTC": "crear fecha UTC",
    "bitbybit.dates.createDateUTC_description": "Crea una nueva fecha a partir de componentes individuales usando UTC (ignora zona horaria). Devuelve milisegundos desde época Unix (Ene 1, 1970 00:00:00 UTC). Ejemplo: año=2024, mes=0, día=15 → Fecha representando Ene 15, 2024 00:00 UTC",
    "bitbybit.dates.createFromUnixTimeStamp": "crear desde marca de tiempo unix",
    "createFromUnixTimeStamp": "crear desde marca de tiempo unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Crea una fecha a partir de marca de tiempo Unix (milisegundos desde Ene 1, 1970 UTC). Ejemplo: unixTimeStamp=1705329000000 → Fecha(Ene 15, 2024 14:30:00)",
    "unixTimeStamp": "marca de tiempo unix",
    "bitbybit.dates.parseDate": "analizar fecha",
    "parseDate": "analizar fecha",
    "bitbybit.dates.parseDate_description": "Analiza una cadena de fecha y devuelve marca de tiempo Unix (milisegundos desde Ene 1, 1970 UTC). Ejemplo: dateString='2024-01-15' → 1705276800000",
    "parse": "analizar",
    "dateString": "cadena de fecha",
    "bitbybit.dates.getDayOfMonth": "obtener día del mes",
    "getDayOfMonth": "obtener día del mes",
    "bitbybit.dates.getDayOfMonth_description": "Extrae día del mes de la fecha (1-31) usando hora local. Ejemplo: Fecha(2024,0,15) → 15",
    "bitbybit.dates.getWeekday": "obtener día de la semana",
    "getWeekday": "obtener día de la semana",
    "bitbybit.dates.getWeekday_description": "Extrae día de la semana de la fecha (0=Domingo, 6=Sábado) usando hora local. Ejemplo: Fecha(2024,0,15) → 1 (Lunes)",
    "bitbybit.dates.getYear": "obtener año",
    "getYear": "obtener año",
    "bitbybit.dates.getYear_description": "Extrae año completo de la fecha usando hora local. Ejemplo: Fecha(2024,0,15) → 2024",
    "bitbybit.dates.getMonth": "obtener mes",
    "getMonth": "obtener mes",
    "bitbybit.dates.getMonth_description": "Extrae mes de la fecha (0=Enero, 11=Diciembre) usando hora local. Ejemplo: Fecha(2024,0,15) → 0 (Enero)",
    "bitbybit.dates.getHours": "obtener horas",
    "getHours": "obtener horas",
    "bitbybit.dates.getHours_description": "Extrae horas de la fecha (0-23) usando hora local. Ejemplo: Fecha(2024,0,15,14,30) → 14",
    "bitbybit.dates.getMinutes": "obtener minutos",
    "getMinutes": "obtener minutos",
    "bitbybit.dates.getMinutes_description": "Extrae minutos de la fecha (0-59) usando hora local. Ejemplo: Fecha(2024,0,15,14,30) → 30",
    "bitbybit.dates.getSeconds": "obtener segundos",
    "getSeconds": "obtener segundos",
    "bitbybit.dates.getSeconds_description": "Extrae segundos de la fecha (0-59) usando hora local. Ejemplo: Fecha(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getMilliseconds": "obtener milisegundos",
    "getMilliseconds": "obtener milisegundos",
    "bitbybit.dates.getMilliseconds_description": "Extrae milisegundos de la fecha (0-999) usando hora local. Ejemplo: Fecha(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.getTime": "obtener tiempo",
    "getTime": "obtener tiempo",
    "bitbybit.dates.getTime_description": "Convierte fecha a marca de tiempo Unix (milisegundos desde Ene 1, 1970 UTC). Ejemplo: Fecha(2024,0,15,14,30) → 1705329000000",
    "bitbybit.dates.getUTCYear": "obtener año UTC",
    "getUTCYear": "obtener año UTC",
    "bitbybit.dates.getUTCYear_description": "Extrae año completo de la fecha usando UTC (ignora zona horaria). Ejemplo: Fecha(2024,0,15) → 2024",
    "bitbybit.dates.getUTCMonth": "obtener mes UTC",
    "getUTCMonth": "obtener mes UTC",
    "bitbybit.dates.getUTCMonth_description": "Extrae mes de la fecha (0=Enero, 11=Diciembre) usando UTC. Ejemplo: Date.UTC(2024,0,15) → 0 (Enero)",
    "bitbybit.dates.getUTCDay": "obtener día UTC",
    "getUTCDay": "obtener día UTC",
    "bitbybit.dates.getUTCDay_description": "Extrae día del mes de la fecha (1-31) usando UTC. Ejemplo: Date.UTC(2024,0,15) → 15",
    "bitbybit.dates.getUTCHours": "obtener horas UTC",
    "getUTCHours": "obtener horas UTC",
    "bitbybit.dates.getUTCHours_description": "Extrae horas de la fecha (0-23) usando UTC. Ejemplo: Date.UTC(2024,0,15,14) → 14",
    "bitbybit.dates.getUTCMinutes": "obtener minutos UTC",
    "getUTCMinutes": "obtener minutos UTC",
    "bitbybit.dates.getUTCMinutes_description": "Extrae minutos de la fecha (0-59) usando UTC. Ejemplo: Date.UTC(2024,0,15,14,30) → 30",
    "bitbybit.dates.getUTCSeconds": "obtener segundos UTC",
    "getUTCSeconds": "obtener segundos UTC",
    "bitbybit.dates.getUTCSeconds_description": "Extrae segundos de la fecha (0-59) usando UTC. Ejemplo: Date.UTC(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getUTCMilliseconds": "obtener milisegundos UTC",
    "getUTCMilliseconds": "obtener milisegundos UTC",
    "bitbybit.dates.getUTCMilliseconds_description": "Extrae milisegundos de la fecha (0-999) usando UTC. Ejemplo: Date.UTC(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.setYear": "establecer año",
    "setYear": "establecer año",
    "bitbybit.dates.setYear_description": "Crea nueva fecha con año modificado (devuelve nueva fecha, original sin cambios). Ejemplo: Fecha(2024,0,15) con año=2025 → Fecha(2025,0,15)",
    "bitbybit.dates.setMonth": "establecer mes",
    "setMonth": "establecer mes",
    "bitbybit.dates.setMonth_description": "Crea nueva fecha con mes modificado (0=Enero, 11=Diciembre, devuelve nueva fecha). Ejemplo: Fecha(2024,0,15) con mes=5 → Fecha(2024,5,15) (Junio 15)",
    "bitbybit.dates.setDayOfMonth": "establecer día del mes",
    "setDayOfMonth": "establecer día del mes",
    "bitbybit.dates.setDayOfMonth_description": "Crea nueva fecha con día del mes modificado (1-31, devuelve nueva fecha). Ejemplo: Fecha(2024,0,15) con día=20 → Fecha(2024,0,20)",
    "bitbybit.dates.setHours": "establecer horas",
    "setHours": "establecer horas",
    "bitbybit.dates.setHours_description": "Establece el valor de la hora en el objeto Date usando la hora local.",
    "bitbybit.dates.setMinutes": "establecer minutos",
    "setMinutes": "establecer minutos",
    "bitbybit.dates.setMinutes_description": "Establece el valor de los minutos en el objeto Date usando la hora local.",
    "bitbybit.dates.setSeconds": "establecer segundos",
    "setSeconds": "establecer segundos",
    "bitbybit.dates.setSeconds_description": "Establece el valor de los segundos en el objeto Date usando la hora local.",
    "bitbybit.dates.setMilliseconds": "establecer milisegundos",
    "setMilliseconds": "establecer milisegundos",
    "bitbybit.dates.setMilliseconds_description": "Establece el valor de los milisegundos en el objeto Date usando la hora local.",
    "bitbybit.dates.setTime": "establecer tiempo",
    "setTime": "establecer tiempo",
    "bitbybit.dates.setTime_description": "Establece el valor de fecha y hora en el objeto Date.",
    "time": "tiempo",
    "bitbybit.dates.setUTCYear": "establecer año UTC",
    "setUTCYear": "establecer año UTC",
    "bitbybit.dates.setUTCYear_description": "Establece el valor del año en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCMonth": "establecer mes UTC",
    "setUTCMonth": "establecer mes UTC",
    "bitbybit.dates.setUTCMonth_description": "Establece el valor del mes en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCDay": "establecer día UTC",
    "setUTCDay": "establecer día UTC",
    "bitbybit.dates.setUTCDay_description": "Establece el día numérico del mes en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCHours": "establecer horas UTC",
    "setUTCHours": "establecer horas UTC",
    "bitbybit.dates.setUTCHours_description": "Establece el valor de las horas en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCMinutes": "establecer minutos UTC",
    "setUTCMinutes": "establecer minutos UTC",
    "bitbybit.dates.setUTCMinutes_description": "Establece el valor de los minutos en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCSeconds": "establecer segundos UTC",
    "setUTCSeconds": "establecer segundos UTC",
    "bitbybit.dates.setUTCSeconds_description": "Establece el valor de los segundos en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "establecer milisegundos UTC",
    "setUTCMilliseconds": "establecer milisegundos UTC",
    "bitbybit.dates.setUTCMilliseconds_description": "Establece el valor de los milisegundos en el objeto Date usando el Tiempo Universal Coordinado (UTC).",
    "bitbybit.json.stringify": "convertir a cadena",
    "json": "json",
    "stringify": "convertir a cadena",
    "bitbybit.json.stringify_description": "Stringifica el valor de entrada",
    "bitbybit.json.parse": "analizar",
    "bitbybit.json.parse_description": "Analiza el valor de entrada",
    "bitbybit.json.query": "consulta",
    "query": "consulta",
    "bitbybit.json.query_description": "Consulta el valor de entrada",
    "jsonpath": "jsonpath",
    "bitbybit.json.setValueOnProp": "establecer valor en prop",
    "setValueOnProp": "establecer valor en prop",
    "bitbybit.json.setValueOnProp_description": "Establece valor en propiedad dada del json dado",
    "props": "props",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "obtener json de array por primera coincidencia prop",
    "getJsonFromArrayByFirstPropMatch": "obtener json de array por primera coincidencia prop",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Obtiene json de array por primera coincidencia de propiedad. Esta es una búsqueda muy simplista y solo devuelve la primera coincidencia. Si necesita una búsqueda más compleja, puede usar consulta jsonpath con filtros.",
    "jsonArray": "array json",
    "any[]": "array cualquier",
    "match": "coincidencia",
    "bitbybit.json.getValueOnProp": "obtener valor en prop",
    "getValueOnProp": "obtener valor en prop",
    "bitbybit.json.getValueOnProp_description": "Obtiene valor de la propiedad en el json dado",
    "bitbybit.json.setValue": "establecer valor",
    "bitbybit.json.setValue_description": "Establece valor al json proporcionando una ruta",
    "prop": "prop",
    "bitbybit.json.setValuesOnPaths": "establecer valores en rutas",
    "setValuesOnPaths": "establecer valores en rutas",
    "bitbybit.json.setValuesOnPaths_description": "Establece múltiples valores al json proporcionando rutas",
    "paths": "rutas",
    "bitbybit.json.paths": "rutas",
    "bitbybit.json.paths_description": "Encuentra rutas a elementos en objeto coincidiendo con expresión de ruta",
    "bitbybit.json.createEmpty": "vacío",
    "bitbybit.json.createEmpty_description": "Crea un objeto JavaScript vacío",
    "bitbybit.json.previewAndSaveJson": "previsualizar y guardar json",
    "previewAndSaveJson": "previsualizar y guardar json",
    "bitbybit.json.previewAndSaveJson_description": "Previsualiza json y da opción de guardarlo",
    "preview": "previsualizar",
    "bitbybit.json.previewJson": "previsualizar json",
    "previewJson": "previsualizar json",
    "bitbybit.json.previewJson_description": "previsualiza json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "curva por nudos puntos control pesos",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "curva por nudos puntos control pesos",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Crea una curva Nurbs proporcionando nudos, puntos de control y pesos",
    "degree": "grado",
    "knots": "nudos",
    "bitbybit.verb.curve.createCurveByPoints": "curva por puntos",
    "createCurveByPoints": "curva por puntos",
    "bitbybit.verb.curve.createCurveByPoints_description": "Crea una curva Nurbs proporcionando puntos de control",
    "bitbybit.verb.curve.createBezierCurve": "curva bezier",
    "createBezierCurve": "curva bezier",
    "bitbybit.verb.curve.createBezierCurve_description": "Crea una curva Bezier Nurbs proporcionando puntos de control y pesos",
    "bitbybit.verb.curve.clone": "clonar",
    "bitbybit.verb.curve.clone_description": "Clona la curva Nurbs",
    "bitbybit.verb.curve.closestParam": "param más cercano",
    "closestParam": "param más cercano",
    "bitbybit.verb.curve.closestParam_description": "Encuentra el parámetro más cercano en la curva Nurbs desde el punto",
    "bitbybit.verb.curve.closestParams": "params más cercanos",
    "closestParams": "params más cercanos",
    "bitbybit.verb.curve.closestParams_description": "Encuentra los parámetros más cercanos en la curva Nurbs desde los puntos",
    "bitbybit.verb.curve.closestPoint": "punto más cercano",
    "closestPoint": "punto más cercano",
    "bitbybit.verb.curve.closestPoint_description": "Encuentra el punto más cercano en la curva Nurbs desde el punto",
    "bitbybit.verb.curve.closestPoints": "puntos más cercanos",
    "closestPoints": "puntos más cercanos",
    "bitbybit.verb.curve.closestPoints_description": "Encuentra los puntos más cercanos en la curva Nurbs desde la lista de puntos",
    "bitbybit.verb.curve.controlPoints": "puntos control",
    "controlPoints": "puntos control",
    "bitbybit.verb.curve.controlPoints_description": "Encuentra los puntos de control de la curva Nurbs",
    "bitbybit.verb.curve.degree": "grado",
    "bitbybit.verb.curve.degree_description": "Encuentra el grado de la curva Nurbs",
    "bitbybit.verb.curve.derivatives": "derivadas",
    "derivatives": "derivadas",
    "bitbybit.verb.curve.derivatives_description": "Encuentra las derivadas de la curva Nurbs en el parámetro",
    "numDerivatives": "núm derivadas",
    "parameter": "parámetro",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "dividir por longitud arco igual a params",
    "divideByEqualArcLengthToParams": "dividir por longitud arco igual a params",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Divide la curva por igual longitud de arco a parámetros",
    "subdivision": "subdivisión",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "dividir por longitud arco igual a puntos",
    "divideByEqualArcLengthToPoints": "dividir por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Divide la curva por igual longitud de arco a puntos",
    "bitbybit.verb.curve.divideByArcLengthToParams": "dividir por longitud arco a params",
    "divideByArcLengthToParams": "dividir por longitud arco a params",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Divide la curva por longitud de arco a parámetros",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "dividir por longitud arco a puntos",
    "divideByArcLengthToPoints": "dividir por longitud arco a puntos",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Divide la curva por longitud de arco a puntos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "dividir curvas por longitud arco igual a puntos",
    "divideCurvesByEqualArcLengthToPoints": "dividir curvas por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divide múltiples curvas por longitud arco igual a puntos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "dividir curvas por longitud arco a puntos",
    "divideCurvesByArcLengthToPoints": "dividir curvas por longitud arco a puntos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divide múltiples curvas por longitud arco a puntos",
    "bitbybit.verb.curve.domain": "dominio",
    "bitbybit.verb.curve.domain_description": "Encuentra el intervalo de dominio de los parámetros de la curva",
    "bitbybit.verb.curve.startPoint": "punto inicio",
    "bitbybit.verb.curve.startPoint_description": "Punto de inicio de la curva",
    "bitbybit.verb.curve.endPoint": "punto fin",
    "bitbybit.verb.curve.endPoint_description": "Punto final de la curva",
    "bitbybit.verb.curve.startPoints": "puntos inicio",
    "bitbybit.verb.curve.startPoints_description": "Puntos de inicio de las curvas",
    "bitbybit.verb.curve.endPoints": "puntos fin",
    "bitbybit.verb.curve.endPoints_description": "Puntos finales de las curvas",
    "bitbybit.verb.curve.knots": "nudos",
    "bitbybit.verb.curve.knots_description": "Encuentra los nudos de la curva Nurbs",
    "bitbybit.verb.curve.lengthAtParam": "longitud en param",
    "lengthAtParam": "longitud en param",
    "bitbybit.verb.curve.lengthAtParam_description": "Obtiene la longitud de la curva Nurbs en parámetro específico",
    "bitbybit.verb.curve.length": "longitud",
    "bitbybit.verb.curve.length_description": "Obtiene la longitud de la curva Nurbs",
    "bitbybit.verb.curve.paramAtLength": "param en longitud",
    "paramAtLength": "param en longitud",
    "bitbybit.verb.curve.paramAtLength_description": "Obtiene el param en longitud especificada en la curva Nurbs",
    "bitbybit.verb.curve.pointAtParam": "punto en param",
    "pointAtParam": "punto en param",
    "bitbybit.verb.curve.pointAtParam_description": "Obtiene el punto en parámetro especificado en la curva Nurbs",
    "bitbybit.verb.curve.pointsAtParam": "puntos en param",
    "pointsAtParam": "puntos en param",
    "bitbybit.verb.curve.pointsAtParam_description": "Obtiene los puntos en parámetro especificado en las curvas Nurbs",
    "bitbybit.verb.curve.reverse": "invertir",
    "bitbybit.verb.curve.reverse_description": "Invierte la curva Nurbs",
    "bitbybit.verb.curve.split": "dividir",
    "bitbybit.verb.curve.split_description": "Divide la curva Nurbs en dos en un parámetro dado",
    "bitbybit.verb.curve.tangent": "tangente",
    "bitbybit.verb.curve.tangent_description": "Tangente de la curva Nurbs en un parámetro dado",
    "bitbybit.verb.curve.tessellate": "teselar",
    "tessellate": "teselar",
    "bitbybit.verb.curve.tessellate_description": "Tesela la curva Nurbs en una lista de puntos",
    "bitbybit.verb.curve.transform": "transformar",
    "bitbybit.verb.curve.transform_description": "Transforma la curva Nurbs",
    "bitbybit.verb.curve.transformCurves": "transformar curvas",
    "transformCurves": "transformar curvas",
    "bitbybit.verb.curve.transformCurves_description": "Transforma las curvas Nurbs",
    "bitbybit.verb.curve.weights": "pesos",
    "bitbybit.verb.curve.weights_description": "Pesos de la curva Nurbs",
    "bitbybit.verb.curve.circle.createCircle": "círculo",
    "createCircle": "círculo",
    "bitbybit.verb.curve.circle.createCircle_description": "Crea la curva Nurbs de círculo",
    "xAxis": "eje x",
    "yAxis": "eje y",
    "bitbybit.verb.curve.circle.createArc": "arco",
    "createArc": "arco",
    "bitbybit.verb.curve.circle.createArc_description": "Crea la curva Nurbs de arco",
    "minAngle": "ángulo mín",
    "maxAngle": "ángulo máx",
    "bitbybit.verb.curve.circle.center": "centro",
    "bitbybit.verb.curve.circle.center_description": "Obtiene el punto central del círculo o un arco",
    "bitbybit.verb.curve.circle.radius": "radio",
    "bitbybit.verb.curve.circle.radius_description": "Obtiene el radio del círculo o un arco",
    "bitbybit.verb.curve.circle.maxAngle": "ángulo máx",
    "bitbybit.verb.curve.circle.maxAngle_description": "Obtiene el ángulo máx del arco en grados",
    "bitbybit.verb.curve.circle.minAngle": "ángulo mín",
    "bitbybit.verb.curve.circle.minAngle_description": "Obtiene el ángulo mín del arco en grados",
    "bitbybit.verb.curve.circle.xAxis": "eje x",
    "bitbybit.verb.curve.circle.xAxis_description": "Obtiene el ángulo x del arco",
    "bitbybit.verb.curve.circle.yAxis": "eje y",
    "bitbybit.verb.curve.circle.yAxis_description": "Obtiene el ángulo y del arco",
    "bitbybit.verb.curve.ellipse.createEllipse": "elipse",
    "createEllipse": "elipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Crea la curva Nurbs de elipse",
    "bitbybit.verb.curve.ellipse.createArc": "arco",
    "bitbybit.verb.curve.ellipse.createArc_description": "Crea la curva Nurbs de arco de elipse",
    "bitbybit.verb.curve.ellipse.center": "centro",
    "bitbybit.verb.curve.ellipse.center_description": "Obtiene el punto central de la elipse o un arco",
    "bitbybit.verb.curve.ellipse.maxAngle": "ángulo máx",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Obtiene el ángulo máx del arco en grados",
    "bitbybit.verb.curve.ellipse.minAngle": "ángulo mín",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Obtiene el ángulo mín del arco en grados",
    "bitbybit.verb.curve.ellipse.xAxis": "eje x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Obtiene el ángulo x del arco o una elipse",
    "bitbybit.verb.curve.ellipse.yAxis": "eje y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Obtiene el ángulo y del arco o una elipse",
    "bitbybit.verb.surface.boundaries": "límites",
    "boundaries": "límites",
    "bitbybit.verb.surface.boundaries_description": "Obtiene las curvas Nurbs de borde límite de la superficie en una lista",
    "bitbybit.verb.surface.createSurfaceByCorners": "superficie por esquinas",
    "createSurfaceByCorners": "superficie por esquinas",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Crea la superficie proporcionando 4 puntos como esquinas",
    "point3": "punto 3",
    "point4": "punto 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "superficie por nudos puntos control pesos",
    "createSurfaceByKnotsControlPointsWeights": "superficie por nudos puntos control pesos",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Crea la superficie Nurbs proporcionando nudos uv, grados uv, puntos y pesos",
    "degreeU": "grado u",
    "degreeV": "grado v",
    "knotsU": "nudos u",
    "knotsV": "nudos v",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "superficie por loft curvas",
    "createSurfaceByLoftingCurves": "superficie por loft curvas",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Crea la superficie Nurbs solevando curvas",
    "bitbybit.verb.surface.clone": "clonar",
    "bitbybit.verb.surface.clone_description": "Clona la superficie Nurbs",
    "bitbybit.verb.surface.closestParam": "param más cercano",
    "bitbybit.verb.surface.closestParam_description": "Encuentra el parámetro más cercano en la superficie desde el punto",
    "bitbybit.verb.surface.closestPoint": "punto más cercano",
    "bitbybit.verb.surface.closestPoint_description": "Encuentra el punto más cercano en la superficie desde el punto",
    "bitbybit.verb.surface.controlPoints": "puntos control",
    "bitbybit.verb.surface.controlPoints_description": "Obtiene los puntos de control en la superficie",
    "bitbybit.verb.surface.degreeU": "grado u",
    "bitbybit.verb.surface.degreeU_description": "Obtiene el grado U de la superficie",
    "bitbybit.verb.surface.degreeV": "grado v",
    "bitbybit.verb.surface.degreeV_description": "Obtiene el grado V de la superficie",
    "bitbybit.verb.surface.derivatives": "derivadas",
    "bitbybit.verb.surface.derivatives_description": "Obtiene las derivadas de la superficie en coordenada uv específica",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "dominio u",
    "domainU": "dominio u",
    "bitbybit.verb.surface.domainU_description": "Obtiene el dominio U de la superficie",
    "bitbybit.verb.surface.domainV": "dominio v",
    "domainV": "dominio v",
    "bitbybit.verb.surface.domainV_description": "Obtiene el dominio V de la superficie",
    "bitbybit.verb.surface.isocurve": "isocurva",
    "isocurve": "isocurva",
    "bitbybit.verb.surface.isocurve_description": "Obtiene la isocurva Nurbs en la superficie",
    "useV": "usar v",
    "bitbybit.verb.surface.isocurvesSubdivision": "subdivisión isocurvas",
    "isocurvesSubdivision": "subdivisión isocurvas",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Subdivide superficie en número preferido de isocurvas",
    "isocurveSegments": "segmentos isocurva",
    "bitbybit.verb.surface.isocurvesAtParams": "isocurvas en params",
    "isocurvesAtParams": "isocurvas en params",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Subdivide superficie en isocurvas en array especificado de parámetros",
    "parameters": "parámetros",
    "bitbybit.verb.surface.knotsU": "nudos u",
    "bitbybit.verb.surface.knotsU_description": "Obtiene los nudos U de la superficie",
    "bitbybit.verb.surface.knotsV": "nudos v",
    "bitbybit.verb.surface.knotsV_description": "Obtiene los nudos V de la superficie",
    "bitbybit.verb.surface.normal": "normal",
    "bitbybit.verb.surface.normal_description": "Obtiene la normal en la superficie en coordenada uv",
    "bitbybit.verb.surface.point": "punto",
    "bitbybit.verb.surface.point_description": "Obtiene el punto en la superficie en coordenada uv",
    "bitbybit.verb.surface.reverse": "invertir",
    "bitbybit.verb.surface.reverse_description": "Invierte la superficie Nurbs. Esto invertirá el origen UV y direcciones de isocurva",
    "bitbybit.verb.surface.split": "dividir",
    "bitbybit.verb.surface.split_description": "Divide la superficie Nurbs en dos mitades.",
    "bitbybit.verb.surface.transformSurface": "transformar superficie",
    "transformSurface": "transformar superficie",
    "bitbybit.verb.surface.transformSurface_description": "Transforma la superficie Nurbs con una lista dada de transformaciones.",
    "bitbybit.verb.surface.weights": "pesos",
    "bitbybit.verb.surface.weights_description": "Obtiene los pesos de la superficie",
    "bitbybit.verb.surface.cone.create": "crear",
    "cone": "cono",
    "bitbybit.verb.surface.cone.create_description": "Crea la superficie Nurbs cónica",
    "bitbybit.verb.surface.cone.axis": "eje",
    "bitbybit.verb.surface.cone.axis_description": "Obtener eje de cono",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "Obtener base de cono",
    "bitbybit.verb.surface.cone.height": "altura",
    "bitbybit.verb.surface.cone.height_description": "Obtener altura de cono",
    "bitbybit.verb.surface.cone.radius": "radio",
    "bitbybit.verb.surface.cone.radius_description": "Obtener radio de cono",
    "bitbybit.verb.surface.cone.xAxis": "eje x",
    "bitbybit.verb.surface.cone.xAxis_description": "Obtener eje x de cono",
    "bitbybit.verb.surface.cylinder.create": "crear",
    "bitbybit.verb.surface.cylinder.create_description": "Crea la superficie Nurbs cilíndrica",
    "bitbybit.verb.surface.cylinder.axis": "eje",
    "bitbybit.verb.surface.cylinder.axis_description": "Obtener eje de cilindro",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "Obtener base de cilindro",
    "bitbybit.verb.surface.cylinder.height": "altura",
    "bitbybit.verb.surface.cylinder.height_description": "Obtener altura de cilindro",
    "bitbybit.verb.surface.cylinder.radius": "radio",
    "bitbybit.verb.surface.cylinder.radius_description": "Obtener radio de cilindro",
    "bitbybit.verb.surface.cylinder.xAxis": "eje x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Obtener eje x de cilindro",
    "bitbybit.verb.surface.extrusion.create": "crear",
    "extrusion": "extrusión",
    "bitbybit.verb.surface.extrusion.create_description": "Crea la extrusión de superficie Nurbs desde la curva",
    "profile": "perfil",
    "bitbybit.verb.surface.extrusion.direction": "dirección",
    "bitbybit.verb.surface.extrusion.direction_description": "Obtiene el vector de dirección de la extrusión",
    "bitbybit.verb.surface.extrusion.profile": "perfil",
    "bitbybit.verb.surface.extrusion.profile_description": "Obtiene la curva Nurbs de perfil de la extrusión",
    "bitbybit.verb.surface.sphere.create": "crear",
    "bitbybit.verb.surface.sphere.create_description": "Crea la superficie Nurbs esférica",
    "bitbybit.verb.surface.sphere.radius": "radio",
    "bitbybit.verb.surface.sphere.radius_description": "Obtener el radio de la superficie Nurbs esférica",
    "bitbybit.verb.surface.sphere.center": "centro",
    "bitbybit.verb.surface.sphere.center_description": "Obtener el centro de la superficie Nurbs esférica",
    "bitbybit.verb.surface.revolved.create": "crear",
    "revolved": "revolucionado",
    "bitbybit.verb.surface.revolved.create_description": "Crea la superficie Nurbs revolucionada",
    "bitbybit.verb.surface.revolved.profile": "perfil",
    "bitbybit.verb.surface.revolved.profile_description": "Obtener la curva Nurbs de perfil de la superficie Nurbs revolucionada",
    "revolution": "revolución",
    "bitbybit.verb.surface.revolved.center": "centro",
    "bitbybit.verb.surface.revolved.center_description": "Obtener la curva Nurbs central de la superficie Nurbs revolucionada",
    "bitbybit.verb.surface.revolved.axis": "eje",
    "bitbybit.verb.surface.revolved.axis_description": "Obtener el eje de rotación de la superficie Nurbs revolucionada",
    "bitbybit.verb.surface.revolved.angle": "ángulo",
    "bitbybit.verb.surface.revolved.angle_description": "Obtener el ángulo de rotación de superficie Nurbs revolucionada",
    "bitbybit.verb.surface.sweep.create": "crear",
    "sweep": "barrido",
    "bitbybit.verb.surface.sweep.create_description": "Crea la superficie Nurbs de barrido",
    "rail": "raíl",
    "bitbybit.verb.surface.sweep.profile": "perfil",
    "bitbybit.verb.surface.sweep.profile_description": "Obtener la curva Nurbs de perfil de la superficie Nurbs barrida",
    "bitbybit.verb.surface.sweep.rail": "raíl",
    "bitbybit.verb.surface.sweep.rail_description": "Obtener la curva Nurbs de riel de la superficie Nurbs barrida",
    "bitbybit.verb.intersect.curves": "curvas",
    "bitbybit.verb.intersect.curves_description": "Intersecta dos curvas Nurbs verb juntas y devuelve resultados de intersección",
    "firstCurve": "primera curva",
    "secondCurve": "segunda curva",
    "bitbybit.verb.intersect.curveAndSurface": "curva y superficie",
    "curveAndSurface": "curva y superficie",
    "bitbybit.verb.intersect.curveAndSurface_description": "interseca curva y superficie",
    "bitbybit.verb.intersect.surfaces": "superficies",
    "bitbybit.verb.intersect.surfaces_description": "interseca dos superficies",
    "firstSurface": "primera superficie",
    "secondSurface": "segunda superficie",
    "bitbybit.verb.intersect.curveCurveFirstParams": "curva curva primeros params",
    "curveCurveFirstParams": "curva curva primeros params",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Obtiene parámetros de intersección en la primera curva de intersección curva-curva",
    "intersections": "intersecciones",
    "BaseTypes.CurveCurveIntersection[]": "array intersección curva curva tipos base",
    "bitbybit.verb.intersect.curveCurveSecondParams": "curva curva segundos params",
    "curveCurveSecondParams": "curva curva segundos params",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Obtiene parámetros de intersección en la segunda curva de intersección curva-curva",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "curva curva primeros puntos",
    "curveCurveFirstPoints": "curva curva primeros puntos",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Obtiene puntos de intersección en la primera curva de intersección curva-curva",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "curva curva segundos puntos",
    "curveCurveSecondPoints": "curva curva segundos puntos",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Obtiene puntos de intersección en la segunda curva de intersección curva-curva",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "curva superficie curva params",
    "curveSurfaceCurveParams": "curva superficie curva params",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Obtiene parámetros de intersección en la curva de intersección curva-superficie",
    "BaseTypes.CurveSurfaceIntersection[]": "array intersección curva superficie tipos base",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "curva superficie superficie params",
    "curveSurfaceSurfaceParams": "curva superficie superficie params",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Obtiene parámetros de intersección en la superficie de intersección curva-superficie",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "curva superficie curva puntos",
    "curveSurfaceCurvePoints": "curva superficie curva puntos",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Obtiene puntos de intersección en la curva de intersección curva-superficie",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "curva superficie superficie puntos",
    "curveSurfaceSurfacePoints": "curva superficie superficie puntos",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Obtiene puntos de intersección en la superficie de intersección curva-superficie",
    "bitbybit.tag.create": "crear",
    "tag": "etiqueta",
    "bitbybit.tag.create_description": "Crea un dto de etiqueta",
    "adaptDepth": "adaptar profundidad",
    "needsUpdate": "necesita actualizar",
    "bitbybit.time.registerRenderFunction": "registrar función renderizado",
    "registerRenderFunction": "registrar función renderizado",
    "bitbybit.time.registerRenderFunction_description": "Registra una función al bucle de renderizado",
    "bitbybit.asset.getFile": "obtener archivo",
    "asset": "activo",
    "getFile": "obtener archivo",
    "bitbybit.asset.getFile_description": "Obtiene el archivo de activo",
    "bitbybit.asset.getLocalFile": "obtener archivo local",
    "getLocalFile": "obtener archivo local",
    "bitbybit.asset.getLocalFile_description": "Obtiene el archivo de activo local almacenado en tu navegador.",
    "bitbybit.asset.fetchBlob": "obtener blob",
    "fetchBlob": "obtener blob",
    "bitbybit.asset.fetchBlob_description": "Obtiene el blob de la url dada, debe ser un punto final accesible con CORS habilitado",
    "fetch": "obtener",
    "bitbybit.asset.fetchFile": "obtener archivo",
    "fetchFile": "obtener archivo",
    "bitbybit.asset.fetchFile_description": "Obtiene el archivo de la url dada, debe ser un punto final accesible con CORS habilitado",
    "bitbybit.asset.fetchJSON": "obtener json",
    "fetchJSON": "obtener json",
    "bitbybit.asset.fetchJSON_description": "Obtiene el json de la url dada, debe ser un punto final accesible con CORS habilitado",
    "bitbybit.asset.fetchText": "obtener texto",
    "fetchText": "obtener texto",
    "bitbybit.asset.fetchText_description": "Obtiene el texto de la url dada, debe ser un punto final accesible con CORS habilitado",
    "bitbybit.asset.createObjectURL": "url objeto",
    "createObjectURL": "url objeto",
    "bitbybit.asset.createObjectURL_description": "Obtiene y crea la ruta de cadena url a su archivo almacenado en su memoria.",
    "file": "archivo",
    "File | Blob": "archivo o blob",
    "bitbybit.asset.createObjectURLs": "urls objeto",
    "createObjectURLs": "urls objeto",
    "bitbybit.asset.createObjectURLs_description": "Obtiene y crea las rutas de cadena url a sus archivos almacenados en su memoria.",
    "files": "archivos",
    "(File | Blob)[]": "array archivo o blob",
    "exec": "ejec",
    "Visible": "Visible",
    "Hidden": "Oculto",
    "flatten": "aplanar",
    "force exec": "forzar ejec",
    "console log": "log consola",
    "preview data": "vista previa datos",
    "flow": "flujo",
    "code": "código",
    "runner": "ejecutor",
    "counters": "contadores",
    "actions": "acciones",
    "loops": "bucles",
    "interval": "intervalo",
    "delay": "retraso",
    "expire": "expirar",
    "timeout": "tiempo espera",
    "counter min max": "contador mín máx",
    "counter steps": "contador pasos",
    "reset": "reiniciar",
    "trigger": "disparador",
    "mouse": "ratón",
    "mouse click": "clic ratón",
    "key": "tecla",
    "pointer": "puntero",
    "pick info": "info selección",
    "down": "abajo",
    "wheel": "rueda",
    "tap": "toque",
    "double tap": "doble toque",
    "render": "renderizar",
    "passed ms": "ms pasados",
    "babylon observable listener": "escuchador observable babylon",
    "object": "objeto",
    "observable selector": "selector observable",
    "get event data": "obtener datos evento",
    "exec click": "ejec clic",
    "exec down": "ejec abajo",
    "toggle": "alternar",
    "flip flop": "flip flop",
    "boolean gate": "puerta booleana",
    "boolean gate silent": "puerta booleana silenciosa",
    "is undefined": "es indefinido",
    "for loop": "bucle for",
    "last": "último",
    "for each loop": "bucle for each",
    "element": "elemento",
    "body": "cuerpo",
    "complete": "completo",
    "editors": "editores",
    "inputs": "entradas",
    "outputs": "salidas",
    "recent": "reciente",
    "Clear": "Limpiar",
    "Run": "Ejecutar",
    "Swap Canvas": "Cambiar Lienzo",
    "Local Assets": "Activos Locales",
    "Import": "Importar",
    "Copy to Clipboard": "Copiar al Portapapeles",
    "Paste from Clipboard": "Pegar del Portapapeles",
    "Export": "Exportar",
    "Export to runner": "Exportar a ejecutor",
    "Clean Cache": "Limpiar Caché",
    "Community": "Comunidad",
    "Sponsors and Partners": "Patrocinadores y Socios",
    "API Documentation": "Documentación API",
    "About": "Acerca de",
    "Toolbox": "Caja de Herramientas",
    "More": "Más",
    "bitbybit.code.typeScriptEditor": "editor typescript",
    "bitbybit.code.typeScriptEditor_description": "Permite escribir código TypeScript con intellisense completo de bitbybit en una función. Lo que retorne la función start se verá como salida del componente.",
    "bitbybit.code.javaScriptEditor": "editor javascript",
    "bitbybit.code.javaScriptEditor_description": "Permite escribir código JavaScript en una función. Lo que retorne la función start se verá como salida del componente.",
    "bitbybit.code.jsonEditor": "editor json",
    "bitbybit.code.jsonEditor_description": "Permite escribir código JSON. Lo que retorne la función start se verá como salida del componente.",
    "bitbybit.flow.actions.keyboard": "teclado",
    "bitbybit.flow.actions.keyboard_description": "Se ejecutará en eventos de teclado al hacer clic en los botones.",
    "bitbybit.flow.actions.mouseClick": "clic ratón",
    "bitbybit.flow.actions.mouseClick_description": "Se ejecutará en eventos de ratón al hacer clic en los botones.",
    "bitbybit.flow.actions.start": "inicio",
    "bitbybit.flow.actions.start_description": "Inicia el flujo de control y dispara ejecuciones.",
    "bitbybit.flow.actions.trigger": "disparador",
    "bitbybit.flow.actions.trigger_description": "Dispara la ejecución al hacer clic en el botón.",
    "bitbybit.flow.babylon.gui.button": "botón",
    "bitbybit.flow.babylon.gui.button_description": "Se ejecutará en varios eventos de puntero al hacer clic con el botón izquierdo del ratón en el lienzo babylonjs.",
    "bitbybit.flow.babylon.scene.pointerEvents": "puntero",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Se ejecutará en varios eventos de puntero al hacer clic con el botón izquierdo del ratón en el lienzo babylonjs.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "obtener datos evento",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Obtiene datos de evento del resultado observado del escuchador observable.",
    "bitbybit.flow.babylon.observableListener": "escuchador observable babylon",
    "bitbybit.flow.babylon.observableListener_description": "Se suscribirá y escuchará a cualquiera de los observables babylonjs.",
    "bitbybit.flow.babylon.render": "renderizar",
    "bitbybit.flow.babylon.render_description": "Se ejecuta en cada fotograma de renderizado babylonjs.",
    "bitbybit.flow.counters.counterMinMax": "contador mín máx",
    "bitbybit.flow.counters.counterMinMax_description": "Cuenta el número de ejecuciones de flujo entre valores mín y máx. Cuando se alcanza máx, se reinicia",
    "bitbybit.flow.counters.counterSteps": "contador pasos",
    "bitbybit.flow.counters.counterSteps_description": "Cuenta el número de ejecuciones de flujo comenzando en valor dado y aumentando en cada ejecución por paso dado de la lista, hasta que terminen los pasos. Cuando se alcanza el final, se reinicia",
    "bitbybit.flow.counters.counter": "contador",
    "bitbybit.flow.counters.counter_description": "Cuenta el número de ejecuciones de flujo.",
    "bitbybit.flow.logic.booleanGateSilent": "puerta booleana silenciosa",
    "bitbybit.flow.logic.booleanGateSilent_description": "Dispara diferentes eventos de ejecución según el valor booleano proporcionado, pero se ejecuta solo cuando el booleano cambia su valor, esto evita que se disparen múltiples eventos constantemente aunque no haya habido cambios.",
    "bitbybit.flow.logic.booleanGate": "puerta booleana",
    "bitbybit.flow.logic.booleanGate_description": "Dispara diferentes eventos de ejecución según el valor booleano proporcionado.",
    "bitbybit.flow.logic.flipFlop": "flip flop",
    "bitbybit.flow.logic.flipFlop_description": "Cada vez que se ejecuta un evento, se disparará un evento diferente, creando esencialmente una funcionalidad de alternancia.",
    "bitbybit.flow.logic.isUndefined": "es indefinido",
    "bitbybit.flow.logic.isUndefined_description": "Comprueba si el valor proporcionado es indefinido y dispara evento verdadero o falso.",
    "bitbybit.flow.loops.forEach": "bucle for each",
    "bitbybit.flow.loops.forEach_description": "Bucle for each que recorre todos los elementos de la lista.",
    "bitbybit.flow.loops.for": "bucle for",
    "bitbybit.flow.loops.for_description": "Bucle for que ejecuta cuerpo entre dos valores.",
    "bitbybit.flow.time.delay": "retraso",
    "bitbybit.flow.time.delay_description": "Retrasa ejecución por tiempo espera dado en ms.",
    "bitbybit.flow.time.interval": "intervalo",
    "bitbybit.flow.time.interval_description": "Ejecuta el flujo cada intervalo dado en ms.",
    "bitbybit.lists.createList": "crear lista",
    "bitbybit.lists.createList_description": "Crea una lista a partir de los elementos dados.",
    "bitbybit.lists.flatten": "aplanar",
    "bitbybit.lists.flatten_description": "Aplana la lista de listas en una sola lista.",
    "bitbybit.lists.passThrough": "pasar a través",
    "bitbybit.lists.passThrough_description": "Convierte el valor al tipo 'any' y pasa la entrada a la salida sin cambios.",
    "bitbybit.math.numberSlider": "deslizador número",
    "bitbybit.math.numberSlider_description": "Crea un número con un deslizador. Puede configurar valores mín, máx y paso.",
    "bitbybit.consoleLog": "log consola",
    "bitbybit.consoleLog_description": "Registra la entrada en la consola del navegador.",
    "bitbybit.previewData": "vista previa datos",
    "bitbybit.previewData_description": "Muestra los datos de entrada en un área de vista previa. Pueden ser texto, números, objetos json, arrays, etc. No se permiten objetos Javascript circulares.",
    "bitbybit.runner.getRunnerInputValue": "obtener valor entrada ejecutor",
    "bitbybit.runner.getRunnerInputValue_description": "Obtiene el valor de entrada del ejecutor desde el JSON de entradas. Este componente siempre retornará un valor indefinido en el contexto del editor.",
    "bitbybit.runner.getRunnerInputs": "obtener entradas ejecutor",
    "bitbybit.runner.getRunnerInputs_description": "Obtiene las entradas del ejecutor en JSON. Este componente siempre retornará un objeto vacío en el contexto del editor.",
    "bitbybit.runner.run": "ejecutar",
    "bitbybit.runner.run_description": "Ejecuta código javascript del ejecutor",
    "bitbybit.runner.setRunnerResult": "establecer resultado ejecutor",
    "bitbybit.runner.setRunnerResult_description": "Establece el resultado JSON completo para el ejecutor. Tenga en cuenta que es más seguro establecer valores ya que este método sobrescribirá todo el objeto resultado con el valor proporcionado.",
    "bitbybit.runner.setRunnerResultArrayValue": "establecer valor array resultado ejecutor",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Establece el valor resultado del ejecutor en la propiedad del objeto JSON. Cada valor se añadirá a un array, que es el valor de la propiedad.",
    "bitbybit.runner.setRunnerResultValue": "establecer valor resultado ejecutor",
    "bitbybit.runner.setRunnerResultValue_description": "Establece el valor resultado del ejecutor en la propiedad del objeto JSON.",
    "bitbybit.text.areaCreate": "área texto",
    "bitbybit.text.areaCreate_description": "Crea un área de texto en el editor. Puede configurar el texto, ancho y alto del área.",
    "update on drag": "actualizar al arrastrar",
    "paste": "pegar",
    "duplicate": "duplicar",
    "delete": "eliminar",
    "keyboard": "teclado",
    "data": "datos",
    "observables": "observables",
    "buttons": "botones",
    "variables": "variables",
    "functions": "funciones",
    "loop": "bucle",
    "apply": "aplicar",
    "async context": "contexto asíncrono",
    "async context description": "Crea contexto asíncrono que puede usar componentes await, simplificando la ejecución y legibilidad del código asíncrono.",
    "then": "entonces",
    "await": "esperar",
    "await description": "Espera a que la promesa se resuelva y retorna el valor.",
    "when the": "cuando el",
    "error": "error",
    "happens in the promise": "ocurre en la promesa",
    "catch": "capturar",
    "catch description": "Captura el error que pueda ocurrir al ejecutar código asíncrono. El usuario puede elegir manejar los errores apropiadamente.",
    "cancel the interval execution": "cancelar ejecución intervalo",
    "cancel the interval description": "Cancela la ejecución del intervalo proporcionando el manejador.",
    "cancel the timeout execution": "cancelar ejecución tiempo espera",
    "cancel the timeout description": "Cancela la ejecución del tiempo de espera proporcionando el manejador.",
    "key down": "tecla abajo",
    "key down descritpion": "Dispara código cuando ocurre evento tecla abajo.",
    "key up": "tecla arriba",
    "key up description": "Dispara código cuando ocurre evento tecla arriba.",
    "key press": "pulsación tecla",
    "key press description": "Dispara código cuando ocurre evento pulsación tecla.",
    "is key pressed": "está tecla pulsada",
    "block_validation_required": "debe ser proporcionado",
    "block_validation_of_length": "debe contener recuento de elementos de",
    "block_validation_higher_or_equal": "debe ser mayor o igual a",
    "block_validation_lower_or_equal": "debe ser menor o igual a",
    "block_validation_range": "debe estar en rango",
    "block_validation_smaller_than": "debe ser menor que",
    "block_validation_smaller_or_equal_than": "debe ser menor o igual que",
    "block_validation_larger_than": "debe ser mayor que",
    "block_validation_larger_or_equal_than": "debe ser mayor o igual que",
    "save text to file": "guardar texto en archivo",
    "save text to file description": "Guarda texto en un archivo y permite elegir nombre y extensión. Este componente no previsualiza el texto y puede usarse en situaciones donde el texto sea demasiado grande para editar en área de texto.",
    "print text on screen": "imprimir texto en pantalla",
    "print text on screen description": "Imprime texto en pantalla. Este componente es útil para depuración.",
    "preview text and save to file": "previsualizar texto y guardar en archivo",
    "preview text and save to file description": "Imprime texto en pantalla y permite guardarlo en un archivo. Este componente es útil para depuración.",
    "register render loop listener": "registrar escuchador bucle renderizado",
    "and update": "y actualizar",
    "register render loop listener description": "Ejecuta la declaración en el bucle de renderizado e indica cuánto tiempo ha pasado desde el último fotograma en la variable timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "timeElapsedFromPreviousFrame",
    "computing": "calculando",
    "result": "resultado",
    "of promise is returned": "de la promesa es retornado",
    "on pointer up": "al soltar puntero",
    "on pointer move": "al mover puntero",
    "on pointer down": "al presionar puntero",
    "of babylonjs observable object": "del objeto observable babylonjs",
    "observable name": "nombre observable",
    "is key pressed description": "Comprueba si la tecla está presionada y retorna verdadero o falso.",
    "execute code after": "ejecutar código después de",
    "execute code after description": "Ejecuta el código después del tiempo de espera dado en segundos.",
    "execute code every": "ejecutar código cada",
    "second(s)": "segundo(s)",
    "execute code every description": "Ejecuta el código cada intervalo dado en segundos.",
    "handler": "manejador",
    "workers initialising": "inicializando workers",
    "Assets": "Activos",
    "Local assets stored in browser cache:": "Activos locales almacenados en caché del navegador:",
    "Asset Name": "Nombre Activo",
    "Name is required": "El nombre es requerido",
    "Asset with this name already exists, choose a different one": "Ya existe un activo con este nombre, elija uno diferente",
    "Allowed file formats:": "Formatos de archivo permitidos:",
    "You must select an asset file": "Debe seleccionar un archivo de activo",
    "Upload Local Asset": "Subir Activo Local",
    "File Name": "Nombre Archivo",
    "File Size": "Tamaño Archivo",
    "Your browser does not support indexDB and you can't upload local asset files.": "Su navegador no soporta indexDB y no puede subir archivos de activos locales.",
    "Upload": "Subir",
    "elements": "elementos",
    "bitbybit.vector.vectorsTheSame": "vectores iguales",
    "vectorsTheSame": "vectores iguales",
    "bitbybit.vector.vectorsTheSame_description": "Comprueba si dos vectores son iguales dentro de una tolerancia dada (tiene en cuenta la precisión de punto flotante). Ejemplo: [1,2,3] vs [1.0001,2.0001,3.0001] con tolerancia 0.001 → true",
    "vec1": "vector 1",
    "vec2": "vector 2",
    "bitbybit.point.boundingBoxOfPoints": "caja delimitadora de puntos",
    "boundingBoxOfPoints": "caja delimitadora de puntos",
    "bitbybit.point.boundingBoxOfPoints_description": "Calcula el cuadro delimitador alineado al eje que contiene todos los puntos (min, max, centro, ancho, alto, longitud). Ejemplo: puntos=[[0,0,0], [10,5,3]] → {min:[0,0,0], max:[10,5,3], center:[5,2.5,1.5], width:10, height:5, length:3}",
    "bitbybit.point.normalFromThreePoints": "normal a partir de tres puntos",
    "normalFromThreePoints": "normal a partir de tres puntos",
    "bitbybit.point.normalFromThreePoints_description": "Calcula vector normal desde tres puntos usando producto cruz (perpendicular al plano). Ejemplo: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0] → [0,0,1] (apuntando arriba desde plano XY)",
    "reverseNormal": "normal invertida",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "contorno de línea con extensiones",
    "createLineWireWithExtensions": "contorno de línea con extensiones",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Crea un contorno de línea OpenCascade con extensiones",
    "extensionStart": "inicio ext.",
    "extensionEnd": "fin ext.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "punto medio en contorno",
    "midPointOnWire": "punto medio en contorno",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Calcula el punto medio en el contorno en el parámetro 0.5",
    "centerOnOrigin": "centrar en origen",
    "bitbybit.occt.shapes.wire.textWiresWithData": "contornos de texto con datos",
    "textWiresWithData": "contornos de texto con datos",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Crea un compuesto OpenCascade a partir de contornos de texto y devuelve información adicional basada en la fuente simplex creada por el Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "alinear normal y eje",
    "alignNormAndAxis": "alinear normal y eje",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Alinea la forma con la normal y el eje",
    "fromNorm": "desde normal",
    "fromAx": "desde eje",
    "toNorm": "a normal",
    "toAx": "a eje",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "cota de longitud lineal simple",
    "simpleLinearLengthDimension": "cota de longitud lineal simple",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Crea dimensión de longitud lineal simple entre dos puntos - unidades de medición. Usted decide qué tipo de unidades está usando proporcionando un sufijo.",
    "offsetFromPoints": "desplazamiento desde puntos",
    "crossingSize": "tamaño de cruce",
    "labelSuffix": "sufijo de etiqueta",
    "labelSize": "tamaño de etiqueta",
    "labelOffset": "desplazamiento de etiqueta",
    "bitbybit.occt.dimensions.simpleAngularDimension": "dimensión angular simple",
    "simpleAngularDimension": "dimensión angular simple",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Crea una dimensión angular simple. Por defecto, se muestran grados, pero puedes optar por usar radianes.",
    "direction1": "dirección 1",
    "direction2": "dirección 2",
    "offsetFromCenter": "desplazamiento desde el centro",
    "extraSize": "tamaño extra",
    "radians": "radianes",
    "bitbybit.occt.dimensions.pinWithLabel": "pin con etiqueta",
    "pinWithLabel": "pin con etiqueta",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Crea un pin con etiqueta. Se puede usar para explicar cosas sobre los modelos o marcar elementos importantes en la escena 3D.",
    "offsetFromStart": "desplazamiento desde el inicio",
    "bitbybit.vector.lengthSq": "longitud al cuadrado",
    "lengthSq": "longitud al cuadrado",
    "bitbybit.vector.lengthSq_description": "Calcula la longitud al cuadrado (magnitud al cuadrado) de un vector 3D. Ejemplo: [3,4,0] → 25 (longitud 5 al cuadrado)",
    "bitbybit.point.twoPointsAlmostEqual": "dos puntos iguales",
    "twoPointsAlmostEqual": "dos puntos iguales",
    "bitbybit.point.twoPointsAlmostEqual_description": "Comprueba si dos puntos son aproximadamente iguales dentro de tolerancia (comparación basada en distancia). Ejemplo: punto1=[1.0000001, 2.0, 3.0], punto2=[1.0, 2.0, 3.0], tolerancia=1e-6 → true",
    "bitbybit.line.lineToSegment": "línea a segmento",
    "lineToSegment": "línea a segmento",
    "bitbybit.line.lineToSegment_description": "Convierte objeto línea a formato array de segmento. Ejemplo: {start:[0,0,0], end:[10,5,0]} → [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "líneas a segmentos",
    "linesToSegments": "líneas a segmentos",
    "bitbybit.line.linesToSegments_description": "Convierte múltiples objetos línea a formato array de segmento (conversión por lotes). Ejemplo: 3 objetos línea → 3 arrays de segmento [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "segmento a línea",
    "segmentToLine": "segmento a línea",
    "bitbybit.line.segmentToLine_description": "Convierte array de segmento a formato objeto línea. Ejemplo: [[0,0,0], [10,5,0]] → {start:[0,0,0], end:[10,5,0]}",
    "segment": "segmento",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segmentos a líneas",
    "segmentsToLines": "segmentos a líneas",
    "bitbybit.line.segmentsToLines_description": "Convierte múltiples arrays de segmento a formato objeto línea (conversión por lotes). Ejemplo: 3 arrays de segmento → 3 objetos línea con propiedades start/end",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "ordenar segmentos en polilíneas",
    "sortSegmentsIntoPolylines": "ordenar segmentos en polilíneas",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Ordena segmentos revueltos en polilíneas conectadas emparejando puntos finales. Usa hashing espacial para búsqueda eficiente de conexiones. Ejemplo: 10 segmentos aleatorios que forman 2 caminos conectados → 2 polilíneas",
    "sort": "ordenar",
    "bitbybit.mesh.signedDistanceToPlane": "distancia con signo al plano",
    "signedDistanceToPlane": "distancia con signo al plano",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calcula distancia con signo desde un punto a un plano (positivo=sobre plano, negativo=bajo plano). Ejemplo: punto=[0,5,0], plano={normal:[0,1,0], d:0} → 5 (punto está 5 unidades sobre plano XZ)",
    "plane": "plano",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calcular plano del triángulo",
    "calculateTrianglePlane": "calcular plano del triángulo",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calcula ecuación de plano desde vértices de triángulo (vector normal y distancia desde origen). Devuelve indefinido si triángulo es degenerado (área cero, puntos colineales). Ejemplo: triángulo=[[0,0,0], [1,0,0], [0,1,0]] → {normal:[0,0,1], d:0} (plano XY)",
    "triangle": "triángulo",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "intersección triángulo-triángulo",
    "triangleTriangleIntersection": "intersección triángulo-triángulo",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calcula segmento de intersección de dos triángulos (segmento de línea donde se cruzan). Devuelve indefinido si triángulos no intersectan, son paralelos o coplanares. Ejemplo: triángulo1=[[0,0,0], [2,0,0], [1,2,0]], triángulo2=[[1,-1,1], [1,1,1], [1,1,-1]] → [[1,0,0], [1,1,0]]",
    "triangle1": "triángulo 1",
    "triangle2": "triángulo 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segmentos de intersección malla-malla",
    "meshMeshIntersectionSegments": "segmentos de intersección malla-malla",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calcula todos los segmentos de intersección entre dos mallas de triángulos (pruebas de triángulos por pares). Devuelve array de segmentos de línea donde superficies de malla intersectan. Ejemplo: malla cubo intersectando con malla esfera → múltiples segmentos formando curva de intersección",
    "mesh1": "malla 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "malla 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polilíneas de intersección malla-malla",
    "meshMeshIntersectionPolylines": "polilíneas de intersección malla-malla",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calcula polilíneas de intersección entre dos mallas ordenando segmentos en caminos conectados. Segmentos se unen extremo-con-extremo para formar curvas continuas o cerradas. Ejemplo: intersección cubo-esfera → bucles de polilínea cerrados donde superficies se encuentran",
    "bitbybit.occt.shapeFacesToPolygonPoints": "caras de forma a puntos de polígono",
    "shapeFacesToPolygonPoints": "caras de forma a puntos de polígono",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Crea puntos de polígono a partir de las caras de la forma",
    "reversedPoints": "puntos invertidos",
    "bitbybit.occt.shapeToMesh": "forma a malla",
    "shapeToMesh": "forma a malla",
    "bitbybit.occt.shapeToMesh_description": "Crea una malla a partir de la forma",
    "bitbybit.occt.shapesToMeshes": "formas a mallas",
    "shapesToMeshes": "formas a mallas",
    "bitbybit.occt.shapesToMeshes_description": "Crea una malla a partir de la forma",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "desde puntos de polígono",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Crear un Manifold a partir de un conjunto de puntos de polígono que describen triángulos.",
    "traingle": "triángulo",
    "bitbybit.point.stretchPointsDirFromCenter": "estirar puntos en dirección desde el centro",
    "stretchPointsDirFromCenter": "estirar puntos en dirección desde el centro",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Estira múltiples puntos a lo largo de una dirección desde un punto central (escalado direccional). Ejemplo: puntos=[[10,0,0]], centro=[0,0,0], dirección=[1,0,0], escala=2 → [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "rejilla hexagonal escalada para ajustar",
    "hexGridScaledToFit": "rejilla hexagonal escalada para ajustar",
    "bitbybit.point.hexGridScaledToFit_description": "Crea cuadrícula hexagonal escalada para caber dentro de los límites de ancho/alto especificados (calcula tamaño de hex automáticamente). Devuelve puntos centrales y vértices de hex. Soporta orientación de punta arriba o plana arriba. Ejemplo: ancho=10, alto=10, nrHexagonosEnAltura=3 → cuadrícula hex llenando área 10×10 con 3 filas",
    "nrHexagonsU": "nº hexágonos U",
    "nrHexagonsV": "nº hexágonos V",
    "extendTop": "extender arriba",
    "extendBottom": "extender abajo",
    "extendLeft": "extender izquierda",
    "extendRight": "extender derecha",
    "centerGrid": "centrar rejilla",
    "bitbybit.point.sortPoints": "ordenar puntos",
    "sortPoints": "ordenar puntos",
    "bitbybit.point.sortPoints_description": "Ordena puntos lexicográficamente (por coordenadas X, luego Y, luego Z). Ejemplo: [[5,0,0], [1,0,0], [3,0,0]] → [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "intersección línea-línea",
    "lineLineIntersection": "intersección línea-línea",
    "bitbybit.line.lineLineIntersection_description": "Calcula punto de intersección de dos líneas (o segmentos si checkSegmentsOnly=true). Devuelve indefinido si líneas son paralelas, sesgadas, o segmentos no se superponen. Ejemplo: línea1={start:[0,0,0], end:[10,0,0]}, línea2={start:[5,-5,0], end:[5,5,0]} → [5,0,0]",
    "line1": "línea 1",
    "line2": "línea 2",
    "checkSegmentsOnly": "comprobar solo segmentos",
    "bitbybit.polyline.polylineToLines": "polilínea a líneas",
    "polylineToLines": "polilínea a líneas",
    "bitbybit.polyline.polylineToLines_description": "Convierte polilínea a segmentos de línea (cada segmento como objeto línea con start/end). Polilíneas cerradas incluyen segmento de cierre. Ejemplo: 3 puntos → 2 o 3 líneas (dependiendo de isClosed)",
    "bitbybit.polyline.polylineToSegments": "polilínea a segmentos",
    "polylineToSegments": "polilínea a segmentos",
    "bitbybit.polyline.polylineToSegments_description": "Convierte polilínea a arrays de segmento (cada segmento como [punto1, punto2]). Polilíneas cerradas incluyen segmento de cierre si puntos finales difieren. Ejemplo: 4 puntos, cerrada → 4 segmentos conectando todos los puntos en un bucle",
    "bitbybit.polyline.polylineSelfIntersection": "autointersección de polilínea",
    "polylineSelfIntersection": "autointersección de polilínea",
    "bitbybit.polyline.polylineSelfIntersection_description": "Encuentra puntos donde la polilínea se cruza consigo misma (puntos de auto-intersección). Omite segmentos adyacentes y deduplica puntos cercanos. Ejemplo: polilínea en forma de 8 → devuelve punto de cruce central",
    "bitbybit.polyline.twoPolylineIntersection": "intersección de dos polilíneas",
    "twoPolylineIntersection": "intersección de dos polilíneas",
    "bitbybit.polyline.twoPolylineIntersection_description": "Encuentra puntos de intersección entre dos polilíneas (todos los cruces segmento-segmento). Prueba todos los pares de segmentos y deduplica puntos cercanos. Ejemplo: polilíneas cruzadas formando una X → devuelve punto de intersección central",
    "polyline1": "polilínea 1",
    "polyline2": "polilínea 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdividir en alambres hexagonales",
    "subdivideToHexagonWires": "subdividir en alambres hexagonales",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivide una cara en alambres hexagonales",
    "extendUUp": "extender U arriba",
    "extendUBottom": "extender U abajo",
    "extendVUp": "extender V arriba",
    "extendVBottom": "extender V abajo",
    "nrHexagonsInHeight": "nº hexágonos en altura",
    "nrHexagonsInWidth": "nº hexágonos en anchura",
    "bitbybit.vector.length": "longitud del vector",
    "bitbybit.vector.length_description": "Calcula la longitud (magnitud) de un vector 3D. Ejemplo: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.point.maxFilletRadius": "radio máximo de redondeo",
    "maxFilletRadius": "radio máximo de redondeo",
    "bitbybit.point.maxFilletRadius_description": "Calcula el radio máximo de redondeo posible en una esquina formada por dos segmentos de línea que comparten un punto final (C), de modo que el arco de redondeo sea tangente a ambos segmentos y se encuentre completamente dentro de ellos.",
    "bitbybit.point.maxFilletRadiusHalfLine": "radio máximo de redondeo media línea",
    "maxFilletRadiusHalfLine": "radio máximo de redondeo media línea",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calcula el radio máximo de redondeo posible en una esquina C, de modo que el arco de redondeo sea tangente a ambos segmentos (P1-C, P2-C) y los puntos tangentes se encuentren dentro de la primera mitad de cada segmento (medido desde C).",
    "bitbybit.point.maxFilletsHalfLine": "redondeos máximos media línea",
    "maxFilletsHalfLine": "redondeos máximos media línea",
    "bitbybit.point.maxFilletsHalfLine_description": "Calcula el radio máximo de redondeo posible en cada esquina de una polilínea formada por una serie de puntos. El radio de redondeo se calcula para cada esquina interna y opcionalmente para las esquinas de cierre si la polilínea está cerrada.",
    "checkLastWithFirst": "comprobar último con primero",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "radio máximo de redondeo más seguro (puntos, media línea)",
    "safestPointsMaxFilletHalfLine": "radio máximo de redondeo más seguro (puntos, media línea)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calcula el único radio máximo de redondeo más seguro que se puede aplicar uniformemente a todas las esquinas de una colección de puntos, basado en la restricción de 'media línea'. Esto se determina encontrando el mínimo de los radios máximos de redondeo posibles calculados para cada esquina individual.",
    "bitbybit.polyline.maxFilletsHalfLine": "redondeos máximos media línea",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calcula el radio máximo de redondeo de media línea posible para cada esquina de una polilínea dada. Para una polilínea cerrada, incluye las esquinas que conectan el último segmento con el primero. El cálculo utiliza la restricción de 'media línea', lo que significa que los puntos tangentes del redondeo deben estar dentro de la primera mitad de cada segmento conectado a la esquina.",
    "bitbybit.polyline.safestFilletRadius": "radio de redondeo más seguro",
    "safestFilletRadius": "radio de redondeo más seguro",
    "bitbybit.polyline.safestFilletRadius_description": "Calcula el único radio máximo de redondeo más seguro que se puede aplicar uniformemente a todas las esquinas de una polilínea, basado en la restricción de 'media línea'. Esto se determina encontrando el mínimo de los radios máximos de redondeo posibles calculados para cada esquina individual.",
    "flatTop": "parte superior plana",
    "bitbybit.mesh.meshMeshIntersectionPoints": "puntos de intersección malla-malla",
    "meshMeshIntersectionPoints": "puntos de intersección malla-malla",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calcula puntos de intersección entre dos mallas como arrays de puntos (un array por polilínea). Polilíneas cerradas tienen primer punto duplicado al final. Ejemplo: intersección cubo-esfera → arrays de puntos definiendo curvas de intersección",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexágonos en rejilla",
    "hexagonsInGrid": "hexágonos en rejilla",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Crea alambres hexagonales de OpenCascade en una rejilla",
    "scalePatternWidth": "escalar anchura del patrón",
    "scalePatternHeight": "escalar altura del patrón",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "alambres de intersección malla-malla",
    "meshMeshIntersectionWires": "alambres de intersección malla-malla",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Realiza una operación de intersección malla-malla entre dos formas; ambas formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los alambres de la intersección, que son polilíneas o polígonos.",
    "mesh based": "basado en malla",
    "precision1": "precisión 1",
    "precision2": "precisión 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "puntos de intersección malla-malla",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Realiza una operación de intersección malla-malla entre dos formas; ambas formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los puntos de la intersección.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "intersección malla-malla a alambres",
    "meshMeshIntersectionOfShapesWires": "intersección malla-malla a alambres",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Realiza una operación de intersección malla-malla entre la forma y múltiples otras formas; todas las formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los alambres de la intersección, que son polilíneas o polígonos.",
    "precisionShapes": "precisión formas",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "intersección malla-malla a puntos",
    "meshMeshIntersectionOfShapesPoints": "intersección malla-malla a puntos",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Realiza una operación de intersección malla-malla entre la forma y múltiples otras formas; todas las formas pueden tener su propia precisión de mallado. Este algoritmo interseca las mallas y devuelve los puntos de la intersección.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexágonos en rejilla",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Crea hexágonos de OpenCascade en una rejilla (caras)",
    "bitbybit.jscad.toPolygonPoints": "a puntos de polígono",
    "toPolygonPoints": "a puntos de polígono",
    "bitbybit.jscad.toPolygonPoints_description": "Convierte la malla Jscad a puntos de polígono representando triángulos de la malla.",
    "conversions": "conversiones",
    "bitbybit.manifold.toPolygonPoints": "a puntos de polígono",
    "bitbybit.manifold.toPolygonPoints_description": "Convierte la forma manifold en una colección de puntos de polígono que representan la malla.",
    "flatU": "plano U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdividir en agujeros hexagonales",
    "subdivideToHexagonHoles": "subdividir en agujeros hexagonales",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivide una cara en agujeros hexagonales",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "convertir líneas a curvas NURBS",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Convierte líneas en curvas NURBS. Devuelve un array de objetos verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "convertir línea a curva NURBS",
    "convertLineToNurbsCurve": "convertir línea a curva NURBS",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Convierte una línea en una curva NURBS. Devuelve el objeto verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "convertir polilínea a curva NURBS",
    "convertPolylineToNurbsCurve": "convertir polilínea a curva NURBS",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Convierte una polilínea en una curva NURBS. Devuelve el objeto verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "convertir polilíneas a curvas NURBS",
    "convertPolylinesToNurbsCurves": "convertir polilíneas a curvas NURBS",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Convierte polilíneas en curvas NURBS. Devuelve los objetos verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segmento",
    "createSegment": "segmento",
    "bitbybit.line.createSegment_description": "Crea un segmento a partir de dos puntos (formato array: [start, end]). Ejemplo: start=[0,0,0], end=[10,5,0] → [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "arista desde línea base",
    "fromBaseLine": "desde línea base",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Crea una arista lineal desde el formato de línea base {start: Point3, end: Point3}",
    "from base": "desde base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "arista desde líneas base",
    "fromBaseLines": "desde líneas base",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Crea aristas lineales desde el formato de líneas base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "arista desde segmento base",
    "fromBaseSegment": "desde segmento base",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Crea una arista lineal desde el formato de segmento base [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "aristas desde segmentos base",
    "fromBaseSegments": "desde segmentos base",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Crea una arista lineal desde el formato de segmentos base [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "aristas desde puntos",
    "fromPoints": "desde puntos",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Crea aristas lineales desde una colección de puntos",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "aristas desde polilínea base",
    "fromBasePolyline": "desde polilínea base",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Crea aristas lineales desde la definición de polilínea",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "aristas desde triángulo base",
    "fromBaseTriangle": "desde triángulo base",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Crea aristas lineales desde la definición de triángulo",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "aristas desde malla base",
    "fromBaseMesh": "desde malla base",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Crea aristas lineales desde la definición de malla",
    "bitbybit.occt.shapes.wire.fromBaseLine": "alambre desde línea base",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Crea un alambre lineal desde el formato de línea base {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "alambres desde líneas base",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Crea alambres lineales desde el formato de líneas base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "alambre desde segmento base",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Crea un alambre lineal desde el formato de segmento base [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "alambres desde segmentos base",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Crea alambres lineales desde el formato de segmentos base [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "alambre desde puntos",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Crea un alambre desde una colección de puntos",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "alambre desde polilínea base",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Crea un alambre desde la definición de polilínea",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "alambre desde triángulo base",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Crea un alambre desde la definición de triángulo",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "alambres desde malla base",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Crea alambres desde la definición de malla",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "cara desde triángulo base",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Crea una cara desde la definición de triángulo",
    "bitbybit.occt.shapes.face.fromBaseMesh": "caras desde malla base",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Crea caras desde la definición de malla",
    "fromRightHanded": "desde diestro",
    "bitbybit.advanced.text3d.createWithUrl": "texto con url",
    "createWithUrl": "texto con url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Crea un texto 3d con una URL de fuente Esto es útil cuando desea usar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se usará para generar el texto 3d. Asegúrese de que las fuentes no contengan auto intersección y otros caracteres malos - eso es un problema común con fuentes personalizadas. Los formatos de fuente soportados son: ttf, otf, woff. Tenga en cuenta que Woff2 no es soportado por opentype.js ya que es un formato comprimido.",
    "fontUrl": "url de la fuente",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "texto en cara url",
    "createTextOnFaceUrl": "texto en cara url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Crea un texto 3D en la cara utilizando una URL de fuente. Esto es útil cuando se quiere utilizar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se utilizará para generar el texto 3D. Asegúrese de que las fuentes no contengan autointersecciones y otros caracteres incorrectos; es un problema común con las fuentes personalizadas. Los formatos de fuente compatibles son: ttf, otf, woff. Tenga en cuenta que Woff2 no es compatible con opentype.js ya que es un formato comprimido.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "textos en cara url",
    "createTextsOnFaceUrl": "textos en cara url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Crea textos 3d en la cara desde múltiples definiciones de url Esto es útil cuando desea usar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se usará para generar el texto 3d. Asegúrese de que las fuentes no contengan auto intersección y otros caracteres malos - eso es un problema común con fuentes personalizadas. Los formatos de fuente soportados son: ttf, otf, woff. Tenga en cuenta que Woff2 no es soportado por opentype.js ya que es un formato comprimido.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "definición de texto 3d en cara url",
    "definition3dTextOnFaceUrl": "definición de texto 3d en cara url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Crea texto 3d que se usará en la definición de url de cara Esto es útil cuando desea usar una fuente personalizada que no está incluida en la biblioteca. La fuente se cargará desde la URL proporcionada y se usará para generar el texto 3d. Asegúrese de que las fuentes no contengan auto intersección y otros caracteres malos - eso es un problema común con fuentes personalizadas. Los formatos de fuente soportados son: ttf, otf, woff. Tenga en cuenta que Woff2 no es soportado por opentype.js ya que es un formato comprimido.",
    "bitbybit.advanced.navigation.pointOfInterest": "punto de interés",
    "navigation": "navegación",
    "pointOfInterest": "punto de interés",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Crea punto de interés - indicador clickeable en espacio 3D que se puede usar para volar la cámara a una ubicación específica con posición de cámara y objetivo predefinidos. Punto de interés se puede estilizar con PointOfInterestStyleDto y animar con efecto de pulso. Punto de interés también puede tener una etiqueta de texto.",
    "cameraTarget": "objetivo de la cámara",
    "cameraPosition": "posición de la cámara",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "sistema de puntos de interés",
    "pointsOfInterestSystem": "sistema de puntos de interés",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "puntos de interés",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "punto de interés",
    "style": "estilo",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "estilo de punto de interés",
    "pointOfInterestStyle": "estilo de punto de interés",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Crear estilo de punto de interés: se utiliza para dar estilo a los indicadores de puntos de interés en el espacio 3D. Puede personalizar el tamaño del punto, el color, el color al pasar el cursor, el efecto de pulso, el color y el tamaño de la etiqueta de texto.",
    "pointSize": "tamaño del punto",
    "pointColor": "color del punto",
    "hoverPointColor": "color del punto al pasar el cursor",
    "pulseColor": "color del pulso",
    "hoverPulseColor": "color del pulso al pasar el cursor",
    "pulseMinSize": "tamaño mínimo del pulso",
    "pulseMaxSize": "tamaño máximo del pulso",
    "pulseThickness": "grosor del pulso",
    "pulseSpeed": "velocidad del pulso",
    "textColor": "color del texto",
    "hoverTextColor": "color del texto al pasar el cursor",
    "textSize": "tamaño del texto",
    "hideSkybox": "ocultar skybox",
    "textureUrl": "URL de la textura",
    "hdrTexture": "textura HDR",
    "textureSize": "tamaño de la textura",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "habilitar textura personalizada del skybox",
    "enableSkyboxCustomTexture": "habilitar textura personalizada del skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Habilita el skybox con una textura personalizada",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "imagen de fondo CSS del canvas",
    "canvasCSSBackgroundImage": "imagen de fondo CSS del canvas",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Cambia el fondo de la escena a una imagen de fondo CSS para el espacio 3D",
    "cssBackgroundImage": "imagen de fondo CSS",
    "bitbybit.babylon.scene.twoColorLinearGradient": "gradiente lineal de dos colores",
    "twoColorLinearGradient": "gradiente lineal de dos colores",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Crea un fondo de gradiente lineal de dos colores para el espacio 3D",
    "colorFrom": "color desde",
    "colorTo": "color hasta",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "parada desde",
    "stopTo": "parada hasta",
    "bitbybit.babylon.scene.twoColorRadialGradient": "gradiente radial de dos colores",
    "twoColorRadialGradient": "gradiente radial de dos colores",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Crea un fondo de gradiente radial de dos colores para el espacio 3D",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "gradiente lineal multicolor",
    "multiColorLinearGradient": "gradiente lineal multicolor",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Crea un fondo de gradiente lineal multicolor para el espacio 3D",
    "Base.Color[]": "Base.Color[]",
    "stops": "paradas",
    "bitbybit.babylon.scene.multiColorRadialGradient": "gradiente radial multicolor",
    "multiColorRadialGradient": "gradiente radial multicolor",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Crea un fondo de gradiente radial multicolor para el espacio 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "imagen de fondo del canvas",
    "canvasBackgroundImage": "imagen de fondo del canvas",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Establece una imagen de fondo con varias opciones de personalización para el espacio 3D",
    "imageUrl": "URL de imagen",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "adjunto",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "recorte",
    "labelRotation": "rotación de etiqueta",
    "bitbybit.advanced.dimensions.linearDimension": "dimensión lineal",
    "linearDimension": "dimensión lineal",
    "bitbybit.advanced.dimensions.linearDimension_description": "Crea una dimensión lineal - una línea de medida entre dos puntos con líneas de extensión y etiqueta de texto. La dimensión muestra la distancia entre los puntos y se puede estilizar con DimensionStyleDto.",
    "linear dimension": "dimensión lineal",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "dimensión angular",
    "angularDimension": "dimensión angular",
    "bitbybit.advanced.dimensions.angularDimension_description": "Crea una dimensión angular - un arco de medida entre dos vectores de dirección con líneas de extensión y etiqueta de texto. La dimensión muestra el ángulo entre las direcciones y se puede estilizar con DimensionStyleDto.",
    "angular dimension": "dimensión angular",
    "centerPoint": "punto central",
    "bitbybit.advanced.dimensions.dimensionStyle": "estilo de dimensión",
    "dimensionStyle": "estilo de dimensión",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Crear estilo de dimensión - utilizado para estilizar líneas de dimensión, flechas y texto en el espacio 3D. Puedes personalizar colores de línea, grosor, tamaño de texto, tamaño de flecha y colores de fondo.",
    "dimension style": "estilo de dimensión",
    "lineColor": "color de línea",
    "lineThickness": "grosor de línea",
    "extensionLineLength": "longitud de línea de extensión",
    "textBackgroundColor": "color de fondo del texto",
    "textBackgroundOpacity": "opacidad del fondo del texto",
    "arrowSize": "tamaño de flecha",
    "arrowColor": "color de flecha",
    "textRenderMode": "modo de renderizado de texto",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "cartelera de texto",
    "occlusionCheckInterval": "intervalo de verificación de oclusión",
    "arrowTailLength": "longitud de cola de flecha",
    "showArrows": "mostrar flechas",
    "labelOverwrite": "sobrescribir etiqueta",
    "bitbybit.advanced.dimensions.radialDimension": "dimensión radial",
    "radialDimension": "dimensión radial",
    "bitbybit.advanced.dimensions.radialDimension_description": "Crea una dimensión radial - una línea de medida desde el centro hasta el perímetro que muestra radio o diámetro. Muestra el prefijo 'R' para radio o el prefijo '⌀' para diámetro con marca central opcional.",
    "radial dimension": "dimensión radial",
    "radiusPoint": "punto de radio",
    "showDiameter": "mostrar diámetro",
    "showCenterMark": "mostrar marca central",
    "bitbybit.advanced.dimensions.diametralDimension": "dimensión diametral",
    "diametralDimension": "dimensión diametral",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Crea una dimensión diametral - una línea de medida que abarca el diámetro completo de características circulares. Muestra el prefijo '⌀' con marca central opcional y flechas en ambos extremos.",
    "diametral dimension": "dimensión diametral",
    "bitbybit.advanced.dimensions.ordinateDimension": "dimensión de ordenada",
    "ordinateDimension": "dimensión de ordenada",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Crea una dimensión de ordenada - muestra la coordenada X, Y o Z desde un punto de referencia con línea guía. Útil para anotaciones de coordenadas y referenciado de datos en dibujos técnicos.",
    "ordinate dimension": "dimensión de ordenada",
    "measurementPoint": "punto de medición",
    "referencePoint": "punto de referencia",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "mostrar línea guía",
    "viewMode": "modo de vista",
    "schema": "esquema",
    "json schema": "esquema JSON",
    "metadata": "metadatos",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "fondo de gradiente lineal de dos colores",
    "twoColorLinearGradientBackground": "fondo de gradiente lineal de dos colores",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Crea un fondo de gradiente lineal de dos colores para el espacio 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "fondo de gradiente radial de dos colores",
    "twoColorRadialGradientBackground": "fondo de gradiente radial de dos colores",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Crea un fondo de gradiente radial de dos colores para el espacio 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "fondo de gradiente lineal multicolor",
    "multiColorLinearGradientBackground": "fondo de gradiente lineal multicolor",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Crea un fondo de gradiente lineal multicolor para el espacio 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "fondo de gradiente radial multicolor",
    "multiColorRadialGradientBackground": "fondo de gradiente radial multicolor",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Crea un fondo de gradiente radial multicolor para el espacio 3D",
    "textBackgroundStroke": "trazo del fondo del texto",
    "textBackgroundRadius": "radio del fondo del texto",
    "stableSize": "tamaño estable",
    "alwaysOnTop": "siempre encima",
    "textStableSize": "tamaño de texto estable",
    "bitbybit.occt.io.shapeToDxfPaths": "forma a rutas DXF",
    "shapeToDxfPaths": "forma a rutas DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Crea rutas DXF desde una forma OCCT Importante - formas conteniendo alambres deben yacer en plano XZ (Y=0) para exportación DXF 2D correcta.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "rutas DXF con capa",
    "dxfPathsWithLayer": "rutas DXF con capa",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Añade información de capa y color a rutas DXF Importante - formas conteniendo alambres deben yacer en plano XZ (Y=0) para exportación DXF 2D correcta.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "capa",
    "bitbybit.occt.io.dxfCreate": "crear DXF",
    "dxfCreate": "crear DXF",
    "bitbybit.occt.io.dxfCreate_description": "Ensambla múltiples partes de ruta en un archivo DXF completo",
    "pathsParts": "partes de rutas",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "grosor de fuente de texto",
    "textPosition": "posición del texto",
    "textBackgroundStrokeThickness": "grosor del trazo",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Borrar",
    "recompute": "Recalcular",
    "clear tooltip": "Borrar toda la caché y los componentes",
    "recompute tooltip": "Borra la caché y recalcula",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "alambre de perfil de viga I",
    "createIBeamProfileWire": "alambre de perfil de viga I",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Crea alambre de perfil de viga I de OpenCascade",
    "beam profiles": "perfiles de vigas",
    "webThickness": "espesor del alma",
    "flangeThickness": "espesor del ala",
    "alignment": "alineación",
    "Base.basicAlignmentEnum": "Base.basicAlignmentEnum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "alambre de perfil de viga H",
    "createHBeamProfileWire": "alambre de perfil de viga H",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Crea alambre de perfil de viga H de OpenCascade",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "alambre de perfil de viga T",
    "createTBeamProfileWire": "alambre de perfil de viga T",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Crea alambre de perfil de viga T de OpenCascade",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "alambre de perfil de viga U",
    "createUBeamProfileWire": "alambre de perfil de viga U",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Crea alambre de perfil de viga U de OpenCascade",
    "flangeWidth": "ancho del ala",
    "bitbybit.occt.shapes.face.createLPolygonFace": "cara de polígono L",
    "createLPolygonFace": "cara de polígono L",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Crea cara de polígono L de OpenCascade",
    "bitbybit.occt.shapes.face.createStarFace": "cara de estrella",
    "createStarFace": "cara de estrella",
    "bitbybit.occt.shapes.face.createStarFace_description": "Crea cara de estrella de OpenCascade",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "cara de árbol de navidad",
    "createChristmasTreeFace": "cara de árbol de navidad",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Crea cara de árbol de navidad de OpenCascade",
    "bitbybit.occt.shapes.face.createParallelogramFace": "cara de paralelogramo",
    "createParallelogramFace": "cara de paralelogramo",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Crea cara de paralelogramo de OpenCascade",
    "bitbybit.occt.shapes.face.createHeartFace": "cara de corazón",
    "createHeartFace": "cara de corazón",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Crea cara de corazón de OpenCascade",
    "bitbybit.occt.shapes.face.createNGonFace": "cara de n-gono",
    "createNGonFace": "cara de n-gono",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Crea cara de n-gono de OpenCascade",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "cara de perfil de viga I",
    "createIBeamProfileFace": "cara de perfil de viga I",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Crea cara de perfil de viga I de OpenCascade",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "cara de perfil de viga H",
    "createHBeamProfileFace": "cara de perfil de viga H",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Crea cara de perfil de viga H de OpenCascade",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "cara de perfil de viga T",
    "createTBeamProfileFace": "cara de perfil de viga T",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Crea cara de perfil de viga T de OpenCascade",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "cara de perfil de viga U",
    "createUBeamProfileFace": "cara de perfil de viga U",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Crea cara de perfil de viga U de OpenCascade",
    "bitbybit.occt.shapes.solid.createStarSolid": "sólido de estrella",
    "createStarSolid": "sólido de estrella",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Crea sólido de estrella de OpenCascade",
    "extrusionLengthFront": "longitud de extrusión frontal",
    "extrusionLengthBack": "longitud de extrusión trasera",
    "bitbybit.occt.shapes.solid.createNGonSolid": "sólido de n-gono",
    "createNGonSolid": "sólido de n-gono",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Crea sólido de n-gono de OpenCascade",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "sólido de paralelogramo",
    "createParallelogramSolid": "sólido de paralelogramo",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Crea sólido de paralelogramo de OpenCascade",
    "bitbybit.occt.shapes.solid.createHeartSolid": "sólido de corazón",
    "createHeartSolid": "sólido de corazón",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Crea sólido de corazón de OpenCascade",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "sólido de árbol de navidad",
    "createChristmasTreeSolid": "sólido de árbol de navidad",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Crea sólido de árbol de navidad de OpenCascade",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "sólido de polígono L",
    "createLPolygonSolid": "sólido de polígono L",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Crea sólido de polígono L de OpenCascade",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "sólido de perfil de viga I",
    "createIBeamProfileSolid": "sólido de perfil de viga I",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Crea sólido de perfil de viga I de OpenCascade",
    "beam": "viga",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "sólido de perfil de viga H",
    "createHBeamProfileSolid": "sólido de perfil de viga H",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Crea sólido de perfil de viga H de OpenCascade",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "sólido de perfil de viga T",
    "createTBeamProfileSolid": "sólido de perfil de viga T",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Crea sólido de perfil de viga T de OpenCascade",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "sólido de perfil de viga U",
    "createUBeamProfileSolid": "sólido de perfil de viga U",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Crea sólido de perfil de viga U de OpenCascade",
    "endType": "tipo de extremo",
    "dimensionEndTypeEnum": "dimensionEndTypeEnum",
    "arrowAngle": "ángulo de flecha",
    "arrowsFlipped": "flechas volteadas",
    "colorFormat": "formato de color",
    "dxfColorFormatEnum": "dxfColorFormatEnum",
    "acadVersion": "versión acad",
    "dxfAcadVersionEnum": "dxfAcadVersionEnum",
    "bitbybit.advanced.navigation.zoomOn": "acercar en",
    "zoomOn": "acercar en",
    "bitbybit.advanced.navigation.zoomOn_description": "Acerca la cámara para ajustar las mallas especificadas en la escena con animación suave. Solo funciona con ArcRotateCamera. La animación puede interrumpirse si se llama varias veces.",
    "animationSpeed": "velocidad de animación",
    "doNotUpdateMaxZ": "no actualizar max z",
    "bitbybit.advanced.navigation.focusFromAngle": "enfocar desde ángulo",
    "focusFromAngle": "enfocar desde ángulo",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Enfoca la cámara en las mallas especificadas desde un ángulo específico con animación suave. Calcula el centro del cuadro delimitador de todas las mallas y posiciona la cámara en el vector de orientación especificado para mirar al centro. Solo funciona con ArcRotateCamera. La animación puede interrumpirse si se llama varias veces.",
    "padding": "relleno",
    "shadowRefreshRate": "Tasa de actualización de sombra",
    "labelFlipHorizontal": "Voltear etiqueta horizontalmente",
    "labelFlipVertical": "Voltear etiqueta verticalmente",
    "bitbybit.advanced.navigation.zoomOnAspect": "Zoom en aspecto",
    "zoomOnAspect": "Zoom en aspecto",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Hace zoom en la cámara para ajustar las mallas especificadas en la escena con animación suave, considerando la relación de aspecto exacta de la pantalla. A diferencia de zoomOn, este método calcula con precisión la distancia de la cámara basándose en las dimensiones del viewport y el cuadro delimitador de la malla para garantizar un mejor ajuste con padding=0. Solo funciona con ArcRotateCamera. La animación puede interrumpirse si se llama varias veces.",
    "bitbybit.vector.parseNumbers": "analizar números",
    "parseNumbers": "analizar números",
    "bitbybit.vector.parseNumbers_description": "Convierte un array de números en cadena a números reales. Ejemplo: ['1', '2.5', '3'] → [1, 2.5, 3], ['10', '-5', '0.1'] → [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "simplificar",
    "bitbybit.manifold.manifold.operations.simplify_description": "Devuelve una copia del manifold simplificada a la tolerancia dada, pero con su valor de tolerancia real sin cambios. El resultado contendrá un subconjunto de los vértices originales y todas las superficies se habrán movido menos que la tolerancia.",
    "bitbybit.manifold.manifold.operations.setProperties": "establecer propiedades",
    "setProperties": "establecer propiedades",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Crea una nueva copia de este manifold con propiedades de vértice actualizadas suministrando una función que toma la posición existente y las propiedades como entrada. Puede especificar cualquier número de propiedades de salida, permitiendo la creación y eliminación de canales. Nota: resultará en un comportamiento indefinido si lee más allá del número de propiedades de entrada o escribe más allá del número de propiedades de salida.",
    "propFunc": "función de propiedades",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "deformar",
    "warp": "deformar",
    "bitbybit.manifold.manifold.transforms.warp_description": "Mueve los vértices de este Manifold (creando uno nuevo) de acuerdo con cualquier función de entrada arbitraria. Es fácil crear una función que deforme un objeto geométricamente válido en uno que se superpone, pero eso no se verifica aquí, por lo que depende del usuario elegir su función con discreción.",
    "warpFunc": "función de deformación",
    "(vert: Base.Vector3) => void": "(vert: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "estado",
    "status": "estado",
    "bitbybit.manifold.manifold.evaluate.status_description": "Devuelve la razón por la que una Malla de entrada produce un Manifold vacío. Este Estado se mantendrá a través de operaciones como la propagación de NaN, asegurando que una malla con errores no se pierda misteriosamente. Las mallas vacías aún pueden mostrar NoError, por ejemplo, la intersección de mallas que no se superponen.",
    "bitbybit.manifold.crossSection.transforms.warp": "deformar",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Mueve los vértices de esta Sección Transversal (creando una nueva) de acuerdo con cualquier función de entrada arbitraria, seguida de una operación de unión (con una regla de relleno Positiva) que asegura que cualquier intersección introducida no se incluya en el resultado.",
    "(vert: Base.Vector2) => void": "(vert: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "redondear y eliminar ceros finales",
    "roundAndRemoveTrailingZeros": "redondear y eliminar ceros finales",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Redondea un número a los decimales especificados y elimina los ceros finales. Ejemplo: 1.32156 con 3 decimales devuelve 1.322, pero 1.320000001 devuelve 1.32, y 1.000 devuelve 1",
    "bitbybit.math.clamp": "restringir (clamp)",
    "clamp": "restringir (clamp)",
    "bitbybit.math.clamp_description": "Restringe un valor entre un mínimo y un máximo. Ejemplo: clamp(5, 0, 3) devuelve 3, clamp(-1, 0, 3) devuelve 0, clamp(1.5, 0, 3) devuelve 1.5",
    "bitbybit.math.lerp": "lerp",
    "bitbybit.math.lerp_description": "Interpolación lineal entre dos valores usando el parámetro t (0 a 1). Ejemplo: De 0 a 100 en t=0.5 → 50, De 10 a 20 en t=0.25 → 12.5. Cuando t=0 devuelve inicio, cuando t=1 devuelve fin. Útil para transiciones suaves.",
    "t": "t",
    "bitbybit.math.inverseLerp": "lerp inverso",
    "inverseLerp": "lerp inverso",
    "bitbybit.math.inverseLerp_description": "Calcula el parámetro de interpolación t para un valor entre inicio y fin (inverso de lerp). Ejemplo: Valor 5 en rango [0,10] → t=0.5, Valor 2.5 en rango [0,10] → t=0.25. Devuelve qué valor t produciría el valor dado en un lerp. Útil para encontrar la posición relativa.",
    "bitbybit.math.smoothstep": "paso suave (smoothstep)",
    "smoothstep": "paso suave (smoothstep)",
    "bitbybit.math.smoothstep_description": "Interpolación Hermite con aceleración y desaceleración suaves (más suave que lerp lineal). Ejemplo: x=0 → 0, x=0.5 → 0.5, x=1 → 1 (pero con curva S suave en el medio). La entrada se restringe automáticamente a [0,1]. La salida entra y sale suavemente. Genial para animaciones.",
    "bitbybit.math.sign": "signo",
    "sign": "signo",
    "bitbybit.math.sign_description": "Devuelve el signo de un número: -1 para negativo, 0 para cero, 1 para positivo. Ejemplo: -5 → -1, 0 → 0, 3.14 → 1. Útil para determinar dirección o polaridad.",
    "bitbybit.math.fract": "parte fraccionaria",
    "fract": "parte fraccionaria",
    "bitbybit.math.fract_description": "Devuelve la parte fraccionaria de un número (elimina la parte entera, mantiene decimales). Ejemplo: 3.14 → 0.14, 5.9 → 0.9, -2.3 → 0.7. Útil para envolver valores y crear patrones repetitivos.",
    "bitbybit.math.wrap": "envolver",
    "bitbybit.math.wrap_description": "Envuelve un número dentro de un rango especificado (crea un ciclo repetitivo). Ejemplo: 1.5 en rango [0,1) → 0.5, -0.3 en rango [0,1) → 0.7, 370° en rango [0,360) → 10°. Útil para ángulos, UVs o cualquier dominio repetitivo. Como el módulo pero maneja los negativos correctamente.",
    "bitbybit.math.pingPong": "ping pong",
    "pingPong": "ping pong",
    "bitbybit.math.pingPong_description": "Crea un efecto de ping-pong (ida y vuelta) que rebota un valor entre 0 y la longitud. El valor va de 0→longitud, luego de vuelta longitud→0, repitiendo este ciclo. Ejemplo: Con longitud=1: t=0→0, t=0.5→0.5, t=1→1 (pico), t=1.5→0.5, t=2→0, t=2.5→0.5 (repite). Útil para crear animaciones de rebote como una pelota o movimiento oscilante.",
    "bitbybit.math.moveTowards": "mover hacia",
    "moveTowards": "mover hacia",
    "bitbybit.math.moveTowards_description": "Mueve un valor hacia un objetivo por una cantidad delta máxima (sin sobrepasar). Ejemplo: De 0 hacia 10 por máx 3 → 3, De 8 hacia 10 por máx 3 → 10 (alcanzado). Útil para movimiento suave con límites de velocidad máxima.",
    "current": "actual",
    "maxDelta": "delta máx",
    "bitbybit.lists.getFirstItem": "obtener primer elemento",
    "getFirstItem": "obtener primer elemento",
    "bitbybit.lists.getFirstItem_description": "Obtiene el primer elemento de la lista. Ejemplo: De [10, 20, 30, 40], devuelve 10",
    "bitbybit.lists.getLastItem": "obtener último elemento",
    "getLastItem": "obtener último elemento",
    "bitbybit.lists.getLastItem_description": "Obtiene el último elemento de la lista. Ejemplo: De [10, 20, 30, 40], devuelve 40",
    "bitbybit.lists.shuffle": "mezclar",
    "shuffle": "mezclar",
    "bitbybit.lists.shuffle_description": "Reorganiza aleatoriamente todos los elementos de la lista (usando el algoritmo Fisher-Yates). Ejemplo: De [1, 2, 3, 4, 5], podría devolver [3, 1, 5, 2, 4] (el orden varía cada vez)",
    "bitbybit.lists.includes": "incluye",
    "includes": "incluye",
    "bitbybit.lists.includes_description": "Comprueba si la lista contiene un elemento específico. Ejemplo: Lista [10, 20, 30, 40] con elemento 30 devuelve true, con elemento 50 devuelve false",
    "bitbybit.lists.findIndex": "encontrar índice",
    "findIndex": "encontrar índice",
    "bitbybit.lists.findIndex_description": "Encuentra la posición (índice) de la primera aparición de un elemento en la lista. Ejemplo: En [10, 20, 30, 20, 40], encontrar 20 devuelve 1 (primera aparición), encontrar 50 devuelve -1 (no encontrado)",
    "bitbybit.lists.removeFirstItem": "eliminar primer elemento",
    "removeFirstItem": "eliminar primer elemento",
    "bitbybit.lists.removeFirstItem_description": "Elimina el primer elemento de la lista. Ejemplo: De [10, 20, 30, 40], devuelve [20, 30, 40]",
    "bitbybit.lists.removeLastItem": "eliminar último elemento",
    "removeLastItem": "eliminar último elemento",
    "bitbybit.lists.removeLastItem_description": "Elimina el último elemento de la lista. Ejemplo: De [10, 20, 30, 40], devuelve [10, 20, 30]",
    "bitbybit.lists.removeItemAtIndexFromEnd": "eliminar elemento en índice desde el final",
    "removeItemAtIndexFromEnd": "eliminar elemento en índice desde el final",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Elimina un elemento contando desde el final de la lista (índice 0 = último elemento, 1 = penúltimo, etc.). Ejemplo: De [10, 20, 30, 40, 50], eliminar índice 1 desde el final da [10, 20, 30, 50] (elimina 40)",
    "bitbybit.lists.removeDuplicates": "eliminar duplicados",
    "removeDuplicates": "eliminar duplicados",
    "bitbybit.lists.removeDuplicates_description": "Elimina elementos duplicados de la lista usando comparación de igualdad estricta (funciona con cualquier tipo). Ejemplo: De ['a', 'b', 'c', 'a', 'd', 'b'], devuelve ['a', 'b', 'c', 'd']",
    "bitbybit.lists.concatenate": "concatenar",
    "concatenate": "concatenar",
    "bitbybit.lists.concatenate_description": "Combina múltiples listas en una sola lista uniéndolas de extremo a extremo. Ejemplo: De [[1, 2], [3, 4], [5, 6]], devuelve [1, 2, 3, 4, 5, 6]",
    "bitbybit.lists.interleave": "intercalar",
    "interleave": "intercalar",
    "bitbybit.lists.interleave_description": "Combina múltiples listas alternando elementos de cada lista (primero de lista1, primero de lista2, segundo de lista1, etc.). Ejemplo: De [[0, 1, 2], [3, 4, 5]], devuelve [0, 3, 1, 4, 2, 5]",
    "bitbybit.text.includes": "incluye",
    "bitbybit.text.includes_description": "Comprueba si el texto contiene una cadena de búsqueda. Ejemplo: texto='hola mundo', búsqueda='mundo' → true",
    "bitbybit.text.startsWith": "empieza con",
    "startsWith": "empieza con",
    "bitbybit.text.startsWith_description": "Comprueba si el texto empieza con una cadena de búsqueda. Ejemplo: texto='hola mundo', búsqueda='hola' → true",
    "bitbybit.text.endsWith": "termina con",
    "endsWith": "termina con",
    "bitbybit.text.endsWith_description": "Comprueba si el texto termina con una cadena de búsqueda. Ejemplo: texto='hola mundo', búsqueda='mundo' → true",
    "bitbybit.text.indexOf": "índice de",
    "indexOf": "índice de",
    "bitbybit.text.indexOf_description": "Devuelve el índice de la primera aparición de una cadena de búsqueda. Ejemplo: texto='hola mundo', búsqueda='mundo' → 5",
    "bitbybit.text.lastIndexOf": "último índice de",
    "lastIndexOf": "último índice de",
    "bitbybit.text.lastIndexOf_description": "Devuelve el índice de la última aparición de una cadena de búsqueda. Ejemplo: texto='hola mundo hola', búsqueda='hola' → 11",
    "bitbybit.text.substring": "subcadena",
    "substring": "subcadena",
    "bitbybit.text.substring_description": "Extrae una sección de texto entre dos índices. Ejemplo: texto='hola mundo', inicio=0, fin=4 → 'hola'",
    "bitbybit.text.slice": "cortar",
    "bitbybit.text.slice_description": "Extrae una sección de texto y devuelve una nueva cadena. Ejemplo: texto='hola mundo', inicio=0, fin=4 → 'hola'",
    "bitbybit.text.charAt": "carácter en",
    "charAt": "carácter en",
    "bitbybit.text.charAt_description": "Devuelve el carácter en el índice especificado. Ejemplo: texto='hola', índice=1 → 'o'",
    "bitbybit.text.trim": "recortar espacios",
    "bitbybit.text.trim_description": "Elimina espacios en blanco de ambos extremos del texto. Ejemplo: texto='  hola  ' → 'hola'",
    "bitbybit.text.trimStart": "recortar inicio",
    "trimStart": "recortar inicio",
    "bitbybit.text.trimStart_description": "Elimina espacios en blanco del inicio del texto. Ejemplo: texto='  hola  ' → 'hola  '",
    "bitbybit.text.trimEnd": "recortar final",
    "trimEnd": "recortar final",
    "bitbybit.text.trimEnd_description": "Elimina espacios en blanco del final del texto. Ejemplo: texto='  hola  ' → '  hola'",
    "bitbybit.text.padStart": "rellenar inicio",
    "padStart": "rellenar inicio",
    "bitbybit.text.padStart_description": "Rellena el texto desde el inicio para alcanzar la longitud objetivo. Ejemplo: texto='x', longitud=3, cadenaRelleno='a' → 'aax'",
    "padString": "cadena de relleno",
    "bitbybit.text.padEnd": "rellenar final",
    "padEnd": "rellenar final",
    "bitbybit.text.padEnd_description": "Rellena el texto desde el final para alcanzar la longitud objetivo. Ejemplo: texto='x', longitud=3, cadenaRelleno='a' → 'xaa'",
    "bitbybit.text.toUpperCase": "a mayúsculas",
    "toUpperCase": "a mayúsculas",
    "bitbybit.text.toUpperCase_description": "Convierte texto a mayúsculas. Ejemplo: texto='hola' → 'HOLA'",
    "bitbybit.text.toLowerCase": "a minúsculas",
    "toLowerCase": "a minúsculas",
    "bitbybit.text.toLowerCase_description": "Convierte texto a minúsculas. Ejemplo: texto='HOLA' → 'hola'",
    "bitbybit.text.toUpperCaseFirst": "mayúscula inicial",
    "toUpperCaseFirst": "mayúscula inicial",
    "bitbybit.text.toUpperCaseFirst_description": "Pone en mayúscula el primer carácter del texto. Ejemplo: texto='hola mundo' → 'Hola mundo'",
    "bitbybit.text.toLowerCaseFirst": "minúscula inicial",
    "toLowerCaseFirst": "minúscula inicial",
    "bitbybit.text.toLowerCaseFirst_description": "Pone en minúscula el primer carácter del texto. Ejemplo: texto='Hola Mundo' → 'hola Mundo'",
    "bitbybit.text.repeat": "repetir",
    "bitbybit.text.repeat_description": "Repite el texto un número especificado de veces. Ejemplo: texto='ja', cuenta=3 → 'jajaja'",
    "bitbybit.text.reverse": "invertir",
    "bitbybit.text.reverse_description": "Invierte los caracteres en el texto. Ejemplo: texto='hola' → 'aloh'",
    "bitbybit.text.length": "longitud",
    "bitbybit.text.length_description": "Devuelve la longitud del texto. Ejemplo: texto='hola' → 4",
    "bitbybit.text.isEmpty": "está vacío",
    "bitbybit.text.isEmpty_description": "Comprueba si el texto está vacío o son solo espacios en blanco. Ejemplo: texto='   ' → true",
    "bitbybit.text.concat": "concatenar",
    "concat": "concatenar",
    "bitbybit.text.concat_description": "Concatena múltiples cadenas de texto. Ejemplo: textos=['hola', ' ', 'mundo'] → 'hola mundo'",
    "texts": "textos",
    "bitbybit.text.regexTest": "test regex",
    "regexTest": "test regex",
    "bitbybit.text.regexTest_description": "Prueba si el texto coincide con un patrón de expresión regular. Ejemplo: texto='hola123', patrón='[0-9]+' → true",
    "regex": "regex",
    "flags": "flags",
    "bitbybit.text.regexMatch": "coincidencia regex",
    "regexMatch": "coincidencia regex",
    "bitbybit.text.regexMatch_description": "Coincide el texto con una expresión regular y devuelve las coincidencias. Ejemplo: texto='hola123mundo456', patrón='[0-9]+', flags='g' → ['123', '456']",
    "bitbybit.text.regexReplace": "reemplazo regex",
    "regexReplace": "reemplazo regex",
    "bitbybit.text.regexReplace_description": "Reemplaza el texto que coincide con un patrón de expresión regular. Ejemplo: texto='hola123mundo456', patrón='[0-9]+', flags='g', reemplazarCon='X' → 'holaXmundoX'",
    "bitbybit.text.regexSearch": "búsqueda regex",
    "regexSearch": "búsqueda regex",
    "bitbybit.text.regexSearch_description": "Busca en el texto un patrón de expresión regular y devuelve el índice. Ejemplo: texto='hola123', patrón='[0-9]+' → 4",
    "bitbybit.text.regexSplit": "división regex",
    "regexSplit": "división regex",
    "bitbybit.text.regexSplit_description": "Divide el texto usando un patrón de expresión regular. Ejemplo: texto='a1b2c3', patrón='[0-9]+' → ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "analizar a array",
    "csv": "csv",
    "parseToArray": "analizar a array",
    "bitbybit.csv.parseToArray_description": "Analiza texto CSV a un array 2D de cadenas (filas y columnas). Ejemplo: csv='a,b,c 1,2,3' → [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "separador de filas",
    "columnSeparator": "separador de columnas",
    "bitbybit.csv.parseToJson": "analizar a json",
    "parseToJson": "analizar a json",
    "bitbybit.csv.parseToJson_description": "Analiza texto CSV a un array de objetos JSON usando encabezados. Ejemplo: csv='nombre,edad Juan,30 Ana,25', filaEncabezado=0, filaInicioDatos=1 → [{'nombre':'Juan','edad':'30'}, {'nombre':'Ana','edad':'25'}]",
    "headerRow": "fila de encabezado",
    "dataStartRow": "fila de inicio de datos",
    "numberColumns": "columnas numéricas",
    "bitbybit.csv.parseToJsonWithHeaders": "analizar a json con encabezados",
    "parseToJsonWithHeaders": "analizar a json con encabezados",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Analiza texto CSV a JSON usando encabezados personalizados (ignora los encabezados CSV si están presentes). Ejemplo: csv='Juan,30 Ana,25', encabezados=['nombre','edad'] → [{'nombre':'Juan','edad':'30'}, {'nombre':'Ana','edad':'25'}]",
    "headers": "encabezados",
    "bitbybit.csv.queryColumn": "consultar columna",
    "queryColumn": "consultar columna",
    "bitbybit.csv.queryColumn_description": "Consulta datos CSV por nombre de encabezado de columna y devuelve todos los valores en esa columna. Ejemplo: csv='nombre,edad Juan,30 Ana,25', columna='nombre' → ['Juan', 'Ana']",
    "column": "columna",
    "asNumber": "como número",
    "bitbybit.csv.queryRowsByValue": "consultar filas por valor",
    "queryRowsByValue": "consultar filas por valor",
    "bitbybit.csv.queryRowsByValue_description": "Consulta datos CSV y filtra filas donde una columna coincide con un valor. Ejemplo: csv='nombre,edad Juan,30 Ana,25', columna='edad', valor='30' → [{'nombre':'Juan','edad':'30'}]",
    "bitbybit.csv.arrayToCsv": "array a csv",
    "arrayToCsv": "array a csv",
    "bitbybit.csv.arrayToCsv_description": "Convierte un array 2D a texto CSV. Ejemplo: array=[['nombre','edad'], ['Juan','30']] → 'nombre,edad Juan,30'",
    "array": "array",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "json a csv",
    "jsonToCsv": "json a csv",
    "bitbybit.csv.jsonToCsv_description": "Convierte un array de objetos JSON a texto CSV. Ejemplo: json=[{'nombre':'Juan','edad':'30'}], encabezados=['nombre','edad'] → 'nombre,edad Juan,30'",
    "includeHeaders": "incluir encabezados",
    "bitbybit.csv.jsonToCsvAuto": "json a csv auto",
    "jsonToCsvAuto": "json a csv auto",
    "bitbybit.csv.jsonToCsvAuto_description": "Convierte un array de objetos JSON a texto CSV usando las claves de objeto como encabezados. Ejemplo: json=[{'nombre':'Juan','edad':'30'}] → 'nombre,edad Juan,30'",
    "bitbybit.csv.getHeaders": "obtener encabezados",
    "getHeaders": "obtener encabezados",
    "bitbybit.csv.getHeaders_description": "Obtiene los encabezados de un archivo CSV. Ejemplo: csv='nombre,edad Juan,30', filaEncabezado=0 → ['nombre', 'edad']",
    "bitbybit.csv.getRowCount": "obtener recuento de filas",
    "getRowCount": "obtener recuento de filas",
    "bitbybit.csv.getRowCount_description": "Obtiene el número de filas en un archivo CSV (excluyendo encabezados si se especifica). Ejemplo: csv='nombre,edad Juan,30 Ana,25', filaEncabezado=0 → 2",
    "hasHeaders": "tiene encabezados",
    "bitbybit.csv.getColumnCount": "obtener recuento de columnas",
    "getColumnCount": "obtener recuento de columnas",
    "bitbybit.csv.getColumnCount_description": "Obtiene el número de columnas en un archivo CSV. Ejemplo: csv='nombre,edad,ciudad Juan,30,NYC' → 3",
    "removeTrailingZeros": "eliminar ceros finales",
    "bitbybit.asset.getTextFile": "obtener archivo de texto",
    "getTextFile": "obtener archivo de texto",
    "bitbybit.asset.getTextFile_description": "Obtiene el texto del archivo de recursos almacenado en su cuenta en la nube.",
    "bitbybit.asset.getLocalTextFile": "obtener archivo de texto local",
    "getLocalTextFile": "obtener archivo de texto local",
    "bitbybit.asset.getLocalTextFile_description": "Obtiene el texto del archivo de recursos almacenado en su navegador.",
    "bitbybit.asset.download": "descargar",
    "bitbybit.asset.download_description": "Descarga un archivo con el contenido, extensión y tipo de contenido dados.",
    "content": "contenido",
    "string | Blob": "string | Blob",
    "extension": "extensión",
    "contentType": "tipo de contenido",
    "preview csv": "previsualizar csv",
    "startRow": "fila de inicio",
    "maxRows": "máximo de filas"
}