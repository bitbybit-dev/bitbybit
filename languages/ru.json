{
    "bitbybit.draw.drawAnyAsyncNoReturn": "Нарисовать любое асинхронно без возврата",
    "bitbybit": "bitbybit",
    "draw": "Рисование",
    "drawAnyAsyncNoReturn": "Нарисовать любое асинхронно без возврата",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Рисует любой вид геометрии и ничего не возвращает",
    "draw async": "Нарисовать асинхронно",
    "entity": "Объект",
    "Entity": "Объект",
    "options": "Параметры",
    "DrawOptions": "Параметры рисования",
    "babylonMesh": "Меш Babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "Меш Babylon или меш линий Babylon",
    "bitbybit.draw.drawAnyAsync": "Нарисовать любое асинхронно",
    "drawAnyAsync": "Нарисовать любое асинхронно",
    "bitbybit.draw.drawAnyAsync_description": "Рисует любой вид геометрии и возвращает сетку babylon",
    "bitbybit.draw.drawAnyNoReturn": "Нарисовать любое без возврата",
    "drawAnyNoReturn": "Нарисовать любое без возврата",
    "bitbybit.draw.drawAnyNoReturn_description": "Рисует любой вид геометрии, который не требует асинхронных вычислений, поэтому его нельзя использовать с фигурами из occt или jscad",
    "draw sync": "Нарисовать синхронно",
    "bitbybit.draw.drawAny": "Нарисовать любое",
    "drawAny": "Нарисовать любое",
    "bitbybit.draw.drawAny_description": "Рисует любой вид геометрии, который не требует асинхронных вычислений, поэтому его нельзя использовать с фигурами из occt или jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "Нарисовать сетку (меш) без возврата",
    "drawGridMeshNoReturn": "Нарисовать сетку (меш) без возврата",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Рисует сетку на плоскости земли в 3D пространстве. Это помогает ориентироваться в мире.",
    "grid": "Сетка",
    "width": "Ширина",
    "number": "Число",
    "height": "Высота",
    "subdivisions": "Подразделения",
    "majorUnitFrequency": "Частота главных линий",
    "minorUnitVisibility": "Видимость вспомогательных линий",
    "gridRatio": "Коэффициент сетки",
    "opacity": "Непрозрачность",
    "backFaceCulling": "Отсечение обратных граней",
    "boolean": "Логический",
    "mainColor": "Основной цвет",
    "Base.Color": "Базовый цвет",
    "secondaryColor": "Вторичный цвет",
    "bitbybit.draw.drawGridMesh": "Нарисовать сетку (меш)",
    "drawGridMesh": "Нарисовать сетку (меш)",
    "bitbybit.draw.drawGridMesh_description": "Рисует сетку на плоскости земли в 3D пространстве. Это помогает ориентироваться в мире.",
    "bitbybit.draw.optionsSimple": "Простые параметры",
    "optionsSimple": "Простые параметры",
    "bitbybit.draw.optionsSimple_description": "Создает опции рисования для базовых типов геометрии, таких как точки, линии, полилинии, поверхности и сетки jscad",
    "colours": "Цвета",
    "string | string[]": "Строка | массив строк",
    "size": "Размер",
    "updatable": "Обновляемый",
    "hidden": "Скрытый",
    "bitbybit.draw.optionsOcctShape": "Параметры формы OCCT",
    "optionsOcctShape": "Параметры формы OCCT",
    "bitbybit.draw.optionsOcctShape_description": "Создает опции рисования для геометрии формы occt, такой как ребра, проволоки, грани, оболочки, твердые тела и составные фигуры",
    "faceOpacity": "Непрозрачность грани",
    "edgeOpacity": "Непрозрачность ребра",
    "edgeColour": "Цвет ребра",
    "faceColour": "Цвет грани",
    "vertexColour": "Цвет вершины",
    "faceMaterial": "Материал грани",
    "Base.Material": "Базовый материал",
    "edgeWidth": "Ширина ребра",
    "vertexSize": "Размер вершины",
    "drawEdges": "Рисовать рёбра",
    "drawFaces": "Рисовать грани",
    "drawVertices": "Рисовать вершины",
    "precision": "Точность",
    "drawEdgeIndexes": "Рисовать индексы рёбер",
    "edgeIndexHeight": "Высота индекса ребра",
    "edgeIndexColour": "Цвет индекса ребра",
    "drawFaceIndexes": "Рисовать индексы граней",
    "faceIndexHeight": "Высота индекса грани",
    "faceIndexColour": "Цвет индекса грани",
    "bitbybit.draw.optionsOcctShapeSimple": "Простые параметры формы OCCT",
    "optionsOcctShapeSimple": "Простые параметры формы OCCT",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Создает простые опции рисования для геометрии формы occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "Параметры материала формы OCCT",
    "optionsOcctShapeMaterial": "Параметры материала формы OCCT",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Создает простые опции рисования с пользовательским материалом грани для геометрии формы occt",
    "any": "Любой",
    "bitbybit.draw.optionsManifoldShapeMaterial": "Параметры материала геометрии Manifold",
    "optionsManifoldShapeMaterial": "Параметры материала геометрии Manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Создает опции рисования для геометрии manifold",
    "crossSectionColour": "Цвет поперечного сечения",
    "crossSectionWidth": "Ширина поперечного сечения",
    "crossSectionOpacity": "Непрозрачность поперечного сечения",
    "computeNormals": "Вычислить нормали",
    "bitbybit.draw.optionsBabylonNode": "Параметры узла Babylon",
    "optionsBabylonNode": "Параметры узла Babylon",
    "bitbybit.draw.optionsBabylonNode_description": "Создает опции рисования для узлов babylon js",
    "colorX": "Цвет X",
    "colorY": "Цвет Y",
    "colorZ": "Цвет Z",
    "bitbybit.babylon.mesh.dispose": "Удалить меш",
    "babylon": "Babylon",
    "mesh": "Меш",
    "dispose": "Удалить",
    "bitbybit.babylon.mesh.dispose_description": "Удаляет отрисованный объект сетки со сцены",
    "memory": "Память",
    "BABYLON.Mesh": "Меш Babylon",
    "bitbybit.babylon.mesh.updateDrawn": "Обновить нарисованное",
    "updateDrawn": "Обновить нарисованное",
    "bitbybit.babylon.mesh.updateDrawn_description": "Обновляет отрисованный объект сетки BabylonJS без его удаления",
    "updates": "Обновления",
    "position": "Позиция",
    "Base.Point3": "Базовая точка 3",
    "rotation": "Вращение",
    "Base.Vector3": "Базовый вектор 3",
    "scaling": "Масштабирование",
    "bitbybit.babylon.mesh.setVisibility": "Установить видимость",
    "setVisibility": "Установить видимость",
    "bitbybit.babylon.mesh.setVisibility_description": "Изменяет видимость отрисованной сетки BabylonJS",
    "visibility": "Видимость",
    "includeChildren": "Включая дочерние",
    "bitbybit.babylon.mesh.hide": "Скрыть",
    "hide": "Скрыть",
    "bitbybit.babylon.mesh.hide_description": "Скрывает меш",
    "bitbybit.babylon.mesh.show": "Показать",
    "show": "Показать",
    "bitbybit.babylon.mesh.show_description": "Показать сетку",
    "bitbybit.babylon.mesh.setParent": "Установить родителя",
    "setParent": "Установить родителя",
    "bitbybit.babylon.mesh.setParent_description": "Изменить родителя отрисованной сетки",
    "set": "Установить",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "Меш Babylon | Экземпляр меша Babylon | Абстрактный меш Babylon",
    "parentMesh": "Родительский меш",
    "bitbybit.babylon.mesh.getParent": "Получить родителя",
    "getParent": "Получить родителя",
    "bitbybit.babylon.mesh.getParent_description": "Получить родителя отрисованной сетки",
    "get": "Получить",
    "bitbybit.babylon.mesh.setCheckCollisions": "Установить проверку коллизий",
    "setCheckCollisions": "Установить проверку коллизий",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Изменить свойство проверки коллизий отрисованной сетки",
    "checkCollisions": "Проверка коллизий",
    "bitbybit.babylon.mesh.getCheckCollisions": "Получить проверку коллизий",
    "getCheckCollisions": "Получить проверку коллизий",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Получить свойство проверки коллизий отрисованной сетки",
    "bitbybit.babylon.mesh.setPickable": "Установить выбираемость",
    "setPickable": "Установить выбираемость",
    "bitbybit.babylon.mesh.setPickable_description": "Изменить свойство выбираемости отрисованной сетки",
    "pickable": "Выбираемый",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "Включить события движения указателя",
    "enablePointerMoveEvents": "Включить события движения указателя",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Принудительно сделать сетку выбираемой событиями перемещения указателя, по умолчанию false, так как это ресурсоемко",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "Отключить события движения указателя",
    "disablePointerMoveEvents": "Отключить события движения указателя",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Заставить сетку игнорировать события перемещения указателя, по умолчанию false",
    "bitbybit.babylon.mesh.getPickable": "Получить выбираемость",
    "getPickable": "Получить выбираемость",
    "bitbybit.babylon.mesh.getPickable_description": "Изменить свойство выбираемости отрисованной сетки",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "Получить меши, имя которых содержит",
    "getMeshesWhereNameContains": "Получить меши, имя которых содержит",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Получает сетки, имена которых содержат заданный текст",
    "name": "Имя",
    "string": "Строка",
    "bitbybit.babylon.mesh.getChildMeshes": "Получить дочерние меши",
    "getChildMeshes": "Получить дочерние меши",
    "bitbybit.babylon.mesh.getChildMeshes_description": "Получает дочерние меши",
    "directDescendantsOnly": "Только прямые потомки",
    "bitbybit.babylon.mesh.getMeshesOfId": "Получить меши по ID",
    "getMeshesOfId": "Получить меши по ID",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Получает сетки по id",
    "id": "ID",
    "bitbybit.babylon.mesh.getMeshOfId": "Получить меш по ID",
    "getMeshOfId": "Получить меш по ID",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Получает сетку по id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "Получить меш по уникальному ID",
    "getMeshOfUniqueId": "Получить меш по уникальному ID",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Получает сетку по уникальному id",
    "uniqueId": "Уникальный ID",
    "bitbybit.babylon.mesh.mergeMeshes": "Объединить меши",
    "mergeMeshes": "Объединить меши",
    "bitbybit.babylon.mesh.mergeMeshes_description": "Объединяет несколько мешей в один",
    "edit": "Редактирование",
    "arrayOfMeshes": "Массив мешей",
    "BABYLON.Mesh[]": "Массив мешей Babylon",
    "disposeSource": "Удалить источник",
    "allow32BitsIndices": "Разрешить 32-битные индексы",
    "meshSubclass": "Подкласс меша",
    "subdivideWithSubMeshes": "Разделить с подмешами",
    "multiMultiMaterials": "Множественные материалы",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "Преобразовать в меш с плоским затенением",
    "convertToFlatShadedMesh": "Преобразовать в меш с плоским затенением",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Преобразует сетку в сетку с плоским затенением",
    "bitbybit.babylon.mesh.clone": "Клонировать",
    "clone": "Клонировать",
    "bitbybit.babylon.mesh.clone_description": "Клонирует меш",
    "bitbybit.babylon.mesh.cloneToPositions": "Клонировать в позиции",
    "cloneToPositions": "Клонировать в позиции",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Клонирует сетку в позиции",
    "positions": "Позиции",
    "Base.Point3[]": "Массив базовых точек 3",
    "bitbybit.babylon.mesh.setId": "Установить ID",
    "setId": "Установить ID",
    "bitbybit.babylon.mesh.setId_description": "Изменить id отрисованной сетки",
    "bitbybit.babylon.mesh.getId": "Получить ID",
    "getId": "Получить ID",
    "bitbybit.babylon.mesh.getId_description": "Получить id отрисованной сетки",
    "bitbybit.babylon.mesh.getUniqueId": "Получить уникальный ID",
    "getUniqueId": "Получить уникальный ID",
    "bitbybit.babylon.mesh.getUniqueId_description": "Получить уникальный id отрисованной сетки",
    "bitbybit.babylon.mesh.setName": "Установить имя",
    "setName": "Установить имя",
    "bitbybit.babylon.mesh.setName_description": "Изменить имя отрисованной сетки",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "Получить вершины как точки полигона",
    "getVerticesAsPolygonPoints": "Получить вершины как точки полигона",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Получает вершины как точки полигона. Их можно использовать с другими методами построения для создания сеток. Сетка должна быть триангулирована.",
    "bitbybit.babylon.mesh.getName": "Получить имя",
    "getName": "Получить имя",
    "bitbybit.babylon.mesh.getName_description": "Получает имя сетки babylon",
    "bitbybit.babylon.mesh.setMaterial": "Установить материал",
    "setMaterial": "Установить материал",
    "bitbybit.babylon.mesh.setMaterial_description": "Изменить материал отрисованной сетки",
    "material": "Материал",
    "BABYLON.Material": "Материал Babylon",
    "bitbybit.babylon.mesh.getMaterial": "Получить материал",
    "getMaterial": "Получить материал",
    "bitbybit.babylon.mesh.getMaterial_description": "Получает материал сетки babylon",
    "bitbybit.babylon.mesh.getPosition": "Получить позицию",
    "getPosition": "Получить позицию",
    "bitbybit.babylon.mesh.getPosition_description": "Получает позицию как точку сетки babylonjs",
    "bitbybit.babylon.mesh.getAbsolutePosition": "Получить абсолютную позицию",
    "getAbsolutePosition": "Получить абсолютную позицию",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Получает абсолютную позицию в мире как точку сетки babylonjs",
    "bitbybit.babylon.mesh.getRotation": "Получить вращение",
    "getRotation": "Получить вращение",
    "bitbybit.babylon.mesh.getRotation_description": "Получает вектор вращения сетки babylonjs",
    "bitbybit.babylon.mesh.getScale": "Получить масштаб",
    "getScale": "Получить масштаб",
    "bitbybit.babylon.mesh.getScale_description": "Получает вектор масштаба сетки babylonjs",
    "bitbybit.babylon.mesh.moveForward": "Двигаться вперёд",
    "moveForward": "Двигаться вперёд",
    "bitbybit.babylon.mesh.moveForward_description": "Перемещает сетку babylonjs вперед в локальном пространстве",
    "move": "Перемещение",
    "distance": "Расстояние",
    "bitbybit.babylon.mesh.moveBackward": "Двигаться назад",
    "moveBackward": "Двигаться назад",
    "bitbybit.babylon.mesh.moveBackward_description": "Перемещает сетку babylonjs назад в локальном пространстве",
    "bitbybit.babylon.mesh.moveUp": "Двигаться вверх",
    "moveUp": "Двигаться вверх",
    "bitbybit.babylon.mesh.moveUp_description": "Перемещает сетку babylonjs вверх в локальном пространстве",
    "bitbybit.babylon.mesh.moveDown": "Двигаться вниз",
    "moveDown": "Двигаться вниз",
    "bitbybit.babylon.mesh.moveDown_description": "Перемещает сетку babylonjs вниз в локальном пространстве",
    "bitbybit.babylon.mesh.moveRight": "Двигаться вправо",
    "moveRight": "Двигаться вправо",
    "bitbybit.babylon.mesh.moveRight_description": "Перемещает сетку babylonjs вправо в локальном пространстве",
    "bitbybit.babylon.mesh.moveLeft": "Двигаться влево",
    "moveLeft": "Двигаться влево",
    "bitbybit.babylon.mesh.moveLeft_description": "Перемещает сетку babylonjs влево в локальном пространстве",
    "bitbybit.babylon.mesh.yaw": "Рыскание",
    "yaw": "Рыскание",
    "bitbybit.babylon.mesh.yaw_description": "Вращает сетку babylonjs вокруг локальной оси y",
    "rotate": "Вращать",
    "bitbybit.babylon.mesh.pitch": "Тангаж",
    "pitch": "Тангаж",
    "bitbybit.babylon.mesh.pitch_description": "Вращает сетку babylonjs вокруг локальной оси x",
    "bitbybit.babylon.mesh.roll": "Крен",
    "roll": "Крен",
    "bitbybit.babylon.mesh.roll_description": "Вращает сетку babylonjs вокруг локальной оси z",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "Вращать вокруг оси с позицией",
    "rotateAroundAxisWithPosition": "Вращать вокруг оси с позицией",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Вращает сетку вокруг оси и заданной позиции на заданный угол",
    "axis": "Ось",
    "angle": "Угол",
    "bitbybit.babylon.mesh.setPosition": "Установить позицию",
    "setPosition": "Установить позицию",
    "bitbybit.babylon.mesh.setPosition_description": "Обновляет позицию сетки BabylonJS или инстанцированной сетки",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "Меш Babylon | Экземпляр меша Babylon",
    "bitbybit.babylon.mesh.setRotation": "Установить вращение",
    "setRotation": "Установить вращение",
    "bitbybit.babylon.mesh.setRotation_description": "Обновляет вращение сетки BabylonJS или инстанцированной сетки",
    "bitbybit.babylon.mesh.setScale": "Установить масштаб",
    "setScale": "Установить масштаб",
    "bitbybit.babylon.mesh.setScale_description": "Обновляет масштаб сетки BabylonJS или инстанцированной сетки",
    "scale": "Масштаб",
    "bitbybit.babylon.mesh.intersectsMesh": "Пересекает меш",
    "intersectsMesh": "Пересекает меш",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Проверяет, пересекает ли сетка другую сетку",
    "intersects": "Пересечения",
    "babylonMesh2": "Меш Babylon 2",
    "precise": "Точный",
    "includeDescendants": "Включая потомков",
    "bitbybit.babylon.mesh.intersectsPoint": "Пересекает точку",
    "intersectsPoint": "Пересекает точку",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Проверяет, пересекает ли сетка точку",
    "point": "Точка",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "Экземпляр меша и трансформация без возврата",
    "createMeshInstanceAndTransformNoReturn": "Экземпляр меша и трансформация без возврата",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Создает экземпляр сетки для оптимизированного рендеринга. Этот метод проверит, содержит ли сетка детей, и создаст экземпляры для каждого ребенка. Они оптимизированы для максимальной производительности при рендеринге множества похожих объектов в сцене. Этот метод возвращает экземпляры как детей в новой сетке. Если у сетки есть дети, то каждый ребенок становится экземпляром сетки.",
    "instance": "Экземпляр",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "Экземпляр меша и трансформация",
    "createMeshInstanceAndTransform": "Экземпляр меша и трансформация",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Создает экземпляр сетки для оптимизированного рендеринга. Этот метод проверит, содержит ли сетка детей, и создаст экземпляры для каждого ребенка. Они оптимизированы для максимальной производительности при рендеринге множества похожих объектов в сцене. Этот метод возвращает экземпляры как детей в новой сетке. Если у сетки есть дети, то каждый ребенок становится экземпляром сетки.",
    "bitbybit.babylon.mesh.createMeshInstance": "Экземпляр меша",
    "createMeshInstance": "Экземпляр меша",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Создает экземпляр сетки. Они оптимизированы для максимальной производительности при рендеринге множества похожих объектов в сцене. Если у сетки есть дети, то каждый ребенок получает экземпляр сетки.",
    "bitbybit.babylon.gaussianSplatting.create": "Гауссово разбрызгивание",
    "gaussianSplatting": "Гауссово разбрызгивание",
    "create": "Создать",
    "bitbybit.babylon.gaussianSplatting.create_description": "Создает меш гауссова разбрызгивания",
    "url": "URL",
    "bitbybit.babylon.gaussianSplatting.clone": "Клонировать гауссово разбрызгивание",
    "bitbybit.babylon.gaussianSplatting.clone_description": "Клонирует меш гауссова разбрызгивания",
    "multiply": "Множитель",
    "BABYLON.GaussianSplattingMesh": "Меш гауссова разбрызгивания Babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "Получить позиции сплэтов",
    "getSplatPositions": "Получить позиции сплэтов",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Получает позиции сплэтов сетки gaussian splat",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "Заморозить матрицу проекции",
    "camera": "Камера",
    "freezeProjectionMatrix": "Заморозить матрицу проекции",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Заморозить матрицу проекции камеры",
    "adjust": "Настроить",
    "BABYLON.Camera": "Камера Babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "Разморозить матрицу проекции",
    "unfreezeProjectionMatrix": "Разморозить матрицу проекции",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Разморозить матрицу проекции камеры",
    "bitbybit.babylon.camera.setPosition": "Установить позицию",
    "bitbybit.babylon.camera.setPosition_description": "Изменяет позицию камеры",
    "BABYLON.TargetCamera": "Целевая камера Babylon",
    "bitbybit.babylon.camera.getPosition": "Получить позицию",
    "bitbybit.babylon.camera.getPosition_description": "Получает позицию камеры",
    "bitbybit.babylon.camera.setTarget": "Установить цель",
    "setTarget": "Установить цель",
    "bitbybit.babylon.camera.setTarget_description": "Изменяет цель камеры",
    "target": "Цель",
    "bitbybit.babylon.camera.getTarget": "Получить цель",
    "getTarget": "Получить цель",
    "bitbybit.babylon.camera.getTarget_description": "Получает цель камеры",
    "bitbybit.babylon.camera.setSpeed": "Установить скорость",
    "setSpeed": "Установить скорость",
    "bitbybit.babylon.camera.setSpeed_description": "Изменяет скорость камеры",
    "speed": "Скорость",
    "bitbybit.babylon.camera.getSpeed": "Получить скорость",
    "getSpeed": "Получить скорость",
    "bitbybit.babylon.camera.getSpeed_description": "Получает скорость камеры",
    "bitbybit.babylon.camera.setMinZ": "Установить мин Z",
    "setMinZ": "Установить мин Z",
    "bitbybit.babylon.camera.setMinZ_description": "Изменяет minZ камеры",
    "minZ": "Мин Z",
    "bitbybit.babylon.camera.setMaxZ": "Установить макс Z",
    "setMaxZ": "Установить макс Z",
    "bitbybit.babylon.camera.setMaxZ_description": "Изменяет maxZ камеры",
    "maxZ": "Макс Z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "Сделать камеру ортографической",
    "makeCameraOrthographic": "Сделать камеру ортографической",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Изменяет режим камеры на ортогональный",
    "orthoLeft": "Орто слева",
    "orthoRight": "Орто справа",
    "orthoBottom": "Орто снизу",
    "orthoTop": "Орто сверху",
    "bitbybit.babylon.camera.makeCameraPerspective": "Сделать камеру перспективной",
    "makeCameraPerspective": "Сделать камеру перспективной",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Изменяет режим камеры на перспективный",
    "bitbybit.babylon.camera.free.create": "Свободная камера",
    "free": "Свободная",
    "bitbybit.babylon.camera.free.create_description": "Создает свободную камеру",
    "bitbybit.babylon.camera.arcRotate.create": "Камера вращения по дуге",
    "arcRotate": "Вращение по дуге",
    "bitbybit.babylon.camera.arcRotate.create_description": "Создает камеру, которая вращается вокруг заданной цели, двигаясь по дуге. Эта камера подходит для простой 3D-навигации и является камерой по умолчанию, используемой bitbybit.",
    "radius": "Радиус",
    "alpha": "Альфа",
    "beta": "Бета",
    "lowerRadiusLimit": "Нижний предел радиуса",
    "upperRadiusLimit": "Верхний предел радиуса",
    "lowerAlphaLimit": "Нижний предел альфа",
    "upperAlphaLimit": "Верхний предел альфа",
    "lowerBetaLimit": "Нижний предел бета",
    "upperBetaLimit": "Верхний предел бета",
    "angularSensibilityX": "Угловая чувствительность X",
    "angularSensibilityY": "Угловая чувствительность Y",
    "panningSensibility": "Чувствительность панорамирования",
    "wheelPrecision": "Точность колеса (мыши)",
    "bitbybit.babylon.camera.target.create": "Целевая камера",
    "bitbybit.babylon.camera.target.create_description": "Создает целевую камеру",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "Иммерсивный опыт AR",
    "webXr": "WebXR",
    "simple": "Простой",
    "createImmersiveARExperience": "Создать иммерсивный опыт AR",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Создает стандартный XR опыт в режиме immersive-ar",
    "scene": "Сцена",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "Стандартный XR опыт с телепортацией",
    "createDefaultXRExperienceWithTeleportation": "Создать стандартный XR опыт с телепортацией",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Создает стандартный XR опыт с телепортацией, который очень прост и работает для простых сценариев",
    "groundMeshes": "Меши земли",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "Стандартный XR опыт с телепортацией (возврат)",
    "createDefaultXRExperienceWithTeleportationReturn": "Создать стандартный XR опыт с телепортацией (возврат)",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Создает стандартный XR опыт с телепортацией, который очень прост и работает для простых сценариев",
    "bitbybit.babylon.node.drawNode": "Нарисовать узел",
    "node": "Узел",
    "drawNode": "Нарисовать узел",
    "bitbybit.babylon.node.drawNode_description": "Рисует узел заданного размера с заданными цветами для каждой оси",
    "BABYLON.TransformNode": "Узел трансформации Babylon",
    "bitbybit.babylon.node.drawNodes": "Нарисовать узлы",
    "drawNodes": "Нарисовать узлы",
    "bitbybit.babylon.node.drawNodes_description": "Рисует узлы заданного размера с заданными цветами для каждой оси",
    "nodes": "Узлы",
    "BABYLON.TransformNode[]": "Массив узлов трансформации Babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "Узел из вращения",
    "createNodeFromRotation": "Создать узел из вращения",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Создает узел в начале координат с заданными вращениями в родительской системе координат",
    "parent": "Родитель",
    "BABYLON.TransformNode | null": "Узел трансформации Babylon | null",
    "origin": "Начало координат",
    "bitbybit.babylon.node.createWorldNode": "Мировой узел",
    "createWorldNode": "Создать мировой узел",
    "bitbybit.babylon.node.createWorldNode_description": "Создает мировой узел, родителем которого является корневой узел",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "Получить абсолютный вектор 'вперёд'",
    "getAbsoluteForwardVector": "Получить абсолютный вектор 'вперёд'",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Получает абсолютный вектор, направленный вперед в мировом пространстве",
    "bitbybit.babylon.node.getAbsoluteRightVector": "Получить абсолютный вектор 'вправо'",
    "getAbsoluteRightVector": "Получить абсолютный вектор 'вправо'",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Получает абсолютный вектор, направленный вправо в мировом пространстве",
    "bitbybit.babylon.node.getAbsoluteUpVector": "Получить абсолютный вектор 'вверх'",
    "getAbsoluteUpVector": "Получить абсолютный вектор 'вверх'",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Получает абсолютный вектор, направленный вверх в мировом пространстве",
    "bitbybit.babylon.node.getAbsolutePosition": "Получить абсолютную позицию",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Получает абсолютную позицию узла как вектор начала координат в мировом пространстве",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "Получить абсолютное преобразование вращения",
    "getAbsoluteRotationTransformation": "Получить абсолютное преобразование вращения",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Получает абсолютное вращение узла как матрицу трансформации, закодированную в массиве из 16 чисел",
    "bitbybit.babylon.node.getRotationTransformation": "Получить преобразование вращения",
    "getRotationTransformation": "Получить преобразование вращения",
    "bitbybit.babylon.node.getRotationTransformation_description": "Получает вращение узла в локальном родительском координатном пространстве как матрицу трансформации, закодированную в массиве из 16 чисел",
    "bitbybit.babylon.node.getChildren": "Получить дочерние элементы",
    "getChildren": "Получить дочерние элементы",
    "bitbybit.babylon.node.getChildren_description": "Получает дочерние элементы узла",
    "bitbybit.babylon.node.getParent": "Получить родителя",
    "bitbybit.babylon.node.getParent_description": "Получает родителя узла",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "Получить позицию в локальном пространстве",
    "getPositionExpressedInLocalSpace": "Получить позицию в локальном пространстве",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Получает позицию узла, выраженную в локальном пространстве",
    "bitbybit.babylon.node.getRootNode": "Получить корневой узел",
    "getRootNode": "Получить корневой узел",
    "bitbybit.babylon.node.getRootNode_description": "Получает корневой узел",
    "bitbybit.babylon.node.getRotation": "Получить вращение",
    "bitbybit.babylon.node.getRotation_description": "Получает углы Эйлера",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "Вращать вокруг оси с позицией",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Вращает узел вокруг оси и заданной позиции на заданный угол",
    "bitbybit.babylon.node.rotate": "Вращать",
    "bitbybit.babylon.node.rotate_description": "Вращает узел вокруг начала координат и заданной оси",
    "bitbybit.babylon.node.setAbsolutePosition": "Установить абсолютную позицию",
    "setAbsolutePosition": "Установить абсолютную позицию",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Устанавливает абсолютную позицию узла",
    "bitbybit.babylon.node.setDirection": "Установить направление",
    "setDirection": "Установить направление",
    "bitbybit.babylon.node.setDirection_description": "Устанавливает направление узла",
    "direction": "Направление",
    "number[]": "Массив чисел",
    "bitbybit.babylon.node.setParent": "Установить родителя",
    "bitbybit.babylon.node.setParent_description": "Устанавливает нового родителя для узла",
    "parentNode": "Родительский узел",
    "bitbybit.babylon.node.translate": "Переместить",
    "translate": "Переместить",
    "bitbybit.babylon.node.translate_description": "Смещает узел на заданный вектор направления и расстояние",
    "bitbybit.babylon.scene.backgroundColour": "Цвет фона",
    "backgroundColour": "Цвет фона",
    "bitbybit.babylon.scene.backgroundColour_description": "Изменяет цвет фона сцены для 3D пространства",
    "environment": "Окружение",
    "colour": "Цвет",
    "bitbybit.babylon.scene.activateCamera": "Активировать камеру",
    "activateCamera": "Активировать камеру",
    "bitbybit.babylon.scene.activateCamera_description": "Активировать камеру, перезаписав текущую активную камеру",
    "bitbybit.babylon.scene.useRightHandedSystem": "Использовать правостороннюю систему",
    "useRightHandedSystem": "Использовать правостороннюю систему",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Использовать правостороннюю систему",
    "system": "Система",
    "use": "Использовать",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "Нарисовать точечный свет без возврата",
    "drawPointLightNoReturn": "Нарисовать точечный свет без возврата",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Создает и рисует точечный свет в сцене, но ничего не выводит",
    "lights": "Источники света",
    "intensity": "Интенсивность",
    "diffuse": "Диффузный",
    "specular": "Бликовый",
    "shadowGeneratorMapSize": "Размер карты генератора теней",
    "enableShadows": "Включить тени",
    "shadowDarkness": "Темнота тени",
    "shadowUsePercentageCloserFiltering": "Тень: использовать процентное сглаживание (PCF)",
    "shadowContactHardeningLightSizeUVRatio": "Тень: коэфф. UV размера света для контактного упрочнения",
    "shadowBias": "Смещение тени",
    "shadowNormalBias": "Смещение тени по нормали",
    "shadowMaxZ": "Тень макс Z",
    "shadowMinZ": "Тень мин Z",
    "bitbybit.babylon.scene.getShadowGenerators": "Получить генераторы теней",
    "getShadowGenerators": "Получить генераторы теней",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Получить генераторы теней, добавленные источниками света через bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "Нарисовать точечный свет",
    "drawPointLight": "Нарисовать точечный свет",
    "bitbybit.babylon.scene.drawPointLight_description": "Создает и рисует точечный свет в сцене",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "Нарисовать направленный свет без возврата",
    "drawDirectionalLightNoReturn": "Нарисовать направленный свет без возврата",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Создает и рисует направленный свет в сцене",
    "bitbybit.babylon.scene.drawDirectionalLight": "Нарисовать направленный свет",
    "drawDirectionalLight": "Нарисовать направленный свет",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Создает и рисует направленный свет в сцене",
    "bitbybit.babylon.scene.getActiveCamera": "Получить активную камеру",
    "getActiveCamera": "Получить активную камеру",
    "bitbybit.babylon.scene.getActiveCamera_description": "Получает активную камеру сцены",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "Настроить активную камеру вращения по дуге",
    "adjustActiveArcRotateCamera": "Настроить активную камеру вращения по дуге",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Настраивает активную камеру вращения по дуге с параметрами конфигурации",
    "lookAt": "Смотреть на",
    "bitbybit.babylon.scene.clearAllDrawn": "Очистить всё нарисованное",
    "clearAllDrawn": "Очистить всё нарисованное",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Очищает все отрисованные объекты в 3D сцене",
    "bitbybit.babylon.scene.enableSkybox": "Включить скайбокс",
    "enableSkybox": "Включить скайбокс",
    "bitbybit.babylon.scene.enableSkybox_description": "Включает скайбокс",
    "skybox": "Скайбокс",
    "Base.skyboxEnum": "Базовое перечисление скайбокса",
    "blur": "Размытие",
    "environmentIntensity": "Интенсивность окружения",
    "bitbybit.babylon.scene.fog": "Туман",
    "fog": "Туман",
    "bitbybit.babylon.scene.fog_description": "Включает режим тумана",
    "mode": "Режим",
    "Base.fogModeEnum": "Базовое перечисление режима тумана",
    "color": "Цвет",
    "density": "Плотность",
    "start": "Начало",
    "end": "Конец",
    "bitbybit.babylon.transforms.rotationCenterAxis": "Вращение: центр, ось",
    "transforms": "Преобразования",
    "rotationCenterAxis": "Вращение: центр, ось",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Создает трансформацию вращения вокруг центра и оси",
    "center": "Центр",
    "bitbybit.babylon.transforms.rotationCenterX": "Вращение: центр, X",
    "rotationCenterX": "Вращение: центр, X",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Создает трансформацию вращения вокруг центра и оси X",
    "bitbybit.babylon.transforms.rotationCenterY": "Вращение: центр, Y",
    "rotationCenterY": "Вращение: центр, Y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Создает трансформацию вращения вокруг центра и оси Y",
    "bitbybit.babylon.transforms.rotationCenterZ": "Вращение: центр, Z",
    "rotationCenterZ": "Вращение: центр, Z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Создает трансформацию вращения вокруг центра и оси Z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "Вращение: центр, рыскание, тангаж, крен",
    "rotationCenterYawPitchRoll": "Вращение: центр, рыскание, тангаж, крен",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Создает трансформацию вращения с рысканием, тангажем и креном",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "Масштаб: центр, XYZ",
    "scaleCenterXYZ": "Масштаб: центр, XYZ",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Трансформация масштаба вокруг центра и направлений xyz",
    "scaleXyz": "Масштаб XYZ",
    "bitbybit.babylon.transforms.scaleXYZ": "Масштаб XYZ",
    "scaleXYZ": "Масштаб XYZ",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Создает трансформацию масштаба в направлениях x, y и z",
    "bitbybit.babylon.transforms.uniformScale": "Равномерный масштаб",
    "uniformScale": "Равномерный масштаб",
    "bitbybit.babylon.transforms.uniformScale_description": "Создает равномерную трансформацию масштаба",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "Равномерный масштаб от центра",
    "uniformScaleFromCenter": "Равномерный масштаб от центра",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Создает равномерную трансформацию масштаба от центра",
    "bitbybit.babylon.transforms.translationXYZ": "Перемещение XYZ",
    "translationXYZ": "Перемещение XYZ",
    "bitbybit.babylon.transforms.translationXYZ_description": "Создает трансформацию перемещения",
    "translation": "Перемещение",
    "bitbybit.babylon.transforms.translationsXYZ": "Перемещения XYZ",
    "translationsXYZ": "Перемещения XYZ",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Создает трансформацию перемещения",
    "translations": "Перемещения",
    "Base.Vector3[]": "Массив базовых векторов 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "Загрузить ресурс в сцену",
    "io": "Ввод/вывод",
    "loadAssetIntoScene": "Загрузить ресурс в сцену",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Импортирует сетку из актива, который вы загрузили для проекта. Вы должны загрузить свои активы в проект через страницу управления проектом.",
    "load": "Загрузка",
    "assetFile": "Файл ресурса",
    "File": "Файл",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "Загрузить ресурс в сцену без возврата",
    "loadAssetIntoSceneNoReturn": "Загрузить ресурс в сцену без возврата",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Импортирует сетку из актива, который вы загрузили для проекта. Вы должны загрузить свои активы в проект через страницу управления проектом.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "Загрузить ресурс в сцену из корневого URL",
    "loadAssetIntoSceneFromRootUrl": "Загрузить ресурс в сцену из корневого URL",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Импортирует сетку из url актива, который вы загрузили в доступное веб-хранилище. Имейте в виду, что файлы должны быть общедоступными, чтобы это работало, убедитесь, что для активов включен доступ CORS.",
    "rootUrl": "Корневой URL",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "Загрузить ресурс в сцену из корневого URL без возврата",
    "loadAssetIntoSceneFromRootUrlNoReturn": "Загрузить ресурс в сцену из корневого URL без возврата",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Импортирует сетку из url актива, который вы загрузили в доступное веб-хранилище. Имейте в виду, что файлы должны быть общедоступными, чтобы это работало, убедитесь, что для активов включен доступ CORS.",
    "bitbybit.babylon.io.exportBabylon": "Экспорт в .babylon",
    "exportBabylon": "Экспорт в .babylon",
    "bitbybit.babylon.io.exportBabylon_description": "Экспортирует всю сцену в формат сцены .babylon. Затем вы можете редактировать ее дальше в редакторах babylonjs.",
    "export": "Экспорт",
    "fileName": "Имя файла",
    "bitbybit.babylon.io.exportGLB": "Экспорт в GLB",
    "exportGLB": "Экспорт в GLB",
    "bitbybit.babylon.io.exportGLB_description": "Экспортирует всю сцену в формат .glb. Этот формат файла стал отраслевым стандартом для веб-моделей.",
    "discardSkyboxAndGrid": "Отбросить скайбокс и сетку",
    "bitbybit.babylon.io.exportMeshToStl": "Экспорт меша в STL",
    "exportMeshToStl": "Экспорт меша в STL",
    "bitbybit.babylon.io.exportMeshToStl_description": "Экспортирует сетку с ее детьми в stl",
    "bitbybit.babylon.io.exportMeshesToStl": "Экспорт мешей в STL",
    "exportMeshesToStl": "Экспорт мешей в STL",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Экспортирует сетки в stl",
    "meshes": "Меши",
    "bitbybit.babylon.ray.createPickingRay": "Луч выбора",
    "ray": "Луч",
    "createPickingRay": "Создать луч выбора",
    "bitbybit.babylon.ray.createPickingRay_description": "Создает луч выбора из текущей позиции мыши в активной камере",
    "bitbybit.babylon.ray.createRay": "Луч",
    "createRay": "Создать луч",
    "bitbybit.babylon.ray.createRay_description": "Создать луч, который начинается в начале координат, имеет вектор направления и опционально длину",
    "length": "Длина",
    "bitbybit.babylon.ray.createRayFromTo": "Луч от/до",
    "createRayFromTo": "Создать луч от/до",
    "bitbybit.babylon.ray.createRayFromTo_description": "Создать луч из одной точки в другую",
    "from": "От",
    "to": "До",
    "bitbybit.babylon.ray.getOrigin": "Получить начало координат",
    "getOrigin": "Получить начало координат",
    "bitbybit.babylon.ray.getOrigin_description": "Получить начало луча",
    "BABYLON.Ray": "Луч Babylon",
    "bitbybit.babylon.ray.getDirection": "Получить направление",
    "getDirection": "Получить направление",
    "bitbybit.babylon.ray.getDirection_description": "Получить направление луча",
    "bitbybit.babylon.ray.getLength": "Получить длину",
    "getLength": "Получить длину",
    "bitbybit.babylon.ray.getLength_description": "Получить длину луча",
    "bitbybit.babylon.pick.pickWithRay": "Выбор лучом",
    "pick": "Выбор",
    "pickWithRay": "Выбрать лучом",
    "bitbybit.babylon.pick.pickWithRay_description": "Получить результат попадания при выборе лучом",
    "bitbybit.babylon.pick.pickWithPickingRay": "Выбор лучом выбора",
    "pickWithPickingRay": "Выбрать лучом выбора",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Выбрать с помощью луча выбора текущей позиции мыши в активной камере",
    "bitbybit.babylon.pick.getDistance": "Получить расстояние",
    "getDistance": "Получить расстояние",
    "bitbybit.babylon.pick.getDistance_description": "Получить расстояние до объекта, если результат выбора существует",
    "get from pick info": "Получить из информации о выборе",
    "pickInfo": "Информация о выборе",
    "BABYLON.PickingInfo": "Информация о выборе Babylon",
    "bitbybit.babylon.pick.getPickedMesh": "Получить выбранный меш",
    "getPickedMesh": "Получить выбранный меш",
    "bitbybit.babylon.pick.getPickedMesh_description": "Получить выбранную сетку",
    "bitbybit.babylon.pick.getPickedPoint": "Получить выбранную точку",
    "getPickedPoint": "Получить выбранную точку",
    "bitbybit.babylon.pick.getPickedPoint_description": "Получить выбранную точку",
    "bitbybit.babylon.pick.hit": "Попадание",
    "hit": "Попадание",
    "bitbybit.babylon.pick.hit_description": "Проверить, попал ли луч выбора во что-то в сцене или нет",
    "bitbybit.babylon.pick.getSubMeshId": "Получить ID подмеша",
    "getSubMeshId": "Получить ID подмеша",
    "bitbybit.babylon.pick.getSubMeshId_description": "Получает уникальный id подсетки, если она была выбрана",
    "bitbybit.babylon.pick.getSubMeshFaceId": "Получить ID грани подмеша",
    "getSubMeshFaceId": "Получить ID грани подмеша",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Получает уникальный id грани подсетки, если она была выбрана",
    "bitbybit.babylon.pick.getBU": "Получить BU",
    "getBU": "Получить BU",
    "bitbybit.babylon.pick.getBU_description": "Получает барицентрическую координату U, которая используется при вычислении текстурных координат столкновения",
    "bitbybit.babylon.pick.getBV": "Получить BV",
    "getBV": "Получить BV",
    "bitbybit.babylon.pick.getBV_description": "Получает барицентрическую координату V, которая используется при вычислении текстурных координат столкновения",
    "bitbybit.babylon.pick.getPickedSprite": "Получить выбранный спрайт",
    "getPickedSprite": "Получить выбранный спрайт",
    "bitbybit.babylon.pick.getPickedSprite_description": "Получить выбранный спрайт",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "PBR: металличность/шероховатость",
    "pbrMetallicRoughness": "PBR Металличность/Шероховатость",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Создать материал PBR metallic roughness.",
    "baseColor": "Базовый цвет",
    "emissiveColor": "Цвет свечения",
    "metallic": "Металличность",
    "roughness": "Шероховатость",
    "zOffset": "Смещение Z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "Установить базовый цвет",
    "setBaseColor": "Установить базовый цвет",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Устанавливает базовый цвет материала",
    "BABYLON.PBRMetallicRoughnessMaterial": "Материал PBR металличность/шероховатость Babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "Установить металличность",
    "setMetallic": "Установить металличность",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Устанавливает свойство металличности материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "Установить шероховатость",
    "setRoughness": "Установить шероховатость",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Устанавливает шероховатость материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "Установить альфа",
    "setAlpha": "Установить альфа",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Устанавливает альфа материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "Установить отсечение обратных граней",
    "setBackFaceCulling": "Установить отсечение обратных граней",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Устанавливает отсечение задней грани материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "Установить базовую текстуру",
    "setBaseTexture": "Установить базовую текстуру",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Устанавливает текстуру материала",
    "baseTexture": "Базовая текстура",
    "BABYLON.Texture": "Текстура Babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "Получить базовый цвет",
    "getBaseColor": "Получить базовый цвет",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Получает базовый цвет материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "Получить металличность",
    "getMetallic": "Получить металличность",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Получает свойство металличности материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "Получить шероховатость",
    "getRoughness": "Получить шероховатость",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Получает шероховатость материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "Получить альфа",
    "getAlpha": "Получить альфа",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Получает альфа материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "Получить отсечение обратных граней",
    "getBackFaceCulling": "Получить отсечение обратных граней",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Получает отсечение задней грани материала",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "Получить базовую текстуру",
    "getBaseTexture": "Получить базовую текстуру",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Получить базовую текстуру материала",
    "bitbybit.babylon.material.skyMaterial.create": "Материал неба",
    "skyMaterial": "Материал неба",
    "bitbybit.babylon.material.skyMaterial.create_description": "Создать материал неба",
    "luminance": "Яркость",
    "turbidity": "Мутность",
    "rayleigh": "Рэлей",
    "mieCoefficient": "Коэффициент Ми",
    "mieDirectionalG": "Направленный G Ми",
    "inclination": "Наклон",
    "azimuth": "Азимут",
    "sunPosition": "Позиция солнца",
    "useSunPosition": "Использовать позицию солнца",
    "cameraOffset": "Смещение камеры",
    "up": "Вверх",
    "dithering": "Дизеринг",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "Установить яркость",
    "setLuminance": "Установить яркость",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Устанавливает яркость материала неба",
    "MATERIALS.SkyMaterial": "Материал неба (Materials)",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "Установить мутность",
    "setTurbidity": "Установить мутность",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Устанавливает мутность материала неба",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "Установить Рэлей",
    "setRayleigh": "Установить Рэлей",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Устанавливает рэлеевское рассеяние материала неба",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "Установить коэффициент Ми",
    "setMieCoefficient": "Установить коэффициент Ми",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Устанавливает коэффициент Ми материала неба",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "Установить направленный G Ми",
    "setMieDirectionalG": "Установить направленный G Ми",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Устанавливает направленный G Ми материала неба",
    "bitbybit.babylon.material.skyMaterial.setDistance": "Установить расстояние",
    "setDistance": "Установить расстояние",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Устанавливает расстояние материала неба",
    "bitbybit.babylon.material.skyMaterial.setInclination": "Установить наклон",
    "setInclination": "Установить наклон",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Устанавливает наклон материала неба",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "Установить азимут",
    "setAzimuth": "Установить азимут",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Устанавливает азимут материала неба",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "Установить позицию солнца",
    "setSunPosition": "Установить позицию солнца",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Устанавливает позицию солнца материала неба",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "Установить использование позиции солнца",
    "setUseSunPosition": "Установить использование позиции солнца",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Устанавливает использование позиции солнца материала неба",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "Установить смещение камеры",
    "setCameraOffset": "Установить смещение камеры",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Устанавливает смещение камеры материала неба",
    "bitbybit.babylon.material.skyMaterial.setUp": "Установить направление 'вверх'",
    "setUp": "Установить 'вверх'",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Устанавливает верх материала неба",
    "bitbybit.babylon.material.skyMaterial.setDithering": "Установить дизеринг",
    "setDithering": "Установить дизеринг",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Устанавливает дизеринг материала неба",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "Получить яркость",
    "getLuminance": "Получить яркость",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Получает яркость материала неба",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "Получить мутность",
    "getTurbidity": "Получить мутность",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Получает мутность материала неба",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "Получить Рэлей",
    "getRayleigh": "Получить Рэлей",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Получает рэлеевское рассеяние материала неба",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "Получить коэффициент Ми",
    "getMieCoefficient": "Получить коэффициент Ми",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Получает коэффициент Ми материала неба",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "Получить направленный G Ми",
    "getMieDirectionalG": "Получить направленный G Ми",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Получает направленный G Ми материала неба",
    "bitbybit.babylon.material.skyMaterial.getDistance": "Получить расстояние",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Получает расстояние материала неба",
    "bitbybit.babylon.material.skyMaterial.getInclination": "Получить наклон",
    "getInclination": "Получить наклон",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Получает наклон материала неба",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "Получить азимут",
    "getAzimuth": "Получить азимут",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Получает азимут материала неба",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "Получить позицию солнца",
    "getSunPosition": "Получить позицию солнца",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Получает позицию солнца материала неба",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "Получить использование позиции солнца",
    "getUseSunPosition": "Получить использование позиции солнца",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Получает использование позиции солнца материала неба",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "Получить смещение камеры",
    "getCameraOffset": "Получить смещение камеры",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Получает смещение камеры материала неба",
    "bitbybit.babylon.material.skyMaterial.getUp": "Получить направление 'вверх'",
    "getUp": "Получить 'вверх'",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Получает верх материала неба",
    "bitbybit.babylon.material.skyMaterial.getDithering": "Получить дизеринг",
    "getDithering": "Получить дизеринг",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Получает дизеринг материала неба",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "Установить направление на цель",
    "shadowLight": "Источник света с тенью",
    "setDirectionToTarget": "Установить направление на цель",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Устанавливает направление света тени",
    "BABYLON.ShadowLight": "Источник света с тенью Babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "Установить позицию",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Устанавливает позицию света тени",
    "bitbybit.babylon.meshBuilder.createBox": "Параллелепипед",
    "meshBuilder": "Конструктор мешей",
    "createBox": "Создать параллелепипед",
    "bitbybit.babylon.meshBuilder.createBox_description": "Создает сетку коробки",
    "create simple": "Создать простой",
    "depth": "Глубина",
    "sideOrientation": "Ориентация стороны",
    "BabylonMesh.sideOrientationEnum": "Перечисление ориентации стороны меша Babylon",
    "bitbybit.babylon.meshBuilder.createCube": "Куб",
    "createCube": "Создать куб",
    "bitbybit.babylon.meshBuilder.createCube_description": "Создает сетку куба",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "Квадратная плоскость",
    "createSquarePlane": "Создать квадратную плоскость",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Создает сетку квадратной плоскости",
    "bitbybit.babylon.meshBuilder.createSphere": "Сфера",
    "createSphere": "Создать сферу",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Создает сетку сферы",
    "diameter": "Диаметр",
    "segments": "Сегменты",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "Икосфера",
    "createIcoSphere": "Создать икосферу",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Создать икосферу",
    "radiusX": "Радиус X",
    "radiusY": "Радиус Y",
    "radiusZ": "Радиус Z",
    "flat": "Плоский",
    "bitbybit.babylon.meshBuilder.createDisc": "Диск",
    "createDisc": "Создать диск",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Создает диск",
    "tessellation": "Тесселяция",
    "arc": "Дуга",
    "bitbybit.babylon.meshBuilder.createTorus": "Тор",
    "createTorus": "Создать тор",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Создать сетку тора",
    "thickness": "Толщина",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "Узел тора",
    "createTorusKnot": "Создать узел тора",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Создать сетку узла тора",
    "tube": "Труба",
    "radialSegments": "Радиальные сегменты",
    "tubularSegments": "Трубчатые сегменты",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "Полигон",
    "createPolygon": "Создать полигон",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Создать полигональную сетку",
    "shape": "Форма",
    "holes": "Отверстия",
    "Base.Vector3[][]": "Массив массивов базовых векторов 3",
    "smoothingThreshold": "Порог сглаживания",
    "wrap": "Обертывание",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "Выдавить полигон",
    "extrudePolygon": "Выдавить полигон",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Создать выдавленную полигональную сетку",
    "bitbybit.babylon.meshBuilder.createTube": "Труба",
    "createTube": "Создать трубу",
    "bitbybit.babylon.meshBuilder.createTube_description": "Создать сетку трубы",
    "path": "Путь",
    "cap": "Крышка",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "Многогранник",
    "createPolyhedron": "Создать многогранник",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Создать сетку многогранника",
    "type": "Тип",
    "sizeX": "Размер X",
    "sizeY": "Размер Y",
    "sizeZ": "Размер Z",
    "custom": "Пользовательский",
    "bitbybit.babylon.meshBuilder.createGeodesic": "Геодезический",
    "createGeodesic": "Создать геодезический",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Создать геодезическую сетку",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "Гольдберг",
    "createGoldberg": "Создать Гольдберг",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Создать сетку Голдберга",
    "bitbybit.babylon.meshBuilder.createCapsule": "Капсула",
    "createCapsule": "Создать капсулу",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Создать сетку капсулы",
    "orientation": "Ориентация",
    "capSubdivisions": "Подразделения крышки",
    "radiusTop": "Радиус верха",
    "radiusBottom": "Радиус низа",
    "topCapSubdivisions": "Подразделения верхней крышки",
    "bottomCapSubdivisions": "Подразделения нижней крышки",
    "bitbybit.babylon.meshBuilder.createCylinder": "Цилиндр",
    "createCylinder": "Создать цилиндр",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Создать сетку цилиндра",
    "diameterTop": "Диаметр верха",
    "diameterBottom": "Диаметр низа",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "Выдавленная форма",
    "createExtrudedSahpe": "Создать выдавленную форму",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Создать выдавленную форму",
    "closeShape": "Замкнуть форму",
    "closePath": "Замкнуть путь",
    "bitbybit.babylon.meshBuilder.createRibbon": "Лента",
    "createRibbon": "Создать ленту",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Создать сетку ленты",
    "pathArray": "Массив путей",
    "closeArray": "Замкнуть массив",
    "offset": "Смещение",
    "bitbybit.babylon.meshBuilder.createLathe": "Токарный станок (Lathe)",
    "createLathe": "Создать Lathe",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Создать сетку вращения",
    "closed": "Замкнутый",
    "bitbybit.babylon.meshBuilder.createGround": "Земля",
    "createGround": "Создать землю",
    "bitbybit.babylon.meshBuilder.createGround_description": "Создать сетку земли",
    "subdivisionsX": "Подразделения X",
    "subdivisionsY": "Подразделения Y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "Прямоугольная плоскость",
    "createRectanglePlane": "Создать прямоугольную плоскость",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Создает сетку прямоугольной плоскости",
    "bitbybit.babylon.texture.createSimple": "Простая текстура",
    "texture": "Текстура",
    "createSimple": "Простой",
    "bitbybit.babylon.texture.createSimple_description": "Создает текстуру из URL с несколькими базовыми опциями. Если вы загрузили актив через файл, создайте object url и передайте его здесь.",
    "invertY": "Инвертировать Y",
    "invertZ": "Инвертировать Z",
    "wAng": "Угол W",
    "uScale": "Масштаб U",
    "vScale": "Масштаб V",
    "uOffset": "Смещение U",
    "vOffset": "Смещение V",
    "samplingMode": "Режим сэмплирования",
    "samplingModeEnum": "Перечисление режима сэмплирования",
    "bitbybit.babylon.tools.createScreenshot": "Снимок экрана",
    "tools": "Инструменты",
    "createScreenshot": "Создать снимок экрана",
    "bitbybit.babylon.tools.createScreenshot_description": "Создает скриншот сцены",
    "screenshots": "Снимки экрана",
    "mimeType": "MIME тип",
    "quality": "Качество",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "Снимок экрана и загрузка",
    "createScreenshotAndDownload": "Создать снимок экрана и загрузить",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Создает скриншот сцены и скачивает файл",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "Полноэкранный UI",
    "gui": "GUI",
    "advancedDynamicTexture": "Продвинутая динамическая текстура",
    "createFullScreenUI": "Создать полноэкранный UI",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "Создает полноэкранный пользовательский интерфейс",
    "spaces": "Пространства",
    "foreground": "Передний план",
    "adaptiveScaling": "Адаптивное масштабирование",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "Для меша",
    "createForMesh": "Создать для меша",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Создает расширенную динамическую текстуру для сетки",
    "BABYLON.AbstractMesh": "Абстрактный меш Babylon",
    "supportPointerMove": "Поддержка движения указателя",
    "onlyAlphaTesting": "Только альфа-тестирование",
    "sampling": "Сэмплирование",
    "BabylonTexture.samplingModeEnum": "Перечисление режима сэмплирования текстуры Babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "Изменить отступы элемента управления",
    "control": "Элемент управления",
    "changeControlPadding": "Изменить отступы",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Изменить отступы для элемента управления",
    "positioning": "Позиционирование",
    "BABYLON.GUI.Control": "Элемент управления GUI Babylon",
    "paddingLeft": "Отступ слева",
    "number | string": "Число | строка",
    "paddingRight": "Отступ справа",
    "paddingTop": "Отступ сверху",
    "paddingBottom": "Отступ снизу",
    "bitbybit.babylon.gui.control.changeControlAlignment": "Изменить выравнивание элемента управления",
    "changeControlAlignment": "Изменить выравнивание",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Изменить выравнивание для элемента управления",
    "T": "T",
    "horizontalAlignment": "Горизонтальное выравнивание",
    "horizontalAlignmentEnum": "Перечисление горизонтального выравнивания",
    "verticalAlignment": "Вертикальное выравнивание",
    "verticalAlignmentEnum": "Перечисление вертикального выравнивания",
    "bitbybit.babylon.gui.control.cloneControl": "Клонировать элемент управления",
    "cloneControl": "Клонировать",
    "bitbybit.babylon.gui.control.cloneControl_description": "Клонировать элемент управления",
    "container": "Контейнер",
    "BABYLON.GUI.Container": "Контейнер GUI Babylon",
    "host": "Хост",
    "BABYLON.GUI.AdvancedDynamicTexture": "Продвинутая динамическая текстура GUI Babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "Селектор наблюдаемого элемента управления",
    "createControlObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Создает селектор наблюдаемого для элемента управления",
    "selector": "Селектор",
    "controlObservableSelectorEnum": "Перечисление селектора наблюдаемого элемента управления",
    "bitbybit.babylon.gui.control.getControlByName": "Получить элемент управления по имени",
    "getControlByName": "Получить по имени",
    "bitbybit.babylon.gui.control.getControlByName_description": "Получить элемент управления по имени",
    "bitbybit.babylon.gui.control.setIsVisible": "Установить видимость",
    "setIsVisible": "Установить видимость",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Установить видимость элемента управления",
    "isVisible": "Видим",
    "bitbybit.babylon.gui.control.setIsReadonly": "Установить 'только для чтения'",
    "setIsReadonly": "Установить 'только для чтения'",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Установить, доступен ли элемент управления только для чтения",
    "isReadOnly": "Только для чтения",
    "bitbybit.babylon.gui.control.setIsEnabled": "Установить доступность",
    "setIsEnabled": "Установить доступность",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Установить, включен ли элемент управления",
    "isEnabled": "Доступен",
    "bitbybit.babylon.gui.control.setHeight": "Установить высоту",
    "setHeight": "Установить высоту",
    "bitbybit.babylon.gui.control.setHeight_description": "Устанавливает высоту элемента управления",
    "bitbybit.babylon.gui.control.setWidth": "Установить ширину",
    "setWidth": "Установить ширину",
    "bitbybit.babylon.gui.control.setWidth_description": "Устанавливает ширину элемента управления",
    "bitbybit.babylon.gui.control.setColor": "Установить цвет",
    "setColor": "Установить цвет",
    "bitbybit.babylon.gui.control.setColor_description": "Устанавливает цвет элемента управления",
    "bitbybit.babylon.gui.control.setFontSize": "Установить размер шрифта",
    "setFontSize": "Установить размер шрифта",
    "bitbybit.babylon.gui.control.setFontSize_description": "Установить размер шрифта",
    "fontSize": "Размер шрифта",
    "bitbybit.babylon.gui.control.getHeight": "Получить высоту",
    "getHeight": "Получить высоту",
    "bitbybit.babylon.gui.control.getHeight_description": "Получает высоту",
    "bitbybit.babylon.gui.control.getWidth": "Получить ширину",
    "getWidth": "Получить ширину",
    "bitbybit.babylon.gui.control.getWidth_description": "Получает ширину",
    "bitbybit.babylon.gui.control.getColor": "Получить цвет",
    "getColor": "Получить цвет",
    "bitbybit.babylon.gui.control.getColor_description": "Получает цвет",
    "bitbybit.babylon.gui.control.getFontSize": "Получить размер шрифта",
    "getFontSize": "Получить размер шрифта",
    "bitbybit.babylon.gui.control.getFontSize_description": "Получить размер шрифта элемента управления",
    "bitbybit.babylon.gui.control.getIsVisible": "Получить видимость",
    "getIsVisible": "Получить видимость",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Получить видимость элемента управления",
    "bitbybit.babylon.gui.control.getIsReadonly": "Получить 'только для чтения'",
    "getIsReadonly": "Получить 'только для чтения'",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Получить только чтение элемента управления",
    "bitbybit.babylon.gui.control.getIsEnabled": "Получить доступность",
    "getIsEnabled": "Получить доступность",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Получить включение элемента управления",
    "bitbybit.babylon.gui.container.addControls": "Добавить элементы управления",
    "addControls": "Добавить элементы",
    "bitbybit.babylon.gui.container.addControls_description": "Добавляет элементы управления в контейнер и сохраняет порядок",
    "controls": "Элементы управления",
    "BABYLON.GUI.Control[]": "Массив элементов управления GUI Babylon",
    "clearControlsFirst": "Сначала очистить элементы",
    "bitbybit.babylon.gui.container.setBackground": "Установить фон",
    "setBackground": "Установить фон",
    "bitbybit.babylon.gui.container.setBackground_description": "Устанавливает фон контейнера",
    "background": "Фон",
    "bitbybit.babylon.gui.container.setIsReadonly": "Установить 'только для чтения'",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Устанавливает контейнер только для чтения",
    "bitbybit.babylon.gui.container.getBackground": "Получить фон",
    "getBackground": "Получить фон",
    "bitbybit.babylon.gui.container.getBackground_description": "Получает фон контейнера",
    "bitbybit.babylon.gui.container.getIsReadonly": "Получить 'только для чтения'",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Получает контейнер только для чтения",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "Панель стека",
    "stackPanel": "Панель стека",
    "createStackPanel": "Создать панель стека",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "Создает панель стека (StackPanel)",
    "isVertical": "Вертикальная",
    "spacing": "Интервал",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "Установить вертикальность",
    "setIsVertical": "Установить вертикальность",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Установить, является ли стековая панель вертикальной",
    "BABYLON.GUI.StackPanel": "Панель стека GUI Babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "Установить интервал",
    "setSpacing": "Установить интервал",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Установить интервал стековой панели",
    "bitbybit.babylon.gui.stackPanel.setWidth": "Установить ширину",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Установить ширину стековой панели",
    "bitbybit.babylon.gui.stackPanel.setHeight": "Установить высоту",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Установить высоту стековой панели",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "Получить вертикальность",
    "getIsVertical": "Получить вертикальность",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Получить вертикальность стековой панели",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "Получить интервал",
    "getSpacing": "Получить интервал",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Получить интервал стековой панели",
    "bitbybit.babylon.gui.stackPanel.getWidth": "Получить ширину",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Получить ширину стековой панели",
    "bitbybit.babylon.gui.stackPanel.getHeight": "Получить высоту",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Получить высоту стековой панели",
    "bitbybit.babylon.gui.button.createSimpleButton": "Простая кнопка",
    "button": "Кнопка",
    "createSimpleButton": "Создать простую кнопку",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "Создает простую кнопку",
    "label": "Метка",
    "bitbybit.babylon.gui.button.setButtonText": "Установить текст кнопки",
    "setButtonText": "Установить текст",
    "bitbybit.babylon.gui.button.setButtonText_description": "Установить текст кнопки",
    "BABYLON.GUI.Button": "Кнопка GUI Babylon",
    "text": "Текст",
    "bitbybit.babylon.gui.button.getButtonText": "Получить текст кнопки",
    "getButtonText": "Получить текст",
    "bitbybit.babylon.gui.button.getButtonText_description": "Получить текст кнопки",
    "bitbybit.babylon.gui.slider.createSlider": "Слайдер",
    "slider": "Слайдер",
    "createSlider": "Создать слайдер",
    "bitbybit.babylon.gui.slider.createSlider_description": "Создает слайдер",
    "minimum": "Минимум",
    "maximum": "Максимум",
    "value": "Значение",
    "step": "Шаг",
    "displayThumb": "Отображать ползунок",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "Изменить ползунок слайдера",
    "changeSliderThumb": "Изменить ползунок",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "Изменяет свойства ползунка слайдера",
    "BABYLON.GUI.Slider": "Слайдер GUI Babylon",
    "isThumbCircle": "Ползунок круглый",
    "thumbColor": "Цвет ползунка",
    "thumbWidth": "Ширина ползунка",
    "string | number": "Строка | число",
    "isThumbClamped": "Ползунок ограничен",
    "bitbybit.babylon.gui.slider.setBorderColor": "Установить цвет рамки",
    "setBorderColor": "Установить цвет рамки",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Изменяет цвет границы слайдера",
    "borderColor": "Цвет рамки",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "Установить цвет фона",
    "setBackgroundColor": "Установить цвет фона",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Изменяет цвет фона слайдера",
    "backgroundColor": "Цвет фона",
    "bitbybit.babylon.gui.slider.setMaximum": "Установить максимум",
    "setMaximum": "Установить максимум",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Изменяет максимальное значение слайдера",
    "bitbybit.babylon.gui.slider.setMinimum": "Установить минимум",
    "setMinimum": "Установить минимум",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Изменяет минимальное значение слайдера",
    "bitbybit.babylon.gui.slider.setStep": "Установить шаг",
    "setStep": "Установить шаг",
    "bitbybit.babylon.gui.slider.setStep_description": "Изменяет значение шага слайдера",
    "bitbybit.babylon.gui.slider.setValue": "Установить значение",
    "setValue": "Установить значение",
    "bitbybit.babylon.gui.slider.setValue_description": "Изменяет значение слайдера",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "Селектор наблюдаемого слайдера",
    "createSliderObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Создает селектор наблюдаемого для слайдера",
    "sliderObservableSelectorEnum": "Перечисление селектора наблюдаемого слайдера",
    "bitbybit.babylon.gui.slider.getBorderColor": "Получить цвет рамки",
    "getBorderColor": "Получить цвет рамки",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Получает цвет границы слайдера",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "Получить цвет фона",
    "getBackgroundColor": "Получить цвет фона",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Получает цвет фона слайдера",
    "bitbybit.babylon.gui.slider.getMaximum": "Получить максимум",
    "getMaximum": "Получить максимум",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Получает максимальное значение слайдера",
    "bitbybit.babylon.gui.slider.getMinimum": "Получить минимум",
    "getMinimum": "Получить минимум",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Получает минимальное значение слайдера",
    "bitbybit.babylon.gui.slider.getStep": "Получить шаг",
    "getStep": "Получить шаг",
    "bitbybit.babylon.gui.slider.getStep_description": "Получает значение шага слайдера",
    "bitbybit.babylon.gui.slider.getValue": "Получить значение",
    "getValue": "Получить значение",
    "bitbybit.babylon.gui.slider.getValue_description": "Получает значение слайдера",
    "bitbybit.babylon.gui.slider.getThumbColor": "Получить цвет ползунка",
    "getThumbColor": "Получить цвет ползунка",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Получает цвет ползунка слайдера",
    "bitbybit.babylon.gui.slider.getThumbWidth": "Получить ширину ползунка",
    "getThumbWidth": "Получить ширину ползунка",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Получает ширину ползунка слайдера",
    "bitbybit.babylon.gui.slider.getIsVertical": "Получить вертикальность",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Получает вертикальность слайдера",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "Получить отображение ползунка",
    "getDisplayThumb": "Получить отображение ползунка",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Получает отображение ползунка слайдера",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "Получить круглость ползунка",
    "getIsThumbCircle": "Получить круглость ползунка",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Получает, является ли ползунок слайдера кругом",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "Получить ограничение ползунка",
    "getIsThumbClamped": "Получить ограничение ползунка",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Получает, закреплен ли ползунок слайдера",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "Текстовый блок",
    "textBlock": "Текстовый блок",
    "createTextBlock": "Создать текстовый блок",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "Создает текстовый блок",
    "bitbybit.babylon.gui.textBlock.alignText": "Выровнять текст",
    "alignText": "Выровнять текст",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Изменить выравнивание текста",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "Установить обводку текста",
    "setTextOutline": "Установить обводку",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Изменить контур текста для текста",
    "BABYLON.GUI.TextBlock": "Текстовый блок GUI Babylon",
    "outlineWidth": "Ширина обводки",
    "outlineColor": "Цвет обводки",
    "bitbybit.babylon.gui.textBlock.setText": "Установить текст",
    "setText": "Установить текст",
    "bitbybit.babylon.gui.textBlock.setText_description": "Устанавливает новый текст в текстовый блок",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "Установить подгонку размера",
    "setRsizeToFit": "Установить подгонку размера",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Включить или отключить изменение размера по содержимому",
    "resizeToFit": "Подогнать размер",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "Установить перенос текста",
    "setTextWrapping": "Установить перенос",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Устанавливает новый перенос текста в текстовый блок",
    "textWrapping": "Перенос текста",
    "boolean | BABYLON.GUI.TextWrapping": "Логический | Перенос текста GUI Babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "Установить межстрочный интервал",
    "setLineSpacing": "Установить интервал",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Устанавливает межстрочный интервал текста",
    "lineSpacing": "Межстрочный интервал",
    "bitbybit.babylon.gui.textBlock.getText": "Получить текст",
    "getText": "Получить текст",
    "bitbybit.babylon.gui.textBlock.getText_description": "Получает текст текстового блока",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "Получить перенос текста",
    "getTextWrapping": "Получить перенос",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Получает перенос текста текстового блока",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "Получить межстрочный интервал",
    "getLineSpacing": "Получить интервал",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Получает межстрочный интервал текстового блока",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "Получить ширину обводки",
    "getOutlineWidth": "Получить ширину обводки",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Получает ширину контура текстового блока",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "Получить подгонку размера",
    "getResizeToFit": "Получить подгонку размера",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Получает изменение размера по содержимому текстового блока",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "Получить горизонтальное выравнивание текста",
    "getTextHorizontalAlignment": "Получить гориз. выравнивание",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Получает горизонтальное выравнивание текста текстового блока",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "Получить вертикальное выравнивание текста",
    "getTextVerticalAlignment": "Получить верт. выравнивание",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Получает вертикальное выравнивание текста текстового блока",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "Селектор наблюдаемого текстового блока",
    "createTextBlockObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Создает селектор наблюдаемого для текстового блока",
    "textBlockObservableSelectorEnum": "Перечисление селектора наблюдаемого текстового блока",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "Радиокнопка",
    "radioButton": "Радиокнопка",
    "createRadioButton": "Создать радиокнопку",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "Создает радиокнопку",
    "group": "Группа",
    "isChecked": "Отмечена",
    "checkSizeRatio": "Коэффициент размера отметки",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "Установить коэфф. размера отметки",
    "setCheckSizeRatio": "Установить коэфф. размера отметки",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Устанавливает соотношение размера отметки радиокнопки",
    "BABYLON.GUI.RadioButton": "Радиокнопка GUI Babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "Установить группу",
    "setGroup": "Установить группу",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Устанавливает группу радиокнопки",
    "bitbybit.babylon.gui.radioButton.setBackground": "Установить фон",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Устанавливает фон радиокнопки",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "Получить коэфф. размера отметки",
    "getCheckSizeRatio": "Получить коэфф. размера отметки",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Получает соотношение размера отметки радиокнопки",
    "bitbybit.babylon.gui.radioButton.getGroup": "Получить группу",
    "getGroup": "Получить группу",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Получает группу радиокнопки",
    "bitbybit.babylon.gui.radioButton.getBackground": "Получить фон",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Получает фон радиокнопки",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "Селектор наблюдаемого радиокнопки",
    "createRadioButtonObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Создает селектор наблюдаемого для радиокнопки",
    "radioButtonObservableSelectorEnum": "Перечисление селектора наблюдаемого радиокнопки",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "Чекбокс",
    "checkbox": "Чекбокс",
    "createCheckbox": "Создать чекбокс",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "Создает чекбокс (флажок)",
    "bitbybit.babylon.gui.checkbox.setBackground": "Установить фон",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Устанавливает фон чекбокса",
    "BABYLON.GUI.Checkbox": "Чекбокс GUI Babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "Установить коэфф. размера отметки",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Устанавливает соотношение размера отметки чекбокса",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "Установить отметку",
    "setIsChecked": "Установить отметку",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Устанавливает, отмечен ли чекбокс",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "Получить коэфф. размера отметки",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Получает соотношение размера отметки",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "Получить отметку",
    "getIsChecked": "Получить отметку",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Получает отмечен ли",
    "bitbybit.babylon.gui.checkbox.getBackground": "Получить фон",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Получает фон",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "Селектор наблюдаемого чекбокса",
    "createCheckboxObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Создает селектор наблюдаемого для чекбокса",
    "checkboxObservableSelectorEnum": "Перечисление селектора наблюдаемого чекбокса",
    "bitbybit.babylon.gui.inputText.createInputText": "Поле ввода текста",
    "inputText": "Поле ввода текста",
    "createInputText": "Создать поле ввода",
    "bitbybit.babylon.gui.inputText.createInputText_description": "Создает поле ввода текста",
    "placeholder": "Заполнитель",
    "bitbybit.babylon.gui.inputText.setBackground": "Установить фон",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Устанавливает фон поля ввода",
    "BABYLON.GUI.InputText": "Поле ввода текста GUI Babylon",
    "bitbybit.babylon.gui.inputText.setText": "Установить текст",
    "bitbybit.babylon.gui.inputText.setText_description": "Устанавливает текст поля ввода",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "Установить заполнитель",
    "setPlaceholder": "Установить заполнитель",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Устанавливает заполнитель поля ввода",
    "bitbybit.babylon.gui.inputText.getBackground": "Получить фон",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Получает фон поля ввода",
    "bitbybit.babylon.gui.inputText.getText": "Получить текст",
    "bitbybit.babylon.gui.inputText.getText_description": "Получает текст поля ввода",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "Получить заполнитель",
    "getPlaceholder": "Получить заполнитель",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Получает заполнитель поля ввода",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "Селектор наблюдаемого поля ввода текста",
    "createInputTextObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Создает селектор наблюдаемого для поля ввода",
    "inputTextObservableSelectorEnum": "Перечисление селектора наблюдаемого поля ввода текста",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "Палитра цветов",
    "colorPicker": "Палитра цветов",
    "createColorPicker": "Создать палитру цветов",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "Создает палитру выбора цвета",
    "defaultColor": "Цвет по умолчанию",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "Установить значение палитры",
    "setColorPickerValue": "Установить значение",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Устанавливает цвет значения выбора цвета",
    "BABYLON.GUI.ColorPicker": "Палитра цветов GUI Babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "Установить размер палитры",
    "setColorPickerSize": "Установить размер",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Устанавливает размер выбора цвета (ширина и высота)",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "Получить значение палитры",
    "getColorPickerValue": "Получить значение",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Получает цвет значения выбора цвета",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "Получить размер палитры",
    "getColorPickerSize": "Получить размер",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "Получает размер палитры",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "Селектор наблюдаемого палитры цветов",
    "createColorPickerObservableSelector": "Создать селектор наблюдаемого",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Создает селектор наблюдаемого для выбора цвета",
    "colorPickerObservableSelectorEnum": "Перечисление селектора наблюдаемого палитры цветов",
    "bitbybit.babylon.gui.image.createImage": "Изображение",
    "image": "Изображение",
    "createImage": "Создать изображение",
    "bitbybit.babylon.gui.image.createImage_description": "Создает элемент изображения",
    "bitbybit.babylon.gui.image.setSourceUrl": "Установить URL источника",
    "setSourceUrl": "Установить URL источника",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "Устанавливает URL источника изображения",
    "BABYLON.GUI.Image": "Изображение GUI Babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "Получить URL источника",
    "getSourceUrl": "Получить URL источника",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "Получает URL источника изображения",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "Менеджер гизмо",
    "gizmo": "Гизмо",
    "manager": "Менеджер",
    "createGizmoManager": "Создать менеджер гизмо",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Создать менеджер гизмо",
    "positionGizmoEnabled": "Гизмо позиции вкл.",
    "rotationGizmoEnabled": "Гизмо вращения вкл.",
    "scaleGizmoEnabled": "Гизмо масштаба вкл.",
    "boundingBoxGizmoEnabled": "Гизмо ограничивающего бокса вкл.",
    "usePointerToAttachGizmos": "Использовать указатель для прикрепления гизмо",
    "clearGizmoOnEmptyPointerEvent": "Очищать гизмо при пустом событии указателя",
    "scaleRatio": "Коэффициент масштаба",
    "attachableMeshes": "Прикрепляемые меши",
    "BABYLON.AbstractMesh[]": "Массив абстрактных мешей Babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "Получить гизмо позиции",
    "getPositionGizmo": "Получить гизмо позиции",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Получить гизмо позиции",
    "gizmoManager": "Менеджер гизмо",
    "BABYLON.GizmoManager": "Менеджер гизмо Babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "Получить гизмо вращения",
    "getRotationGizmo": "Получить гизмо вращения",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Получить гизмо вращения",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "Получить гизмо масштаба",
    "getScaleGizmo": "Получить гизмо масштаба",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Получить гизмо масштаба",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "Получить гизмо ограничивающего бокса",
    "getBoundingBoxGizmo": "Получить гизмо огран. бокса",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Получить гизмо ограничивающего параллелепипеда",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "Прикрепить к мешу",
    "attachToMesh": "Прикрепить к мешу",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Прикрепить менеджер гизмо к сетке",
    "update": "Обновить",
    "bitbybit.babylon.gizmo.manager.detachMesh": "Открепить меш",
    "detachMesh": "Открепить меш",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Отсоединить менеджер гизмо от сетки",
    "bitbybit.babylon.gizmo.base.scaleRatio": "Установить коэффициент масштаба",
    "base": "База",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Установить коэффициент масштаба гизмо",
    "BABYLON.IGizmo": "Интерфейс гизмо Babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "Получить коэффициент масштаба",
    "getScaleRatio": "Получить коэфф. масштаба",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Получает коэффициент масштаба",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "Установить вкл. плоского гизмо",
    "positionGizmo": "Гизмо позиции",
    "planarGizmoEnabled": "Плоский гизмо вкл.",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Установить планарный гизмо включенным",
    "BABYLON.IPositionGizmo": "Интерфейс гизмо позиции Babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "Установить дистанцию привязки",
    "snapDistance": "Дистанция привязки",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Установить дистанцию привязки гизмо позиции",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "Получить прикрепленный меш",
    "getAttachedMesh": "Получить прикрепленный меш",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Получить прикрепленную сетку",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "Получить прикрепленный узел",
    "getAttachedNode": "Получить прикрепленный узел",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Получить прикрепленный узел",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "Получить гизмо X",
    "getXGizmo": "Получить гизмо X",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Получить x гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "Получить гизмо Y",
    "getYGizmo": "Получить гизмо Y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Получить y гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "Получить гизмо Z",
    "getZGizmo": "Получить гизмо Z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Получить z гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "Получить гизмо плоскости X",
    "getXPlaneGizmo": "Получить гизмо плоскости X",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Получить x планарный гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "Получить гизмо плоскости Y",
    "getYPlaneGizmo": "Получить гизмо плоскости Y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Получить y планарный гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "Получить гизмо плоскости Z",
    "getZPlaneGizmo": "Получить гизмо плоскости Z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Получить z планарный гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "получить вкл. плоского гизмо",
    "getPlanarGizmoEnabled": "получить вкл. плоского гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Получить, включен ли планарный гизмо",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "получить дистанцию привязки",
    "getSnapDistance": "получить дистанцию привязки",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Получить дистанцию привязки",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "получить состояние перетаскивания",
    "getIsDragging": "получить состояние перетаскивания",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Получить, происходит ли перетаскивание",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "селектор наблюдаемого гизмо позиции",
    "createPositionGizmoObservableSelector": "селектор наблюдаемого гизмо позиции",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Создает селектор наблюдаемого для гизмо позиции",
    "positionGizmoObservableSelectorEnum": "перечисление селектора наблюдаемого гизмо позиции",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "установить дистанцию привязки",
    "rotationGizmo": "гизмо вращения",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Установить дистанцию привязки гизмо вращения",
    "BABYLON.IRotationGizmo": "интерфейс гизмо вращения Babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "установить чувствительность",
    "sensitivity": "чувствительность",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Установить чувствительность гизмо вращения",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "получить прикрепленный меш",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Получить прикрепленную сетку",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "получить прикрепленный узел",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Получить прикрепленный узел",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "получить гизмо X",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Получить x гизмо",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "получить гизмо Y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Получить y гизмо",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "получить гизмо Z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Получить z гизмо",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "получить дистанцию привязки",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Получить дистанцию привязки",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "получить чувствительность",
    "getSensitivity": "получить чувствительность",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Получить чувствительность",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "селектор наблюдаемого гизмо вращения",
    "createRotationGizmoObservableSelector": "селектор наблюдаемого гизмо вращения",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Создает селектор наблюдаемого для гизмо вращения",
    "rotationGizmoObservableSelectorEnum": "перечисление селектора наблюдаемого гизмо вращения",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "получить гизмо X",
    "scaleGizmo": "гизмо масштаба",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Получить x гизмо",
    "BABYLON.IScaleGizmo": "интерфейс гизмо масштаба Babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "получить гизмо Y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Получить y гизмо",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "получить гизмо Z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Получить z гизмо",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "установить дистанцию привязки",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Установить дистанцию привязки гизмо масштаба",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "установить инкрементную привязку",
    "setIncrementalSnap": "установить инкрементную привязку",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Установить инкрементальную привязку гизмо масштаба",
    "incrementalSnap": "инкрементная привязка",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "установить чувствительность",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Установить чувствительность гизмо масштаба",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "получить инкрементную привязку",
    "getIncrementalSnap": "получить инкрементную привязку",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Получить инкрементальную привязку",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "получить дистанцию привязки",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Получить дистанцию привязки",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "получить чувствительность",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Получить чувствительность",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "селектор наблюдаемого гизмо масштаба",
    "createScaleGizmoObservableSelector": "селектор наблюдаемого гизмо масштаба",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Создает селектор наблюдаемого для гизмо масштаба",
    "scaleGizmoObservableSelectorEnum": "перечисление селектора наблюдаемого гизмо масштаба",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "установить размер сферы вращения",
    "boundingBoxGizmo": "гизмо ограничивающего бокса",
    "setRotationSphereSize": "установить размер сферы вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Установить размер сферы вращения гизмо ограничивающего параллелепипеда",
    "BABYLON.BoundingBoxGizmo": "гизмо ограничивающего бокса Babylon",
    "rotationSphereSize": "размер сферы вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "установить фикс. экранный размер меша перетаскивания",
    "setFixedDragMeshScreenSize": "установить фикс. экранный размер меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "Если установлено, якоря вращения и масштабирующие боксы будут увеличиваться в размерах в зависимости от расстояния от камеры, чтобы иметь постоянный размер на экране (По умолчанию: false) Примечание: fixedDragMeshScreenSize имеет приоритет над fixedDragMeshBoundsSize, если оба истинны",
    "fixedDragMeshScreenSize": "фикс. экранный размер меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "установить фикс. размер границ меша перетаскивания",
    "setFixedDragMeshBoundsSize": "установить фикс. размер границ меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Установить фиксированный размер границ перетаскиваемой сетки гизмо ограничивающего параллелепипеда",
    "fixedDragMeshBoundsSize": "фикс. размер границ меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "установить фактор дистанции для фикс. экранного размера меша перетаскивания",
    "setFixedDragMeshScreenSizeDistanceFactor": "установить фактор дистанции фикс. экранного размера меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "Расстояние от объекта, на котором перетаскиваемые сетки должны появляться в мировом размере, когда fixedDragMeshScreenSize установлено в true (по умолчанию: 10)",
    "fixedDragMeshScreenSizeDistanceFactor": "фактор дистанции фикс. экранного размера меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "установить дистанцию привязки масштабирования",
    "setScalingSnapDistance": "установить дистанцию привязки масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Установить дистанцию привязки масштабирования гизмо ограничивающего параллелепипеда. Дистанция перетаскивания в единицах babylon, к которой гизмо будет привязывать масштабирование при перетаскивании.",
    "scalingSnapDistance": "дистанция привязки масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "установить дистанцию привязки вращения",
    "setRotationSnapDistance": "установить дистанцию привязки вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Установить дистанцию привязки вращения гизмо ограничивающего параллелепипеда. Дистанция перетаскивания в единицах babylon, к которой гизмо будет привязывать вращение при перетаскивании.",
    "rotationSnapDistance": "дистанция привязки вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "установить размер бокса масштабирования",
    "setScaleBoxSize": "установить размер бокса масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Установить размер масштабирующего бокса гизмо ограничивающего параллелепипеда",
    "scaleBoxSize": "размер бокса масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "установить инкрементную привязку",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Установить инкрементальную привязку гизмо ограничивающего параллелепипеда. Инкрементальная привязка масштабирования (по умолчанию false). Когда true, с snapDistance 0.1, масштабирование будет 1.1, 1.2, 1.3 вместо, когда false: 1.1, 1.21, 1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "установить точку опоры масштабирования",
    "setScalePivot": "установить точку опоры масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Установить центр масштабирования гизмо ограничивающего параллелепипеда. Относительный центр ограничивающего параллелепипеда, используемый при масштабировании присоединенного узла. Когда null объект масштабируется от противоположного угла. 0.5,0.5,0.5 для центра и 0.5,0,0.5 для низа (По умолчанию: null)",
    "scalePivot": "точка опоры масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "установить фактор оси",
    "setAxisFactor": "установить фактор оси",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Установить коэффициент оси гизмо ограничивающего параллелепипеда. Установить пользовательское значение чувствительности для каждой оси",
    "axisFactor": "фактор оси",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "установить скорость перетаскивания масштаба",
    "setScaleDragSpeed": "установить скорость перетаскивания масштаба",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Установить скорость перетаскивания масштабирования гизмо ограничивающего параллелепипеда",
    "scaleDragSpeed": "скорость перетаскивания масштаба",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "получить размер сферы вращения",
    "getRotationSphereSize": "получить размер сферы вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Получить размер сферы вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "получить размер бокса масштабирования",
    "getScaleBoxSize": "получить размер бокса масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Получить размер масштабирующего бокса",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "получить фикс. экранный размер меша перетаскивания",
    "getFixedDragMeshScreenSize": "получить фикс. экранный размер меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Получить фиксированный размер экрана перетаскиваемой сетки",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "получить фикс. размер границ меша перетаскивания",
    "getFixedDragMeshBoundsSize": "получить фикс. размер границ меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Получить фиксированный размер границ перетаскиваемой сетки",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "получить фактор дистанции фикс. экранного размера меша перетаскивания",
    "getFixedDragMeshScreenSizeDistanceFactor": "получить фактор дистанции фикс. экранного размера меша перетаскивания",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Получить коэффициент расстояния фиксированного размера экрана перетаскиваемой сетки",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "получить дистанцию привязки масштабирования",
    "getScalingSnapDistance": "получить дистанцию привязки масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Получить дистанцию привязки масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "получить дистанцию привязки вращения",
    "getRotationSnapDistance": "получить дистанцию привязки вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Получить дистанцию привязки вращения",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "получить инкрементную привязку",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Получить инкрементальную привязку",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "получить точку опоры масштабирования",
    "getScalePivot": "получить точку опоры масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Получить центр масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "получить фактор оси",
    "getAxisFactor": "получить фактор оси",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Получить коэффициент оси",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "получить скорость перетаскивания масштаба",
    "getScaleDragSpeed": "получить скорость перетаскивания масштаба",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Получить скорость перетаскивания масштабирования",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "селектор наблюдаемого гизмо ограничивающего бокса",
    "createBoundingBoxGizmoObservableSelector": "селектор наблюдаемого гизмо ограничивающего бокса",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Создает селектор наблюдаемого для гизмо ограничивающего параллелепипеда",
    "boundingBoxGizmoObservableSelectorEnum": "перечисление селектора наблюдаемого гизмо ограничивающего бокса",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "установить доступность",
    "axisDragGizmo": "гизмо перетаскивания по оси",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Устанавливает, включена ли ось",
    "BABYLON.IAxisDragGizmo": "интерфейс гизмо перетаскивания по оси Babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "получить доступность",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Проверяет, включена ли ось",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "установить доступность",
    "axisScaleGizmo": "гизмо масштабирования по оси",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Устанавливает, включена ли ось",
    "BABYLON.IAxisScaleGizmo": "интерфейс гизмо масштабирования по оси Babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "получить доступность",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Проверяет, включена ли ось",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "установить доступность",
    "planeDragGizmo": "гизмо перетаскивания по плоскости",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Устанавливает, включена ли плоскость",
    "BABYLON.IPlaneDragGizmo": "интерфейс гизмо перетаскивания по плоскости Babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "получить доступность",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Проверяет, включена ли плоскость",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "установить доступность",
    "planeRotationGizmo": "гизмо вращения по плоскости",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Устанавливает, включена ли плоскость",
    "BABYLON.IPlaneRotationGizmo": "интерфейс гизмо вращения по плоскости Babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "получить доступность",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Проверяет, включена ли плоскость",
    "bitbybit.vector.removeAllDuplicateVectors": "удалить все дубликаты векторов",
    "vector": "вектор",
    "removeAllDuplicateVectors": "удалить все дубликаты векторов",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Удаляет все дубликаты векторов из входного массива (оставляет только уникальные векторы). Пример: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]] → [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "удалить",
    "vectors": "векторы",
    "number[][]": "массив массивов чисел",
    "tolerance": "допуск",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "удалить последовательные дубликаты векторов",
    "removeConsecutiveDuplicateVectors": "удалить последовательные дубликаты векторов",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Удаляет последовательные дубликаты векторов из входного массива (удаляет только те дубликаты, которые появляются рядом друг с другом). Пример: [[1,2], [1,2], [3,4], [1,2]] → [[1,2], [3,4], [1,2]] (удален только последовательный дубликат)",
    "checkFirstAndLast": "проверить первый и последний",
    "bitbybit.vector.angleBetween": "угол между",
    "angleBetween": "угол между",
    "bitbybit.vector.angleBetween_description": "Измеряет угол между двумя векторами в градусах (всегда возвращает положительный угол 0-180°). Пример: [1,0,0] и [0,1,0] → 90° (перпендикулярные векторы)",
    "angles": "углы",
    "first": "первый",
    "second": "второй",
    "bitbybit.vector.angleBetweenNormalized2d": "угол между нормированными 2d",
    "angleBetweenNormalized2d": "угол между нормированными 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Измеряет нормализованный 2D угол между двумя векторами в градусах (учитывает направление, может быть отрицательным). Пример: [1,0] к [0,1] → 90°, [0,1] к [1,0] → -90°",
    "bitbybit.vector.positiveAngleBetween": "положительный угол между",
    "positiveAngleBetween": "положительный угол между",
    "bitbybit.vector.positiveAngleBetween_description": "Измеряет положительный угол между двумя векторами с учетом вектора ссылки в градусах (всегда 0-360°). Пример: преобразует отрицательные углы со знаком в положительные, добавляя 360° при необходимости",
    "reference": "опорный",
    "bitbybit.vector.addAll": "сложить все",
    "addAll": "сложить все",
    "bitbybit.vector.addAll_description": "Складывает все значения xyz векторов поэлементно и создает новый вектор. Пример: [[1,2,3], [4,5,6], [7,8,9]] → [12,15,18] (суммирует каждый столбец)",
    "sum": "сумма",
    "bitbybit.vector.add": "сложить",
    "add": "сложить",
    "bitbybit.vector.add_description": "Складывает два вектора поэлементно. Пример: [1,2,3] + [4,5,6] → [5,7,9]",
    "bitbybit.vector.all": "все",
    "all": "все",
    "bitbybit.vector.all_description": "Проверяет, содержит ли логический массив только значения true, возвращает false, если есть хотя бы одно false. Пример: [true, true, true] → true, [true, false, true] → false",
    "boolean[]": "логический массив",
    "bitbybit.vector.cross": "векторное произведение",
    "cross": "векторное произведение",
    "bitbybit.vector.cross_description": "Вычисляет векторное произведение двух 3D векторов (перпендикулярный вектор к обоим входным). Пример: [1,0,0] × [0,1,0] → [0,0,1] (правило правой руки)",
    "bitbybit.vector.distSquared": "квадрат расстояния",
    "distSquared": "квадрат расстояния",
    "bitbybit.vector.distSquared_description": "Вычисляет квадрат расстояния между двумя векторами (быстрее, чем расстояние, избегает корня). Пример: [0,0,0] до [3,4,0] → 25 (расстояние 5 в квадрате)",
    "bitbybit.vector.dist": "расстояние",
    "dist": "расстояние",
    "bitbybit.vector.dist_description": "Вычисляет евклидово расстояние между двумя векторами. Пример: [0,0,0] до [3,4,0] → 5, [1,1] до [4,5] → 5",
    "bitbybit.vector.div": "разделить",
    "div": "разделить",
    "bitbybit.vector.div_description": "Делит каждый элемент вектора на скалярное значение. Пример: [10,20,30] ÷ 2 → [5,10,15]",
    "scalar": "скаляр",
    "bitbybit.vector.domain": "диапазон",
    "domain": "диапазон",
    "bitbybit.vector.domain_description": "Вычисляет область (диапазон) между минимальным и максимальным значениями вектора. Пример: [1,3,5,9] → 8 (разница между последним и первым: 9-1)",
    "bitbybit.vector.dot": "скалярное произведение",
    "dot": "скалярное произведение",
    "bitbybit.vector.dot_description": "Вычисляет скалярное произведение двух векторов (измеряет схожесть/проекцию). Пример: [1,2,3] • [4,5,6] → 32 (1×4 + 2×5 + 3×6), перпендикулярные векторы → 0",
    "bitbybit.vector.finite": "конечный",
    "finite": "конечный",
    "bitbybit.vector.finite_description": "Проверяет, является ли каждый элемент в векторе конечным, и возвращает логический массив. Пример: [1, 2, Infinity, 3] → [true, true, false, true]",
    "validate": "проверить",
    "bitbybit.vector.isZero": "нулевой",
    "isZero": "нулевой",
    "bitbybit.vector.isZero_description": "Проверяет, имеет ли вектор нулевую длину (все элементы равны нулю). Пример: [0,0,0] → true, [0,0,0.001] → false",
    "bitbybit.vector.lerp": "линейная интерполяция",
    "lerp": "линейная интерполяция",
    "bitbybit.vector.lerp_description": "Находит интерполированный вектор между двумя векторами, используя долю (линейная интерполяция). Пример: [0,0,0] к [10,10,10] при 0.5 → [5,5,5], доля=0 → первый, доля=1 → второй",
    "fraction": "доля",
    "bitbybit.vector.max": "максимум",
    "max": "максимум",
    "bitbybit.vector.max_description": "Находит максимальное (наибольшее) значение в векторе. Пример: [3, 7, 2, 9, 1] → 9",
    "extract": "извлечь",
    "bitbybit.vector.min": "минимум",
    "min": "минимум",
    "bitbybit.vector.min_description": "Находит минимальное (наименьшее) значение в векторе. Пример: [3, 7, 2, 9, 1] → 1",
    "bitbybit.vector.mul": "умножить",
    "mul": "умножить",
    "bitbybit.vector.mul_description": "Умножает каждый элемент вектора на скалярное значение. Пример: [2,3,4] × 5 → [10,15,20]",
    "bitbybit.vector.neg": "отрицание",
    "neg": "отрицание",
    "bitbybit.vector.neg_description": "Инвертирует вектор (меняет знак каждого элемента). Пример: [5,-3,2] → [-5,3,-2]",
    "bitbybit.vector.normSquared": "квадрат нормы",
    "normSquared": "квадрат нормы",
    "bitbybit.vector.normSquared_description": "Вычисляет квадрат нормы (квадрат величины/длины) вектора. Пример: [3,4,0] → 25 (длина 5 в квадрате)",
    "bitbybit.vector.norm": "норма",
    "norm": "норма",
    "bitbybit.vector.norm_description": "Вычисляет норму (величину/длину) вектора. Пример: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.vector.normalized": "нормированный",
    "normalized": "нормированный",
    "bitbybit.vector.normalized_description": "Нормализует вектор в единичный вектор, имеющий длину 1 (сохраняет направление, масштабирует величину до 1). Пример: [3,4,0] → [0.6,0.8,0], [10,0,0] → [1,0,0]",
    "bitbybit.vector.onRay": "на луче",
    "onRay": "на луче",
    "bitbybit.vector.onRay_description": "Находит точку на луче на заданном расстоянии от начала координат вдоль вектора направления. Пример: Точка [0,0,0] + направление [1,0,0] на расстоянии 5 → [5,0,0]",
    "bitbybit.vector.vectorXYZ": "вектор xyz",
    "vectorXYZ": "вектор xyz",
    "bitbybit.vector.vectorXYZ_description": "Создает 3D вектор из координат x, y, z. Пример: x=1, y=2, z=3 → [1,2,3]",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "вектор xy",
    "vectorXY": "вектор xy",
    "bitbybit.vector.vectorXY_description": "Создает 2D вектор из координат x, y. Пример: x=3, y=4 → [3,4]",
    "bitbybit.vector.range": "диапазон",
    "range": "диапазон",
    "bitbybit.vector.range_description": "Создает вектор целых чисел от 0 до max (исключая). Пример: max=5 → [0,1,2,3,4], max=3 → [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "знаковый угол между",
    "signedAngleBetween": "знаковый угол между",
    "bitbybit.vector.signedAngleBetween_description": "Вычисляет угол со знаком между двумя векторами, используя вектор ссылки (определяет направление вращения). Пример: Возвращает положительный или отрицательный угол в зависимости от направления вращения относительно ссылки",
    "bitbybit.vector.span": "промежуток",
    "span": "промежуток",
    "bitbybit.vector.span_description": "Создает вектор, содержащий числа от min до max с заданным шагом. Пример: min=0, max=10, step=2 → [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "промежуток с замедлением",
    "spanEaseItems": "промежуток с замедлением",
    "bitbybit.vector.spanEaseItems_description": "Создает вектор с числами от min до max, используя функцию плавности для нелинейного распределения. Пример: min=0, max=100, nrItems=5, ease='easeInQuad' → создает ускоряющиеся интервалы",
    "nrItems": "кол-во элементов",
    "ease": "замедление",
    "Math.easeEnum": "перечисление замедления Math",
    "intervals": "интервалы",
    "bitbybit.vector.spanLinearItems": "линейный промежуток",
    "spanLinearItems": "линейный промежуток",
    "bitbybit.vector.spanLinearItems_description": "Создает вектор с равномерно распределенными числами от min до max с указанным количеством элементов. Пример: min=0, max=10, nrItems=5 → [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "вычесть",
    "sub": "вычесть",
    "bitbybit.vector.sub_description": "Вычитает второй вектор из первого поэлементно. Пример: [10,20,30] - [1,2,3] → [9,18,27]",
    "bitbybit.vector.sum": "сумма",
    "bitbybit.vector.sum_description": "Суммирует все значения в векторе и возвращает одно число. Пример: [1,2,3,4] → 10, [5,10,15] → 30",
    "bitbybit.point.transformPoint": "трансформировать точку",
    "transformPoint": "трансформировать точку",
    "bitbybit.point.transformPoint_description": "Применяет матрицу трансформации к одной точке (вращает, масштабирует или перемещает). Пример: point=[0,0,0] с перемещением [5,5,0] → [5,5,0]",
    "transformation": "преобразование",
    "Base.TransformMatrixes": "базовые матрицы преобразования",
    "bitbybit.point.transformPoints": "трансформировать точки",
    "transformPoints": "трансформировать точки",
    "bitbybit.point.transformPoints_description": "Применяет одну и ту же матрицу трансформации к нескольким точкам (пакетная трансформация). Пример: 5 точек с вращением 90° → все 5 точек повернуты вместе",
    "points": "точки",
    "bitbybit.point.transformsForPoints": "преобразования для точек",
    "transformsForPoints": "преобразования для точек",
    "bitbybit.point.transformsForPoints_description": "Применяет разные матрицы трансформации к соответствующим точкам (одна трансформация на точку). Массивы должны иметь одинаковую длину. Пример: 3 точки с 3 разными перемещениями → каждая точка перемещена независимо",
    "Base.TransformMatrixes[]": "массив базовых матриц преобразования",
    "bitbybit.point.translatePoints": "переместить точки",
    "translatePoints": "переместить точки",
    "bitbybit.point.translatePoints_description": "Перемещает несколько точек на вектор перемещения (одинаковое смещение для всех точек). Пример: points=[[0,0,0], [1,0,0]], translation=[5,5,0] → [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "переместить точки векторами",
    "translatePointsWithVectors": "переместить точки векторами",
    "bitbybit.point.translatePointsWithVectors_description": "Перемещает несколько точек на соответствующие векторы перемещения (один вектор на точку). Массивы должны иметь одинаковую длину. Пример: 3 точки с 3 разными векторами → каждая точка перемещена своим вектором",
    "bitbybit.point.translateXYZPoints": "переместить точки xyz",
    "translateXYZPoints": "переместить точки xyz",
    "bitbybit.point.translateXYZPoints_description": "Перемещает несколько точек на отдельные значения X, Y, Z (удобный метод для перемещения). Пример: points=[[0,0,0]], x=10, y=5, z=0 → [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "масштабировать точки центр xyz",
    "scalePointsCenterXYZ": "масштабировать точки центр xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "Масштабирует несколько точек вокруг центральной точки с разными факторами по осям. Пример: points=[[10,0,0]], center=[5,0,0], scaleXyz=[2,1,1] → [[15,0,0]] (удваивает расстояние X от центра)",
    "bitbybit.point.rotatePointsCenterAxis": "вращать точки центр ось",
    "rotatePointsCenterAxis": "вращать точки центр ось",
    "bitbybit.point.rotatePointsCenterAxis_description": "Вращает несколько точек вокруг центральной точки вдоль пользовательской оси. Пример: points=[[10,0,0]], center=[0,0,0], axis=[0,1,0], angle=90° → [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "расстояние до ближайшей точки из точек",
    "closestPointFromPointsDistance": "расстояние до ближайшей точки из точек",
    "bitbybit.point.closestPointFromPointsDistance_description": "Вычисляет расстояние до ближайшей точки в коллекции. Пример: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]] → 3 (расстояние до [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "индекс ближайшей точки из точек",
    "closestPointFromPointsIndex": "индекс ближайшей точки из точек",
    "bitbybit.point.closestPointFromPointsIndex_description": "Находит индекс массива ближайшей точки в коллекции (индекс на основе 1, а не 0). Пример: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]] → 3 (индекс [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "ближайшая точка из точек",
    "closestPointFromPoints": "ближайшая точка из точек",
    "bitbybit.point.closestPointFromPoints_description": "Находит ближайшую точку в коллекции к контрольной точке. Пример: point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]] → [3,0,0]",
    "bitbybit.point.distance": "расстояние",
    "bitbybit.point.distance_description": "Вычисляет евклидово расстояние между двумя точками. Пример: start=[0,0,0], end=[3,4,0] → 5 (используя теорему Пифагора: √(3²+4²))",
    "measure": "измерить",
    "startPoint": "начальная точка",
    "endPoint": "конечная точка",
    "bitbybit.point.distancesToPoints": "расстояния до точек",
    "distancesToPoints": "расстояния до точек",
    "bitbybit.point.distancesToPoints_description": "Вычисляет расстояния от начальной точки до нескольких конечных точек. Пример: start=[0,0,0], endPoints=[[3,0,0], [0,4,0], [5,0,0]] → [3, 4, 5]",
    "endPoints": "конечные точки",
    "bitbybit.point.multiplyPoint": "умножить точку",
    "multiplyPoint": "умножить точку",
    "bitbybit.point.multiplyPoint_description": "Дублирует точку N раз (создает массив с N копиями одной и той же точки). Пример: point=[5,5,0], amountOfPoints=3 → [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "количество точек",
    "bitbybit.point.getX": "получить x",
    "getX": "получить x",
    "bitbybit.point.getX_description": "Извлекает координату X из точки. Пример: point=[5,10,3] → 5",
    "bitbybit.point.getY": "получить y",
    "getY": "получить y",
    "bitbybit.point.getY_description": "Извлекает координату Y из точки. Пример: point=[5,10,3] → 10",
    "bitbybit.point.getZ": "получить z",
    "getZ": "получить z",
    "bitbybit.point.getZ_description": "Извлекает координату Z из точки. Пример: point=[5,10,3] → 3",
    "bitbybit.point.averagePoint": "средняя точка",
    "averagePoint": "средняя точка",
    "bitbybit.point.averagePoint_description": "Вычисляет центроид (среднюю позицию) нескольких точек. Пример: points=[[0,0,0], [10,0,0], [10,10,0]] → [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "точка xyz",
    "pointXYZ": "точка xyz",
    "bitbybit.point.pointXYZ_description": "Создает 3D точку из координат X, Y, Z. Пример: x=10, y=5, z=3 → [10,5,3]",
    "bitbybit.point.pointXY": "точка xy",
    "pointXY": "точка xy",
    "bitbybit.point.pointXY_description": "Создает 2D точку из координат X, Y. Пример: x=10, y=5 → [10,5]",
    "bitbybit.point.spiral": "спираль",
    "spiral": "спираль",
    "bitbybit.point.spiral_description": "Создает точки логарифмической спирали, используя золотой угол или пользовательский фактор расширения. Генерирует естественные спиральные узоры, распространенные в природе (подсолнух, раковина наутилуса). Пример: numberPoints=100, radius=10, phi=1.618 → 100 точек, образующих спираль наружу",
    "phi": "фи",
    "numberPoints": "количество точек",
    "widening": "расширение",
    "factor": "фактор",
    "bitbybit.point.hexGrid": "гексагональная сетка",
    "hexGrid": "гексагональная сетка",
    "bitbybit.point.hexGrid_description": "Создает центральные точки шестиугольной сетки на плоскости XY (сотовый узор). Размер сетки контролируется количеством шестиугольников, а не шириной/высотой. Пример: radiusHexagon=1, nrHexagonsX=3, nrHexagonsY=3 → 9 центров шестиугольников в виде сетки",
    "nrHexagonsY": "кол-во гексагонов по Y",
    "nrHexagonsX": "кол-во гексагонов по X",
    "radiusHexagon": "радиус гексагона",
    "orientOnCenter": "ориентировать по центру",
    "pointsOnGround": "точки на земле",
    "bitbybit.point.removeConsecutiveDuplicates": "удалить последовательные дубликаты",
    "removeConsecutiveDuplicates": "удалить последовательные дубликаты",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Удаляет последовательные повторяющиеся точки из массива в пределах допуска. Пример: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]] → [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "очистить",
    "bitbybit.line.convertToNurbsCurve": "конвертировать в NURBS кривую",
    "line": "линия",
    "convertToNurbsCurve": "конвертировать в NURBS кривую",
    "bitbybit.line.convertToNurbsCurve_description": "конвертирует линию в NURBS кривую",
    "LinePointsDto": "DTO точек линии",
    "bitbybit.line.convertLinesToNurbsCurves": "конвертировать линии в NURBS кривые",
    "convertLinesToNurbsCurves": "конвертировать линии в NURBS кривые",
    "bitbybit.line.convertLinesToNurbsCurves_description": "конвертирует массив линий в массив NURBS кривых",
    "lines": "линии",
    "LinePointsDto[]": "массив DTO точек линии",
    "bitbybit.line.getStartPoint": "получить начальную точку",
    "getStartPoint": "получить начальную точку",
    "bitbybit.line.getStartPoint_description": "Извлекает начальную точку из линии. Пример: line={start:[0,0,0], end:[10,5,0]} → [0,0,0]",
    "bitbybit.line.getEndPoint": "получить конечную точку",
    "getEndPoint": "получить конечную точку",
    "bitbybit.line.getEndPoint_description": "Извлекает конечную точку из линии. Пример: line={start:[0,0,0], end:[10,5,0]} → [10,5,0]",
    "bitbybit.line.length": "длина",
    "bitbybit.line.length_description": "Вычисляет длину (расстояние) отрезка линии. Пример: line={start:[0,0,0], end:[3,4,0]} → 5 (используя теорему Пифагора)",
    "bitbybit.line.reverse": "обратить",
    "reverse": "обратить",
    "bitbybit.line.reverse_description": "Меняет направление линии, меняя местами начальную и конечную точки. Пример: line={start:[0,0,0], end:[10,5,0]} → {start:[10,5,0], end:[0,0,0]}",
    "bitbybit.line.transformLine": "трансформировать линию",
    "transformLine": "трансформировать линию",
    "bitbybit.line.transformLine_description": "Применяет матрицу трансформации к линии (вращает, масштабирует или перемещает обе конечные точки). Пример: line={start:[0,0,0], end:[10,0,0]} с перемещением [5,5,0] → {start:[5,5,0], end:[15,5,0]}",
    "bitbybit.line.transformsForLines": "преобразования для линий",
    "transformsForLines": "преобразования для линий",
    "bitbybit.line.transformsForLines_description": "Применяет несколько трансформаций к нескольким линиям (одна трансформация на линию). Пример: 3 линии с 3 разными матрицами перемещения → каждая линия перемещена независимо",
    "bitbybit.line.create": "создать",
    "bitbybit.line.create_description": "Создает линию из двух точек (объект линии со свойствами start и end). Пример: start=[0,0,0], end=[10,5,0] → {start:[0,0,0], end:[10,5,0]}",
    "bitbybit.line.createAsync": "асинхронно",
    "createAsync": "асинхронно",
    "bitbybit.line.createAsync_description": "создает линию из асинхронных точек",
    "bitbybit.line.getPointOnLine": "получить точку на линии",
    "getPointOnLine": "получить точку на линии",
    "bitbybit.line.getPointOnLine_description": "Вычисляет точку в параметре t вдоль отрезка линии (0=start, 1=end, линейная интерполяция). Пример: line={start:[0,0,0], end:[10,0,0]}, param=0.5 → [5,0,0] (середина)",
    "param": "параметр",
    "bitbybit.line.linesBetweenPoints": "линии между точками",
    "linesBetweenPoints": "линии между точками",
    "bitbybit.line.linesBetweenPoints_description": "Создает отрезки линий, соединяющие последовательные точки в списке (формирует путь полилинии). Пример: points=[[0,0,0], [5,0,0], [5,5,0]] → 2 линии: [0→5] и [5→5,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "линии между начальными и конечными точками",
    "linesBetweenStartAndEndPoints": "линии между начальными и конечными точками",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Создает линии путем сопряжения соответствующих начальных и конечных точек из двух массивов. Отфильтровывает линии нулевой длины. Пример: starts=[[0,0,0], [5,0,0]], ends=[[0,5,0], [5,5,0]] → 2 линии, соединяющие парные точки",
    "startPoints": "начальные точки",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "линии между нач. и кон. точками асинхронно",
    "linesBetweenStartAndEndPointsAsync": "линии между нач. и кон. точками асинхронно",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "создает линии между начальными и конечными точками с асинхронными входами",
    "bitbybit.polyline.convertToNurbsCurve": "конвертировать в NURBS кривую",
    "polyline": "полилиния",
    "bitbybit.polyline.convertToNurbsCurve_description": "конвертирует полилинию в NURBS кривую",
    "PolylinePropertiesDto": "DTO свойств полилинии",
    "bitbybit.polyline.length": "длина",
    "bitbybit.polyline.length_description": "Вычисляет общую длину полилинии путем суммирования расстояний между последовательными точками. Пример: points=[[0,0,0], [3,0,0], [3,4,0]] → 3 + 4 = 7",
    "bitbybit.polyline.countPoints": "количество точек",
    "countPoints": "количество точек",
    "bitbybit.polyline.countPoints_description": "Считает количество точек в полилинии. Пример: полилиния с points=[[0,0,0], [1,0,0], [1,1,0]] → 3",
    "bitbybit.polyline.getPoints": "получить точки",
    "getPoints": "получить точки",
    "bitbybit.polyline.getPoints_description": "Извлекает массив точек из объекта полилинии. Пример: polyline={points:[[0,0,0], [1,0,0]]} → [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "обратить",
    "bitbybit.polyline.reverse_description": "Меняет порядок точек полилинии на обратный (меняет направление). Пример: points=[[0,0,0], [1,0,0], [2,0,0]] → [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "трансформировать полилинию",
    "transformPolyline": "трансформировать полилинию",
    "bitbybit.polyline.transformPolyline_description": "Применяет матрицу трансформации ко всем точкам в полилинии (вращает, масштабирует или перемещает). Пример: полилиния с 4 точками, перемещение [5,0,0] → все точки перемещены на +5 по оси X",
    "bitbybit.polyline.create": "создать",
    "bitbybit.polyline.create_description": "Создает полилинию из массива точек с опциональным флагом isClosed. Пример: points=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true → {points:..., isClosed:true}",
    "isClosed": "замкнутая",
    "string | number[]": "строка | массив чисел",
    "bitbybit.occt.deleteShape": "удалить форму",
    "occt": "occt",
    "deleteShape": "удалить форму",
    "bitbybit.occt.deleteShape_description": "Удаляет форму из кэша для поддержания низкого использования памяти",
    "bitbybit.occt.deleteShapes": "удалить формы",
    "deleteShapes": "удалить формы",
    "bitbybit.occt.deleteShapes_description": "Удаляет формы из кэша для поддержания низкого использования памяти",
    "shapes": "формы",
    "T[]": "массив T",
    "bitbybit.occt.cleanAllCache": "очистить весь кэш",
    "cleanAllCache": "очистить весь кэш",
    "bitbybit.occt.cleanAllCache_description": "Очищает весь кэш и все формы из памяти",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "вершина из xyz",
    "vertex": "вершина",
    "vertexFromXYZ": "вершина из xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Создает форму вершины из координат x y z",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "вершина из точки",
    "vertexFromPoint": "вершина из точки",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Создает форму вершины из точки",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "вершины из точек",
    "verticesFromPoints": "вершины из точек",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "создает вершины из точек",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "составная форма вершин из точек",
    "verticesCompoundFromPoints": "составная форма вершин из точек",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Создает составную форму, содержащую несколько вершин. Это просто ускоряет рендеринг и позволяет легко применять трансформации occt к группам вершин.",
    "bitbybit.occt.shapes.vertex.getVertices": "получить вершины",
    "getVertices": "получить вершины",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Получить все вершины в списке формы",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "получить вершины как точки",
    "getVerticesAsPoints": "получить вершины как точки",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Получить все вершины в списке формы как точки",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "вершины в точки",
    "verticesToPoints": "вершины в точки",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "преобразует вершины в точки",
    "transform": "преобразовать",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "вершина в точку",
    "vertexToPoint": "вершина в точку",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Преобразовать вершину в точку",
    "bitbybit.occt.shapes.vertex.projectPoints": "проектировать точки",
    "projectPoints": "проектировать точки",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "проектирует точки на форму",
    "place": "разместить",
    "projectionType": "тип проекции",
    "pointProjectionTypeEnum": "перечисление типа проекции точки",
    "bitbybit.occt.shapes.edge.line": "линия",
    "edge": "ребро",
    "bitbybit.occt.shapes.edge.line_description": "создает линейное ребро между двумя точками",
    "primitives": "примитивы",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "дуга через три точки",
    "arcThroughThreePoints": "дуга через три точки",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Создает дуговое ребро между тремя точками",
    "middle": "средняя",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "дуга через две точки и касательную",
    "arcThroughTwoPointsAndTangent": "дуга через две точки и касательную",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Создает дуговое ребро между двумя точками с заданным вектором касательной в первой точке.",
    "tangentVec": "вектор касательной",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "дуга из окружности и двух точек",
    "arcFromCircleAndTwoPoints": "дуга из окружности и двух точек",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Создает дуговое ребро между двумя точками на окружности",
    "circle": "окружность",
    "sense": "направление",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "дуга из окружности и двух углов",
    "arcFromCircleAndTwoAngles": "дуга из окружности и двух углов",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Создает дуговое ребро между двумя углами альфа на окружности",
    "alphaAngle1": "альфа угол 1",
    "alphaAngle2": "альфа угол 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "дуга из окружности, точки и угла",
    "arcFromCirclePointAndAngle": "дуга из окружности, точки и угла",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Создает дуговое ребро между точкой на окружности и заданным углом альфа",
    "alphaAngle": "альфа угол",
    "bitbybit.occt.shapes.edge.createCircleEdge": "ребро-окружность",
    "createCircleEdge": "создать ребро-окружность",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "создает ребро-окружность OpenCascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "ребро-эллипс",
    "createEllipseEdge": "создать ребро-эллипс",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "создает ребро-эллипс OpenCascade",
    "radiusMinor": "малый радиус",
    "radiusMajor": "большой радиус",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "удалить внутренние рёбра",
    "removeInternalEdges": "удалить внутренние рёбра",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Удаляет внутренние грани для формы",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "создать ребро из 2d кривой и поверхности",
    "makeEdgeFromGeom2dCurveAndSurface": "создать ребро из 2d кривой и поверхности",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Создает ребро из геометрической кривой и геометрической поверхности",
    "curve": "кривая",
    "surface": "поверхность",
    "U": "U",
    "bitbybit.occt.shapes.edge.getEdge": "получить ребро",
    "getEdge": "получить ребро",
    "bitbybit.occt.shapes.edge.getEdge_description": "Получает ребро, предоставляя индекс из формы",
    "index": "индекс",
    "bitbybit.occt.shapes.edge.getEdges": "получить рёбра",
    "getEdges": "получить рёбра",
    "bitbybit.occt.shapes.edge.getEdges_description": "Получает ребра формы в виде списка",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "получить рёбра вдоль контура",
    "getEdgesAlongWire": "получить рёбра вдоль контура",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Получает ребра проволоки, упорядоченные вдоль направления проволоки",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "получить круговые рёбра вдоль контура",
    "getCircularEdgesAlongWire": "получить круговые рёбра вдоль контура",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Получает круглые ребра проволоки, упорядоченные вдоль направления проволоки",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "получить линейные рёбра вдоль контура",
    "getLinearEdgesAlongWire": "получить линейные рёбра вдоль контура",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Получает линейные ребра проволоки, упорядоченные вдоль направления проволоки",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "получить угловые точки рёбер для формы",
    "getCornerPointsOfEdgesForShape": "получить угловые точки рёбер для формы",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Получает угловые точки ребер для формы. Здесь нет гарантии порядка. Все дубликаты удаляются, поэтому, когда три ребра образуют один угол, это будет представлено одной точкой в списке.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "получить длину ребра",
    "getEdgeLength": "получить длину ребра",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Получает длину ребра",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "получить длины рёбер формы",
    "getEdgeLengthsOfShape": "получить длины рёбер формы",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Получает длины ребер формы",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "получить длины рёбер",
    "getEdgesLengths": "получить длины рёбер",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Получает длины ребер",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "получить центр масс ребра",
    "getEdgeCenterOfMass": "получить центр масс ребра",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Получает центр масс для ребра",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "получить центры масс рёбер",
    "getEdgesCentersOfMass": "получить центры масс рёбер",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Получает центры масс для ребер",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "получить центр кругового ребра",
    "getCircularEdgeCenterPoint": "получить центр кругового ребра",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Получает центральную точку круглого ребра. Если ребро не круглое, точка не будет возвращена.",
    "get circular edge": "получить круговое ребро",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "получить радиус кругового ребра",
    "getCircularEdgeRadius": "получить радиус кругового ребра",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Получает радиус круглого ребра. Если ребро не круглое, радиус не будет возвращен.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "получить направление плоскости кругового ребра",
    "getCircularEdgePlaneDirection": "получить направление плоскости кругового ребра",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Получает вектор направления плоскость круглого ребра. Если ребро не круглое, вектор направления не будет возвращен.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "точка на ребре по параметру",
    "pointOnEdgeAtParam": "точка на ребре по параметру",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Получает точку на ребре по параметру",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "точки на рёбрах по параметру",
    "pointsOnEdgesAtParam": "точки на рёбрах по параметру",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Получает точки на ребрах по параметру",
    "bitbybit.occt.shapes.edge.edgesToPoints": "рёбра в точки",
    "edgesToPoints": "рёбра в точки",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Получает точки всех ребер из формы в отдельных списках для каждого ребра",
    "angularDeflection": "угловое отклонение",
    "curvatureDeflection": "отклонение кривизны",
    "minimumOfPoints": "минимум точек",
    "uTolerance": "допуск U",
    "minimumLength": "минимальная длина",
    "bitbybit.occt.shapes.edge.reversedEdge": "обратное ребро",
    "reversedEdge": "обратное ребро",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Вычисляет перевернутое ребро из входного ребра",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "касательная на ребре по параметру",
    "tangentOnEdgeAtParam": "касательная на ребре по параметру",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Получает касательный вектор на ребре по параметру",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "касательные на рёбрах по параметру",
    "tangentsOnEdgesAtParam": "касательные на рёбрах по параметру",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Получает касательные векторы на ребрах по параметру",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "точка на ребре по длине",
    "pointOnEdgeAtLength": "точка на ребре по длине",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Получает точку на ребре по длине",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "точки на рёбрах по длине",
    "pointsOnEdgesAtLength": "точки на рёбрах по длине",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Получает точки на ребрах по длине",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "касательная на ребре по длине",
    "tangentOnEdgeAtLength": "касательная на ребре по длине",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Получает касательный вектор на ребре по длине",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "касательные на рёбрах по длине",
    "tangentsOnEdgesAtLength": "касательные на рёбрах по длине",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Получает касательные векторы на ребрах по длине",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "начальная точка на ребре",
    "startPointOnEdge": "начальная точка на ребре",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Получает начальную точку на ребре",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "начальные точки на рёбрах",
    "startPointsOnEdges": "начальные точки на рёбрах",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Получает начальные точки на ребрах",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "конечная точка на ребре",
    "endPointOnEdge": "конечная точка на ребре",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Получает конечную точку на ребре",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "конечные точки на рёбрах",
    "endPointsOnEdges": "конечные точки на рёбрах",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Получает конечные точки на ребрах",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "разделить ребро по параметрам на точки",
    "divideEdgeByParamsToPoints": "разделить ребро по параметрам на точки",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "делит ребро на точки по параметрам",
    "nrOfDivisions": "кол-во делений",
    "removeStartPoint": "удалить начальную точку",
    "removeEndPoint": "удалить конечную точку",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "разделить рёбра по параметрам на точки",
    "divideEdgesByParamsToPoints": "разделить рёбра по параметрам на точки",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "делит рёбра на точки по параметрам",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "разделить ребро на равные расстояния точками",
    "divideEdgeByEqualDistanceToPoints": "разделить ребро на равные расстояния точками",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "делит ребро на точки по длине",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "разделить рёбра на равные расстояния точками",
    "divideEdgesByEqualDistanceToPoints": "разделить рёбра на равные расстояния точками",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "делит рёбра на точки по длине",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "огр: касательные линии от 2 точек к окружности",
    "constraintTanLinesFromTwoPtsToCircle": "огр: касательные линии от 2 точек к окружности",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Создает линии от двух заданных точек до точек касания окружности",
    "constraint": "ограничение",
    "point1": "точка 1",
    "point2": "точка 2",
    "positionResult": "результат позиции",
    "positionResultEnum": "перечисление результата позиции",
    "circleRemainder": "остаток окружности",
    "circleInclusionEnum": "перечисление включения окружности",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "огр: касательные линии от точки к окружности",
    "constraintTanLinesFromPtToCircle": "огр: касательные линии от точки к окружности",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Создает линии от заданной точки до точек касания окружности",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "огр: касательные линии на двух окружностях",
    "constraintTanLinesOnTwoCircles": "огр: касательные линии на двух окружностях",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Создает касательные линии между двумя окружностями.",
    "circle1": "окружность 1",
    "circle2": "окружность 2",
    "circleRemainders": "остатки окружностей",
    "twoCircleInclusionEnum": "перечисление включения двух окружностей",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "огр: касательные окружности на двух окружностях",
    "constraintTanCirclesOnTwoCircles": "огр: касательные окружности на двух окружностях",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Создает касательные окружности между двумя окружностями.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "огр: касательные окружности на окружности и точке",
    "constraintTanCirclesOnCircleAndPnt": "огр: касательные окружности на окружности и точке",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Создает касательные окружности между точкой и окружностью.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "ребро линейное",
    "isEdgeLinear": "ребро линейное",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Проверяет, является ли ребро линейным",
    "is": "является",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "ребро круговое",
    "isEdgeCircular": "ребро круговое",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Проверяет, является ли ребро круглым",
    "bitbybit.occt.shapes.wire.createPolygonWire": "контур полигона",
    "wire": "контур",
    "createPolygonWire": "создать контур полигона",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "создает контур полигона OpenCascade",
    "via points": "через точки",
    "bitbybit.occt.shapes.wire.createPolygons": "полигоны",
    "createPolygons": "создать полигоны",
    "bitbybit.occt.shapes.wire.createPolygons_description": "создает полигоны OpenCascade",
    "multiple": "множественные",
    "polygons": "полигоны",
    "PolygonDto[]": "массив DTO полигонов",
    "returnCompound": "вернуть составную форму",
    "bitbybit.occt.shapes.wire.createLineWire": "контур линии",
    "createLineWire": "создать контур линии",
    "bitbybit.occt.shapes.wire.createLineWire_description": "создает контур линии OpenCascade",
    "bitbybit.occt.shapes.wire.createLines": "линии",
    "createLines": "создать линии",
    "bitbybit.occt.shapes.wire.createLines_description": "создает линии OpenCascade",
    "LineDto[]": "массив DTO линий",
    "bitbybit.occt.shapes.wire.splitOnPoints": "разделить по точкам",
    "splitOnPoints": "разделить по точкам",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Разделяет проволоку по набору заданных точек",
    "bitbybit.occt.shapes.wire.wiresToPoints": "контуры в точки",
    "wiresToPoints": "контуры в точки",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Преобразовать проволоки формы в точки, упорядоченные в списках. Это также удаляет дублирующиеся точки между начальной и конечной точками последовательных ребер на проволоке",
    "bitbybit.occt.shapes.wire.createPolylineWire": "контур полилинии",
    "createPolylineWire": "создать контур полилинии",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "создает контур полилинии OpenCascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "зигзаг между двумя контурами",
    "createZigZagBetweenTwoWires": "создать зигзаг между двумя контурами",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "создает зигзаг между двумя контурами",
    "via wires": "через контуры",
    "wire1": "контур 1",
    "wire2": "контур 2",
    "nrZigZags": "кол-во зигзагов",
    "inverse": "инвертировать",
    "divideByEqualDistance": "разделить на равные расстояния",
    "zigZagsPerEdge": "зигзагов на ребро",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "контур из касательных к двум окружностям",
    "createWireFromTwoCirclesTan": "создать контур из касательных к двум окружностям",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Создает касательную проволоку, охватывающую две плоские окружности",
    "keepLines": "сохранить линии",
    "twoSidesStrictEnum": "перечисление строгих двух сторон",
    "fourSidesStrictEnum": "перечисление строгих четырех сторон",
    "bitbybit.occt.shapes.wire.createPolylines": "полилинии",
    "createPolylines": "создать полилинии",
    "bitbybit.occt.shapes.wire.createPolylines_description": "создает контуры полилиний OpenCascade",
    "polylines": "полилинии",
    "PolylineDto[]": "массив DTO полилиний",
    "bitbybit.occt.shapes.wire.createBezier": "Безье",
    "createBezier": "создать Безье",
    "bitbybit.occt.shapes.wire.createBezier_description": "создает контур Безье OpenCascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "веса Безье",
    "createBezierWeights": "создать Безье с весами",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "создает контур Безье OpenCascade с весами",
    "weights": "веса",
    "bitbybit.occt.shapes.wire.createBezierWires": "контуры Безье",
    "createBezierWires": "создать контуры Безье",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "создает контуры Безье OpenCascade",
    "bezierWires": "контуры Безье",
    "BezierDto[]": "массив DTO Безье",
    "bitbybit.occt.shapes.wire.interpolatePoints": "интерполировать точки",
    "interpolatePoints": "интерполировать точки",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Создает проволоку OpenCascade BSpline из точек. Этот метод можно использовать для создания петель красивой формы (периодических).",
    "periodic": "периодический",
    "bitbybit.occt.shapes.wire.interpolateWires": "интерполировать контуры",
    "interpolateWires": "интерполировать контуры",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Создает несколько интерполированных проволок OpenCascade",
    "interpolations": "интерполяции",
    "InterpolationDto[]": "массив DTO интерполяций",
    "bitbybit.occt.shapes.wire.createBSpline": "B-сплайн",
    "createBSpline": "создать B-сплайн",
    "bitbybit.occt.shapes.wire.createBSpline_description": "создает B-сплайн контур OpenCascade",
    "bitbybit.occt.shapes.wire.createBSplines": "B-сплайны",
    "createBSplines": "создать B-сплайны",
    "bitbybit.occt.shapes.wire.createBSplines_description": "создает B-сплайн контуры OpenCascade",
    "bSplines": "B-сплайны",
    "BSplineDto[]": "массив DTO B-сплайнов",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "объединить рёбра и контуры в один контур",
    "combineEdgesAndWiresIntoAWire": "объединить рёбра и контуры в контур",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Объединяет ребра и проволоки OpenCascade в одну проволоку",
    "build": "построить",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "контур из ребра",
    "createWireFromEdge": "создать контур из ребра",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "создает контур из ребра",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "добавить рёбра и контуры к контуру",
    "addEdgesAndWiresToWire": "добавить рёбра и контуры к контуру",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Добавляет ребра и проволоки OpenCascade в другую проволоку",
    "U[]": "массив U",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "разделить контур по параметрам на точки",
    "divideWireByParamsToPoints": "разделить контур по параметрам на точки",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Разделяет проволоку OpenCascade на точки, слепо следуя ее параметрическому пространству",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "разделить контуры по параметрам на точки",
    "divideWiresByParamsToPoints": "разделить контуры по параметрам на точки",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Разделяет проволоки OpenCascade на точки, слепо следуя их параметрическому пространству",
    "extract from wires": "извлечь из контуров",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "разделить контур на равные расстояния точками",
    "divideWireByEqualDistanceToPoints": "разделить контур на равные расстояния точками",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Разделяет проволоку OpenCascade на точки на равном расстоянии",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "разделить контуры на равные расстояния точками",
    "divideWiresByEqualDistanceToPoints": "разделить контуры на равные расстояния точками",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Разделяет проволоки OpenCascade на точки на равном расстоянии",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "точка на контуре по параметру",
    "pointOnWireAtParam": "точка на контуре по параметру",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Оценивает точку на проволоке при значении параметра от 0 до 1, являющегося начальной и конечной точками",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "точка на контуре по длине",
    "pointOnWireAtLength": "точка на контуре по длине",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Оценивает точку на проволоке на определенной длине",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "точки на контуре по длинам",
    "pointsOnWireAtLengths": "точки на контуре по длинам",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Оценивает точки на проволоке на определенных длинах",
    "lengths": "длины",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "точки на контуре на равной длине",
    "pointsOnWireAtEqualLength": "точки на контуре на равной длине",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Оценивает точки на проволоке на равной длине",
    "tryNext": "попробовать следующий",
    "includeFirst": "включить первый",
    "includeLast": "включить последний",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "точки на контуре по шаблону длин",
    "pointsOnWireAtPatternOfLengths": "точки на контуре по шаблону длин",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Оценивает точки на проволоке по шаблону длин",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "касательная на контуре по параметру",
    "tangentOnWireAtParam": "касательная на контуре по параметру",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Оценивает касательный вектор на проволоке при значении параметра от 0 до 1, являющегося начальной и конечной точками",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "касательная на контуре по длине",
    "tangentOnWireAtLength": "касательная на контуре по длине",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Оценивает касательный вектор на проволоке на определенной длине",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "производные на контуре по длине",
    "derivativesOnWireAtLength": "производные на контуре по длине",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Вычисляет 3 производных вектора кривой на заданной длине",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "производные на контуре по параметру",
    "derivativesOnWireAtParam": "производные на контуре по параметру",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Вычисляет 3 производных вектора кривой на параметре от 0 до 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "начальная точка на контуре",
    "startPointOnWire": "начальная точка на контуре",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Вычисляет начальную точку на проволоке при параметре 0",
    "bitbybit.occt.shapes.wire.endPointOnWire": "конечная точка на контуре",
    "endPointOnWire": "конечная точка на контуре",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Вычисляет конечную точку на проволоке при параметре 1",
    "bitbybit.occt.shapes.wire.createCircleWire": "контур-окружность",
    "createCircleWire": "создать контур-окружность",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "создает контур-окружность OpenCascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "контур-квадрат",
    "createSquareWire": "создать контур-квадрат",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "создает контур-квадрат OpenCascade",
    "bitbybit.occt.shapes.wire.createStarWire": "контур-звезда",
    "createStarWire": "создать контур-звезду",
    "bitbybit.occt.shapes.wire.createStarWire_description": "создает контур-звезду OpenCascade",
    "numRays": "кол-во лучей",
    "outerRadius": "внешний радиус",
    "innerRadius": "внутренний радиус",
    "offsetOuterEdges": "смещение внешних рёбер",
    "half": "половина",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "контур-ёлка",
    "createChristmasTreeWire": "создать контур-ёлку",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "создает контур-ёлку",
    "innerDist": "внутреннее расстояние",
    "outerDist": "внешнее расстояние",
    "nrSkirts": "кол-во юбок",
    "trunkHeight": "высота ствола",
    "trunkWidth": "ширина ствола",
    "bitbybit.occt.shapes.wire.createNGonWire": "контур-n-угольник",
    "createNGonWire": "создать контур-n-угольник",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Создает n-угольную проволоку OpenCascade",
    "nrCorners": "кол-во углов",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "контур-параллелограмм",
    "createParallelogramWire": "создать контур-параллелограмм",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Создает проволоку параллелограмм",
    "aroundCenter": "вокруг центра",
    "bitbybit.occt.shapes.wire.createHeartWire": "контур-сердце",
    "createHeartWire": "создать контур-сердце",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Создает проволоку в форме сердца",
    "sizeApprox": "приблиз. размер",
    "bitbybit.occt.shapes.wire.createRectangleWire": "контур-прямоугольник",
    "createRectangleWire": "создать контур-прямоугольник",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "создает контур-прямоугольник OpenCascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "L-образный контур",
    "createLPolygonWire": "создать L-образный контур",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "создает L-образный контур OpenCascade",
    "widthFirst": "ширина первая",
    "lengthFirst": "длина первая",
    "widthSecond": "ширина вторая",
    "lengthSecond": "длина вторая",
    "align": "выровнять",
    "directionEnum": "перечисление направления",
    "bitbybit.occt.shapes.wire.createEllipseWire": "контур-эллипс",
    "createEllipseWire": "создать контур-эллипс",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "создает контур-эллипс OpenCascade",
    "bitbybit.occt.shapes.wire.textWires": "Текстовые контуры",
    "textWires": "Текстовые контуры",
    "bitbybit.occt.shapes.wire.textWires_description": "Создает текстовые контуры OpenCascade на основе шрифта simplex, созданного доктором А. В. Херши.",
    "xOffset": "Смещение по x",
    "yOffset": "Смещение по y",
    "letterSpacing": "Межбуквенный интервал",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "Смещение выдавливания",
    "bitbybit.occt.shapes.wire.getWire": "получить контур",
    "getWire": "получить контур",
    "bitbybit.occt.shapes.wire.getWire_description": "Получает проволоку, предоставляя индекс из формы",
    "bitbybit.occt.shapes.wire.getWires": "получить контуры",
    "getWires": "получить контуры",
    "bitbybit.occt.shapes.wire.getWires_description": "Получает все проволоки из формы",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "получить центр масс контура",
    "getWireCenterOfMass": "получить центр масс контура",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Получить точку центра масс проволоки",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "получить центры масс контуров",
    "getWiresCentersOfMass": "получить центры масс контуров",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Получить точки центров масс проволок",
    "bitbybit.occt.shapes.wire.reversedWire": "обратный контур",
    "reversedWire": "обратный контур",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Вычисляет перевернутую проволоку из входной проволоки",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "обратный контур из обратных рёбер",
    "reversedWireFromReversedEdges": "обратный контур из обратных рёбер",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Вычисляет перевернутую проволоку путем переворачивания всех ребер и объединения их в новую проволоку",
    "bitbybit.occt.shapes.wire.isWireClosed": "контур замкнут",
    "isWireClosed": "контур замкнут",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Проверяет, замкнута ли проволока",
    "bitbybit.occt.shapes.wire.getWireLength": "получить длину контура",
    "getWireLength": "получить длину контура",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Получает длину проволоки",
    "bitbybit.occt.shapes.wire.getWiresLengths": "получить длины контуров",
    "getWiresLengths": "получить длины контуров",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Получает длины проволок",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "разместить контур на грани",
    "placeWireOnFace": "разместить контур на грани",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Размещает проволоку на грани, отображая ее 2d координаты в UV пространство. Проволока должна быть расположена на плоскости земли XZ, чтобы это сработало.",
    "face": "грань",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "разместить контуры на грани",
    "placeWiresOnFace": "разместить контуры на грани",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Размещает несколько проволок на грани, отображая их 2d координаты в UV пространство. Проволоки должны быть расположены на плоскости земли XZ, чтобы это сработало.",
    "wires": "контуры",
    "bitbybit.occt.shapes.wire.closeOpenWire": "замкнуть открытый контур",
    "closeOpenWire": "замкнуть открытый контур",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Замыкает открытую проволоку дополнительным прямым ребром, соединяющим начальную и конечную точки",
    "bitbybit.occt.shapes.wire.project": "проектировать",
    "project": "проектировать",
    "bitbybit.occt.shapes.wire.project_description": "Спроецировать проволоку на форму",
    "bitbybit.occt.shapes.wire.projectWires": "проектировать контуры",
    "projectWires": "проектировать контуры",
    "bitbybit.occt.shapes.wire.projectWires_description": "Спроецировать несколько проволок на форму",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "грани из контуров на грани",
    "createFacesFromWiresOnFace": "создать грани из контуров на грани",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Создает грани из проволок на грани",
    "inside": "внутри",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "грань из контура на грани",
    "createFaceFromWireOnFace": "создать грань из контура на грани",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Создает грань из проволоки на грани",
    "bitbybit.occt.shapes.face.createFaceFromWire": "грань из контура",
    "createFaceFromWire": "создать грань из контура",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Создает грань из проволоки",
    "planar": "плоский",
    "bitbybit.occt.shapes.face.createFaceFromWires": "грань из контуров",
    "createFaceFromWires": "создать грань из контуров",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Создает грань из проволок. Это может создавать полые грани.",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "грань из контуров на грани",
    "createFaceFromWiresOnFace": "создать грань из контуров на грани",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Создает грань из проволок на направляющей грани. Это может создавать полые грани.",
    "bitbybit.occt.shapes.face.createFacesFromWires": "грани из контуров",
    "createFacesFromWires": "создать грани из контуров",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "создает грани из контуров",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "грань из нескольких касательных контуров к окружностям",
    "createFaceFromMultipleCircleTanWires": "создать грань из нескольких касательных контуров к окружностям",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "создает грань из нескольких касательных контуров к окружностям",
    "circles": "окружности",
    "combination": "комбинация",
    "combinationCirclesForFaceEnum": "перечисление комбинации окружностей для грани",
    "unify": "объединить",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "грань из коллекций касательных контуров к окружностям",
    "createFaceFromMultipleCircleTanWireCollections": "создать грань из коллекций касательных контуров к окружностям",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "создает грань из коллекций касательных контуров к окружностям",
    "listsOfCircles": "списки окружностей",
    "T[][]": "массив массивов T",
    "bitbybit.occt.shapes.face.faceFromSurface": "грань из поверхности",
    "faceFromSurface": "создать грань из поверхности",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Создает грань из поверхности",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "грань из поверхности и контура",
    "faceFromSurfaceAndWire": "создать грань из поверхности и контура",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Создает грань из поверхности и проволоки",
    "bitbybit.occt.shapes.face.createPolygonFace": "грань-полигон",
    "createPolygonFace": "создать грань-полигон",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "создает грань-полигон OpenCascade",
    "bitbybit.occt.shapes.face.createCircleFace": "грань-окружность",
    "createCircleFace": "создать грань-окружность",
    "bitbybit.occt.shapes.face.createCircleFace_description": "создает грань-окружность OpenCascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "грань-эллипс",
    "createEllipseFace": "создать грань-эллипс",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "создает грань-эллипс OpenCascade",
    "bitbybit.occt.shapes.face.createSquareFace": "грань-квадрат",
    "createSquareFace": "создать грань-квадрат",
    "bitbybit.occt.shapes.face.createSquareFace_description": "создает грань-квадрат OpenCascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "грань-прямоугольник",
    "createRectangleFace": "создать грань-прямоугольник",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "создает грань-прямоугольник OpenCascade",
    "bitbybit.occt.shapes.face.getFace": "получить грань",
    "getFace": "получить грань",
    "bitbybit.occt.shapes.face.getFace_description": "Получает грань, предоставляя индекс из формы",
    "bitbybit.occt.shapes.face.getFaces": "получить грани",
    "getFaces": "получить грани",
    "bitbybit.occt.shapes.face.getFaces_description": "Получает грани формы в виде списка",
    "bitbybit.occt.shapes.face.reversedFace": "обратная грань",
    "reversedFace": "обратная грань",
    "bitbybit.occt.shapes.face.reversedFace_description": "Вычисляет перевернутую грань из входной грани",
    "bitbybit.occt.shapes.face.subdivideToPoints": "разделить на точки",
    "subdivideToPoints": "разделить на точки",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Подразделяет грань на сетку точек",
    "nrDivisionsU": "кол-во делений U",
    "nrDivisionsV": "кол-во делений V",
    "shiftHalfStepU": "сдвиг на полшага U",
    "removeStartEdgeU": "удалить начальное ребро U",
    "removeEndEdgeU": "удалить конечное ребро U",
    "shiftHalfStepV": "сдвиг на полшага V",
    "removeStartEdgeV": "удалить начальное ребро V",
    "removeEndEdgeV": "удалить конечное ребро V",
    "bitbybit.occt.shapes.face.subdivideToWires": "разделить на контуры",
    "subdivideToWires": "разделить на контуры",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Подразделяет грань на проволоки",
    "nrDivisions": "кол-во делений",
    "isU": "является U",
    "shiftHalfStep": "сдвиг на полшага",
    "removeStart": "удалить начало",
    "removeEnd": "удалить конец",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "разделить на прямоугольные контуры",
    "subdivideToRectangleWires": "разделить на прямоугольные контуры",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Подразделяет грань на прямоугольные проволоки",
    "patterns": "шаблоны",
    "nrRectanglesU": "кол-во прямоугольников U",
    "nrRectanglesV": "кол-во прямоугольников V",
    "scalePatternU": "масштаб шаблона U",
    "scalePatternV": "масштаб шаблона V",
    "filletPattern": "шаблон скругления",
    "inclusionPattern": "шаблон включения",
    "offsetFromBorderU": "смещение от границы U",
    "offsetFromBorderV": "смещение от границы V",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "разделить на прямоугольные отверстия",
    "subdivideToRectangleHoles": "разделить на прямоугольные отверстия",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Подразделяет грань на прямоугольные проволоки",
    "holesToFaces": "отверстия в грани",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "разделить на точки (контролируемо)",
    "subdivideToPointsControlled": "разделить на точки (контролируемо)",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Подразделяет грань на сетку точек со сдвигами и удалениями на n-ых строках или столбцах uv",
    "shiftHalfStepNthU": "сдвиг на полшага каждый N-й U",
    "shiftHalfStepUOffsetN": "сдвиг на полшага U смещение N",
    "removeStartEdgeNthU": "удалить начальное ребро каждый N-й U",
    "removeStartEdgeUOffsetN": "удалить начальное ребро U смещение N",
    "removeEndEdgeNthU": "удалить конечное ребро каждый N-й U",
    "removeEndEdgeUOffsetN": "удалить конечное ребро U смещение N",
    "shiftHalfStepNthV": "сдвиг на полшага каждый N-й V",
    "shiftHalfStepVOffsetN": "сдвиг на полшага V смещение N",
    "removeStartEdgeNthV": "удалить начальное ребро каждый N-й V",
    "removeStartEdgeVOffsetN": "удалить начальное ребро V смещение N",
    "removeEndEdgeNthV": "удалить конечное ребро каждый N-й V",
    "removeEndEdgeVOffsetN": "удалить конечное ребро V смещение N",
    "bitbybit.occt.shapes.face.subdivideToNormals": "разделить на нормали",
    "subdivideToNormals": "разделить на нормали",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Подразделяет грань на сетку нормалей",
    "bitbybit.occt.shapes.face.subdivideToUV": "разделить на UV",
    "subdivideToUV": "разделить на UV",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Подразделяет грань на сетку uv",
    "bitbybit.occt.shapes.face.pointOnUV": "точка на UV",
    "pointOnUV": "точка на UV",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Получить точку на UV, где U и V описаны от 0 до 1. Они будут отображены на реальные границы.",
    "paramU": "параметр U",
    "paramV": "параметр V",
    "bitbybit.occt.shapes.face.normalOnUV": "нормаль на UV",
    "normalOnUV": "нормаль на UV",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Получить нормаль на UV, где U и V описаны от 0 до 1. Они будут отображены на реальные границы.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "точки на UVs",
    "pointsOnUVs": "точки на UVs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Получить точки на UV, где U и V описаны от 0 до 1 в двумерных массивах. Они будут отображены на реальные границы.",
    "paramsUV": "параметры UV",
    "[number, number][]": "массив пар чисел",
    "bitbybit.occt.shapes.face.normalsOnUVs": "нормали на UVs",
    "normalsOnUVs": "нормали на UVs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Получить нормали на UV, где U и V описаны от 0 до 1 в двумерных массивах. Они будут отображены на реальные границы.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "разделить на точки по параметру",
    "subdivideToPointsOnParam": "разделить на точки по параметру",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Подразделяет грань на точки вдоль линии по параметру",
    "nrPoints": "кол-во точек",
    "bitbybit.occt.shapes.face.wireAlongParam": "контур вдоль параметра",
    "wireAlongParam": "контур вдоль параметра",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Получает проволоку вдоль параметра на грани",
    "bitbybit.occt.shapes.face.wiresAlongParams": "контуры вдоль параметров",
    "wiresAlongParams": "контуры вдоль параметров",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Получает проволоки вдоль параметров на грани",
    "params": "параметры",
    "bitbybit.occt.shapes.face.getUMinBound": "получить мин. границу U",
    "getUMinBound": "получить мин. границу U",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Получает минимальную границу U грани",
    "bitbybit.occt.shapes.face.getUMaxBound": "получить макс. границу U",
    "getUMaxBound": "получить макс. границу U",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Получает максимальную границу U грани",
    "bitbybit.occt.shapes.face.getVMinBound": "получить мин. границу V",
    "getVMinBound": "получить мин. границу V",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Получает минимальную границу V грани",
    "bitbybit.occt.shapes.face.getVMaxBound": "получить макс. границу V",
    "getVMaxBound": "получить макс. границу V",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Получает максимальную границу V грани",
    "bitbybit.occt.shapes.face.getFaceArea": "получить площадь грани",
    "getFaceArea": "получить площадь грани",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Получить площадь грани",
    "bitbybit.occt.shapes.face.getFacesAreas": "получить площади граней",
    "getFacesAreas": "получить площади граней",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Получить площади граней",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "получить центр масс грани",
    "getFaceCenterOfMass": "получить центр масс грани",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Получить точку центра масс грани",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "получить центры масс граней",
    "getFacesCentersOfMass": "получить центры масс граней",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Получить точки центров масс для граней",
    "bitbybit.occt.shapes.face.filterFacePoints": "фильтровать точки грани",
    "filterFacePoints": "фильтровать точки грани",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "фильтрует точки на грани",
    "filter": "фильтр",
    "useBndBox": "использовать огр. бокс",
    "gapTolerance": "допуск зазора",
    "keepIn": "оставить внутри",
    "keepOn": "оставить на",
    "keepOut": "оставить снаружи",
    "keepUnknown": "оставить неизвестные",
    "bitbybit.occt.shapes.face.filterFacesPoints": "фильтровать точки граней",
    "filterFacesPoints": "фильтровать точки граней",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "фильтрует точки на гранях",
    "flatPointsArray": "плоский массив точек",
    "bitbybit.occt.shapes.shell.sewFaces": "сшить грани",
    "shell": "оболочка",
    "sewFaces": "сшить грани",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Создает оболочку из граней",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "получить площадь поверхности оболочки",
    "getShellSurfaceArea": "получить площадь поверхности оболочки",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Получить площадь поверхности оболочки",
    "bitbybit.occt.shapes.solid.fromClosedShell": "из замкнутой оболочки",
    "solid": "твёрдое тело",
    "fromClosedShell": "из замкнутой оболочки",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Создает Тело из оболочки, которая должна быть замкнутой",
    "bitbybit.occt.shapes.solid.createBox": "параллелепипед",
    "bitbybit.occt.shapes.solid.createBox_description": "создает параллелепипед OpenCascade",
    "originOnCenter": "начало координат в центре",
    "bitbybit.occt.shapes.solid.createCube": "куб",
    "bitbybit.occt.shapes.solid.createCube_description": "создает куб OpenCascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "параллелепипед из угла",
    "createBoxFromCorner": "создать параллелепипед из угла",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "создает параллелепипед OpenCascade из угла",
    "corner": "угол",
    "bitbybit.occt.shapes.solid.createCylinder": "цилиндр",
    "bitbybit.occt.shapes.solid.createCylinder_description": "создает цилиндр OpenCascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "цилиндры на линиях",
    "createCylindersOnLines": "создать цилиндры на линиях",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Создает Цилиндры OpenCascade на простых линиях bit by bit, представленных двумя точками",
    "Base.Line3[]": "массив базовых линий 3",
    "bitbybit.occt.shapes.solid.createSphere": "сфера",
    "bitbybit.occt.shapes.solid.createSphere_description": "создает сферу OpenCascade",
    "bitbybit.occt.shapes.solid.createCone": "конус",
    "createCone": "создать конус",
    "bitbybit.occt.shapes.solid.createCone_description": "создает конус OpenCascade",
    "radius1": "радиус 1",
    "radius2": "радиус 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "получить площадь поверхности тела",
    "getSolidSurfaceArea": "получить площадь поверхности тела",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Получить площадь поверхности тела",
    "bitbybit.occt.shapes.solid.getSolidVolume": "получить объём тела",
    "getSolidVolume": "получить объём тела",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Получить объем тела",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "получить объёмы тел",
    "getSolidsVolumes": "получить объёмы тел",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Получить объемы тел",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "получить центр масс тела",
    "getSolidCenterOfMass": "получить центр масс тела",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Получить центр масс тела",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "получить центры масс тел",
    "getSolidsCentersOfMass": "получить центры масс тел",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Получить центры масс тел",
    "bitbybit.occt.shapes.solid.getSolids": "получить тела",
    "getSolids": "получить тела",
    "bitbybit.occt.shapes.solid.getSolids_description": "Получает тела формы в виде списка",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "фильтровать точки тела",
    "filterSolidPoints": "фильтровать точки тела",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Фильтрует коллекцию точек на основе отношения к телу. Вы можете выбрать, выводить ли точки внутри, на или снаружи.",
    "bitbybit.occt.shapes.compound.makeCompound": "создать составную форму",
    "compound": "составная форма",
    "makeCompound": "создать составную форму",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Создает составную форму, которая может включать любые виды форм",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "получить формы из составной",
    "getShapesOfCompound": "получить формы из составной",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Получает формы, из которых состоит составная фигура",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "удалить внутренние рёбра",
    "purgeInternalEdges": "удалить внутренние рёбра",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Удалить внутренние ребра, которые не соединены ни с одной гранью в форме",
    "bitbybit.occt.shapes.shape.unifySameDomain": "объединить в том же домене",
    "unifySameDomain": "объединить в том же домене",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Объединяет грани, ребра в одной области и имеет возможность конкатенировать bsplines",
    "unifyEdges": "объединить рёбра",
    "unifyFaces": "объединить грани",
    "concatBSplines": "соединить B-сплайны",
    "bitbybit.occt.shapes.shape.isClosed": "замкнута",
    "bitbybit.occt.shapes.shape.isClosed_description": "Проверить, замкнута ли форма",
    "analysis": "анализ",
    "bitbybit.occt.shapes.shape.isConvex": "выпуклая",
    "isConvex": "выпуклая",
    "bitbybit.occt.shapes.shape.isConvex_description": "Проверить, выпуклая ли форма",
    "bitbybit.occt.shapes.shape.isChecked": "проверена",
    "bitbybit.occt.shapes.shape.isChecked_description": "Проверить, проверена ли форма",
    "bitbybit.occt.shapes.shape.isFree": "свободна",
    "isFree": "свободна",
    "bitbybit.occt.shapes.shape.isFree_description": "Проверить, свободна ли форма",
    "bitbybit.occt.shapes.shape.isInfinite": "бесконечна",
    "isInfinite": "бесконечна",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Проверить, бесконечна ли форма",
    "bitbybit.occt.shapes.shape.isModified": "изменена",
    "isModified": "изменена",
    "bitbybit.occt.shapes.shape.isModified_description": "Проверить, изменена ли форма",
    "bitbybit.occt.shapes.shape.isLocked": "заблокирована",
    "isLocked": "заблокирована",
    "bitbybit.occt.shapes.shape.isLocked_description": "Проверить, заблокирована ли форма",
    "bitbybit.occt.shapes.shape.isNull": "нулевая",
    "isNull": "нулевая",
    "bitbybit.occt.shapes.shape.isNull_description": "Проверить, является ли форма null",
    "bitbybit.occt.shapes.shape.isEqual": "равна",
    "isEqual": "равна",
    "bitbybit.occt.shapes.shape.isEqual_description": "Проверить, равна ли форма другой форме",
    "otherShape": "другая форма",
    "bitbybit.occt.shapes.shape.isNotEqual": "не равна",
    "isNotEqual": "не равна",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Проверить, не равна ли форма другой форме",
    "bitbybit.occt.shapes.shape.isPartner": "является партнером",
    "isPartner": "является партнером",
    "bitbybit.occt.shapes.shape.isPartner_description": "Проверить, является ли форма партнером другой формы",
    "bitbybit.occt.shapes.shape.isSame": "та же самая",
    "isSame": "та же самая",
    "bitbybit.occt.shapes.shape.isSame_description": "Проверить, является ли форма той же самой, что и другая форма",
    "bitbybit.occt.shapes.shape.getOrientation": "получить ориентацию",
    "getOrientation": "получить ориентацию",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Получить ориентацию формы",
    "bitbybit.occt.shapes.shape.getShapeType": "получить тип формы",
    "getShapeType": "получить тип формы",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Получить тип формы",
    "bitbybit.occt.geom.curves.geom2dEllipse": "геом. 2d эллипс",
    "geom": "геометрия",
    "curves": "кривые",
    "geom2dEllipse": "геом. 2d эллипс",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Создает 2d эллипс. Обязательно используйте эту геометрию только для конструктивных целей моделирования, но не для представления. Вам нужно преобразовать эти кривые в ребра, чтобы нарисовать их.",
    "Base.Point2": "базовая точка 2",
    "Base.Vector2": "базовый вектор 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "геом. 2d обрезанная кривая",
    "geom2dTrimmedCurve": "геом. 2d обрезанная кривая",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Создает обрезанную кривую из базовой кривой, ограниченной между U1 и U2. Эту кривую нельзя нарисовать.",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "скорректировать периодичность",
    "bitbybit.occt.geom.curves.geom2dSegment": "геом. 2d отрезок",
    "geom2dSegment": "геом. 2d отрезок",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Создает обрезанный сегмент 2d кривой между двумя 2d точками. Эту кривую нельзя нарисовать.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "получить 2d точку из 2d кривой по параметру",
    "get2dPointFrom2dCurveOnParam": "получить 2d точку из 2d кривой по параметру",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Получает 2d точку, представленную как [число, число], на кривой по параметру.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "геом. кривая-окружность",
    "geomCircleCurve": "геом. кривая-окружность",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Создает геометрическую кривую круга",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "геом. кривая-эллипс",
    "geomEllipseCurve": "геом. кривая-эллипс",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Создает геометрическую кривую эллипса",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "цилиндрическая поверхность",
    "surfaces": "поверхности",
    "cylindricalSurface": "цилиндрическая поверхность",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Создает бесконечную цилиндрическую поверхность, которую нельзя нарисовать. Обязательно используйте эту геометрию только для конструктивных целей моделирования, но не для представления.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "поверхность из грани",
    "surfaceFromFace": "поверхность из грани",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Создает поверхность из грани",
    "bitbybit.occt.fillets.filletEdges": "скруглить рёбра",
    "fillets": "скругления",
    "filletEdges": "скруглить рёбра",
    "bitbybit.occt.fillets.filletEdges_description": "скругляет рёбра форм OpenCascade",
    "3d fillets": "3D скругления",
    "radiusList": "список радиусов",
    "indexes": "индексы",
    "bitbybit.occt.fillets.filletEdgesList": "скруглить список рёбер",
    "filletEdgesList": "скруглить список рёбер",
    "bitbybit.occt.fillets.filletEdgesList_description": "Скругляет список ребер с разным радиусом на каждом ребре.",
    "edges": "рёбра",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "скруглить список рёбер одним радиусом",
    "filletEdgesListOneRadius": "скруглить список рёбер одним радиусом",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Скругляет список ребер с одним радиусом на всех ребрах.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "скруглить ребро переменным радиусом",
    "filletEdgeVariableRadius": "скруглить ребро переменным радиусом",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Скругляет одно ребро с переменным списком радиусов на заданных параметрах u. Вам нужно предоставить список параметров, чтобы определить, на каком параметре U применять радиус.",
    "paramsU": "параметры U",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "скруглить рёбра одинаковым переменным радиусом",
    "filletEdgesSameVariableRadius": "скруглить рёбра одинаковым переменным радиусом",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Скругляет несколько предоставленных ребер с одинаковыми переменными радиусами на параметрах u для каждого ребра.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "скруглить рёбра переменными радиусами",
    "filletEdgesVariableRadius": "скруглить рёбра переменными радиусами",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Скругляет несколько предоставленных ребер с переменными списками радиусов на заданных списках параметров. Вам нужно предоставить список параметров, чтобы определить, на каком параметре U применять радиус.",
    "radiusLists": "списки радиусов",
    "paramsULists": "списки параметров U",
    "bitbybit.occt.fillets.fillet3DWire": "скруглить 3D контур",
    "fillet3DWire": "скруглить 3D контур",
    "bitbybit.occt.fillets.fillet3DWire_description": "Скругляет 3d проволоку OpenCascade, этот алгоритм принимает одно направляющее направление для формирования скруглений. Он не учитывает касательные направления на каждом скругленном углу. Этот алгоритм основан на выдавливании проволоки вдоль заданного направления для формирования оболочки, затем скруглении оболочки и, наконец, извлечении скругленной проволоки из самой оболочки. Убедитесь, что вы предоставляете направление, которое не параллельно проволоке и которое образует достаточно высокое выдавливание для успешного скругления.",
    "bitbybit.occt.fillets.fillet3DWires": "скруглить 3D контуры",
    "fillet3DWires": "скруглить 3D контуры",
    "bitbybit.occt.fillets.fillet3DWires_description": "Скругляет 3d проволоки OpenCascade, этот алгоритм принимает одно направляющее направление для формирования скруглений. Он не учитывает касательные направления на каждом скругленном углу. Этот алгоритм основан на выдавливании проволок вдоль заданного направления для формирования оболочки, затем скруглении оболочки и, наконец, извлечении скругленной проволоки из самой оболочки. Убедитесь, что вы предоставляете направление, которое не параллельно проволоке и которое образует достаточно высокое выдавливание для успешного скругления.",
    "bitbybit.occt.fillets.chamferEdges": "сделать фаску на рёбрах",
    "chamferEdges": "сделать фаску на рёбрах",
    "bitbybit.occt.fillets.chamferEdges_description": "Снять фаску с ребер формы OpenCascade",
    "3d chamfers": "3D фаски",
    "distanceList": "список расстояний",
    "bitbybit.occt.fillets.chamferEdgesList": "сделать фаску на списке рёбер",
    "chamferEdgesList": "сделать фаску на списке рёбер",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Снимает фаску со списка ребер с разным расстоянием на каждом ребре.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "сделать фаску на ребре с двумя расстояниями",
    "chamferEdgeTwoDistances": "сделать фаску на ребре с двумя расстояниями",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Снимает фаску с ребра на два расстояния. Грань указывает первое применяемое расстояние",
    "F": "F",
    "distance1": "расстояние 1",
    "distance2": "расстояние 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "сделать фаску на рёбрах с двумя расстояниями",
    "chamferEdgesTwoDistances": "сделать фаску на рёбрах с двумя расстояниями",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Снимает фаску с ребер на два расстояния. Грань указывает первое применяемое расстояние",
    "faces": "грани",
    "F[]": "массив F",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "сделать фаску на рёбрах со списками двух расстояний",
    "chamferEdgesTwoDistancesLists": "сделать фаску на рёбрах со списками двух расстояний",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Снимает фаску с ребер на два расстояния. Грань указывает первое применяемое расстояние",
    "distances1": "расстояния 1",
    "distances2": "расстояния 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "сделать фаску на ребре с расстоянием и углом",
    "chamferEdgeDistAngle": "сделать фаску на ребре с расстоянием и углом",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Снимает фаску с ребра на заданное расстояние и угол от грани",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "сделать фаску на рёбрах с расстоянием и углом",
    "chamferEdgesDistAngle": "сделать фаску на рёбрах с расстоянием и углом",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Снимает фаску с нескольких ребер на заданное расстояние и угол от граней",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "сделать фаску на рёбрах с расстояниями и углами",
    "chamferEdgesDistsAngles": "сделать фаску на рёбрах с расстояниями и углами",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Снимает фаску с ребер на заданные расстояния и углы от граней",
    "distances": "расстояния",
    "bitbybit.occt.fillets.fillet2d": "2D скругление",
    "fillet2d": "2D скругление",
    "bitbybit.occt.fillets.fillet2d_description": "скругляет 2D контур или грань",
    "2d fillets": "2D скругления",
    "bitbybit.occt.fillets.fillet2dShapes": "скруглить 2D формы",
    "fillet2dShapes": "скруглить 2D формы",
    "bitbybit.occt.fillets.fillet2dShapes_description": "скругляет 2D контуры или грани",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "скруглить два ребра в плоскости в контур",
    "filletTwoEdgesInPlaneIntoAWire": "скруглить два ребра в плоскости в контур",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Скругляет два плоских ребра в проволоку, предоставляя радиус, плоскость, ребра и возможный индекс решения, если существует более одного результата",
    "edge1": "ребро 1",
    "edge2": "ребро 2",
    "planeOrigin": "начало координат плоскости",
    "planeDirection": "направление плоскости",
    "solution": "решение",
    "bitbybit.occt.transforms.transform": "трансформировать",
    "bitbybit.occt.transforms.transform_description": "Трансформирует форму",
    "on single shape": "на одной форме",
    "rotationAxis": "ось вращения",
    "rotationAngle": "угол вращения",
    "scaleFactor": "коэффициент масштаба",
    "bitbybit.occt.transforms.rotate": "вращать",
    "bitbybit.occt.transforms.rotate_description": "Вращает форму",
    "bitbybit.occt.transforms.rotateAroundCenter": "вращать вокруг центра",
    "rotateAroundCenter": "вращать вокруг центра",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Вращает форму вокруг предоставленного центра",
    "bitbybit.occt.transforms.align": "выровнять",
    "bitbybit.occt.transforms.align_description": "Выравнивает форму",
    "fromOrigin": "из начала координат",
    "fromDirection": "из направления",
    "toOrigin": "в начало координат",
    "toDirection": "в направление",
    "bitbybit.occt.transforms.alignAndTranslate": "выровнять и переместить",
    "alignAndTranslate": "выровнять и переместить",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Выравнивает и перемещает форму",
    "bitbybit.occt.transforms.translate": "переместить",
    "bitbybit.occt.transforms.translate_description": "Перемещает форму",
    "bitbybit.occt.transforms.scale": "масштабировать",
    "bitbybit.occt.transforms.scale_description": "Масштабирует форму",
    "bitbybit.occt.transforms.scale3d": "3D масштабирование",
    "scale3d": "3D масштабирование",
    "bitbybit.occt.transforms.scale3d_description": "Масштабирует форму в 3D",
    "bitbybit.occt.transforms.mirror": "отразить",
    "mirror": "отразить",
    "bitbybit.occt.transforms.mirror_description": "Зеркально отражает форму",
    "bitbybit.occt.transforms.mirrorAlongNormal": "отразить вдоль нормали",
    "mirrorAlongNormal": "отразить вдоль нормали",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Зеркально отражает форму вдоль нормали и начала координат",
    "normal": "нормаль",
    "bitbybit.occt.transforms.transformShapes": "трансформировать формы",
    "transformShapes": "трансформировать формы",
    "bitbybit.occt.transforms.transformShapes_description": "Трансформирует массив форм с помощью трансформаций",
    "on shapes": "на формах",
    "rotationAxes": "оси вращения",
    "rotationAngles": "углы вращения",
    "scaleFactors": "коэффициенты масштаба",
    "bitbybit.occt.transforms.rotateShapes": "вращать формы",
    "rotateShapes": "вращать формы",
    "bitbybit.occt.transforms.rotateShapes_description": "Вращает формы с помощью вращений",
    "axes": "оси",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "вращать формы вокруг центра",
    "rotateAroundCenterShapes": "вращать формы вокруг центра",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Вращает формы вокруг центра и оси",
    "centers": "центры",
    "bitbybit.occt.transforms.alignShapes": "выровнять формы",
    "alignShapes": "выровнять формы",
    "bitbybit.occt.transforms.alignShapes_description": "Выравнивает формы с помощью выравниваний",
    "fromOrigins": "из начал координат",
    "fromDirections": "из направлений",
    "toOrigins": "в начала координат",
    "toDirections": "в направления",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "выровнять и переместить формы",
    "alignAndTranslateShapes": "выровнять и переместить формы",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Выравнивает и перемещает формы",
    "directions": "направления",
    "bitbybit.occt.transforms.translateShapes": "переместить формы",
    "translateShapes": "переместить формы",
    "bitbybit.occt.transforms.translateShapes_description": "Перемещает формы с помощью перемещений",
    "bitbybit.occt.transforms.scaleShapes": "масштабировать формы",
    "scaleShapes": "масштабировать формы",
    "bitbybit.occt.transforms.scaleShapes_description": "Масштабирует формы с помощью масштабных коэффициентов",
    "factors": "факторы",
    "bitbybit.occt.transforms.scale3dShapes": "3D масштабирование форм",
    "scale3dShapes": "3D масштабирование форм",
    "bitbybit.occt.transforms.scale3dShapes_description": "Масштабирует форму в 3D",
    "scales": "масштабы",
    "bitbybit.occt.transforms.mirrorShapes": "отразить формы",
    "mirrorShapes": "отразить формы",
    "bitbybit.occt.transforms.mirrorShapes_description": "Зеркально отражает формы с помощью нескольких зеркал",
    "origins": "начала координат",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "отразить формы вдоль нормали",
    "mirrorAlongNormalShapes": "отразить формы вдоль нормали",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Зеркально отражает формы вдоль нормали и начала координат",
    "normals": "нормали",
    "bitbybit.occt.operations.loft": "лофт",
    "operations": "операции",
    "loft": "лофт",
    "bitbybit.occt.operations.loft_description": "Создает лофтинг проволок в оболочку",
    "lofts": "лофты",
    "makeSolid": "создать тело",
    "bitbybit.occt.operations.loftAdvanced": "расширенный лофт",
    "loftAdvanced": "расширенный лофт",
    "bitbybit.occt.operations.loftAdvanced_description": "Создает лофтинг проволок в оболочку, используя множество расширенных опций",
    "straight": "прямой",
    "nrPeriodicSections": "кол-во периодических секций",
    "useSmoothing": "использовать сглаживание",
    "maxUDegree": "макс. степень U",
    "parType": "тип параметризации",
    "approxParametrizationTypeEnum": "перечисление типа приближенной параметризации",
    "startVertex": "начальная вершина",
    "endVertex": "конечная вершина",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "ближайшие точки между двумя формами",
    "closestPointsBetweenTwoShapes": "ближайшие точки между двумя формами",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Вычисляет две ближайшие точки между двумя формами",
    "closest pts": "ближайшие точки",
    "shape1": "форма 1",
    "shape2": "форма 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "ближайшие точки на форме от точек",
    "closestPointsOnShapeFromPoints": "ближайшие точки на форме от точек",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Вычисляет ближайшие точки между списком точек и заданной формой",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "ближайшие точки на формах от точек",
    "closestPointsOnShapesFromPoints": "ближайшие точки на формах от точек",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Вычисляет ближайшие точки между списком точек и формами",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "расстояния до формы от точек",
    "distancesToShapeFromPoints": "расстояния до формы от точек",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Вычисляет расстояния между списком точек и соответствующими ближайшими точками на формах.",
    "bitbybit.occt.operations.boundingBoxOfShape": "ограничивающий бокс формы",
    "boundingBoxOfShape": "ограничивающий бокс формы",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Вычисляет параметры ограничивающего бокса формы",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "мин. точка огр. бокса формы",
    "boundingBoxMinOfShape": "мин. точка огр. бокса формы",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Получить минимальную точку ограничивающего бокса формы",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "макс. точка огр. бокса формы",
    "boundingBoxMaxOfShape": "макс. точка огр. бокса формы",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Получить максимальную точку ограничивающего бокса формы",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "центр огр. бокса формы",
    "boundingBoxCenterOfShape": "центр огр. бокса формы",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Получить центральную точку ограничивающего бокса формы",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "размер огр. бокса формы",
    "boundingBoxSizeOfShape": "размер огр. бокса формы",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Получить точку размера ограничивающего бокса формы",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "форма огр. бокса формы",
    "boundingBoxShapeOfShape": "форма огр. бокса формы",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Получить форму ограничивающего бокса формы",
    "bitbybit.occt.operations.boundingSphereOfShape": "ограничивающая сфера формы",
    "boundingSphereOfShape": "ограничивающая сфера формы",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Вычисляет параметры ограничивающей сферы формы",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "центр огр. сферы формы",
    "boundingSphereCenterOfShape": "центр огр. сферы формы",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Получить центральную точку ограничивающей сферы формы",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "радиус огр. сферы формы",
    "boundingSphereRadiusOfShape": "радиус огр. сферы формы",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Получить радиус ограничивающей сферы формы",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "форма огр. сферы формы",
    "boundingSphereShapeOfShape": "форма огр. сферы формы",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Получить форму ограничивающей сферы формы",
    "bitbybit.occt.operations.extrude": "выдавить",
    "extrude": "выдавить",
    "bitbybit.occt.operations.extrude_description": "Выдавливает форму вдоль направления - проволока создаст оболочку, грань создаст тело",
    "extrusions": "выдавливания",
    "bitbybit.occt.operations.extrudeShapes": "выдавить формы",
    "extrudeShapes": "выдавить формы",
    "bitbybit.occt.operations.extrudeShapes_description": "Выдавливает формы вдоль направления",
    "bitbybit.occt.operations.splitShapeWithShapes": "разделить форму формами",
    "splitShapeWithShapes": "разделить форму формами",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Разделяет форму формами",
    "divisions": "деления",
    "localFuzzyTolerance": "локальный нечеткий допуск",
    "nonDestructive": "неразрушающий",
    "bitbybit.occt.operations.revolve": "вращать",
    "revolve": "вращать",
    "bitbybit.occt.operations.revolve_description": "Вращает форму вокруг заданного направления",
    "revolutions": "вращения",
    "copy": "копировать",
    "bitbybit.occt.operations.rotatedExtrude": "вращательное выдавливание",
    "rotatedExtrude": "вращательное выдавливание",
    "bitbybit.occt.operations.rotatedExtrude_description": "Вращательное выдавливание, которое выполняется на форме",
    "bitbybit.occt.operations.pipe": "труба",
    "pipe": "труба",
    "bitbybit.occt.operations.pipe_description": "Сдвигает формы вдоль проволоки",
    "pipeing": "создание трубы",
    "bitbybit.occt.operations.pipePolylineWireNGon": "труба из полилинии с n-угольным профилем",
    "pipePolylineWireNGon": "труба из полилинии с n-угольным профилем",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Сдвигает проволоку полилинии с профилем n-угольника.",
    "trihedronEnum": "перечисление триэдра",
    "geomFillTrihedronEnum": "перечисление триэдра заполнения геометрии",
    "forceApproxC1": "принудительное приближение C1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "цилиндрические трубы из контуров",
    "pipeWiresCylindrical": "цилиндрические трубы из контуров",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Сдвигает проволоки с цилиндрической формой",
    "bitbybit.occt.operations.pipeWireCylindrical": "цилиндрическая труба из контура",
    "pipeWireCylindrical": "цилиндрическая труба из контура",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Сдвигает проволоку с цилиндрической формой",
    "bitbybit.occt.operations.offset": "смещение",
    "bitbybit.occt.operations.offset_description": "Смещение для различных форм",
    "offsets": "смещения",
    "bitbybit.occt.operations.offsetAdv": "расширенное смещение",
    "offsetAdv": "расширенное смещение",
    "bitbybit.occt.operations.offsetAdv_description": "Расширенное смещение, которое дает больше опций для смещения, таких как тип соединения для ребер и углов",
    "joinType": "тип соединения",
    "joinTypeEnum": "перечисление типа соединения",
    "removeIntEdges": "удалить внутренние рёбра",
    "bitbybit.occt.operations.makeThickSolidSimple": "создать простое утолщенное тело",
    "makeThickSolidSimple": "создать простое утолщенное тело",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Утолщает форму в тело на расстояние смещения",
    "bitbybit.occt.operations.makeThickSolidByJoin": "создать утолщенное тело соединением",
    "makeThickSolidByJoin": "создать утолщенное тело соединением",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Утолщает форму в тело путем соединения",
    "intersection": "пересечение",
    "selfIntersection": "самопересечение",
    "bitbybit.occt.operations.slice": "срез",
    "slice": "срез",
    "bitbybit.occt.operations.slice_description": "Разрезает форму",
    "bitbybit.occt.operations.sliceInStepPattern": "срез по шаговому шаблону",
    "sliceInStepPattern": "срез по шаговому шаблону",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Разрезает форму ступенчатым узором",
    "steps": "шаги",
    "bitbybit.occt.operations.offset3DWire": "смещение 3D контура",
    "offset3DWire": "смещение 3D контура",
    "bitbybit.occt.operations.offset3DWire_description": "Смещает 3D проволоку. При использовании этого метода рассмотрите возможность использования его на скругленных проволоках, которые не содержат острых углов. Вы можете использовать на ней 3D скругление.",
    "bitbybit.occt.booleans.union": "объединение",
    "booleans": "булевы операции",
    "union": "объединение",
    "bitbybit.occt.booleans.union_description": "Соединяет отдельные объекты",
    "keepEdges": "сохранить рёбра",
    "bitbybit.occt.booleans.difference": "разность",
    "difference": "разность",
    "bitbybit.occt.booleans.difference_description": "Выполняет логическую операцию разности между основной формой и заданными формами",
    "bitbybit.occt.booleans.intersection": "пересечение",
    "bitbybit.occt.booleans.intersection_description": "Выполняет логическую операцию пересечения между основной формой и заданными формами",
    "bitbybit.occt.shapeFix.basicShapeRepair": "базовое исправление формы",
    "shapeFix": "исправление формы",
    "basicShapeRepair": "базовое исправление формы",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Выполняет базовый ремонт формы",
    "maxTolerance": "макс. допуск",
    "minTolerance": "мин. допуск",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "исправить мелкое ребро на контуре",
    "fixSmallEdgeOnWire": "исправить мелкое ребро на контуре",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Исправить маленькое ребро на проволоке",
    "lockvtx": "заблокировать vtx",
    "precsmall": "точность малого",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "исправить ориентации рёбер вдоль контура",
    "fixEdgeOrientationsAlongWire": "исправить ориентации рёбер вдоль контура",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Исправить ориентации ребер вдоль проволоки",
    "bitbybit.occt.io.saveShapeSTEP": "сохранить форму STEP",
    "saveShapeSTEP": "сохранить форму STEP",
    "bitbybit.occt.io.saveShapeSTEP_description": "Сохраняет файл step",
    "adjustYtoZ": "подогнать Y к Z",
    "tryDownload": "попробовать загрузить",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "сохранить форму STEP и вернуть",
    "saveShapeSTEPAndReturn": "сохранить форму STEP и вернуть",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Сохраняет файл step и возвращает текстовое значение",
    "bitbybit.occt.io.saveShapeStl": "сохранить форму STL",
    "saveShapeStl": "сохранить форму STL",
    "bitbybit.occt.io.saveShapeStl_description": "Сохраняет файл stl",
    "binary": "двоичный",
    "bitbybit.occt.io.saveShapeStlAndReturn": "сохранить форму STL и вернуть",
    "saveShapeStlAndReturn": "сохранить форму STL и вернуть",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Сохраняет файл stl и возвращает",
    "bitbybit.occt.io.loadSTEPorIGES": "загрузить STEP или IGES",
    "loadSTEPorIGES": "загрузить STEP или IGES",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Импортирует файл актива step или iges",
    "adjustZtoY": "подогнать Z к Y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "загрузить STEP или IGES из текста",
    "loadSTEPorIGESFromText": "загрузить STEP или IGES из текста",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Импортирует файл актива step или iges из текста",
    "fileType": "тип файла",
    "fileTypeEnum": "перечисление типа файла",
    "bitbybit.advanced.text3d.create": "3D текст",
    "advanced": "расширенные",
    "text3d": "3D текст",
    "bitbybit.advanced.text3d.create_description": "Создает 3d текст",
    "fontType": "тип шрифта",
    "fontsEnum": "перечисление шрифтов",
    "fontVariant": "вариант шрифта",
    "fontVariantsEnum": "перечисление вариантов шрифта",
    "Inputs.Base.Vector3": "входы базовый вектор 3",
    "originAlignment": "выравнивание начала координат",
    "recAlignmentEnum": "перечисление выравнивания прямоугольника",
    "bitbybit.advanced.text3d.createTextOnFace": "текст на грани",
    "createTextOnFace": "создать текст на грани",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Создает 3d текст на грани",
    "facePlanar": "грань плоская",
    "faceTextVar": "переменная текста на грани",
    "faceTextVarEnum": "перечисление переменной текста на грани",
    "originParamU": "параметр U начала координат",
    "originParamV": "параметр V начала координат",
    "bitbybit.advanced.text3d.createTextsOnFace": "тексты на грани",
    "createTextsOnFace": "создать тексты на грани",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Создает 3d тексты на грани из нескольких определений",
    "definitions": "определения",
    "Text3DFaceDefinitionDto[]": "массив DTO определения 3D текста на грани",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "определение 3D текста на грани",
    "definition3dTextOnFace": "определение 3D текста на грани",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Создает 3d текст, который будет использоваться в определении грани",
    "bitbybit.advanced.text3d.getCompoundShape": "получить составную форму",
    "getCompoundShape": "получить составную форму",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Получает составную форму результата 3d текста",
    "model": "модель",
    "Text3DData<T>": "данные 3D текста T",
    "bitbybit.advanced.text3d.getCharacterShape": "получить форму символа",
    "getCharacterShape": "получить форму символа",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Получает форму символа по определенному индексу",
    "bitbybit.advanced.text3d.getCharacterShapes": "получить формы символов",
    "getCharacterShapes": "получить формы символов",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Получает формы символов результата 3d текста",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "получить координаты центра символов",
    "getCharacterCenterCoordinates": "получить координаты центра символов",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Получает координаты центра масс всех символов",
    "bitbybit.advanced.text3d.getFaceCutout": "получить вырез грани",
    "getFaceCutout": "получить вырез грани",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Получает вырез грани из текста 3d, который был создан на грани",
    "get from face": "получить из грани",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "получить все грани выреза",
    "getAllFacesOfCutout": "получить все грани выреза",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Получает все вырезы граней из текста 3d, который был создан на исходной грани",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "получить вырезы внутри символов",
    "getCutoutsInsideCharacters": "получить вырезы внутри символов",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Получает вырезы граней символов из текста 3d, который был создан на исходной грани",
    "bitbybit.advanced.text3d.getAdvanceWidth": "получить ширину вывода",
    "getAdvanceWidth": "получить ширину вывода",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Получить ширину продвижения",
    "dimensions": "размеры",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "простая пирамида",
    "facePatterns": "шаблоны граней",
    "pyramidSimple": "простая пирамида",
    "createPyramidSimple": "создать простую пирамиду",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Создает простой пирамидальный узор на гранях",
    "uNumber": "количество по U",
    "vNumber": "количество по V",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "простая пирамида с аффекторами",
    "createPyramidSimpleAffectors": "создать простую пирамиду с аффекторами",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Создает простой пирамидальный узор на гранях с эффекторами, которые изменяют высоту",
    "affectorPoints": "точки аффектора",
    "Inputs.Base.Point3[]": "массив входов базовых точек 3",
    "affectorRadiusList": "список радиусов аффектора",
    "affectorFactors": "факторы аффектора",
    "defaultHeight": "высота по умолчанию",
    "affectMinHeight": "мин. высота влияния",
    "affectMaxHeight": "макс. высота влияния",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "получить составную форму",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Получает составную форму всех пирамид",
    "get shapes": "получить формы",
    "PyramidSimpleData<T>": "данные простой пирамиды T",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "получить составную форму на грани",
    "getCompoundShapeOnFace": "получить составную форму на грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Получает составную форму на грани",
    "faceIndex": "индекс грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "получить форму ячейки составной формы на грани",
    "getCompoundShapeCellOnFace": "получить форму ячейки составной формы на грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Получает составную форму пирамиды на грани по определенному индексу",
    "uIndex": "индекс U",
    "vIndex": "индекс V",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "получить все ячейки пирамиды",
    "getAllPyramidCells": "получить все ячейки пирамиды",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Получает все ячейки пирамиды. Это обычно промежуточное действие, чтобы затем прочитать конкретную информацию о самих ячейках.",
    "get cells": "получить ячейки",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "получить все ячейки пирамиды на грани",
    "getAllPyramidCellsOnFace": "получить все ячейки пирамиды на грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Получает ячейки пирамиды на грани. Это обычно промежуточное действие, чтобы затем прочитать конкретную информацию о самих ячейках.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "получить все U-ячейки пирамиды на грани",
    "getAllPyramidUCellsOnFace": "получить все U-ячейки пирамиды на грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Получает ячейки пирамиды на грани. Это обычно промежуточное действие, чтобы затем прочитать конкретную информацию о самих ячейках.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "получить все U-ячейки пирамиды на грани в точке U",
    "getAllPyramidUCellsOnFaceAtU": "получить все U-ячейки пирамиды на грани в точке U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Получает ячейки пирамиды на грани по индексу u вдоль направления v. Это обычно промежуточное действие, чтобы затем прочитать конкретную информацию о самих ячейках.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "получить все U-ячейки пирамиды на грани в точке V",
    "getAllPyramidUCellsOnFaceAtV": "получить все U-ячейки пирамиды на грани в точке V",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Получает ячейки пирамиды на грани по индексу v вдоль направления u. Это обычно промежуточное действие, чтобы затем прочитать конкретную информацию о самих ячейках.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "получить ячейку по индексу",
    "getCellOnIndex": "получить ячейку по индексу",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Получает ячейку пирамиды на грани по индексу u и v. Это обычно промежуточное действие, чтобы затем прочитать конкретную информацию о самой ячейке.",
    "get cell": "получить ячейку",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "получить верхние точки ячеек",
    "getTopPointsOfCells": "получить верхние точки ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Получает верхние точки ячеек",
    "get from cells": "получить из ячеек",
    "cells": "ячейки",
    "PyramidSimpleCellPart<T>[]": "массив частей ячейки простой пирамиды T",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "получить центральные точки ячеек",
    "getCenterPointsOfCells": "получить центральные точки ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Получает центральную точку между углами ячейки",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "получить угловые точки ячеек",
    "getCornerPointsOfCells": "получить угловые точки ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Получает угловые точки ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "получить угловую точку ячеек",
    "getCornerPointOfCells": "получить угловую точку ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Получает угловые точки ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "получить нормаль угла ячеек",
    "getCornerNormalOfCells": "получить нормаль угла ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Получает нормаль угла ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "получить нормали углов ячеек",
    "getCornerNormalsOfCells": "получить нормали углов ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Получает нормали углов ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "получить составные формы ячеек",
    "getCompoundShapesOfCells": "получить составные формы ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Получает составные формы ячеек пирамиды",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "получить формы граней ячеек",
    "getFaceShapesOfCells": "получить формы граней ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Получает формы граней предоставленных ячеек пирамиды",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "получить формы контуров ячеек",
    "getWireShapesOfCells": "получить формы контуров ячеек",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Получает формы граней предоставленных ячеек пирамиды",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "получить начальный контур полилинии U",
    "getStartPolylineWireU": "получить начальный контур полилинии U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Получает проволоку полилинии вдоль начального края направления U грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "получить конечный контур полилинии U",
    "getEndPolylineWireU": "получить конечный контур полилинии U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Получает проволоку полилинии вдоль конечного края направления U грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "получить начальный контур полилинии V",
    "getStartPolylineWireV": "получить начальный контур полилинии V",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Получает проволоку полилинии вдоль начального края направления V грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "получить конечный контур полилинии V",
    "getEndPolylineWireV": "получить конечный контур полилинии V",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Получает проволоку полилинии вдоль конечного края направления V грани",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "получить составную форму контуров полилиний U",
    "getPolylineWiresUCompound": "получить составную форму контуров полилиний U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Получает проволоки полилинии вдоль направления U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "получить составную форму контуров полилиний V",
    "getPolylineWiresVCompound": "получить составную форму контуров полилиний V",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Получает проволоки полилинии вдоль направления V",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "Вилла «Кончик крыла»",
    "things": "вещи",
    "kidsCorner": "детский уголок",
    "birdhouses": "скворечники",
    "wingtipVilla": "вилла «Кончик крыла»",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Создает скворечник wingtip villa с крышей под 45 градусов",
    "birdhouse": "скворечник",
    "interiorWidth": "внутренняя ширина",
    "interiorLength": "внутренняя длина",
    "interiorHeight": "внутренняя высота",
    "holeDiameter": "диаметр отверстия",
    "holeDistToBottom": "расстояние отверстия до низа",
    "stickLength": "длина жердочки",
    "stickDiameter": "диаметр жердочки",
    "baseAttachmentHeight": "высота крепления основания",
    "roofOverhang": "свес крыши",
    "chimneyHeight": "высота трубы",
    "Inputs.Base.Point3": "входы базовая точка 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "Шале «Чирик»",
    "chirpyChalet": "шале «Чирик»",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Создает скворечник chirpy chalet с крышей под 45 градусов",
    "roofAngle": "угол крыши",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "Вихрь безмятежности",
    "threeDPrinting": "3D печать",
    "vases": "вазы",
    "serenitySwirl": "вихрь безмятежности",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Создает serenity swirl",
    "swirl": "вихрь",
    "addRadiusNarrow": "добавить узкий радиус",
    "addRadiusWide": "добавить широкий радиус",
    "addMiddleHeight": "добавить среднюю высоту",
    "addTopHeight": "добавить верхнюю высоту",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "Арабская арка",
    "arabicArchway": "арабская арка",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Создает вазу arabic archway",
    "profilePoints": "точки профиля",
    "nrOfSides": "количество сторон",
    "nrOfVerticalArches": "количество вертикальных арок",
    "archCenterThickness": "толщина центра арки",
    "edgesThickness": "толщина рёбер",
    "baseHeight": "высота основания",
    "patchHoles": "заделать отверстия",
    "lod": "уровень детализации",
    "Things.Enums.lodEnum": "перечисление уровня детализации (Things)",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "Вечная любовь",
    "medals": "медали",
    "eternalLove": "вечная любовь",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Создает модель медали eternal love",
    "textHeading": "текст заголовка",
    "textName": "текст имени",
    "fullModel": "полная модель",
    "decorationThickness": "толщина украшения",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "Чашка «Спокойствие»",
    "cups": "чашки",
    "calmCup": "чашка «Спокойствие»",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Создает модель чашки для ваших спокойных моментов",
    "radiusTopOffset": "смещение верхнего радиуса",
    "fillet": "скругление",
    "nrOfHandles": "количество ручек",
    "handleDist": "расстояние ручки",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "Чашка дракона",
    "dragonCup": "чашка дракона",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Создает модель чашки для вашего внутреннего дракона",
    "radiusMidOffset": "смещение среднего радиуса",
    "rotationTopAngle": "угол вращения верха",
    "rotationMidAngle": "угол вращения середины",
    "nrSkinCellsVertical": "кол-во ячеек кожи по вертикали",
    "nrSkinCellsHorizontal": "кол-во ячеек кожи по горизонтали",
    "nrSkinCellDivisionsTop": "кол-во делений ячейки кожи сверху",
    "nrSkinCellDivisionsBottom": "кол-во делений ячейки кожи снизу",
    "skinCellOuterHeight": "внешняя высота ячейки кожи",
    "skinCellInnerHeight": "внутренняя высота ячейки кожи",
    "skinCellBottomHeight": "нижняя высота ячейки кожи",
    "skinCellTopHeight": "верхняя высота ячейки кожи",
    "bottomThickness": "толщина дна",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "получить составную форму",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Получает составную форму чашки дракона",
    "DragonCupData<T>": "данные чашки дракона T",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "Гнездо для телефона",
    "desktop": "рабочий стол",
    "phoneNest": "гнездо для телефона",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Создает модель phone nest",
    "heightBottom": "высота низа",
    "heightTop": "высота верха",
    "widthBack": "ширина сзади",
    "widthFront": "ширина спереди",
    "backOffset": "смещение сзади",
    "applyOrnaments": "применить украшения",
    "filletRadius": "радиус скругления",
    "phoneHeight": "высота телефона",
    "phoneWidth": "ширина телефона",
    "phoneThickness": "толщина телефона",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "получить составную форму",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Получает составную форму phone nest",
    "PhoneNestData<T>": "данные гнезда для телефона T",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "параметры рисования",
    "drawOptions": "параметры рисования",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "создает параметры рисования для модели",
    "mainMaterial": "основной материал",
    "phoneMaterial": "материал телефона",
    "Inputs.Base.Color": "входы базовый цвет",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "Держатель для телефона «Капельки»",
    "laserCutting": "лазерная резка",
    "gadgets": "гаджеты",
    "dropletsPhoneHolder": "держатель для телефона «Капельки»",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "создает держатель для телефона «Капельки»",
    "title": "заголовок",
    "subtitle": "подзаголовок",
    "includeLogo": "включить логотип",
    "kerf": "пропил",
    "backLength": "длина задней части",
    "offsetAroundPhone": "смещение вокруг телефона",
    "penShelf": "полка для ручки",
    "phoneLockHeight": "высота фиксатора телефона",
    "includePattern": "включить шаблон",
    "densityPattern": "плотность шаблона",
    "holesForWire": "отверстия для провода",
    "wireInputThickness": "толщина входа провода",
    "includeModel": "включить модель",
    "includeDrawings": "включить чертежи",
    "spacingDrawings": "интервал чертежей",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "получить составную форму",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Получает составную форму droplets phone holder",
    "DropletsPhoneHolderData<T>": "данные держателя «Капельки» T",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "получить составную форму контуров резки",
    "getCutWiresCompound": "получить составную форму контуров резки",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Получает состав из проволок резки",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "получить составную форму контуров гравировки",
    "getEngravingWiresCompound": "получить составную форму контуров гравировки",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Получает состав из проволок гравировки",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "скачать чертежи DXF",
    "downloadDXFDrawings": "скачать чертежи DXF",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "скачивает чертеж DXF",
    "download": "скачать",
    "cutWiresColor": "цвет контуров резки",
    "engravingWiresColor": "цвет контуров гравировки",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "скачать чертежи STEP",
    "downloadSTEPDrawings": "скачать чертежи STEP",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "скачивает чертеж STEP",
    "adjustYZ": "подогнать YZ",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "скачать 3D модель STEP",
    "download3dSTEPModel": "скачать 3D модель STEP",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "скачивает 3D модель STEP",
    "bitbybit.things.architecture.houses.zenHideout.create": "Укрытие Дзен",
    "architecture": "архитектура",
    "houses": "дома",
    "zenHideout": "укрытие Дзен",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Создает zen hideout",
    "widthFirstWing": "ширина первого крыла",
    "lengthFirstWing": "длина первого крыла",
    "terraceWidth": "ширина террасы",
    "widthSecondWing": "ширина второго крыла",
    "lengthSecondWing": "длина второго крыла",
    "heightWalls": "высота стен",
    "roofAngleFirstWing": "угол крыши первого крыла",
    "roofAngleSecondWing": "угол крыши второго крыла",
    "roofOffset": "смещение крыши",
    "roofInsideOverhang": "внутренний свес крыши",
    "roofMaxDistAttachmentBeams": "макс. расстояние между балками крепления крыши",
    "roofAttachmentBeamWidth": "ширина балки крепления крыши",
    "roofAttachmentBeamHeight": "высота балки крепления крыши",
    "roofOutsideOverhang": "внешний свес крыши",
    "columnSize": "размер колонны",
    "ceilingBeamHeight": "высота потолочной балки",
    "ceilingBeamWidth": "ширина потолочной балки",
    "nrCeilingBeamsBetweenColumns": "кол-во потолочных балок между колоннами",
    "distBetweenColumns": "расстояние между колоннами",
    "floorHeight": "высота пола",
    "groundLevel": "уровень земли",
    "facadePanelThickness": "толщина фасадной панели",
    "windowWidthOffset": "смещение ширины окна",
    "windowHeightOffset": "смещение высоты окна",
    "windowFrameThickness": "толщина оконной рамы",
    "windowGlassFrameThickness": "толщина рамы стекла окна",
    "skinOpacity": "непрозрачность оболочки",
    "bitbybit.things.furniture.chairs.snakeChair.create": "Стул «Змея»",
    "furniture": "мебель",
    "chairs": "стулья",
    "snakeChair": "стул «Змея»",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Создает модель стула змеи",
    "sittingHeight": "высота сидения",
    "backRestOffset": "смещение спинки",
    "backRestHeight": "высота спинки",
    "nrOrnamentPlanks": "кол-во декоративных планок",
    "ornamentDepth": "глубина декора",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "получить составную форму",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Получает составную форму стула",
    "SnakeChairData<T>": "данные стула «Змея» T",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "получить форму контура сидения",
    "getSittingWireShape": "получить форму контура сидения",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Получает форму проволоки сиденья стула",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "получить центр зоны сидения",
    "getSittingAreaCenterPoint": "получить центр зоны сидения",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Получает центральную точку сиденья стула",
    "get points": "получить точки",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "параметры рисования",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "создает параметры рисования для стула «Змея»",
    "bitbybit.things.furniture.tables.elegantTable.create": "Элегантный стол",
    "tables": "столы",
    "elegantTable": "элегантный стол",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Создает элегантную модель стола",
    "topThickness": "толщина столешницы",
    "topOffset": "смещение столешницы",
    "minFillet": "мин. скругление",
    "radiusLegTop": "радиус верха ножки",
    "radiusLegBottom": "радиус низа ножки",
    "nrLegPairs": "кол-во пар ножек",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "получить составную форму",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Получает составную форму стола",
    "ElegantTableData<T>": "данные элегантного стола T",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "получить формы ножек",
    "getLegShapes": "получить формы ножек",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Получает формы ножек в виде списка",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "получить форму ножки по индексу",
    "getLegShapeByIndex": "получить форму ножки по индексу",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Получает форму ножки по индексу",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "получить форму столешницы",
    "getTopPanelShape": "получить форму столешницы",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Получает форму верхней панели стола",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "получить форму контура столешницы",
    "getTopPanelWireShape": "получить форму контура столешницы",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Получает форму проволоки верхней панели стола",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "получить форму контура нижней панели",
    "getBottomPanelWireShape": "получить форму контура нижней панели",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Получает форму проволоки нижней панели стола",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "получить форму нижней панели",
    "getBottomPanelShape": "получить форму нижней панели",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Получает форму нижней панели стола",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "получить составную форму ножек",
    "getLegsCompoundShape": "получить составную форму ножек",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Получает формы ножек в виде составной формы",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "получить центр столешницы стола",
    "getTableTopCenterPoint": "получить центр столешницы стола",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Получает верхнюю центральную точку",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "получить центр основания стола",
    "getTableBottomCenterPoint": "получить центр основания стола",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Получает нижнюю центральную точку",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "получить нижние точки ножек",
    "getLegBottomPoints": "получить нижние точки ножек",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Получает нижние точки ножек",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "получить верхние точки ножек",
    "getLegTopPoints": "получить верхние точки ножек",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Получает верхние точки ножек",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "параметры рисования",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "создает параметры рисования для элегантного стола",
    "topMaterial": "материал столешницы",
    "topBaseMaterial": "материал основания столешницы",
    "legsMaterial": "материал ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "Хороший кофейный столик",
    "goodCoffeeTable": "хороший кофейный столик",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Создает модель хорошего кофейного столика",
    "chamfer": "фаска",
    "topGlassOffset": "смещение стекла столешницы",
    "glassThickness": "толщина стекла",
    "glassHolderLength": "длина держателя стекла",
    "shelfTopOffset": "смещение верха полки",
    "shelfThickness": "толщина полки",
    "legWidth": "ширина ножки",
    "legDepth": "глубина ножки",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "получить составную форму",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Получает составную форму стола",
    "GoodCoffeeTableData<T>": "данные хорошего кофейного столика T",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "получить формы ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Получает формы ножек в виде списка",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "получить форму ножки по индексу",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Получает форму ножки по индексу",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "получить форму столешницы",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Получает форму верхней панели стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "получить форму контура столешницы",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Получает форму проволоки верхней панели стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "получить форму стеклянной панели",
    "getGlassPanelShape": "получить форму стеклянной панели",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Получает форму стеклянной панели стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "получить форму контура стеклянной панели",
    "getGlassPanelWireShape": "получить форму контура стеклянной панели",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Получает форму проволоки стеклянной панели стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "получить форму полки",
    "getShelfShape": "получить форму полки",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Получает форму полки стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "получить форму верхнего контура полки",
    "getShelfTopWireShape": "получить форму верхнего контура полки",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Получает форму верхней проволоки полки стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "получить составную форму ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Получает формы ножек в виде составной формы",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "получить центр столешницы стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Получает верхнюю центральную точку",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "получить центр верха полки стола",
    "getTableShelfTopCenterPoint": "получить центр верха полки стола",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Получает верхнюю центральную точку полки",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "получить нижние точки ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Получает нижние точки ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "получить верхние точки ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Получает верхние точки ножек",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "параметры рисования",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "создает параметры рисования для хорошего кофейного столика",
    "topGlassMaterial": "материал стекла столешницы",
    "shelfMaterial": "материал полки",
    "bitbybit.things.furniture.tables.snakeTable.create": "Стол «Змея»",
    "snakeTable": "стол «Змея»",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Создает модель стола змеи",
    "supportLength": "длина опоры",
    "shelfHeight": "высота полки",
    "glassOffset": "смещение стекла",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "получить составную форму",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Получает составную форму стола",
    "SnakeTableData<T>": "данные стола «Змея» T",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "получить форму стекла",
    "getGlassShape": "получить форму стекла",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Получает стеклянную форму стола",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "получить основную форму",
    "getMainShape": "получить основную форму",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Получает основную твердую форму стола",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "получить верхнюю центральную точку",
    "getTopCenterPoint": "получить верхнюю центральную точку",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Получает центральную точку столешницы",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "параметры рисования",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "создает параметры рисования для стола «Змея»",
    "glassMaterial": "материал стекла",
    "bitbybit.things.enums.lodEnum": "перечисление уровня детализации",
    "enums": "перечисления",
    "lodEnum": "перечисление уровня детализации",
    "bitbybit.things.enums.lodEnum_description": "Создает значение перечисления уровня детализации",
    "bitbybit.jscad.transformSolids": "трансформировать тела",
    "jscad": "jscad",
    "transformSolids": "трансформировать тела",
    "bitbybit.jscad.transformSolids_description": "Трансформирует твердые сетки Jscad с помощью заданного списка трансформаций.",
    "JSCADEntity[]": "массив сущностей JSCAD",
    "bitbybit.jscad.transformSolid": "трансформировать тело",
    "transformSolid": "трансформировать тело",
    "bitbybit.jscad.transformSolid_description": "Трансформирует твердую сетку Jscad с помощью заданного списка трансформаций.",
    "JSCADEntity": "сущность JSCAD",
    "bitbybit.jscad.downloadSolidSTL": "скачать тело STL",
    "downloadSolidSTL": "скачать тело STL",
    "bitbybit.jscad.downloadSolidSTL_description": "Загружает бинарный файл STL из 3D твердого тела",
    "bitbybit.jscad.downloadSolidsSTL": "скачать тела STL",
    "downloadSolidsSTL": "скачать тела STL",
    "bitbybit.jscad.downloadSolidsSTL_description": "Загружает бинарный файл STL из 3D твердых тел",
    "bitbybit.jscad.downloadGeometryDxf": "скачать геометрию DXF",
    "downloadGeometryDxf": "скачать геометрию DXF",
    "bitbybit.jscad.downloadGeometryDxf_description": "Загружает файл dxf из геометрии jscad. Поддерживает пути и сетки в массиве.",
    "geometry": "геометрия",
    "JSCADEntity | JSCADEntity[]": "сущность JSCAD или массив",
    "bitbybit.jscad.downloadGeometry3MF": "скачать геометрию 3MF",
    "downloadGeometry3MF": "скачать геометрию 3MF",
    "bitbybit.jscad.downloadGeometry3MF_description": "Загружает файл 3MF из геометрии jscad.",
    "bitbybit.jscad.booleans.intersect": "пересечь",
    "intersect": "пересечь",
    "bitbybit.jscad.booleans.intersect_description": "Пересечь несколько объектов твердой сетки",
    "bitbybit.jscad.booleans.subtract": "вычесть",
    "subtract": "вычесть",
    "bitbybit.jscad.booleans.subtract_description": "Вычесть несколько объектов твердой сетки",
    "bitbybit.jscad.booleans.union": "объединить",
    "bitbybit.jscad.booleans.union_description": "Объединить несколько объектов твердой сетки",
    "bitbybit.jscad.booleans.intersectTwo": "пересечь два",
    "intersectTwo": "пересечь два",
    "bitbybit.jscad.booleans.intersectTwo_description": "Пересечь два объекта твердой сетки",
    "bitbybit.jscad.booleans.subtractTwo": "вычесть два",
    "subtractTwo": "вычесть два",
    "bitbybit.jscad.booleans.subtractTwo_description": "Вычесть два объекта твердой сетки",
    "bitbybit.jscad.booleans.unionTwo": "объединить два",
    "unionTwo": "объединить два",
    "bitbybit.jscad.booleans.unionTwo_description": "Объединить два объекта твердой сетки",
    "bitbybit.jscad.booleans.subtractFrom": "вычесть из",
    "subtractFrom": "вычесть из",
    "bitbybit.jscad.booleans.subtractFrom_description": "Вычесть несколько сеток из одного объекта сетки",
    "bitbybit.jscad.expansions.expand": "расширить",
    "expansions": "расширения",
    "expand": "расширить",
    "bitbybit.jscad.expansions.expand_description": "Расширить геометрию категории solid",
    "expansion": "расширение",
    "delta": "дельта",
    "corners": "углы",
    "solidCornerTypeEnum": "перечисление типа угла тела",
    "bitbybit.jscad.expansions.offset": "смещение",
    "bitbybit.jscad.expansions.offset_description": "Сместить 2d геометрию категории solid",
    "bitbybit.jscad.extrusions.extrudeLinear": "линейное выдавливание",
    "extrudeLinear": "линейное выдавливание",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Линейно выдавить 2D геометрию категории solid",
    "twistAngle": "угол скручивания",
    "twistSteps": "шаги скручивания",
    "bitbybit.jscad.extrusions.extrudeRectangular": "прямоугольное выдавливание",
    "extrudeRectangular": "прямоугольное выдавливание",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Прямоугольно выдавить 2D геометрию категории solid. Создает выдавливание типа стены определенной высоты и размера.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "прямоугольное выдавливание точек",
    "extrudeRectangularPoints": "прямоугольное выдавливание точек",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Прямоугольно выдавить список 2D точек. Создает выдавливание типа стены определенной высоты и размера.",
    "bitbybit.jscad.extrusions.extrudeRotate": "вращательное выдавливание",
    "extrudeRotate": "вращательное выдавливание",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Прямоугольно выдавить список 2D точек. Создает выдавливание типа стены определенной высоты и размера.",
    "polygon": "полигон",
    "startAngle": "начальный угол",
    "bitbybit.jscad.hulls.hullChain": "цепная оболочка",
    "hulls": "оболочки",
    "hullChain": "цепная оболочка",
    "bitbybit.jscad.hulls.hullChain_description": "Цепочка оболочек соединяет твердые тела или 2d геометрию, заполняя пустое пространство между объектами по порядку. Геометрия должна быть одного типа.",
    "bitbybit.jscad.hulls.hull": "оболочка",
    "hull": "оболочка",
    "bitbybit.jscad.hulls.hull_description": "Выпуклая оболочка соединяет твердые тела или 2d геометрию, заполняя пустое пространство между ними без соблюдения порядка. Геометрия должна быть одного типа.",
    "bitbybit.jscad.path.createFromPoints": "из точек",
    "createFromPoints": "создать из точек",
    "bitbybit.jscad.path.createFromPoints_description": "Создать 2D путь из списка точек",
    "Base.Point2[]": "массив базовых точек 2",
    "bitbybit.jscad.path.createPathsFromPoints": "пути из точек",
    "createPathsFromPoints": "создать пути из точек",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Создать 2D пути из списков точек",
    "pointsLists": "списки точек",
    "Base.Point3[][] | Base.Point2[][]": "массив массивов базовых точек 3 или 2",
    "bitbybit.jscad.path.createFromPolyline": "из полилинии",
    "createFromPolyline": "создать из полилинии",
    "bitbybit.jscad.path.createFromPolyline_description": "Создать 2D путь из полилинии",
    "bitbybit.jscad.path.createEmpty": "пустой",
    "createEmpty": "создать пустой",
    "bitbybit.jscad.path.createEmpty_description": "Создать пустой 2D путь",
    "bitbybit.jscad.path.close": "замкнуть",
    "close": "замкнуть",
    "bitbybit.jscad.path.close_description": "Закрывает открытый 2D путь",
    "bitbybit.jscad.path.appendPoints": "добавить точки",
    "appendPoints": "добавить точки",
    "bitbybit.jscad.path.appendPoints_description": "Добавить к пути 2D точки",
    "append": "добавить",
    "bitbybit.jscad.path.appendPolyline": "добавить полилинию",
    "appendPolyline": "добавить полилинию",
    "bitbybit.jscad.path.appendPolyline_description": "Добавить к пути полилинию",
    "bitbybit.jscad.path.appendArc": "добавить дугу",
    "appendArc": "добавить дугу",
    "bitbybit.jscad.path.appendArc_description": "Добавить дугу к пути",
    "xAxisRotation": "вращение оси X",
    "clockwise": "по часовой стрелке",
    "large": "большой",
    "bitbybit.jscad.polygon.createFromPoints": "из точек",
    "bitbybit.jscad.polygon.createFromPoints_description": "Создать 2D полигон из списка точек",
    "bitbybit.jscad.polygon.createFromPolyline": "из полилинии",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Создать 2D полигон из полилинии",
    "bitbybit.jscad.polygon.createFromCurve": "из кривой",
    "createFromCurve": "создать из кривой",
    "bitbybit.jscad.polygon.createFromCurve_description": "Создать 2D полигон из кривой",
    "bitbybit.jscad.polygon.createFromPath": "из пути",
    "createFromPath": "создать из пути",
    "bitbybit.jscad.polygon.createFromPath_description": "Создать 2D полигон из пути",
    "bitbybit.jscad.polygon.circle": "окружность",
    "bitbybit.jscad.polygon.circle_description": "Создать 2D полигон круг",
    "bitbybit.jscad.polygon.ellipse": "эллипс",
    "ellipse": "эллипс",
    "bitbybit.jscad.polygon.ellipse_description": "Создать 2D полигон эллипс",
    "bitbybit.jscad.polygon.rectangle": "прямоугольник",
    "rectangle": "прямоугольник",
    "bitbybit.jscad.polygon.rectangle_description": "Создать 2D полигон прямоугольник",
    "bitbybit.jscad.polygon.roundedRectangle": "скругленный прямоугольник",
    "roundedRectangle": "скругленный прямоугольник",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Создать 2D скругленный прямоугольник",
    "roundRadius": "радиус скругления",
    "bitbybit.jscad.polygon.square": "квадрат",
    "square": "квадрат",
    "bitbybit.jscad.polygon.square_description": "Создать 2D полигон квадрат",
    "bitbybit.jscad.polygon.star": "звезда",
    "star": "звезда",
    "bitbybit.jscad.polygon.star_description": "Создать 2D полигон звезда",
    "vertices": "вершины",
    "bitbybit.jscad.shapes.cube": "куб",
    "cube": "куб",
    "bitbybit.jscad.shapes.cube_description": "Создать 3D форму куба",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "кубы на центральных точках",
    "cubesOnCenterPoints": "кубы на центральных точках",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Создать 3D кубы на нескольких центральных точках",
    "primitives on centers": "примитивы на центрах",
    "bitbybit.jscad.shapes.cuboid": "параллелепипед",
    "cuboid": "параллелепипед",
    "bitbybit.jscad.shapes.cuboid_description": "Создать 3D форму кубоида",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "параллелепипеды на центральных точках",
    "cuboidsOnCenterPoints": "параллелепипеды на центральных точках",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Создать 3D кубоиды на нескольких центральных точках",
    "bitbybit.jscad.shapes.cylinderElliptic": "эллиптический цилиндр",
    "cylinderElliptic": "эллиптический цилиндр",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Создать 3D эллиптический цилиндр",
    "startRadius": "начальный радиус",
    "endRadius": "конечный радиус",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "эллиптические цилиндры на центральных точках",
    "cylinderEllipticOnCenterPoints": "эллиптические цилиндры на центральных точках",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Создать 3D эллиптические цилиндры на нескольких центральных точках",
    "bitbybit.jscad.shapes.cylinder": "цилиндр",
    "cylinder": "цилиндр",
    "bitbybit.jscad.shapes.cylinder_description": "Создать 3D цилиндр",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "цилиндры на центральных точках",
    "cylindersOnCenterPoints": "цилиндры на центральных точках",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Создать 3D цилиндры на нескольких центральных точках",
    "bitbybit.jscad.shapes.ellipsoid": "эллипсоид",
    "ellipsoid": "эллипсоид",
    "bitbybit.jscad.shapes.ellipsoid_description": "Создать 3D эллипсоид",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "эллипсоиды на центральных точках",
    "ellipsoidsOnCenterPoints": "эллипсоиды на центральных точках",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Создать 3D эллипсоиды на нескольких центральных точках",
    "bitbybit.jscad.shapes.geodesicSphere": "геодезическая сфера",
    "geodesicSphere": "геодезическая сфера",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Создать 3D геодезическую сферу",
    "frequency": "частота",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "геодезические сферы на центральных точках",
    "geodesicSpheresOnCenterPoints": "геодезические сферы на центральных точках",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Создать 3D геодезические сферы на нескольких центральных точках",
    "bitbybit.jscad.shapes.roundedCuboid": "скругленный параллелепипед",
    "roundedCuboid": "скругленный параллелепипед",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Создать 3D скругленный кубоид",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "скругленные параллелепипеды на центральных точках",
    "roundedCuboidsOnCenterPoints": "скругленные параллелепипеды на центральных точках",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Создать 3D скругленные кубоиды на нескольких центральных точках",
    "bitbybit.jscad.shapes.roundedCylinder": "скругленный цилиндр",
    "roundedCylinder": "скругленный цилиндр",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Создать 3D скругленный цилиндр",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "скругленные цилиндры на центральных точках",
    "roundedCylindersOnCenterPoints": "скругленные цилиндры на центральных точках",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Создать 3D скругленные цилиндры на нескольких центральных точках",
    "bitbybit.jscad.shapes.sphere": "сфера",
    "sphere": "сфера",
    "bitbybit.jscad.shapes.sphere_description": "Создать 3D сферу",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "сферы на центральных точках",
    "spheresOnCenterPoints": "сферы на центральных точках",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Создать 3D сферу на нескольких центральных точках",
    "bitbybit.jscad.shapes.torus": "тор",
    "torus": "тор",
    "bitbybit.jscad.shapes.torus_description": "Создать 3D тор",
    "innerSegments": "внутренние сегменты",
    "outerSegments": "внешние сегменты",
    "innerRotation": "внутреннее вращение",
    "outerRotation": "внешнее вращение",
    "bitbybit.jscad.shapes.fromPolygonPoints": "из точек полигона",
    "fromPolygonPoints": "из точек полигона",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Создать 3D форму из полигональных точек, которые должны быть вложенными массивами точек",
    "polygonPoints": "точки полигона",
    "Base.Point3[][]": "массив массивов базовых точек 3",
    "bitbybit.jscad.text.cylindricalText": "цилиндрический текст",
    "cylindricalText": "цилиндрический текст",
    "bitbybit.jscad.text.cylindricalText_description": "Создает текст, основанный на цепных оболочках цилиндров",
    "extrusionHeight": "высота выдавливания",
    "extrusionSize": "размер выдавливания",
    "jscadTextAlignEnum": "перечисление выравнивания текста jscad",
    "bitbybit.jscad.text.sphericalText": "сферический текст",
    "sphericalText": "сферический текст",
    "bitbybit.jscad.text.sphericalText_description": "Создает текст, основанный на цепных оболочках сфер",
    "bitbybit.jscad.text.createVectorText": "векторный текст",
    "createVectorText": "создать векторный текст",
    "bitbybit.jscad.text.createVectorText_description": "Создает векторный текст",
    "bitbybit.jscad.colors.colorize": "раскрасить",
    "colors": "цвета",
    "colorize": "раскрасить",
    "bitbybit.jscad.colors.colorize_description": "Окрашивает геометрию jscad. Если геометрия находится в массиве, он окрасит все элементы и вернет их. Если геометрия - это один элемент, он вернет один элемент. Имейте в виду, что окрашенная геометрия в jscad всегда будет рисоваться этим цветом, даже если вы попытаетесь изменить его через параметры рисования.",
    "bitbybit.manifold.manifoldToMeshPointer": "указатель Manifold в меш",
    "manifold": "Manifold",
    "manifoldToMeshPointer": "указатель Manifold в меш",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Превращает форму manifold в указатель сетки, который живет в памяти worker. Этот указатель можно использовать с функциями bitbybit.manifold.mesh",
    "meshing": "создание меша",
    "normalIdx": "индекс нормали",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "разложить Manifold или поперечное сечение",
    "decomposeManifoldOrCrossSection": "разложить Manifold или поперечное сечение",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Разлагает форму manifold или поперечное сечение на сетку или простые полигоны",
    "decompose": "разложить",
    "manifoldOrCrossSection": "Manifold или поперечное сечение",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "разложить Manifolds или поперечные сечения",
    "decomposeManifoldsOrCrossSections": "разложить Manifolds или поперечные сечения",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Разлагает форму manifold или поперечное сечение на сетку или простые полигоны",
    "manifoldsOrCrossSections": "Manifolds или поперечные сечения",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "удалить Manifold или поперечное сечение",
    "deleteManifoldOrCrossSection": "удалить Manifold или поперечное сечение",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Удалить manifold или поперечное сечение из памяти",
    "cleanup": "очистка",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "удалить Manifolds или поперечные сечения",
    "deleteManifoldsOrCrossSections": "удалить Manifolds или поперечные сечения",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Удалить manifolds или поперечные сечения из памяти",
    "bitbybit.manifold.manifold.manifoldToMesh": "Manifold в меш",
    "manifoldToMesh": "Manifold в меш",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Превращает форму manifold в сетку",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "Manifolds в меши",
    "manifoldsToMeshes": "Manifolds в меши",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "превращает формы Manifold в меши",
    "manifolds": "Manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "Manifold из меша",
    "manifoldFromMesh": "Manifold из меша",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Преобразует Mesh в Manifold, сохраняя его свойства и объединяя только позиции в соответствии с векторами слияния. Выдаст ошибку, если результат не является ориентированным 2-manifold. Свернет вырожденные треугольники и ненужные вершины. Все поля считываются, что делает эту структуру подходящей для циклического обмена данными без потерь из manifoldToMesh(). Для мультиматериального ввода используйте reserveIDs(), чтобы установить уникальный originalID для каждого материала, и отсортируйте материалы по треугольным прогонам.",
    "DecomposedManifoldMeshDto": "DTO разложенного меша Manifold",
    "bitbybit.manifold.manifold.shapes.cube": "куб",
    "bitbybit.manifold.manifold.shapes.cube_description": "Создать форму 3D куба",
    "bitbybit.manifold.manifold.shapes.sphere": "сфера",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Создать форму 3D сферы",
    "circularSegments": "круговые сегменты",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "тетраэдр",
    "tetrahedron": "тетраэдр",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Создать форму 3D тетраэдра",
    "bitbybit.manifold.manifold.shapes.cylinder": "цилиндр",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Создать форму 3D цилиндра",
    "radiusLow": "нижний радиус",
    "radiusHigh": "верхний радиус",
    "bitbybit.manifold.manifold.booleans.subtract": "вычесть",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Вычесть две формы manifold",
    "a to b": "от a к b",
    "manifold1": "Manifold 1",
    "manifold2": "Manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "сложить",
    "bitbybit.manifold.manifold.booleans.add_description": "Сложить две формы manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "пересечь",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Пересечь две формы manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "разность двух",
    "differenceTwo": "разность двух",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "разность двух форм Manifold",
    "2 manifolds": "2 Manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "объединение двух",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "объединение двух форм Manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "пересечение двух",
    "intersectionTwo": "пересечение двух",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "пересечение двух форм Manifold",
    "bitbybit.manifold.manifold.booleans.difference": "разность",
    "bitbybit.manifold.manifold.booleans.difference_description": "разность нескольких форм Manifold",
    "bitbybit.manifold.manifold.booleans.union": "объединение",
    "bitbybit.manifold.manifold.booleans.union_description": "объединение нескольких форм Manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "пересечение",
    "bitbybit.manifold.manifold.booleans.intersection_description": "пересечение нескольких форм Manifold",
    "bitbybit.manifold.manifold.booleans.split": "разделить",
    "split": "разделить",
    "bitbybit.manifold.manifold.booleans.split_description": "Разделить manifold другим manifold",
    "manifoldToSplit": "Manifold для разделения",
    "manifoldCutter": "Режущий Manifold",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "разделить плоскостью",
    "splitByPlane": "разделить плоскостью",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Разделить manifold плоскостью",
    "originOffset": "смещение начала координат",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "разделить плоскостью по смещениям",
    "splitByPlaneOnOffsets": "разделить плоскостью по смещениям",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Разделить manifold плоскостью на различных смещениях",
    "originOffsets": "смещения начала координат",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "обрезать плоскостью",
    "trimByPlane": "обрезать плоскостью",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Обрезать manifold плоскостью",
    "trim": "обрезать",
    "bitbybit.manifold.manifold.operations.hull": "оболочка",
    "bitbybit.manifold.manifold.operations.hull_description": "Вычисляет выпуклую оболочку предоставленной формы manifold",
    "bitbybit.manifold.manifold.operations.hullPoints": "оболочка точек",
    "hullPoints": "оболочка точек",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Оболочка точек или manifolds",
    "bitbybit.manifold.manifold.operations.slice": "срез",
    "bitbybit.manifold.manifold.operations.slice_description": "Возвращает поперечное сечение этого объекта параллельно плоскости X-Y на указанной высоте. Использование высоты, равной нижней части ограничивающего параллелепипеда, вернет нижние грани, в то время как использование высоты, равной верхней части ограничивающего параллелепипеда, вернет пустоту.",
    "cross sections": "поперечные сечения",
    "bitbybit.manifold.manifold.operations.project": "проекция",
    "bitbybit.manifold.manifold.operations.project_description": "Создает проекцию на плоскость xy из контура формы",
    "bitbybit.manifold.manifold.operations.setTolerance": "установить допуск",
    "setTolerance": "установить допуск",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Возвращает копию manifold с установленным значением допуска. Это выполняет упрощение сетки при увеличении значения допуска.",
    "basic": "базовый",
    "bitbybit.manifold.manifold.operations.reserveIds": "зарезервировать ID",
    "reserveIds": "зарезервировать ID",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Возвращает первый из n последовательных новых уникальных идентификаторов сетки для маркировки наборов треугольников, которые можно найти после дальнейших операций. Назначить вектору Mesh.runOriginalID.",
    "count": "количество",
    "bitbybit.manifold.manifold.operations.asOriginal": "как оригинал",
    "asOriginal": "как оригинал",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "Если вы копируете manifold, но хотите, чтобы у этой новой копии были новые свойства (например, другое UV-отображение), вы можете сбросить его идентификаторы на новый оригинал, что означает, что теперь на него будут ссылаться его потомки, а не сетки, из которых он был построен, что позволит вам различать копии при применении ваших свойств к конечному результату. Эта функция также уплотняет все копланарные грани в отношении и сворачивает эти ребра. Если вы хотите иметь несогласованные свойства на этих гранях, то есть вы хотите сохранить некоторые из этих ребер, вам следует вместо этого вызвать GetMesh(), вычислить свои свойства и использовать их для создания нового manifold.",
    "bitbybit.manifold.manifold.operations.compose": "составить",
    "compose": "составить",
    "bitbybit.manifold.manifold.operations.compose_description": "Конструирует новый manifold из списка других manifolds. Это чисто топологическая операция, поэтому следует проявлять осторожность, чтобы избежать создания перекрывающихся результатов. Это обратная операция Decompose().",
    "composition": "композиция",
    "bitbybit.manifold.manifold.operations.decompose": "разложить",
    "bitbybit.manifold.manifold.operations.decompose_description": "Эта операция возвращает вектор Manifolds, которые топологически не связаны. Если все связано, вектор имеет длину один, содержащий копию оригинала. Это обратная операция Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "вычислить нормали",
    "calculateNormals": "вычислить нормали",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Заполняет свойства вершин для нормальных векторов, вычисленных из геометрии сетки. Плоские грани, состоящие из трех или более треугольников, останутся плоскими.",
    "adjustments": "корректировки",
    "minSharpAngle": "мин. острый угол",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "вычислить кривизну",
    "calculateCurvature": "вычислить кривизну",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "Кривизна - это обратная величина радиуса кривизны, со знаком, таким что положительное значение означает выпуклость, а отрицательное - вогнутость. В любой точке на manifold есть две ортогональные главные кривизны, одна максимальная, а другая минимальная. Гауссова кривизна - это их произведение, а средняя кривизна - их сумма. Это аппроксимирует их для каждой вершины и назначает их в качестве свойств вершины на заданных каналах.",
    "gaussianIdx": "индекс Гаусса",
    "meanIdx": "индекс средней кривизны",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "уточнить до допуска",
    "refineToTolerance": "уточнить до допуска",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Увеличивает плотность сетки, разбивая каждое ребро на части так, чтобы любая точка на результирующих треугольниках находилась примерно в пределах допуска гладко изогнутой поверхности, определенной касательными векторами. Это означает, что сильно изогнутые области будут разделены более тонко, чем более гладкие области. Если halfedgeTangents отсутствуют, результатом будет просто копия оригинала. Квадраты будут игнорировать свою внутреннюю биссектрису треугольника.",
    "bitbybit.manifold.manifold.operations.refineToLength": "уточнить до длины",
    "refineToLength": "уточнить до длины",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Увеличивает плотность сетки, разбивая каждое ребро на части примерно заданной длины. Внутренние вершины добавляются, чтобы остальные ребра триангуляции также были примерно той же длины. Если halfedgeTangents присутствуют (например, из конструктора Smooth()), новые вершины будут перемещены на интерполированную поверхность в соответствии с их барицентрическими координатами.",
    "bitbybit.manifold.manifold.operations.refine": "уточнить",
    "refine": "уточнить",
    "bitbybit.manifold.manifold.operations.refine_description": "Увеличивает плотность сетки, разбивая каждое ребро на n частей. Например, при n = 2 каждый треугольник будет разбит на 4 треугольника. Все они будут копланарными (и не будут немедленно свернуты), если только MeshManifold не имеет указанных halfedgeTangents (например, из конструктора Smooth()), в этом случае новые вершины будут перемещены на интерполированную поверхность в соответствии с их барицентрическими координатами.",
    "bitbybit.manifold.manifold.operations.smoothOut": "сгладить",
    "smoothOut": "сгладить",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Сглаживает Manifold, заполняя векторы halfedgeTangent. Геометрия останется неизменной до тех пор, пока не будет вызван Refine или RefineToLength для интерполяции поверхности. Эта версия использует геометрию треугольников и псевдонормалей для определения касательных векторов.",
    "minSmoothness": "мин. гладкость",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "сгладить по нормалям",
    "smoothByNormals": "сгладить по нормалям",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Сглаживает Manifold, заполняя векторы halfedgeTangent. Геометрия останется неизменной до тех пор, пока не будет вызван Refine или RefineToLength для интерполяции поверхности. Эта версия использует предоставленные свойства нормалей вершин для определения касательных векторов.",
    "bitbybit.manifold.manifold.transforms.scale3D": "масштабировать 3D",
    "scale3D": "масштабировать 3D",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Масштабирует форму manifold с помощью 3D вектора",
    "bitbybit.manifold.manifold.transforms.scale": "масштабировать",
    "bitbybit.manifold.manifold.transforms.scale_description": "Масштабирует форму manifold с помощью одного коэффициента",
    "bitbybit.manifold.manifold.transforms.mirror": "отразить",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Зеркально отражает форму manifold относительно плоскости, определенной нормальным вектором",
    "bitbybit.manifold.manifold.transforms.translate": "переместить",
    "bitbybit.manifold.manifold.transforms.translate_description": "Перемещает форму manifold вдоль вектора",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "переместить векторами",
    "translateByVectors": "переместить векторами",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Перемещает форму manifold вдоль нескольких векторов",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "переместить XYZ",
    "translateXYZ": "переместить XYZ",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Перемещает форму manifold вдоль x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "вращать",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Вращает форму manifold вдоль вектора, содержащего углы Эйлера",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "вращать XYZ",
    "rotateXYZ": "вращать XYZ",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Вращает форму manifold вдоль углов Эйлера x y z",
    "bitbybit.manifold.manifold.transforms.transform": "трансформировать",
    "bitbybit.manifold.manifold.transforms.transform_description": "Трансформирует форму manifold с помощью матрицы трансформации 4x4",
    "matrix": "матрица",
    "Base.TransformMatrix": "базовая матрица преобразования",
    "bitbybit.manifold.manifold.transforms.transforms": "преобразования",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Трансформирует форму manifold с помощью матриц трансформации 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "площадь поверхности",
    "evaluate": "вычислить",
    "surfaceArea": "площадь поверхности",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Получить площадь поверхности manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "объём",
    "volume": "объём",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Получить объем manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "пустой",
    "isEmpty": "пустой",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Проверить, содержит ли manifold треугольники",
    "bitbybit.manifold.manifold.evaluate.numVert": "кол-во вершин",
    "numVert": "кол-во вершин",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Получить количество вершин в manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "кол-во треуг.",
    "numTri": "кол-во треуг.",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Получить количество треугольников в manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "кол-во рёбер",
    "numEdge": "кол-во рёбер",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Получить количество ребер в manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "кол-во свойств",
    "numProp": "кол-во свойств",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Получить количество свойств в manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "кол-во вершин свойств",
    "numPropVert": "кол-во вершин свойств",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "Количество вершин свойств в Manifold. Это всегда будет >= numVert, так как некоторые физические вершины могут дублироваться для учета разных свойств на разных соседних треугольниках.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "ограничивающий бокс",
    "boundingBox": "ограничивающий бокс",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Возвращает выровненный по осям ограничивающий параллелепипед всех вершин Manifold.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "допуск",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Возвращает допуск вершин этого Manifold, который отслеживает приблизительную ошибку округления по всем трансформациям и операциям, которые привели к этому состоянию. Любые треугольники, которые коллинеарны в пределах этого допуска, считаются вырожденными и удаляются.",
    "bitbybit.manifold.manifold.evaluate.genus": "род",
    "genus": "род",
    "bitbybit.manifold.manifold.evaluate.genus_description": "Род - это топологическое свойство manifold, представляющее количество ручек. Сфера - 0, тор - 1 и т.д. Это имеет смысл только для одной сетки, поэтому лучше сначала вызвать Decompose().",
    "bitbybit.manifold.manifold.evaluate.minGap": "мин. зазор",
    "minGap": "мин. зазор",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Возвращает минимальный зазор между двумя manifolds. Возвращает float между 0 и searchLength.",
    "searchLength": "длина поиска",
    "bitbybit.manifold.manifold.evaluate.originalID": "исходный ID",
    "originalID": "исходный ID",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "Если эта сетка является оригиналом, это возвращает ее ID, на который могут ссылаться manifolds продукта. Если этот manifold является продуктом, это возвращает -1.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "поперечное сечение в полигоны",
    "crossSection": "поперечное сечение",
    "crossSectionToPolygons": "поперечное сечение в полигоны",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "превращает поперечное сечение в полигоны",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "поперечные сечения в полигоны",
    "crossSectionsToPolygons": "поперечные сечения в полигоны",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "превращает поперечные сечения в полигоны",
    "crossSections": "поперечные сечения",
    "bitbybit.manifold.crossSection.shapes.create": "создать",
    "bitbybit.manifold.crossSection.shapes.create_description": "Создать 2d поперечное сечение из набора контуров (сложные полигоны). Операция логического объединения (с правилом заполнения Positive по умолчанию) выполняется для объединения перекрывающихся полигонов и обеспечения отсутствия пересечений в результирующем CrossSection.",
    "Base.Vector2[][]": "массив массивов базовых векторов 2",
    "fillRule": "правило заливки",
    "fillRuleEnum": "перечисление правила заливки",
    "bitbybit.manifold.crossSection.shapes.square": "квадрат",
    "bitbybit.manifold.crossSection.shapes.square_description": "Создать 2D квадратное поперечное сечение",
    "bitbybit.manifold.crossSection.shapes.circle": "окружность",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Создать 2D круглое поперечное сечение",
    "bitbybit.manifold.crossSection.shapes.rectangle": "прямоугольник",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Создать 2D прямоугольное поперечное сечение",
    "bitbybit.manifold.crossSection.operations.hull": "оболочка",
    "bitbybit.manifold.crossSection.operations.hull_description": "Вычислить выпуклую оболочку для поперечного сечения",
    "bitbybit.manifold.crossSection.operations.extrude": "выдавить",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Выдавить поперечное сечение для создания 3D формы",
    "nDivisions": "n делений",
    "twistDegrees": "градусы скручивания",
    "scaleTopX": "масштаб верха X",
    "scaleTopY": "масштаб верха Y",
    "bitbybit.manifold.crossSection.operations.revolve": "вращать",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Вращать поперечное сечение для создания 3D формы",
    "revolveDegrees": "градусы вращения",
    "matchProfile": "соответствовать профилю",
    "bitbybit.manifold.crossSection.operations.offset": "смещение",
    "bitbybit.manifold.crossSection.operations.offset_description": "Смещает поперечное сечение для создания нового поперечного сечения с заданной дельтой (использует алгоритм Clipper2).",
    "manifoldJoinTypeEnum": "перечисление типа соединения Manifold",
    "miterLimit": "предел скоса",
    "bitbybit.manifold.crossSection.operations.simplify": "упростить",
    "simplify": "упростить",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Удалить вершины из контуров в этой CrossSection, которые находятся менее чем на указанном расстоянии эпсилон от воображаемой линии, проходящей через две соседние вершины. Близкие дублирующиеся вершины и коллинеарные точки будут удалены при более низких эпсилонах, при этом удаление сегментов линии становится все более агрессивным с увеличением эпсилонов. Рекомендуется применять эту функцию после Offset, чтобы очистить любые паразитные крошечные сегменты линии, которые не улучшают операции смещения, что усугубило бы проблему.",
    "epsilon": "эпсилон",
    "bitbybit.manifold.crossSection.operations.compose": "составить",
    "bitbybit.manifold.crossSection.operations.compose_description": "Собирает несколько поперечных сечений или полигонов в одно поперечное сечение",
    "bitbybit.manifold.crossSection.operations.decompose": "разложить",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Разлагает поперечные сечения, которые топологически не связаны, каждое из которых содержит один внешний контур с нулем или более отверстиями.",
    "bitbybit.manifold.crossSection.booleans.subtract": "вычесть",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Вычесть два поперечных сечения",
    "crossSection1": "поперечное сечение 1",
    "crossSection2": "поперечное сечение 2",
    "bitbybit.manifold.crossSection.booleans.add": "сложить",
    "bitbybit.manifold.crossSection.booleans.add_description": "Сложить два поперечных сечения",
    "bitbybit.manifold.crossSection.booleans.intersect": "пересечь",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Пересечь два поперечных сечения",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "разность двух",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "разность двух поперечных сечений",
    "2 cross sections": "2 поперечных сечения",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "объединение двух",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "объединение двух поперечных сечений",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "пересечение двух",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "пересечение двух поперечных сечений",
    "bitbybit.manifold.crossSection.booleans.difference": "разность",
    "bitbybit.manifold.crossSection.booleans.difference_description": "разность нескольких поперечных сечений",
    "bitbybit.manifold.crossSection.booleans.union": "объединение",
    "bitbybit.manifold.crossSection.booleans.union_description": "объединение нескольких поперечных сечений",
    "bitbybit.manifold.crossSection.booleans.intersection": "пересечение",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "пересечение нескольких поперечных сечений",
    "bitbybit.manifold.crossSection.transforms.scale2D": "масштабировать 2D",
    "scale2D": "масштабировать 2D",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Масштабирует форму поперечного сечения с помощью 2D вектора",
    "bitbybit.manifold.crossSection.transforms.scale": "масштабировать",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Масштабирует форму поперечного сечения с помощью одного коэффициента",
    "bitbybit.manifold.crossSection.transforms.mirror": "отразить",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Зеркально отражает форму поперечного сечения относительно плоскости, определенной нормальным вектором",
    "bitbybit.manifold.crossSection.transforms.translate": "переместить",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Перемещает форму поперечного сечения вдоль вектора",
    "bitbybit.manifold.crossSection.transforms.translateXY": "переместить XY",
    "translateXY": "переместить XY",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Перемещает форму поперечного сечения вдоль x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "вращать",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Вращает форму поперечного сечения вдоль содержащихся градусов",
    "degrees": "градусы",
    "bitbybit.manifold.crossSection.transforms.transform": "трансформировать",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Трансформирует форму поперечного сечения с помощью матрицы трансформации 3x3",
    "Base.TransformMatrix3x3": "базовая матрица преобразования 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "площадь",
    "area": "площадь",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Получить площадь поперечного сечения",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "пустой",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Проверить, пустое ли поперечное сечение",
    "bitbybit.manifold.crossSection.evaluate.numVert": "кол-во вершин",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Получить количество вершин в поперечном сечении",
    "bitbybit.manifold.crossSection.evaluate.numContour": "кол-во контуров",
    "numContour": "кол-во контуров",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Получить количество контуров в поперечном сечении",
    "bitbybit.manifold.crossSection.evaluate.bounds": "границы",
    "bounds": "границы",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Получить границы контура как прямоугольник. Вывод дается в двух точках vec2 в массиве. Первый массив - это мин. точка, второй - макс. точка.",
    "bitbybit.manifold.mesh.operations.merge": "объединить",
    "merge": "объединить",
    "bitbybit.manifold.mesh.operations.merge_description": "Обновляет векторы mergeFromVert и mergeToVert для создания твердого тела manifold. Если MeshGL уже manifold, изменений не произойдет, и функция вернет false. В противном случае это объединит вершины вдоль открытых ребер в пределах допуска (максимум допуска MeshGL и базового допуска ограничивающего параллелепипеда), сохраняя любые из существующих векторов слияния. Нет гарантии, что результат будет manifold - это вспомогательная функция, разработанная в основном для помощи в случае, когда был создан мультиматериальный MeshGL manifold, но его векторы слияния были потеряны из-за циклического обмена через формат файла. Создание Manifold из результата сообщит о статусе, если он не manifold.",
    "bitbybit.manifold.mesh.evaluate.position": "позиция",
    "bitbybit.manifold.mesh.evaluate.position_description": "Получить позицию по индексу вершины сетки",
    "vertexIndex": "индекс вершины",
    "bitbybit.manifold.mesh.evaluate.verts": "вершины",
    "verts": "вершины",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Получает три индекса вершин этого треугольника в порядке против часовой стрелки.",
    "triangleIndex": "индекс треугольника",
    "bitbybit.manifold.mesh.evaluate.tangent": "касательная",
    "tangent": "касательная",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Получает вектор касательной, начинающийся в verts(tri)[j] и указывающий на следующую точку Безье вдоль ребра против часовой стрелки. Четвертое значение - его вес.",
    "halfEdgeIndex": "индекс полуребра",
    "bitbybit.manifold.mesh.evaluate.extras": "дополнительно",
    "extras": "дополнительно",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Получает любые другие свойства, связанные с этой вершиной.",
    "bitbybit.manifold.mesh.evaluate.transform": "преобразование",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Получает матрицу трансформации 4x4 с приоритетом столбцов от исходной сетки к этим связанным треугольникам.",
    "bitbybit.manifold.mesh.evaluate.numProp": "кол-во свойств",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Количество свойств на вершину, всегда >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "кол-во вершин",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Количество вершин свойств",
    "bitbybit.manifold.mesh.evaluate.numTri": "кол-во треуг.",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Получить количество треугольников на сетке",
    "bitbybit.manifold.mesh.evaluate.numRun": "кол-во проходов",
    "numRun": "кол-во проходов",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Количество прогонов треугольников. Каждый прогон треугольников - это набор последовательных треугольников, которые все происходят из одного экземпляра одной и той же входной сетки.",
    "bitbybit.logic.boolean": "логический",
    "logic": "логика",
    "bitbybit.logic.boolean_description": "Создает и возвращает логическое значение (пропуск для логического ввода). Пример: true → true, false → false",
    "bitbybit.logic.randomBooleans": "случайные логические",
    "randomBooleans": "случайные логические",
    "bitbybit.logic.randomBooleans_description": "Генерирует случайный логический список, где каждое значение имеет пороговый шанс быть истинным. Пример: length=5, threshold=0.7 → может вернуть [true, true, false, true, true]",
    "trueThreshold": "порог 'истина'",
    "bitbybit.logic.twoThresholdRandomGradient": "случайный градиент с двумя порогами",
    "twoThresholdRandomGradient": "случайный градиент с двумя порогами",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Преобразует числа в логические значения, используя два порога с градиентной рандомизацией между ними. Значения ниже trueThreshold → всегда true, выше falseThreshold → всегда false. Между порогами → градиент вероятности (ближе к false порогу = выше шанс false). Пример: [0.1, 0.4, 0.6, 0.9] с порогами [0.3, 0.7] → [true, gradient, gradient, false]",
    "numbers": "числа",
    "thresholdTotalTrue": "порог всего 'истина'",
    "thresholdTotalFalse": "порог всего 'ложь'",
    "nrLevels": "кол-во уровней",
    "bitbybit.logic.thresholdBooleanList": "список логических значений с порогом",
    "thresholdBooleanList": "список логических значений с порогом",
    "bitbybit.logic.thresholdBooleanList_description": "Преобразует числа в логические значения на основе порога (ниже порога → true, выше → false). Можно инвертировать, чтобы перевернуть логику. Пример: [0.3, 0.7, 0.5] с порогом=0.6 → [true, false, true]",
    "threshold": "порог",
    "bitbybit.logic.thresholdGapsBooleanList": "список логических значений с порогами зазоров",
    "thresholdGapsBooleanList": "список логических значений с порогами зазоров",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Преобразует числа в логические значения, используя несколько порогов диапазона (промежутки определяют истинные диапазоны). Значения внутри любого диапазона промежутка → true, вне всех промежутков → false. Можно инвертировать. Пример: [0.2, 0.5, 0.8] с промежутками [[0.3, 0.6], [0.7, 0.9]] → [false, true, true]",
    "gapThresholds": "пороги зазоров",
    "Base.Vector2[]": "массив базовых векторов 2",
    "bitbybit.logic.not": "не",
    "not": "не",
    "bitbybit.logic.not_description": "Применяет оператор NOT, чтобы перевернуть логическое значение. Пример: true → false, false → true",
    "bitbybit.logic.notList": "список 'не'",
    "notList": "список 'не'",
    "bitbybit.logic.notList_description": "Применяет оператор NOT, чтобы перевернуть все логические значения в списке. Пример: [true, false, true] → [false, true, false]",
    "bitbybit.logic.compare": "сравнить",
    "compare": "сравнить",
    "bitbybit.logic.compare_description": "Сравнивает два значения, используя различные операторы (==, !=, ===, !==, <, <=, >, >=). Пример: 5 > 3 → true, 'привет' === 'мир' → false",
    "operator": "оператор",
    "BooleanOperatorsEnum": "перечисление логических операторов",
    "bitbybit.logic.valueGate": "шлюз значения",
    "valueGate": "шлюз значения",
    "bitbybit.logic.valueGate_description": "Условно пропускает значение, если логическое значение истинно, в противном случае возвращает undefined. Пример: value=42, boolean=true → 42, value=42, boolean=false → undefined",
    "bitbybit.logic.firstDefinedValueGate": "шлюз первого определенного значения",
    "firstDefinedValueGate": "шлюз первого определенного значения",
    "bitbybit.logic.firstDefinedValueGate_description": "Возвращает первое определенное (не undefined) значение из двух вариантов (шаблон fallback). Пример: value1=42, value2=10 → 42, value1=undefined, value2=10 → 10",
    "value1": "значение 1",
    "value2": "значение 2",
    "bitbybit.math.number": "число",
    "math": "математика",
    "bitbybit.math.number_description": "Создает и возвращает числовое значение (пропуск для числового ввода). Пример: Ввод 42 → 42, Ввод 3.14 → 3.14",
    "bitbybit.math.twoNrOperation": "операция с двумя числами",
    "twoNrOperation": "операция с двумя числами",
    "bitbybit.math.twoNrOperation_description": "Выполняет базовые арифметические операции с двумя числами (сложение, вычитание, умножение, деление, степень, модуль). Пример: 5 + 3 → 8, 10 % 3 → 1, 2 ^ 3 → 8",
    "operation": "операция",
    "mathTwoNrOperatorEnum": "перечисление математических операторов для двух чисел",
    "bitbybit.math.modulus": "остаток от деления",
    "modulus": "остаток от деления",
    "bitbybit.math.modulus_description": "Вычисляет остаток от деления (операция модуля). Пример: 10 % 3 → 1, 17 % 5 → 2",
    "bitbybit.math.roundToDecimals": "округлить до десятичных знаков",
    "roundToDecimals": "округлить до десятичных знаков",
    "bitbybit.math.roundToDecimals_description": "Округляет число до указанных десятичных знаков. Пример: 1.32156 с 3 знаками возвращает 1.322",
    "decimalPlaces": "десятичные знаки",
    "bitbybit.math.oneNrOperation": "операция с одним числом",
    "oneNrOperation": "операция с одним числом",
    "bitbybit.math.oneNrOperation_description": "Выполняет математические операции с одним числом (абсолютное значение, отрицание, корень, тригонометрические функции, логарифмы и т.д.). Пример: sqrt(5) → 2.236, abs(-3) → 3, sin(π2) → 1",
    "mathOneNrOperatorEnum": "перечисление математических операторов для одного числа",
    "bitbybit.math.remap": "перемасштабировать",
    "remap": "перемасштабировать",
    "bitbybit.math.remap_description": "Пропорционально отображает число из одного диапазона в другой. Пример: 5 из [0,10] в [0,100] → 50, 0.5 из [0,1] в [-10,10] → 0",
    "fromLow": "от нижнего",
    "fromHigh": "от верхнего",
    "toLow": "к нижнему",
    "toHigh": "к верхнему",
    "bitbybit.math.random": "случайное",
    "random": "случайное",
    "bitbybit.math.random_description": "Генерирует случайное десятичное число от 0 (включительно) до 1 (исключительно). Пример: Вывод типа 0.342, 0.891 или любое значение в [0, 1)",
    "generate": "генерировать",
    "bitbybit.math.randomNumber": "случайное число",
    "randomNumber": "случайное число",
    "bitbybit.math.randomNumber_description": "Генерирует случайное число в указанном диапазоне (от низкого до высокого). Пример: Диапазон [0, 10] → вывод типа 3.7, 8.2 или любое значение от 0 до 10",
    "low": "нижний",
    "high": "верхний",
    "bitbybit.math.randomNumbers": "случайные числа",
    "randomNumbers": "случайные числа",
    "bitbybit.math.randomNumbers_description": "Генерирует несколько случайных чисел в указанном диапазоне. Пример: Диапазон [0, 10] с 3 элементами → [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "Пи",
    "pi": "Пи",
    "bitbybit.math.pi_description": "Возвращает математическую константу π (пи) ≈ 3.14159. Пример: Вывод 3.141592653589793",
    "bitbybit.math.toFixed": "с фикс. точностью",
    "toFixed": "с фикс. точностью",
    "bitbybit.math.toFixed_description": "Форматирует число как строку с фиксированным количеством десятичных знаков (всегда показывает замыкающие нули). Пример: 3.14159 с 2 знаками → '3.14', 5 с 3 знаками → '5.000'",
    "bitbybit.math.add": "сложить",
    "bitbybit.math.add_description": "Складывает два числа вместе. Пример: 5 + 3 → 8, -2 + 7 → 5",
    "basics": "основы",
    "bitbybit.math.subtract": "вычесть",
    "bitbybit.math.subtract_description": "Вычитает второе число из первого. Пример: 10 - 3 → 7, 5 - 8 → -3",
    "bitbybit.math.multiply": "умножить",
    "bitbybit.math.multiply_description": "Умножает два числа вместе. Пример: 5 × 3 → 15, -2 × 4 → -8",
    "bitbybit.math.divide": "разделить",
    "divide": "разделить",
    "bitbybit.math.divide_description": "Делит первое число на второе. Пример: 10 ÷ 2 → 5, 7 ÷ 2 → 3.5",
    "bitbybit.math.power": "степень",
    "power": "степень",
    "bitbybit.math.power_description": "Возводит первое число в степень второго (возведение в степень). Пример: 2³ → 8, 5² → 25, 10⁻¹ → 0.1",
    "bitbybit.math.sqrt": "квадратный корень",
    "sqrt": "квадратный корень",
    "bitbybit.math.sqrt_description": "Вычисляет квадратный корень числа. Пример: √9 → 3, √2 → 1.414, √16 → 4",
    "bitbybit.math.abs": "модуль",
    "abs": "модуль",
    "bitbybit.math.abs_description": "Возвращает абсолютное значение (удаляет отрицательный знак, всегда положительное или ноль). Пример: |-5| → 5, |3| → 3, |0| → 0",
    "bitbybit.math.round": "округлить",
    "round": "округлить",
    "bitbybit.math.round_description": "Округляет число до ближайшего целого. Пример: 3.7 → 4, 2.3 → 2, 5.5 → 6",
    "bitbybit.math.floor": "округлить вниз",
    "floor": "округлить вниз",
    "bitbybit.math.floor_description": "Округляет число вниз до ближайшего целого (к минус бесконечности). Пример: 3.7 → 3, -2.3 → -3, 5 → 5",
    "bitbybit.math.ceil": "округлить вверх",
    "ceil": "округлить вверх",
    "bitbybit.math.ceil_description": "Округляет число вверх до ближайшего целого (к плюс бесконечности). Пример: 3.2 → 4, -2.8 → -2, 5 → 5",
    "bitbybit.math.negate": "отрицание",
    "negate": "отрицание",
    "bitbybit.math.negate_description": "Отрицает число (меняет его знак: положительное становится отрицательным, отрицательное становится положительным). Пример: 5 → -5, -3 → 3, 0 → 0",
    "bitbybit.math.ln": "натуральный логарифм",
    "ln": "натуральный логарифм",
    "bitbybit.math.ln_description": "Вычисляет натуральный логарифм (основание e) числа. Пример: ln(2.718) → ~1, ln(7.389) → ~2, ln(1) → 0",
    "bitbybit.math.log10": "десятичный логарифм",
    "log10": "десятичный логарифм",
    "bitbybit.math.log10_description": "Вычисляет логарифм по основанию 10 числа. Пример: log₁₀(100) → 2, log₁₀(1000) → 3, log₁₀(10) → 1",
    "bitbybit.math.tenPow": "10 в степени",
    "tenPow": "10 в степени",
    "bitbybit.math.tenPow_description": "Возводит 10 в степень входного числа. Пример: 10² → 100, 10³ → 1000, 10⁻¹ → 0.1",
    "bitbybit.math.sin": "синус",
    "sin": "синус",
    "bitbybit.math.sin_description": "Вычисляет синус угла в радианах. Пример: sin(0) → 0, sin(π2) → 1, sin(π) → ~0",
    "bitbybit.math.cos": "косинус",
    "cos": "косинус",
    "bitbybit.math.cos_description": "Вычисляет косинус угла в радианах. Пример: cos(0) → 1, cos(π2) → ~0, cos(π) → -1",
    "bitbybit.math.tan": "тангенс",
    "tan": "тангенс",
    "bitbybit.math.tan_description": "Вычисляет тангенс угла в радианах. Пример: tan(0) → 0, tan(π4) → ~1, tan(π2) → бесконечность",
    "bitbybit.math.asin": "арксинус",
    "asin": "арксинус",
    "bitbybit.math.asin_description": "Вычисляет арксинус (обратный синус) в радианах, возвращает угол, синус которого равен вводу. Пример: asin(0) → 0, asin(1) → π2 (~1.57), asin(0.5) → π6 (~0.524)",
    "bitbybit.math.acos": "арккосинус",
    "acos": "арккосинус",
    "bitbybit.math.acos_description": "Вычисляет арккосинус (обратный косинус) в радианах, возвращает угол, косинус которого равен вводу. Пример: acos(1) → 0, acos(0) → π2 (~1.57), acos(-1) → π (~3.14)",
    "bitbybit.math.atan": "арктангенс",
    "atan": "арктангенс",
    "bitbybit.math.atan_description": "Вычисляет арктангенс (обратный тангенс) в радианах, возвращает угол, тангенс которого равен вводу. Пример: atan(0) → 0, atan(1) → π4 (~0.785), atan(-1) → -π4",
    "bitbybit.math.exp": "экспонента",
    "exp": "экспонента",
    "bitbybit.math.exp_description": "Вычисляет e, возведенное в степень ввода (экспоненциальная функция). Пример: e⁰ → 1, e¹ → ~2.718, e² → ~7.389",
    "bitbybit.math.degToRad": "градусы в радианы",
    "degToRad": "градусы в радианы",
    "bitbybit.math.degToRad_description": "Преобразует угол из градусов в радианы. Пример: 180° → π (~3.14159), 90° → π2 (~1.5708), 360° → 2π",
    "bitbybit.math.radToDeg": "радианы в градусы",
    "radToDeg": "радианы в градусы",
    "bitbybit.math.radToDeg_description": "Преобразует угол из радиан в градусы. Пример: π → 180°, π2 → 90°, 2π → 360°",
    "bitbybit.math.ease": "замедление",
    "bitbybit.math.ease_description": "Применяет функцию плавности для плавной интерполяции между минимальным и максимальным значениями. Пример: x=0.5 от [0,100] с easeInQuad → применяет кривую квадратичного ускорения. Полезно для плавных анимаций с различными кривыми ускорения/замедления.",
    "easeEnum": "перечисление замедления",
    "bitbybit.lists.getItem": "получить элемент",
    "lists": "списки",
    "getItem": "получить элемент",
    "bitbybit.lists.getItem_description": "Получает элемент из списка в определенной позиции, используя индексацию с нуля. Пример: Из [10, 20, 30, 40], получение индекса 2 возвращает 30",
    "list": "список",
    "bitbybit.lists.randomGetThreshold": "случайное получение с порогом",
    "randomGetThreshold": "случайное получение с порогом",
    "bitbybit.lists.randomGetThreshold_description": "Случайным образом сохраняет элементы из списка на основе порога вероятности (от 0 до 1). Пример: Из [1, 2, 3, 4, 5] с порогом 0.5, может вернуть [1, 3, 5] (50% шанс для каждого элемента)",
    "bitbybit.lists.getSubList": "получить подсписок",
    "getSubList": "получить подсписок",
    "bitbybit.lists.getSubList_description": "Извлекает часть списка между начальной и конечной позициями (конец исключается). Пример: Из [10, 20, 30, 40, 50] с start=1 и end=4, возвращает [20, 30, 40]",
    "indexStart": "начальный индекс",
    "indexEnd": "конечный индекс",
    "bitbybit.lists.getNthItem": "получить N-й элемент",
    "getNthItem": "получить N-й элемент",
    "bitbybit.lists.getNthItem_description": "Получает каждый n-й элемент из списка, начиная с необязательной позиции смещения. Пример: Из [0, 1, 2, 3, 4, 5, 6, 7, 8] с nth=3 и offset=0, возвращает [0, 3, 6] Пример: Из [0, 1, 2, 3, 4, 5, 6, 7, 8] с nth=2 и offset=1, возвращает [1, 3, 5, 7]",
    "nth": "N-й",
    "bitbybit.lists.getByPattern": "получить по шаблону",
    "getByPattern": "получить по шаблону",
    "bitbybit.lists.getByPattern_description": "Фильтрует элементы из списка, используя повторяющийся шаблон truefalse. Пример: Из [0, 1, 2, 3, 4, 5] с шаблоном [true, true, false], возвращает [0, 1, 3, 4] (сохраняет элементы, где шаблон true)",
    "pattern": "шаблон",
    "bitbybit.lists.mergeElementsOfLists": "объединить элементы списков",
    "mergeElementsOfLists": "объединить элементы списков",
    "bitbybit.lists.mergeElementsOfLists_description": "Объединяет элементы из нескольких списков на определенном уровне вложенности, группируя элементы по позиции. Пример: Из [[0, 1, 2], [3, 4, 5]] на уровне 0, возвращает [[0, 3], [1, 4], [2, 5]]",
    "level": "уровень",
    "bitbybit.lists.getLongestListLength": "получить длину самого длинного списка",
    "getLongestListLength": "получить длину самого длинного списка",
    "bitbybit.lists.getLongestListLength_description": "Находит длину самого длинного списка среди нескольких списков. Пример: Из [[1, 2], [3, 4, 5, 6], [7]], возвращает 4 (длина [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "обратить",
    "bitbybit.lists.reverse_description": "Меняет порядок элементов в списке на обратный. Пример: Из [1, 2, 3, 4, 5], возвращает [5, 4, 3, 2, 1]",
    "bitbybit.lists.flipLists": "перевернуть списки",
    "flipLists": "перевернуть списки",
    "bitbybit.lists.flipLists_description": "Транспонирует 2D список, меняя местами строки и столбцы (все подсписки должны быть одинаковой длины). Пример: Из [[0, 1, 2], [3, 4, 5]], возвращает [[0, 3], [1, 4], [2, 5]]",
    "bitbybit.lists.groupNth": "сгруппировать по N",
    "groupNth": "сгруппировать по N",
    "bitbybit.lists.groupNth_description": "Разбивает список на меньшие списки по n элементов в каждом. Пример: Из [0, 1, 2, 3, 4, 5, 6, 7, 8] с n=3, возвращает [[0, 1, 2], [3, 4, 5], [6, 7, 8]] Пример: Из [0, 1, 2, 3, 4] с n=2 и keepRemainder=true, возвращает [[0, 1], [2, 3], [4]]",
    "nrElements": "кол-во элементов",
    "keepRemainder": "сохранить остаток",
    "bitbybit.lists.getListDepth": "получить глубину списка",
    "getListDepth": "получить глубину списка",
    "bitbybit.lists.getListDepth_description": "Определяет максимальный уровень вложенности (глубину) структуры списка. Пример: [1, 2, 3] имеет глубину 1, [[1, 2], [3, 4]] имеет глубину 2, [[[1]]] имеет глубину 3",
    "bitbybit.lists.listLength": "длина списка",
    "listLength": "длина списка",
    "bitbybit.lists.listLength_description": "Возвращает количество элементов в списке. Пример: [10, 20, 30, 40, 50] возвращает 5, [] возвращает 0",
    "bitbybit.lists.addItemAtIndex": "добавить элемент по индексу",
    "addItemAtIndex": "добавить элемент по индексу",
    "bitbybit.lists.addItemAtIndex_description": "Вставляет элемент в определенную позицию в списке. Пример: В [10, 20, 30, 40], добавление 99 по индексу 2 дает [10, 20, 99, 30, 40]",
    "item": "элемент",
    "bitbybit.lists.addItemAtIndexes": "добавить элемент по индексам",
    "addItemAtIndexes": "добавить элемент по индексам",
    "bitbybit.lists.addItemAtIndexes_description": "Вставляет один и тот же элемент в несколько указанных позиций в списке. Пример: В [10, 20, 30], добавление 99 по индексам [0, 2] дает [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "добавить элементы по индексам",
    "addItemsAtIndexes": "добавить элементы по индексам",
    "bitbybit.lists.addItemsAtIndexes_description": "Вставляет несколько элементов в соответствующие позиции (первый элемент по первому индексу, второй элемент по второму индексу и т.д.). Пример: В [10, 20, 30], добавление элементов [88, 99] по индексам [1, 2] дает [10, 88, 20, 99, 30]",
    "items": "элементы",
    "bitbybit.lists.removeItemAtIndex": "удалить элемент по индексу",
    "removeItemAtIndex": "удалить элемент по индексу",
    "bitbybit.lists.removeItemAtIndex_description": "Удаляет элемент в определенной позиции в списке. Пример: Из [10, 20, 30, 40, 50], удаление индекса 2 дает [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "удалить элементы по индексам",
    "removeItemsAtIndexes": "удалить элементы по индексам",
    "bitbybit.lists.removeItemsAtIndexes_description": "Удаляет элементы в нескольких указанных позициях из списка. Пример: Из [10, 20, 30, 40, 50], удаление индексов [1, 3] дает [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "удалить все элементы",
    "removeAllItems": "удалить все элементы",
    "bitbybit.lists.removeAllItems_description": "Очищает все элементы из списка, в результате получается пустой список. Пример: Из [10, 20, 30, 40], возвращает []",
    "bitbybit.lists.removeNthItem": "удалить N-й элемент",
    "removeNthItem": "удалить N-й элемент",
    "bitbybit.lists.removeNthItem_description": "Удаляет каждый n-й элемент из списка, начиная с необязательной позиции смещения. Пример: Из [0, 1, 2, 3, 4, 5, 6, 7, 8] с nth=3 и offset=0, возвращает [1, 2, 4, 5, 7, 8] (удаляет 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "случайное удаление с порогом",
    "randomRemoveThreshold": "случайное удаление с порогом",
    "bitbybit.lists.randomRemoveThreshold_description": "Случайным образом удаляет элементы из списка на основе порога вероятности (от 0 до 1). Пример: Из [1, 2, 3, 4, 5] с порогом 0.5, может вернуть [2, 4] (50% шанс удалить каждый элемент)",
    "bitbybit.lists.removeDuplicateNumbers": "удалить дубликаты чисел",
    "removeDuplicateNumbers": "удалить дубликаты чисел",
    "bitbybit.lists.removeDuplicateNumbers_description": "Удаляет дублирующиеся числа из списка, сохраняя только первое вхождение каждого значения. Пример: Из [1, 2, 3, 2, 4, 3, 5], возвращает [1, 2, 3, 4, 5]",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "удалить дубликаты чисел с допуском",
    "removeDuplicateNumbersTolerance": "удалить дубликаты чисел с допуском",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Удаляет дублирующиеся числа, которые находятся в пределах указанного диапазона допуска друг от друга. Пример: Из [1.0, 1.001, 2.0, 2.002, 3.0] с допуском 0.01, возвращает [1.0, 2.0, 3.0]",
    "bitbybit.lists.addItem": "добавить элемент",
    "addItem": "добавить элемент",
    "bitbybit.lists.addItem_description": "Добавляет элемент в конец списка. Пример: К [10, 20, 30], добавление 40 дает [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "добавить в начало",
    "prependItem": "добавить в начало",
    "bitbybit.lists.prependItem_description": "Добавляет элемент в начало списка. Пример: К [10, 20, 30], добавление в начало 5 дает [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "добавить элемент в начало/конец",
    "addItemFirstLast": "добавить элемент в начало/конец",
    "bitbybit.lists.addItemFirstLast_description": "Добавляет элемент либо в начало, либо в конец списка в зависимости от параметра позиции. Пример: К [10, 20, 30], добавление 5 в 'first' дает [5, 10, 20, 30], в 'last' дает [10, 20, 30, 5]",
    "firstLastEnum": "перечисление начало/конец",
    "bitbybit.lists.createEmptyList": "пустой список",
    "createEmptyList": "создать пустой список",
    "bitbybit.lists.createEmptyList_description": "Создает новый пустой список без элементов. Пример: Возвращает []",
    "bitbybit.lists.repeat": "повторить",
    "repeat": "повторить",
    "bitbybit.lists.repeat_description": "Создает новый список путем повторения элемента указанное количество раз. Пример: Повторение 5 три раза возвращает [5, 5, 5]",
    "times": "раз",
    "bitbybit.lists.repeatInPattern": "повторить по шаблону",
    "repeatInPattern": "повторить по шаблону",
    "bitbybit.lists.repeatInPattern_description": "Повторяет шаблон элементов циклически до достижения целевой длины списка. Пример: Шаблон [1, 2, 3] с длиной 7 возвращает [1, 2, 3, 1, 2, 3, 1]",
    "lengthLimit": "предел длины",
    "bitbybit.lists.sortNumber": "сортировать числа",
    "sortNumber": "сортировать числа",
    "bitbybit.lists.sortNumber_description": "Сортирует числа в порядке возрастания (от наименьшего к наибольшему) или убывания (от наибольшего к наименьшему). Пример: [5, 2, 8, 1, 9] возрастание возвращает [1, 2, 5, 8, 9], убывание возвращает [9, 8, 5, 2, 1]",
    "sorting": "сортировка",
    "orderAsc": "по возрастанию",
    "bitbybit.lists.sortTexts": "сортировать тексты",
    "sortTexts": "сортировать тексты",
    "bitbybit.lists.sortTexts_description": "Сортирует текстовые строки в алфавитном порядке по возрастанию (от А до Я) или убыванию (от Я до А). Пример: ['собака', 'яблоко', 'кот', 'банан'] возрастание возвращает ['банан', 'кот', 'собака', 'яблоко']",
    "bitbybit.lists.sortByPropValue": "сортировать по значению свойства",
    "sortByPropValue": "сортировать по значению свойства",
    "bitbybit.lists.sortByPropValue_description": "Сортирует объекты, сравнивая числовые значения указанного свойства. Пример: [{age: 30}, {age: 20}, {age: 25}] отсортировано по 'age' возрастание возвращает [{age: 20}, {age: 25}, {age: 30}]",
    "property": "свойство",
    "bitbybit.color.hexColor": "HEX цвет",
    "hexColor": "HEX цвет",
    "bitbybit.color.hexColor_description": "Создает и возвращает строку шестнадцатеричного цвета (пропуск для ввода цвета). Пример: '#FF5733' → '#FF5733'",
    "bitbybit.color.hexToRgb": "HEX в RGB",
    "hexToRgb": "HEX в RGB",
    "bitbybit.color.hexToRgb_description": "Преобразует шестнадцатеричный цвет в объект RGB со значениями r, g, b (диапазон 0-255). Пример: '#FF5733' → {r: 255, g: 87, b: 51}",
    "convert": "конвертировать",
    "bitbybit.color.rgbToHex": "rgb в hex",
    "rgbToHex": "rgb в hex",
    "bitbybit.color.rgbToHex_description": "Преобразует значения RGB в строку шестнадцатеричного цвета (поддерживает пользовательские диапазоны min/max, авто-переназначение в 0-255). Пример: r=255, g=87, b=51 с диапазоном [0,255] → '#ff5733' Пример: r=1, g=0.5, b=0.2 с диапазоном [0,1] → '#ff7f33'",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "объект rgb в hex",
    "rgbObjToHex": "объект rgb в hex",
    "bitbybit.color.rgbObjToHex_description": "Преобразует объект RGB в строку шестнадцатеричного цвета (поддерживает пользовательские диапазоны min/max). Пример: {r: 1, g: 0.5, b: 0.2} с диапазоном [0,1] → '#ff7f33'",
    "rgb": "rgb",
    "Base.ColorRGB": "базовый цвет rgb",
    "bitbybit.color.hexToRgbMapped": "hex в rgb с маппингом",
    "hexToRgbMapped": "hex в rgb с маппингом",
    "bitbybit.color.hexToRgbMapped_description": "Преобразует шестнадцатеричный цвет в RGB и переназначает значения в пользовательский диапазон. Пример: '#FF5733' отображено в [0,1] → {r: 1, g: 0.341, b: 0.2} Пример: '#FF5733' отображено в [0,100] → {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "получить параметр красного",
    "getRedParam": "получить параметр красного",
    "bitbybit.color.getRedParam_description": "Извлекает значение красного канала из шестнадцатеричного цвета (может быть отображено в пользовательский диапазон). Пример: '#FF5733' с диапазоном [0,1] → 1",
    "hex to": "hex в",
    "bitbybit.color.getGreenParam": "получить параметр зеленого",
    "getGreenParam": "получить параметр зеленого",
    "bitbybit.color.getGreenParam_description": "Извлекает значение зеленого канала из шестнадцатеричного цвета (может быть отображено в пользовательский диапазон). Пример: '#FF5733' с диапазоном [0,1] → 0.341",
    "bitbybit.color.getBlueParam": "получить параметр синего",
    "getBlueParam": "получить параметр синего",
    "bitbybit.color.getBlueParam_description": "Извлекает значение синего канала из шестнадцатеричного цвета (может быть отображено в пользовательский диапазон). Пример: '#FF5733' с диапазоном [0,1] → 0.2",
    "bitbybit.color.rgbToRed": "rgb в красный",
    "rgbToRed": "rgb в красный",
    "bitbybit.color.rgbToRed_description": "Извлекает значение красного канала из объекта RGB. Пример: {r: 255, g: 87, b: 51} → 255",
    "rgb to": "rgb в",
    "bitbybit.color.rgbToGreen": "rgb в зеленый",
    "rgbToGreen": "rgb в зеленый",
    "bitbybit.color.rgbToGreen_description": "Извлекает значение зеленого канала из объекта RGB. Пример: {r: 255, g: 87, b: 51} → 87",
    "bitbybit.color.rgbToBlue": "rgb в синий",
    "rgbToBlue": "rgb в синий",
    "bitbybit.color.rgbToBlue_description": "Извлекает значение синего канала из объекта RGB. Пример: {r: 255, g: 87, b: 51} → 51",
    "bitbybit.color.invert": "инвертировать",
    "invert": "инвертировать",
    "bitbybit.color.invert_description": "Инвертирует шестнадцатеричный цвет (переворачивает каналы RGB: 255-r, 255-g, 255-b). С blackAndWhite=true → возвращает '#000000' или '#ffffff' в зависимости от яркости. Пример: '#FF5733' → '#00a8cc', '#FF5733' с blackAndWhite=true → '#ffffff'",
    "blackAndWhite": "черно-белый",
    "bitbybit.text.create": "создать",
    "bitbybit.text.create_description": "Создает и возвращает текстовую строку (пропуск для текстового ввода). Пример: text='Привет мир' → 'Привет мир'",
    "bitbybit.text.split": "разделить",
    "bitbybit.text.split_description": "Разделяет текст на несколько частей, используя строку-разделитель. Пример: text='яблоко,банан,вишня', separator=',' → ['яблоко', 'банан', 'вишня']",
    "separator": "разделитель",
    "bitbybit.text.replaceAll": "заменить все",
    "replaceAll": "заменить все",
    "bitbybit.text.replaceAll_description": "Заменяет все вхождения строки поиска на строку замены. Пример: text='привет привет', search='привет', replaceWith='здрасьте' → 'здрасьте здрасьте'",
    "search": "поиск",
    "replaceWith": "заменить на",
    "bitbybit.text.join": "объединить",
    "join": "объединить",
    "bitbybit.text.join_description": "Объединяет несколько элементов в одну текстовую строку, используя разделитель. Пример: list=['яблоко', 'банан', 'вишня'], separator=', ' → 'яблоко, банан, вишня'",
    "string[]": "массив строк",
    "bitbybit.text.toString": "в строку",
    "toString": "в строку",
    "bitbybit.text.toString_description": "Преобразовать любой элемент в текст",
    "bitbybit.text.toStringEach": "каждый в строку",
    "toStringEach": "каждый в строку",
    "bitbybit.text.toStringEach_description": "Преобразовать каждый элемент в списке в текст",
    "bitbybit.text.format": "форматировать",
    "format": "форматировать",
    "bitbybit.text.format_description": "Форматирует текст с помощью значений-заполнителей, используя синтаксис {0}, {1} и т.д. Пример: text='Точка: ({0}, {1})', values=[10, 5] → 'Точка: (10, 5)'",
    "values": "значения",
    "bitbybit.text.vectorChar": "Векторный символ",
    "vectorChar": "Векторный символ",
    "bitbybit.text.vectorChar_description": "Преобразует символ в векторные пути (полилинии) с данными о ширине и высоте для рендеринга. Использует симплексный штриховой шрифт для генерации 2D сегментов линий, представляющих форму символа. Пример: char='A', height=10 → {width:8, height:10, paths:[[точки, образующие форму A]]}",
    "char": "Символ",
    "bitbybit.text.vectorText": "Векторный текст",
    "vectorText": "Векторный текст",
    "bitbybit.text.vectorText_description": "Преобразует многострочный текст в векторные пути (полилинии) с элементами управления выравниванием и интервалом. Поддерживает разрывы строк, межбуквенный интервал, межстрочный интервал, горизонтальное выравнивание и центрирование начала координат. Пример: text='Привет мир', height=10, align=center → [{символы строки1}, {символы строки2}]",
    "bitbybit.dates.toDateString": "в строку даты",
    "dates": "даты",
    "toDateString": "в строку даты",
    "bitbybit.dates.toDateString_description": "Преобразует дату в читаемую строку даты (исключает время). Пример: Date(2024,0,15,14,30) → 'Mon Jan 15 2024'",
    "date": "дата",
    "Date": "дата",
    "bitbybit.dates.toISOString": "в строку ISO",
    "toISOString": "в строку ISO",
    "bitbybit.dates.toISOString_description": "Преобразует дату в строку формата ISO 8601 (стандартный формат для API и обмена данными). Пример: Date(2024,0,15,14,30,45) → '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "в JSON",
    "toJSON": "в JSON",
    "bitbybit.dates.toJSON_description": "Преобразует дату в строку, совместимую с JSON (то же, что и формат ISO, используется в JSON.stringify). Пример: Date(2024,0,15,14,30) → '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "в строку",
    "bitbybit.dates.toString_description": "Преобразует дату в полную строку, специфичную для локали (включает дату, время и часовой пояс). Пример: Date(2024,0,15,14,30) → 'Mon Jan 15 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "в строку времени",
    "toTimeString": "в строку времени",
    "bitbybit.dates.toTimeString_description": "Преобразует дату в строку времени (исключает дату, включает часовой пояс). Пример: Date(2024,0,15,14,30,45) → '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "в строку UTC",
    "toUTCString": "в строку UTC",
    "bitbybit.dates.toUTCString_description": "Преобразует дату в формат строки UTC (Всемирное координированное время, без смещения часового пояса). Пример: Date(2024,0,15,14,30) → 'Mon, 15 Jan 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "сейчас",
    "now": "сейчас",
    "bitbybit.dates.now_description": "Возвращает текущую дату и время на момент выполнения. Пример: вызов now() → Объект Date, представляющий текущий момент (например, '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "создать дату",
    "createDate": "создать дату",
    "bitbybit.dates.createDate_description": "Создает новую дату из отдельных компонентов, используя местное время. Месяц индексируется с 0: 0=Январь, 11=Декабрь. Пример: year=2024, month=0, day=15, hours=14, minutes=30 → Date(Jan 15, 2024 14:30)",
    "year": "год",
    "month": "месяц",
    "day": "день",
    "hours": "часы",
    "minutes": "минуты",
    "seconds": "секунды",
    "milliseconds": "миллисекунды",
    "bitbybit.dates.createDateUTC": "создать дату UTC",
    "createDateUTC": "создать дату UTC",
    "bitbybit.dates.createDateUTC_description": "Создает новую дату из отдельных компонентов, используя UTC (игнорирует часовой пояс). Возвращает миллисекунды с эпохи Unix (1 января 1970 00:00:00 UTC). Пример: year=2024, month=0, day=15 → Date, представляющая Jan 15, 2024 00:00 UTC",
    "bitbybit.dates.createFromUnixTimeStamp": "создать из временной метки Unix",
    "createFromUnixTimeStamp": "создать из временной метки Unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Создает дату из временной метки Unix (миллисекунды с 1 января 1970 UTC). Пример: unixTimeStamp=1705329000000 → Date(Jan 15, 2024 14:30:00)",
    "unixTimeStamp": "временная метка Unix",
    "bitbybit.dates.parseDate": "распарсить дату",
    "parseDate": "распарсить дату",
    "bitbybit.dates.parseDate_description": "Парсит строку даты и возвращает временную метку Unix (миллисекунды с 1 января 1970 UTC). Пример: dateString='2024-01-15' → 1705276800000",
    "parse": "распарсить",
    "dateString": "строка даты",
    "bitbybit.dates.getDayOfMonth": "получить день месяца",
    "getDayOfMonth": "получить день месяца",
    "bitbybit.dates.getDayOfMonth_description": "Извлекает день месяца из даты (1-31), используя местное время. Пример: Date(2024,0,15) → 15",
    "bitbybit.dates.getWeekday": "получить день недели",
    "getWeekday": "получить день недели",
    "bitbybit.dates.getWeekday_description": "Извлекает день недели из даты (0=Воскресенье, 6=Суббота), используя местное время. Пример: Date(2024,0,15) → 1 (Понедельник)",
    "bitbybit.dates.getYear": "получить год",
    "getYear": "получить год",
    "bitbybit.dates.getYear_description": "Извлекает полный год из даты, используя местное время. Пример: Date(2024,0,15) → 2024",
    "bitbybit.dates.getMonth": "получить месяц",
    "getMonth": "получить месяц",
    "bitbybit.dates.getMonth_description": "Извлекает месяц из даты (0=Январь, 11=Декабрь), используя местное время. Пример: Date(2024,0,15) → 0 (Январь)",
    "bitbybit.dates.getHours": "получить часы",
    "getHours": "получить часы",
    "bitbybit.dates.getHours_description": "Извлекает часы из даты (0-23), используя местное время. Пример: Date(2024,0,15,14,30) → 14",
    "bitbybit.dates.getMinutes": "получить минуты",
    "getMinutes": "получить минуты",
    "bitbybit.dates.getMinutes_description": "Извлекает минуты из даты (0-59), используя местное время. Пример: Date(2024,0,15,14,30) → 30",
    "bitbybit.dates.getSeconds": "получить секунды",
    "getSeconds": "получить секунды",
    "bitbybit.dates.getSeconds_description": "Извлекает секунды из даты (0-59), используя местное время. Пример: Date(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getMilliseconds": "получить миллисекунды",
    "getMilliseconds": "получить миллисекунды",
    "bitbybit.dates.getMilliseconds_description": "Извлекает миллисекунды из даты (0-999), используя местное время. Пример: Date(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.getTime": "получить время",
    "getTime": "получить время",
    "bitbybit.dates.getTime_description": "Преобразует дату во временную метку Unix (миллисекунды с 1 января 1970 UTC). Пример: Date(2024,0,15,14,30) → 1705329000000",
    "bitbybit.dates.getUTCYear": "получить год UTC",
    "getUTCYear": "получить год UTC",
    "bitbybit.dates.getUTCYear_description": "Извлекает полный год из даты, используя UTC (игнорирует часовой пояс). Пример: Date(2024,0,15) → 2024",
    "bitbybit.dates.getUTCMonth": "получить месяц UTC",
    "getUTCMonth": "получить месяц UTC",
    "bitbybit.dates.getUTCMonth_description": "Извлекает месяц из даты (0=Январь, 11=Декабрь), используя UTC. Пример: Date.UTC(2024,0,15) → 0 (Январь)",
    "bitbybit.dates.getUTCDay": "получить день UTC",
    "getUTCDay": "получить день UTC",
    "bitbybit.dates.getUTCDay_description": "Извлекает день месяца из даты (1-31), используя UTC. Пример: Date.UTC(2024,0,15) → 15",
    "bitbybit.dates.getUTCHours": "получить часы UTC",
    "getUTCHours": "получить часы UTC",
    "bitbybit.dates.getUTCHours_description": "Извлекает часы из даты (0-23), используя UTC. Пример: Date.UTC(2024,0,15,14) → 14",
    "bitbybit.dates.getUTCMinutes": "получить минуты UTC",
    "getUTCMinutes": "получить минуты UTC",
    "bitbybit.dates.getUTCMinutes_description": "Извлекает минуты из даты (0-59), используя UTC. Пример: Date.UTC(2024,0,15,14,30) → 30",
    "bitbybit.dates.getUTCSeconds": "получить секунды UTC",
    "getUTCSeconds": "получить секунды UTC",
    "bitbybit.dates.getUTCSeconds_description": "Извлекает секунды из даты (0-59), используя UTC. Пример: Date.UTC(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getUTCMilliseconds": "получить миллисекунды UTC",
    "getUTCMilliseconds": "получить миллисекунды UTC",
    "bitbybit.dates.getUTCMilliseconds_description": "Извлекает миллисекунды из даты (0-999), используя UTC. Пример: Date.UTC(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.setYear": "установить год",
    "setYear": "установить год",
    "bitbybit.dates.setYear_description": "Создает новую дату с измененным годом (возвращает новую дату, оригинал без изменений). Пример: Date(2024,0,15) с year=2025 → Date(2025,0,15)",
    "bitbybit.dates.setMonth": "установить месяц",
    "setMonth": "установить месяц",
    "bitbybit.dates.setMonth_description": "Создает новую дату с измененным месяцем (0=Январь, 11=Декабрь, возвращает новую дату). Пример: Date(2024,0,15) с month=5 → Date(2024,5,15) (15 июня)",
    "bitbybit.dates.setDayOfMonth": "установить день месяца",
    "setDayOfMonth": "установить день месяца",
    "bitbybit.dates.setDayOfMonth_description": "Создает новую дату с измененным днем месяца (1-31, возвращает новую дату). Пример: Date(2024,0,15) с day=20 → Date(2024,0,20)",
    "bitbybit.dates.setHours": "установить часы",
    "setHours": "установить часы",
    "bitbybit.dates.setHours_description": "Устанавливает значение часа в объекте Date, используя местное время.",
    "bitbybit.dates.setMinutes": "установить минуты",
    "setMinutes": "установить минуты",
    "bitbybit.dates.setMinutes_description": "Устанавливает значение минут в объекте Date, используя местное время.",
    "bitbybit.dates.setSeconds": "установить секунды",
    "setSeconds": "установить секунды",
    "bitbybit.dates.setSeconds_description": "Устанавливает значение секунд в объекте Date, используя местное время.",
    "bitbybit.dates.setMilliseconds": "установить миллисекунды",
    "setMilliseconds": "установить миллисекунды",
    "bitbybit.dates.setMilliseconds_description": "Устанавливает значение миллисекунд в объекте Date, используя местное время.",
    "bitbybit.dates.setTime": "установить время",
    "setTime": "установить время",
    "bitbybit.dates.setTime_description": "Устанавливает значение даты и времени в объекте Date.",
    "time": "время",
    "bitbybit.dates.setUTCYear": "установить год UTC",
    "setUTCYear": "установить год UTC",
    "bitbybit.dates.setUTCYear_description": "Устанавливает значение года в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.dates.setUTCMonth": "установить месяц UTC",
    "setUTCMonth": "установить месяц UTC",
    "bitbybit.dates.setUTCMonth_description": "Устанавливает значение месяца в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.dates.setUTCDay": "установить день UTC",
    "setUTCDay": "установить день UTC",
    "bitbybit.dates.setUTCDay_description": "Устанавливает числовое значение дня месяца в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.dates.setUTCHours": "установить часы UTC",
    "setUTCHours": "установить часы UTC",
    "bitbybit.dates.setUTCHours_description": "Устанавливает значение часов в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.dates.setUTCMinutes": "установить минуты UTC",
    "setUTCMinutes": "установить минуты UTC",
    "bitbybit.dates.setUTCMinutes_description": "Устанавливает значение минут в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.dates.setUTCSeconds": "установить секунды UTC",
    "setUTCSeconds": "установить секунды UTC",
    "bitbybit.dates.setUTCSeconds_description": "Устанавливает значение секунд в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "установить миллисекунды UTC",
    "setUTCMilliseconds": "установить миллисекунды UTC",
    "bitbybit.dates.setUTCMilliseconds_description": "Устанавливает значение миллисекунд в объекте Date с использованием Всемирного координированного времени (UTC).",
    "bitbybit.json.stringify": "в строку",
    "json": "json",
    "stringify": "в строку",
    "bitbybit.json.stringify_description": "Преобразует входное значение в строку",
    "bitbybit.json.parse": "распарсить",
    "bitbybit.json.parse_description": "Парсит входное значение",
    "bitbybit.json.query": "запрос",
    "query": "запрос",
    "bitbybit.json.query_description": "Запрашивает входное значение",
    "jsonpath": "jsonpath",
    "bitbybit.json.setValueOnProp": "установить значение по свойству",
    "setValueOnProp": "установить значение по свойству",
    "bitbybit.json.setValueOnProp_description": "Устанавливает значение для заданного свойства заданного json",
    "props": "свойства",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "получить json из массива по первому совпадению свойства",
    "getJsonFromArrayByFirstPropMatch": "получить json из массива по первому совпадению свойства",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Получает json из массива по первому совпадению свойства. Это очень простой поиск, который возвращает только первое совпадение. Если вам нужен более сложный поиск, вы можете использовать запрос jsonpath с фильтрами.",
    "jsonArray": "массив json",
    "any[]": "массив any",
    "match": "совпадение",
    "bitbybit.json.getValueOnProp": "получить значение по свойству",
    "getValueOnProp": "получить значение по свойству",
    "bitbybit.json.getValueOnProp_description": "Получает значение свойства в заданном json",
    "bitbybit.json.setValue": "установить значение",
    "bitbybit.json.setValue_description": "Устанавливает значение в json, предоставляя путь",
    "prop": "свойство",
    "bitbybit.json.setValuesOnPaths": "установить значения по путям",
    "setValuesOnPaths": "установить значения по путям",
    "bitbybit.json.setValuesOnPaths_description": "Устанавливает несколько значений в json, предоставляя пути",
    "paths": "пути",
    "bitbybit.json.paths": "пути",
    "bitbybit.json.paths_description": "Находит пути к элементам в объекте, соответствующим выражению пути",
    "bitbybit.json.createEmpty": "пустой",
    "bitbybit.json.createEmpty_description": "Создает пустой объект JavaScript",
    "bitbybit.json.previewAndSaveJson": "предпросмотр и сохранение json",
    "previewAndSaveJson": "предпросмотр и сохранение json",
    "bitbybit.json.previewAndSaveJson_description": "Предварительный просмотр json и возможность его сохранения",
    "preview": "предпросмотр",
    "bitbybit.json.previewJson": "предпросмотр json",
    "previewJson": "предпросмотр json",
    "bitbybit.json.previewJson_description": "предварительно просматривает json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "кривая по узлам, контр. точкам, весам",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "кривая по узлам, контр. точкам, весам",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Создает кривую Nurbs, предоставляя узлы, контрольные точки и веса",
    "degree": "степень",
    "knots": "узлы",
    "bitbybit.verb.curve.createCurveByPoints": "кривая по точкам",
    "createCurveByPoints": "кривая по точкам",
    "bitbybit.verb.curve.createCurveByPoints_description": "Создает кривую Nurbs, предоставляя контрольные точки",
    "bitbybit.verb.curve.createBezierCurve": "кривая Безье",
    "createBezierCurve": "кривая Безье",
    "bitbybit.verb.curve.createBezierCurve_description": "Создает кривую Безье Nurbs, предоставляя контрольные точки и веса",
    "bitbybit.verb.curve.clone": "клонировать",
    "bitbybit.verb.curve.clone_description": "Клонировать кривую Nurbs",
    "bitbybit.verb.curve.closestParam": "ближайший параметр",
    "closestParam": "ближайший параметр",
    "bitbybit.verb.curve.closestParam_description": "Находит ближайший параметр на кривой Nurbs от точки",
    "bitbybit.verb.curve.closestParams": "ближайшие параметры",
    "closestParams": "ближайшие параметры",
    "bitbybit.verb.curve.closestParams_description": "Находит ближайшие параметры на кривой Nurbs от точек",
    "bitbybit.verb.curve.closestPoint": "ближайшая точка",
    "closestPoint": "ближайшая точка",
    "bitbybit.verb.curve.closestPoint_description": "Находит ближайшую точку на кривой Nurbs от точки",
    "bitbybit.verb.curve.closestPoints": "ближайшие точки",
    "closestPoints": "ближайшие точки",
    "bitbybit.verb.curve.closestPoints_description": "Находит ближайшие точки на кривой Nurbs из списка точек",
    "bitbybit.verb.curve.controlPoints": "контрольные точки",
    "controlPoints": "контрольные точки",
    "bitbybit.verb.curve.controlPoints_description": "Находит контрольные точки кривой Nurbs",
    "bitbybit.verb.curve.degree": "степень",
    "bitbybit.verb.curve.degree_description": "Находит степень кривой Nurbs",
    "bitbybit.verb.curve.derivatives": "производные",
    "derivatives": "производные",
    "bitbybit.verb.curve.derivatives_description": "Находит производные кривой Nurbs в параметре",
    "numDerivatives": "кол-во производных",
    "parameter": "параметр",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "разделить на равную длину дуги по параметрам",
    "divideByEqualArcLengthToParams": "разделить на равную длину дуги по параметрам",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Разделяет кривую по равной длине дуги на параметры",
    "subdivision": "подразделение",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "разделить на равную длину дуги точками",
    "divideByEqualArcLengthToPoints": "разделить на равную длину дуги точками",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Разделяет кривую по равной длине дуги на точки",
    "bitbybit.verb.curve.divideByArcLengthToParams": "разделить по длине дуги по параметрам",
    "divideByArcLengthToParams": "разделить по длине дуги по параметрам",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Разделяет кривую по длине дуги на параметры",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "разделить по длине дуги точками",
    "divideByArcLengthToPoints": "разделить по длине дуги точками",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Разделяет кривую по длине дуги на точки",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "разделить кривые на равную длину дуги точками",
    "divideCurvesByEqualArcLengthToPoints": "разделить кривые на равную длину дуги точками",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "делит несколько кривых на равную длину дуги точками",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "разделить кривые по длине дуги точками",
    "divideCurvesByArcLengthToPoints": "разделить кривые по длине дуги точками",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "делит несколько кривых по длине дуги точками",
    "bitbybit.verb.curve.domain": "домен",
    "bitbybit.verb.curve.domain_description": "Находит интервал домена параметров кривой",
    "bitbybit.verb.curve.startPoint": "начальная точка",
    "bitbybit.verb.curve.startPoint_description": "Начальная точка кривой",
    "bitbybit.verb.curve.endPoint": "конечная точка",
    "bitbybit.verb.curve.endPoint_description": "Конечная точка кривой",
    "bitbybit.verb.curve.startPoints": "начальные точки",
    "bitbybit.verb.curve.startPoints_description": "Начальные точки кривых",
    "bitbybit.verb.curve.endPoints": "конечные точки",
    "bitbybit.verb.curve.endPoints_description": "Конечные точки кривых",
    "bitbybit.verb.curve.knots": "узлы",
    "bitbybit.verb.curve.knots_description": "Находит узлы кривой Nurbs",
    "bitbybit.verb.curve.lengthAtParam": "длина по параметру",
    "lengthAtParam": "длина по параметру",
    "bitbybit.verb.curve.lengthAtParam_description": "Получает длину кривой Nurbs в определенном параметре",
    "bitbybit.verb.curve.length": "длина",
    "bitbybit.verb.curve.length_description": "Получает длину кривой Nurbs",
    "bitbybit.verb.curve.paramAtLength": "параметр по длине",
    "paramAtLength": "параметр по длине",
    "bitbybit.verb.curve.paramAtLength_description": "Получает параметр на указанной длине на кривой Nurbs",
    "bitbybit.verb.curve.pointAtParam": "точка по параметру",
    "pointAtParam": "точка по параметру",
    "bitbybit.verb.curve.pointAtParam_description": "Получает точку на указанном параметре на кривой Nurbs",
    "bitbybit.verb.curve.pointsAtParam": "точки по параметру",
    "pointsAtParam": "точки по параметру",
    "bitbybit.verb.curve.pointsAtParam_description": "Получает точки на указанном параметре на кривых Nurbs",
    "bitbybit.verb.curve.reverse": "обратить",
    "bitbybit.verb.curve.reverse_description": "Переворачивает кривую Nurbs",
    "bitbybit.verb.curve.split": "разделить",
    "bitbybit.verb.curve.split_description": "Разделяет кривую Nurbs на две части в заданном параметре",
    "bitbybit.verb.curve.tangent": "касательная",
    "bitbybit.verb.curve.tangent_description": "Касательная кривой Nurbs в заданном параметре",
    "bitbybit.verb.curve.tessellate": "тесселировать",
    "tessellate": "тесселировать",
    "bitbybit.verb.curve.tessellate_description": "Тесселирует кривую Nurbs в список точек",
    "bitbybit.verb.curve.transform": "трансформировать",
    "bitbybit.verb.curve.transform_description": "Трансформирует кривую Nurbs",
    "bitbybit.verb.curve.transformCurves": "трансформировать кривые",
    "transformCurves": "трансформировать кривые",
    "bitbybit.verb.curve.transformCurves_description": "Трансформирует кривые Nurbs",
    "bitbybit.verb.curve.weights": "веса",
    "bitbybit.verb.curve.weights_description": "Веса кривой Nurbs",
    "bitbybit.verb.curve.circle.createCircle": "окружность",
    "createCircle": "создать окружность",
    "bitbybit.verb.curve.circle.createCircle_description": "Создает кривую круга Nurbs",
    "xAxis": "ось X",
    "yAxis": "ось Y",
    "bitbybit.verb.curve.circle.createArc": "дуга",
    "createArc": "создать дугу",
    "bitbybit.verb.curve.circle.createArc_description": "Создает кривую дуги Nurbs",
    "minAngle": "мин. угол",
    "maxAngle": "макс. угол",
    "bitbybit.verb.curve.circle.center": "центр",
    "bitbybit.verb.curve.circle.center_description": "Получает центральную точку круга или дуги",
    "bitbybit.verb.curve.circle.radius": "радиус",
    "bitbybit.verb.curve.circle.radius_description": "Получает радиус круга или дуги",
    "bitbybit.verb.curve.circle.maxAngle": "макс. угол",
    "bitbybit.verb.curve.circle.maxAngle_description": "Получает максимальный угол дуги в градусах",
    "bitbybit.verb.curve.circle.minAngle": "мин. угол",
    "bitbybit.verb.curve.circle.minAngle_description": "Получает минимальный угол дуги в градусах",
    "bitbybit.verb.curve.circle.xAxis": "ось X",
    "bitbybit.verb.curve.circle.xAxis_description": "Получает угол x дуги",
    "bitbybit.verb.curve.circle.yAxis": "ось Y",
    "bitbybit.verb.curve.circle.yAxis_description": "Получает угол y дуги",
    "bitbybit.verb.curve.ellipse.createEllipse": "эллипс",
    "createEllipse": "создать эллипс",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Создает кривую эллипса Nurbs",
    "bitbybit.verb.curve.ellipse.createArc": "дуга",
    "bitbybit.verb.curve.ellipse.createArc_description": "Создает кривую дуги эллипса Nurbs",
    "bitbybit.verb.curve.ellipse.center": "центр",
    "bitbybit.verb.curve.ellipse.center_description": "Получает центральную точку эллипса или дуги",
    "bitbybit.verb.curve.ellipse.maxAngle": "макс. угол",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Получает максимальный угол дуги в градусах",
    "bitbybit.verb.curve.ellipse.minAngle": "мин. угол",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Получает минимальный угол дуги в градусах",
    "bitbybit.verb.curve.ellipse.xAxis": "ось X",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Получает угол x дуги или эллипса",
    "bitbybit.verb.curve.ellipse.yAxis": "ось Y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Получает угол y дуги или эллипса",
    "bitbybit.verb.surface.boundaries": "границы",
    "boundaries": "границы",
    "bitbybit.verb.surface.boundaries_description": "Получает граничные кривые ребер Nurbs поверхности в виде списка",
    "bitbybit.verb.surface.createSurfaceByCorners": "поверхность по углам",
    "createSurfaceByCorners": "создать поверхность по углам",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Создает поверхность, предоставляя 4 точки в качестве углов",
    "point3": "точка 3",
    "point4": "точка 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "поверхность по узлам, контр. точкам, весам",
    "createSurfaceByKnotsControlPointsWeights": "создать поверхность по узлам, контр. точкам, весам",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Создает поверхность Nurbs, предоставляя узлы uv, степени uv, точки и веса",
    "degreeU": "степень U",
    "degreeV": "степень V",
    "knotsU": "узлы U",
    "knotsV": "узлы V",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "поверхность лофтингом кривых",
    "createSurfaceByLoftingCurves": "создать поверхность лофтингом кривых",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Создает поверхность Nurbs путем лофтинга кривых",
    "bitbybit.verb.surface.clone": "клонировать",
    "bitbybit.verb.surface.clone_description": "Клонировать поверхность Nurbs",
    "bitbybit.verb.surface.closestParam": "ближайший параметр",
    "bitbybit.verb.surface.closestParam_description": "Находит ближайший параметр на поверхности от точки",
    "bitbybit.verb.surface.closestPoint": "ближайшая точка",
    "bitbybit.verb.surface.closestPoint_description": "Находит ближайшую точку на поверхности от точки",
    "bitbybit.verb.surface.controlPoints": "контрольные точки",
    "bitbybit.verb.surface.controlPoints_description": "Получает контрольные точки на поверхности",
    "bitbybit.verb.surface.degreeU": "степень U",
    "bitbybit.verb.surface.degreeU_description": "Получает степень U поверхности",
    "bitbybit.verb.surface.degreeV": "степень V",
    "bitbybit.verb.surface.degreeV_description": "Получает степень V поверхности",
    "bitbybit.verb.surface.derivatives": "производные",
    "bitbybit.verb.surface.derivatives_description": "Получает производные поверхности в указанной координате uv",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "домен U",
    "domainU": "домен U",
    "bitbybit.verb.surface.domainU_description": "Получает домен U поверхности",
    "bitbybit.verb.surface.domainV": "домен V",
    "domainV": "домен V",
    "bitbybit.verb.surface.domainV_description": "Получает домен V поверхности",
    "bitbybit.verb.surface.isocurve": "изокривая",
    "isocurve": "изокривая",
    "bitbybit.verb.surface.isocurve_description": "Получает изокривую Nurbs на поверхности",
    "useV": "использовать V",
    "bitbybit.verb.surface.isocurvesSubdivision": "подразделение изокривыми",
    "isocurvesSubdivision": "подразделение изокривыми",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Подразделяет поверхность на предпочтительное количество изокривых",
    "isocurveSegments": "сегменты изокривых",
    "bitbybit.verb.surface.isocurvesAtParams": "изокривые по параметрам",
    "isocurvesAtParams": "изокривые по параметрам",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Подразделяет поверхность на изокривые на указанном массиве параметров",
    "parameters": "параметры",
    "bitbybit.verb.surface.knotsU": "узлы U",
    "bitbybit.verb.surface.knotsU_description": "Получает узлы U поверхности",
    "bitbybit.verb.surface.knotsV": "узлы V",
    "bitbybit.verb.surface.knotsV_description": "Получает узлы V поверхности",
    "bitbybit.verb.surface.normal": "нормаль",
    "bitbybit.verb.surface.normal_description": "Получает нормаль на поверхности в координате uv",
    "bitbybit.verb.surface.point": "точка",
    "bitbybit.verb.surface.point_description": "Получает точку на поверхности в координате uv",
    "bitbybit.verb.surface.reverse": "обратить",
    "bitbybit.verb.surface.reverse_description": "Перевернуть поверхность Nurbs. Это перевернет начало координат UV и направления изокривых",
    "bitbybit.verb.surface.split": "разделить",
    "bitbybit.verb.surface.split_description": "Разделяет поверхность Nurbs на две половины.",
    "bitbybit.verb.surface.transformSurface": "трансформировать поверхность",
    "transformSurface": "трансформировать поверхность",
    "bitbybit.verb.surface.transformSurface_description": "Трансформирует поверхность Nurbs с помощью заданного списка трансформаций.",
    "bitbybit.verb.surface.weights": "веса",
    "bitbybit.verb.surface.weights_description": "Получает веса поверхности",
    "bitbybit.verb.surface.cone.create": "создать",
    "cone": "конус",
    "bitbybit.verb.surface.cone.create_description": "Создает коническую поверхность Nurbs",
    "bitbybit.verb.surface.cone.axis": "ось",
    "bitbybit.verb.surface.cone.axis_description": "Получить ось конуса",
    "bitbybit.verb.surface.cone.base": "основание",
    "bitbybit.verb.surface.cone.base_description": "Получить основание конуса",
    "bitbybit.verb.surface.cone.height": "высота",
    "bitbybit.verb.surface.cone.height_description": "Получить высоту конуса",
    "bitbybit.verb.surface.cone.radius": "радиус",
    "bitbybit.verb.surface.cone.radius_description": "Получить радиус конуса",
    "bitbybit.verb.surface.cone.xAxis": "ось X",
    "bitbybit.verb.surface.cone.xAxis_description": "Получить ось x конуса",
    "bitbybit.verb.surface.cylinder.create": "создать",
    "bitbybit.verb.surface.cylinder.create_description": "Создает цилиндрическую поверхность Nurbs",
    "bitbybit.verb.surface.cylinder.axis": "ось",
    "bitbybit.verb.surface.cylinder.axis_description": "Получить ось цилиндра",
    "bitbybit.verb.surface.cylinder.base": "основание",
    "bitbybit.verb.surface.cylinder.base_description": "Получить основание цилиндра",
    "bitbybit.verb.surface.cylinder.height": "высота",
    "bitbybit.verb.surface.cylinder.height_description": "Получить высоту цилиндра",
    "bitbybit.verb.surface.cylinder.radius": "радиус",
    "bitbybit.verb.surface.cylinder.radius_description": "Получить радиус цилиндра",
    "bitbybit.verb.surface.cylinder.xAxis": "ось X",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Получить ось x цилиндра",
    "bitbybit.verb.surface.extrusion.create": "создать",
    "extrusion": "выдавливание",
    "bitbybit.verb.surface.extrusion.create_description": "Создает экструзию поверхности Nurbs из кривой",
    "profile": "профиль",
    "bitbybit.verb.surface.extrusion.direction": "направление",
    "bitbybit.verb.surface.extrusion.direction_description": "Получает вектор направления экструзии",
    "bitbybit.verb.surface.extrusion.profile": "профиль",
    "bitbybit.verb.surface.extrusion.profile_description": "Получает профильную кривую Nurbs экструзии",
    "bitbybit.verb.surface.sphere.create": "создать",
    "bitbybit.verb.surface.sphere.create_description": "Создает сферическую поверхность Nurbs",
    "bitbybit.verb.surface.sphere.radius": "радиус",
    "bitbybit.verb.surface.sphere.radius_description": "Получить радиус сферической поверхности Nurbs",
    "bitbybit.verb.surface.sphere.center": "центр",
    "bitbybit.verb.surface.sphere.center_description": "Получить центр сферической поверхности Nurbs",
    "bitbybit.verb.surface.revolved.create": "создать",
    "revolved": "вращением",
    "bitbybit.verb.surface.revolved.create_description": "Создает вращающуюся поверхность Nurbs",
    "bitbybit.verb.surface.revolved.profile": "профиль",
    "bitbybit.verb.surface.revolved.profile_description": "Получить профильную кривую Nurbs вращающейся поверхности Nurbs",
    "revolution": "вращение",
    "bitbybit.verb.surface.revolved.center": "центр",
    "bitbybit.verb.surface.revolved.center_description": "Получить центральную кривую Nurbs вращающейся поверхности Nurbs",
    "bitbybit.verb.surface.revolved.axis": "ось",
    "bitbybit.verb.surface.revolved.axis_description": "Получить ось вращения вращающейся поверхности Nurbs",
    "bitbybit.verb.surface.revolved.angle": "угол",
    "bitbybit.verb.surface.revolved.angle_description": "Получить угол вращения вращающейся поверхности Nurbs",
    "bitbybit.verb.surface.sweep.create": "создать",
    "sweep": "по траектории",
    "bitbybit.verb.surface.sweep.create_description": "Создает поверхность Nurbs сдвига",
    "rail": "траектория",
    "bitbybit.verb.surface.sweep.profile": "профиль",
    "bitbybit.verb.surface.sweep.profile_description": "Получить профильную кривую Nurbs поверхности Nurbs сдвига",
    "bitbybit.verb.surface.sweep.rail": "траектория",
    "bitbybit.verb.surface.sweep.rail_description": "Получить направляющую кривую Nurbs поверхности Nurbs сдвига",
    "bitbybit.verb.intersect.curves": "кривые",
    "bitbybit.verb.intersect.curves_description": "Пересекает две кривые verb Nurbs вместе и возвращает результаты пересечения",
    "firstCurve": "первая кривая",
    "secondCurve": "вторая кривая",
    "bitbybit.verb.intersect.curveAndSurface": "кривая и поверхность",
    "curveAndSurface": "кривая и поверхность",
    "bitbybit.verb.intersect.curveAndSurface_description": "пересекает кривую и поверхность",
    "bitbybit.verb.intersect.surfaces": "поверхности",
    "bitbybit.verb.intersect.surfaces_description": "пересекает две поверхности",
    "firstSurface": "первая поверхность",
    "secondSurface": "вторая поверхность",
    "bitbybit.verb.intersect.curveCurveFirstParams": "параметры первой кривой пересечения",
    "curveCurveFirstParams": "параметры первой кривой пересечения",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Получает параметры пересечения на первой кривой из пересечения кривая-кривая",
    "intersections": "пересечения",
    "BaseTypes.CurveCurveIntersection[]": "массив пересечений кривая-кривая базовых типов",
    "bitbybit.verb.intersect.curveCurveSecondParams": "параметры второй кривой пересечения",
    "curveCurveSecondParams": "параметры второй кривой пересечения",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Получает параметры пересечения на второй кривой из пересечения кривая-кривая",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "точки первой кривой пересечения",
    "curveCurveFirstPoints": "точки первой кривой пересечения",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Получает точки пересечения на первой кривой из пересечения кривая-кривая",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "точки второй кривой пересечения",
    "curveCurveSecondPoints": "точки второй кривой пересечения",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Получает точки пересечения на второй кривой из пересечения кривая-кривая",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "параметры кривой пересечения кривая-поверхность",
    "curveSurfaceCurveParams": "параметры кривой пересечения кривая-поверхность",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Получает параметры пересечения на кривой из пересечения кривая-поверхность",
    "BaseTypes.CurveSurfaceIntersection[]": "массив пересечений кривая-поверхность базовых типов",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "параметры поверхности пересечения кривая-поверхность",
    "curveSurfaceSurfaceParams": "параметры поверхности пересечения кривая-поверхность",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Получает параметры пересечения на поверхности из пересечения кривая-поверхность",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "точки кривой пересечения кривая-поверхность",
    "curveSurfaceCurvePoints": "точки кривой пересечения кривая-поверхность",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Получает точки пересечения на кривой из пересечения кривая-поверхность",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "точки поверхности пересечения кривая-поверхность",
    "curveSurfaceSurfacePoints": "точки поверхности пересечения кривая-поверхность",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Получает точки пересечения на поверхности из пересечения кривая-поверхность",
    "bitbybit.tag.create": "создать",
    "tag": "тег",
    "bitbybit.tag.create_description": "Создает dto тега",
    "adaptDepth": "адаптировать глубину",
    "needsUpdate": "требуется обновление",
    "bitbybit.time.registerRenderFunction": "зарегистрировать функцию рендеринга",
    "registerRenderFunction": "зарегистрировать функцию рендеринга",
    "bitbybit.time.registerRenderFunction_description": "Регистрирует функцию в цикле рендеринга",
    "bitbybit.asset.getFile": "получить файл",
    "asset": "ресурс",
    "getFile": "получить файл",
    "bitbybit.asset.getFile_description": "Получает файл актива",
    "bitbybit.asset.getLocalFile": "получить локальный файл",
    "getLocalFile": "получить локальный файл",
    "bitbybit.asset.getLocalFile_description": "Получает локальный файл актива, хранящийся в вашем браузере.",
    "bitbybit.asset.fetchBlob": "получить blob",
    "fetchBlob": "получить blob",
    "bitbybit.asset.fetchBlob_description": "Извлекает blob из заданного url, должен быть доступным endpoint с включенным CORS",
    "fetch": "получить",
    "bitbybit.asset.fetchFile": "получить файл",
    "fetchFile": "получить файл",
    "bitbybit.asset.fetchFile_description": "Извлекает файл из заданного url, должен быть доступным endpoint с включенным CORS",
    "bitbybit.asset.fetchJSON": "получить JSON",
    "fetchJSON": "получить JSON",
    "bitbybit.asset.fetchJSON_description": "Извлекает json из заданного url, должен быть доступным endpoint с включенным CORS",
    "bitbybit.asset.fetchText": "получить текст",
    "fetchText": "получить текст",
    "bitbybit.asset.fetchText_description": "Извлекает текст из заданного url, должен быть доступным endpoint с включенным CORS",
    "bitbybit.asset.createObjectURL": "URL объекта",
    "createObjectURL": "URL объекта",
    "bitbybit.asset.createObjectURL_description": "Получает и создает путь url-строки к вашему файлу, хранящемуся в вашей памяти.",
    "file": "файл",
    "File | Blob": "файл или blob",
    "bitbybit.asset.createObjectURLs": "URL объектов",
    "createObjectURLs": "URL объектов",
    "bitbybit.asset.createObjectURLs_description": "Получает и создает пути url-строк к вашим файлам, хранящимся в вашей памяти.",
    "files": "файлы",
    "(File | Blob)[]": "массив файлов или blob",
    "exec": "выполнить",
    "Visible": "Видим",
    "Hidden": "Скрыт",
    "flatten": "сделать плоским",
    "force exec": "принудительно выполнить",
    "console log": "журнал консоли",
    "preview data": "предпросмотр данных",
    "flow": "поток",
    "code": "код",
    "runner": "запуск",
    "counters": "счетчики",
    "actions": "действия",
    "loops": "циклы",
    "interval": "интервал",
    "delay": "задержка",
    "expire": "истечь",
    "timeout": "таймаут",
    "counter min max": "счетчик мин макс",
    "counter steps": "шаги счетчика",
    "reset": "сброс",
    "trigger": "триггер",
    "mouse": "мышь",
    "mouse click": "клик мыши",
    "key": "клавиша",
    "pointer": "указатель",
    "pick info": "информация о выборе",
    "down": "нажатие",
    "wheel": "колесо",
    "tap": "касание",
    "double tap": "двойное касание",
    "render": "рендеринг",
    "passed ms": "прошло мс",
    "babylon observable listener": "слушатель observable babylon",
    "object": "объект",
    "observable selector": "селектор observable",
    "get event data": "получить данные события",
    "exec click": "выполнить клик",
    "exec down": "выполнить нажатие",
    "toggle": "переключатель",
    "flip flop": "триггер",
    "boolean gate": "логический шлюз",
    "boolean gate silent": "тихий логический шлюз",
    "is undefined": "не определено",
    "for loop": "цикл for",
    "last": "последний",
    "for each loop": "цикл for each",
    "element": "элемент",
    "body": "тело",
    "complete": "завершено",
    "editors": "редакторы",
    "inputs": "входы",
    "outputs": "выходы",
    "recent": "недавние",
    "Clear": "Очистить",
    "Run": "Запустить",
    "Swap Canvas": "Сменить холст",
    "Local Assets": "Локальные ресурсы",
    "Import": "Импорт",
    "Copy to Clipboard": "Копировать в буфер обмена",
    "Paste from Clipboard": "Вставить из буфера обмена",
    "Export": "Экспорт",
    "Export to runner": "Экспорт в Runner",
    "Clean Cache": "Очистить кэш",
    "Community": "Сообщество",
    "Sponsors and Partners": "Спонсоры и партнеры",
    "API Documentation": "Документация API",
    "About": "О программе",
    "Toolbox": "Инструменты",
    "More": "Ещё",
    "bitbybit.code.typeScriptEditor": "редактор TypeScript",
    "bitbybit.code.typeScriptEditor_description": "Позволяет писать код TypeScript с полным автодополнением bitbybit в одной функции. Все, что возвращает функция start, будет рассматриваться как выход компонента.",
    "bitbybit.code.javaScriptEditor": "редактор JavaScript",
    "bitbybit.code.javaScriptEditor_description": "Позволяет писать код JavaScript в одной функции. Все, что возвращает функция start, будет рассматриваться как выход компонента.",
    "bitbybit.code.jsonEditor": "редактор JSON",
    "bitbybit.code.jsonEditor_description": "Позволяет писать код JSON. Все, что возвращает функция start, будет рассматриваться как выход компонента.",
    "bitbybit.flow.actions.keyboard": "клавиатура",
    "bitbybit.flow.actions.keyboard_description": "Выполнится по событиям клавиатуры при нажатии кнопок.",
    "bitbybit.flow.actions.mouseClick": "клик мыши",
    "bitbybit.flow.actions.mouseClick_description": "Выполнится по событиям мыши при нажатии кнопок.",
    "bitbybit.flow.actions.start": "старт",
    "bitbybit.flow.actions.start_description": "Запускает поток управления и инициирует выполнение.",
    "bitbybit.flow.actions.trigger": "триггер",
    "bitbybit.flow.actions.trigger_description": "Инициирует выполнение при нажатии кнопки.",
    "bitbybit.flow.babylon.gui.button": "кнопка",
    "bitbybit.flow.babylon.gui.button_description": "Выполнится по различным событиям указателя при нажатии левой кнопки мыши на холсте babylonjs.",
    "bitbybit.flow.babylon.scene.pointerEvents": "указатель",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Выполнится по различным событиям указателя при нажатии левой кнопки мыши на холсте babylonjs.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "получить данные события",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Получает данные события из наблюдаемого результата слушателя observable.",
    "bitbybit.flow.babylon.observableListener": "слушатель observable babylon",
    "bitbybit.flow.babylon.observableListener_description": "Подпишется и будет слушать любой из observable babylonjs.",
    "bitbybit.flow.babylon.render": "рендеринг",
    "bitbybit.flow.babylon.render_description": "Выполняется на каждом кадре рендеринга babylonjs.",
    "bitbybit.flow.counters.counterMinMax": "счетчик мин макс",
    "bitbybit.flow.counters.counterMinMax_description": "Подсчитывает количество выполнений потока между минимальным и максимальным значениями. При достижении максимума сбрасывается.",
    "bitbybit.flow.counters.counterSteps": "шаги счетчика",
    "bitbybit.flow.counters.counterSteps_description": "Подсчитывает количество выполнений потока, начиная с заданного значения счетчика и увеличивая его на каждом шаге на заданное значение из списка, пока шаги не закончатся. При достижении конца сбрасывается.",
    "bitbybit.flow.counters.counter": "счетчик",
    "bitbybit.flow.counters.counter_description": "Подсчитывает количество выполнений потока.",
    "bitbybit.flow.logic.booleanGateSilent": "тихий логический шлюз",
    "bitbybit.flow.logic.booleanGateSilent_description": "Инициирует различные события выполнения на основе предоставленного логического значения, но выполняется только при изменении логического значения, что предотвращает постоянное срабатывание нескольких событий, даже если изменений не произошло.",
    "bitbybit.flow.logic.booleanGate": "логический шлюз",
    "bitbybit.flow.logic.booleanGate_description": "Инициирует различные события выполнения на основе предоставленного логического значения.",
    "bitbybit.flow.logic.flipFlop": "триггер",
    "bitbybit.flow.logic.flipFlop_description": "Каждый раз при выполнении события срабатывает другое событие, по сути создавая функциональность переключателя.",
    "bitbybit.flow.logic.isUndefined": "не определено",
    "bitbybit.flow.logic.isUndefined_description": "Проверяет, не определено ли предоставленное значение, и инициирует событие 'истина' или 'ложь'.",
    "bitbybit.flow.loops.forEach": "цикл for each",
    "bitbybit.flow.loops.forEach_description": "Цикл for each, который проходит по всем элементам списка.",
    "bitbybit.flow.loops.for": "цикл for",
    "bitbybit.flow.loops.for_description": "Цикл for, который выполняет тело между двумя значениями.",
    "bitbybit.flow.time.delay": "задержка",
    "bitbybit.flow.time.delay_description": "Задерживает выполнение на заданный таймаут в мс.",
    "bitbybit.flow.time.interval": "интервал",
    "bitbybit.flow.time.interval_description": "Выполняет поток каждые заданный интервал в мс.",
    "bitbybit.lists.createList": "создать список",
    "bitbybit.lists.createList_description": "Создает список из предоставленных элементов.",
    "bitbybit.lists.flatten": "сделать плоским",
    "bitbybit.lists.flatten_description": "Преобразует список списков в один плоский список.",
    "bitbybit.lists.passThrough": "пропустить через",
    "bitbybit.lists.passThrough_description": "Приводит значение к типу 'any' и передает ввод на выход без изменений.",
    "bitbybit.math.numberSlider": "числовой слайдер",
    "bitbybit.math.numberSlider_description": "Создает число со слайдером. Можно настроить минимальное, максимальное и шаговое значения.",
    "bitbybit.consoleLog": "журнал консоли",
    "bitbybit.consoleLog_description": "Выводит ввод в консоль браузера.",
    "bitbybit.previewData": "предпросмотр данных",
    "bitbybit.previewData_description": "Показывает входные данные в области предпросмотра. Это может быть текст, числа, объекты json, массивы и т.д. Циклические объекты Javascript не допускаются.",
    "bitbybit.runner.getRunnerInputValue": "получить значение входа runner",
    "bitbybit.runner.getRunnerInputValue_description": "Получить значение входа runner из JSON входов. Этот компонент всегда будет возвращать неопределенное значение в контексте редактора.",
    "bitbybit.runner.getRunnerInputs": "получить входы runner",
    "bitbybit.runner.getRunnerInputs_description": "Получить входы runner в JSON. Этот компонент всегда будет возвращать пустой объект в контексте редактора.",
    "bitbybit.runner.run": "запустить",
    "bitbybit.runner.run_description": "Запускает код javascript runner",
    "bitbybit.runner.setRunnerResult": "установить результат runner",
    "bitbybit.runner.setRunnerResult_description": "Устанавливает полный JSON результат для runner. Имейте в виду, что безопаснее устанавливать значения, так как этот метод перезапишет весь объект результата предоставленным значением.",
    "bitbybit.runner.setRunnerResultArrayValue": "установить значение массива результата runner",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Устанавливает значение результата runner по свойству объекта JSON. Каждое значение будет добавлено в массив, который является значением свойства.",
    "bitbybit.runner.setRunnerResultValue": "установить значение результата runner",
    "bitbybit.runner.setRunnerResultValue_description": "Устанавливает значение результата runner по свойству объекта JSON.",
    "bitbybit.text.areaCreate": "текстовая область",
    "bitbybit.text.areaCreate_description": "Создает текстовую область в редакторе. Можно настроить текст, ширину и высоту области.",
    "update on drag": "обновлять при перетаскивании",
    "paste": "вставить",
    "duplicate": "дублировать",
    "delete": "удалить",
    "keyboard": "клавиатура",
    "data": "данные",
    "observables": "наблюдаемые",
    "buttons": "кнопки",
    "variables": "переменные",
    "functions": "функции",
    "loop": "цикл",
    "apply": "применить",
    "async context": "асинхронный контекст",
    "async context description": "Создает асинхронный контекст, который может использовать компоненты await, упрощая выполнение и читаемость асинхронного кода.",
    "then": "затем",
    "await": "ожидать",
    "await description": "Ожидает разрешения промиса и возвращает значение.",
    "when the": "когда",
    "error": "ошибка",
    "happens in the promise": "происходит в промисе",
    "catch": "перехватить",
    "catch description": "Перехватывает ошибку, которая может произойти при выполнении асинхронного кода. Пользователь может выбрать подходящий способ обработки ошибок.",
    "cancel the interval execution": "отменить выполнение интервала",
    "cancel the interval description": "Отменяет выполнение интервала, предоставляя обработчик.",
    "cancel the timeout execution": "отменить выполнение таймаута",
    "cancel the timeout description": "Отменяет выполнение таймаута, предоставляя обработчик.",
    "key down": "клавиша нажата",
    "key down descritpion": "Инициирует код при событии нажатия клавиши.",
    "key up": "клавиша отпущена",
    "key up description": "Инициирует код при событии отпускания клавиши.",
    "key press": "нажатие клавиши",
    "key press description": "Инициирует код при событии нажатия клавиши.",
    "is key pressed": "клавиша нажата?",
    "block_validation_required": "должно быть предоставлено",
    "block_validation_of_length": "должно содержать количество элементов",
    "block_validation_higher_or_equal": "должно быть больше или равно",
    "block_validation_lower_or_equal": "должно быть меньше или равно",
    "block_validation_range": "должно быть в диапазоне",
    "block_validation_smaller_than": "должно быть меньше, чем",
    "block_validation_smaller_or_equal_than": "должно быть меньше или равно, чем",
    "block_validation_larger_than": "должно быть больше, чем",
    "block_validation_larger_or_equal_than": "должно быть больше или равно, чем",
    "save text to file": "сохранить текст в файл",
    "save text to file description": "Сохраняет текст в файл и позволяет выбрать имя и расширение. Этот компонент не отображает текст и может использоваться в ситуациях, когда текст слишком велик для редактирования в поле текстовой области.",
    "print text on screen": "вывести текст на экран",
    "print text on screen description": "Выводит текст на экран. Этот компонент полезен для целей отладки.",
    "preview text and save to file": "предпросмотр текста и сохранение в файл",
    "preview text and save to file description": "Выводит текст на экран и позволяет сохранить его в файл. Этот компонент полезен для целей отладки.",
    "register render loop listener": "зарегистрировать слушателя цикла рендеринга",
    "and update": "и обновить",
    "register render loop listener description": "Запускает оператор в цикле рендеринга и указывает, сколько времени прошло с предыдущего кадра, в переменной timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "timeElapsedFromPreviousFrame",
    "computing": "вычисление",
    "result": "результат",
    "of promise is returned": "промиса возвращается",
    "on pointer up": "при отпускании указателя",
    "on pointer move": "при движении указателя",
    "on pointer down": "при нажатии указателя",
    "of babylonjs observable object": "объекта observable babylonjs",
    "observable name": "имя observable",
    "is key pressed description": "Проверяет, нажата ли клавиша, и возвращает true или false.",
    "execute code after": "выполнить код через",
    "execute code after description": "Выполняет код через заданный таймаут в секундах.",
    "execute code every": "выполнять код каждые",
    "second(s)": "секунд(ы)",
    "execute code every description": "Выполняет код каждые заданный интервал в секундах.",
    "handler": "обработчик",
    "workers initialising": "инициализация воркеров",
    "Assets": "Ресурсы",
    "Local assets stored in browser cache:": "Локальные ресурсы, сохраненные в кэше браузера:",
    "Asset Name": "Имя ресурса",
    "Name is required": "Имя обязательно",
    "Asset with this name already exists, choose a different one": "Ресурс с таким именем уже существует, выберите другое",
    "Allowed file formats:": "Допустимые форматы файлов:",
    "You must select an asset file": "Необходимо выбрать файл ресурса",
    "Upload Local Asset": "Загрузить локальный ресурс",
    "File Name": "Имя файла",
    "File Size": "Размер файла",
    "Your browser does not support indexDB and you can't upload local asset files.": "Ваш браузер не поддерживает indexDB, и вы не можете загружать локальные файлы ресурсов.",
    "Upload": "Загрузить",
    "elements": "элементы",
    "bitbybit.vector.vectorsTheSame": "векторы одинаковы",
    "vectorsTheSame": "векторы одинаковы",
    "bitbybit.vector.vectorsTheSame_description": "Проверяет, совпадают ли два вектора в пределах заданного допуска (учитывает точность плавающей запятой). Пример: [1,2,3] vs [1.0001,2.0001,3.0001] с допуском 0.001 → true",
    "vec1": "вектор 1",
    "vec2": "вектор 2",
    "bitbybit.point.boundingBoxOfPoints": "габаритный контейнер точек",
    "boundingBoxOfPoints": "габаритный контейнер точек",
    "bitbybit.point.boundingBoxOfPoints_description": "Вычисляет выровненный по осям ограничивающий параллелепипед, содержащий все точки (min, max, center, width, height, length). Пример: points=[[0,0,0], [10,5,3]] → {min:[0,0,0], max:[10,5,3], center:[5,2.5,1.5], width:10, height:5, length:3}",
    "bitbybit.point.normalFromThreePoints": "нормаль из трех точек",
    "normalFromThreePoints": "нормаль из трех точек",
    "bitbybit.point.normalFromThreePoints_description": "Вычисляет вектор нормали из трех точек, используя векторное произведение (перпендикулярно плоскости). Пример: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0] → [0,0,1] (указывает вверх от плоскости XY)",
    "reverseNormal": "обратная нормаль",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "линейный контур с удлинениями",
    "createLineWireWithExtensions": "линейный контур с удлинениями",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Создает линейный контур OpenCascade с удлинениями",
    "extensionStart": "нач. удлин.",
    "extensionEnd": "кон. удлин.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "средняя точка на контуре",
    "midPointOnWire": "средняя точка на контуре",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Вычисляет среднюю точку на контуре при параметре 0.5",
    "centerOnOrigin": "центрировать по началу координат",
    "bitbybit.occt.shapes.wire.textWiresWithData": "текстовые контуры с данными",
    "textWiresWithData": "текстовые контуры с данными",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Создает составную фигуру OpenCascade из текстовых контуров и возвращает дополнительную информацию на основе шрифта simplex, созданного доктором А. В. Херши",
    "bitbybit.occt.transforms.alignNormAndAxis": "выровнять нормаль и ось",
    "alignNormAndAxis": "выровнять нормаль и ось",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Выравнивает фигуру по нормали и оси",
    "fromNorm": "от нормали",
    "fromAx": "от оси",
    "toNorm": "к нормали",
    "toAx": "к оси",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "простой линейный размер длины",
    "simpleLinearLengthDimension": "простой линейный размер длины",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Создает простую линейную размерность длины между двумя точками - единицы измерения. Вы решаете, какой тип единиц вы используете, предоставляя суффикс.",
    "offsetFromPoints": "отступ от точек",
    "crossingSize": "размер пересечения",
    "labelSuffix": "суффикс метки",
    "labelSize": "размер метки",
    "labelOffset": "отступ метки",
    "bitbybit.occt.dimensions.simpleAngularDimension": "простой угловой размер",
    "simpleAngularDimension": "простой угловой размер",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Создает простой угловой размер. По умолчанию выводятся градусы, но вы можете выбрать использование радианов.",
    "direction1": "направление 1",
    "direction2": "направление 2",
    "offsetFromCenter": "смещение от центра",
    "extraSize": "дополнительный размер",
    "radians": "радианы",
    "bitbybit.occt.dimensions.pinWithLabel": "маркер с меткой",
    "pinWithLabel": "маркер с меткой",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Создает маркер с меткой. Его можно использовать для пояснения информации о моделях или отметки важных элементов в 3D-сцене.",
    "offsetFromStart": "смещение от начала",
    "bitbybit.vector.lengthSq": "длина в квадрате",
    "lengthSq": "длина в квадрате",
    "bitbybit.vector.lengthSq_description": "Вычисляет квадрат длины (квадрат величины) 3D вектора. Пример: [3,4,0] → 25 (длина 5 в квадрате)",
    "bitbybit.point.twoPointsAlmostEqual": "две точки равны",
    "twoPointsAlmostEqual": "две точки равны",
    "bitbybit.point.twoPointsAlmostEqual_description": "Проверяет, являются ли две точки приблизительно равными в пределах допуска (сравнение на основе расстояния). Пример: point1=[1.0000001, 2.0, 3.0], point2=[1.0, 2.0, 3.0], tolerance=1e-6 → true",
    "bitbybit.line.lineToSegment": "линия в отрезок",
    "lineToSegment": "линия в отрезок",
    "bitbybit.line.lineToSegment_description": "Преобразует объект линии в формат массива сегмента. Пример: {start:[0,0,0], end:[10,5,0]} → [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "линии в отрезки",
    "linesToSegments": "линии в отрезки",
    "bitbybit.line.linesToSegments_description": "Преобразует несколько объектов линий в формат массива сегментов (пакетное преобразование). Пример: 3 объекта линий → 3 массива сегментов [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "отрезок в линию",
    "segmentToLine": "отрезок в линию",
    "bitbybit.line.segmentToLine_description": "Преобразует массив сегмента в формат объекта линии. Пример: [[0,0,0], [10,5,0]] → {start:[0,0,0], end:[10,5,0]}",
    "segment": "отрезок",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "отрезки в линии",
    "segmentsToLines": "отрезки в линии",
    "bitbybit.line.segmentsToLines_description": "Преобразует несколько массивов сегментов в формат объекта линии (пакетное преобразование). Пример: 3 массива сегментов → 3 объекта линий со свойствами start/end",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "сортировать отрезки в полилинии",
    "sortSegmentsIntoPolylines": "сортировать отрезки в полилинии",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Сортирует перемешанные сегменты в связанные полилинии путем сопоставления конечных точек. Использует пространственное хеширование для эффективного поиска соединений. Пример: 10 случайных сегментов, образующих 2 связанных пути → 2 полилинии",
    "sort": "сортировать",
    "bitbybit.mesh.signedDistanceToPlane": "знаковое расстояние до плоскости",
    "signedDistanceToPlane": "знаковое расстояние до плоскости",
    "bitbybit.mesh.signedDistanceToPlane_description": "Вычисляет расстояние со знаком от точки до плоскости (положительное=над плоскостью, отрицательное=под). Пример: point=[0,5,0], plane={normal:[0,1,0], d:0} → 5 (точка находится на 5 единиц выше плоскости XZ)",
    "plane": "плоскость",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "вычислить плоскость треугольника",
    "calculateTrianglePlane": "вычислить плоскость треугольника",
    "bitbybit.mesh.calculateTrianglePlane_description": "Вычисляет уравнение плоскости по вершинам треугольника (вектор нормали и расстояние от начала координат). Возвращает undefined, если треугольник вырожденный (нулевая площадь, коллинеарные точки). Пример: triangle=[[0,0,0], [1,0,0], [0,1,0]] → {normal:[0,0,1], d:0} (плоскость XY)",
    "triangle": "треугольник",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "пересечение треугольников",
    "triangleTriangleIntersection": "пересечение треугольников",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Вычисляет сегмент пересечения двух треугольников (отрезок линии, где они пересекаются). Возвращает undefined, если треугольники не пересекаются, параллельны или копланарны. Пример: triangle1=[[0,0,0], [2,0,0], [1,2,0]], triangle2=[[1,-1,1], [1,1,1], [1,1,-1]] → [[1,0,0], [1,1,0]]",
    "triangle1": "треугольник 1",
    "triangle2": "треугольник 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "отрезки пересечения сеток",
    "meshMeshIntersectionSegments": "отрезки пересечения сеток",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Вычисляет все сегменты пересечения между двумя треугольными сетками (попарные тесты треугольников). Возвращает массив отрезков линий, где поверхности сеток пересекаются. Пример: сетка куба пересекается с сеткой сферы → несколько сегментов, образующих кривую пересечения",
    "mesh1": "сетка 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "сетка 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "полилинии пересечения сеток",
    "meshMeshIntersectionPolylines": "полилинии пересечения сеток",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Вычисляет полилинии пересечения между двумя сетками путем сортировки сегментов в связанные пути. Сегменты соединяются конец-в-конец, образуя непрерывные или замкнутые кривые. Пример: пересечение куб-сфера → замкнутые петли полилиний, где поверхности встречаются",
    "bitbybit.occt.shapeFacesToPolygonPoints": "грани формы в точки полигона",
    "shapeFacesToPolygonPoints": "грани формы в точки полигона",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Создает точки полигона из граней формы",
    "reversedPoints": "обратные точки",
    "bitbybit.occt.shapeToMesh": "форма в сетку",
    "shapeToMesh": "форма в сетку",
    "bitbybit.occt.shapeToMesh_description": "Создает сетку из формы",
    "bitbybit.occt.shapesToMeshes": "формы в сетки",
    "shapesToMeshes": "формы в сетки",
    "bitbybit.occt.shapesToMeshes_description": "Создает сетку из формы",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "из точек полигона",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Создать многообразие (Manifold) из набора точек полигона, описывающих треугольники.",
    "traingle": "треугольник",
    "bitbybit.point.stretchPointsDirFromCenter": "растянуть точки в направлении от центра",
    "stretchPointsDirFromCenter": "растянуть точки в направлении от центра",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Растягивает несколько точек вдоль направления от центральной точки (направленное масштабирование). Пример: points=[[10,0,0]], center=[0,0,0], direction=[1,0,0], scale=2 → [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "шестиугольная сетка, масштабированная по размеру",
    "hexGridScaledToFit": "шестиугольная сетка, масштабированная по размеру",
    "bitbybit.point.hexGridScaledToFit_description": "Создает шестиугольную сетку, масштабированную для соответствия заданным границам ширины/высоты (автоматически вычисляет размер шестиугольника). Возвращает центральные точки и вершины шестиугольников. Поддерживает ориентацию острием вверх или плоской стороной вверх. Пример: width=10, height=10, nrHexagonsInHeight=3 → шестиугольная сетка, заполняющая область 10×10 с 3 рядами",
    "nrHexagonsU": "кол-во шестиугольников U",
    "nrHexagonsV": "кол-во шестиугольников V",
    "extendTop": "расширить сверху",
    "extendBottom": "расширить снизу",
    "extendLeft": "расширить слева",
    "extendRight": "расширить справа",
    "centerGrid": "центрировать сетку",
    "bitbybit.point.sortPoints": "сортировать точки",
    "sortPoints": "сортировать точки",
    "bitbybit.point.sortPoints_description": "Сортирует точки лексикографически (по координатам X, затем Y, затем Z). Пример: [[5,0,0], [1,0,0], [3,0,0]] → [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "пересечение линия-линия",
    "lineLineIntersection": "пересечение линия-линия",
    "bitbybit.line.lineLineIntersection_description": "Вычисляет точку пересечения двух линий (или сегментов, если checkSegmentsOnly=true). Возвращает undefined, если линии параллельны, скрещиваются или сегменты не перекрываются. Пример: line1={start:[0,0,0], end:[10,0,0]}, line2={start:[5,-5,0], end:[5,5,0]} → [5,0,0]",
    "line1": "линия 1",
    "line2": "линия 2",
    "checkSegmentsOnly": "проверять только отрезки",
    "bitbybit.polyline.polylineToLines": "полилиния в линии",
    "polylineToLines": "полилиния в линии",
    "bitbybit.polyline.polylineToLines_description": "Преобразует полилинию в отрезки линий (каждый сегмент как объект линии со start/end). Закрытые полилинии включают замыкающий сегмент. Пример: 3 точки → 2 или 3 линии (в зависимости от isClosed)",
    "bitbybit.polyline.polylineToSegments": "полилиния в отрезки",
    "polylineToSegments": "полилиния в отрезки",
    "bitbybit.polyline.polylineToSegments_description": "Преобразует полилинию в массивы сегментов (каждый сегмент как [point1, point2]). Закрытые полилинии включают замыкающий сегмент, если конечные точки различаются. Пример: 4 точки, закрытая → 4 сегмента, соединяющих все точки в петлю",
    "bitbybit.polyline.polylineSelfIntersection": "самопересечение полилинии",
    "polylineSelfIntersection": "самопересечение полилинии",
    "bitbybit.polyline.polylineSelfIntersection_description": "Находит точки, где полилиния пересекает саму себя (точки самопересечения). Пропускает смежные сегменты и дедуплицирует близкие точки. Пример: полилиния в форме восьмерки → возвращает центральную точку пересечения",
    "bitbybit.polyline.twoPolylineIntersection": "пересечение двух полилиний",
    "twoPolylineIntersection": "пересечение двух полилиний",
    "bitbybit.polyline.twoPolylineIntersection_description": "Находит точки пересечения между двумя полилиниями (все пересечения сегмент-сегмент). Проверяет все пары сегментов и дедуплицирует близкие точки. Пример: пересекающиеся полилинии, образующие X → возвращает центральную точку пересечения",
    "polyline1": "полилиния 1",
    "polyline2": "полилиния 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "разделить на шестиугольные каркасы",
    "subdivideToHexagonWires": "разделить на шестиугольные каркасы",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Разделяет грань на шестиугольные каркасы",
    "extendUUp": "расширить U вверх",
    "extendUBottom": "расширить U вниз",
    "extendVUp": "расширить V вверх",
    "extendVBottom": "расширить V вниз",
    "nrHexagonsInHeight": "кол-во шестиугольников по высоте",
    "nrHexagonsInWidth": "кол-во шестиугольников по ширине",
    "bitbybit.vector.length": "длина вектора",
    "bitbybit.vector.length_description": "Вычисляет длину (величину) 3D вектора. Пример: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.point.maxFilletRadius": "макс. радиус скругления",
    "maxFilletRadius": "макс. радиус скругления",
    "bitbybit.point.maxFilletRadius_description": "Вычисляет максимально возможный радиус скругления в углу, образованном двумя отрезками линий с общей конечной точкой (C), так, чтобы дуга скругления была касательной к обоим отрезкам и полностью лежала внутри них.",
    "bitbybit.point.maxFilletRadiusHalfLine": "макс. радиус скругления (половина линии)",
    "maxFilletRadiusHalfLine": "макс. радиус скругления (половина линии)",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Вычисляет максимально возможный радиус скругления в углу C так, чтобы дуга скругления была касательной к обоим отрезкам (P1-C, P2-C), а точки касания лежали в пределах первой половины каждого отрезка (измеренной от C).",
    "bitbybit.point.maxFilletsHalfLine": "макс. скругления (половина линии)",
    "maxFilletsHalfLine": "макс. скругления (половина линии)",
    "bitbybit.point.maxFilletsHalfLine_description": "Вычисляет максимально возможный радиус скругления в каждом углу полилинии, образованной серией точек. Радиус скругления рассчитывается для каждого внутреннего угла и опционально для замыкающих углов, если полилиния замкнута.",
    "checkLastWithFirst": "проверить последний с первым",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "наиболее безопасный макс. радиус скругления для точек (половина линии)",
    "safestPointsMaxFilletHalfLine": "наиболее безопасный макс. радиус скругления для точек (половина линии)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Вычисляет единственный наиболее безопасный максимальный радиус скругления, который может быть равномерно применен ко всем углам набора точек, на основе ограничения 'половина линии'. Он определяется путем нахождения минимума из максимально возможных радиусов скругления, рассчитанных для каждого отдельного угла.",
    "bitbybit.polyline.maxFilletsHalfLine": "макс. скругления (половина линии)",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Вычисляет максимально возможный радиус скругления по правилу 'половина линии' для каждого угла данной полилинии. Для замкнутой полилинии он включает углы, соединяющие последний отрезок с первым. Расчет использует ограничение 'половина линии', что означает, что точки касания скругления должны лежать в пределах первой половины каждого отрезка, соединенного с углом.",
    "bitbybit.polyline.safestFilletRadius": "наиболее безопасный радиус скругления",
    "safestFilletRadius": "наиболее безопасный радиус скругления",
    "bitbybit.polyline.safestFilletRadius_description": "Вычисляет единственный наиболее безопасный максимальный радиус скругления, который может быть равномерно применен ко всем углам полилинии, на основе ограничения 'половина линии'. Он определяется путем нахождения минимума из максимально возможных радиусов скругления, рассчитанных для каждого отдельного угла.",
    "flatTop": "плоская вершина",
    "bitbybit.mesh.meshMeshIntersectionPoints": "точки пересечения сетка-сетка",
    "meshMeshIntersectionPoints": "точки пересечения сетка-сетка",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Вычисляет точки пересечения между двумя сетками как массивы точек (один массив на полилинию). Закрытые полилинии имеют первую точку, продублированную в конце. Пример: пересечение куб-сфера → массивы точек, определяющие кривые пересечения",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "шестиугольники в сетке",
    "hexagonsInGrid": "шестиугольники в сетке",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Создает шестиугольные каркасы OpenCascade в сетке",
    "scalePatternWidth": "масштабировать ширину узора",
    "scalePatternHeight": "масштабировать высоту узора",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "каркасы пересечения сетка-сетка",
    "meshMeshIntersectionWires": "каркасы пересечения сетка-сетка",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Выполняет операцию пересечения сетка-сетка между двумя формами - обе формы могут иметь свою точность построения сетки. Этот алгоритм пересекает сетки и возвращает каркасы пересечения, которые являются полилиниями или многоугольниками.",
    "mesh based": "на основе сетки",
    "precision1": "точность 1",
    "precision2": "точность 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "точки пересечения сетка-сетка",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Выполняет операцию пересечения сетка-сетка между двумя формами - обе формы могут иметь свою точность построения сетки. Этот алгоритм пересекает сетки и возвращает точки пересечения.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "пересечение сетка-сетка в каркасы",
    "meshMeshIntersectionOfShapesWires": "пересечение сетка-сетка в каркасы",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Выполняет операцию пересечения сетка-сетка между формой и несколькими другими формами - все формы могут иметь свою точность построения сетки. Этот алгоритм пересекает сетки и возвращает каркасы пересечения, которые являются полилиниями или многоугольниками.",
    "precisionShapes": "точность форм",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "пересечение сетка-сетка в точки",
    "meshMeshIntersectionOfShapesPoints": "пересечение сетка-сетка в точки",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Выполняет операцию пересечения сетка-сетка между формой и несколькими другими формами - все формы могут иметь свою точность построения сетки. Этот алгоритм пересекает сетки и возвращает точки пересечения.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "шестиугольники в сетке",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Создает шестиугольники OpenCascade в сетке (как грани)",
    "bitbybit.jscad.toPolygonPoints": "в точки полигона",
    "toPolygonPoints": "в точки полигона",
    "bitbybit.jscad.toPolygonPoints_description": "Преобразует сетку Jscad в полигональные точки, представляющие треугольники сетки.",
    "conversions": "преобразования",
    "bitbybit.manifold.toPolygonPoints": "в точки полигона",
    "bitbybit.manifold.toPolygonPoints_description": "Преобразует форму manifold в набор точек полигонов, представляющих сетку.",
    "flatU": "плоский U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "разделить на шестиугольные отверстия",
    "subdivideToHexagonHoles": "разделить на шестиугольные отверстия",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Разделяет грань на шестиугольные отверстия",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "конвертировать линии в NURBS кривые",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Конвертирует линии в NURBS кривые. Возвращает массив объектов verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "конвертировать линию в NURBS кривую",
    "convertLineToNurbsCurve": "конвертировать линию в NURBS кривую",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Конвертирует линию в NURBS кривую. Возвращает объект verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "конвертировать полилинию в NURBS кривую",
    "convertPolylineToNurbsCurve": "конвертировать полилинию в NURBS кривую",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Конвертирует полилинию в NURBS кривую. Возвращает объект verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "конвертировать полилинии в NURBS кривые",
    "convertPolylinesToNurbsCurves": "конвертировать полилинии в NURBS кривые",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Конвертирует полилинии в NURBS кривые. Возвращает объекты verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "сегмент",
    "createSegment": "сегмент",
    "bitbybit.line.createSegment_description": "Создает сегмент из двух точек (формат массива: [start, end]). Пример: start=[0,0,0], end=[10,5,0] → [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "ребро из базовой линии",
    "fromBaseLine": "из базовой линии",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Создает линейное ребро из формата базовой линии {start: Point3, end: Point3}",
    "from base": "из базы",
    "bitbybit.occt.shapes.edge.fromBaseLines": "ребро из базовых линий",
    "fromBaseLines": "из базовых линий",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Создает линейные ребра из формата базовых линий {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "ребро из базового сегмента",
    "fromBaseSegment": "из базового сегмента",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Создает линейное ребро из формата базового сегмента [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "ребра из базовых сегментов",
    "fromBaseSegments": "из базовых сегментов",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Создает линейное ребро из формата базовых сегментов [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "ребра из точек",
    "fromPoints": "из точек",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Создает линейные ребра из набора точек",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "ребра из базовой полилинии",
    "fromBasePolyline": "из базовой полилинии",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Создает линейные ребра из определения полилинии",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "ребра из базового треугольника",
    "fromBaseTriangle": "из базового треугольника",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Создает линейные ребра из определения треугольника",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "ребра из базовой сетки",
    "fromBaseMesh": "из базовой сетки",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Создает линейные ребра из определения сетки",
    "bitbybit.occt.shapes.wire.fromBaseLine": "каркас из базовой линии",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Создает линейный каркас из формата базовой линии {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "каркасы из базовых линий",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Создает линейные каркасы из формата базовых линий {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "каркас из базового сегмента",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Создает линейный каркас из формата базового сегмента [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "каркасы из базовых сегментов",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Создает линейные каркасы из формата базовых сегментов [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "каркас из точек",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Создает каркас из набора точек",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "каркас из базовой полилинии",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Создает каркас из определения полилинии",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "каркас из базового треугольника",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Создает каркас из определения треугольника",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "каркасы из базовой сетки",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Создает каркасы из определения сетки",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "грань из базового треугольника",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Создает грань из определения треугольника",
    "bitbybit.occt.shapes.face.fromBaseMesh": "грани из базовой сетки",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Создает грани из определения сетки",
    "fromRightHanded": "из правостороннего",
    "bitbybit.advanced.text3d.createWithUrl": "текст с url",
    "createWithUrl": "текст с url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Создает 3d текст с URL шрифта Это полезно, когда вы хотите использовать пользовательский шрифт, который не включен в библиотеку. Шрифт будет загружен с предоставленного URL и использован для генерации 3d текста. Убедитесь, что шрифты не содержат самопересечений и других плохих символов - это распространенная проблема с пользовательскими шрифтами. Поддерживаемые форматы шрифтов: ttf, otf, woff. Обратите внимание, что Woff2 не поддерживается opentype.js, так как это сжатый формат.",
    "fontUrl": "url шрифта",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "текст на грани url",
    "createTextOnFaceUrl": "текст на грани url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Создает 3D-текст на грани с использованием URL-адреса шрифта. Это полезно, когда вы хотите использовать пользовательский шрифт, который не включен в библиотеку. Шрифт будет загружен с предоставленного URL-адреса и использован для создания 3D-текста. Убедитесь, что шрифты не содержат самопересечений и других некорректных символов - это частая проблема с пользовательскими шрифтами. Поддерживаемые форматы шрифтов: ttf, otf, woff. Обратите внимание, что Woff2 не поддерживается opentype.js, так как это сжатый формат.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "тексты на грани url",
    "createTextsOnFaceUrl": "тексты на грани url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Создает 3d тексты на грани из нескольких определений URL Это полезно, когда вы хотите использовать пользовательский шрифт, который не включен в библиотеку. Шрифт будет загружен с предоставленного URL и использован для генерации 3d текста. Убедитесь, что шрифты не содержат самопересечений и других плохих символов - это распространенная проблема с пользовательскими шрифтами. Поддерживаемые форматы шрифтов: ttf, otf, woff. Обратите внимание, что Woff2 не поддерживается opentype.js, так как это сжатый формат.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "определение 3d текста на грани url",
    "definition3dTextOnFaceUrl": "определение 3d текста на грани url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Создает 3d текст, который будет использоваться в определении URL грани Это полезно, когда вы хотите использовать пользовательский шрифт, который не включен в библиотеку. Шрифт будет загружен с предоставленного URL и использован для генерации 3d текста. Убедитесь, что шрифты не содержат самопересечений и других плохих символов - это распространенная проблема с пользовательскими шрифтами. Поддерживаемые форматы шрифтов: ttf, otf, woff. Обратите внимание, что Woff2 не поддерживается opentype.js, так как это сжатый формат.",
    "bitbybit.advanced.navigation.pointOfInterest": "точка интереса",
    "navigation": "навигация",
    "pointOfInterest": "точка интереса",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Создает точку интереса - кликабельный индикатор в 3D пространстве, который можно использовать для перемещения камеры в определенное место с предопределенной позицией камеры и целью. Точка интереса может быть стилизована с помощью PointOfInterestStyleDto и анимирована с эффектом пульсации. Точка интереса также может иметь текстовую метку.",
    "cameraTarget": "цель камеры",
    "cameraPosition": "положение камеры",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "система точек интереса",
    "pointsOfInterestSystem": "система точек интереса",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "точки интереса",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "точка интереса",
    "style": "стиль",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "стиль точки интереса",
    "pointOfInterestStyle": "стиль точки интереса",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Создать стиль для точки интереса - используется для оформления индикаторов точек интереса в 3D-пространстве. Вы можете настроить размер точки, цвет, цвет при наведении, эффект пульсации, цвет и размер текстовой метки.",
    "pointSize": "размер точки",
    "pointColor": "цвет точки",
    "hoverPointColor": "цвет точки при наведении",
    "pulseColor": "цвет пульсации",
    "hoverPulseColor": "цвет пульсации при наведении",
    "pulseMinSize": "мин. размер пульсации",
    "pulseMaxSize": "макс. размер пульсации",
    "pulseThickness": "толщина пульсации",
    "pulseSpeed": "скорость пульсации",
    "textColor": "цвет текста",
    "hoverTextColor": "цвет текста при наведении",
    "textSize": "размер текста",
    "hideSkybox": "скрыть скайбокс",
    "textureUrl": "URL текстуры",
    "hdrTexture": "HDR-текстура",
    "textureSize": "размер текстуры",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "включить пользовательскую текстуру для скайбокса",
    "enableSkyboxCustomTexture": "включить пользовательскую текстуру для скайбокса",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Включает скайбокс с пользовательской текстурой",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "CSS фоновое изображение холста",
    "canvasCSSBackgroundImage": "CSS фоновое изображение холста",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Изменяет фон сцены на CSS фоновое изображение для 3D пространства",
    "cssBackgroundImage": "CSS фоновое изображение",
    "bitbybit.babylon.scene.twoColorLinearGradient": "двухцветный линейный градиент",
    "twoColorLinearGradient": "двухцветный линейный градиент",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Создает двухцветный линейный градиентный фон для 3D пространства",
    "colorFrom": "цвет от",
    "colorTo": "цвет до",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "остановка от",
    "stopTo": "остановка до",
    "bitbybit.babylon.scene.twoColorRadialGradient": "двухцветный радиальный градиент",
    "twoColorRadialGradient": "двухцветный радиальный градиент",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Создает двухцветный радиальный градиентный фон для 3D пространства",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "многоцветный линейный градиент",
    "multiColorLinearGradient": "многоцветный линейный градиент",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Создает многоцветный линейный градиентный фон для 3D пространства",
    "Base.Color[]": "Base.Color[]",
    "stops": "остановки",
    "bitbybit.babylon.scene.multiColorRadialGradient": "многоцветный радиальный градиент",
    "multiColorRadialGradient": "многоцветный радиальный градиент",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Создает многоцветный радиальный градиентный фон для 3D пространства",
    "bitbybit.babylon.scene.canvasBackgroundImage": "фоновое изображение холста",
    "canvasBackgroundImage": "фоновое изображение холста",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Устанавливает фоновое изображение с различными опциями настройки для 3D пространства",
    "imageUrl": "URL изображения",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "вложение",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "обрезка",
    "labelRotation": "поворот метки",
    "bitbybit.advanced.dimensions.linearDimension": "линейный размер",
    "linearDimension": "линейный размер",
    "bitbybit.advanced.dimensions.linearDimension_description": "Создает линейный размер - измерительную линию между двумя точками с выносными линиями и текстовой меткой. Размер показывает расстояние между точками и может быть стилизован с помощью DimensionStyleDto.",
    "linear dimension": "линейный размер",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "угловой размер",
    "angularDimension": "угловой размер",
    "bitbybit.advanced.dimensions.angularDimension_description": "Создает угловой размер - измерительную дугу между двумя векторами направления с выносными линиями и текстовой меткой. Размер показывает угол между направлениями и может быть стилизован с помощью DimensionStyleDto.",
    "angular dimension": "угловой размер",
    "centerPoint": "центральная точка",
    "bitbybit.advanced.dimensions.dimensionStyle": "стиль размера",
    "dimensionStyle": "стиль размера",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Создать стиль размера - используется для стилизации размерных линий, стрелок и текста в 3D пространстве. Вы можете настроить цвета линий, толщину, размер текста, размер стрелок и цвета фона.",
    "dimension style": "стиль размера",
    "lineColor": "цвет линии",
    "lineThickness": "толщина линии",
    "extensionLineLength": "длина выносной линии",
    "textBackgroundColor": "цвет фона текста",
    "textBackgroundOpacity": "прозрачность фона текста",
    "arrowSize": "размер стрелки",
    "arrowColor": "цвет стрелки",
    "textRenderMode": "режим рендеринга текста",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "текстовый щит",
    "occlusionCheckInterval": "интервал проверки окклюзии",
    "arrowTailLength": "длина хвоста стрелки",
    "showArrows": "показать стрелки",
    "labelOverwrite": "перезаписать метку",
    "bitbybit.advanced.dimensions.radialDimension": "радиальный размер",
    "radialDimension": "радиальный размер",
    "bitbybit.advanced.dimensions.radialDimension_description": "Создает радиальный размер - измерительную линию от центра к периметру, показывающую радиус или диаметр. Показывает префикс 'R' для радиуса или префикс '⌀' для диаметра с дополнительной центральной меткой.",
    "radial dimension": "радиальный размер",
    "radiusPoint": "точка радиуса",
    "showDiameter": "показать диаметр",
    "showCenterMark": "показать центральную метку",
    "bitbybit.advanced.dimensions.diametralDimension": "диаметральный размер",
    "diametralDimension": "диаметральный размер",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Создает диаметральный размер - измерительную линию, охватывающую полный диаметр круглых элементов. Показывает префикс '⌀' с дополнительной центральной меткой и стрелками на обоих концах.",
    "diametral dimension": "диаметральный размер",
    "bitbybit.advanced.dimensions.ordinateDimension": "ординатный размер",
    "ordinateDimension": "ординатный размер",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Создает ординатный размер - показывает координату X, Y или Z от опорной точки с выносной линией. Полезно для аннотаций координат и ссылок на базы в технических чертежах.",
    "ordinate dimension": "ординатный размер",
    "measurementPoint": "точка измерения",
    "referencePoint": "опорная точка",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "показать выносную линию",
    "viewMode": "режим просмотра",
    "schema": "схема",
    "json schema": "JSON схема",
    "metadata": "метаданные",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "двухцветный линейный градиентный фон",
    "twoColorLinearGradientBackground": "двухцветный линейный градиентный фон",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Создает двухцветный линейный градиентный фон для 3D пространства",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "двухцветный радиальный градиентный фон",
    "twoColorRadialGradientBackground": "двухцветный радиальный градиентный фон",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Создает двухцветный радиальный градиентный фон для 3D пространства",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "многоцветный линейный градиентный фон",
    "multiColorLinearGradientBackground": "многоцветный линейный градиентный фон",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Создает многоцветный линейный градиентный фон для 3D пространства",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "многоцветный радиальный градиентный фон",
    "multiColorRadialGradientBackground": "многоцветный радиальный градиентный фон",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Создает многоцветный радиальный градиентный фон для 3D пространства",
    "textBackgroundStroke": "обводка фона текста",
    "textBackgroundRadius": "радиус фона текста",
    "stableSize": "стабильный размер",
    "alwaysOnTop": "всегда сверху",
    "textStableSize": "стабильный размер текста",
    "bitbybit.occt.io.shapeToDxfPaths": "форма в пути DXF",
    "shapeToDxfPaths": "форма в пути DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Создает пути DXF из формы OCCT Важно - формы, содержащие проволоки, должны лежать на плоскости XZ (Y=0) для корректного экспорта 2D DXF.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "пути DXF со слоем",
    "dxfPathsWithLayer": "пути DXF со слоем",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Добавляет информацию о слое и цвете к путям DXF Важно - формы, содержащие проволоки, должны лежать на плоскости XZ (Y=0) для корректного экспорта 2D DXF.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "слой",
    "bitbybit.occt.io.dxfCreate": "создать DXF",
    "dxfCreate": "создать DXF",
    "bitbybit.occt.io.dxfCreate_description": "Собирает несколько частей пути в полный файл DXF",
    "pathsParts": "части путей",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "толщина шрифта текста",
    "textPosition": "позиция текста",
    "textBackgroundStrokeThickness": "толщина обводки",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Очистить",
    "recompute": "Пересчитать",
    "clear tooltip": "Очистить все кэши и компоненты",
    "recompute tooltip": "Очищает кэш и пересчитывает",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "проволока профиля I-балки",
    "createIBeamProfileWire": "проволока профиля I-балки",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Создает проволоку профиля I-балки OpenCascade",
    "beam profiles": "профили балок",
    "webThickness": "толщина стенки",
    "flangeThickness": "толщина полки",
    "alignment": "выравнивание",
    "Base.basicAlignmentEnum": "Base.basicAlignmentEnum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "проволока профиля H-балки",
    "createHBeamProfileWire": "проволока профиля H-балки",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Создает проволоку профиля H-балки OpenCascade",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "проволока профиля T-балки",
    "createTBeamProfileWire": "проволока профиля T-балки",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Создает проволоку профиля T-балки OpenCascade",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "проволока профиля U-балки",
    "createUBeamProfileWire": "проволока профиля U-балки",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Создает проволоку профиля U-балки OpenCascade",
    "flangeWidth": "ширина полки",
    "bitbybit.occt.shapes.face.createLPolygonFace": "грань L-многоугольника",
    "createLPolygonFace": "грань L-многоугольника",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Создает грань L-многоугольника OpenCascade",
    "bitbybit.occt.shapes.face.createStarFace": "грань звезды",
    "createStarFace": "грань звезды",
    "bitbybit.occt.shapes.face.createStarFace_description": "Создает грань звезды OpenCascade",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "грань рождественской елки",
    "createChristmasTreeFace": "грань рождественской елки",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Создает грань рождественской елки OpenCascade",
    "bitbybit.occt.shapes.face.createParallelogramFace": "грань параллелограмма",
    "createParallelogramFace": "грань параллелограмма",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Создает грань параллелограмма OpenCascade",
    "bitbybit.occt.shapes.face.createHeartFace": "грань сердца",
    "createHeartFace": "грань сердца",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Создает грань сердца OpenCascade",
    "bitbybit.occt.shapes.face.createNGonFace": "грань n-угольника",
    "createNGonFace": "грань n-угольника",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Создает грань n-угольника OpenCascade",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "грань профиля I-балки",
    "createIBeamProfileFace": "грань профиля I-балки",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Создает грань профиля I-балки OpenCascade",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "грань профиля H-балки",
    "createHBeamProfileFace": "грань профиля H-балки",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Создает грань профиля H-балки OpenCascade",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "грань профиля T-балки",
    "createTBeamProfileFace": "грань профиля T-балки",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Создает грань профиля T-балки OpenCascade",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "грань профиля U-балки",
    "createUBeamProfileFace": "грань профиля U-балки",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Создает грань профиля U-балки OpenCascade",
    "bitbybit.occt.shapes.solid.createStarSolid": "твердое тело звезды",
    "createStarSolid": "твердое тело звезды",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Создает твердое тело звезды OpenCascade",
    "extrusionLengthFront": "длина выдавливания спереди",
    "extrusionLengthBack": "длина выдавливания сзади",
    "bitbybit.occt.shapes.solid.createNGonSolid": "твердое тело n-угольника",
    "createNGonSolid": "твердое тело n-угольника",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Создает твердое тело n-угольника OpenCascade",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "твердое тело параллелограмма",
    "createParallelogramSolid": "твердое тело параллелограмма",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Создает твердое тело параллелограмма OpenCascade",
    "bitbybit.occt.shapes.solid.createHeartSolid": "твердое тело сердца",
    "createHeartSolid": "твердое тело сердца",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Создает твердое тело сердца OpenCascade",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "твердое тело рождественской елки",
    "createChristmasTreeSolid": "твердое тело рождественской елки",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Создает твердое тело рождественской елки OpenCascade",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "твердое тело L-многоугольника",
    "createLPolygonSolid": "твердое тело L-многоугольника",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Создает твердое тело L-многоугольника OpenCascade",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "твердое тело профиля I-балки",
    "createIBeamProfileSolid": "твердое тело профиля I-балки",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Создает твердое тело профиля I-балки OpenCascade",
    "beam": "балка",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "твердое тело профиля H-балки",
    "createHBeamProfileSolid": "твердое тело профиля H-балки",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Создает твердое тело профиля H-балки OpenCascade",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "твердое тело профиля T-балки",
    "createTBeamProfileSolid": "твердое тело профиля T-балки",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Создает твердое тело профиля T-балки OpenCascade",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "твердое тело профиля U-балки",
    "createUBeamProfileSolid": "твердое тело профиля U-балки",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Создает твердое тело профиля U-балки OpenCascade",
    "endType": "Тип окончания",
    "dimensionEndTypeEnum": "dimensionEndTypeEnum",
    "arrowAngle": "Угол стрелки",
    "arrowsFlipped": "Стрелки перевернуты",
    "colorFormat": "Формат цвета",
    "dxfColorFormatEnum": "dxfColorFormatEnum",
    "acadVersion": "Версия Acad",
    "dxfAcadVersionEnum": "dxfAcadVersionEnum",
    "bitbybit.advanced.navigation.zoomOn": "Приблизить к",
    "zoomOn": "Приблизить к",
    "bitbybit.advanced.navigation.zoomOn_description": "Приближает камеру для подгонки указанных мешей в сцене с плавной анимацией. Работает только с ArcRotateCamera. Анимация может быть прервана при многократном вызове.",
    "animationSpeed": "Скорость анимации",
    "doNotUpdateMaxZ": "Не обновлять max z",
    "bitbybit.advanced.navigation.focusFromAngle": "Фокус под углом",
    "focusFromAngle": "Фокус под углом",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Фокусирует камеру на указанных мешах под определенным углом с плавной анимацией. Вычисляет центр ограничивающего блока всех мешей и позиционирует камеру по указанному вектору ориентации для просмотра центра. Работает только с ArcRotateCamera. Анимация может быть прервана при многократном вызове.",
    "padding": "Отступ",
    "shadowRefreshRate": "Частота обновления тени",
    "labelFlipHorizontal": "Отразить метку по горизонтали",
    "labelFlipVertical": "Отразить метку по вертикали",
    "bitbybit.advanced.navigation.zoomOnAspect": "Масштабирование по соотношению",
    "zoomOnAspect": "Масштабирование по соотношению",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Масштабирует камеру для размещения указанных мешей в сцене с плавной анимацией, учитывая точное соотношение сторон экрана. В отличие от zoomOn, этот метод точно вычисляет расстояние камеры на основе размеров области просмотра и ограничивающей рамки меша для обеспечения лучшего размещения при padding=0. Работает только с ArcRotateCamera. Анимация может быть прервана при многократном вызове.",
    "bitbybit.vector.parseNumbers": "разобрать числа",
    "parseNumbers": "разобрать числа",
    "bitbybit.vector.parseNumbers_description": "Преобразует массив чисел в строковом формате в фактические числа. Пример: ['1', '2.5', '3'] → [1, 2.5, 3], ['10', '-5', '0.1'] → [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "упростить",
    "bitbybit.manifold.manifold.operations.simplify_description": "Возвращает копию manifold, упрощенную до заданного допуска, но с неизменным фактическим значением допуска. Результат будет содержать подмножество исходных вершин, и все поверхности сдвинутся меньше, чем на величину допуска.",
    "bitbybit.manifold.manifold.operations.setProperties": "установить свойства",
    "setProperties": "установить свойства",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Создает новую копию этого manifold с обновленными свойствами вершин, предоставляя функцию, которая принимает существующую позицию и свойства в качестве входных данных. Вы можете указать любое количество выходных свойств, что позволяет создавать и удалять каналы. Примечание: чтение за пределами количества входных свойств или запись за пределами количества выходных свойств приведет к неопределенному поведению.",
    "propFunc": "функция свойств",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "деформировать",
    "warp": "деформировать",
    "bitbybit.manifold.manifold.transforms.warp_description": "Перемещает вершины этого Manifold (создавая новый) в соответствии с любой произвольной входной функцией. Легко создать функцию, которая деформирует геометрически правильный объект в такой, который пересекает сам себя, но это здесь не проверяется, поэтому пользователю следует выбирать функцию с осторожностью.",
    "warpFunc": "функция деформации",
    "(vert: Base.Vector3) => void": "(vert: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "статус",
    "status": "статус",
    "bitbybit.manifold.manifold.evaluate.status_description": "Возвращает причину, по которой входной Mesh создает пустой Manifold. Этот статус будет сохраняться при таких операциях, как распространение NaN, гарантируя, что ошибочная сетка не исчезнет таинственным образом. Пустые сетки все еще могут показывать NoError, например, при пересечении неперекрывающихся сеток.",
    "bitbybit.manifold.crossSection.transforms.warp": "деформировать",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Перемещает вершины этой CrossSection (создавая новую) в соответствии с любой произвольной входной функцией, за которой следует операция объединения (с правилом заполнения Positive), гарантирующая, что любые введенные пересечения не будут включены в результат.",
    "(vert: Base.Vector2) => void": "(vert: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "округлить и удалить замыкающие нули",
    "roundAndRemoveTrailingZeros": "округлить и удалить замыкающие нули",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Округляет число до указанных десятичных знаков и удаляет замыкающие нули. Пример: 1.32156 с 3 знаками возвращает 1.322, но 1.320000001 возвращает 1.32, а 1.000 возвращает 1",
    "bitbybit.math.clamp": "ограничить (clamp)",
    "clamp": "ограничить (clamp)",
    "bitbybit.math.clamp_description": "Ограничивает значение между минимальным и максимальным значением. Пример: clamp(5, 0, 3) возвращает 3, clamp(-1, 0, 3) возвращает 0, clamp(1.5, 0, 3) возвращает 1.5",
    "bitbybit.math.lerp": "линейная интерполяция (lerp)",
    "bitbybit.math.lerp_description": "Линейная интерполяция между двумя значениями с использованием параметра t (от 0 до 1). Пример: От 0 до 100 при t=0.5 → 50, От 10 до 20 при t=0.25 → 12.5. Когда t=0 возвращает start, когда t=1 возвращает end. Полезно для плавных переходов.",
    "t": "t",
    "bitbybit.math.inverseLerp": "обратная интерполяция",
    "inverseLerp": "обратная интерполяция",
    "bitbybit.math.inverseLerp_description": "Вычисляет параметр интерполяции t для значения между start и end (обратно lerp). Пример: Значение 5 в диапазоне [0,10] → t=0.5, Значение 2.5 в диапазоне [0,10] → t=0.25. Возвращает значение t, которое дало бы указанное значение в lerp. Полезно для поиска относительной позиции.",
    "bitbybit.math.smoothstep": "сглаженный шаг (smoothstep)",
    "smoothstep": "сглаженный шаг (smoothstep)",
    "bitbybit.math.smoothstep_description": "Интерполяция Эрмита с плавным ускорением и замедлением (более плавная, чем линейная lerp). Пример: x=0 → 0, x=0.5 → 0.5, x=1 → 1 (но с плавной S-образной кривой между ними). Ввод автоматически ограничивается диапазоном [0,1]. Вывод плавно нарастает и убывает. Отлично подходит для анимации.",
    "bitbybit.math.sign": "знак",
    "sign": "знак",
    "bitbybit.math.sign_description": "Возвращает знак числа: -1 для отрицательного, 0 для нуля, 1 для положительного. Пример: -5 → -1, 0 → 0, 3.14 → 1. Полезно для определения направления или полярности.",
    "bitbybit.math.fract": "дробная часть",
    "fract": "дробная часть",
    "bitbybit.math.fract_description": "Возвращает дробную часть числа (удаляет целую часть, сохраняет десятичные). Пример: 3.14 → 0.14, 5.9 → 0.9, -2.3 → 0.7. Полезно для зацикливания значений и создания повторяющихся паттернов.",
    "bitbybit.math.wrap": "обернуть",
    "bitbybit.math.wrap_description": "Оборачивает число в указанный диапазон (создает повторяющийся цикл). Пример: 1.5 в диапазоне [0,1) → 0.5, -0.3 в диапазоне [0,1) → 0.7, 370° в диапазоне [0,360) → 10°. Полезно для углов, UV или любого повторяющегося домена. Похоже на модуль, но корректно обрабатывает отрицательные числа.",
    "bitbybit.math.pingPong": "пинг-понг",
    "pingPong": "пинг-понг",
    "bitbybit.math.pingPong_description": "Создает эффект пинг-понга (туда-сюда), который заставляет значение отскакивать между 0 и длиной. Значение идет от 0→length, затем обратно length→0, повторяя этот цикл. Пример: С length=1: t=0→0, t=0.5→0.5, t=1→1 (пик), t=1.5→0.5, t=2→0, t=2.5→0.5 (повторяется). Полезно для создания анимации отскока, как мяч или колебательное движение.",
    "bitbybit.math.moveTowards": "двигаться к",
    "moveTowards": "двигаться к",
    "bitbybit.math.moveTowards_description": "Перемещает значение к цели на максимальную величину дельты (никогда не проскакивая). Пример: От 0 к 10 на макс 3 → 3, От 8 к 10 на макс 3 → 10 (достигнуто). Полезно для плавного движения с ограничением максимальной скорости.",
    "current": "текущее",
    "maxDelta": "макс дельта",
    "bitbybit.lists.getFirstItem": "получить первый элемент",
    "getFirstItem": "получить первый элемент",
    "bitbybit.lists.getFirstItem_description": "Получает первый элемент из списка. Пример: Из [10, 20, 30, 40], возвращает 10",
    "bitbybit.lists.getLastItem": "получить последний элемент",
    "getLastItem": "получить последний элемент",
    "bitbybit.lists.getLastItem_description": "Получает последний элемент из списка. Пример: Из [10, 20, 30, 40], возвращает 40",
    "bitbybit.lists.shuffle": "перемешать",
    "shuffle": "перемешать",
    "bitbybit.lists.shuffle_description": "Случайным образом переупорядочивает все элементы в списке (используя алгоритм Фишера-Йетса). Пример: Из [1, 2, 3, 4, 5], может вернуть [3, 1, 5, 2, 4] (порядок меняется каждый раз)",
    "bitbybit.lists.includes": "включает",
    "includes": "включает",
    "bitbybit.lists.includes_description": "Проверяет, содержит ли список определенный элемент. Пример: Список [10, 20, 30, 40] с элементом 30 возвращает true, с элементом 50 возвращает false",
    "bitbybit.lists.findIndex": "найти индекс",
    "findIndex": "найти индекс",
    "bitbybit.lists.findIndex_description": "Находит позицию (индекс) первого вхождения элемента в списке. Пример: В [10, 20, 30, 20, 40], поиск 20 возвращает 1 (первое вхождение), поиск 50 возвращает -1 (не найдено)",
    "bitbybit.lists.removeFirstItem": "удалить первый элемент",
    "removeFirstItem": "удалить первый элемент",
    "bitbybit.lists.removeFirstItem_description": "Удаляет первый элемент из списка. Пример: Из [10, 20, 30, 40], возвращает [20, 30, 40]",
    "bitbybit.lists.removeLastItem": "удалить последний элемент",
    "removeLastItem": "удалить последний элемент",
    "bitbybit.lists.removeLastItem_description": "Удаляет последний элемент из списка. Пример: Из [10, 20, 30, 40], возвращает [10, 20, 30]",
    "bitbybit.lists.removeItemAtIndexFromEnd": "удалить элемент по индексу с конца",
    "removeItemAtIndexFromEnd": "удалить элемент по индексу с конца",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Удаляет элемент, считая с конца списка (индекс 0 = последний элемент, 1 = предпоследний и т.д.). Пример: Из [10, 20, 30, 40, 50], удаление индекса 1 с конца дает [10, 20, 30, 50] (удаляет 40)",
    "bitbybit.lists.removeDuplicates": "удалить дубликаты",
    "removeDuplicates": "удалить дубликаты",
    "bitbybit.lists.removeDuplicates_description": "Удаляет повторяющиеся элементы из списка, используя строгое сравнение равенства (работает с любым типом). Пример: Из ['a', 'b', 'c', 'a', 'd', 'b'], возвращает ['a', 'b', 'c', 'd']",
    "bitbybit.lists.concatenate": "объединить",
    "concatenate": "объединить",
    "bitbybit.lists.concatenate_description": "Объединяет несколько списков в один список, соединяя их последовательно. Пример: Из [[1, 2], [3, 4], [5, 6]], возвращает [1, 2, 3, 4, 5, 6]",
    "bitbybit.lists.interleave": "чередовать",
    "interleave": "чередовать",
    "bitbybit.lists.interleave_description": "Объединяет несколько списков, чередуя элементы из каждого списка (первый из списка1, первый из списка2, второй из списка1 и т.д.). Пример: Из [[0, 1, 2], [3, 4, 5]], возвращает [0, 3, 1, 4, 2, 5]",
    "bitbybit.text.includes": "включает",
    "bitbybit.text.includes_description": "Проверяет, содержит ли текст строку поиска. Пример: text='привет мир', search='мир' → true",
    "bitbybit.text.startsWith": "начинается с",
    "startsWith": "начинается с",
    "bitbybit.text.startsWith_description": "Проверяет, начинается ли текст со строки поиска. Пример: text='привет мир', search='привет' → true",
    "bitbybit.text.endsWith": "заканчивается на",
    "endsWith": "заканчивается на",
    "bitbybit.text.endsWith_description": "Проверяет, заканчивается ли текст строкой поиска. Пример: text='привет мир', search='мир' → true",
    "bitbybit.text.indexOf": "индекс",
    "indexOf": "индекс",
    "bitbybit.text.indexOf_description": "Возвращает индекс первого вхождения строки поиска. Пример: text='привет мир', search='мир' → 7",
    "bitbybit.text.lastIndexOf": "последний индекс",
    "lastIndexOf": "последний индекс",
    "bitbybit.text.lastIndexOf_description": "Возвращает индекс последнего вхождения строки поиска. Пример: text='привет мир привет', search='привет' → 11",
    "bitbybit.text.substring": "подстрока",
    "substring": "подстрока",
    "bitbybit.text.substring_description": "Извлекает часть текста между двумя индексами. Пример: text='привет мир', start=0, end=6 → 'привет'",
    "bitbybit.text.slice": "срез",
    "bitbybit.text.slice_description": "Извлекает часть текста и возвращает новую строку. Пример: text='привет мир', start=0, end=6 → 'привет'",
    "bitbybit.text.charAt": "символ в",
    "charAt": "символ в",
    "bitbybit.text.charAt_description": "Возвращает символ по указанному индексу. Пример: text='привет', index=1 → 'р'",
    "bitbybit.text.trim": "обрезать пробелы",
    "bitbybit.text.trim_description": "Удаляет пробелы с обоих концов текста. Пример: text='  привет  ' → 'привет'",
    "bitbybit.text.trimStart": "обрезать пробелы в начале",
    "trimStart": "обрезать пробелы в начале",
    "bitbybit.text.trimStart_description": "Удаляет пробелы в начале текста. Пример: text='  привет  ' → 'привет  '",
    "bitbybit.text.trimEnd": "обрезать пробелы в конце",
    "trimEnd": "обрезать пробелы в конце",
    "bitbybit.text.trimEnd_description": "Удаляет пробелы в конце текста. Пример: text='  привет  ' → '  привет'",
    "bitbybit.text.padStart": "заполнить начало",
    "padStart": "заполнить начало",
    "bitbybit.text.padStart_description": "Заполняет текст с начала до достижения целевой длины. Пример: text='x', length=3, padString='a' → 'aax'",
    "padString": "строка заполнения",
    "bitbybit.text.padEnd": "заполнить конец",
    "padEnd": "заполнить конец",
    "bitbybit.text.padEnd_description": "Заполняет текст с конца до достижения целевой длины. Пример: text='x', length=3, padString='a' → 'xaa'",
    "bitbybit.text.toUpperCase": "в верхний регистр",
    "toUpperCase": "в верхний регистр",
    "bitbybit.text.toUpperCase_description": "Преобразует текст в верхний регистр. Пример: text='привет' → 'ПРИВЕТ'",
    "bitbybit.text.toLowerCase": "в нижний регистр",
    "toLowerCase": "в нижний регистр",
    "bitbybit.text.toLowerCase_description": "Преобразует текст в нижний регистр. Пример: text='ПРИВЕТ' → 'привет'",
    "bitbybit.text.toUpperCaseFirst": "первая буква заглавная",
    "toUpperCaseFirst": "первая буква заглавная",
    "bitbybit.text.toUpperCaseFirst_description": "Делает первый символ текста заглавным. Пример: text='привет мир' → 'Привет мир'",
    "bitbybit.text.toLowerCaseFirst": "первая буква строчная",
    "toLowerCaseFirst": "первая буква строчная",
    "bitbybit.text.toLowerCaseFirst_description": "Делает первый символ текста строчным. Пример: text='Привет Мир' → 'привет Мир'",
    "bitbybit.text.repeat": "повторить",
    "bitbybit.text.repeat_description": "Повторяет текст указанное количество раз. Пример: text='ха', count=3 → 'хахаха'",
    "bitbybit.text.reverse": "перевернуть",
    "bitbybit.text.reverse_description": "Переворачивает символы в тексте. Пример: text='привет' → 'тевирп'",
    "bitbybit.text.length": "длина",
    "bitbybit.text.length_description": "Возвращает длину текста. Пример: text='привет' → 6",
    "bitbybit.text.isEmpty": "пустой",
    "bitbybit.text.isEmpty_description": "Проверяет, является ли текст пустым или содержит только пробелы. Пример: text='   ' → true",
    "bitbybit.text.concat": "конкатенация",
    "concat": "конкатенация",
    "bitbybit.text.concat_description": "Объединяет несколько текстовых строк. Пример: texts=['привет', ' ', 'мир'] → 'привет мир'",
    "texts": "тексты",
    "bitbybit.text.regexTest": "regex тест",
    "regexTest": "regex тест",
    "bitbybit.text.regexTest_description": "Проверяет, соответствует ли текст шаблону регулярного выражения. Пример: text='hello123', pattern='[0-9]+' → true",
    "regex": "regex",
    "flags": "флаги",
    "bitbybit.text.regexMatch": "regex совпадение",
    "regexMatch": "regex совпадение",
    "bitbybit.text.regexMatch_description": "Сопоставляет текст с регулярным выражением и возвращает совпадения. Пример: text='hello123world456', pattern='[0-9]+', flags='g' → ['123', '456']",
    "bitbybit.text.regexReplace": "regex замена",
    "regexReplace": "regex замена",
    "bitbybit.text.regexReplace_description": "Заменяет текст, соответствующий шаблону регулярного выражения. Пример: text='hello123world456', pattern='[0-9]+', flags='g', replaceWith='X' → 'helloXworldX'",
    "bitbybit.text.regexSearch": "regex поиск",
    "regexSearch": "regex поиск",
    "bitbybit.text.regexSearch_description": "Ищет в тексте шаблон регулярного выражения и возвращает индекс. Пример: text='hello123', pattern='[0-9]+' → 5",
    "bitbybit.text.regexSplit": "regex разделение",
    "regexSplit": "regex разделение",
    "bitbybit.text.regexSplit_description": "Разделяет текст с использованием шаблона регулярного выражения. Пример: text='a1b2c3', pattern='[0-9]+' → ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "парсить в массив",
    "csv": "csv",
    "parseToArray": "парсить в массив",
    "bitbybit.csv.parseToArray_description": "Парсит текст CSV в двумерный массив строк (строки и столбцы). Пример: csv='a,b,c 1,2,3' → [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "разделитель строк",
    "columnSeparator": "разделитель столбцов",
    "bitbybit.csv.parseToJson": "парсить в json",
    "parseToJson": "парсить в json",
    "bitbybit.csv.parseToJson_description": "Парсит текст CSV в массив объектов JSON, используя заголовки. Пример: csv='name,age John,30 Jane,25', headerRow=0, dataStartRow=1 → [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headerRow": "строка заголовка",
    "dataStartRow": "строка начала данных",
    "numberColumns": "количество столбцов",
    "bitbybit.csv.parseToJsonWithHeaders": "парсить в json с заголовками",
    "parseToJsonWithHeaders": "парсить в json с заголовками",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Парсит текст CSV в JSON, используя пользовательские заголовки (игнорирует заголовки CSV, если они есть). Пример: csv='John,30 Jane,25', headers=['name','age'] → [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headers": "заголовки",
    "bitbybit.csv.queryColumn": "запросить столбец",
    "queryColumn": "запросить столбец",
    "bitbybit.csv.queryColumn_description": "Запрашивает данные CSV по имени заголовка столбца и возвращает все значения в этом столбце. Пример: csv='name,age John,30 Jane,25', column='name' → ['John', 'Jane']",
    "column": "столбец",
    "asNumber": "как число",
    "bitbybit.csv.queryRowsByValue": "запросить строки по значению",
    "queryRowsByValue": "запросить строки по значению",
    "bitbybit.csv.queryRowsByValue_description": "Запрашивает данные CSV и фильтрует строки, где столбец соответствует значению. Пример: csv='name,age John,30 Jane,25', column='age', value='30' → [{'name':'John','age':'30'}]",
    "bitbybit.csv.arrayToCsv": "массив в csv",
    "arrayToCsv": "массив в csv",
    "bitbybit.csv.arrayToCsv_description": "Преобразует двумерный массив в текст CSV. Пример: array=[['name','age'], ['John','30']] → 'name,age John,30'",
    "array": "массив",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "json в csv",
    "jsonToCsv": "json в csv",
    "bitbybit.csv.jsonToCsv_description": "Преобразует массив объектов JSON в текст CSV. Пример: json=[{'name':'John','age':'30'}], headers=['name','age'] → 'name,age John,30'",
    "includeHeaders": "включить заголовки",
    "bitbybit.csv.jsonToCsvAuto": "json в csv авто",
    "jsonToCsvAuto": "json в csv авто",
    "bitbybit.csv.jsonToCsvAuto_description": "Преобразует массив объектов JSON в текст CSV, используя ключи объекта в качестве заголовков. Пример: json=[{'name':'John','age':'30'}] → 'name,age John,30'",
    "bitbybit.csv.getHeaders": "получить заголовки",
    "getHeaders": "получить заголовки",
    "bitbybit.csv.getHeaders_description": "Получает заголовки из файла CSV. Пример: csv='name,age John,30', headerRow=0 → ['name', 'age']",
    "bitbybit.csv.getRowCount": "получить количество строк",
    "getRowCount": "получить количество строк",
    "bitbybit.csv.getRowCount_description": "Получает количество строк в файле CSV (исключая заголовки, если указано). Пример: csv='name,age John,30 Jane,25', headerRow=0 → 2",
    "hasHeaders": "имеет заголовки",
    "bitbybit.csv.getColumnCount": "получить количество столбцов",
    "getColumnCount": "получить количество столбцов",
    "bitbybit.csv.getColumnCount_description": "Получает количество столбцов в файле CSV. Пример: csv='name,age,city John,30,NYC' → 3",
    "removeTrailingZeros": "удалить замыкающие нули",
    "bitbybit.asset.getTextFile": "получить текстовый файл",
    "getTextFile": "получить текстовый файл",
    "bitbybit.asset.getTextFile_description": "Получает текст из файла ресурса, хранящегося в вашей облачной учетной записи.",
    "bitbybit.asset.getLocalTextFile": "получить локальный текстовый файл",
    "getLocalTextFile": "получить локальный текстовый файл",
    "bitbybit.asset.getLocalTextFile_description": "Получает текст из файла ресурса, хранящегося в вашем браузере.",
    "bitbybit.asset.download": "скачать",
    "bitbybit.asset.download_description": "Скачивает файл с заданным содержимым, расширением и типом содержимого.",
    "content": "содержимое",
    "string | Blob": "string | Blob",
    "extension": "расширение",
    "contentType": "тип содержимого",
    "preview csv": "предпросмотр csv",
    "startRow": "начальная строка",
    "maxRows": "максимальное количество строк",
    "colorMapStrategy": "стратегия цветовой карты",
    "Base.colorMapStrategyEnum": "Base.colorMapStrategyEnum",
    "drawTwoSided": "рисовать двусторонний",
    "backFaceColour": "цвет задней грани",
    "backFaceOpacity": "непрозрачность задней грани",
    "edgeArrowSize": "размер стрелки края",
    "edgeArrowAngle": "угол стрелки края",
    "bitbybit.draw.createTexture": "создать текстуру",
    "createTexture": "создать текстуру",
    "bitbybit.draw.createTexture_description": "Создает универсальную текстуру, которую можно использовать с материалами PBR. Этот метод обеспечивает кросс-движковый совместимый способ создания текстур.",
    "bitbybit.draw.createPBRMaterial": "создать pbr материал",
    "createPBRMaterial": "создать pbr материал",
    "bitbybit.draw.createPBRMaterial_description": "Создает универсальный материал PBR (физически корректный рендеринг). Этот метод обеспечивает кросс-движковый совместимый способ создания материалов, которые можно использовать с параметрами рисования для форм OCCT и другой геометрии.",
    "emissiveIntensity": "интенсивность излучения",
    "zOffsetUnits": "единицы смещения z",
    "baseColorTexture": "текстура базового цвета",
    "Base.Texture": "Base.Texture",
    "metallicRoughnessTexture": "текстура металлической шероховатости",
    "normalTexture": "нормальная текстура",
    "emissiveTexture": "излучающая текстура",
    "occlusionTexture": "текстура окклюзии",
    "alphaMode": "режим альфа",
    "alphaModeEnum": "перечисление режима альфа",
    "alphaCutoff": "отсечка альфа",
    "doubleSided": "двусторонний",
    "wireframe": "каркас",
    "unlit": "неосвещенный",
    "bitbybit.babylon.mesh.setLocalScale": "установить локальный масштаб",
    "setLocalScale": "установить локальный масштаб",
    "bitbybit.babylon.mesh.setLocalScale_description": "Масштабирует сетку BabylonJS или экземпляр сетки на месте с заданным коэффициентом",
    "transparencyShadow": "тень прозрачности",
    "bitbybit.manifold.crossSection.crossSectionFromPoints": "поперечное сечение из точек",
    "crossSectionFromPoints": "поперечное сечение из точек",
    "bitbybit.manifold.crossSection.crossSectionFromPoints_description": "Создает поперечное сечение из точек одного многоугольника",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons": "поперечное сечение из многоугольников",
    "crossSectionFromPolygons": "поперечное сечение из многоугольников",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons_description": "Создает поперечное сечение из точек нескольких многоугольников",
    "bitbybit.manifold.crossSection.crossSectionToPoints": "поперечное сечение в точки",
    "crossSectionToPoints": "поперечное сечение в точки",
    "bitbybit.manifold.crossSection.crossSectionToPoints_description": "Извлекает точки из поперечного сечения",
    "bitbybit.manifold.crossSection.crossSectionsToPoints": "поперечные сечения в точки",
    "crossSectionsToPoints": "поперечные сечения в точки",
    "bitbybit.manifold.crossSection.crossSectionsToPoints_description": "Извлекает точки из поперечных сечений",
    "bitbybit.previewCSV": "предпросмотр CSV"
}