{
    "bitbybit.draw.drawAnyAsyncNoReturn": "rysuj cokolwiek asynchronicznie bez zwracania",
    "bitbybit": "bitbybit",
    "draw": "rysuj",
    "drawAnyAsyncNoReturn": "rysuj cokolwiek asynchronicznie bez zwracania",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Rysuje dowolny rodzaj geometrii i nic nie zwraca",
    "draw async": "rysuj asynchronicznie",
    "entity": "obiekt",
    "Entity": "obiekt",
    "options": "opcje",
    "DrawOptions": "opcje rysowania",
    "babylonMesh": "siatka babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "siatka babylon lub siatka linii",
    "bitbybit.draw.drawAnyAsync": "rysuj cokolwiek asynchronicznie",
    "drawAnyAsync": "rysuj cokolwiek asynchronicznie",
    "bitbybit.draw.drawAnyAsync_description": "Rysuje dowolny rodzaj geometrii i zwraca siatkę babylon",
    "bitbybit.draw.drawAnyNoReturn": "rysuj cokolwiek bez zwracania",
    "drawAnyNoReturn": "rysuj cokolwiek bez zwracania",
    "bitbybit.draw.drawAnyNoReturn_description": "Rysuje dowolny rodzaj geometrii, który nie wymaga obliczeń asynchronicznych, więc nie może być używany z kształtami pochodzącymi z occt lub jscad",
    "draw sync": "rysuj synchronicznie",
    "bitbybit.draw.drawAny": "rysuj cokolwiek",
    "drawAny": "rysuj cokolwiek",
    "bitbybit.draw.drawAny_description": "Rysuje dowolny rodzaj geometrii, który nie wymaga obliczeń asynchronicznych, więc nie może być używany z kształtami pochodzącymi z occt lub jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "rysuj siatkę współrzędnych bez zwracania",
    "drawGridMeshNoReturn": "rysuj siatkę współrzędnych bez zwracania",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Rysuje siatkę współrzędnych na płaszczyźnie podłoża w przestrzeni 3D. Pomaga to zorientować się w świecie.",
    "grid": "siatka",
    "width": "szerokość",
    "number": "liczba",
    "height": "wysokość",
    "subdivisions": "podziały",
    "majorUnitFrequency": "częstotliwość głównych jednostek",
    "minorUnitVisibility": "widoczność mniejszych jednostek",
    "gridRatio": "proporcje siatki",
    "opacity": "przezroczystość",
    "backFaceCulling": "odrzucanie tylnych ścian",
    "boolean": "boolean",
    "mainColor": "główny kolor",
    "Base.Color": "kolor bazowy",
    "secondaryColor": "drugorzędny kolor",
    "bitbybit.draw.drawGridMesh": "rysuj siatkę współrzędnych",
    "drawGridMesh": "rysuj siatkę współrzędnych",
    "bitbybit.draw.drawGridMesh_description": "Rysuje siatkę współrzędnych na płaszczyźnie podłoża w przestrzeni 3D. Pomaga to zorientować się w świecie.",
    "bitbybit.draw.optionsSimple": "opcje proste",
    "optionsSimple": "opcje proste",
    "bitbybit.draw.optionsSimple_description": "Tworzy opcje rysowania dla podstawowych typów geometrii, takich jak punkty, linie, polilinie, powierzchnie i siatki jscad",
    "colours": "kolory",
    "string | string[]": "ciąg znaków lub tablica ciągów znaków",
    "size": "rozmiar",
    "updatable": "aktualizowalny",
    "hidden": "ukryty",
    "bitbybit.draw.optionsOcctShape": "opcje kształtu occt",
    "optionsOcctShape": "opcje kształtu occt",
    "bitbybit.draw.optionsOcctShape_description": "Tworzy opcje rysowania dla geometrii kształtów occt, takich jak krawędzie, kontury, ściany, powłoki, bryły i złożenia",
    "faceOpacity": "przezroczystość ściany",
    "edgeOpacity": "przezroczystość krawędzi",
    "edgeColour": "kolor krawędzi",
    "faceColour": "kolor ściany",
    "vertexColour": "kolor wierzchołka",
    "faceMaterial": "materiał ściany",
    "Base.Material": "materiał bazowy",
    "edgeWidth": "szerokość krawędzi",
    "vertexSize": "rozmiar wierzchołka",
    "drawEdges": "rysuj krawędzie",
    "drawFaces": "rysuj ściany",
    "drawVertices": "rysuj wierzchołki",
    "precision": "precyzja",
    "drawEdgeIndexes": "rysuj indeksy krawędzi",
    "edgeIndexHeight": "wysokość indeksu krawędzi",
    "edgeIndexColour": "kolor indeksu krawędzi",
    "drawFaceIndexes": "rysuj indeksy ścian",
    "faceIndexHeight": "wysokość indeksu ściany",
    "faceIndexColour": "kolor indeksu ściany",
    "bitbybit.draw.optionsOcctShapeSimple": "proste opcje kształtu occt",
    "optionsOcctShapeSimple": "proste opcje kształtu occt",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Tworzy proste opcje rysowania dla geometrii kształtu occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "opcje materiału kształtu occt",
    "optionsOcctShapeMaterial": "opcje materiału kształtu occt",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Tworzy proste opcje rysowania z niestandardowym materiałem ścian dla geometrii kształtu occt",
    "any": "dowolny",
    "bitbybit.draw.optionsManifoldShapeMaterial": "opcje materiału kształtu manifold",
    "optionsManifoldShapeMaterial": "opcje materiału kształtu manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Tworzy opcje rysowania dla geometrii typu manifold",
    "crossSectionColour": "kolor przekroju",
    "crossSectionWidth": "szerokość przekroju",
    "crossSectionOpacity": "przezroczystość przekroju",
    "computeNormals": "oblicz wektory normalne",
    "bitbybit.draw.optionsBabylonNode": "opcje węzła babylon",
    "optionsBabylonNode": "opcje węzła babylon",
    "bitbybit.draw.optionsBabylonNode_description": "Tworzy opcje rysowania dla węzłów babylon js",
    "colorX": "kolor x",
    "colorY": "kolor y",
    "colorZ": "kolor z",
    "bitbybit.babylon.mesh.dispose": "usuń siatkę",
    "babylon": "babylon",
    "mesh": "siatka",
    "dispose": "usuń",
    "bitbybit.babylon.mesh.dispose_description": "Usuwa narysowany obiekt siatki ze sceny",
    "memory": "pamięć",
    "BABYLON.Mesh": "siatka babylon",
    "bitbybit.babylon.mesh.updateDrawn": "aktualizuj narysowane",
    "updateDrawn": "aktualizuj narysowane",
    "bitbybit.babylon.mesh.updateDrawn_description": "Aktualizuje narysowany obiekt siatki BabylonJS bez usuwania go",
    "updates": "aktualizacje",
    "position": "pozycja",
    "Base.Point3": "punkt bazowy 3",
    "rotation": "obrót",
    "Base.Vector3": "wektor bazowy 3",
    "scaling": "skalowanie",
    "bitbybit.babylon.mesh.setVisibility": "ustaw widoczność",
    "setVisibility": "ustaw widoczność",
    "bitbybit.babylon.mesh.setVisibility_description": "Zmienia widoczność narysowanej siatki BabylonJS",
    "visibility": "widoczność",
    "includeChildren": "uwzględnij dzieci",
    "bitbybit.babylon.mesh.hide": "ukryj",
    "hide": "ukryj",
    "bitbybit.babylon.mesh.hide_description": "ukrywa siatkę",
    "bitbybit.babylon.mesh.show": "pokaż",
    "show": "pokaż",
    "bitbybit.babylon.mesh.show_description": "Pokazuje siatkę",
    "bitbybit.babylon.mesh.setParent": "ustaw rodzica",
    "setParent": "ustaw rodzica",
    "bitbybit.babylon.mesh.setParent_description": "Zmienia rodzica narysowanej siatki",
    "set": "ustaw",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "siatka babylon lub instancja siatki lub siatka abstrakcyjna",
    "parentMesh": "siatka nadrzędna",
    "bitbybit.babylon.mesh.getParent": "pobierz rodzica",
    "getParent": "pobierz rodzica",
    "bitbybit.babylon.mesh.getParent_description": "Pobiera rodzica narysowanej siatki",
    "get": "pobierz",
    "bitbybit.babylon.mesh.setCheckCollisions": "ustaw sprawdzanie kolizji",
    "setCheckCollisions": "ustaw sprawdzanie kolizji",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Zmienia właściwość sprawdzania kolizji narysowanej siatki",
    "checkCollisions": "sprawdzaj kolizje",
    "bitbybit.babylon.mesh.getCheckCollisions": "pobierz sprawdzanie kolizji",
    "getCheckCollisions": "pobierz sprawdzanie kolizji",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Pobiera właściwość sprawdzania kolizji narysowanej siatki",
    "bitbybit.babylon.mesh.setPickable": "ustaw wybieralność",
    "setPickable": "ustaw wybieralność",
    "bitbybit.babylon.mesh.setPickable_description": "Zmienia właściwość wybieralności (klikalności) narysowanej siatki",
    "pickable": "wybieralny",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "włącz zdarzenia ruchu wskaźnika",
    "enablePointerMoveEvents": "włącz zdarzenia ruchu wskaźnika",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Wymusza na siatce reagowanie na zdarzenia ruchu wskaźnika; domyślnie wyłączone, ponieważ obciąża wydajność",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "wyłącz zdarzenia ruchu wskaźnika",
    "disablePointerMoveEvents": "wyłącz zdarzenia ruchu wskaźnika",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Sprawia, że siatka ignoruje zdarzenia ruchu wskaźnika; domyślnie wyłączone",
    "bitbybit.babylon.mesh.getPickable": "pobierz wybieralność",
    "getPickable": "pobierz wybieralność",
    "bitbybit.babylon.mesh.getPickable_description": "Pobiera właściwość wybieralności narysowanej siatki",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "pobierz siatki, których nazwa zawiera",
    "getMeshesWhereNameContains": "pobierz siatki, których nazwa zawiera",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Pobiera siatki, których nazwy zawierają podany tekst",
    "name": "nazwa",
    "string": "ciąg znaków",
    "bitbybit.babylon.mesh.getChildMeshes": "pobierz siatki potomne",
    "getChildMeshes": "pobierz siatki potomne",
    "bitbybit.babylon.mesh.getChildMeshes_description": "pobiera siatki potomne",
    "directDescendantsOnly": "tylko bezpośredni potomkowie",
    "bitbybit.babylon.mesh.getMeshesOfId": "pobierz siatki o id",
    "getMeshesOfId": "pobierz siatki o id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Pobiera siatki o podanym id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "pobierz siatkę o id",
    "getMeshOfId": "pobierz siatkę o id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Pobiera siatkę o podanym id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "pobierz siatkę o unikalnym id",
    "getMeshOfUniqueId": "pobierz siatkę o unikalnym id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Pobiera siatkę o podanym unikalnym id",
    "uniqueId": "unikalne id",
    "bitbybit.babylon.mesh.mergeMeshes": "scal siatki",
    "mergeMeshes": "scal siatki",
    "bitbybit.babylon.mesh.mergeMeshes_description": "scala wiele siatek w jedną",
    "edit": "edytuj",
    "arrayOfMeshes": "tablica siatek",
    "BABYLON.Mesh[]": "tablica siatek babylon",
    "disposeSource": "usuń źródło",
    "allow32BitsIndices": "zezwól na indeksy 32-bitowe",
    "meshSubclass": "podklasa siatki",
    "subdivideWithSubMeshes": "podziel z pod-siatkami",
    "multiMultiMaterials": "wiele multi-materiałów",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "konwertuj na siatkę cieniowaną płasko",
    "convertToFlatShadedMesh": "konwertuj na siatkę cieniowaną płasko",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Konwertuje siatkę na siatkę cieniowaną płasko (flat shaded)",
    "bitbybit.babylon.mesh.clone": "sklonuj",
    "clone": "sklonuj",
    "bitbybit.babylon.mesh.clone_description": "klonuje siatkę",
    "bitbybit.babylon.mesh.cloneToPositions": "sklonuj do pozycji",
    "cloneToPositions": "sklonuj do pozycji",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Klonuje siatkę do podanych pozycji",
    "positions": "pozycje",
    "Base.Point3[]": "tablica punktów bazowych 3",
    "bitbybit.babylon.mesh.setId": "ustaw id",
    "setId": "ustaw id",
    "bitbybit.babylon.mesh.setId_description": "Zmienia id narysowanej siatki",
    "bitbybit.babylon.mesh.getId": "pobierz id",
    "getId": "pobierz id",
    "bitbybit.babylon.mesh.getId_description": "Pobiera id narysowanej siatki",
    "bitbybit.babylon.mesh.getUniqueId": "pobierz unikalne id",
    "getUniqueId": "pobierz unikalne id",
    "bitbybit.babylon.mesh.getUniqueId_description": "Pobiera unikalne id narysowanej siatki",
    "bitbybit.babylon.mesh.setName": "ustaw nazwę",
    "setName": "ustaw nazwę",
    "bitbybit.babylon.mesh.setName_description": "Zmienia nazwę narysowanej siatki",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "pobierz wierzchołki jako punkty wielokąta",
    "getVerticesAsPolygonPoints": "pobierz wierzchołki jako punkty wielokąta",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Pobiera wierzchołki jako punkty wielokąta. Można ich użyć z innymi metodami konstrukcyjnymi do tworzenia siatek. Siatka musi być trójkątna.",
    "bitbybit.babylon.mesh.getName": "pobierz nazwę",
    "getName": "pobierz nazwę",
    "bitbybit.babylon.mesh.getName_description": "Pobiera nazwę siatki babylon",
    "bitbybit.babylon.mesh.setMaterial": "ustaw materiał",
    "setMaterial": "ustaw materiał",
    "bitbybit.babylon.mesh.setMaterial_description": "Zmienia materiał narysowanej siatki",
    "material": "materiał",
    "BABYLON.Material": "materiał babylon",
    "bitbybit.babylon.mesh.getMaterial": "pobierz materiał",
    "getMaterial": "pobierz materiał",
    "bitbybit.babylon.mesh.getMaterial_description": "Pobiera materiał siatki babylon",
    "bitbybit.babylon.mesh.getPosition": "pobierz pozycję",
    "getPosition": "pobierz pozycję",
    "bitbybit.babylon.mesh.getPosition_description": "Pobiera pozycję siatki babylonjs jako punkt",
    "bitbybit.babylon.mesh.getAbsolutePosition": "pobierz pozycję absolutną",
    "getAbsolutePosition": "pobierz pozycję absolutną",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Pobiera absolutną pozycję w świecie jako punkt siatki babylonjs",
    "bitbybit.babylon.mesh.getRotation": "pobierz obrót",
    "getRotation": "pobierz obrót",
    "bitbybit.babylon.mesh.getRotation_description": "Pobiera wektor obrotu siatki babylonjs",
    "bitbybit.babylon.mesh.getScale": "pobierz skalę",
    "getScale": "pobierz skalę",
    "bitbybit.babylon.mesh.getScale_description": "Pobiera wektor skali siatki babylonjs",
    "bitbybit.babylon.mesh.moveForward": "przesuń do przodu",
    "moveForward": "przesuń do przodu",
    "bitbybit.babylon.mesh.moveForward_description": "Przesuwa siatkę babylonjs do przodu w przestrzeni lokalnej",
    "move": "przesuń",
    "distance": "dystans",
    "bitbybit.babylon.mesh.moveBackward": "przesuń do tyłu",
    "moveBackward": "przesuń do tyłu",
    "bitbybit.babylon.mesh.moveBackward_description": "Przesuwa siatkę babylonjs do tyłu w przestrzeni lokalnej",
    "bitbybit.babylon.mesh.moveUp": "przesuń w górę",
    "moveUp": "przesuń w górę",
    "bitbybit.babylon.mesh.moveUp_description": "Przesuwa siatkę babylonjs w górę w przestrzeni lokalnej",
    "bitbybit.babylon.mesh.moveDown": "przesuń w dół",
    "moveDown": "przesuń w dół",
    "bitbybit.babylon.mesh.moveDown_description": "Przesuwa siatkę babylonjs w dół w przestrzeni lokalnej",
    "bitbybit.babylon.mesh.moveRight": "przesuń w prawo",
    "moveRight": "przesuń w prawo",
    "bitbybit.babylon.mesh.moveRight_description": "Przesuwa siatkę babylonjs w prawo w przestrzeni lokalnej",
    "bitbybit.babylon.mesh.moveLeft": "przesuń w lewo",
    "moveLeft": "przesuń w lewo",
    "bitbybit.babylon.mesh.moveLeft_description": "Przesuwa siatkę babylonjs w lewo w przestrzeni lokalnej",
    "bitbybit.babylon.mesh.yaw": "odchylenie (yaw)",
    "yaw": "odchylenie",
    "bitbybit.babylon.mesh.yaw_description": "Obraca siatkę babylonjs wokół lokalnej osi y",
    "rotate": "obróć",
    "bitbybit.babylon.mesh.pitch": "pochylenie (pitch)",
    "pitch": "pochylenie",
    "bitbybit.babylon.mesh.pitch_description": "Obraca siatkę babylonjs wokół lokalnej osi x",
    "bitbybit.babylon.mesh.roll": "przechylenie (roll)",
    "roll": "przechylenie",
    "bitbybit.babylon.mesh.roll_description": "Obraca siatkę babylonjs wokół lokalnej osi z",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "obróć wokół osi z pozycją",
    "rotateAroundAxisWithPosition": "obróć wokół osi z pozycją",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Obraca siatkę wokół osi i danej pozycji o zadany kąt",
    "axis": "oś",
    "angle": "kąt",
    "bitbybit.babylon.mesh.setPosition": "ustaw pozycję",
    "setPosition": "ustaw pozycję",
    "bitbybit.babylon.mesh.setPosition_description": "Aktualizuje pozycję siatki lub instancji siatki BabylonJS",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "siatka babylon lub instancja siatki",
    "bitbybit.babylon.mesh.setRotation": "ustaw obrót",
    "setRotation": "ustaw obrót",
    "bitbybit.babylon.mesh.setRotation_description": "Aktualizuje obrót siatki lub instancji siatki BabylonJS",
    "bitbybit.babylon.mesh.setScale": "ustaw skalę",
    "setScale": "ustaw skalę",
    "bitbybit.babylon.mesh.setScale_description": "Aktualizuje skalę siatki lub instancji siatki BabylonJS",
    "scale": "skala",
    "bitbybit.babylon.mesh.intersectsMesh": "przecina siatkę",
    "intersectsMesh": "przecina siatkę",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Sprawdza, czy siatka przecina inną siatkę",
    "intersects": "przecina",
    "babylonMesh2": "siatka babylon 2",
    "precise": "precyzyjnie",
    "includeDescendants": "uwzględnij potomków",
    "bitbybit.babylon.mesh.intersectsPoint": "przecina punkt",
    "intersectsPoint": "przecina punkt",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Sprawdza, czy siatka przecina punkt",
    "point": "punkt",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instancja siatki i transformacja bez zwracania",
    "createMeshInstanceAndTransformNoReturn": "instancja siatki i transformacja bez zwracania",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Tworzy instancję siatki dla zoptymalizowanego renderowania. Ta metoda sprawdzi, czy siatka zawiera dzieci i utworzy instancje dla każdego dziecka. Są one zoptymalizowane pod kątem maksymalnej wydajności podczas renderowania wielu podobnych obiektów na scenie. Ta metoda zwraca instancje jako dzieci w nowej siatce. Jeśli siatka ma dzieci, każde dziecko staje się instancją siatki.",
    "instance": "instancja",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instancja siatki i transformacja",
    "createMeshInstanceAndTransform": "instancja siatki i transformacja",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Tworzy instancję siatki dla zoptymalizowanego renderowania. Ta metoda sprawdzi, czy siatka zawiera dzieci i utworzy instancje dla każdego dziecka. Są one zoptymalizowane pod kątem maksymalnej wydajności podczas renderowania wielu podobnych obiektów na scenie. Ta metoda zwraca instancje jako dzieci w nowej siatce. Jeśli siatka ma dzieci, każde dziecko staje się instancją siatki.",
    "bitbybit.babylon.mesh.createMeshInstance": "instancja siatki",
    "createMeshInstance": "instancja siatki",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Tworzy instancję siatki. Są one zoptymalizowane pod kątem maksymalnej wydajności podczas renderowania wielu podobnych obiektów na scenie. Jeśli siatka ma dzieci, każde dziecko otrzymuje instancję siatki.",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussowski",
    "gaussianSplatting": "splatting gaussowski",
    "create": "utwórz",
    "bitbybit.babylon.gaussianSplatting.create_description": "tworzy siatkę splattingu gaussowskiego",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "sklonuj splatting gaussowski",
    "bitbybit.babylon.gaussianSplatting.clone_description": "klonuje siatkę splattingu gaussowskiego",
    "multiply": "mnóż",
    "BABYLON.GaussianSplattingMesh": "siatka splattingu gaussowskiego babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "pobierz pozycje splatów",
    "getSplatPositions": "pobierz pozycje splatów",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Pobiera pozycje splatów z siatki gaussowskiej",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "zamroź macierz projekcji",
    "camera": "kamera",
    "freezeProjectionMatrix": "zamroź macierz projekcji",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Zamraża macierz projekcji kamery",
    "adjust": "dostosuj",
    "BABYLON.Camera": "kamera babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "odmroź macierz projekcji",
    "unfreezeProjectionMatrix": "odmroź macierz projekcji",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Odmraża macierz projekcji kamery",
    "bitbybit.babylon.camera.setPosition": "ustaw pozycję",
    "bitbybit.babylon.camera.setPosition_description": "Zmienia pozycję kamery",
    "BABYLON.TargetCamera": "kamera celownicza babylon",
    "bitbybit.babylon.camera.getPosition": "pobierz pozycję",
    "bitbybit.babylon.camera.getPosition_description": "Pobiera pozycję kamery",
    "bitbybit.babylon.camera.setTarget": "ustaw cel",
    "setTarget": "ustaw cel",
    "bitbybit.babylon.camera.setTarget_description": "Zmienia cel kamery",
    "target": "cel",
    "bitbybit.babylon.camera.getTarget": "pobierz cel",
    "getTarget": "pobierz cel",
    "bitbybit.babylon.camera.getTarget_description": "Pobiera cel kamery",
    "bitbybit.babylon.camera.setSpeed": "ustaw prędkość",
    "setSpeed": "ustaw prędkość",
    "bitbybit.babylon.camera.setSpeed_description": "Zmienia prędkość kamery",
    "speed": "prędkość",
    "bitbybit.babylon.camera.getSpeed": "pobierz prędkość",
    "getSpeed": "pobierz prędkość",
    "bitbybit.babylon.camera.getSpeed_description": "Pobiera prędkość kamery",
    "bitbybit.babylon.camera.setMinZ": "ustaw min z",
    "setMinZ": "ustaw min z",
    "bitbybit.babylon.camera.setMinZ_description": "Zmienia minZ kamery",
    "minZ": "min z",
    "bitbybit.babylon.camera.setMaxZ": "ustaw max z",
    "setMaxZ": "ustaw max z",
    "bitbybit.babylon.camera.setMaxZ_description": "Zmienia maxZ kamery",
    "maxZ": "max z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "ustaw kamerę na ortograficzną",
    "makeCameraOrthographic": "ustaw kamerę na ortograficzną",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Zmienia tryb kamery na ortograficzny",
    "orthoLeft": "ortho lewo",
    "orthoRight": "ortho prawo",
    "orthoBottom": "ortho dół",
    "orthoTop": "ortho góra",
    "bitbybit.babylon.camera.makeCameraPerspective": "ustaw kamerę na perspektywiczną",
    "makeCameraPerspective": "ustaw kamerę na perspektywiczną",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Zmienia tryb kamery na perspektywiczny",
    "bitbybit.babylon.camera.free.create": "kamera swobodna",
    "free": "swobodna",
    "bitbybit.babylon.camera.free.create_description": "Tworzy kamerę swobodną (free camera)",
    "bitbybit.babylon.camera.arcRotate.create": "kamera orbitalna",
    "arcRotate": "orbitalna (arc rotate)",
    "bitbybit.babylon.camera.arcRotate.create_description": "Tworzy kamerę, która obraca się wokół danego celu, podróżując po łuku. Ta kamera nadaje się do prostej nawigacji 3D i jest domyślną kamerą używaną przez bitbybit.",
    "radius": "promień",
    "alpha": "alfa",
    "beta": "beta",
    "lowerRadiusLimit": "dolny limit promienia",
    "upperRadiusLimit": "górny limit promienia",
    "lowerAlphaLimit": "dolny limit alfa",
    "upperAlphaLimit": "górny limit alfa",
    "lowerBetaLimit": "dolny limit beta",
    "upperBetaLimit": "górny limit beta",
    "angularSensibilityX": "czułość kątowa x",
    "angularSensibilityY": "czułość kątowa y",
    "panningSensibility": "czułość przesuwania",
    "wheelPrecision": "precyzja kółka",
    "bitbybit.babylon.camera.target.create": "kamera celownicza",
    "bitbybit.babylon.camera.target.create_description": "Tworzy kamerę celowniczą (target camera)",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "immersyjne doświadczenie ar",
    "webXr": "web xr",
    "simple": "proste",
    "createImmersiveARExperience": "immersyjne doświadczenie ar",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Tworzy domyślne doświadczenie XR w trybie immersive-ar",
    "scene": "scena",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "domyślne doświadczenie xr z teleportacją",
    "createDefaultXRExperienceWithTeleportation": "domyślne doświadczenie xr z teleportacją",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Tworzy domyślne doświadczenie XR z teleportacją, które jest bardzo podstawowe i działa w prostych scenariuszach",
    "groundMeshes": "siatki podłoża",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "zwróć domyślne doświadczenie xr z teleportacją",
    "createDefaultXRExperienceWithTeleportationReturn": "zwróć domyślne doświadczenie xr z teleportacją",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Tworzy domyślne doświadczenie XR z teleportacją, które jest bardzo podstawowe i działa w prostych scenariuszach",
    "bitbybit.babylon.node.drawNode": "rysuj węzeł",
    "node": "węzeł",
    "drawNode": "rysuj węzeł",
    "bitbybit.babylon.node.drawNode_description": "Rysuje węzeł o zadanym rozmiarze z podanymi kolorami dla każdej osi",
    "BABYLON.TransformNode": "węzeł transformacji babylon",
    "bitbybit.babylon.node.drawNodes": "rysuj węzły",
    "drawNodes": "rysuj węzły",
    "bitbybit.babylon.node.drawNodes_description": "Rysuje węzły o zadanym rozmiarze z podanymi kolorami dla każdej osi",
    "nodes": "węzły",
    "BABYLON.TransformNode[]": "tablica węzłów transformacji babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "węzeł z obrotu",
    "createNodeFromRotation": "węzeł z obrotu",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Tworzy węzeł w początku układu współrzędnych z zadanymi obrotami w układzie współrzędnych rodzica",
    "parent": "rodzic",
    "BABYLON.TransformNode | null": "węzeł transformacji babylon lub null",
    "origin": "początek układu",
    "bitbybit.babylon.node.createWorldNode": "węzeł świata",
    "createWorldNode": "węzeł świata",
    "bitbybit.babylon.node.createWorldNode_description": "Tworzy węzeł świata, którego rodzicem jest węzeł główny (root)",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "pobierz absolutny wektor do przodu",
    "getAbsoluteForwardVector": "pobierz absolutny wektor do przodu",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Pobiera absolutny wektor skierowany do przodu w przestrzeni świata",
    "bitbybit.babylon.node.getAbsoluteRightVector": "pobierz absolutny wektor w prawo",
    "getAbsoluteRightVector": "pobierz absolutny wektor w prawo",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Pobiera absolutny wektor skierowany w prawo w przestrzeni świata",
    "bitbybit.babylon.node.getAbsoluteUpVector": "pobierz absolutny wektor w górę",
    "getAbsoluteUpVector": "pobierz absolutny wektor w górę",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Pobiera absolutny wektor skierowany w górę w przestrzeni świata",
    "bitbybit.babylon.node.getAbsolutePosition": "pobierz pozycję absolutną",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Pobiera absolutną pozycję węzła jako wektor początku w przestrzeni świata",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "pobierz absolutną transformację obrotu",
    "getAbsoluteRotationTransformation": "pobierz absolutną transformację obrotu",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Pobiera absolutny obrót węzła jako macierz transformacji zakodowaną w tablicy 16 liczb",
    "bitbybit.babylon.node.getRotationTransformation": "pobierz transformację obrotu",
    "getRotationTransformation": "pobierz transformację obrotu",
    "bitbybit.babylon.node.getRotationTransformation_description": "Pobiera obrót węzła w lokalnej przestrzeni współrzędnych rodzica jako macierz transformacji zakodowaną w tablicy 16 liczb",
    "bitbybit.babylon.node.getChildren": "pobierz dzieci",
    "getChildren": "pobierz dzieci",
    "bitbybit.babylon.node.getChildren_description": "Pobiera dzieci węzła",
    "bitbybit.babylon.node.getParent": "pobierz rodzica",
    "bitbybit.babylon.node.getParent_description": "Pobiera rodzica węzła",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "pobierz pozycję w przestrzeni lokalnej",
    "getPositionExpressedInLocalSpace": "pobierz pozycję w przestrzeni lokalnej",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Pobiera pozycję węzła wyrażoną w przestrzeni lokalnej",
    "bitbybit.babylon.node.getRootNode": "pobierz węzeł główny",
    "getRootNode": "pobierz węzeł główny",
    "bitbybit.babylon.node.getRootNode_description": "Pobiera węzeł główny",
    "bitbybit.babylon.node.getRotation": "pobierz obrót",
    "bitbybit.babylon.node.getRotation_description": "Pobiera obroty Eulera",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "obróć wokół osi z pozycją",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Obraca węzeł wokół osi i danej pozycji o zadany kąt",
    "bitbybit.babylon.node.rotate": "obróć",
    "bitbybit.babylon.node.rotate_description": "Obraca węzeł wokół początku układu i danej osi",
    "bitbybit.babylon.node.setAbsolutePosition": "ustaw pozycję absolutną",
    "setAbsolutePosition": "ustaw pozycję absolutną",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Ustawia absolutną pozycję węzła",
    "bitbybit.babylon.node.setDirection": "ustaw kierunek",
    "setDirection": "ustaw kierunek",
    "bitbybit.babylon.node.setDirection_description": "Ustawia kierunek węzła",
    "direction": "kierunek",
    "number[]": "tablica liczb",
    "bitbybit.babylon.node.setParent": "ustaw rodzica",
    "bitbybit.babylon.node.setParent_description": "Ustawia nowego rodzica dla węzła",
    "parentNode": "węzeł nadrzędny",
    "bitbybit.babylon.node.translate": "przesuń",
    "translate": "przesuń",
    "bitbybit.babylon.node.translate_description": "Przesuwa węzeł o dany wektor kierunku i odległość",
    "bitbybit.babylon.scene.backgroundColour": "kolor tła",
    "backgroundColour": "kolor tła",
    "bitbybit.babylon.scene.backgroundColour_description": "Zmienia kolor tła sceny dla przestrzeni 3D",
    "environment": "środowisko",
    "colour": "kolor",
    "bitbybit.babylon.scene.activateCamera": "aktywuj kamerę",
    "activateCamera": "aktywuj kamerę",
    "bitbybit.babylon.scene.activateCamera_description": "Aktywuje kamerę, nadpisując aktualnie aktywną kamerę",
    "bitbybit.babylon.scene.useRightHandedSystem": "użyj układu prawoskrętnego",
    "useRightHandedSystem": "użyj układu prawoskrętnego",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Użyj prawoskrętnego układu współrzędnych",
    "system": "system",
    "use": "użyj",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "rysuj światło punktowe bez zwracania",
    "drawPointLightNoReturn": "rysuj światło punktowe bez zwracania",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Tworzy i rysuje światło punktowe na scenie, ale niczego nie zwraca",
    "lights": "światła",
    "intensity": "intensywność",
    "diffuse": "rozproszone",
    "specular": "odbłyskowe",
    "shadowGeneratorMapSize": "rozmiar mapy generatora cieni",
    "enableShadows": "włącz cienie",
    "shadowDarkness": "zaciemnienie cienia",
    "shadowUsePercentageCloserFiltering": "użyj filtrowania percentage closer dla cieni",
    "shadowContactHardeningLightSizeUVRatio": "stosunek rozmiaru światła uv dla utwardzania kontaktu cienia",
    "shadowBias": "przesunięcie cienia (bias)",
    "shadowNormalBias": "przesunięcie normalne cienia (normal bias)",
    "shadowMaxZ": "cień max z",
    "shadowMinZ": "cień min z",
    "bitbybit.babylon.scene.getShadowGenerators": "pobierz generatory cieni",
    "getShadowGenerators": "pobierz generatory cieni",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Pobiera generatory cieni dodane przez źródła światła przez bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "rysuj światło punktowe",
    "drawPointLight": "rysuj światło punktowe",
    "bitbybit.babylon.scene.drawPointLight_description": "Tworzy i rysuje światło punktowe na scenie",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "rysuj światło kierunkowe bez zwracania",
    "drawDirectionalLightNoReturn": "rysuj światło kierunkowe bez zwracania",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Tworzy i rysuje światło kierunkowe na scenie",
    "bitbybit.babylon.scene.drawDirectionalLight": "rysuj światło kierunkowe",
    "drawDirectionalLight": "rysuj światło kierunkowe",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Tworzy i rysuje światło kierunkowe na scenie",
    "bitbybit.babylon.scene.getActiveCamera": "pobierz aktywną kamerę",
    "getActiveCamera": "pobierz aktywną kamerę",
    "bitbybit.babylon.scene.getActiveCamera_description": "Pobiera aktywną kamerę sceny",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "dostosuj aktywną kamerę orbitalną",
    "adjustActiveArcRotateCamera": "dostosuj aktywną kamerę orbitalną",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Dostosowuje aktywną kamerę orbitalną za pomocą parametrów konfiguracyjnych",
    "lookAt": "patrz na",
    "bitbybit.babylon.scene.clearAllDrawn": "wyczyść wszystko narysowane",
    "clearAllDrawn": "wyczyść wszystko narysowane",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Czyści wszystkie narysowane obiekty na scenie 3D",
    "bitbybit.babylon.scene.enableSkybox": "włącz skybox",
    "enableSkybox": "włącz skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "Włącza skybox",
    "skybox": "skybox",
    "Base.skyboxEnum": "bazowy skybox enum",
    "blur": "rozmycie",
    "environmentIntensity": "intensywność środowiska",
    "bitbybit.babylon.scene.fog": "mgła",
    "fog": "mgła",
    "bitbybit.babylon.scene.fog_description": "Włącza tryb mgły",
    "mode": "tryb",
    "Base.fogModeEnum": "bazowy tryb mgły enum",
    "color": "kolor",
    "density": "gęstość",
    "start": "start",
    "end": "koniec",
    "bitbybit.babylon.transforms.rotationCenterAxis": "oś środka obrotu",
    "transforms": "transformacje",
    "rotationCenterAxis": "oś środka obrotu",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Tworzy transformację obrotu wokół środka i osi",
    "center": "środek",
    "bitbybit.babylon.transforms.rotationCenterX": "środek obrotu x",
    "rotationCenterX": "środek obrotu x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Tworzy transformację obrotu wokół środka i osi X",
    "bitbybit.babylon.transforms.rotationCenterY": "środek obrotu y",
    "rotationCenterY": "środek obrotu y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Tworzy transformację obrotu wokół środka i osi Y",
    "bitbybit.babylon.transforms.rotationCenterZ": "środek obrotu z",
    "rotationCenterZ": "środek obrotu z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Tworzy transformację obrotu wokół środka i osi Z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "środek obrotu yaw pitch roll",
    "rotationCenterYawPitchRoll": "środek obrotu yaw pitch roll",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Tworzy transformację obrotu z odchyleniem (yaw), pochyleniem (pitch) i przechyleniem (roll)",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "skala środek xyz",
    "scaleCenterXYZ": "skala środek xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Transformacja skalowania wokół środka i kierunków xyz",
    "scaleXyz": "skala xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "skala xyz",
    "scaleXYZ": "skala xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Tworzy transformację skalowania w kierunkach x, y i z",
    "bitbybit.babylon.transforms.uniformScale": "jednolite skalowanie",
    "uniformScale": "jednolite skalowanie",
    "bitbybit.babylon.transforms.uniformScale_description": "Tworzy transformację jednolitego skalowania",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "jednolite skalowanie od środka",
    "uniformScaleFromCenter": "jednolite skalowanie od środka",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Tworzy transformację jednolitego skalowania od środka",
    "bitbybit.babylon.transforms.translationXYZ": "przesunięcie xyz",
    "translationXYZ": "przesunięcie xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "Tworzy transformację przesunięcia",
    "translation": "przesunięcie",
    "bitbybit.babylon.transforms.translationsXYZ": "przesunięcia xyz",
    "translationsXYZ": "przesunięcia xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Tworzy transformację przesunięcia",
    "translations": "przesunięcia",
    "Base.Vector3[]": "tablica wektorów bazowych 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "załaduj zasób do sceny",
    "io": "io",
    "loadAssetIntoScene": "załaduj zasób do sceny",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Importuje siatkę z zasobu przesłanego dla projektu. Musisz przesłać swoje zasoby do projektu za pośrednictwem strony zarządzania projektem.",
    "load": "załaduj",
    "assetFile": "plik zasobu",
    "File": "plik",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "załaduj zasób do sceny bez zwracania",
    "loadAssetIntoSceneNoReturn": "załaduj zasób do sceny bez zwracania",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Importuje siatkę z zasobu przesłanego dla projektu. Musisz przesłać swoje zasoby do projektu za pośrednictwem strony zarządzania projektem.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "załaduj zasób do sceny z głównego url",
    "loadAssetIntoSceneFromRootUrl": "załaduj zasób do sceny z głównego url",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Importuje siatkę z adresu url zasobu, który został przesłany do dostępnego magazynu internetowego. Pamiętaj, że pliki muszą być publicznie dostępne, aby to zadziałało, upewnij się, że dostęp CORS jest włączony dla zasobów.",
    "rootUrl": "główny url",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "załaduj zasób do sceny z głównego url bez zwracania",
    "loadAssetIntoSceneFromRootUrlNoReturn": "załaduj zasób do sceny z głównego url bez zwracania",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Importuje siatkę z adresu url zasobu, który został przesłany do dostępnego magazynu internetowego. Pamiętaj, że pliki muszą być publicznie dostępne, aby to zadziałało, upewnij się, że dostęp CORS jest włączony dla zasobów.",
    "bitbybit.babylon.io.exportBabylon": "eksportuj babylon",
    "exportBabylon": "eksportuj babylon",
    "bitbybit.babylon.io.exportBabylon_description": "Eksportuje całą scenę do formatu sceny .babylon. Możesz ją następnie edytować w edytorach babylonjs.",
    "export": "eksportuj",
    "fileName": "nazwa pliku",
    "bitbybit.babylon.io.exportGLB": "eksportuj glb",
    "exportGLB": "eksportuj glb",
    "bitbybit.babylon.io.exportGLB_description": "Eksportuje całą scenę do formatu .glb. Ten format plików stał się standardem branżowym dla modeli internetowych.",
    "discardSkyboxAndGrid": "odrzuć skybox i siatkę",
    "bitbybit.babylon.io.exportMeshToStl": "eksportuj siatkę do stl",
    "exportMeshToStl": "eksportuj siatkę do stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "Eksportuje siatkę wraz z jej dziećmi do stl",
    "bitbybit.babylon.io.exportMeshesToStl": "eksportuj siatki do stl",
    "exportMeshesToStl": "eksportuj siatki do stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Eksportuje siatki do stl",
    "meshes": "siatki",
    "bitbybit.babylon.ray.createPickingRay": "promień wybierania",
    "ray": "promień",
    "createPickingRay": "promień wybierania",
    "bitbybit.babylon.ray.createPickingRay_description": "Tworzy promień wybierania aktualnej pozycji myszy w aktywnej kamerze",
    "bitbybit.babylon.ray.createRay": "promień",
    "createRay": "promień",
    "bitbybit.babylon.ray.createRay_description": "Tworzy promień, który zaczyna się w początku, ma wektor kierunku i opcjonalnie długość",
    "length": "długość",
    "bitbybit.babylon.ray.createRayFromTo": "promień od do",
    "createRayFromTo": "promień od do",
    "bitbybit.babylon.ray.createRayFromTo_description": "Tworzy promień od jednego punktu do drugiego",
    "from": "od",
    "to": "do",
    "bitbybit.babylon.ray.getOrigin": "pobierz początek",
    "getOrigin": "pobierz początek",
    "bitbybit.babylon.ray.getOrigin_description": "Pobiera początek promienia",
    "BABYLON.Ray": "promień babylon",
    "bitbybit.babylon.ray.getDirection": "pobierz kierunek",
    "getDirection": "pobierz kierunek",
    "bitbybit.babylon.ray.getDirection_description": "Pobiera kierunek promienia",
    "bitbybit.babylon.ray.getLength": "pobierz długość",
    "getLength": "pobierz długość",
    "bitbybit.babylon.ray.getLength_description": "Pobiera długość promienia",
    "bitbybit.babylon.pick.pickWithRay": "wybierz promieniem",
    "pick": "wybierz",
    "pickWithRay": "wybierz promieniem",
    "bitbybit.babylon.pick.pickWithRay_description": "Pobiera wynik trafienia wybierania promieniem",
    "bitbybit.babylon.pick.pickWithPickingRay": "wybierz promieniem wybierania",
    "pickWithPickingRay": "wybierz promieniem wybierania",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Wybiera promieniem wybierania aktualnej pozycji myszy w aktywnej kamerze",
    "bitbybit.babylon.pick.getDistance": "pobierz dystans",
    "getDistance": "pobierz dystans",
    "bitbybit.babylon.pick.getDistance_description": "Pobiera odległość do obiektu, jeśli wynik wybierania istnieje",
    "get from pick info": "pobierz z informacji o wyborze",
    "pickInfo": "informacje o wyborze",
    "BABYLON.PickingInfo": "informacje o wyborze babylon",
    "bitbybit.babylon.pick.getPickedMesh": "pobierz wybraną siatkę",
    "getPickedMesh": "pobierz wybraną siatkę",
    "bitbybit.babylon.pick.getPickedMesh_description": "Pobiera wybraną siatkę",
    "bitbybit.babylon.pick.getPickedPoint": "pobierz wybrany punkt",
    "getPickedPoint": "pobierz wybrany punkt",
    "bitbybit.babylon.pick.getPickedPoint_description": "Pobiera wybrany punkt",
    "bitbybit.babylon.pick.hit": "trafienie",
    "hit": "trafienie",
    "bitbybit.babylon.pick.hit_description": "Sprawdza, czy promień wybierania trafił w coś na scenie",
    "bitbybit.babylon.pick.getSubMeshId": "pobierz id pod-siatki",
    "getSubMeshId": "pobierz id pod-siatki",
    "bitbybit.babylon.pick.getSubMeshId_description": "Pobiera unikalne id pod-siatki, jeśli została wybrana",
    "bitbybit.babylon.pick.getSubMeshFaceId": "pobierz id ściany pod-siatki",
    "getSubMeshFaceId": "pobierz id ściany pod-siatki",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Pobiera unikalne id ściany pod-siatki, jeśli została wybrana",
    "bitbybit.babylon.pick.getBU": "pobierz bu",
    "getBU": "pobierz bu",
    "bitbybit.babylon.pick.getBU_description": "Pobiera współrzędną barycentryczną U, która jest używana przy obliczaniu współrzędnych tekstury kolizji",
    "bitbybit.babylon.pick.getBV": "pobierz bv",
    "getBV": "pobierz bv",
    "bitbybit.babylon.pick.getBV_description": "Pobiera współrzędną barycentryczną V, która jest używana przy obliczaniu współrzędnych tekstury kolizji",
    "bitbybit.babylon.pick.getPickedSprite": "pobierz wybrany sprite",
    "getPickedSprite": "pobierz wybrany sprite",
    "bitbybit.babylon.pick.getPickedSprite_description": "Pobiera wybrany sprite",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "szorstkość metaliczna pbr",
    "pbrMetallicRoughness": "szorstkość metaliczna pbr",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Tworzy materiał PBR o szorstkości metalicznej.",
    "baseColor": "kolor bazowy",
    "emissiveColor": "kolor emisyjny",
    "metallic": "metaliczność",
    "roughness": "szorstkość",
    "zOffset": "przesunięcie z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "ustaw kolor bazowy",
    "setBaseColor": "ustaw kolor bazowy",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Ustawia kolor bazowy materiału",
    "BABYLON.PBRMetallicRoughnessMaterial": "materiał szorstkości metalicznej pbr babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "ustaw metaliczność",
    "setMetallic": "ustaw metaliczność",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Ustawia właściwość metaliczności materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "ustaw szorstkość",
    "setRoughness": "ustaw szorstkość",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Ustawia szorstkość materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "ustaw alfa",
    "setAlpha": "ustaw alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Ustawia alfa materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "ustaw odrzucanie tylnych ścian",
    "setBackFaceCulling": "ustaw odrzucanie tylnych ścian",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Ustawia odrzucanie tylnych ścian materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "ustaw teksturę bazową",
    "setBaseTexture": "ustaw teksturę bazową",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Ustawia teksturę materiału",
    "baseTexture": "tekstura bazowa",
    "BABYLON.Texture": "tekstura babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "pobierz kolor bazowy",
    "getBaseColor": "pobierz kolor bazowy",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Pobiera kolor bazowy materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "pobierz metaliczność",
    "getMetallic": "pobierz metaliczność",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Pobiera właściwość metaliczności materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "pobierz szorstkość",
    "getRoughness": "pobierz szorstkość",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Pobiera szorstkość materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "pobierz alfa",
    "getAlpha": "pobierz alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Pobiera alfa materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "pobierz odrzucanie tylnych ścian",
    "getBackFaceCulling": "pobierz odrzucanie tylnych ścian",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Pobiera odrzucanie tylnych ścian materiału",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "pobierz teksturę bazową",
    "getBaseTexture": "pobierz teksturę bazową",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Pobiera teksturę bazową materiału",
    "bitbybit.babylon.material.skyMaterial.create": "materiał nieba",
    "skyMaterial": "materiał nieba",
    "bitbybit.babylon.material.skyMaterial.create_description": "Tworzy materiał nieba",
    "luminance": "luminancja",
    "turbidity": "mętność",
    "rayleigh": "rayleigh",
    "mieCoefficient": "współczynnik mie",
    "mieDirectionalG": "kierunkowość mie g",
    "inclination": "nachylenie",
    "azimuth": "azymut",
    "sunPosition": "pozycja słońca",
    "useSunPosition": "użyj pozycji słońca",
    "cameraOffset": "przesunięcie kamery",
    "up": "góra",
    "dithering": "dithering",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "ustaw luminancję",
    "setLuminance": "ustaw luminancję",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Ustawia luminancję materiału nieba",
    "MATERIALS.SkyMaterial": "materiały materiał nieba",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "ustaw mętność",
    "setTurbidity": "ustaw mętność",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Ustawia mętność materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "ustaw rayleigh",
    "setRayleigh": "ustaw rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Ustawia rayleigh materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "ustaw współczynnik mie",
    "setMieCoefficient": "ustaw współczynnik mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Ustawia współczynnik mie materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "ustaw kierunkowość mie g",
    "setMieDirectionalG": "ustaw kierunkowość mie g",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Ustawia kierunkowość mie g materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setDistance": "ustaw dystans",
    "setDistance": "ustaw dystans",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Ustawia dystans materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setInclination": "ustaw nachylenie",
    "setInclination": "ustaw nachylenie",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Ustawia nachylenie materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "ustaw azymut",
    "setAzimuth": "ustaw azymut",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Ustawia azymut materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "ustaw pozycję słońca",
    "setSunPosition": "ustaw pozycję słońca",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Ustawia pozycję słońca materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "ustaw użycie pozycji słońca",
    "setUseSunPosition": "ustaw użycie pozycji słońca",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Ustawia użycie pozycji słońca materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "ustaw przesunięcie kamery",
    "setCameraOffset": "ustaw przesunięcie kamery",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Ustawia przesunięcie kamery materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setUp": "ustaw górę",
    "setUp": "ustaw górę",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Ustawia górę materiału nieba",
    "bitbybit.babylon.material.skyMaterial.setDithering": "ustaw dithering",
    "setDithering": "ustaw dithering",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Ustawia dithering materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "pobierz luminancję",
    "getLuminance": "pobierz luminancję",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Pobiera luminancję materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "pobierz mętność",
    "getTurbidity": "pobierz mętność",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Pobiera mętność materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "pobierz rayleigh",
    "getRayleigh": "pobierz rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Pobiera rayleigh materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "pobierz współczynnik mie",
    "getMieCoefficient": "pobierz współczynnik mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Pobiera współczynnik mie materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "pobierz kierunkowość mie g",
    "getMieDirectionalG": "pobierz kierunkowość mie g",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Pobiera kierunkowość mie g materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getDistance": "pobierz dystans",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Pobiera dystans materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getInclination": "pobierz nachylenie",
    "getInclination": "pobierz nachylenie",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Pobiera nachylenie materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "pobierz azymut",
    "getAzimuth": "pobierz azymut",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Pobiera azymut materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "pobierz pozycję słońca",
    "getSunPosition": "pobierz pozycję słońca",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Pobiera pozycję słońca materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "pobierz użycie pozycji słońca",
    "getUseSunPosition": "pobierz użycie pozycji słońca",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Pobiera użycie pozycji słońca materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "pobierz przesunięcie kamery",
    "getCameraOffset": "pobierz przesunięcie kamery",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Pobiera przesunięcie kamery materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getUp": "pobierz górę",
    "getUp": "pobierz górę",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Pobiera górę materiału nieba",
    "bitbybit.babylon.material.skyMaterial.getDithering": "pobierz dithering",
    "getDithering": "pobierz dithering",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Pobiera dithering materiału nieba",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "ustaw kierunek do celu",
    "shadowLight": "światło cienia",
    "setDirectionToTarget": "ustaw kierunek do celu",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Ustawia kierunek światła cienia",
    "BABYLON.ShadowLight": "światło cienia babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "ustaw pozycję",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Ustawia pozycję światła cienia",
    "bitbybit.babylon.meshBuilder.createBox": "pudełko",
    "meshBuilder": "generator siatek",
    "createBox": "pudełko",
    "bitbybit.babylon.meshBuilder.createBox_description": "Tworzy siatkę pudełka (box)",
    "create simple": "utwórz proste",
    "depth": "głębokość",
    "sideOrientation": "orientacja boczna",
    "BabylonMesh.sideOrientationEnum": "orientacja boczna siatki babylon enum",
    "bitbybit.babylon.meshBuilder.createCube": "sześcian",
    "createCube": "sześcian",
    "bitbybit.babylon.meshBuilder.createCube_description": "Tworzy siatkę sześcianu",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "płaszczyzna kwadratowa",
    "createSquarePlane": "płaszczyzna kwadratowa",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Tworzy siatkę płaszczyzny kwadratowej",
    "bitbybit.babylon.meshBuilder.createSphere": "kula",
    "createSphere": "kula",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Tworzy siatkę kuli",
    "diameter": "średnica",
    "segments": "segmenty",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "icosphere",
    "createIcoSphere": "icosphere",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Tworzy icosphere (kulę ikosaedryczną)",
    "radiusX": "promień x",
    "radiusY": "promień y",
    "radiusZ": "promień z",
    "flat": "płaski",
    "bitbybit.babylon.meshBuilder.createDisc": "dysk",
    "createDisc": "dysk",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Tworzy dysk",
    "tessellation": "teselacja",
    "arc": "łuk",
    "bitbybit.babylon.meshBuilder.createTorus": "torus",
    "createTorus": "torus",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Tworzy siatkę torusa",
    "thickness": "grubość",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "węzeł torusa",
    "createTorusKnot": "węzeł torusa",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Tworzy siatkę węzła torusa",
    "tube": "rura",
    "radialSegments": "segmenty radialne",
    "tubularSegments": "segmenty rurki",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "wielokąt",
    "createPolygon": "wielokąt",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Tworzy siatkę wielokąta",
    "shape": "kształt",
    "holes": "otwory",
    "Base.Vector3[][]": "tablica tablic wektorów bazowych 3",
    "smoothingThreshold": "próg wygładzania",
    "wrap": "zawijanie",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "wyciągnij wielokąt",
    "extrudePolygon": "wyciągnij wielokąt",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Tworzy siatkę wyciągniętego wielokąta",
    "bitbybit.babylon.meshBuilder.createTube": "rura",
    "createTube": "rura",
    "bitbybit.babylon.meshBuilder.createTube_description": "Tworzy siatkę rury",
    "path": "ścieżka",
    "cap": "zatyczka",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "wielościan",
    "createPolyhedron": "wielościan",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Tworzy siatkę wielościanu",
    "type": "typ",
    "sizeX": "rozmiar x",
    "sizeY": "rozmiar y",
    "sizeZ": "rozmiar z",
    "custom": "niestandardowy",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodezyjna",
    "createGeodesic": "geodezyjna",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Tworzy siatkę geodezyjną",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Tworzy siatkę goldberga",
    "bitbybit.babylon.meshBuilder.createCapsule": "kapsuła",
    "createCapsule": "kapsuła",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Tworzy siatkę kapsuły",
    "orientation": "orientacja",
    "capSubdivisions": "podziały zatyczki",
    "radiusTop": "promień góra",
    "radiusBottom": "promień dół",
    "topCapSubdivisions": "podziały górnej zatyczki",
    "bottomCapSubdivisions": "podziały dolnej zatyczki",
    "bitbybit.babylon.meshBuilder.createCylinder": "walec",
    "createCylinder": "walec",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Tworzy siatkę walca",
    "diameterTop": "średnica góra",
    "diameterBottom": "średnica dół",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "kształt wyciągnięty",
    "createExtrudedSahpe": "kształt wyciągnięty",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Tworzy kształt wyciągnięty",
    "closeShape": "zamknij kształt",
    "closePath": "zamknij ścieżkę",
    "bitbybit.babylon.meshBuilder.createRibbon": "wstęga",
    "createRibbon": "wstęga",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Tworzy siatkę wstęgi",
    "pathArray": "tablica ścieżek",
    "closeArray": "zamknij tablicę",
    "offset": "offset",
    "bitbybit.babylon.meshBuilder.createLathe": "bryła obrotowa",
    "createLathe": "bryła obrotowa",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Tworzy siatkę bryły obrotowej (lathe)",
    "closed": "zamknięty",
    "bitbybit.babylon.meshBuilder.createGround": "podłoże",
    "createGround": "podłoże",
    "bitbybit.babylon.meshBuilder.createGround_description": "Tworzy siatkę podłoża",
    "subdivisionsX": "podziały x",
    "subdivisionsY": "podziały y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "płaszczyzna prostokątna",
    "createRectanglePlane": "płaszczyzna prostokątna",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Tworzy siatkę płaszczyzny prostokątnej",
    "bitbybit.babylon.texture.createSimple": "prosta tekstura",
    "texture": "tekstura",
    "createSimple": "prosta",
    "bitbybit.babylon.texture.createSimple_description": "Tworzy teksturę z adresu URL na podstawie kilku podstawowych opcji. Jeśli załadowałeś zasób przez plik, utwórz obiekt url i przekaż go tutaj.",
    "invertY": "odwróć y",
    "invertZ": "odwróć z",
    "wAng": "kąt w",
    "uScale": "skala u",
    "vScale": "skala v",
    "uOffset": "offset u",
    "vOffset": "offset v",
    "samplingMode": "tryb próbkowania",
    "samplingModeEnum": "tryb próbkowania enum",
    "bitbybit.babylon.tools.createScreenshot": "zrzut ekranu",
    "tools": "narzędzia",
    "createScreenshot": "zrzut ekranu",
    "bitbybit.babylon.tools.createScreenshot_description": "Tworzy zrzut ekranu sceny",
    "screenshots": "zrzuty ekranu",
    "mimeType": "typ mime",
    "quality": "jakość",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "zrzut ekranu i pobieranie",
    "createScreenshotAndDownload": "zrzut ekranu i pobieranie",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Tworzy zrzut ekranu sceny i pobiera plik",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interfejs pełnoekranowy",
    "gui": "gui",
    "advancedDynamicTexture": "zaawansowana dynamiczna tekstura",
    "createFullScreenUI": "interfejs pełnoekranowy",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "tworzy interfejs użytkownika na pełnym ekranie",
    "spaces": "przestrzenie",
    "foreground": "pierwszy plan",
    "adaptiveScaling": "skalowanie adaptacyjne",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "dla siatki",
    "createForMesh": "dla siatki",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Tworzy zaawansowaną dynamiczną teksturę dla siatki",
    "BABYLON.AbstractMesh": "abstrakcyjna siatka babylon",
    "supportPointerMove": "obsługa ruchu wskaźnika",
    "onlyAlphaTesting": "tylko testowanie alfa",
    "sampling": "próbkowanie",
    "BabylonTexture.samplingModeEnum": "tryb próbkowania tekstury babylon enum",
    "bitbybit.babylon.gui.control.changeControlPadding": "zmień padding kontrolki",
    "control": "kontrolka",
    "changeControlPadding": "zmień padding kontrolki",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Zmienia padding dla kontrolki",
    "positioning": "pozycjonowanie",
    "BABYLON.GUI.Control": "kontrolka gui babylon",
    "paddingLeft": "padding lewy",
    "number | string": "liczba lub ciąg znaków",
    "paddingRight": "padding prawy",
    "paddingTop": "padding górny",
    "paddingBottom": "padding dolny",
    "bitbybit.babylon.gui.control.changeControlAlignment": "zmień wyrównanie kontrolki",
    "changeControlAlignment": "zmień wyrównanie kontrolki",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Zmienia wyrównanie dla kontrolki",
    "T": "t",
    "horizontalAlignment": "wyrównanie poziome",
    "horizontalAlignmentEnum": "wyrównanie poziome enum",
    "verticalAlignment": "wyrównanie pionowe",
    "verticalAlignmentEnum": "wyrównanie pionowe enum",
    "bitbybit.babylon.gui.control.cloneControl": "sklonuj kontrolkę",
    "cloneControl": "sklonuj kontrolkę",
    "bitbybit.babylon.gui.control.cloneControl_description": "Klonuje kontrolkę",
    "container": "kontener",
    "BABYLON.GUI.Container": "kontener gui babylon",
    "host": "host",
    "BABYLON.GUI.AdvancedDynamicTexture": "zaawansowana dynamiczna tekstura gui babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "selektor obserwowalny kontrolki",
    "createControlObservableSelector": "selektor obserwowalny kontrolki",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Tworzy selektor obserwowalny dla kontrolki",
    "selector": "selektor",
    "controlObservableSelectorEnum": "selektor obserwowalny kontrolki enum",
    "bitbybit.babylon.gui.control.getControlByName": "pobierz kontrolkę po nazwie",
    "getControlByName": "pobierz kontrolkę po nazwie",
    "bitbybit.babylon.gui.control.getControlByName_description": "Pobiera kontrolkę po nazwie",
    "bitbybit.babylon.gui.control.setIsVisible": "ustaw czy widoczne",
    "setIsVisible": "ustaw czy widoczne",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Ustawia, czy kontrolka jest widoczna",
    "isVisible": "jest widoczne",
    "bitbybit.babylon.gui.control.setIsReadonly": "ustaw czy tylko do odczytu",
    "setIsReadonly": "ustaw czy tylko do odczytu",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Ustawia, czy kontrolka jest tylko do odczytu",
    "isReadOnly": "jest tylko do odczytu",
    "bitbybit.babylon.gui.control.setIsEnabled": "ustaw czy włączone",
    "setIsEnabled": "ustaw czy włączone",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Ustawia, czy kontrolka jest włączona",
    "isEnabled": "jest włączone",
    "bitbybit.babylon.gui.control.setHeight": "ustaw wysokość",
    "setHeight": "ustaw wysokość",
    "bitbybit.babylon.gui.control.setHeight_description": "Ustawia wysokość kontrolki",
    "bitbybit.babylon.gui.control.setWidth": "ustaw szerokość",
    "setWidth": "ustaw szerokość",
    "bitbybit.babylon.gui.control.setWidth_description": "Ustawia szerokość kontrolki",
    "bitbybit.babylon.gui.control.setColor": "ustaw kolor",
    "setColor": "ustaw kolor",
    "bitbybit.babylon.gui.control.setColor_description": "Ustawia kolor kontrolki",
    "bitbybit.babylon.gui.control.setFontSize": "ustaw rozmiar czcionki",
    "setFontSize": "ustaw rozmiar czcionki",
    "bitbybit.babylon.gui.control.setFontSize_description": "Ustawia rozmiar czcionki",
    "fontSize": "rozmiar czcionki",
    "bitbybit.babylon.gui.control.getHeight": "pobierz wysokość",
    "getHeight": "pobierz wysokość",
    "bitbybit.babylon.gui.control.getHeight_description": "Pobiera wysokość",
    "bitbybit.babylon.gui.control.getWidth": "pobierz szerokość",
    "getWidth": "pobierz szerokość",
    "bitbybit.babylon.gui.control.getWidth_description": "Pobiera szerokość",
    "bitbybit.babylon.gui.control.getColor": "pobierz kolor",
    "getColor": "pobierz kolor",
    "bitbybit.babylon.gui.control.getColor_description": "Pobiera kolor",
    "bitbybit.babylon.gui.control.getFontSize": "pobierz rozmiar czcionki",
    "getFontSize": "pobierz rozmiar czcionki",
    "bitbybit.babylon.gui.control.getFontSize_description": "Pobiera rozmiar czcionki kontrolki",
    "bitbybit.babylon.gui.control.getIsVisible": "pobierz czy widoczne",
    "getIsVisible": "pobierz czy widoczne",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Pobiera informację, czy kontrolka jest widoczna",
    "bitbybit.babylon.gui.control.getIsReadonly": "pobierz czy tylko do odczytu",
    "getIsReadonly": "pobierz czy tylko do odczytu",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Pobiera informację, czy kontrolka jest tylko do odczytu",
    "bitbybit.babylon.gui.control.getIsEnabled": "pobierz czy włączone",
    "getIsEnabled": "pobierz czy włączone",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Pobiera informację, czy kontrolka jest włączona",
    "bitbybit.babylon.gui.container.addControls": "dodaj kontrolki",
    "addControls": "dodaj kontrolki",
    "bitbybit.babylon.gui.container.addControls_description": "Dodaje kontrolki do kontenera i zachowuje kolejność",
    "controls": "kontrolki",
    "BABYLON.GUI.Control[]": "tablica kontrolek gui babylon",
    "clearControlsFirst": "najpierw wyczyść kontrolki",
    "bitbybit.babylon.gui.container.setBackground": "ustaw tło",
    "setBackground": "ustaw tło",
    "bitbybit.babylon.gui.container.setBackground_description": "Ustawia tło kontenera",
    "background": "tło",
    "bitbybit.babylon.gui.container.setIsReadonly": "ustaw czy tylko do odczytu",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Ustawia, czy kontener jest tylko do odczytu",
    "bitbybit.babylon.gui.container.getBackground": "pobierz tło",
    "getBackground": "pobierz tło",
    "bitbybit.babylon.gui.container.getBackground_description": "Pobiera tło kontenera",
    "bitbybit.babylon.gui.container.getIsReadonly": "pobierz czy tylko do odczytu",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Pobiera informację, czy kontener jest tylko do odczytu",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "panel stosu",
    "stackPanel": "panel stosu",
    "createStackPanel": "panel stosu",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "tworzy panel stosu (stack panel)",
    "isVertical": "jest pionowy",
    "spacing": "odstęp",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "ustaw czy pionowy",
    "setIsVertical": "ustaw czy pionowy",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Ustawia, czy panel stosu jest pionowy",
    "BABYLON.GUI.StackPanel": "panel stosu gui babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "ustaw odstęp",
    "setSpacing": "ustaw odstęp",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Ustawia odstęp panelu stosu",
    "bitbybit.babylon.gui.stackPanel.setWidth": "ustaw szerokość",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Ustawia szerokość panelu stosu",
    "bitbybit.babylon.gui.stackPanel.setHeight": "ustaw wysokość",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Ustawia wysokość panelu stosu",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "pobierz czy pionowy",
    "getIsVertical": "pobierz czy pionowy",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Pobiera informację, czy panel stosu jest pionowy",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "pobierz odstęp",
    "getSpacing": "pobierz odstęp",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Pobiera odstęp panelu stosu",
    "bitbybit.babylon.gui.stackPanel.getWidth": "pobierz szerokość",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Pobiera szerokość panelu stosu",
    "bitbybit.babylon.gui.stackPanel.getHeight": "pobierz wysokość",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Pobiera wysokość panelu stosu",
    "bitbybit.babylon.gui.button.createSimpleButton": "prosty przycisk",
    "button": "przycisk",
    "createSimpleButton": "prosty przycisk",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "tworzy prosty przycisk",
    "label": "etykieta",
    "bitbybit.babylon.gui.button.setButtonText": "ustaw tekst przycisku",
    "setButtonText": "ustaw tekst przycisku",
    "bitbybit.babylon.gui.button.setButtonText_description": "Ustawia tekst przycisku",
    "BABYLON.GUI.Button": "przycisk gui babylon",
    "text": "tekst",
    "bitbybit.babylon.gui.button.getButtonText": "pobierz tekst przycisku",
    "getButtonText": "pobierz tekst przycisku",
    "bitbybit.babylon.gui.button.getButtonText_description": "Pobiera tekst przycisku",
    "bitbybit.babylon.gui.slider.createSlider": "suwak",
    "slider": "suwak",
    "createSlider": "suwak",
    "bitbybit.babylon.gui.slider.createSlider_description": "tworzy suwak",
    "minimum": "minimum",
    "maximum": "maksimum",
    "value": "wartość",
    "step": "krok",
    "displayThumb": "wyświetl uchwyt",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "zmień uchwyt suwaka",
    "changeSliderThumb": "zmień uchwyt suwaka",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "zmienia właściwości uchwytu suwaka",
    "BABYLON.GUI.Slider": "suwak gui babylon",
    "isThumbCircle": "czy uchwyt jest kołem",
    "thumbColor": "kolor uchwytu",
    "thumbWidth": "szerokość uchwytu",
    "string | number": "ciąg znaków lub liczba",
    "isThumbClamped": "czy uchwyt jest ograniczony",
    "bitbybit.babylon.gui.slider.setBorderColor": "ustaw kolor obramowania",
    "setBorderColor": "ustaw kolor obramowania",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Zmienia kolor obramowania suwaka",
    "borderColor": "kolor obramowania",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "ustaw kolor tła",
    "setBackgroundColor": "ustaw kolor tła",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Zmienia kolor tła suwaka",
    "backgroundColor": "kolor tła",
    "bitbybit.babylon.gui.slider.setMaximum": "ustaw maksimum",
    "setMaximum": "ustaw maksimum",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Zmienia maksymalną wartość suwaka",
    "bitbybit.babylon.gui.slider.setMinimum": "ustaw minimum",
    "setMinimum": "ustaw minimum",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Zmienia minimalną wartość suwaka",
    "bitbybit.babylon.gui.slider.setStep": "ustaw krok",
    "setStep": "ustaw krok",
    "bitbybit.babylon.gui.slider.setStep_description": "Zmienia wartość kroku suwaka",
    "bitbybit.babylon.gui.slider.setValue": "ustaw wartość",
    "setValue": "ustaw wartość",
    "bitbybit.babylon.gui.slider.setValue_description": "Zmienia wartość suwaka",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "selektor obserwowalny suwaka",
    "createSliderObservableSelector": "selektor obserwowalny suwaka",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Tworzy selektor obserwowalny dla suwaka",
    "sliderObservableSelectorEnum": "selektor obserwowalny suwaka enum",
    "bitbybit.babylon.gui.slider.getBorderColor": "pobierz kolor obramowania",
    "getBorderColor": "pobierz kolor obramowania",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Pobiera kolor obramowania suwaka",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "pobierz kolor tła",
    "getBackgroundColor": "pobierz kolor tła",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Pobiera kolor tła suwaka",
    "bitbybit.babylon.gui.slider.getMaximum": "pobierz maksimum",
    "getMaximum": "pobierz maksimum",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Pobiera maksymalną wartość suwaka",
    "bitbybit.babylon.gui.slider.getMinimum": "pobierz minimum",
    "getMinimum": "pobierz minimum",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Pobiera minimalną wartość suwaka",
    "bitbybit.babylon.gui.slider.getStep": "pobierz krok",
    "getStep": "pobierz krok",
    "bitbybit.babylon.gui.slider.getStep_description": "Pobiera wartość kroku suwaka",
    "bitbybit.babylon.gui.slider.getValue": "pobierz wartość",
    "getValue": "pobierz wartość",
    "bitbybit.babylon.gui.slider.getValue_description": "Pobiera wartość suwaka",
    "bitbybit.babylon.gui.slider.getThumbColor": "pobierz kolor uchwytu",
    "getThumbColor": "pobierz kolor uchwytu",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Pobiera kolor uchwytu suwaka",
    "bitbybit.babylon.gui.slider.getThumbWidth": "pobierz szerokość uchwytu",
    "getThumbWidth": "pobierz szerokość uchwytu",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Pobiera szerokość uchwytu suwaka",
    "bitbybit.babylon.gui.slider.getIsVertical": "pobierz czy pionowy",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Pobiera informację, czy suwak jest pionowy",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "pobierz wyświetlanie uchwytu",
    "getDisplayThumb": "pobierz wyświetlanie uchwytu",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Pobiera informację o wyświetlaniu uchwytu suwaka",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "pobierz czy uchwyt jest kołem",
    "getIsThumbCircle": "pobierz czy uchwyt jest kołem",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Pobiera informację, czy uchwyt suwaka jest kołem",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "pobierz czy uchwyt jest ograniczony",
    "getIsThumbClamped": "pobierz czy uchwyt jest ograniczony",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Pobiera informację, czy uchwyt suwaka jest ograniczony",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "blok tekstu",
    "textBlock": "blok tekstu",
    "createTextBlock": "blok tekstu",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "tworzy blok tekstu",
    "bitbybit.babylon.gui.textBlock.alignText": "wyrównaj tekst",
    "alignText": "wyrównaj tekst",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Zmienia wyrównanie tekstu",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "ustaw obrys tekstu",
    "setTextOutline": "ustaw obrys tekstu",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Zmienia obrys tekstu",
    "BABYLON.GUI.TextBlock": "blok tekstu gui babylon",
    "outlineWidth": "szerokość obrysu",
    "outlineColor": "kolor obrysu",
    "bitbybit.babylon.gui.textBlock.setText": "ustaw tekst",
    "setText": "ustaw tekst",
    "bitbybit.babylon.gui.textBlock.setText_description": "Ustawia nowy tekst dla bloku tekstu",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "ustaw dopasowanie rozmiaru",
    "setRsizeToFit": "ustaw dopasowanie rozmiaru",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Włącza lub wyłącza dopasowanie rozmiaru do treści (resize to fit)",
    "resizeToFit": "dopasowanie rozmiaru",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "ustaw zawijanie tekstu",
    "setTextWrapping": "ustaw zawijanie tekstu",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Ustawia nowe zawijanie tekstu dla bloku tekstu",
    "textWrapping": "zawijanie tekstu",
    "boolean | BABYLON.GUI.TextWrapping": "boolean lub zawijanie tekstu gui babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "ustaw interlinię",
    "setLineSpacing": "ustaw interlinię",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Ustawia odstęp między wierszami tekstu",
    "lineSpacing": "interlinia",
    "bitbybit.babylon.gui.textBlock.getText": "pobierz tekst",
    "getText": "pobierz tekst",
    "bitbybit.babylon.gui.textBlock.getText_description": "Pobiera tekst bloku tekstu",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "pobierz zawijanie tekstu",
    "getTextWrapping": "pobierz zawijanie tekstu",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Pobiera ustawienie zawijania tekstu bloku tekstu",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "pobierz interlinię",
    "getLineSpacing": "pobierz interlinię",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Pobiera odstęp między wierszami bloku tekstu",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "pobierz szerokość obrysu",
    "getOutlineWidth": "pobierz szerokość obrysu",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Pobiera szerokość obrysu bloku tekstu",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "pobierz dopasowanie rozmiaru",
    "getResizeToFit": "pobierz dopasowanie rozmiaru",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Pobiera ustawienie dopasowania rozmiaru bloku tekstu",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "pobierz poziome wyrównanie tekstu",
    "getTextHorizontalAlignment": "pobierz poziome wyrównanie tekstu",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Pobiera poziome wyrównanie tekstu w bloku tekstu",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "pobierz pionowe wyrównanie tekstu",
    "getTextVerticalAlignment": "pobierz pionowe wyrównanie tekstu",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Pobiera pionowe wyrównanie tekstu w bloku tekstu",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "selektor obserwowalny bloku tekstu",
    "createTextBlockObservableSelector": "selektor obserwowalny bloku tekstu",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Tworzy selektor obserwowalny dla bloku tekstu",
    "textBlockObservableSelectorEnum": "selektor obserwowalny bloku tekstu enum",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "przycisk opcji",
    "radioButton": "przycisk opcji",
    "createRadioButton": "przycisk opcji",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "tworzy przycisk opcji (radio button)",
    "group": "grupa",
    "isChecked": "jest zaznaczony",
    "checkSizeRatio": "współczynnik rozmiaru zaznaczenia",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "ustaw współczynnik rozmiaru zaznaczenia",
    "setCheckSizeRatio": "ustaw współczynnik rozmiaru zaznaczenia",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Ustawia współczynnik rozmiaru zaznaczenia przycisku opcji",
    "BABYLON.GUI.RadioButton": "przycisk opcji gui babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "ustaw grupę",
    "setGroup": "ustaw grupę",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Ustawia grupę przycisku opcji",
    "bitbybit.babylon.gui.radioButton.setBackground": "ustaw tło",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Ustawia tło przycisku opcji",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "pobierz współczynnik rozmiaru zaznaczenia",
    "getCheckSizeRatio": "pobierz współczynnik rozmiaru zaznaczenia",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Pobiera współczynnik rozmiaru zaznaczenia przycisku opcji",
    "bitbybit.babylon.gui.radioButton.getGroup": "pobierz grupę",
    "getGroup": "pobierz grupę",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Pobiera grupę przycisku opcji",
    "bitbybit.babylon.gui.radioButton.getBackground": "pobierz tło",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Pobiera tło przycisku opcji",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "selektor obserwowalny przycisku opcji",
    "createRadioButtonObservableSelector": "selektor obserwowalny przycisku opcji",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Tworzy selektor obserwowalny dla przycisku opcji",
    "radioButtonObservableSelectorEnum": "selektor obserwowalny przycisku opcji enum",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "pole wyboru",
    "checkbox": "pole wyboru",
    "createCheckbox": "pole wyboru",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "tworzy pole wyboru (checkbox)",
    "bitbybit.babylon.gui.checkbox.setBackground": "ustaw tło",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Ustawia tło pola wyboru",
    "BABYLON.GUI.Checkbox": "pole wyboru gui babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "ustaw współczynnik rozmiaru zaznaczenia",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Ustawia współczynnik rozmiaru zaznaczenia pola wyboru",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "ustaw czy zaznaczone",
    "setIsChecked": "ustaw czy zaznaczone",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Ustawia, czy pole wyboru jest zaznaczone",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "pobierz współczynnik rozmiaru zaznaczenia",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Pobiera współczynnik rozmiaru zaznaczenia",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "pobierz czy zaznaczone",
    "getIsChecked": "pobierz czy zaznaczone",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Pobiera informację, czy pole wyboru jest zaznaczone",
    "bitbybit.babylon.gui.checkbox.getBackground": "pobierz tło",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Pobiera tło",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "selektor obserwowalny pola wyboru",
    "createCheckboxObservableSelector": "selektor obserwowalny pola wyboru",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Tworzy selektor obserwowalny dla pola wyboru",
    "checkboxObservableSelectorEnum": "selektor obserwowalny pola wyboru enum",
    "bitbybit.babylon.gui.inputText.createInputText": "pole tekstowe",
    "inputText": "pole tekstowe",
    "createInputText": "pole tekstowe",
    "bitbybit.babylon.gui.inputText.createInputText_description": "tworzy pole tekstowe",
    "placeholder": "tekst zastępczy",
    "bitbybit.babylon.gui.inputText.setBackground": "ustaw tło",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Ustawia tło pola tekstowego",
    "BABYLON.GUI.InputText": "pole tekstowe gui babylon",
    "bitbybit.babylon.gui.inputText.setText": "ustaw tekst",
    "bitbybit.babylon.gui.inputText.setText_description": "Ustawia tekst pola tekstowego",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "ustaw tekst zastępczy",
    "setPlaceholder": "ustaw tekst zastępczy",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Ustawia tekst zastępczy (placeholder) pola tekstowego",
    "bitbybit.babylon.gui.inputText.getBackground": "pobierz tło",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Pobiera tło pola tekstowego",
    "bitbybit.babylon.gui.inputText.getText": "pobierz tekst",
    "bitbybit.babylon.gui.inputText.getText_description": "Pobiera tekst pola tekstowego",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "pobierz tekst zastępczy",
    "getPlaceholder": "pobierz tekst zastępczy",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Pobiera tekst zastępczy pola tekstowego",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "selektor obserwowalny pola tekstowego",
    "createInputTextObservableSelector": "selektor obserwowalny pola tekstowego",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Tworzy selektor obserwowalny dla pola tekstowego",
    "inputTextObservableSelectorEnum": "selektor obserwowalny pola tekstowego enum",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "wybór koloru",
    "colorPicker": "wybór koloru",
    "createColorPicker": "wybór koloru",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "tworzy wybór koloru (color picker)",
    "defaultColor": "domyślny kolor",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "ustaw wartość wyboru koloru",
    "setColorPickerValue": "ustaw wartość wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Ustawia kolor wartości wyboru koloru",
    "BABYLON.GUI.ColorPicker": "wybór koloru gui babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "ustaw rozmiar wyboru koloru",
    "setColorPickerSize": "ustaw rozmiar wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Ustawia rozmiar wyboru koloru (szerokość i wysokość)",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "pobierz wartość wyboru koloru",
    "getColorPickerValue": "pobierz wartość wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Pobiera kolor wartości wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "pobierz rozmiar wyboru koloru",
    "getColorPickerSize": "pobierz rozmiar wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "pobiera rozmiar wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "selektor obserwowalny wyboru koloru",
    "createColorPickerObservableSelector": "selektor obserwowalny wyboru koloru",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Tworzy selektor obserwowalny dla wyboru koloru",
    "colorPickerObservableSelectorEnum": "selektor obserwowalny wyboru koloru enum",
    "bitbybit.babylon.gui.image.createImage": "obraz",
    "image": "obraz",
    "createImage": "obraz",
    "bitbybit.babylon.gui.image.createImage_description": "tworzy obraz",
    "bitbybit.babylon.gui.image.setSourceUrl": "ustaw adres url źródła",
    "setSourceUrl": "ustaw adres url źródła",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "ustawia adres url źródła obrazu",
    "BABYLON.GUI.Image": "obraz gui babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "pobierz adres url źródła",
    "getSourceUrl": "pobierz adres url źródła",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "pobiera adres url źródła obrazu",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "menedżer gizmo",
    "gizmo": "gizmo",
    "manager": "menedżer",
    "createGizmoManager": "menedżer gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Tworzy menedżer gizmo",
    "positionGizmoEnabled": "gizmo pozycji włączone",
    "rotationGizmoEnabled": "gizmo obrotu włączone",
    "scaleGizmoEnabled": "gizmo skali włączone",
    "boundingBoxGizmoEnabled": "gizmo prostopadłościanu otaczającego włączone",
    "usePointerToAttachGizmos": "użyj wskaźnika do dołączania gizmo",
    "clearGizmoOnEmptyPointerEvent": "wyczyść gizmo przy pustym zdarzeniu wskaźnika",
    "scaleRatio": "współczynnik skali",
    "attachableMeshes": "siatki dołączalne",
    "BABYLON.AbstractMesh[]": "tablica siatek abstrakcyjnych babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "pobierz gizmo pozycji",
    "getPositionGizmo": "pobierz gizmo pozycji",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Pobiera gizmo pozycji",
    "gizmoManager": "menedżer gizmo",
    "BABYLON.GizmoManager": "menedżer gizmo babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "pobierz gizmo obrotu",
    "getRotationGizmo": "pobierz gizmo obrotu",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Pobiera gizmo obrotu",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "pobierz gizmo skali",
    "getScaleGizmo": "pobierz gizmo skali",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Pobiera gizmo skali",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "pobierz gizmo prostopadłościanu otaczającego",
    "getBoundingBoxGizmo": "pobierz gizmo prostopadłościanu otaczającego",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Pobiera gizmo prostopadłościanu otaczającego",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "dołącz do siatki",
    "attachToMesh": "dołącz do siatki",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Dołącza menedżer gizmo do siatki",
    "update": "aktualizuj",
    "bitbybit.babylon.gizmo.manager.detachMesh": "odłącz siatkę",
    "detachMesh": "odłącz siatkę",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Odłącza menedżer gizmo od siatki",
    "bitbybit.babylon.gizmo.base.scaleRatio": "ustaw współczynnik skali",
    "base": "bazowy",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Ustawia współczynnik skali gizmo",
    "BABYLON.IGizmo": "babylon i gizmo",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "pobierz współczynnik skali",
    "getScaleRatio": "pobierz współczynnik skali",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Pobiera współczynnik skali",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "ustaw gizmo płaskie włączone",
    "positionGizmo": "gizmo pozycji",
    "planarGizmoEnabled": "gizmo płaskie włączone",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Ustawia czy gizmo płaskie jest włączone",
    "BABYLON.IPositionGizmo": "babylon i gizmo pozycji",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "ustaw dystans przyciągania",
    "snapDistance": "dystans przyciągania",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Ustawia dystans przyciągania gizmo pozycji",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "pobierz dołączoną siatkę",
    "getAttachedMesh": "pobierz dołączoną siatkę",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Pobiera dołączoną siatkę",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "pobierz dołączony węzeł",
    "getAttachedNode": "pobierz dołączony węzeł",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Pobiera dołączony węzeł",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "pobierz gizmo x",
    "getXGizmo": "pobierz gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Pobiera gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "pobierz gizmo y",
    "getYGizmo": "pobierz gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Pobiera gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "pobierz gizmo z",
    "getZGizmo": "pobierz gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Pobiera gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "pobierz gizmo płaszczyzny x",
    "getXPlaneGizmo": "pobierz gizmo płaszczyzny x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Pobiera gizmo płaszczyzny x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "pobierz gizmo płaszczyzny y",
    "getYPlaneGizmo": "pobierz gizmo płaszczyzny y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Pobiera gizmo płaszczyzny y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "pobierz gizmo płaszczyzny z",
    "getZPlaneGizmo": "pobierz gizmo płaszczyzny z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Pobiera gizmo płaszczyzny z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "pobierz czy gizmo płaskie włączone",
    "getPlanarGizmoEnabled": "pobierz czy gizmo płaskie włączone",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Pobiera informację, czy gizmo płaskie jest włączone",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "pobierz dystans przyciągania",
    "getSnapDistance": "pobierz dystans przyciągania",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Pobiera dystans przyciągania",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "pobierz czy przeciągane",
    "getIsDragging": "pobierz czy przeciągane",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Pobiera informację, czy odbywa się przeciąganie",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "selektor obserwowalny gizmo pozycji",
    "createPositionGizmoObservableSelector": "selektor obserwowalny gizmo pozycji",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Tworzy selektor obserwowalny dla gizmo pozycji",
    "positionGizmoObservableSelectorEnum": "selektor obserwowalny gizmo pozycji enum",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "ustaw dystans przyciągania",
    "rotationGizmo": "gizmo obrotu",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Ustawia dystans przyciągania gizmo obrotu",
    "BABYLON.IRotationGizmo": "babylon i gizmo obrotu",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "ustaw czułość",
    "sensitivity": "czułość",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Ustawia czułość gizmo obrotu",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "pobierz dołączoną siatkę",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Pobiera dołączoną siatkę",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "pobierz dołączony węzeł",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Pobiera dołączony węzeł",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "pobierz gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Pobiera gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "pobierz gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Pobiera gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "pobierz gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Pobiera gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "pobierz dystans przyciągania",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Pobiera dystans przyciągania",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "pobierz czułość",
    "getSensitivity": "pobierz czułość",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Pobiera czułość",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "selektor obserwowalny gizmo obrotu",
    "createRotationGizmoObservableSelector": "selektor obserwowalny gizmo obrotu",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Tworzy selektor obserwowalny dla gizmo obrotu",
    "rotationGizmoObservableSelectorEnum": "selektor obserwowalny gizmo obrotu enum",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "pobierz gizmo x",
    "scaleGizmo": "gizmo skali",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Pobiera gizmo x",
    "BABYLON.IScaleGizmo": "babylon i gizmo skali",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "pobierz gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Pobiera gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "pobierz gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Pobiera gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "ustaw dystans przyciągania",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Ustawia dystans przyciągania gizmo skali",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "ustaw przyciąganie przyrostowe",
    "setIncrementalSnap": "ustaw przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Ustawia przyciąganie przyrostowe gizmo skali",
    "incrementalSnap": "przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "ustaw czułość",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Ustawia czułość gizmo skali",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "pobierz przyciąganie przyrostowe",
    "getIncrementalSnap": "pobierz przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Pobiera przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "pobierz dystans przyciągania",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Pobiera dystans przyciągania",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "pobierz czułość",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Pobiera czułość",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "selektor obserwowalny gizmo skali",
    "createScaleGizmoObservableSelector": "selektor obserwowalny gizmo skali",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Tworzy selektor obserwowalny dla gizmo skali",
    "scaleGizmoObservableSelectorEnum": "selektor obserwowalny gizmo skali enum",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "ustaw rozmiar sfery obrotu",
    "boundingBoxGizmo": "gizmo obwiedni",
    "setRotationSphereSize": "ustaw rozmiar sfery obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Ustawia rozmiar sfery obrotu gizmo obwiedni",
    "BABYLON.BoundingBoxGizmo": "gizmo obwiedni babylon",
    "rotationSphereSize": "rozmiar sfery obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "ustaw stały rozmiar ekranu siatki przeciągania",
    "setFixedDragMeshScreenSize": "ustaw stały rozmiar ekranu siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "Jeśli ustawione, kotwice obrotu i pudełka skalowania będą zwiększać rozmiar w zależności od odległości od kamery, aby zachować stały rozmiar na ekranie (Domyślnie: false). Uwaga: fixedDragMeshScreenSize ma pierwszeństwo przed fixedDragMeshBoundsSize, jeśli oba są prawdziwe",
    "fixedDragMeshScreenSize": "stały rozmiar ekranu siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "ustaw stały rozmiar granic siatki przeciągania",
    "setFixedDragMeshBoundsSize": "ustaw stały rozmiar granic siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Ustawia stały rozmiar granic siatki przeciągania gizmo obwiedni",
    "fixedDragMeshBoundsSize": "stały rozmiar granic siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "ustaw współczynnik odległości stałego rozmiaru ekranu",
    "setFixedDragMeshScreenSizeDistanceFactor": "ustaw współczynnik odległości stałego rozmiaru ekranu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "Odległość od obiektu, przy której przeciągane siatki powinny wyglądać na wymiarowe w świecie, gdy fixedDragMeshScreenSize jest ustawione na true (domyślnie: 10)",
    "fixedDragMeshScreenSizeDistanceFactor": "współczynnik odległości stałego rozmiaru ekranu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "ustaw dystans przyciągania skalowania",
    "setScalingSnapDistance": "ustaw dystans przyciągania skalowania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Ustawia dystans przyciągania skalowania gizmo obwiedni. Odległość przeciągnięcia w jednostkach babylon, do której gizmo przyciągnie skalowanie podczas przeciągania.",
    "scalingSnapDistance": "dystans przyciągania skalowania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "ustaw dystans przyciągania obrotu",
    "setRotationSnapDistance": "ustaw dystans przyciągania obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Ustawia dystans przyciągania obrotu gizmo obwiedni. Odległość przeciągnięcia w jednostkach babylon, do której gizmo przyciągnie obrót podczas przeciągania.",
    "rotationSnapDistance": "dystans przyciągania obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "ustaw rozmiar pudełka skali",
    "setScaleBoxSize": "ustaw rozmiar pudełka skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Ustawia rozmiar pudełka skali gizmo obwiedni",
    "scaleBoxSize": "rozmiar pudełka skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "ustaw przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Ustawia przyciąganie przyrostowe gizmo obwiedni. Skalowanie z przyciąganiem przyrostowym (domyślnie false). Gdy true, przy snapDistance równym 0.1, skalowanie wyniesie 1.1, 1.2, 1.3 zamiast (gdy false): 1.1, 1.21, 1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "ustaw punkt obrotu skali",
    "setScalePivot": "ustaw punkt obrotu skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Ustawia punkt obrotu (pivot) skali gizmo obwiedni. Względny punkt obrotu obwiedni używany podczas skalowania dołączonego węzła. Gdy null, skaluje od przeciwległego rogu. 0.5,0.5,0.5 dla środka i 0.5,0,0.5 dla dołu (Domyślnie: null)",
    "scalePivot": "punkt obrotu skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "ustaw współczynnik osi",
    "setAxisFactor": "ustaw współczynnik osi",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Ustawia współczynnik osi gizmo obwiedni. Ustawia niestandardową wartość czułości dla każdej osi",
    "axisFactor": "współczynnik osi",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "ustaw prędkość przeciągania skali",
    "setScaleDragSpeed": "ustaw prędkość przeciągania skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Ustawia prędkość przeciągania skali gizmo obwiedni",
    "scaleDragSpeed": "prędkość przeciągania skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "pobierz rozmiar sfery obrotu",
    "getRotationSphereSize": "pobierz rozmiar sfery obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Pobiera rozmiar sfery obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "pobierz rozmiar pudełka skali",
    "getScaleBoxSize": "pobierz rozmiar pudełka skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Pobiera rozmiar pudełka skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "pobierz stały rozmiar ekranu siatki przeciągania",
    "getFixedDragMeshScreenSize": "pobierz stały rozmiar ekranu siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Pobiera stały rozmiar ekranu siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "pobierz stały rozmiar granic siatki przeciągania",
    "getFixedDragMeshBoundsSize": "pobierz stały rozmiar granic siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Pobiera stały rozmiar granic siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "pobierz współczynnik odległości stałego rozmiaru ekranu",
    "getFixedDragMeshScreenSizeDistanceFactor": "pobierz współczynnik odległości stałego rozmiaru ekranu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Pobiera współczynnik odległości stałego rozmiaru ekranu siatki przeciągania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "pobierz dystans przyciągania skalowania",
    "getScalingSnapDistance": "pobierz dystans przyciągania skalowania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Pobiera dystans przyciągania skalowania",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "pobierz dystans przyciągania obrotu",
    "getRotationSnapDistance": "pobierz dystans przyciągania obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Pobiera dystans przyciągania obrotu",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "pobierz przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Pobiera przyciąganie przyrostowe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "pobierz punkt obrotu skali",
    "getScalePivot": "pobierz punkt obrotu skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Pobiera punkt obrotu skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "pobierz współczynnik osi",
    "getAxisFactor": "pobierz współczynnik osi",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Pobiera współczynnik osi",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "pobierz prędkość przeciągania skali",
    "getScaleDragSpeed": "pobierz prędkość przeciągania skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Pobiera prędkość przeciągania skali",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "selektor obserwowalny gizmo obwiedni",
    "createBoundingBoxGizmoObservableSelector": "selektor obserwowalny gizmo obwiedni",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Tworzy selektor obserwowalny dla gizmo obwiedni",
    "boundingBoxGizmoObservableSelectorEnum": "selektor obserwowalny gizmo obwiedni enum",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "ustaw czy włączone",
    "axisDragGizmo": "gizmo przeciągania osi",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Ustawia czy oś jest włączona",
    "BABYLON.IAxisDragGizmo": "babylon i gizmo przeciągania osi",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "pobierz czy włączone",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Sprawdza czy oś jest włączona",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "ustaw czy włączone",
    "axisScaleGizmo": "gizmo skalowania osi",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Ustawia czy oś jest włączona",
    "BABYLON.IAxisScaleGizmo": "babylon i gizmo skalowania osi",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "pobierz czy włączone",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Sprawdza czy oś jest włączona",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "ustaw czy włączone",
    "planeDragGizmo": "gizmo przeciągania płaszczyzny",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Ustawia czy płaszczyzna jest włączona",
    "BABYLON.IPlaneDragGizmo": "babylon i gizmo przeciągania płaszczyzny",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "pobierz czy włączone",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Sprawdza czy płaszczyzna jest włączona",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "ustaw czy włączone",
    "planeRotationGizmo": "gizmo obrotu płaszczyzny",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Ustawia czy płaszczyzna jest włączona",
    "BABYLON.IPlaneRotationGizmo": "babylon i gizmo obrotu płaszczyzny",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "pobierz czy włączone",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Sprawdza czy płaszczyzna jest włączona",
    "bitbybit.vector.removeAllDuplicateVectors": "usuń wszystkie zduplikowane wektory",
    "vector": "wektor",
    "removeAllDuplicateVectors": "usuń wszystkie zduplikowane wektory",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Usuwa wszystkie zduplikowane wektory z tablicy wejściowej (zachowuje tylko unikalne wektory). Przykład: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]] → [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "usuń",
    "vectors": "wektory",
    "number[][]": "tablica tablic liczb",
    "tolerance": "tolerancja",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "usuń kolejne zduplikowane wektory",
    "removeConsecutiveDuplicateVectors": "usuń kolejne zduplikowane wektory",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Usuwa kolejne zduplikowane wektory z tablicy wejściowej (usuwa tylko duplikaty występujące obok siebie). Przykład: [[1,2], [1,2], [3,4], [1,2]] → [[1,2], [3,4], [1,2]] (usunięto tylko kolejny duplikat)",
    "checkFirstAndLast": "sprawdź pierwszy i ostatni",
    "bitbybit.vector.angleBetween": "kąt między",
    "angleBetween": "kąt między",
    "bitbybit.vector.angleBetween_description": "Mierzy kąt między dwoma wektorami w stopniach (zawsze zwraca kąt dodatni 0-180°). Przykład: [1,0,0] i [0,1,0] → 90° (wektory prostopadłe)",
    "angles": "kąty",
    "first": "pierwszy",
    "second": "drugi",
    "bitbybit.vector.angleBetweenNormalized2d": "kąt między znormalizowanymi 2d",
    "angleBetweenNormalized2d": "kąt między znormalizowanymi 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Mierzy znormalizowany kąt 2D między dwoma wektorami w stopniach (uwzględnia kierunek, może być ujemny). Przykład: [1,0] do [0,1] → 90°, [0,1] do [1,0] → -90°",
    "bitbybit.vector.positiveAngleBetween": "dodatni kąt między",
    "positiveAngleBetween": "dodatni kąt między",
    "bitbybit.vector.positiveAngleBetween_description": "Mierzy dodatni kąt między dwoma wektorami względem wektora odniesienia w stopniach (zawsze 0-360°). Przykład: konwertuje ujemne kąty ze znakiem na dodatnie, dodając 360° w razie potrzeby",
    "reference": "odniesienie",
    "bitbybit.vector.addAll": "dodaj wszystkie",
    "addAll": "dodaj wszystkie",
    "bitbybit.vector.addAll_description": "Dodaje wszystkie wartości xyz wektorów element po elemencie i tworzy nowy wektor. Przykład: [[1,2,3], [4,5,6], [7,8,9]] → [12,15,18] (sumuje każdą kolumnę)",
    "sum": "suma",
    "bitbybit.vector.add": "dodaj",
    "add": "dodaj",
    "bitbybit.vector.add_description": "Dodaje dwa wektory do siebie element po elemencie. Przykład: [1,2,3] + [4,5,6] → [5,7,9]",
    "bitbybit.vector.all": "wszystkie",
    "all": "wszystkie",
    "bitbybit.vector.all_description": "Sprawdza, czy tablica logiczna zawiera tylko wartości true, zwraca false jeśli wystąpi pojedyncze false. Przykład: [true, true, true] → true, [true, false, true] → false",
    "boolean[]": "tablica wartości logicznych",
    "bitbybit.vector.cross": "iloczyn wektorowy",
    "cross": "iloczyn wektorowy",
    "bitbybit.vector.cross_description": "Oblicza iloczyn wektorowy dwóch wektorów 3D (wektor prostopadły do obu wejść). Przykład: [1,0,0] × [0,1,0] → [0,0,1] (reguła prawej ręki)",
    "bitbybit.vector.distSquared": "odległość do kwadratu",
    "distSquared": "odległość do kwadratu",
    "bitbybit.vector.distSquared_description": "Oblicza kwadrat odległości między dwoma wektorami (szybsze niż odległość, unika pierwiastkowania). Przykład: [0,0,0] do [3,4,0] → 25 (odległość 5 do kwadratu)",
    "bitbybit.vector.dist": "odległość",
    "dist": "odległość",
    "bitbybit.vector.dist_description": "Oblicza odległość euklidesową między dwoma wektorami. Przykład: [0,0,0] do [3,4,0] → 5, [1,1] do [4,5] → 5",
    "bitbybit.vector.div": "dziel",
    "div": "dziel",
    "bitbybit.vector.div_description": "Dzieli każdy element wektora przez wartość skalarną. Przykład: [10,20,30] ÷ 2 → [5,10,15]",
    "scalar": "skalar",
    "bitbybit.vector.domain": "zakres",
    "domain": "zakres",
    "bitbybit.vector.domain_description": "Oblicza zakres (domenę) między minimalnymi i maksymalnymi wartościami wektora. Przykład: [1,3,5,9] → 8 (różnica między ostatnim a pierwszym: 9-1)",
    "bitbybit.vector.dot": "iloczyn skalarny",
    "dot": "iloczyn skalarny",
    "bitbybit.vector.dot_description": "Oblicza iloczyn skalarny dwóch wektorów (mierzy podobieństwo/rzutowanie). Przykład: [1,2,3] • [4,5,6] → 32 (1×4 + 2×5 + 3×6), wektory prostopadłe → 0",
    "bitbybit.vector.finite": "skończony",
    "finite": "skończony",
    "bitbybit.vector.finite_description": "Sprawdza, czy każdy element w wektorze jest skończony i zwraca tablicę logiczną. Przykład: [1, 2, Infinity, 3] → [true, true, false, true]",
    "validate": "waliduj",
    "bitbybit.vector.isZero": "jest zerem",
    "isZero": "jest zerem",
    "bitbybit.vector.isZero_description": "Sprawdza, czy wektor ma długość zero (wszystkie elementy są zerami). Przykład: [0,0,0] → true, [0,0,0.001] → false",
    "bitbybit.vector.lerp": "interpolacja liniowa (lerp)",
    "lerp": "interpolacja liniowa (lerp)",
    "bitbybit.vector.lerp_description": "Znajduje interpolowany wektor między dwoma wektorami przy użyciu ułamka (interpolacja liniowa). Przykład: [0,0,0] do [10,10,10] przy 0.5 → [5,5,5], ułamek=0 → pierwszy, ułamek=1 → drugi",
    "fraction": "ułamek",
    "bitbybit.vector.max": "maks",
    "max": "maks",
    "bitbybit.vector.max_description": "Znajduje maksymalną (największą) wartość w wektorze. Przykład: [3, 7, 2, 9, 1] → 9",
    "extract": "wyodrębnij",
    "bitbybit.vector.min": "min",
    "min": "min",
    "bitbybit.vector.min_description": "Znajduje minimalną (najmniejszą) wartość w wektorze. Przykład: [3, 7, 2, 9, 1] → 1",
    "bitbybit.vector.mul": "mnóż",
    "mul": "mnóż",
    "bitbybit.vector.mul_description": "Mnoży każdy element wektora przez wartość skalarną. Przykład: [2,3,4] × 5 → [10,15,20]",
    "bitbybit.vector.neg": "neguj",
    "neg": "neguj",
    "bitbybit.vector.neg_description": "Neguje wektor (odwraca znak każdego elementu). Przykład: [5,-3,2] → [-5,3,-2]",
    "bitbybit.vector.normSquared": "norma do kwadratu",
    "normSquared": "norma do kwadratu",
    "bitbybit.vector.normSquared_description": "Oblicza kwadrat normy (kwadrat długości/wielkości) wektora. Przykład: [3,4,0] → 25 (długość 5 do kwadratu)",
    "bitbybit.vector.norm": "norma",
    "norm": "norma",
    "bitbybit.vector.norm_description": "Oblicza normę (długość/wielkość) wektora. Przykład: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.vector.normalized": "znormalizowany",
    "normalized": "znormalizowany",
    "bitbybit.vector.normalized_description": "Normalizuje wektor do wektora jednostkowego o długości 1 (zachowuje kierunek, skaluje wielkość do 1). Przykład: [3,4,0] → [0.6,0.8,0], [10,0,0] → [1,0,0]",
    "bitbybit.vector.onRay": "na promieniu",
    "onRay": "na promieniu",
    "bitbybit.vector.onRay_description": "Znajduje punkt na promieniu w danej odległości od początku wzdłuż wektora kierunku. Przykład: Punkt [0,0,0] + kierunek [1,0,0] w odległości 5 → [5,0,0]",
    "bitbybit.vector.vectorXYZ": "wektor xyz",
    "vectorXYZ": "wektor xyz",
    "bitbybit.vector.vectorXYZ_description": "Tworzy wektor 3D ze współrzędnych x, y, z. Przykład: x=1, y=2, z=3 → [1,2,3]",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "wektor xy",
    "vectorXY": "wektor xy",
    "bitbybit.vector.vectorXY_description": "Tworzy wektor 2D ze współrzędnych x, y. Przykład: x=3, y=4 → [3,4]",
    "bitbybit.vector.range": "zakres",
    "range": "zakres",
    "bitbybit.vector.range_description": "Tworzy wektor liczb całkowitych od 0 do max (wyłącznie). Przykład: max=5 → [0,1,2,3,4], max=3 → [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "kąt skierowany między",
    "signedAngleBetween": "kąt skierowany między",
    "bitbybit.vector.signedAngleBetween_description": "Oblicza kąt ze znakiem między dwoma wektorami przy użyciu wektora odniesienia (określa kierunek obrotu). Przykład: Zwraca dodatni lub ujemny kąt w zależności od kierunku obrotu względem odniesienia",
    "bitbybit.vector.span": "rozpiętość",
    "span": "rozpiętość",
    "bitbybit.vector.span_description": "Tworzy wektor zawierający liczby od min do max z danym krokiem. Przykład: min=0, max=10, krok=2 → [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "rozpiętość elementów z easingiem",
    "spanEaseItems": "rozpiętość elementów z easingiem",
    "bitbybit.vector.spanEaseItems_description": "Tworzy wektor z liczbami od min do max przy użyciu funkcji easing (wygładzania) dla nieliniowego rozkładu. Przykład: min=0, max=100, nrItems=5, ease='easeInQuad' → tworzy przyspieszające interwały",
    "nrItems": "liczba elementów",
    "ease": "funkcja ease",
    "Math.easeEnum": "funkcja ease matematyczna enum",
    "intervals": "interwały",
    "bitbybit.vector.spanLinearItems": "rozpiętość elementów liniowa",
    "spanLinearItems": "rozpiętość elementów liniowa",
    "bitbybit.vector.spanLinearItems_description": "Tworzy wektor z równomiernie rozmieszczonymi liczbami od min do max z określoną liczbą elementów. Przykład: min=0, max=10, nrItems=5 → [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "odejmij",
    "sub": "odejmij",
    "bitbybit.vector.sub_description": "Odejmuje drugi wektor od pierwszego element po elemencie. Przykład: [10,20,30] - [1,2,3] → [9,18,27]",
    "bitbybit.vector.sum": "suma",
    "bitbybit.vector.sum_description": "Sumuje wszystkie wartości w wektorze i zwraca pojedynczą liczbę. Przykład: [1,2,3,4] → 10, [5,10,15] → 30",
    "bitbybit.point.transformPoint": "przekształć punkt",
    "transformPoint": "przekształć punkt",
    "bitbybit.point.transformPoint_description": "Stosuje macierz transformacji do pojedynczego punktu (obraca, skaluje lub przesuwa). Przykład: punkt=[0,0,0] z przesunięciem [5,5,0] → [5,5,0]",
    "transformation": "transformacja",
    "Base.TransformMatrixes": "macierze transformacji bazowe",
    "bitbybit.point.transformPoints": "przekształć punkty",
    "transformPoints": "przekształć punkty",
    "bitbybit.point.transformPoints_description": "Stosuje tę samą macierz transformacji do wielu punktów (przekształcenie grupowe). Przykład: 5 punktów z obrotem 90° → wszystkie 5 punktów obróconych razem",
    "points": "punkty",
    "bitbybit.point.transformsForPoints": "transformacje dla punktów",
    "transformsForPoints": "transformacje dla punktów",
    "bitbybit.point.transformsForPoints_description": "Stosuje różne macierze transformacji do odpowiadających im punktów (jedna transformacja na punkt). Tablice muszą mieć taką samą długość. Przykład: 3 punkty z 3 różnymi przesunięciami → każdy punkt przesunięty niezależnie",
    "Base.TransformMatrixes[]": "tablica macierzy transformacji bazowych",
    "bitbybit.point.translatePoints": "przesuń punkty",
    "translatePoints": "przesuń punkty",
    "bitbybit.point.translatePoints_description": "Przesuwa wiele punktów o wektor translacji (to samo przesunięcie dla wszystkich punktów). Przykład: punkty=[[0,0,0], [1,0,0]], translacja=[5,5,0] → [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "przesuń punkty wektorami",
    "translatePointsWithVectors": "przesuń punkty wektorami",
    "bitbybit.point.translatePointsWithVectors_description": "Przesuwa wiele punktów o odpowiadające im wektory translacji (jeden wektor na punkt). Tablice muszą mieć taką samą długość. Przykład: 3 punkty z 3 różnymi wektorami → każdy punkt przesunięty o odpowiadający mu wektor",
    "bitbybit.point.translateXYZPoints": "przesuń punkty xyz",
    "translateXYZPoints": "przesuń punkty xyz",
    "bitbybit.point.translateXYZPoints_description": "Przesuwa wiele punktów o oddzielne wartości X, Y, Z (wygodna metoda translacji). Przykład: punkty=[[0,0,0]], x=10, y=5, z=0 → [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "skaluj punkty środek xyz",
    "scalePointsCenterXYZ": "skaluj punkty środek xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "Skaluje wiele punktów wokół punktu środkowego z różnymi współczynnikami dla każdej osi. Przykład: punkty=[[10,0,0]], środek=[5,0,0], skalaXyz=[2,1,1] → [[15,0,0]] (podwaja odległość X od środka)",
    "bitbybit.point.rotatePointsCenterAxis": "obróć punkty środek oś",
    "rotatePointsCenterAxis": "obróć punkty środek oś",
    "bitbybit.point.rotatePointsCenterAxis_description": "Obraca wiele punktów wokół punktu środkowego wzdłuż niestandardowej osi. Przykład: punkty=[[10,0,0]], środek=[0,0,0], oś=[0,1,0], kąt=90° → [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "odległość najbliższego punktu z punktów",
    "closestPointFromPointsDistance": "odległość najbliższego punktu z punktów",
    "bitbybit.point.closestPointFromPointsDistance_description": "Oblicza odległość do najbliższego punktu w kolekcji. Przykład: punkt=[0,0,0], punkty=[[5,0,0], [10,0,0], [3,0,0]] → 3 (odległość do [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "indeks najbliższego punktu z punktów",
    "closestPointFromPointsIndex": "indeks najbliższego punktu z punktów",
    "bitbybit.point.closestPointFromPointsIndex_description": "Znajduje indeks tablicy najbliższego punktu w kolekcji (indeks liczony od 1, nie od 0). Przykład: punkt=[0,0,0], punkty=[[5,0,0], [10,0,0], [3,0,0]] → 3 (indeks [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "najbliższy punkt z punktów",
    "closestPointFromPoints": "najbliższy punkt z punktów",
    "bitbybit.point.closestPointFromPoints_description": "Znajduje najbliższy punkt w kolekcji względem punktu odniesienia. Przykład: punkt=[0,0,0], punkty=[[5,0,0], [10,0,0], [3,0,0]] → [3,0,0]",
    "bitbybit.point.distance": "odległość",
    "bitbybit.point.distance_description": "Oblicza odległość euklidesową między dwoma punktami. Przykład: start=[0,0,0], koniec=[3,4,0] → 5 (używając twierdzenia Pitagorasa: √(3²+4²))",
    "measure": "mierz",
    "startPoint": "punkt początkowy",
    "endPoint": "punkt końcowy",
    "bitbybit.point.distancesToPoints": "odległości do punktów",
    "distancesToPoints": "odległości do punktów",
    "bitbybit.point.distancesToPoints_description": "Oblicza odległości od punktu początkowego do wielu punktów końcowych. Przykład: start=[0,0,0], punktyKońcowe=[[3,0,0], [0,4,0], [5,0,0]] → [3, 4, 5]",
    "endPoints": "punkty końcowe",
    "bitbybit.point.multiplyPoint": "powiel punkt",
    "multiplyPoint": "powiel punkt",
    "bitbybit.point.multiplyPoint_description": "Duplikuje punkt N razy (tworzy tablicę z N kopiami tego samego punktu). Przykład: punkt=[5,5,0], iloscPunktow=3 → [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "ilość punktów",
    "bitbybit.point.getX": "pobierz x",
    "getX": "pobierz x",
    "bitbybit.point.getX_description": "Wyodrębnia współrzędną X z punktu. Przykład: punkt=[5,10,3] → 5",
    "bitbybit.point.getY": "pobierz y",
    "getY": "pobierz y",
    "bitbybit.point.getY_description": "Wyodrębnia współrzędną Y z punktu. Przykład: punkt=[5,10,3] → 10",
    "bitbybit.point.getZ": "pobierz z",
    "getZ": "pobierz z",
    "bitbybit.point.getZ_description": "Wyodrębnia współrzędną Z z punktu. Przykład: punkt=[5,10,3] → 3",
    "bitbybit.point.averagePoint": "uśredniony punkt",
    "averagePoint": "uśredniony punkt",
    "bitbybit.point.averagePoint_description": "Oblicza centroid (średnią pozycję) wielu punktów. Przykład: punkty=[[0,0,0], [10,0,0], [10,10,0]] → [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "punkt xyz",
    "pointXYZ": "punkt xyz",
    "bitbybit.point.pointXYZ_description": "Tworzy punkt 3D ze współrzędnych X, Y, Z. Przykład: x=10, y=5, z=3 → [10,5,3]",
    "bitbybit.point.pointXY": "punkt xy",
    "pointXY": "punkt xy",
    "bitbybit.point.pointXY_description": "Tworzy punkt 2D ze współrzędnych X, Y. Przykład: x=10, y=5 → [10,5]",
    "bitbybit.point.spiral": "spirala",
    "spiral": "spirala",
    "bitbybit.point.spiral_description": "Tworzy punkty spirali logarytmicznej przy użyciu złotego kąta lub niestandardowego współczynnika rozszerzania. Generuje naturalne wzory spiralne spotykane w przyrodzie (słonecznik, muszla łodzika). Przykład: liczbaPunktów=100, promień=10, phi=1.618 → 100 punktów tworzących spiralę zewnętrzną",
    "phi": "phi",
    "numberPoints": "liczba punktów",
    "widening": "rozszerzanie",
    "factor": "współczynnik",
    "bitbybit.point.hexGrid": "siatka heksagonalna",
    "hexGrid": "siatka heksagonalna",
    "bitbybit.point.hexGrid_description": "Tworzy punkty środkowe siatki heksagonalnej na płaszczyźnie XY (wzór plastra miodu). Rozmiar siatki kontrolowany przez liczbę sześciokątów, a nie szerokość/wysokość. Przykład: promienSzesciokata=1, nrSzesciokatowX=3, nrSzesciokatowY=3 → 9 środków heksagonów we wzorze siatki",
    "nrHexagonsY": "nr sześciokątów y",
    "nrHexagonsX": "nr sześciokątów x",
    "radiusHexagon": "promień sześciokąta",
    "orientOnCenter": "zorientuj na środku",
    "pointsOnGround": "punkty na ziemi",
    "bitbybit.point.removeConsecutiveDuplicates": "usuń kolejne duplikaty",
    "removeConsecutiveDuplicates": "usuń kolejne duplikaty",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Usuwa kolejne zduplikowane punkty z tablicy z uwzględnieniem tolerancji. Przykład: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]] → [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "wyczyść",
    "bitbybit.line.convertToNurbsCurve": "konwertuj na krzywą nurbs",
    "line": "linia",
    "convertToNurbsCurve": "konwertuj na krzywą nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "konwertuje linię na krzywą nurbs",
    "LinePointsDto": "line points dto",
    "bitbybit.line.convertLinesToNurbsCurves": "konwertuj linie na krzywe nurbs",
    "convertLinesToNurbsCurves": "konwertuj linie na krzywe nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "konwertuje tablicę linii na tablicę krzywych nurbs",
    "lines": "linie",
    "LinePointsDto[]": "tablica line points dto",
    "bitbybit.line.getStartPoint": "pobierz punkt początkowy",
    "getStartPoint": "pobierz punkt początkowy",
    "bitbybit.line.getStartPoint_description": "Wyodrębnia punkt początkowy z linii. Przykład: linia={start:[0,0,0], koniec:[10,5,0]} → [0,0,0]",
    "bitbybit.line.getEndPoint": "pobierz punkt końcowy",
    "getEndPoint": "pobierz punkt końcowy",
    "bitbybit.line.getEndPoint_description": "Wyodrębnia punkt końcowy z linii. Przykład: linia={start:[0,0,0], koniec:[10,5,0]} → [10,5,0]",
    "bitbybit.line.length": "długość",
    "bitbybit.line.length_description": "Oblicza długość (odległość) odcinka linii. Przykład: linia={start:[0,0,0], koniec:[3,4,0]} → 5 (używając twierdzenia Pitagorasa)",
    "bitbybit.line.reverse": "odwróć linię",
    "reverse": "odwróć",
    "bitbybit.line.reverse_description": "Odwraca kierunek linii, zamieniając punkty początkowy i końcowy. Przykład: linia={start:[0,0,0], koniec:[10,5,0]} → {start:[10,5,0], koniec:[0,0,0]}",
    "bitbybit.line.transformLine": "przekształć linię",
    "transformLine": "przekształć linię",
    "bitbybit.line.transformLine_description": "Stosuje macierz transformacji do linii (obraca, skaluje lub przesuwa oba punkty końcowe). Przykład: linia={start:[0,0,0], koniec:[10,0,0]} z przesunięciem [5,5,0] → {start:[5,5,0], koniec:[15,5,0]}",
    "bitbybit.line.transformsForLines": "transformacje dla linii",
    "transformsForLines": "transformacje dla linii",
    "bitbybit.line.transformsForLines_description": "Stosuje wiele transformacji do wielu linii (jedna transformacja na linię). Przykład: 3 linie z 3 różnymi macierzami translacji → każda linia przesunięta niezależnie",
    "bitbybit.line.create": "linia",
    "bitbybit.line.create_description": "Tworzy linię z dwóch punktów (obiekt linii z właściwościami start i end). Przykład: start=[0,0,0], koniec=[10,5,0] → {start:[0,0,0], koniec:[10,5,0]}",
    "bitbybit.line.createAsync": "asynchronicznie",
    "createAsync": "asynchronicznie",
    "bitbybit.line.createAsync_description": "tworzy linię z punktów asynchronicznych",
    "bitbybit.line.getPointOnLine": "pobierz punkt na linii",
    "getPointOnLine": "pobierz punkt na linii",
    "bitbybit.line.getPointOnLine_description": "Oblicza punkt przy parametrze t wzdłuż odcinka linii (0=start, 1=koniec, interpolacja liniowa). Przykład: linia={start:[0,0,0], koniec:[10,0,0]}, param=0.5 → [5,0,0] (punkt środkowy)",
    "param": "parametr",
    "bitbybit.line.linesBetweenPoints": "linie między punktami",
    "linesBetweenPoints": "linie między punktami",
    "bitbybit.line.linesBetweenPoints_description": "Tworzy odcinki linii łączące kolejne punkty na liście (tworzy ścieżkę polilinii). Przykład: punkty=[[0,0,0], [5,0,0], [5,5,0]] → 2 linie: [0→5] i [5→5,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "linie między punktami startowymi i końcowymi",
    "linesBetweenStartAndEndPoints": "linie między punktami startowymi i końcowymi",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Tworzy linie poprzez sparowanie odpowiednich punktów początkowych i końcowych z dwóch tablic. Odfiltrowuje linie o zerowej długości. Przykład: starty=[[0,0,0], [5,0,0]], końce=[[0,5,0], [5,5,0]] → 2 linie łączące sparowane punkty",
    "startPoints": "punkty początkowe",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "linie między punktami startowymi i końcowymi asynchronicznie",
    "linesBetweenStartAndEndPointsAsync": "linie między punktami startowymi i końcowymi asynchronicznie",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "tworzy linie między punktami startowymi i końcowymi z danymi asynchronicznymi",
    "bitbybit.polyline.convertToNurbsCurve": "konwertuj na krzywą nurbs",
    "polyline": "polilinia",
    "bitbybit.polyline.convertToNurbsCurve_description": "konwertuje polilinię na krzywą nurbs",
    "PolylinePropertiesDto": "polyline properties dto",
    "bitbybit.polyline.length": "długość",
    "bitbybit.polyline.length_description": "Oblicza całkowitą długość polilinii sumując odległości między kolejnymi punktami. Przykład: punkty=[[0,0,0], [3,0,0], [3,4,0]] → 3 + 4 = 7",
    "bitbybit.polyline.countPoints": "liczba punktów",
    "countPoints": "liczba punktów",
    "bitbybit.polyline.countPoints_description": "Zlicza liczbę punktów w polilinii. Przykład: polilinia z punktami=[[0,0,0], [1,0,0], [1,1,0]] → 3",
    "bitbybit.polyline.getPoints": "pobierz punkty",
    "getPoints": "pobierz punkty",
    "bitbybit.polyline.getPoints_description": "Wyodrębnia tablicę punktów z obiektu polilinii. Przykład: polilinia={punkty:[[0,0,0], [1,0,0]]} → [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "odwróć polilinię",
    "bitbybit.polyline.reverse_description": "Odwraca kolejność punktów polilinii (odwraca kierunek). Przykład: punkty=[[0,0,0], [1,0,0], [2,0,0]] → [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "przekształć polilinię",
    "transformPolyline": "przekształć polilinię",
    "bitbybit.polyline.transformPolyline_description": "Stosuje macierz transformacji do wszystkich punktów w polilinii (obraca, skaluje lub przesuwa). Przykład: polilinia z 4 punktami, translacja [5,0,0] → wszystkie punkty przesunięte o +5 w kierunku X",
    "bitbybit.polyline.create": "polilinia",
    "bitbybit.polyline.create_description": "Tworzy polilinię z tablicy punktów z opcjonalną flagą isClosed. Przykład: punkty=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true → {punkty:..., isClosed:true}",
    "isClosed": "jest zamknięta",
    "string | number[]": "ciąg znaków lub tablica liczb",
    "bitbybit.occt.deleteShape": "usuń kształt",
    "occt": "occt",
    "deleteShape": "usuń kształt",
    "bitbybit.occt.deleteShape_description": "Usuwa kształt z pamięci podręcznej, aby utrzymać niskie zużycie pamięci",
    "bitbybit.occt.deleteShapes": "usuń kształty",
    "deleteShapes": "usuń kształty",
    "bitbybit.occt.deleteShapes_description": "Usuwa kształty z pamięci podręcznej, aby utrzymać niskie zużycie pamięci",
    "shapes": "kształty",
    "T[]": "tablica t",
    "bitbybit.occt.cleanAllCache": "wyczyść całą pamięć podręczną",
    "cleanAllCache": "wyczyść całą pamięć podręczną",
    "bitbybit.occt.cleanAllCache_description": "Czyści całą pamięć podręczną i wszystkie kształty z pamięci",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "wierzchołek z xyz",
    "vertex": "wierzchołek",
    "vertexFromXYZ": "wierzchołek z xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Tworzy kształt wierzchołka ze współrzędnych x y z",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "wierzchołek z punktu",
    "vertexFromPoint": "wierzchołek z punktu",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Tworzy kształt wierzchołka z punktu",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "wierzchołki z punktów",
    "verticesFromPoints": "wierzchołki z punktów",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "tworzy wierzchołki z punktów",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "złożenie wierzchołków z punktów",
    "verticesCompoundFromPoints": "złożenie wierzchołków z punktów",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Tworzy kształt złożony zawierający wiele wierzchołków. Przyspiesza to renderowanie i pozwala na łatwe stosowanie transformacji occt na grupach wierzchołków.",
    "bitbybit.occt.shapes.vertex.getVertices": "pobierz wierzchołki",
    "getVertices": "pobierz wierzchołki",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Pobiera wszystkie wierzchołki na liście kształtu",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "pobierz wierzchołki jako punkty",
    "getVerticesAsPoints": "pobierz wierzchołki jako punkty",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Pobiera wszystkie wierzchołki na liście kształtu jako punkty",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "wierzchołki na punkty",
    "verticesToPoints": "wierzchołki na punkty",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "przekształca wierzchołki na punkty",
    "transform": "transformacja",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "wierzchołek na punkt",
    "vertexToPoint": "wierzchołek na punkt",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Przekształca wierzchołek na punkt",
    "bitbybit.occt.shapes.vertex.projectPoints": "rzutuj punkty",
    "projectPoints": "rzutuj punkty",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "Rzutuj punkty na kształt i zwróć rzutowane punkty - długość wektora jest istotna",
    "place": "miejsce",
    "projectionType": "typ rzutowania",
    "pointProjectionTypeEnum": "typ rzutowania punktu enum",
    "bitbybit.occt.shapes.edge.line": "linia",
    "edge": "krawędź",
    "bitbybit.occt.shapes.edge.line_description": "tworzy liniową krawędź między dwoma punktami",
    "primitives": "prymitywy",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "łuk przez trzy punkty",
    "arcThroughThreePoints": "łuk przez trzy punkty",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Tworzy krawędź łuku między trzema punktami",
    "middle": "środek",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "łuk przez dwa punkty i styczną",
    "arcThroughTwoPointsAndTangent": "łuk przez dwa punkty i styczną",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Tworzy krawędź łuku między dwoma punktami, biorąc pod uwagę wektor kierunku stycznej w pierwszym punkcie.",
    "tangentVec": "wektor stycznej",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "łuk z okręgu i dwóch punktów",
    "arcFromCircleAndTwoPoints": "łuk z okręgu i dwóch punktów",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Tworzy krawędź łuku między dwoma punktami na okręgu",
    "circle": "okrąg",
    "sense": "zwrot",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "łuk z okręgu i dwóch kątów",
    "arcFromCircleAndTwoAngles": "łuk z okręgu i dwóch kątów",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Tworzy krawędź łuku między dwoma kątami alfa na okręgu",
    "alphaAngle1": "kąt alfa 1",
    "alphaAngle2": "kąt alfa 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "łuk z punktu okręgu i kąta",
    "arcFromCirclePointAndAngle": "łuk z punktu okręgu i kąta",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Tworzy krawędź łuku między punktem na okręgu a danym kątem alfa",
    "alphaAngle": "kąt alfa",
    "bitbybit.occt.shapes.edge.createCircleEdge": "krawędź okręgu",
    "createCircleEdge": "krawędź okręgu",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "tworzy krawędź okręgu opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "krawędź elipsy",
    "createEllipseEdge": "krawędź elipsy",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "tworzy krawędź elipsy opencascade",
    "radiusMinor": "promień mniejszy",
    "radiusMajor": "promień większy",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "usuń krawędzie wewnętrzne",
    "removeInternalEdges": "usuń krawędzie wewnętrzne",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Usuwa ściany wewnętrzne dla kształtu",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "utwórz krawędź z krzywej geom 2d i powierzchni",
    "makeEdgeFromGeom2dCurveAndSurface": "utwórz krawędź z krzywej geom 2d i powierzchni",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Tworzy krawędź z krzywej geometrycznej i powierzchni geometrycznej",
    "curve": "krzywa",
    "surface": "powierzchnia",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "pobierz krawędź",
    "getEdge": "pobierz krawędź",
    "bitbybit.occt.shapes.edge.getEdge_description": "Pobiera krawędź podając indeks z kształtu",
    "index": "indeks",
    "bitbybit.occt.shapes.edge.getEdges": "pobierz krawędzie",
    "getEdges": "pobierz krawędzie",
    "bitbybit.occt.shapes.edge.getEdges_description": "Pobiera krawędzie kształtu w liście",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "pobierz krawędzie wzdłuż konturu",
    "getEdgesAlongWire": "pobierz krawędzie wzdłuż konturu",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Pobiera krawędzie konturu uporządkowane wzdłuż kierunku konturu",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "pobierz krawędzie kołowe wzdłuż konturu",
    "getCircularEdgesAlongWire": "pobierz krawędzie kołowe wzdłuż konturu",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Pobiera krawędzie kołowe konturu uporządkowane wzdłuż kierunku konturu",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "pobierz krawędzie liniowe wzdłuż konturu",
    "getLinearEdgesAlongWire": "pobierz krawędzie liniowe wzdłuż konturu",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Pobiera krawędzie liniowe konturu uporządkowane wzdłuż kierunku konturu",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "pobierz punkty narożne krawędzi dla kształtu",
    "getCornerPointsOfEdgesForShape": "pobierz punkty narożne krawędzi dla kształtu",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Pobiera punkty narożne krawędzi dla kształtu. Nie ma tu gwarancji kolejności. Wszystkie duplikaty są usuwane, więc gdy trzy krawędzie tworzą jeden róg, będzie on reprezentowany przez pojedynczy punkt na liście.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "pobierz długość krawędzi",
    "getEdgeLength": "pobierz długość krawędzi",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Pobiera długość krawędzi",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "pobierz długości krawędzi kształtu",
    "getEdgeLengthsOfShape": "pobierz długości krawędzi kształtu",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Pobiera długości krawędzi kształtu",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "pobierz długości krawędzi",
    "getEdgesLengths": "pobierz długości krawędzi",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Pobiera długości krawędzi",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "pobierz środek masy krawędzi",
    "getEdgeCenterOfMass": "pobierz środek masy krawędzi",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Pobiera środek masy dla krawędzi",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "pobierz środki masy krawędzi",
    "getEdgesCentersOfMass": "pobierz środki masy krawędzi",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Pobiera środki masy dla krawędzi",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "pobierz punkt środkowy krawędzi kołowej",
    "getCircularEdgeCenterPoint": "pobierz punkt środkowy krawędzi kołowej",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Pobiera punkt środkowy krawędzi kołowej. Jeśli krawędź nie jest kołowa, punkt nie zostanie zwrócony.",
    "get circular edge": "pobierz krawędź kołową",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "pobierz promień krawędzi kołowej",
    "getCircularEdgeRadius": "pobierz promień krawędzi kołowej",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Pobiera promień krawędzi kołowej. Jeśli krawędź nie jest kołowa, promień nie zostanie zwrócony.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "pobierz kierunek płaszczyzny krawędzi kołowej",
    "getCircularEdgePlaneDirection": "pobierz kierunek płaszczyzny krawędzi kołowej",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Pobiera wektor kierunku płaszczyzny krawędzi kołowej. Jeśli krawędź nie jest kołowa, wektor kierunku nie zostanie zwrócony.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "punkt na krawędzi przy parametrze",
    "pointOnEdgeAtParam": "punkt na krawędzi przy parametrze",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Pobiera punkt na krawędzi przy zadanym parametrze",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "punkty na krawędziach przy parametrze",
    "pointsOnEdgesAtParam": "punkty na krawędziach przy parametrze",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Pobiera punkty na krawędziach przy zadanym parametrze",
    "bitbybit.occt.shapes.edge.edgesToPoints": "krawędzie na punkty",
    "edgesToPoints": "krawędzie na punkty",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Pobiera punkty wszystkich krawędzi z kształtu w oddzielnych listach dla każdej krawędzi",
    "angularDeflection": "odchylenie kątowe",
    "curvatureDeflection": "odchylenie krzywizny",
    "minimumOfPoints": "minimum punktów",
    "uTolerance": "tolerancja u",
    "minimumLength": "minimalna długość",
    "bitbybit.occt.shapes.edge.reversedEdge": "odwrócona krawędź",
    "reversedEdge": "odwrócona krawędź",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Oblicza odwróconą krawędź z krawędzi wejściowej",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "styczna na krawędzi przy parametrze",
    "tangentOnEdgeAtParam": "styczna na krawędzi przy parametrze",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Pobiera wektor styczny na krawędzi przy zadanym parametrze",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "styczne na krawędziach przy parametrze",
    "tangentsOnEdgesAtParam": "styczne na krawędziach przy parametrze",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Pobiera wektory styczne na krawędziach przy zadanym parametrze",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "punkt na krawędzi przy długości",
    "pointOnEdgeAtLength": "punkt na krawędzi przy długości",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Pobiera punkt na krawędzi przy zadanej długości",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "punkty na krawędziach przy długości",
    "pointsOnEdgesAtLength": "punkty na krawędziach przy długości",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Pobiera punkty na krawędziach przy zadanej długości",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "styczna na krawędzi przy długości",
    "tangentOnEdgeAtLength": "styczna na krawędzi przy długości",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Pobiera wektor styczny na krawędzi przy zadanej długości",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "styczne na krawędziach przy długości",
    "tangentsOnEdgesAtLength": "styczne na krawędziach przy długości",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Pobiera wektory styczne na krawędziach przy zadanej długości",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "punkt początkowy na krawędzi",
    "startPointOnEdge": "punkt początkowy na krawędzi",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Pobiera punkt początkowy na krawędzi",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "punkty początkowe na krawędziach",
    "startPointsOnEdges": "punkty początkowe na krawędziach",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Pobiera punkty początkowe na krawędziach",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "punkt końcowy na krawędzi",
    "endPointOnEdge": "punkt końcowy na krawędzi",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Pobiera punkt końcowy na krawędzi",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "punkty końcowe na krawędziach",
    "endPointsOnEdges": "punkty końcowe na krawędziach",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Pobiera punkty końcowe na krawędziach",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "podziel krawędź parametrami na punkty",
    "divideEdgeByParamsToPoints": "podziel krawędź parametrami na punkty",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "dzieli krawędź parametrami na punkty",
    "nrOfDivisions": "liczba podziałów",
    "removeStartPoint": "usuń punkt początkowy",
    "removeEndPoint": "usuń punkt końcowy",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "podziel krawędzie parametrami na punkty",
    "divideEdgesByParamsToPoints": "podziel krawędzie parametrami na punkty",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "dzieli krawędzie parametrami na punkty",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "podziel krawędź równą odległością na punkty",
    "divideEdgeByEqualDistanceToPoints": "podziel krawędź równą odległością na punkty",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "dzieli krawędź długością na punkty",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "podziel krawędzie równą odległością na punkty",
    "divideEdgesByEqualDistanceToPoints": "podziel krawędzie równą odległością na punkty",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "dzieli krawędzie długością na punkty",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "linie styczne z ograniczeniem od dwóch pkt do okręgu",
    "constraintTanLinesFromTwoPtsToCircle": "linie styczne z ograniczeniem od dwóch pkt do okręgu",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Tworzy linie od dwóch danych punktów do miejsc styczności z okręgiem",
    "constraint": "ograniczenie",
    "point1": "punkt 1",
    "point2": "punkt 2",
    "positionResult": "wynik pozycji",
    "positionResultEnum": "wynik pozycji enum",
    "circleRemainder": "reszta okręgu",
    "circleInclusionEnum": "zawieranie okręgu enum",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "linie styczne z ograniczeniem od pkt do okręgu",
    "constraintTanLinesFromPtToCircle": "linie styczne z ograniczeniem od pkt do okręgu",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Tworzy linie od danego punktu do miejsc styczności z okręgiem",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "linie styczne z ograniczeniem na dwóch okręgach",
    "constraintTanLinesOnTwoCircles": "linie styczne z ograniczeniem na dwóch okręgach",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Tworzy linie styczne między dwoma okręgami.",
    "circle1": "okrąg 1",
    "circle2": "okrąg 2",
    "circleRemainders": "reszty okręgu",
    "twoCircleInclusionEnum": "zawieranie dwóch okręgów enum",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "okręgi styczne z ograniczeniem na dwóch okręgach",
    "constraintTanCirclesOnTwoCircles": "okręgi styczne z ograniczeniem na dwóch okręgach",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Tworzy okręgi styczne między dwoma okręgami.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "okręgi styczne z ograniczeniem na okręgu i pkt",
    "constraintTanCirclesOnCircleAndPnt": "okręgi styczne z ograniczeniem na okręgu i pkt",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Tworzy okręgi styczne między punktem a okręgiem.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "czy krawędź jest liniowa",
    "isEdgeLinear": "czy krawędź jest liniowa",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Sprawdza, czy krawędź jest liniowa",
    "is": "czy",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "czy krawędź jest kołowa",
    "isEdgeCircular": "czy krawędź jest kołowa",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Sprawdza, czy krawędź jest kołowa",
    "bitbybit.occt.shapes.wire.createPolygonWire": "kontur wielokąta",
    "wire": "kontur",
    "createPolygonWire": "kontur wielokąta",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "tworzy kontur wielokąta opencascade",
    "via points": "przez punkty",
    "bitbybit.occt.shapes.wire.createPolygons": "wielokąty",
    "createPolygons": "wielokąty",
    "bitbybit.occt.shapes.wire.createPolygons_description": "tworzy wielokąty opencascade",
    "multiple": "wiele",
    "polygons": "wielokąty",
    "PolygonDto[]": "tablica polygon dto",
    "returnCompound": "zwróć złożenie",
    "bitbybit.occt.shapes.wire.createLineWire": "kontur linii",
    "createLineWire": "kontur linii",
    "bitbybit.occt.shapes.wire.createLineWire_description": "tworzy kontur linii opencascade",
    "bitbybit.occt.shapes.wire.createLines": "linie",
    "createLines": "linie",
    "bitbybit.occt.shapes.wire.createLines_description": "tworzy linie opencascade",
    "LineDto[]": "tablica line dto",
    "bitbybit.occt.shapes.wire.splitOnPoints": "podziel na punktach",
    "splitOnPoints": "podziel na punktach",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Dzieli kontur na zadanym zestawie punktów",
    "bitbybit.occt.shapes.wire.wiresToPoints": "kontury na punkty",
    "wiresToPoints": "kontury na punkty",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Przekształca kontury kształtu na punkty uporządkowane w listach. Usuwa również zduplikowane punkty między punktami początkowymi i końcowymi kolejnych krawędzi na konturze",
    "bitbybit.occt.shapes.wire.createPolylineWire": "kontur polilinii",
    "createPolylineWire": "kontur polilinii",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "tworzy kontur polilinii opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zygzak między dwoma konturami",
    "createZigZagBetweenTwoWires": "zygzak między dwoma konturami",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "tworzy zygzak między dwoma konturami",
    "via wires": "przez kontury",
    "wire1": "kontur 1",
    "wire2": "kontur 2",
    "nrZigZags": "liczba zygzaków",
    "inverse": "odwróć",
    "divideByEqualDistance": "podziel równą odległością",
    "zigZagsPerEdge": "zygzaki na krawędź",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "kontur styczny z dwóch okręgów",
    "createWireFromTwoCirclesTan": "kontur styczny z dwóch okręgów",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Tworzy styczny kontur otaczający dwa płaskie okręgi",
    "keepLines": "zachowaj linie",
    "twoSidesStrictEnum": "dwie strony ścisłe enum",
    "fourSidesStrictEnum": "cztery strony ścisłe enum",
    "bitbybit.occt.shapes.wire.createPolylines": "polilinie",
    "createPolylines": "polilinie",
    "bitbybit.occt.shapes.wire.createPolylines_description": "tworzy kontury polilinii opencascade",
    "polylines": "polilinie",
    "PolylineDto[]": "tablica polyline dto",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "tworzy kontur beziera opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "wagi beziera",
    "createBezierWeights": "wagi beziera",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "tworzy kontur beziera opencascade z wagami",
    "weights": "wagi",
    "bitbybit.occt.shapes.wire.createBezierWires": "kontury beziera",
    "createBezierWires": "kontury beziera",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "tworzy kontury beziera opencascade",
    "bezierWires": "kontury beziera",
    "BezierDto[]": "tablica bezier dto",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpoluj punkty",
    "interpolatePoints": "interpoluj punkty",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Tworzy kontur BSpline OpenCascade z punktów. Tej metody można użyć do tworzenia ładnie ukształtowanych (okresowych) pętli.",
    "periodic": "okresowy",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpoluj kontury",
    "interpolateWires": "interpoluj kontury",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Tworzy wiele interpolowanych konturów OpenCascade",
    "interpolations": "interpolacje",
    "InterpolationDto[]": "tablica interpolation dto",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "tworzy kontur bspline opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "tworzy kontury bspline opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "tablica bspline dto",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "połącz krawędzie i kontury w kontur",
    "combineEdgesAndWiresIntoAWire": "połącz krawędzie i kontury w kontur",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Łączy krawędzie i kontury OpenCascade w jeden kontur",
    "build": "buduj",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "kontur z krawędzi",
    "createWireFromEdge": "kontur z krawędzi",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "tworzy kontur z krawędzi",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "dodaj krawędzie i kontury do konturu",
    "addEdgesAndWiresToWire": "dodaj krawędzie i kontury do konturu",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Dodaje krawędzie i kontury OpenCascade do innego konturu",
    "U[]": "tablica u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "podziel kontur parametrami na punkty",
    "divideWireByParamsToPoints": "podziel kontur parametrami na punkty",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Dzieli kontur OpenCascade na punkty ślepo podążając za jego przestrzenią parametryczną",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "podziel kontury parametrami na punkty",
    "divideWiresByParamsToPoints": "podziel kontury parametrami na punkty",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Dzieli kontury OpenCascade na punkty ślepo podążając za ich przestrzenią parametryczną",
    "extract from wires": "wyodrębnij z konturów",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "podziel kontur równą odległością na punkty",
    "divideWireByEqualDistanceToPoints": "podziel kontur równą odległością na punkty",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Dzieli kontur OpenCascade na punkty w równej odległości",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "podziel kontury równą odległością na punkty",
    "divideWiresByEqualDistanceToPoints": "podziel kontury równą odległością na punkty",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Dzieli kontury OpenCascade na punkty w równej odległości",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "punkt na konturze przy parametrze",
    "pointOnWireAtParam": "punkt na konturze przy parametrze",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Oblicza punkt na konturze przy wartości parametru między 0 a 1, będącymi punktami początkowym i końcowym",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "punkt na konturze przy długości",
    "pointOnWireAtLength": "punkt na konturze przy długości",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Oblicza punkt na konturze przy określonej długości",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "punkty na konturze przy długościach",
    "pointsOnWireAtLengths": "punkty na konturze przy długościach",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Oblicza punkty na konturze przy określonych długościach",
    "lengths": "długości",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "punkty na konturze przy równej długości",
    "pointsOnWireAtEqualLength": "punkty na konturze przy równej długości",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Oblicza punkty na konturze przy równej długości",
    "tryNext": "spróbuj następny",
    "includeFirst": "uwzględnij pierwszy",
    "includeLast": "uwzględnij ostatni",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "punkty na konturze przy wzorcu długości",
    "pointsOnWireAtPatternOfLengths": "punkty na konturze przy wzorcu długości",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Oblicza punkty na konturze według wzorca długości",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "styczna na konturze przy parametrze",
    "tangentOnWireAtParam": "styczna na konturze przy parametrze",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Oblicza wektor styczny na konturze przy wartości parametru między 0 a 1, będącymi punktami początkowym i końcowym",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "styczna na konturze przy długości",
    "tangentOnWireAtLength": "styczna na konturze przy długości",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Oblicza wektor styczny na konturze przy określonej długości",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "pochodne na konturze przy długości",
    "derivativesOnWireAtLength": "pochodne na konturze przy długości",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Oblicza 3 wektory pochodne krzywej przy danej długości",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "pochodne na konturze przy parametrze",
    "derivativesOnWireAtParam": "pochodne na konturze przy parametrze",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Oblicza 3 wektory pochodne krzywej na parametrze między 0 a 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "punkt początkowy na konturze",
    "startPointOnWire": "punkt początkowy na konturze",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Oblicza punkt początkowy na konturze przy parametrze 0",
    "bitbybit.occt.shapes.wire.endPointOnWire": "punkt końcowy na konturze",
    "endPointOnWire": "punkt końcowy na konturze",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Oblicza punkt końcowy na konturze przy parametrze 1",
    "bitbybit.occt.shapes.wire.createCircleWire": "kontur kołowy",
    "createCircleWire": "kontur kołowy",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "tworzy kontur kołowy opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "kontur kwadratowy",
    "createSquareWire": "kontur kwadratowy",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "tworzy kontur kwadratowy opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "kontur gwiazdy",
    "createStarWire": "kontur gwiazdy",
    "bitbybit.occt.shapes.wire.createStarWire_description": "tworzy kontur gwiazdy opencascade",
    "numRays": "liczba promieni",
    "outerRadius": "promień zewnętrzny",
    "innerRadius": "promień wewnętrzny",
    "offsetOuterEdges": "przesunięcie krawędzi zewnętrznych",
    "half": "połowa",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "kontur choinki",
    "createChristmasTreeWire": "kontur choinki",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "tworzy kontur choinki",
    "innerDist": "dystans wewnętrzny",
    "outerDist": "dystans zewnętrzny",
    "nrSkirts": "liczba warstw",
    "trunkHeight": "wysokość pnia",
    "trunkWidth": "szerokość pnia",
    "bitbybit.occt.shapes.wire.createNGonWire": "kontur n-kąta",
    "createNGonWire": "kontur n-kąta",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Tworzy kontur n-kąta OpenCascade",
    "nrCorners": "liczba narożników",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "kontur równoległoboku",
    "createParallelogramWire": "kontur równoległoboku",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Tworzy kontur równoległoboku",
    "aroundCenter": "wokół środka",
    "bitbybit.occt.shapes.wire.createHeartWire": "kontur serca",
    "createHeartWire": "kontur serca",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Tworzy kontur serca",
    "sizeApprox": "rozmiar przybliżony",
    "bitbybit.occt.shapes.wire.createRectangleWire": "kontur prostokąta",
    "createRectangleWire": "kontur prostokąta",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "tworzy kontur prostokąta opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "kontur wielokąta L",
    "createLPolygonWire": "kontur wielokąta L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "tworzy kontur wielokąta L opencascade",
    "widthFirst": "szerokość pierwsza",
    "lengthFirst": "długość pierwsza",
    "widthSecond": "szerokość druga",
    "lengthSecond": "długość druga",
    "align": "wyrównaj",
    "directionEnum": "kierunek enum",
    "bitbybit.occt.shapes.wire.createEllipseWire": "kontur elipsy",
    "createEllipseWire": "kontur elipsy",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "tworzy kontur elipsy opencascade",
    "bitbybit.occt.shapes.wire.textWires": "kontury tekstu",
    "textWires": "kontury tekstu",
    "bitbybit.occt.shapes.wire.textWires_description": "Tworzy kontury tekstu OpenCascade w oparciu o czcionkę simplex stworzoną przez dr. A. V. Hersheya",
    "xOffset": "przesunięcie x",
    "yOffset": "przesunięcie y",
    "letterSpacing": "odstępy między literami",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "przesunięcie wyciągnięcia",
    "bitbybit.occt.shapes.wire.getWire": "pobierz kontur",
    "getWire": "pobierz kontur",
    "bitbybit.occt.shapes.wire.getWire_description": "Pobiera kontur podając indeks z kształtu",
    "bitbybit.occt.shapes.wire.getWires": "pobierz kontury",
    "getWires": "pobierz kontury",
    "bitbybit.occt.shapes.wire.getWires_description": "Pobiera wszystkie kontury z kształtu",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "pobierz środek masy konturu",
    "getWireCenterOfMass": "pobierz środek masy konturu",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Pobierz punkt środka masy konturu",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "pobierz środki masy konturów",
    "getWiresCentersOfMass": "pobierz środki masy konturów",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Pobierz punkty środków masy konturów",
    "bitbybit.occt.shapes.wire.reversedWire": "odwrócony kontur",
    "reversedWire": "odwrócony kontur",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Oblicza odwrócony kontur z konturu wejściowego",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "odwrócony kontur z odwróconych krawędzi",
    "reversedWireFromReversedEdges": "odwrócony kontur z odwróconych krawędzi",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Oblicza odwrócony kontur poprzez odwrócenie wszystkich krawędzi i połączenie ich w nowy kontur",
    "bitbybit.occt.shapes.wire.isWireClosed": "czy kontur jest zamknięty",
    "isWireClosed": "czy kontur jest zamknięty",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Sprawdza czy kontur jest zamknięty",
    "bitbybit.occt.shapes.wire.getWireLength": "pobierz długość konturu",
    "getWireLength": "pobierz długość konturu",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Pobiera długość konturu",
    "bitbybit.occt.shapes.wire.getWiresLengths": "pobierz długości konturów",
    "getWiresLengths": "pobierz długości konturów",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Pobiera długości konturów",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "umieść kontur na ścianie",
    "placeWireOnFace": "umieść kontur na ścianie",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Umieszcza kontur na ścianie poprzez mapowanie jego współrzędnych 2d na przestrzeń UV. Aby to zadziałało, kontur musi być umieszczony na płaszczyźnie podłoża XZ.",
    "face": "ściana",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "umieść kontury na ścianie",
    "placeWiresOnFace": "umieść kontury na ścianie",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Umieszcza wiele konturów na ścianie poprzez mapowanie ich współrzędnych 2d na przestrzeń UV. Aby to zadziałało, kontury muszą być umieszczone na płaszczyźnie podłoża XZ.",
    "wires": "kontury",
    "bitbybit.occt.shapes.wire.closeOpenWire": "zamknij otwarty kontur",
    "closeOpenWire": "zamknij otwarty kontur",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Zamyka otwarty kontur dodatkową prostą krawędzią łączącą punkty początkowy i końcowy",
    "bitbybit.occt.shapes.wire.project": "rzutuj",
    "project": "rzutuj",
    "bitbybit.occt.shapes.wire.project_description": "Rzutuj kontur na kształt",
    "bitbybit.occt.shapes.wire.projectWires": "rzutuj kontury",
    "projectWires": "rzutuj kontury",
    "bitbybit.occt.shapes.wire.projectWires_description": "Rzutuj wiele konturów na kształt",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "ściany z konturów na ścianie",
    "createFacesFromWiresOnFace": "ściany z konturów na ścianie",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Tworzy ściany z konturów na ścianie",
    "inside": "wewnątrz",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "ściana z konturu na ścianie",
    "createFaceFromWireOnFace": "ściana z konturu na ścianie",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Tworzy ścianę z konturu na ścianie",
    "bitbybit.occt.shapes.face.createFaceFromWire": "ściana z konturu",
    "createFaceFromWire": "ściana z konturu",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Tworzy ścianę z konturu",
    "planar": "płaski",
    "bitbybit.occt.shapes.face.createFaceFromWires": "ściana z konturów",
    "createFaceFromWires": "ściana z konturów",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Tworzy ścianę z konturów. Może to tworzyć puste ściany (z otworami).",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "ściana z konturów na ścianie",
    "createFaceFromWiresOnFace": "ściana z konturów na ścianie",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Tworzy ścianę z konturów na ścianie prowadzącej. Może to tworzyć puste ściany (z otworami).",
    "bitbybit.occt.shapes.face.createFacesFromWires": "ściany z konturów",
    "createFacesFromWires": "ściany z konturów",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "tworzy ściany z konturów",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "ściana z wielu konturów stycznych kołowo",
    "createFaceFromMultipleCircleTanWires": "ściana z wielu konturów stycznych kołowo",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "tworzy ścianę z wielu konturów stycznych kołowo",
    "circles": "okręgi",
    "combination": "kombinacja",
    "combinationCirclesForFaceEnum": "kombinacja okręgów dla ściany enum",
    "unify": "unifikuj",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "ściana z kolekcji wielu konturów stycznych kołowo",
    "createFaceFromMultipleCircleTanWireCollections": "ściana z kolekcji wielu konturów stycznych kołowo",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "tworzy ścianę z kolekcji wielu konturów stycznych kołowo",
    "listsOfCircles": "listy okręgów",
    "T[][]": "tablica tablic t",
    "bitbybit.occt.shapes.face.faceFromSurface": "ściana z powierzchni",
    "faceFromSurface": "ściana z powierzchni",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Tworzy ścianę z powierzchni",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "ściana z powierzchni i konturu",
    "faceFromSurfaceAndWire": "ściana z powierzchni i konturu",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Tworzy ścianę z powierzchni i konturu",
    "bitbybit.occt.shapes.face.createPolygonFace": "ściana wielokątna",
    "createPolygonFace": "ściana wielokątna",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "tworzy ścianę wielokątną opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "ściana kołowa",
    "createCircleFace": "ściana kołowa",
    "bitbybit.occt.shapes.face.createCircleFace_description": "tworzy ścianę kołową opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "ściana eliptyczna",
    "createEllipseFace": "ściana eliptyczna",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "tworzy ścianę eliptyczną opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "ściana kwadratowa",
    "createSquareFace": "ściana kwadratowa",
    "bitbybit.occt.shapes.face.createSquareFace_description": "tworzy ścianę kwadratową opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "ściana prostokątna",
    "createRectangleFace": "ściana prostokątna",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "tworzy ścianę prostokątną opencascade",
    "bitbybit.occt.shapes.face.getFace": "pobierz ścianę",
    "getFace": "pobierz ścianę",
    "bitbybit.occt.shapes.face.getFace_description": "Pobiera ścianę podając indeks z kształtu",
    "bitbybit.occt.shapes.face.getFaces": "pobierz ściany",
    "getFaces": "pobierz ściany",
    "bitbybit.occt.shapes.face.getFaces_description": "Pobiera ściany kształtu w liście",
    "bitbybit.occt.shapes.face.reversedFace": "odwrócona ściana",
    "reversedFace": "odwrócona ściana",
    "bitbybit.occt.shapes.face.reversedFace_description": "Oblicza odwróconą ścianę ze ściany wejściowej",
    "bitbybit.occt.shapes.face.subdivideToPoints": "podziel na punkty",
    "subdivideToPoints": "podziel na punkty",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Dzieli ścianę na siatkę punktów",
    "nrDivisionsU": "liczba podziałów u",
    "nrDivisionsV": "liczba podziałów v",
    "shiftHalfStepU": "przesuń pół kroku u",
    "removeStartEdgeU": "usuń krawędź początkową u",
    "removeEndEdgeU": "usuń krawędź końcową u",
    "shiftHalfStepV": "przesuń pół kroku v",
    "removeStartEdgeV": "usuń krawędź początkową v",
    "removeEndEdgeV": "usuń krawędź końcową v",
    "bitbybit.occt.shapes.face.subdivideToWires": "podziel na kontury",
    "subdivideToWires": "podziel na kontury",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Dzieli ścianę na kontury",
    "nrDivisions": "liczba podziałów",
    "isU": "jest u",
    "shiftHalfStep": "przesuń pół kroku",
    "removeStart": "usuń początek",
    "removeEnd": "usuń koniec",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "podziel na kontury prostokątne",
    "subdivideToRectangleWires": "podziel na kontury prostokątne",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Dzieli ścianę na kontury prostokątne",
    "patterns": "wzory",
    "nrRectanglesU": "liczba prostokątów u",
    "nrRectanglesV": "liczba prostokątów v",
    "scalePatternU": "skaluj wzór u",
    "scalePatternV": "skaluj wzór v",
    "filletPattern": "wzór zaokrąglenia",
    "inclusionPattern": "wzór inkluzji",
    "offsetFromBorderU": "przesunięcie od granicy u",
    "offsetFromBorderV": "przesunięcie od granicy v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "podziel na otwory prostokątne",
    "subdivideToRectangleHoles": "podziel na otwory prostokątne",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Dzieli ścianę na kontury prostokątne (otwory)",
    "holesToFaces": "otwory na ściany",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "podziel na punkty kontrolowane",
    "subdivideToPointsControlled": "podziel na punkty kontrolowane",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Dzieli ścianę na siatkę punktów z przesunięciami i usuwaniem w n-tych rzędach lub kolumnach uv",
    "shiftHalfStepNthU": "przesuń pół kroku n-te u",
    "shiftHalfStepUOffsetN": "przesuń pół kroku u offset n",
    "removeStartEdgeNthU": "usuń krawędź początkową n-tą u",
    "removeStartEdgeUOffsetN": "usuń krawędź początkową u offset n",
    "removeEndEdgeNthU": "usuń krawędź końcową n-tą u",
    "removeEndEdgeUOffsetN": "usuń krawędź końcową u offset n",
    "shiftHalfStepNthV": "przesuń pół kroku n-te v",
    "shiftHalfStepVOffsetN": "przesuń pół kroku v offset n",
    "removeStartEdgeNthV": "usuń krawędź początkową n-tą v",
    "removeStartEdgeVOffsetN": "usuń krawędź początkową v offset n",
    "removeEndEdgeNthV": "usuń krawędź końcową n-tą v",
    "removeEndEdgeVOffsetN": "usuń krawędź końcową v offset n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "podziel na normalne",
    "subdivideToNormals": "podziel na normalne",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Dzieli ścianę na siatkę normalnych",
    "bitbybit.occt.shapes.face.subdivideToUV": "podziel na uv",
    "subdivideToUV": "podziel na uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Dzieli ścianę na siatkę uv",
    "bitbybit.occt.shapes.face.pointOnUV": "punkt na uv",
    "pointOnUV": "punkt na uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Pobierz punkt na UV, gdzie U i V są opisane między 0 a 1. Zostaną one zmapowane na rzeczywiste granice.",
    "paramU": "parametr u",
    "paramV": "parametr v",
    "bitbybit.occt.shapes.face.normalOnUV": "normalna na uv",
    "normalOnUV": "normalna na uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Pobierz normalną na UV, gdzie U i V są opisane między 0 a 1. Zostaną one zmapowane na rzeczywiste granice.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "punkty na uv",
    "pointsOnUVs": "punkty na uv",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Pobierz punkty na UV, gdzie U i V są opisane między 0 a 1 w dwuwymiarowych tablicach. Zostaną one zmapowane na rzeczywiste granice.",
    "paramsUV": "parametry uv",
    "[number, number][]": "tablica par liczb",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normalne na uv",
    "normalsOnUVs": "normalne na uv",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Pobierz normalne na UV, gdzie U i V są opisane między 0 a 1 w dwuwymiarowych tablicach. Zostaną one zmapowane na rzeczywiste granice.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "podziel na punkty na parametrze",
    "subdivideToPointsOnParam": "podziel na punkty na parametrze",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Dzieli ścianę na punkty wzdłuż linii parametru",
    "nrPoints": "liczba punktów",
    "bitbybit.occt.shapes.face.wireAlongParam": "kontur wzdłuż parametru",
    "wireAlongParam": "kontur wzdłuż parametru",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Pobiera kontur wzdłuż parametru na ścianie",
    "bitbybit.occt.shapes.face.wiresAlongParams": "kontury wzdłuż parametrów",
    "wiresAlongParams": "kontury wzdłuż parametrów",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Pobiera kontury wzdłuż parametrów na ścianie",
    "params": "parametry",
    "bitbybit.occt.shapes.face.getUMinBound": "pobierz minimalną granicę u",
    "getUMinBound": "pobierz minimalną granicę u",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Pobiera minimalną granicę U ściany",
    "bitbybit.occt.shapes.face.getUMaxBound": "pobierz maksymalną granicę u",
    "getUMaxBound": "pobierz maksymalną granicę u",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Pobiera maksymalną granicę U ściany",
    "bitbybit.occt.shapes.face.getVMinBound": "pobierz minimalną granicę v",
    "getVMinBound": "pobierz minimalną granicę v",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Pobiera minimalną granicę V ściany",
    "bitbybit.occt.shapes.face.getVMaxBound": "pobierz maksymalną granicę v",
    "getVMaxBound": "pobierz maksymalną granicę v",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Pobiera maksymalną granicę V ściany",
    "bitbybit.occt.shapes.face.getFaceArea": "pobierz pole powierzchni ściany",
    "getFaceArea": "pobierz pole powierzchni ściany",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Pobierz pole powierzchni ściany",
    "bitbybit.occt.shapes.face.getFacesAreas": "pobierz pola powierzchni ścian",
    "getFacesAreas": "pobierz pola powierzchni ścian",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Pobierz pola powierzchni ścian",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "pobierz środek masy ściany",
    "getFaceCenterOfMass": "pobierz środek masy ściany",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Pobierz punkt środka masy ściany",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "pobierz środki masy ścian",
    "getFacesCentersOfMass": "pobierz środki masy ścian",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Pobierz punkty środków masy dla ścian",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtruj punkty ściany",
    "filterFacePoints": "filtruj punkty ściany",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtruje punkty na ścianie",
    "filter": "filtr",
    "useBndBox": "użyj bnd box",
    "gapTolerance": "tolerancja luki",
    "keepIn": "zachowaj wewnątrz",
    "keepOn": "zachowaj na",
    "keepOut": "zachowaj na zewnątrz",
    "keepUnknown": "zachowaj nieznane",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtruj punkty ścian",
    "filterFacesPoints": "filtruj punkty ścian",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtruje punkty na ścianach",
    "flatPointsArray": "płaska tablica punktów",
    "bitbybit.occt.shapes.shell.sewFaces": "zszyj ściany",
    "shell": "powłoka",
    "sewFaces": "zszyj ściany",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Tworzy powłokę ze ścian",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "pobierz pole powierzchni powłoki",
    "getShellSurfaceArea": "pobierz pole powierzchni powłoki",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Pobierz pole powierzchni powłoki",
    "bitbybit.occt.shapes.solid.fromClosedShell": "z zamkniętej powłoki",
    "solid": "bryła",
    "fromClosedShell": "z zamkniętej powłoki",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Tworzy bryłę z powłoki, która musi być zamknięta",
    "bitbybit.occt.shapes.solid.createBox": "pudełko",
    "bitbybit.occt.shapes.solid.createBox_description": "tworzy pudełko opencascade",
    "originOnCenter": "początek na środku",
    "bitbybit.occt.shapes.solid.createCube": "sześcian",
    "bitbybit.occt.shapes.solid.createCube_description": "tworzy sześcian opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "pudełko z narożnika",
    "createBoxFromCorner": "pudełko z narożnika",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "tworzy pudełko opencascade z narożnika",
    "corner": "narożnik",
    "bitbybit.occt.shapes.solid.createCylinder": "walec",
    "bitbybit.occt.shapes.solid.createCylinder_description": "tworzy walec opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "walce na liniach",
    "createCylindersOnLines": "walce na liniach",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Tworzy walce OpenCascade na prostych liniach bit by bit reprezentowanych przez dwa punkty",
    "Base.Line3[]": "tablica base line3",
    "bitbybit.occt.shapes.solid.createSphere": "kula",
    "bitbybit.occt.shapes.solid.createSphere_description": "tworzy kulę opencascade",
    "bitbybit.occt.shapes.solid.createCone": "stożek",
    "createCone": "stożek",
    "bitbybit.occt.shapes.solid.createCone_description": "tworzy stożek opencascade",
    "radius1": "promień 1",
    "radius2": "promień 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "pobierz pole powierzchni bryły",
    "getSolidSurfaceArea": "pobierz pole powierzchni bryły",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Pobierz pole powierzchni bryły",
    "bitbybit.occt.shapes.solid.getSolidVolume": "pobierz objętość bryły",
    "getSolidVolume": "pobierz objętość bryły",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Pobierz objętość bryły",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "pobierz objętości brył",
    "getSolidsVolumes": "pobierz objętości brył",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Pobierz objętości brył",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "pobierz środek masy bryły",
    "getSolidCenterOfMass": "pobierz środek masy bryły",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Pobierz środek masy bryły",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "pobierz środki masy brył",
    "getSolidsCentersOfMass": "pobierz środki masy brył",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Pobierz środki masy brył",
    "bitbybit.occt.shapes.solid.getSolids": "pobierz bryły",
    "getSolids": "pobierz bryły",
    "bitbybit.occt.shapes.solid.getSolids_description": "Pobiera bryły kształtu w liście",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtruj punkty bryły",
    "filterSolidPoints": "filtruj punkty bryły",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Filtruje kolekcję punktów na podstawie relacji z bryłą. Możesz wybrać, czy wyprowadzać punkty wewnątrz (in), na (on) czy na zewnątrz (out).",
    "bitbybit.occt.shapes.compound.makeCompound": "utwórz złożenie",
    "compound": "złożenie",
    "makeCompound": "utwórz złożenie",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Tworzy kształt złożony, który może zawierać dowolne rodzaje kształtów",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "pobierz kształty złożenia",
    "getShapesOfCompound": "pobierz kształty złożenia",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Pobiera kształty, z których składa się złożenie",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "usuń krawędzie wewnętrzne",
    "purgeInternalEdges": "usuń krawędzie wewnętrzne",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Usuń krawędzie wewnętrzne, które nie są połączone z żadną ścianą w kształcie",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unifikuj tę samą domenę",
    "unifySameDomain": "unifikuj tę samą domenę",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Unifikuje ściany, krawędzie w tej samej domenie i ma możliwość łączenia bspline",
    "unifyEdges": "unifikuj krawędzie",
    "unifyFaces": "unifikuj ściany",
    "concatBSplines": "połącz bspline",
    "bitbybit.occt.shapes.shape.isClosed": "jest zamknięty",
    "bitbybit.occt.shapes.shape.isClosed_description": "Sprawdź, czy kształt jest zamknięty",
    "analysis": "analiza",
    "bitbybit.occt.shapes.shape.isConvex": "jest wypukły",
    "isConvex": "jest wypukły",
    "bitbybit.occt.shapes.shape.isConvex_description": "Sprawdź, czy kształt jest wypukły",
    "bitbybit.occt.shapes.shape.isChecked": "jest sprawdzony",
    "bitbybit.occt.shapes.shape.isChecked_description": "Sprawdź, czy kształt jest sprawdzony",
    "bitbybit.occt.shapes.shape.isFree": "jest wolny",
    "isFree": "jest wolny",
    "bitbybit.occt.shapes.shape.isFree_description": "Sprawdź, czy kształt jest wolny",
    "bitbybit.occt.shapes.shape.isInfinite": "jest nieskończony",
    "isInfinite": "jest nieskończony",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Sprawdź, czy kształt jest nieskończony",
    "bitbybit.occt.shapes.shape.isModified": "jest zmodyfikowany",
    "isModified": "jest zmodyfikowany",
    "bitbybit.occt.shapes.shape.isModified_description": "Sprawdź, czy kształt jest zmodyfikowany",
    "bitbybit.occt.shapes.shape.isLocked": "jest zablokowany",
    "isLocked": "jest zablokowany",
    "bitbybit.occt.shapes.shape.isLocked_description": "Sprawdź, czy kształt jest zablokowany",
    "bitbybit.occt.shapes.shape.isNull": "jest null",
    "isNull": "jest null",
    "bitbybit.occt.shapes.shape.isNull_description": "Sprawdź, czy kształt jest null",
    "bitbybit.occt.shapes.shape.isEqual": "jest równy",
    "isEqual": "jest równy",
    "bitbybit.occt.shapes.shape.isEqual_description": "Sprawdź, czy kształt jest równy innemu kształtowi",
    "otherShape": "inny kształt",
    "bitbybit.occt.shapes.shape.isNotEqual": "nie jest równy",
    "isNotEqual": "nie jest równy",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Sprawdź, czy kształt nie jest równy innemu kształtowi",
    "bitbybit.occt.shapes.shape.isPartner": "jest partnerem",
    "isPartner": "jest partnerem",
    "bitbybit.occt.shapes.shape.isPartner_description": "Sprawdź, czy kształt jest partnerem innego kształtu",
    "bitbybit.occt.shapes.shape.isSame": "jest taki sam",
    "isSame": "jest taki sam",
    "bitbybit.occt.shapes.shape.isSame_description": "Sprawdź, czy kształt jest taki sam jak inny kształt",
    "bitbybit.occt.shapes.shape.getOrientation": "pobierz orientację",
    "getOrientation": "pobierz orientację",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Pobierz orientację kształtu",
    "bitbybit.occt.shapes.shape.getShapeType": "pobierz typ kształtu",
    "getShapeType": "pobierz typ kształtu",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Pobierz typ kształtu",
    "bitbybit.occt.geom.curves.geom2dEllipse": "elipsa geom 2d",
    "geom": "geom",
    "curves": "krzywe",
    "geom2dEllipse": "elipsa geom 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Tworzy elipsę 2d. Używaj tej geometrii tylko do celów konstrukcyjnych modelowania, a nie do reprezentacji. Aby je narysować, musisz przekształcić te krzywe w krawędzie.",
    "Base.Point2": "punkt bazowy 2",
    "Base.Vector2": "wektor bazowy 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "przycięta krzywa geom 2d",
    "geom2dTrimmedCurve": "przycięta krzywa geom 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Tworzy przyciętą krzywą z krzywej bazowej ograniczonej między U1 a U2. Tej krzywej nie można narysować.",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "dostosuj okresowość",
    "bitbybit.occt.geom.curves.geom2dSegment": "segment geom 2d",
    "geom2dSegment": "segment geom 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Tworzy przycięty segment krzywej 2d między dwoma punktami 2d. Tej krzywej nie można narysować.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "pobierz punkt 2d z krzywej 2d przy parametrze",
    "get2dPointFrom2dCurveOnParam": "pobierz punkt 2d z krzywej 2d przy parametrze",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Pobiera punkt 2d reprezentowany przez [liczba, liczba] na krzywej przy parametrze.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "krzywa geom okręgu",
    "geomCircleCurve": "krzywa geom okręgu",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Tworzy krzywą geom okręgu",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "krzywa geom elipsy",
    "geomEllipseCurve": "krzywa geom elipsy",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Tworzy krzywą geom elipsy",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "powierzchnia cylindryczna",
    "surfaces": "powierzchnie",
    "cylindricalSurface": "powierzchnia cylindryczna",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Tworzy nieskończoną powierzchnię cylindryczną, której nie można narysować. Używaj tej geometrii tylko do celów konstrukcyjnych modelowania, a nie do reprezentacji.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "powierzchnia ze ściany",
    "surfaceFromFace": "powierzchnia ze ściany",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Tworzy powierzchnię ze ściany",
    "bitbybit.occt.fillets.filletEdges": "zaokrąglij krawędzie",
    "fillets": "zaokrąglenia",
    "filletEdges": "zaokrąglij krawędzie",
    "bitbybit.occt.fillets.filletEdges_description": "zaokrągla kształty opencascade",
    "3d fillets": "zaokrąglenia 3d",
    "radiusList": "lista promieni",
    "indexes": "indeksy",
    "bitbybit.occt.fillets.filletEdgesList": "lista krawędzi do zaokrąglenia",
    "filletEdgesList": "lista krawędzi do zaokrąglenia",
    "bitbybit.occt.fillets.filletEdgesList_description": "Zaokrągla listę krawędzi z różnym promieniem na każdej krawędzi.",
    "edges": "krawędzie",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "lista krawędzi do zaokrąglenia jeden promień",
    "filletEdgesListOneRadius": "lista krawędzi do zaokrąglenia jeden promień",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Zaokrągla listę krawędzi z pojedynczym promieniem na wszystkich krawędziach.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "zaokrąglij krawędź zmienny promień",
    "filletEdgeVariableRadius": "zaokrąglij krawędź zmienny promień",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Zaokrągla pojedynczą krawędź z listą zmiennych promieni na zadanych parametrach u. Musisz podać listę parametrów, aby zidentyfikować, na którym parametrze U zastosować promień.",
    "paramsU": "parametry u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "zaokrąglij krawędzie ten sam zmienny promień",
    "filletEdgesSameVariableRadius": "zaokrąglij krawędzie ten sam zmienny promień",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Zaokrągla wiele podanych krawędzi z tymi samymi zmiennymi promieniami na parametrach u dla każdej krawędzi.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "zaokrąglij krawędzie zmienny promień",
    "filletEdgesVariableRadius": "zaokrąglij krawędzie zmienny promień",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Zaokrągla wiele podanych krawędzi z listami zmiennych promieni na zadanych listach parametrów. Musisz podać listę parametrów, aby zidentyfikować, na którym parametrze U zastosować promień.",
    "radiusLists": "listy promieni",
    "paramsULists": "listy parametrów u",
    "bitbybit.occt.fillets.fillet3DWire": "zaokrąglij kontur 3d",
    "fillet3DWire": "zaokrąglij kontur 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "Zaokrągla kontur 3d OpenCascade, ten algorytm przyjmuje jeden kierunek prowadzący do utworzenia zaokrągleń. Nie respektuje kierunków stycznych na każdym zaokrąglanym rogu. Ten algorytm opiera się na wyciągnięciu konturu wzdłuż danego kierunku, aby utworzyć powłokę, następnie zaokrągleniu powłoki i wreszcie wyodrębnieniu zaokrąglonego konturu z samej powłoki. Upewnij się, że podajesz kierunek, który nie jest równoległy do konturu i który tworzy wystarczająco wysokie wyciągnięcie, aby zaokrąglenie się powiodło.",
    "bitbybit.occt.fillets.fillet3DWires": "zaokrąglij kontury 3d",
    "fillet3DWires": "zaokrąglij kontury 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "Zaokrągla kontury 3d OpenCascade, ten algorytm przyjmuje jeden kierunek prowadzący do utworzenia zaokrągleń. Nie respektuje kierunków stycznych na każdym zaokrąglanym rogu. Ten algorytm opiera się na wyciągnięciu konturów wzdłuż danego kierunku, aby utworzyć powłokę, następnie zaokrągleniu powłoki i wreszcie wyodrębnieniu zaokrąglonego konturu z samej powłoki. Upewnij się, że podajesz kierunek, który nie jest równoległy do konturu i który tworzy wystarczająco wysokie wyciągnięcie, aby zaokrąglenie się powiodło.",
    "bitbybit.occt.fillets.chamferEdges": "fazuj krawędzie",
    "chamferEdges": "fazuj krawędzie",
    "bitbybit.occt.fillets.chamferEdges_description": "Fazuj krawędzie kształtu OpenCascade",
    "3d chamfers": "fazowania 3d",
    "distanceList": "lista odległości",
    "bitbybit.occt.fillets.chamferEdgesList": "lista krawędzi do fazowania",
    "chamferEdgesList": "lista krawędzi do fazowania",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Fazuje listę krawędzi z różną odległością na każdej krawędzi.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "fazuj krawędź dwie odległości",
    "chamferEdgeTwoDistances": "fazuj krawędź dwie odległości",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Fazuje krawędź o dwie odległości. Ściana wskazuje pierwszą odległość do zastosowania",
    "F": "f",
    "distance1": "odległość 1",
    "distance2": "odległość 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "fazuj krawędzie dwie odległości",
    "chamferEdgesTwoDistances": "fazuj krawędzie dwie odległości",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Fazuje krawędzie o dwie odległości. Ściana wskazuje pierwszą odległość do zastosowania",
    "faces": "ściany",
    "F[]": "tablica f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "listy krawędzi do fazowania dwie odległości",
    "chamferEdgesTwoDistancesLists": "listy krawędzi do fazowania dwie odległości",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Fazuje krawędzie o dwie odległości. Ściana wskazuje pierwszą odległość do zastosowania",
    "distances1": "odległości 1",
    "distances2": "odległości 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "fazuj krawędź odległość kąt",
    "chamferEdgeDistAngle": "fazuj krawędź odległość kąt",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Fazuje krawędź o zadaną odległość i kąt od ściany",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "fazuj krawędzie odległość kąt",
    "chamferEdgesDistAngle": "fazuj krawędzie odległość kąt",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Fazuje wiele krawędzi o zadaną odległość i kąt od ścian",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "fazuj krawędzie odległości kąty",
    "chamferEdgesDistsAngles": "fazuj krawędzie odległości kąty",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Fazuje krawędzie o zadane odległości i kąty od ścian",
    "distances": "odległości",
    "bitbybit.occt.fillets.fillet2d": "zaokrąglenie 2d",
    "fillet2d": "zaokrąglenie 2d",
    "bitbybit.occt.fillets.fillet2d_description": "zaokrągla kontur lub ścianę 2d",
    "2d fillets": "zaokrąglenia 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "zaokrąglenie kształtów 2d",
    "fillet2dShapes": "zaokrąglenie kształtów 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "zaokrągla kontury lub ściany 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "zaokrąglij dwie krawędzie w płaszczyźnie w kontur",
    "filletTwoEdgesInPlaneIntoAWire": "zaokrąglij dwie krawędzie w płaszczyźnie w kontur",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Zaokrągla dwie płaskie krawędzie w kontur, podając promień, płaszczyznę, krawędzie i możliwy indeks rozwiązania, jeśli istnieje więcej niż jeden wynik",
    "edge1": "krawędź 1",
    "edge2": "krawędź 2",
    "planeOrigin": "początek płaszczyzny",
    "planeDirection": "kierunek płaszczyzny",
    "solution": "rozwiązanie",
    "bitbybit.occt.transforms.transform": "przekształć",
    "bitbybit.occt.transforms.transform_description": "Przekształca kształt",
    "on single shape": "na pojedynczym kształcie",
    "rotationAxis": "oś obrotu",
    "rotationAngle": "kąt obrotu",
    "scaleFactor": "współczynnik skali",
    "bitbybit.occt.transforms.rotate": "obróć",
    "bitbybit.occt.transforms.rotate_description": "Obraca kształt",
    "bitbybit.occt.transforms.rotateAroundCenter": "obróć wokół środka",
    "rotateAroundCenter": "obróć wokół środka",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Obraca kształt wokół podanego środka",
    "bitbybit.occt.transforms.align": "wyrównaj",
    "bitbybit.occt.transforms.align_description": "Wyrównuje kształt",
    "fromOrigin": "z początku",
    "fromDirection": "z kierunku",
    "toOrigin": "do początku",
    "toDirection": "do kierunku",
    "bitbybit.occt.transforms.alignAndTranslate": "wyrównaj i przesuń",
    "alignAndTranslate": "wyrównaj i przesuń",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Wyrównuje i przesuwa kształt",
    "bitbybit.occt.transforms.translate": "przesuń",
    "bitbybit.occt.transforms.translate_description": "Przesuwa kształt",
    "bitbybit.occt.transforms.scale": "skaluj",
    "bitbybit.occt.transforms.scale_description": "Skaluje kształt",
    "bitbybit.occt.transforms.scale3d": "skaluj 3d",
    "scale3d": "skaluj 3d",
    "bitbybit.occt.transforms.scale3d_description": "Skaluje kształt w 3D",
    "bitbybit.occt.transforms.mirror": "odbij",
    "mirror": "odbij",
    "bitbybit.occt.transforms.mirror_description": "Odbija lustrzanie kształt",
    "bitbybit.occt.transforms.mirrorAlongNormal": "odbij wzdłuż normalnej",
    "mirrorAlongNormal": "odbij wzdłuż normalnej",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Odbija lustrzanie kształt wzdłuż normalnej i początku",
    "normal": "normalna",
    "bitbybit.occt.transforms.transformShapes": "przekształć kształty",
    "transformShapes": "przekształć kształty",
    "bitbybit.occt.transforms.transformShapes_description": "Przekształca tablicę kształtów za pomocą transformacji",
    "on shapes": "na kształtach",
    "rotationAxes": "osie obrotu",
    "rotationAngles": "kąty obrotu",
    "scaleFactors": "współczynniki skali",
    "bitbybit.occt.transforms.rotateShapes": "obróć kształty",
    "rotateShapes": "obróć kształty",
    "bitbybit.occt.transforms.rotateShapes_description": "Obraca kształty za pomocą obrotów",
    "axes": "osie",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "obróć kształty wokół środka",
    "rotateAroundCenterShapes": "obróć kształty wokół środka",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Obraca kształty wokół środka i osi",
    "centers": "środki",
    "bitbybit.occt.transforms.alignShapes": "wyrównaj kształty",
    "alignShapes": "wyrównaj kształty",
    "bitbybit.occt.transforms.alignShapes_description": "Wyrównuje kształty za pomocą wyrównań",
    "fromOrigins": "z początków",
    "fromDirections": "z kierunków",
    "toOrigins": "do początków",
    "toDirections": "do kierunków",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "wyrównaj i przesuń kształty",
    "alignAndTranslateShapes": "wyrównaj i przesuń kształty",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Wyrównuje i przesuwa kształty",
    "directions": "kierunki",
    "bitbybit.occt.transforms.translateShapes": "przesuń kształty",
    "translateShapes": "przesuń kształty",
    "bitbybit.occt.transforms.translateShapes_description": "Przesuwa kształty za pomocą translacji",
    "bitbybit.occt.transforms.scaleShapes": "skaluj kształty",
    "scaleShapes": "skaluj kształty",
    "bitbybit.occt.transforms.scaleShapes_description": "Skaluje kształty za pomocą współczynników skali",
    "factors": "współczynniki",
    "bitbybit.occt.transforms.scale3dShapes": "skaluj kształty 3d",
    "scale3dShapes": "skaluj kształty 3d",
    "bitbybit.occt.transforms.scale3dShapes_description": "Skaluje kształt w 3D",
    "scales": "skale",
    "bitbybit.occt.transforms.mirrorShapes": "odbij kształty",
    "mirrorShapes": "odbij kształty",
    "bitbybit.occt.transforms.mirrorShapes_description": "Odbija lustrzanie kształty za pomocą wielu luster",
    "origins": "początki",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "odbij kształty wzdłuż normalnej",
    "mirrorAlongNormalShapes": "odbij kształty wzdłuż normalnej",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Odbija lustrzanie kształty wzdłuż normalnej i początku",
    "normals": "normalne",
    "bitbybit.occt.operations.loft": "loft",
    "operations": "operacje",
    "loft": "loft",
    "bitbybit.occt.operations.loft_description": "Tworzy loft z konturów w powłokę",
    "lofts": "lofty",
    "makeSolid": "utwórz bryłę",
    "bitbybit.occt.operations.loftAdvanced": "loft zaawansowany",
    "loftAdvanced": "loft zaawansowany",
    "bitbybit.occt.operations.loftAdvanced_description": "Tworzy loft z konturów w powłokę używając wielu zaawansowanych opcji",
    "straight": "prosty",
    "nrPeriodicSections": "liczba sekcji okresowych",
    "useSmoothing": "użyj wygładzania",
    "maxUDegree": "maksymalny stopień u",
    "parType": "typ parametru",
    "approxParametrizationTypeEnum": "typ parametryzacji aproksymacji enum",
    "startVertex": "wierzchołek początkowy",
    "endVertex": "wierzchołek końcowy",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "najbliższe punkty między dwoma kształtami",
    "closestPointsBetweenTwoShapes": "najbliższe punkty między dwoma kształtami",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Oblicza dwa najbliższe punkty między dwoma kształtami",
    "closest pts": "najbliższe pkt",
    "shape1": "kształt 1",
    "shape2": "kształt 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "najbliższe punkty na kształcie z punktów",
    "closestPointsOnShapeFromPoints": "najbliższe punkty na kształcie z punktów",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Oblicza najbliższe punkty między listą punktów a danym kształtem",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "najbliższe punkty na kształtach z punktów",
    "closestPointsOnShapesFromPoints": "najbliższe punkty na kształtach z punktów",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Oblicza najbliższe punkty między listą punktów a kształtami",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "odległości do kształtu z punktów",
    "distancesToShapeFromPoints": "odległości do kształtu z punktów",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Oblicza odległości między listą punktów a odpowiadającymi im najbliższymi punktami na kształtach.",
    "bitbybit.occt.operations.boundingBoxOfShape": "bbox kształtu",
    "boundingBoxOfShape": "bbox kształtu",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Oblicza parametry prostopadłościanu otaczającego (bbox) kształtu",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "bbox min kształtu",
    "boundingBoxMinOfShape": "bbox min kształtu",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Pobierz punkt min prostopadłościanu otaczającego kształtu",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "bbox max kształtu",
    "boundingBoxMaxOfShape": "bbox max kształtu",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Pobierz punkt max prostopadłościanu otaczającego kształtu",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "środek bbox kształtu",
    "boundingBoxCenterOfShape": "środek bbox kształtu",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Pobierz punkt środkowy prostopadłościanu otaczającego kształtu",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "rozmiar bbox kształtu",
    "boundingBoxSizeOfShape": "rozmiar bbox kształtu",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Pobierz punkt rozmiaru prostopadłościanu otaczającego kształtu",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "kształt bbox kształtu",
    "boundingBoxShapeOfShape": "kształt bbox kształtu",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Pobierz kształt prostopadłościanu otaczającego kształtu",
    "bitbybit.occt.operations.boundingSphereOfShape": "bsphere kształtu",
    "boundingSphereOfShape": "bsphere kształtu",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Oblicza parametry sfery otaczającej kształtu",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "środek bsphere kształtu",
    "boundingSphereCenterOfShape": "środek bsphere kształtu",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Pobierz punkt środkowy sfery otaczającej kształtu",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "promień bsphere kształtu",
    "boundingSphereRadiusOfShape": "promień bsphere kształtu",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Pobierz promień sfery otaczającej kształtu",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "kształt bsphere kształtu",
    "boundingSphereShapeOfShape": "kształt bsphere kształtu",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Pobierz kształt sfery otaczającej kształtu",
    "bitbybit.occt.operations.extrude": "wyciągnij",
    "extrude": "wyciągnij",
    "bitbybit.occt.operations.extrude_description": "Wyciąga kształt wzdłuż kierunku - kontur utworzy powłokę, ściana utworzy bryłę",
    "extrusions": "wyciągnięcia",
    "bitbybit.occt.operations.extrudeShapes": "wyciągnij kształty",
    "extrudeShapes": "wyciągnij kształty",
    "bitbybit.occt.operations.extrudeShapes_description": "Wyciąga kształty wzdłuż kierunku",
    "bitbybit.occt.operations.splitShapeWithShapes": "podziel kształt kształtami",
    "splitShapeWithShapes": "podziel kształt kształtami",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Dzieli kształt za pomocą kształtów",
    "divisions": "podziały",
    "localFuzzyTolerance": "lokalna tolerancja rozmyta",
    "nonDestructive": "nieniszczący",
    "bitbybit.occt.operations.revolve": "obróć",
    "revolve": "obróć",
    "bitbybit.occt.operations.revolve_description": "Obraca kształt wokół zadanego kierunku",
    "revolutions": "obroty",
    "copy": "kopiuj",
    "bitbybit.occt.operations.rotatedExtrude": "obrócone wyciągnięcie",
    "rotatedExtrude": "obrócone wyciągnięcie",
    "bitbybit.occt.operations.rotatedExtrude_description": "Obrócone wyciągnięcie wykonane na kształcie",
    "bitbybit.occt.operations.pipe": "rura",
    "pipe": "rura",
    "bitbybit.occt.operations.pipe_description": "Tworzy rurę z kształtów wzdłuż konturu",
    "pipeing": "tworzenie rur",
    "bitbybit.occt.operations.pipePolylineWireNGon": "rura z konturu polilinii ngon",
    "pipePolylineWireNGon": "rura z konturu polilinii ngon",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Tworzy rurę z konturu polilinii o profilu n-kąta.",
    "trihedronEnum": "trójścian enum",
    "geomFillTrihedronEnum": "trójścian wypełnienia geom enum",
    "forceApproxC1": "wymuś aproksymację c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "rura z konturów cylindryczna",
    "pipeWiresCylindrical": "rura z konturów cylindryczna",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Tworzy rurę z konturów o kształcie cylindrycznym",
    "bitbybit.occt.operations.pipeWireCylindrical": "rura z konturu cylindryczna",
    "pipeWireCylindrical": "rura z konturu cylindryczna",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Tworzy rurę z konturu o kształcie cylindrycznym",
    "bitbybit.occt.operations.offset": "przesunięcie",
    "bitbybit.occt.operations.offset_description": "Przesunięcie dla różnych kształtów",
    "offsets": "przesunięcia",
    "bitbybit.occt.operations.offsetAdv": "przesunięcie zaawansowane",
    "offsetAdv": "przesunięcie zaawansowane",
    "bitbybit.occt.operations.offsetAdv_description": "Zaawansowane przesunięcie dające więcej opcji, takich jak typ łączenia dla krawędzi i narożników",
    "joinType": "typ łączenia",
    "joinTypeEnum": "typ łączenia enum",
    "removeIntEdges": "usuń krawędzie wew",
    "bitbybit.occt.operations.makeThickSolidSimple": "utwórz grubą bryłę proste",
    "makeThickSolidSimple": "utwórz grubą bryłę proste",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Pogrubia kształt w bryłę o odległość przesunięcia",
    "bitbybit.occt.operations.makeThickSolidByJoin": "utwórz grubą bryłę przez łączenie",
    "makeThickSolidByJoin": "utwórz grubą bryłę przez łączenie",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Pogrubia kształt w bryłę poprzez łączenie",
    "intersection": "przecięcie",
    "selfIntersection": "samoprzecięcie",
    "bitbybit.occt.operations.slice": "tnij",
    "slice": "tnij",
    "bitbybit.occt.operations.slice_description": "Tnie kształt",
    "bitbybit.occt.operations.sliceInStepPattern": "tnij we wzór schodkowy",
    "sliceInStepPattern": "tnij we wzór schodkowy",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Tnie kształt we wzór schodkowy",
    "steps": "kroki",
    "bitbybit.occt.operations.offset3DWire": "przesuń kontur 3d",
    "offset3DWire": "przesuń kontur 3d",
    "bitbybit.occt.operations.offset3DWire_description": "Przesuwa kontur 3D. Używając tej metody, rozważ użycie jej na zaokrąglonych konturach, które nie zawierają ostrych narożników. Możesz użyć na nim zaokrąglenia 3D.",
    "bitbybit.occt.booleans.union": "suma",
    "booleans": "operacje logiczne",
    "union": "suma",
    "bitbybit.occt.booleans.union_description": "Łączy oddzielne obiekty",
    "keepEdges": "zachowaj krawędzie",
    "bitbybit.occt.booleans.difference": "różnica",
    "difference": "różnica",
    "bitbybit.occt.booleans.difference_description": "Wykonuje operację różnicy logicznej między kształtem głównym a podanymi kształtami",
    "bitbybit.occt.booleans.intersection": "przecięcie",
    "bitbybit.occt.booleans.intersection_description": "Wykonuje operację przecięcia logicznego między kształtem głównym a podanymi kształtami",
    "bitbybit.occt.shapeFix.basicShapeRepair": "podstawowa naprawa kształtu",
    "shapeFix": "naprawa kształtu",
    "basicShapeRepair": "podstawowa naprawa kształtu",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Wykonuje podstawową naprawę kształtu",
    "maxTolerance": "maks tolerancja",
    "minTolerance": "min tolerancja",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "napraw małą krawędź na konturze",
    "fixSmallEdgeOnWire": "napraw małą krawędź na konturze",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Napraw małą krawędź na konturze",
    "lockvtx": "zablokuj wierzchołki",
    "precsmall": "precyzja mała",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "napraw orientacje krawędzi wzdłuż konturu",
    "fixEdgeOrientationsAlongWire": "napraw orientacje krawędzi wzdłuż konturu",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Napraw orientacje krawędzi wzdłuż konturu",
    "bitbybit.occt.io.saveShapeSTEP": "zapisz kształt step",
    "saveShapeSTEP": "zapisz kształt step",
    "bitbybit.occt.io.saveShapeSTEP_description": "Zapisuje plik step",
    "adjustYtoZ": "dostosuj y do z",
    "tryDownload": "spróbuj pobrać",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "zapisz kształt step i zwróć",
    "saveShapeSTEPAndReturn": "zapisz kształt step i zwróć",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Zapisuje plik step i zwraca wartość tekstową",
    "bitbybit.occt.io.saveShapeStl": "zapisz kształt stl",
    "saveShapeStl": "zapisz kształt stl",
    "bitbybit.occt.io.saveShapeStl_description": "Zapisuje plik stl",
    "binary": "binarny",
    "bitbybit.occt.io.saveShapeStlAndReturn": "zapisz kształt stl i zwróć",
    "saveShapeStlAndReturn": "zapisz kształt stl i zwróć",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Zapisuje plik stl i zwraca",
    "bitbybit.occt.io.loadSTEPorIGES": "wczytaj step lub iges",
    "loadSTEPorIGES": "wczytaj step lub iges",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Importuje plik zasobu step lub iges",
    "adjustZtoY": "dostosuj z do y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "wczytaj step lub iges z tekstu",
    "loadSTEPorIGESFromText": "wczytaj step lub iges z tekstu",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Importuje plik zasobu step lub iges z tekstu",
    "fileType": "typ pliku",
    "fileTypeEnum": "typ pliku enum",
    "bitbybit.advanced.text3d.create": "tekst 3d",
    "advanced": "zaawansowane",
    "text3d": "tekst 3d",
    "bitbybit.advanced.text3d.create_description": "Tworzy tekst 3d",
    "fontType": "typ czcionki",
    "fontsEnum": "czcionki enum",
    "fontVariant": "wariant czcionki",
    "fontVariantsEnum": "warianty czcionki enum",
    "Inputs.Base.Vector3": "wejścia base vector 3",
    "originAlignment": "wyrównanie początku",
    "recAlignmentEnum": "wyrównanie prostokąta enum",
    "bitbybit.advanced.text3d.createTextOnFace": "tekst na ścianie",
    "createTextOnFace": "tekst na ścianie",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Tworzy tekst 3d na ścianie",
    "facePlanar": "płaszczyzna ściany",
    "faceTextVar": "zmienna tekstu ściany",
    "faceTextVarEnum": "zmienna tekstu ściany enum",
    "originParamU": "parametr początku u",
    "originParamV": "parametr początku v",
    "bitbybit.advanced.text3d.createTextsOnFace": "teksty na ścianie",
    "createTextsOnFace": "teksty na ścianie",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Tworzy teksty 3d na ścianie z wielu definicji",
    "definitions": "definicje",
    "Text3DFaceDefinitionDto[]": "tablica definicji tekstu 3d na ścianie",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "definicja tekstu 3d na ścianie",
    "definition3dTextOnFace": "definicja tekstu 3d na ścianie",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Tworzy tekst 3d, który zostanie użyty na definicji ściany",
    "bitbybit.advanced.text3d.getCompoundShape": "pobierz kształt złożony",
    "getCompoundShape": "pobierz kształt złożony",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Pobiera złożony kształt wyniku tekstu 3d",
    "model": "model",
    "Text3DData<T>": "dane tekstu 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "pobierz kształt znaku",
    "getCharacterShape": "pobierz kształt znaku",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Pobiera kształt znaku o określonym indeksie",
    "bitbybit.advanced.text3d.getCharacterShapes": "pobierz kształty znaków",
    "getCharacterShapes": "pobierz kształty znaków",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Pobiera kształty znaków wyniku tekstu 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "pobierz współrzędne środka znaku",
    "getCharacterCenterCoordinates": "pobierz współrzędne środka znaku",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Pobiera współrzędne środka masy wszystkich znaków",
    "bitbybit.advanced.text3d.getFaceCutout": "pobierz wycięcie ściany",
    "getFaceCutout": "pobierz wycięcie ściany",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Pobiera wycięcie ściany z tekstu 3d, który został utworzony na ścianie",
    "get from face": "pobierz ze ściany",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "pobierz wszystkie ściany wycięcia",
    "getAllFacesOfCutout": "pobierz wszystkie ściany wycięcia",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Pobiera wszystkie wycięcia ścian z tekstu 3d, który został utworzony na oryginalnej ścianie",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "pobierz wycięcia wewnątrz znaków",
    "getCutoutsInsideCharacters": "pobierz wycięcia wewnątrz znaków",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Pobiera wycięcia ścian znaków z tekstu 3d, który został utworzony na oryginalnej ścianie",
    "bitbybit.advanced.text3d.getAdvanceWidth": "pobierz szerokość przesunięcia",
    "getAdvanceWidth": "pobierz szerokość przesunięcia",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Pobiera szerokość przesunięcia (advance width)",
    "dimensions": "wymiary",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "prosta piramida",
    "facePatterns": "wzory ścian",
    "pyramidSimple": "prosta piramida",
    "createPyramidSimple": "prosta piramida",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Tworzy prosty wzór piramidy na ścianach",
    "uNumber": "liczba u",
    "vNumber": "liczba v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "afektory prostej piramidy",
    "createPyramidSimpleAffectors": "afektory prostej piramidy",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Tworzy prosty wzór piramidy na ścianach z afektorami zmieniającymi wysokość",
    "affectorPoints": "punkty afektora",
    "Inputs.Base.Point3[]": "wejścia tablica punktów 3",
    "affectorRadiusList": "lista promieni afektora",
    "affectorFactors": "współczynniki afektora",
    "defaultHeight": "domyślna wysokość",
    "affectMinHeight": "wpływ na minimalną wysokość",
    "affectMaxHeight": "wpływ na maksymalną wysokość",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Pobiera kształt złożony wszystkich piramid",
    "get shapes": "pobierz kształty",
    "PyramidSimpleData<T>": "dane prostej piramidy t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "pobierz kształt złożony na ścianie",
    "getCompoundShapeOnFace": "pobierz kształt złożony na ścianie",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Pobiera kształt złożony na ścianie",
    "faceIndex": "indeks ściany",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "pobierz kształt złożony komórki na ścianie",
    "getCompoundShapeCellOnFace": "pobierz kształt złożony komórki na ścianie",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Pobiera kształt złożony piramidy na ścianie o określonym indeksie",
    "uIndex": "indeks u",
    "vIndex": "indeks v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "pobierz wszystkie komórki piramid",
    "getAllPyramidCells": "pobierz wszystkie komórki piramid",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Pobiera wszystkie komórki piramid. Jest to zazwyczaj akcja pośrednia przed odczytaniem konkretnych informacji o samych komórkach.",
    "get cells": "pobierz komórki",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "pobierz wszystkie komórki piramid na ścianie",
    "getAllPyramidCellsOnFace": "pobierz wszystkie komórki piramid na ścianie",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Pobiera komórki piramid na ścianie. Jest to zazwyczaj akcja pośrednia przed odczytaniem konkretnych informacji o samych komórkach.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "pobierz wszystkie komórki u piramid na ścianie",
    "getAllPyramidUCellsOnFace": "pobierz wszystkie komórki u piramid na ścianie",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Pobiera komórki piramid na ścianie. Jest to zazwyczaj akcja pośrednia przed odczytaniem konkretnych informacji o samych komórkach.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "pobierz wszystkie komórki u piramid na ścianie przy u",
    "getAllPyramidUCellsOnFaceAtU": "pobierz wszystkie komórki u piramid na ścianie przy u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Pobiera komórki piramid na ścianie przy indeksie u wzdłuż kierunku v. Jest to zazwyczaj akcja pośrednia przed odczytaniem konkretnych informacji o samych komórkach.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "pobierz wszystkie komórki u piramid na ścianie przy v",
    "getAllPyramidUCellsOnFaceAtV": "pobierz wszystkie komórki u piramid na ścianie przy v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Pobiera komórki piramid na ścianie przy indeksie v wzdłuż kierunku u. Jest to zazwyczaj akcja pośrednia przed odczytaniem konkretnych informacji o samych komórkach.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "pobierz komórkę przy indeksie",
    "getCellOnIndex": "pobierz komórkę przy indeksie",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Pobiera komórkę piramidy na ścianie przy indeksie u i v. Jest to zazwyczaj akcja pośrednia przed odczytaniem konkretnych informacji o samej komórce.",
    "get cell": "pobierz komórkę",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "pobierz punkty szczytowe komórek",
    "getTopPointsOfCells": "pobierz punkty szczytowe komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Pobiera punkty szczytowe komórek",
    "get from cells": "pobierz z komórek",
    "cells": "komórki",
    "PyramidSimpleCellPart<T>[]": "część komórki prostej piramidy t array",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "pobierz punkty środkowe komórek",
    "getCenterPointsOfCells": "pobierz punkty środkowe komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Pobiera punkt środkowy pomiędzy narożnikami komórki",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "pobierz punkty narożne komórek",
    "getCornerPointsOfCells": "pobierz punkty narożne komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Pobiera punkty narożne komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "pobierz punkt narożny komórek",
    "getCornerPointOfCells": "pobierz punkt narożny komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Pobiera punkty narożne komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "pobierz normalną narożnika komórek",
    "getCornerNormalOfCells": "pobierz normalną narożnika komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Pobiera normalną narożnika komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "pobierz normalne narożników komórek",
    "getCornerNormalsOfCells": "pobierz normalne narożników komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Pobiera normalne narożników komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "pobierz kształty złożone komórek",
    "getCompoundShapesOfCells": "pobierz kształty złożone komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Pobiera kształty złożone komórek piramid",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "pobierz kształty ścian komórek",
    "getFaceShapesOfCells": "pobierz kształty ścian komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Pobiera kształty ścian podanych komórek piramid",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "pobierz kształty konturów komórek",
    "getWireShapesOfCells": "pobierz kształty konturów komórek",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Pobiera kształty ścian podanych komórek piramid",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "pobierz początkowy kontur polilinii u",
    "getStartPolylineWireU": "pobierz początkowy kontur polilinii u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Pobiera kontur polilinii wzdłuż krawędzi początkowej kierunku U ściany",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "pobierz końcowy kontur polilinii u",
    "getEndPolylineWireU": "pobierz końcowy kontur polilinii u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Pobiera kontur polilinii wzdłuż krawędzi końcowej kierunku U ściany",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "pobierz początkowy kontur polilinii v",
    "getStartPolylineWireV": "pobierz początkowy kontur polilinii v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Pobiera kontur polilinii wzdłuż krawędzi początkowej kierunku V ściany",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "pobierz końcowy kontur polilinii v",
    "getEndPolylineWireV": "pobierz końcowy kontur polilinii v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Pobiera kontur polilinii wzdłuż krawędzi końcowej kierunku V ściany",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "pobierz złożenie konturów polilinii u",
    "getPolylineWiresUCompound": "pobierz złożenie konturów polilinii u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Pobiera kontury polilinii wzdłuż kierunku U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "pobierz złożenie konturów polilinii v",
    "getPolylineWiresVCompound": "pobierz złożenie konturów polilinii v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Pobiera kontury polilinii wzdłuż kierunku V",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "willa wingtip",
    "things": "rzeczy",
    "kidsCorner": "kącik dziecięcy",
    "birdhouses": "karmniki",
    "wingtipVilla": "willa wingtip",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Tworzy karmnik dla ptaków willa wingtip z dachem 45 stopni",
    "birdhouse": "karmnik",
    "interiorWidth": "szerokość wewnętrzna",
    "interiorLength": "długość wewnętrzna",
    "interiorHeight": "wysokość wewnętrzna",
    "holeDiameter": "średnica otworu",
    "holeDistToBottom": "odległość otworu od dołu",
    "stickLength": "długość patyka",
    "stickDiameter": "średnica patyka",
    "baseAttachmentHeight": "wysokość mocowania podstawy",
    "roofOverhang": "nawis dachu",
    "chimneyHeight": "wysokość komina",
    "Inputs.Base.Point3": "wejścia punkt bazowy 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "domek chirpy",
    "chirpyChalet": "domek chirpy",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Tworzy karmnik dla ptaków domek chirpy z dachem 45 stopni",
    "roofAngle": "kąt dachu",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "wir spokoju",
    "threeDPrinting": "druk 3d",
    "vases": "wazony",
    "serenitySwirl": "wir spokoju",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Tworzy wir spokoju",
    "swirl": "wir",
    "addRadiusNarrow": "dodaj promień wąski",
    "addRadiusWide": "dodaj promień szeroki",
    "addMiddleHeight": "dodaj wysokość środkową",
    "addTopHeight": "dodaj wysokość górną",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arabskie łuki",
    "arabicArchway": "arabskie łuki",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Tworzy wazon arabskie łuki",
    "profilePoints": "punkty profilu",
    "nrOfSides": "liczba boków",
    "nrOfVerticalArches": "liczba pionowych łuków",
    "archCenterThickness": "grubość środka łuku",
    "edgesThickness": "grubość krawędzi",
    "baseHeight": "wysokość podstawy",
    "patchHoles": "załataj dziury",
    "lod": "poziom szczegółowości",
    "Things.Enums.lodEnum": "rzeczy enumy poziom szczegółowości enum",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "wieczna miłość",
    "medals": "medale",
    "eternalLove": "wieczna miłość",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Tworzy model medalu wieczna miłość",
    "textHeading": "tekst nagłówka",
    "textName": "tekst imienia",
    "fullModel": "pełny model",
    "decorationThickness": "grubość dekoracji",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "kubek spokoju",
    "cups": "kubki",
    "calmCup": "kubek spokoju",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Tworzy model kubka na spokojne chwile",
    "radiusTopOffset": "przesunięcie promienia góry",
    "fillet": "zaokrąglenie",
    "nrOfHandles": "liczba uchwytów",
    "handleDist": "odległość uchwytu",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "kubek smoka",
    "dragonCup": "kubek smoka",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Tworzy model kubka dla twojego wewnętrznego smoka",
    "radiusMidOffset": "przesunięcie promienia środka",
    "rotationTopAngle": "kąt obrotu góry",
    "rotationMidAngle": "kąt obrotu środka",
    "nrSkinCellsVertical": "liczba pionowych komórek skóry",
    "nrSkinCellsHorizontal": "liczba poziomych komórek skóry",
    "nrSkinCellDivisionsTop": "liczba podziałów komórek skóry góra",
    "nrSkinCellDivisionsBottom": "liczba podziałów komórek skóry dół",
    "skinCellOuterHeight": "wysokość zewnętrzna komórki skóry",
    "skinCellInnerHeight": "wysokość wewnętrzna komórki skóry",
    "skinCellBottomHeight": "wysokość dolna komórki skóry",
    "skinCellTopHeight": "wysokość górna komórki skóry",
    "bottomThickness": "grubość dna",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Pobiera kształt złożony kubka smoka",
    "DragonCupData<T>": "dane kubka smoka t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "gniazdo telefonu",
    "desktop": "biurko",
    "phoneNest": "gniazdo telefonu",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Tworzy model gniazda telefonu",
    "heightBottom": "wysokość dół",
    "heightTop": "wysokość góra",
    "widthBack": "szerokość tył",
    "widthFront": "szerokość przód",
    "backOffset": "przesunięcie tyłu",
    "applyOrnaments": "zastosuj ornamenty",
    "filletRadius": "promień zaokrąglenia",
    "phoneHeight": "wysokość telefonu",
    "phoneWidth": "szerokość telefonu",
    "phoneThickness": "grubość telefonu",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Pobiera kształt złożony gniazda telefonu",
    "PhoneNestData<T>": "dane gniazda telefonu t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "opcje rysowania",
    "drawOptions": "opcje rysowania",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "tworzy opcje rysowania dla modelu",
    "mainMaterial": "materiał główny",
    "phoneMaterial": "materiał telefonu",
    "Inputs.Base.Color": "wejścia kolor bazowy",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "uchwyt na telefon kropelki",
    "laserCutting": "cięcie laserowe",
    "gadgets": "gadżety",
    "dropletsPhoneHolder": "uchwyt na telefon kropelki",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "tworzy uchwyt na telefon kropelki",
    "title": "tytuł",
    "subtitle": "podtytuł",
    "includeLogo": "uwzględnij logo",
    "kerf": "rzaz",
    "backLength": "długość tyłu",
    "offsetAroundPhone": "przesunięcie wokół telefonu",
    "penShelf": "półka na długopis",
    "phoneLockHeight": "wysokość blokady telefonu",
    "includePattern": "uwzględnij wzór",
    "densityPattern": "gęstość wzoru",
    "holesForWire": "otwory na przewód",
    "wireInputThickness": "grubość wejścia przewodu",
    "includeModel": "uwzględnij model",
    "includeDrawings": "uwzględnij rysunki",
    "spacingDrawings": "odstępy rysunków",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Pobiera kształt złożony uchwytu na telefon kropelki",
    "DropletsPhoneHolderData<T>": "dane uchwytu na telefon kropelki t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "pobierz złożenie konturów cięcia",
    "getCutWiresCompound": "pobierz złożenie konturów cięcia",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Pobiera złożenie konturów cięcia",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "pobierz złożenie konturów grawerowania",
    "getEngravingWiresCompound": "pobierz złożenie konturów grawerowania",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Pobiera złożenie konturów grawerowania",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "pobierz rysunki dxf",
    "downloadDXFDrawings": "pobierz rysunki dxf",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "pobiera rysunek dxf",
    "download": "pobierz",
    "cutWiresColor": "kolor konturów cięcia",
    "engravingWiresColor": "kolor konturów grawerowania",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "pobierz rysunki step",
    "downloadSTEPDrawings": "pobierz rysunki step",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "pobiera rysunek step",
    "adjustYZ": "dostosuj yz",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "pobierz model 3d step",
    "download3dSTEPModel": "pobierz model 3d step",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "pobiera model 3d step",
    "bitbybit.things.architecture.houses.zenHideout.create": "kryjówka zen",
    "architecture": "architektura",
    "houses": "domy",
    "zenHideout": "kryjówka zen",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Tworzy kryjówkę zen",
    "widthFirstWing": "szerokość pierwszego skrzydła",
    "lengthFirstWing": "długość pierwszego skrzydła",
    "terraceWidth": "szerokość tarasu",
    "widthSecondWing": "szerokość drugiego skrzydła",
    "lengthSecondWing": "długość drugiego skrzydła",
    "heightWalls": "wysokość ścian",
    "roofAngleFirstWing": "kąt dachu pierwszego skrzydła",
    "roofAngleSecondWing": "kąt dachu drugiego skrzydła",
    "roofOffset": "przesunięcie dachu",
    "roofInsideOverhang": "nawis dachu wewnątrz",
    "roofMaxDistAttachmentBeams": "maksymalna odległość belek mocujących dachu",
    "roofAttachmentBeamWidth": "szerokość belki mocującej dachu",
    "roofAttachmentBeamHeight": "wysokość belki mocującej dachu",
    "roofOutsideOverhang": "nawis dachu na zewnątrz",
    "columnSize": "rozmiar kolumny",
    "ceilingBeamHeight": "wysokość belki stropowej",
    "ceilingBeamWidth": "szerokość belki stropowej",
    "nrCeilingBeamsBetweenColumns": "liczba belek stropowych między kolumnami",
    "distBetweenColumns": "odległość między kolumnami",
    "floorHeight": "wysokość podłogi",
    "groundLevel": "poziom gruntu",
    "facadePanelThickness": "grubość panelu elewacyjnego",
    "windowWidthOffset": "przesunięcie szerokości okna",
    "windowHeightOffset": "przesunięcie wysokości okna",
    "windowFrameThickness": "grubość ramy okiennej",
    "windowGlassFrameThickness": "grubość ramy szyby okiennej",
    "skinOpacity": "przezroczystość powłoki",
    "bitbybit.things.furniture.chairs.snakeChair.create": "krzesło wąż",
    "furniture": "meble",
    "chairs": "krzesła",
    "snakeChair": "krzesło wąż",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Tworzy model krzesła wąż",
    "sittingHeight": "wysokość siedzenia",
    "backRestOffset": "przesunięcie oparcia",
    "backRestHeight": "wysokość oparcia",
    "nrOrnamentPlanks": "liczba desek ozdobnych",
    "ornamentDepth": "głębokość ornamentu",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Pobiera kształt złożony krzesła",
    "SnakeChairData<T>": "dane krzesła wąż t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "pobierz kształt konturu siedzenia",
    "getSittingWireShape": "pobierz kształt konturu siedzenia",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Pobiera kształt konturu obszaru siedzenia krzesła",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "pobierz punkt środkowy obszaru siedzenia",
    "getSittingAreaCenterPoint": "pobierz punkt środkowy obszaru siedzenia",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Pobiera punkt środkowy obszaru siedzenia krzesła",
    "get points": "pobierz punkty",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "opcje rysowania",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "tworzy opcje rysowania dla krzesła wąż",
    "bitbybit.things.furniture.tables.elegantTable.create": "elegancki stół",
    "tables": "stoły",
    "elegantTable": "elegancki stół",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Tworzy model eleganckiego stołu",
    "topThickness": "grubość blatu",
    "topOffset": "przesunięcie blatu",
    "minFillet": "minimalne zaokrąglenie",
    "radiusLegTop": "promień nogi góra",
    "radiusLegBottom": "promień nogi dół",
    "nrLegPairs": "liczba par nóg",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Pobiera kształt złożony stołu",
    "ElegantTableData<T>": "dane eleganckiego stołu t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "pobierz kształty nóg",
    "getLegShapes": "pobierz kształty nóg",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Pobiera kształty nóg jako listę",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "pobierz kształt nogi po indeksie",
    "getLegShapeByIndex": "pobierz kształt nogi po indeksie",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Pobiera kształt nogi po indeksie",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "pobierz kształt panelu górnego",
    "getTopPanelShape": "pobierz kształt panelu górnego",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Pobiera kształt panelu blatu stołu",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "pobierz kształt konturu panelu górnego",
    "getTopPanelWireShape": "pobierz kształt konturu panelu górnego",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Pobiera kształt konturu panelu blatu stołu",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "pobierz kształt konturu panelu dolnego",
    "getBottomPanelWireShape": "pobierz kształt konturu panelu dolnego",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Pobiera kształt konturu panelu dolnego stołu",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "pobierz kształt panelu dolnego",
    "getBottomPanelShape": "pobierz kształt panelu dolnego",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Pobiera kształt panelu dolnego stołu",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "pobierz kształt złożony nóg",
    "getLegsCompoundShape": "pobierz kształt złożony nóg",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Pobiera kształty nóg jako kształt złożony",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "pobierz punkt środkowy blatu",
    "getTableTopCenterPoint": "pobierz punkt środkowy blatu",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Pobiera punkt środkowy góry",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "pobierz punkt środkowy dołu stołu",
    "getTableBottomCenterPoint": "pobierz punkt środkowy dołu stołu",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Pobiera punkt środkowy dołu",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "pobierz punkty dolne nóg",
    "getLegBottomPoints": "pobierz punkty dolne nóg",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Pobiera punkty dolne nóg",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "pobierz punkty górne nóg",
    "getLegTopPoints": "pobierz punkty górne nóg",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Pobiera punkty górne nóg",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "opcje rysowania",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "tworzy opcje rysowania dla eleganckiego stołu",
    "topMaterial": "materiał blatu",
    "topBaseMaterial": "materiał podstawy blatu",
    "legsMaterial": "materiał nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "dobry stolik kawowy",
    "goodCoffeeTable": "dobry stolik kawowy",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Tworzy model dobrego stolika kawowego",
    "chamfer": "fazowanie",
    "topGlassOffset": "przesunięcie górnego szkła",
    "glassThickness": "grubość szkła",
    "glassHolderLength": "długość uchwytu szkła",
    "shelfTopOffset": "przesunięcie górne półki",
    "shelfThickness": "grubość półki",
    "legWidth": "szerokość nogi",
    "legDepth": "głębokość nogi",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Pobiera kształt złożony stołu",
    "GoodCoffeeTableData<T>": "dane dobrego stolika kawowego t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "pobierz kształty nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Pobiera kształty nóg jako listę",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "pobierz kształt nogi po indeksie",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Pobiera kształt nogi po indeksie",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "pobierz kształt panelu górnego",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Pobiera kształt panelu blatu stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "pobierz kształt konturu panelu górnego",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Pobiera kształt konturu panelu blatu stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "pobierz kształt panelu szklanego",
    "getGlassPanelShape": "pobierz kształt panelu szklanego",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Pobiera kształt panelu szklanego stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "pobierz kształt konturu panelu szklanego",
    "getGlassPanelWireShape": "pobierz kształt konturu panelu szklanego",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Pobiera kształt konturu panelu szklanego stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "pobierz kształt półki",
    "getShelfShape": "pobierz kształt półki",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Pobiera kształt półki stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "pobierz kształt konturu górnego półki",
    "getShelfTopWireShape": "pobierz kształt konturu górnego półki",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Pobiera kształt konturu górnego półki stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "pobierz kształt złożony nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Pobiera kształty nóg jako kształt złożony",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "pobierz punkt środkowy blatu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Pobiera punkt środkowy góry",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "pobierz punkt środkowy góry półki stołu",
    "getTableShelfTopCenterPoint": "pobierz punkt środkowy góry półki stołu",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Pobiera punkt środkowy góry półki",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "pobierz punkty dolne nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Pobiera punkty dolne nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "pobierz punkty górne nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Pobiera punkty górne nóg",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "opcje rysowania",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "tworzy opcje rysowania dla dobrego stolika kawowego",
    "topGlassMaterial": "materiał górnego szkła",
    "shelfMaterial": "materiał półki",
    "bitbybit.things.furniture.tables.snakeTable.create": "stół wąż",
    "snakeTable": "stół wąż",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Tworzy model stołu wąż",
    "supportLength": "długość podpory",
    "shelfHeight": "wysokość półki",
    "glassOffset": "przesunięcie szkła",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "pobierz kształt złożony",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Pobiera kształt złożony stołu",
    "SnakeTableData<T>": "dane stołu wąż t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "pobierz kształt szkła",
    "getGlassShape": "pobierz kształt szkła",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Pobiera kształt szkła stołu",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "pobierz kształt główny",
    "getMainShape": "pobierz kształt główny",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Pobiera główny kształt bryły stołu",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "pobierz punkt środkowy blatu",
    "getTopCenterPoint": "pobierz punkt środkowy blatu",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Pobiera punkt środkowy blatu stołu",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "opcje rysowania",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "tworzy opcje rysowania dla stołu wąż",
    "glassMaterial": "materiał szkła",
    "bitbybit.things.enums.lodEnum": "enum poziomu szczegółowości",
    "enums": "enumy",
    "lodEnum": "enum poziomu szczegółowości",
    "bitbybit.things.enums.lodEnum_description": "Tworzy wartość wyliczeniową poziomu szczegółowości",
    "bitbybit.jscad.transformSolids": "przekształć bryły",
    "jscad": "jscad",
    "transformSolids": "przekształć bryły",
    "bitbybit.jscad.transformSolids_description": "Przekształca siatki brył Jscad za pomocą podanej listy transformacji.",
    "JSCADEntity[]": "tablica encji jscad",
    "bitbybit.jscad.transformSolid": "przekształć bryłę",
    "transformSolid": "przekształć bryłę",
    "bitbybit.jscad.transformSolid_description": "Przekształca siatkę bryły Jscad za pomocą podanej listy transformacji.",
    "JSCADEntity": "encja jscad",
    "bitbybit.jscad.downloadSolidSTL": "pobierz stl bryły",
    "downloadSolidSTL": "pobierz stl bryły",
    "bitbybit.jscad.downloadSolidSTL_description": "Pobiera binarny plik STL z bryły 3D",
    "bitbybit.jscad.downloadSolidsSTL": "pobierz stl brył",
    "downloadSolidsSTL": "pobierz stl brył",
    "bitbybit.jscad.downloadSolidsSTL_description": "Pobiera binarny plik STL z brył 3D",
    "bitbybit.jscad.downloadGeometryDxf": "pobierz dxf geometrii",
    "downloadGeometryDxf": "pobierz dxf geometrii",
    "bitbybit.jscad.downloadGeometryDxf_description": "Pobiera plik dxf z geometrii jscad. Obsługuje ścieżki i siatki w tablicy.",
    "geometry": "geometria",
    "JSCADEntity | JSCADEntity[]": "encja jscad lub tablica",
    "bitbybit.jscad.downloadGeometry3MF": "pobierz 3mf geometrii",
    "downloadGeometry3MF": "pobierz 3mf geometrii",
    "bitbybit.jscad.downloadGeometry3MF_description": "Pobiera plik 3MF z geometrii jscad.",
    "bitbybit.jscad.booleans.intersect": "przecięcie",
    "intersect": "przecięcie",
    "bitbybit.jscad.booleans.intersect_description": "Przecięcie wielu obiektów siatek brył",
    "bitbybit.jscad.booleans.subtract": "odejmij",
    "subtract": "odejmij",
    "bitbybit.jscad.booleans.subtract_description": "Odejmij wiele obiektów siatek brył",
    "bitbybit.jscad.booleans.union": "suma",
    "bitbybit.jscad.booleans.union_description": "Suma wielu obiektów siatek brył",
    "bitbybit.jscad.booleans.intersectTwo": "przecięcie dwóch",
    "intersectTwo": "przecięcie dwóch",
    "bitbybit.jscad.booleans.intersectTwo_description": "Przecięcie dwóch obiektów siatek brył",
    "bitbybit.jscad.booleans.subtractTwo": "odejmij dwa",
    "subtractTwo": "odejmij dwa",
    "bitbybit.jscad.booleans.subtractTwo_description": "Odejmij dwa obiekty siatek brył",
    "bitbybit.jscad.booleans.unionTwo": "suma dwóch",
    "unionTwo": "suma dwóch",
    "bitbybit.jscad.booleans.unionTwo_description": "Suma dwóch obiektów siatek brył",
    "bitbybit.jscad.booleans.subtractFrom": "odejmij od",
    "subtractFrom": "odejmij od",
    "bitbybit.jscad.booleans.subtractFrom_description": "Odejmij wiele siatek od jednego obiektu siatki",
    "bitbybit.jscad.expansions.expand": "rozszerz",
    "expansions": "rozszerzenia",
    "expand": "rozszerz",
    "bitbybit.jscad.expansions.expand_description": "Rozszerz geometrie kategorii solid",
    "expansion": "rozszerzenie",
    "delta": "delta",
    "corners": "narożniki",
    "solidCornerTypeEnum": "typ narożnika bryły enum",
    "bitbybit.jscad.expansions.offset": "przesunięcie",
    "bitbybit.jscad.expansions.offset_description": "Przesuń geometrie 2d kategorii solid",
    "bitbybit.jscad.extrusions.extrudeLinear": "wyciągnij liniowo",
    "extrudeLinear": "wyciągnij liniowo",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Liniowe wyciągnięcie geometrii 2D kategorii solid",
    "twistAngle": "kąt skrętu",
    "twistSteps": "kroki skrętu",
    "bitbybit.jscad.extrusions.extrudeRectangular": "wyciągnij prostokątnie",
    "extrudeRectangular": "wyciągnij prostokątnie",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Prostokątne wyciągnięcie geometrii 2D kategorii solid. Tworzy wyciągnięcie typu ściana o określonej wysokości i rozmiarze.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "wyciągnij prostokątnie punkty",
    "extrudeRectangularPoints": "wyciągnij prostokątnie punkty",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Prostokątne wyciągnięcie listy punktów 2D. Tworzy wyciągnięcie typu ściana o określonej wysokości i rozmiarze.",
    "bitbybit.jscad.extrusions.extrudeRotate": "wyciągnij obrotowo",
    "extrudeRotate": "wyciągnij obrotowo",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Prostokątne wyciągnięcie listy punktów 2D. Tworzy wyciągnięcie typu ściana o określonej wysokości i rozmiarze.",
    "polygon": "wielokąt",
    "startAngle": "kąt początkowy",
    "bitbybit.jscad.hulls.hullChain": "łańcuch otoczki",
    "hulls": "otoczki",
    "hullChain": "łańcuch otoczki",
    "bitbybit.jscad.hulls.hullChain_description": "Łańcuch otoczki łączy bryły lub geometrie 2d wypełniając pustą przestrzeń między obiektami w kolejności. Geometrie muszą być tego samego typu.",
    "bitbybit.jscad.hulls.hull": "otoczka",
    "hull": "otoczka",
    "bitbybit.jscad.hulls.hull_description": "Otoczka wypukła łączy bryły lub geometrie 2d wypełniając pustą przestrzeń między bez zachowania kolejności. Geometrie muszą być tego samego typu.",
    "bitbybit.jscad.path.createFromPoints": "z punktów",
    "createFromPoints": "z punktów",
    "bitbybit.jscad.path.createFromPoints_description": "Utwórz ścieżkę 2D z listy punktów",
    "Base.Point2[]": "tablica punktów bazowych 2",
    "bitbybit.jscad.path.createPathsFromPoints": "ścieżki z punktów",
    "createPathsFromPoints": "ścieżki z punktów",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Utwórz ścieżki 2D z list punktów",
    "pointsLists": "listy punktów",
    "Base.Point3[][] | Base.Point2[][]": "tablica punktów bazowych 3 lub 2",
    "bitbybit.jscad.path.createFromPolyline": "z polilinii",
    "createFromPolyline": "z polilinii",
    "bitbybit.jscad.path.createFromPolyline_description": "Utwórz ścieżkę 2D z polilinii",
    "bitbybit.jscad.path.createEmpty": "pusta",
    "createEmpty": "pusta",
    "bitbybit.jscad.path.createEmpty_description": "Utwórz pustą ścieżkę 2D",
    "bitbybit.jscad.path.close": "zamknij",
    "close": "zamknij",
    "bitbybit.jscad.path.close_description": "Zamyka otwartą ścieżkę 2D",
    "bitbybit.jscad.path.appendPoints": "dołącz punkty",
    "appendPoints": "dołącz punkty",
    "bitbybit.jscad.path.appendPoints_description": "Dołącz punkty 2D do ścieżki",
    "append": "dołącz",
    "bitbybit.jscad.path.appendPolyline": "dołącz polilinię",
    "appendPolyline": "dołącz polilinię",
    "bitbybit.jscad.path.appendPolyline_description": "Dołącz polilinię do ścieżki",
    "bitbybit.jscad.path.appendArc": "dołącz łuk",
    "appendArc": "dołącz łuk",
    "bitbybit.jscad.path.appendArc_description": "Dołącz łuk do ścieżki",
    "xAxisRotation": "obrót osi x",
    "clockwise": "zgodnie z ruchem wskazówek zegara",
    "large": "duży",
    "bitbybit.jscad.polygon.createFromPoints": "z punktów",
    "bitbybit.jscad.polygon.createFromPoints_description": "Utwórz wielokąt 2D z listy punktów",
    "bitbybit.jscad.polygon.createFromPolyline": "z polilinii",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Utwórz wielokąt 2D z polilinii",
    "bitbybit.jscad.polygon.createFromCurve": "z krzywej",
    "createFromCurve": "z krzywej",
    "bitbybit.jscad.polygon.createFromCurve_description": "Utwórz wielokąt 2D z krzywej",
    "bitbybit.jscad.polygon.createFromPath": "ze ścieżki",
    "createFromPath": "ze ścieżki",
    "bitbybit.jscad.polygon.createFromPath_description": "Utwórz wielokąt 2D ze ścieżki",
    "bitbybit.jscad.polygon.circle": "okrąg",
    "bitbybit.jscad.polygon.circle_description": "Utwórz okrąg wielokątny 2D",
    "bitbybit.jscad.polygon.ellipse": "elipsa",
    "ellipse": "elipsa",
    "bitbybit.jscad.polygon.ellipse_description": "Utwórz elipsę wielokątną 2D",
    "bitbybit.jscad.polygon.rectangle": "prostokąt",
    "rectangle": "prostokąt",
    "bitbybit.jscad.polygon.rectangle_description": "Utwórz prostokąt wielokątny 2D",
    "bitbybit.jscad.polygon.roundedRectangle": "zaokrąglony prostokąt",
    "roundedRectangle": "zaokrąglony prostokąt",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Utwórz zaokrąglony prostokąt 2D",
    "roundRadius": "promień zaokrąglenia",
    "bitbybit.jscad.polygon.square": "kwadrat",
    "square": "kwadrat",
    "bitbybit.jscad.polygon.square_description": "Utwórz kwadrat wielokątny 2D",
    "bitbybit.jscad.polygon.star": "gwiazda",
    "star": "gwiazda",
    "bitbybit.jscad.polygon.star_description": "Utwórz gwiazdę wielokątną 2D",
    "vertices": "wierzchołki",
    "bitbybit.jscad.shapes.cube": "sześcian",
    "cube": "sześcian",
    "bitbybit.jscad.shapes.cube_description": "Utwórz kształt sześcianu 3D",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "sześciany na punktach środkowych",
    "cubesOnCenterPoints": "sześciany na punktach środkowych",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Utwórz sześciany 3D na wielu punktach środkowych",
    "primitives on centers": "prymitywy na środkach",
    "bitbybit.jscad.shapes.cuboid": "prostopadłościan",
    "cuboid": "prostopadłościan",
    "bitbybit.jscad.shapes.cuboid_description": "Utwórz kształt prostopadłościanu 3D",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "prostopadłościany na punktach środkowych",
    "cuboidsOnCenterPoints": "prostopadłościany na punktach środkowych",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Utwórz prostopadłościany 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.cylinderElliptic": "walec eliptyczny",
    "cylinderElliptic": "walec eliptyczny",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Utwórz bryłę walca eliptycznego 3D",
    "startRadius": "promień początkowy",
    "endRadius": "promień końcowy",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "walec eliptyczny na punktach środkowych",
    "cylinderEllipticOnCenterPoints": "walec eliptyczny na punktach środkowych",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Utwórz walce eliptyczne 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.cylinder": "walec",
    "cylinder": "walec",
    "bitbybit.jscad.shapes.cylinder_description": "Utwórz bryłę walca 3D",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "walce na punktach środkowych",
    "cylindersOnCenterPoints": "walce na punktach środkowych",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Utwórz walce 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.ellipsoid": "elipsoida",
    "ellipsoid": "elipsoida",
    "bitbybit.jscad.shapes.ellipsoid_description": "Utwórz bryłę elipsoidy 3D",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "elipsoidy na punktach środkowych",
    "ellipsoidsOnCenterPoints": "elipsoidy na punktach środkowych",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Utwórz elipsoidy 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.geodesicSphere": "kula geodezyjna",
    "geodesicSphere": "kula geodezyjna",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Utwórz bryłę kuli geodezyjnej 3D",
    "frequency": "częstotliwość",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "kule geodezyjne na punktach środkowych",
    "geodesicSpheresOnCenterPoints": "kule geodezyjne na punktach środkowych",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Utwórz kule geodezyjne 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.roundedCuboid": "zaokrąglony prostopadłościan",
    "roundedCuboid": "zaokrąglony prostopadłościan",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Utwórz bryłę zaokrąglonego prostopadłościanu 3D",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "zaokrąglone prostopadłościany na punktach środkowych",
    "roundedCuboidsOnCenterPoints": "zaokrąglone prostopadłościany na punktach środkowych",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Utwórz zaokrąglone prostopadłościany 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.roundedCylinder": "zaokrąglony walec",
    "roundedCylinder": "zaokrąglony walec",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Utwórz bryłę zaokrąglonego walca 3D",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "zaokrąglone walce na punktach środkowych",
    "roundedCylindersOnCenterPoints": "zaokrąglone walce na punktach środkowych",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Utwórz zaokrąglone walce 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.sphere": "kula",
    "sphere": "kula",
    "bitbybit.jscad.shapes.sphere_description": "Utwórz bryłę kuli 3D",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "kule na punktach środkowych",
    "spheresOnCenterPoints": "kule na punktach środkowych",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Utwórz kulę 3D na wielu punktach środkowych",
    "bitbybit.jscad.shapes.torus": "torus",
    "torus": "torus",
    "bitbybit.jscad.shapes.torus_description": "Utwórz bryłę torusa 3D",
    "innerSegments": "segmenty wewnętrzne",
    "outerSegments": "segmenty zewnętrzne",
    "innerRotation": "obrót wewnętrzny",
    "outerRotation": "obrót zewnętrzny",
    "bitbybit.jscad.shapes.fromPolygonPoints": "z punktów wielokąta",
    "fromPolygonPoints": "z punktów wielokąta",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Utwórz kształt 3D z punktów wielokąta, które muszą być zagnieżdżonymi tablicami punktów",
    "polygonPoints": "punkty wielokąta",
    "Base.Point3[][]": "tablica punktów bazowych 3",
    "bitbybit.jscad.text.cylindricalText": "tekst cylindryczny",
    "cylindricalText": "tekst cylindryczny",
    "bitbybit.jscad.text.cylindricalText_description": "Tworzy tekst oparty na łańcuchowym łączeniu otoczek cylindrów",
    "extrusionHeight": "wysokość wyciągnięcia",
    "extrusionSize": "rozmiar wyciągnięcia",
    "jscadTextAlignEnum": "jscad wyrównanie tekstu enum",
    "bitbybit.jscad.text.sphericalText": "tekst sferyczny",
    "sphericalText": "tekst sferyczny",
    "bitbybit.jscad.text.sphericalText_description": "Tworzy tekst oparty na łańcuchowym łączeniu otoczek kul",
    "bitbybit.jscad.text.createVectorText": "tekst wektorowy",
    "createVectorText": "tekst wektorowy",
    "bitbybit.jscad.text.createVectorText_description": "Tworzy tekst wektorowy",
    "bitbybit.jscad.colors.colorize": "pokoloruj",
    "colors": "kolory",
    "colorize": "pokoloruj",
    "bitbybit.jscad.colors.colorize_description": "Koloruje geometrię jscad. Jeśli geometria jest w tablicy, pokoloruje wszystkie elementy i zwróci je. Jeśli geometria jest pojedynczym elementem, zwróci pojedynczy element. Pamiętaj, że pokolorowana geometria w jscad zawsze będzie rysowana w tym kolorze, nawet jeśli spróbujesz zmienić go za pomocą opcji rysowania.",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold na wskaźnik siatki",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold na wskaźnik siatki",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Zamienia kształt manifold na wskaźnik siatki, który żyje w pamięci workera. Tego wskaźnika można używać z funkcjami bitbybit.manifold.mesh",
    "meshing": "siatkowanie",
    "normalIdx": "indeks normalnej",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "rozłóż manifold lub przekrój",
    "decomposeManifoldOrCrossSection": "rozłóż manifold lub przekrój",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Rozkłada kształt manifold lub przekrój na siatkę lub proste wielokąty",
    "decompose": "rozłóż",
    "manifoldOrCrossSection": "manifold lub przekrój",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "rozłóż manifoldy lub przekroje",
    "decomposeManifoldsOrCrossSections": "rozłóż manifoldy lub przekroje",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Rozkłada kształt manifold lub przekrój na siatkę lub proste wielokąty",
    "manifoldsOrCrossSections": "manifoldy lub przekroje",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "usuń manifold lub przekrój",
    "deleteManifoldOrCrossSection": "usuń manifold lub przekrój",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Usuń manifold lub przekrój z pamięci",
    "cleanup": "czyszczenie",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "usuń manifoldy lub przekroje",
    "deleteManifoldsOrCrossSections": "usuń manifoldy lub przekroje",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Usuń manifoldy lub przekroje z pamięci",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold na siatkę",
    "manifoldToMesh": "manifold na siatkę",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Zamienia kształt manifold na siatkę",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifoldy na siatki",
    "manifoldsToMeshes": "manifoldy na siatki",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "zamienia kształty manifold na siatki",
    "manifolds": "manifoldy",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold z siatki",
    "manifoldFromMesh": "manifold z siatki",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Konwertuje siatkę na Manifold, zachowując jej właściwości i łącząc tylko pozycje zgodnie z wektorami łączenia. Zgłosi błąd, jeśli wynik nie jest zorientowanym 2-manifoldem. Zwinie zdegenerowane trójkąty i niepotrzebne wierzchołki. Wszystkie pola są odczytywane, co sprawia, że ta struktura nadaje się do bezstratnego obiegu danych z manifoldToMesh(). Dla wejścia wielomateriałowego użyj reserveIDs(), aby ustawić unikalny originalID dla każdego materiału, i posortuj materiały w ciągi trójkątów.",
    "DecomposedManifoldMeshDto": "zdekomponowana siatka manifold dto",
    "bitbybit.manifold.manifold.shapes.cube": "sześcian",
    "bitbybit.manifold.manifold.shapes.cube_description": "Utwórz kształt sześcianu 3D",
    "bitbybit.manifold.manifold.shapes.sphere": "kula",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Utwórz kształt kuli 3D",
    "circularSegments": "segmenty kołowe",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "czworościan",
    "tetrahedron": "czworościan",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Utwórz kształt czworościanu 3D",
    "bitbybit.manifold.manifold.shapes.cylinder": "walec",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Utwórz kształt walca 3D",
    "radiusLow": "promień dolny",
    "radiusHigh": "promień górny",
    "bitbybit.manifold.manifold.booleans.subtract": "odejmij",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Odejmij dwa kształty manifold",
    "a to b": "a do b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "dodaj",
    "bitbybit.manifold.manifold.booleans.add_description": "Dodaj dwa kształty manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "przecięcie",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Przecięcie dwóch kształtów manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "różnica dwóch",
    "differenceTwo": "różnica dwóch",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "różnica dwóch kształtów manifold",
    "2 manifolds": "2 manifoldy",
    "bitbybit.manifold.manifold.booleans.unionTwo": "suma dwóch",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "suma dwóch kształtów manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "przecięcie dwóch",
    "intersectionTwo": "przecięcie dwóch",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "przecięcie dwóch kształtów manifold",
    "bitbybit.manifold.manifold.booleans.difference": "różnica",
    "bitbybit.manifold.manifold.booleans.difference_description": "różnica wielu kształtów manifold",
    "bitbybit.manifold.manifold.booleans.union": "suma",
    "bitbybit.manifold.manifold.booleans.union_description": "suma wielu kształtów manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "przecięcie",
    "bitbybit.manifold.manifold.booleans.intersection_description": "przecięcie wielu kształtów manifold",
    "bitbybit.manifold.manifold.booleans.split": "podziel",
    "split": "podziel",
    "bitbybit.manifold.manifold.booleans.split_description": "Podziel manifold innym manifoldem",
    "manifoldToSplit": "manifold do podziału",
    "manifoldCutter": "manifold tnący",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "podziel płaszczyzną",
    "splitByPlane": "podziel płaszczyzną",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Podziel manifold płaszczyzną",
    "originOffset": "przesunięcie początku",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "podziel płaszczyzną na przesunięciach",
    "splitByPlaneOnOffsets": "podziel płaszczyzną na przesunięciach",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Podziel manifold płaszczyzną na różnych przesunięciach",
    "originOffsets": "przesunięcia początku",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "przytnij płaszczyzną",
    "trimByPlane": "przytnij płaszczyzną",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Przytnij manifold płaszczyzną",
    "trim": "przytnij",
    "bitbybit.manifold.manifold.operations.hull": "otoczka",
    "bitbybit.manifold.manifold.operations.hull_description": "Oblicza otoczkę wypukłą dostarczonego kształtu manifold",
    "bitbybit.manifold.manifold.operations.hullPoints": "punkty otoczki",
    "hullPoints": "punkty otoczki",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Punkty otoczki lub manifoldy",
    "bitbybit.manifold.manifold.operations.slice": "tnij",
    "bitbybit.manifold.manifold.operations.slice_description": "Zwraca przekrój tego obiektu równoległy do płaszczyzny X-Y na określonej wysokości. Użycie wysokości równej dołowi prostopadłościanu otaczającego zwróci dolne ściany, podczas gdy użycie wysokości równej górze prostopadłościanu otaczającego zwróci pusty wynik.",
    "cross sections": "przekroje",
    "bitbybit.manifold.manifold.operations.project": "rzutuj",
    "bitbybit.manifold.manifold.operations.project_description": "Tworzy rzutowanie na płaszczyznę xy z obrysu kształtu",
    "bitbybit.manifold.manifold.operations.setTolerance": "ustaw tolerancję",
    "setTolerance": "ustaw tolerancję",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Zwraca kopię manifoldu z ustawioną wartością tolerancji. Wykonuje to uproszczenie siatki, gdy wartość tolerancji jest zwiększana.",
    "basic": "podstawowy",
    "bitbybit.manifold.manifold.operations.reserveIds": "zarezerwuj id",
    "reserveIds": "zarezerwuj id",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Zwraca pierwszy z n kolejnych nowych unikalnych identyfikatorów siatki do oznaczania zestawów trójkątów, które można wyszukać po dalszych operacjach. Przypisz do wektora Mesh.runOriginalID.",
    "count": "liczba",
    "bitbybit.manifold.manifold.operations.asOriginal": "jako oryginał",
    "asOriginal": "jako oryginał",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "Jeśli kopiujesz manifold, ale chcesz, aby ta nowa kopia miała nowe właściwości (np. inne mapowanie UV), możesz zresetować jej ID do nowego oryginału, co oznacza, że będzie teraz odwoływać się do niej przez jej potomków zamiast siatek, z których została zbudowana, co pozwala na rozróżnienie kopii podczas stosowania właściwości do wyniku końcowego. Ta funkcja również kondensuje wszystkie współpłaszczyznowe ściany w relacji i zwija te krawędzie. Jeśli chcesz mieć niespójne właściwości na tych ścianach, co oznacza, że chcesz zachować niektóre z tych krawędzi, powinieneś zamiast tego wywołać GetMesh(), obliczyć swoje właściwości i użyć ich do skonstruowania nowego manifoldu.",
    "bitbybit.manifold.manifold.operations.compose": "komponuj",
    "compose": "komponuj",
    "bitbybit.manifold.manifold.operations.compose_description": "Konstruuje nowy manifold z listy innych manifoldów. Jest to operacja czysto topologiczna, więc należy uważać, aby uniknąć tworzenia nakładających się wyników. Jest to odwrotna operacja do Decompose().",
    "composition": "kompozycja",
    "bitbybit.manifold.manifold.operations.decompose": "rozłóż",
    "bitbybit.manifold.manifold.operations.decompose_description": "Ta operacja zwraca wektor Manifoldów, które są topologicznie rozłączone. Jeśli wszystko jest połączone, wektor ma długość jeden, zawierając kopię oryginału. Jest to odwrotna operacja do Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "oblicz normalne",
    "calculateNormals": "oblicz normalne",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Wypełnia właściwości wierzchołków wektorami normalnymi, obliczonymi z geometrii siatki. Płaskie ściany złożone z trzech lub więcej trójkątów pozostaną płaskie.",
    "adjustments": "korekty",
    "minSharpAngle": "min ostry kąt",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "oblicz krzywiznę",
    "calculateCurvature": "oblicz krzywiznę",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "Krzywizna jest odwrotnością promienia krzywizny i jest oznaczona tak, że dodatnia jest wypukła, a ujemna wklęsła. W każdym punkcie manifoldu istnieją dwie ortogonalne krzywizny główne, jedna maksymalna, a druga minimalna. Krzywizna Gaussa jest ich iloczynem, podczas gdy krzywizna średnia jest ich sumą. To przybliża je dla każdego wierzchołka i przypisuje je jako właściwości wierzchołka na podanych kanałach.",
    "gaussianIdx": "indeks gaussa",
    "meanIdx": "indeks średni",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "uszlachetnij do tolerancji",
    "refineToTolerance": "uszlachetnij do tolerancji",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Zwiększ gęstość siatki, dzieląc każdą krawędź na części tak, aby każdy punkt na wynikowych trójkątach mieścił się mniej więcej w tolerancji gładko zakrzywionej powierzchni zdefiniowanej przez wektory styczne. Oznacza to, że obszary o dużej krzywiźnie będą dzielone drobniej niż obszary gładsze. Jeśli halfedgeTangents nie są obecne, wynik będzie po prostu kopią oryginału. Czworokąty zignorują swój wewnętrzny dwusieczny trójkąta.",
    "bitbybit.manifold.manifold.operations.refineToLength": "uszlachetnij do długości",
    "refineToLength": "uszlachetnij do długości",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Zwiększ gęstość siatki, dzieląc każdą krawędź na części o przybliżonej długości wejściowej. Dodawane są wierzchołki wewnętrzne, aby reszta krawędzi triangulacji miała również mniej więcej tę samą długość. Jeśli obecne są halfedgeTangents (np. z konstruktora Smooth()), nowe wierzchołki zostaną przesunięte na interpolowaną powierzchnię zgodnie z ich współrzędnymi barycentrycznymi.",
    "bitbybit.manifold.manifold.operations.refine": "uszlachetnij",
    "refine": "uszlachetnij",
    "bitbybit.manifold.manifold.operations.refine_description": "Zwiększ gęstość siatki, dzieląc każdą krawędź na n części. Na przykład przy n = 2 każdy trójkąt zostanie podzielony na 4 trójkąty. Wszystkie one będą współpłaszczyznowe (i nie zostaną natychmiast zwinięte), chyba że MeshManifold ma określone halfedgeTangents (np. z konstruktora Smooth()), w którym to przypadku nowe wierzchołki zostaną przesunięte na interpolowaną powierzchnię zgodnie z ich współrzędnymi barycentrycznymi.",
    "bitbybit.manifold.manifold.operations.smoothOut": "wygładź",
    "smoothOut": "wygładź",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Wygładza Manifold, wypełniając wektory halfedgeTangent. Geometria pozostanie niezmieniona do momentu wywołania Refine lub RefineToLength w celu interpolacji powierzchni. Ta wersja wykorzystuje geometrię trójkątów i pseudo-normalnych do zdefiniowania wektorów stycznych.",
    "minSmoothness": "min gładkość",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "wygładź normalnymi",
    "smoothByNormals": "wygładź normalnymi",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Wygładza Manifold, wypełniając wektory halfedgeTangent. Geometria pozostanie niezmieniona do momentu wywołania Refine lub RefineToLength w celu interpolacji powierzchni. Ta wersja wykorzystuje dostarczone właściwości normalnych wierzchołków do zdefiniowania wektorów stycznych.",
    "bitbybit.manifold.manifold.transforms.scale3D": "skaluj 3d",
    "scale3D": "skaluj 3d",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Skaluje kształt manifold wektorem 3D",
    "bitbybit.manifold.manifold.transforms.scale": "skaluj",
    "bitbybit.manifold.manifold.transforms.scale_description": "Skaluje kształt manifold pojedynczym współczynnikiem",
    "bitbybit.manifold.manifold.transforms.mirror": "odbij",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Odbija lustrzanie kształt manifold względem płaszczyzny zdefiniowanej przez wektor normalny",
    "bitbybit.manifold.manifold.transforms.translate": "przesuń",
    "bitbybit.manifold.manifold.transforms.translate_description": "Przesuwa kształt manifold wzdłuż wektora",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "przesuń wektorami",
    "translateByVectors": "przesuń wektorami",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Przesuwa kształt manifold wzdłuż wielu wektorów",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "przesuń xyz",
    "translateXYZ": "przesuń xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Przesuwa kształt manifold wzdłuż x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "obróć",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Obraca kształt manifold wzdłuż wektora zawierającego kąty eulera",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "obróć xyz",
    "rotateXYZ": "obróć xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Obraca kształt manifold wzdłuż kątów eulera x y z",
    "bitbybit.manifold.manifold.transforms.transform": "przekształć",
    "bitbybit.manifold.manifold.transforms.transform_description": "Przekształca kształt manifold używając macierzy transformacji 4x4",
    "matrix": "macierz",
    "Base.TransformMatrix": "bazowa macierz transformacji",
    "bitbybit.manifold.manifold.transforms.transforms": "przekształcenia",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Przekształca kształt manifold używając macierzy transformacji 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "pole powierzchni",
    "evaluate": "ewaluacja",
    "surfaceArea": "pole powierzchni",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Pobierz pole powierzchni manifoldu",
    "bitbybit.manifold.manifold.evaluate.volume": "objętość",
    "volume": "objętość",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Pobierz objętość manifoldu",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "jest pusty",
    "isEmpty": "jest pusty",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Sprawdź, czy manifold zawiera trójkąty",
    "bitbybit.manifold.manifold.evaluate.numVert": "liczba wierzch",
    "numVert": "liczba wierzch",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Pobierz liczbę wierzchołków w manifoldzie",
    "bitbybit.manifold.manifold.evaluate.numTri": "liczba trój",
    "numTri": "liczba trój",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Pobierz liczbę trójkątów w manifoldzie",
    "bitbybit.manifold.manifold.evaluate.numEdge": "liczba kraw",
    "numEdge": "liczba kraw",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Pobierz liczbę krawędzi w manifoldzie",
    "bitbybit.manifold.manifold.evaluate.numProp": "liczba właś",
    "numProp": "liczba właś",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Pobierz liczbę właściwości w manifoldzie",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "liczba właś wierzch",
    "numPropVert": "liczba właś wierzch",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "Liczba wierzchołków właściwości w Manifoldzie. Będzie ona zawsze >= numVert, ponieważ niektóre wierzchołki fizyczne mogą być zduplikowane, aby uwzględnić różne właściwości na różnych sąsiednich trójkątach.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "prostopadłościan otaczający",
    "boundingBox": "prostopadłościan otaczający",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Zwraca wyrównany do osi prostopadłościan otaczający (bounding box) wszystkich wierzchołków Manifoldu.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolerancja",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Zwraca tolerancję wierzchołków tego Manifoldu, która śledzi przybliżony błąd zaokrąglenia we wszystkich transformacjach i operacjach, które doprowadziły do tego stanu. Wszelkie trójkąty, które są współliniowe w tej tolerancji, są uważane za zdegenerowane i usuwane. Jest to wartość epsilon definiująca [epsilon-valid](https://github.com/elalish/manifold/wiki/Manifold-Library#definition-of-%CE%B5-valid).",
    "bitbybit.manifold.manifold.evaluate.genus": "rodzaj",
    "genus": "rodzaj",
    "bitbybit.manifold.manifold.evaluate.genus_description": "Rodzaj (genus) to właściwość topologiczna rozmaitości, reprezentująca liczbę uchwytów. Sfera ma 0, torus 1 itd. Ma to znaczenie tylko dla pojedynczej siatki, więc najlepiej najpierw wywołać Decompose().",
    "bitbybit.manifold.manifold.evaluate.minGap": "min luka",
    "minGap": "min luka",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Zwraca minimalną przerwę między dwoma manifoldami. Zwraca float od 0 do searchLength.",
    "searchLength": "długość przeszukiwania",
    "bitbybit.manifold.manifold.evaluate.originalID": "oryginalne id",
    "originalID": "oryginalne id",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "Jeśli ta siatka jest oryginałem, zwraca jej ID, do którego mogą odwoływać się manifoldy produktowe. Jeśli ten manifold jest produktem, zwraca -1.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "przekrój na wielokąty",
    "crossSection": "przekrój",
    "crossSectionToPolygons": "przekrój na wielokąty",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "zamienia przekrój na wielokąty",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "przekroje na wielokąty",
    "crossSectionsToPolygons": "przekroje na wielokąty",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "zamienia przekroje na wielokąty",
    "crossSections": "przekroje",
    "bitbybit.manifold.crossSection.shapes.create": "utwórz",
    "bitbybit.manifold.crossSection.shapes.create_description": "Utwórz przekrój 2d z zestawu konturów (złożonych wielokątów). Wykonywana jest operacja sumy logicznej (domyślnie z regułą wypełniania Positive), aby połączyć nakładające się wielokąty i zapewnić, że wynikowy CrossSection jest wolny od przecięć.",
    "Base.Vector2[][]": "tablica wektorów bazowych 2",
    "fillRule": "reguła wypełniania",
    "fillRuleEnum": "reguła wypełniania enum",
    "bitbybit.manifold.crossSection.shapes.square": "kwadrat",
    "bitbybit.manifold.crossSection.shapes.square_description": "Utwórz kwadratowy przekrój 2D",
    "bitbybit.manifold.crossSection.shapes.circle": "okrąg",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Utwórz okrągły przekrój 2D",
    "bitbybit.manifold.crossSection.shapes.rectangle": "prostokąt",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Utwórz prostokątny przekrój 2D",
    "bitbybit.manifold.crossSection.operations.hull": "otoczka",
    "bitbybit.manifold.crossSection.operations.hull_description": "Oblicz otoczkę wypukłą dla przekroju",
    "bitbybit.manifold.crossSection.operations.extrude": "wyciągnij",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Wyciągnij przekrój, aby utworzyć kształt 3D",
    "nDivisions": "n podziałów",
    "twistDegrees": "stopnie skrętu",
    "scaleTopX": "skala góra x",
    "scaleTopY": "skala góra y",
    "bitbybit.manifold.crossSection.operations.revolve": "obróć",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Obróć przekrój, aby utworzyć kształt 3D",
    "revolveDegrees": "stopnie obrotu",
    "matchProfile": "dopasuj profil",
    "bitbybit.manifold.crossSection.operations.offset": "przesunięcie",
    "bitbybit.manifold.crossSection.operations.offset_description": "Przesuwa przekrój, aby utworzyć nowy przekrój z daną deltą (używa algorytmu Clipper2 pod spodem).",
    "manifoldJoinTypeEnum": "typ łączenia manifold enum",
    "miterLimit": "limit skosu",
    "bitbybit.manifold.crossSection.operations.simplify": "uprość",
    "simplify": "uprość",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Usuń wierzchołki z konturów w tym CrossSection, które znajdują się w odległości mniejszej niż określona epsilon od wyimaginowanej linii przechodzącej przez dwa sąsiednie wierzchołki. Bliskie duplikaty wierzchołków i punkty współliniowe zostaną usunięte przy niższych epsilonach, a eliminacja segmentów linii stanie się coraz bardziej agresywna przy większych epsilonach. Zaleca się stosowanie tej funkcji po Offset, aby wyczyścić wszelkie fałszywe, drobne segmenty linii wprowadzone, które nie poprawiają operacji przesunięcia, co pogorszyłoby problem.",
    "epsilon": "epsilon",
    "bitbybit.manifold.crossSection.operations.compose": "komponuj",
    "bitbybit.manifold.crossSection.operations.compose_description": "Komponuje wiele przekrojów lub wielokątów w jeden przekrój",
    "bitbybit.manifold.crossSection.operations.decompose": "rozłóż",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Rozłóż przekroje, które są topologicznie rozłączone, z których każdy zawiera jeden kontur zewnętrzny z zero lub więcej otworami.",
    "bitbybit.manifold.crossSection.booleans.subtract": "odejmij",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Odejmij dwa przekroje",
    "crossSection1": "przekrój 1",
    "crossSection2": "przekrój 2",
    "bitbybit.manifold.crossSection.booleans.add": "dodaj",
    "bitbybit.manifold.crossSection.booleans.add_description": "Dodaj dwa przekroje",
    "bitbybit.manifold.crossSection.booleans.intersect": "przecięcie",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Przecięcie dwóch przekrojów",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "różnica dwóch",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "różnica dwóch przekrojów",
    "2 cross sections": "2 przekroje",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "suma dwóch",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "suma dwóch przekrojów",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "przecięcie dwóch",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "przecięcie dwóch przekrojów",
    "bitbybit.manifold.crossSection.booleans.difference": "różnica",
    "bitbybit.manifold.crossSection.booleans.difference_description": "różnica wielu przekrojów",
    "bitbybit.manifold.crossSection.booleans.union": "suma",
    "bitbybit.manifold.crossSection.booleans.union_description": "suma wielu przekrojów",
    "bitbybit.manifold.crossSection.booleans.intersection": "przecięcie",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "przecięcie wielu przekrojów",
    "bitbybit.manifold.crossSection.transforms.scale2D": "skaluj 2d",
    "scale2D": "skaluj 2d",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Skaluje kształt przekroju wektorem 2D",
    "bitbybit.manifold.crossSection.transforms.scale": "skaluj",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Skaluje kształt przekroju pojedynczym współczynnikiem",
    "bitbybit.manifold.crossSection.transforms.mirror": "odbij",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Odbija lustrzanie kształt przekroju względem płaszczyzny zdefiniowanej przez wektor normalny",
    "bitbybit.manifold.crossSection.transforms.translate": "przesuń",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Przesuwa kształt przekroju wzdłuż wektora",
    "bitbybit.manifold.crossSection.transforms.translateXY": "przesuń xy",
    "translateXY": "przesuń xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Przesuwa kształt przekroju wzdłuż x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "obróć",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Obraca kształt przekroju o zawarte stopnie",
    "degrees": "stopnie",
    "bitbybit.manifold.crossSection.transforms.transform": "przekształć",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Przekształca kształt przekroju używając macierzy transformacji 3x3",
    "Base.TransformMatrix3x3": "bazowa macierz transformacji 3x3",
    "area": "pole powierzchni",
    "bitbybit.manifold.crossSection.evaluate.area": "pole powierzchni",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Pobierz pole powierzchni przekroju",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "jest pusty",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Sprawdź czy przekrój jest pusty",
    "bitbybit.manifold.crossSection.evaluate.numVert": "liczba wierzch",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Pobierz liczbę wierzchołków w przekroju",
    "bitbybit.manifold.crossSection.evaluate.numContour": "liczba konturów",
    "numContour": "liczba konturów",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Pobierz liczbę konturów w przekroju",
    "bitbybit.manifold.crossSection.evaluate.bounds": "granice",
    "bounds": "granice",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Pobierz granice konturu jako prostokąt. Wynik podawany jest w dwóch punktach vec2 w tablicy. Pierwsza tablica to punkt min, a druga to punkt max.",
    "bitbybit.manifold.mesh.operations.merge": "scal",
    "merge": "scal",
    "bitbybit.manifold.mesh.operations.merge_description": "Aktualizuje wektory mergeFromVert i mergeToVert w celu utworzenia bryły manifold. Jeśli MeshGL jest już manifoldem, nie nastąpi żadna zmiana, a funkcja zwróci false. W przeciwnym razie scali wierzchołki wzdłuż otwartych krawędzi w granicach tolerancji (maksimum tolerancji MeshGL i podstawowej tolerancji prostopadłościanu otaczającego), zachowując wszelkie z istniejących wektorów scalania. Nie ma gwarancji, że wynik będzie manifoldem - jest to funkcja pomocnicza typu best-effort, zaprojektowana głównie w celu pomocy w przypadku, gdy wyprodukowano manifold MeshGL z wieloma materiałami, ale jego wektory scalania zostały utracone z powodu obiegu przez format pliku. Konstruowanie Manifoldu z wyniku zgłosi Status, jeśli nie jest to manifold.",
    "bitbybit.manifold.mesh.evaluate.position": "pozycja",
    "bitbybit.manifold.mesh.evaluate.position_description": "Pobierz pozycję na indeksie wierzchołka siatki",
    "vertexIndex": "indeks wierzchołka",
    "bitbybit.manifold.mesh.evaluate.verts": "wierzch",
    "verts": "wierzch",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Pobiera trzy indeksy wierzchołków tego trójkąta w kolejności przeciwnym do ruchu wskazówek zegara (CCW).",
    "triangleIndex": "indeks trójkąta",
    "bitbybit.manifold.mesh.evaluate.tangent": "styczna",
    "tangent": "styczna",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Pobiera wektor styczny zaczynający się w verts(tri)[j] wskazujący na następny punkt Beziera wzdłuż krawędzi CCW. Czwarta wartość to jego waga.",
    "halfEdgeIndex": "indeks półkrawędzi",
    "bitbybit.manifold.mesh.evaluate.extras": "dodatki",
    "extras": "dodatki",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Pobiera wszelkie inne właściwości powiązane z tym wierzchołkiem.",
    "bitbybit.manifold.mesh.evaluate.transform": "przekształć",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Pobiera macierz transformacji 4x4 w układzie kolumnowym z oryginalnej siatki do tych powiązanych trójkątów.",
    "bitbybit.manifold.mesh.evaluate.numProp": "liczba właś",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Liczba właściwości na wierzchołek, zawsze >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "liczba wierzch",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Liczba wierzchołków właściwości",
    "bitbybit.manifold.mesh.evaluate.numTri": "liczba trój",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Pobierz liczbę trójkątów w siatce",
    "bitbybit.manifold.mesh.evaluate.numRun": "liczba biegów",
    "numRun": "liczba biegów",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Liczba biegów trójkątów. Każdy bieg trójkątów to zbiór kolejnych trójkątów, które pochodzą z tej samej instancji tej samej siatki wejściowej.",
    "bitbybit.logic.boolean": "logiczny",
    "logic": "logika",
    "bitbybit.logic.boolean_description": "Tworzy i zwraca wartość logiczną (przekazuje wartość wejściową). Przykład: true → true, false → false",
    "bitbybit.logic.randomBooleans": "losowe wartości logiczne",
    "randomBooleans": "losowe wartości logiczne",
    "bitbybit.logic.randomBooleans_description": "Generuje losową listę wartości logicznych, gdzie każda wartość ma szansę na bycie true określoną przez próg. Przykład: długość=5, próg=0.7 → może wygenerować [true, true, false, true, true]",
    "trueThreshold": "próg prawdy",
    "bitbybit.logic.twoThresholdRandomGradient": "dwuprogowy losowy gradient",
    "twoThresholdRandomGradient": "dwuprogowy losowy gradient",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Konwertuje liczby na wartości logiczne używając dwóch progów z losowym gradientem pomiędzy nimi. Wartości poniżej progu prawdy → zawsze true, powyżej progu fałszu → zawsze false. Pomiędzy progami → gradient prawdopodobieństwa (bliżej progu fałszu = wyższa szansa na false). Przykład: [0.1, 0.4, 0.6, 0.9] z progami [0.3, 0.7] → [true, gradient, gradient, false]",
    "numbers": "liczby",
    "thresholdTotalTrue": "próg całkowitej prawdy",
    "thresholdTotalFalse": "próg całkowitego fałszu",
    "nrLevels": "liczba poziomów",
    "bitbybit.logic.thresholdBooleanList": "progowa lista logiczna",
    "thresholdBooleanList": "progowa lista logiczna",
    "bitbybit.logic.thresholdBooleanList_description": "Konwertuje liczby na wartości logiczne na podstawie progu (poniżej progu → true, powyżej → false). Można odwrócić logikę. Przykład: [0.3, 0.7, 0.5] z progiem=0.6 → [true, false, true]",
    "threshold": "próg",
    "bitbybit.logic.thresholdGapsBooleanList": "progowa lista luk logicznych",
    "thresholdGapsBooleanList": "progowa lista luk logicznych",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Konwertuje liczby na wartości logiczne używając wielu zakresów progowych (luki definiują zakresy true). Wartości w dowolnym zakresie luki → true, poza wszystkimi lukami → false. Można odwrócić. Przykład: [0.2, 0.5, 0.8] z lukami [[0.3, 0.6], [0.7, 0.9]] → [false, true, true]",
    "gapThresholds": "progi luk",
    "Base.Vector2[]": "tablica wektorów bazowych 2",
    "bitbybit.logic.not": "nie",
    "not": "nie",
    "bitbybit.logic.not_description": "Stosuje operator NIE (NOT), aby odwrócić wartość logiczną. Przykład: true → false, false → true",
    "bitbybit.logic.notList": "lista nie",
    "notList": "lista nie",
    "bitbybit.logic.notList_description": "Stosuje operator NIE (NOT), aby odwrócić wszystkie wartości logiczne w liście. Przykład: [true, false, true] → [false, true, false]",
    "bitbybit.logic.compare": "porównaj",
    "compare": "porównaj",
    "bitbybit.logic.compare_description": "Porównuje dwie wartości używając różnych operatorów (==, !=, ===, !==, <, <=, >, >=). Przykład: 5 > 3 → true, 'hello' === 'world' → false",
    "operator": "operator",
    "BooleanOperatorsEnum": "enum operatorów logicznych",
    "bitbybit.logic.valueGate": "bramka wartości",
    "valueGate": "bramka wartości",
    "bitbybit.logic.valueGate_description": "Warunkowo przepuszcza wartość jeśli wartość logiczna jest true, w przeciwnym razie zwraca undefined. Przykład: wartość=42, boolean=true → 42, wartość=42, boolean=false → undefined",
    "bitbybit.logic.firstDefinedValueGate": "bramka pierwszej zdefiniowanej wartości",
    "firstDefinedValueGate": "bramka pierwszej zdefiniowanej wartości",
    "bitbybit.logic.firstDefinedValueGate_description": "Zwraca pierwszą zdefiniowaną (nie undefined) wartość z dwóch opcji (wzorzec fallback). Przykład: wartość1=42, wartość2=10 → 42, wartość1=undefined, wartość2=10 → 10",
    "value1": "wartość 1",
    "value2": "wartość 2",
    "bitbybit.math.number": "liczba",
    "math": "matematyka",
    "bitbybit.math.number_description": "Tworzy i zwraca wartość liczbową (przekazuje wartość wejściową). Przykład: Wejście 42 → 42, Wejście 3.14 → 3.14",
    "bitbybit.math.twoNrOperation": "operacja na dwóch liczbach",
    "twoNrOperation": "operacja na dwóch liczbach",
    "bitbybit.math.twoNrOperation_description": "Wykonuje podstawowe operacje arytmetyczne na dwóch liczbach (dodawanie, odejmowanie, mnożenie, dzielenie, potęgowanie, modulo). Przykład: 5 + 3 → 8, 10 % 3 → 1, 2 ^ 3 → 8",
    "operation": "operacja",
    "mathTwoNrOperatorEnum": "enum operatorów matematycznych dwóch liczb",
    "bitbybit.math.modulus": "modulo",
    "modulus": "modulo",
    "bitbybit.math.modulus_description": "Oblicza resztę z dzielenia (operacja modulo). Przykład: 10 % 3 → 1, 17 % 5 → 2",
    "bitbybit.math.roundToDecimals": "zaokrąglij do miejsc dziesiętnych",
    "roundToDecimals": "zaokrąglij do miejsc dziesiętnych",
    "bitbybit.math.roundToDecimals_description": "Zaokrągla liczbę do określonej liczby miejsc dziesiętnych. Przykład: 1.32156 z 3 miejscami dziesiętnymi zwraca 1.322",
    "decimalPlaces": "miejsca dziesiętne",
    "bitbybit.math.oneNrOperation": "operacja na jednej liczbie",
    "oneNrOperation": "operacja na jednej liczbie",
    "bitbybit.math.oneNrOperation_description": "Wykonuje operacje matematyczne na pojedynczej liczbie (wartość bezwzględna, negacja, pierwiastek kwadratowy, funkcje trygonometryczne, logarytmy itp.). Przykład: sqrt(5) → 2.236, abs(-3) → 3, sin(π2) → 1",
    "mathOneNrOperatorEnum": "enum operatorów matematycznych jednej liczby",
    "bitbybit.math.remap": "przekształć zakres",
    "remap": "przekształć zakres",
    "bitbybit.math.remap_description": "Mapuje liczbę z jednego zakresu na inny zakres proporcjonalnie. Przykład: 5 z [0,10] na [0,100] → 50, 0.5 z [0,1] na [-10,10] → 0",
    "fromLow": "z dolnego",
    "fromHigh": "z górnego",
    "toLow": "na dolny",
    "toHigh": "na górny",
    "bitbybit.math.random": "losowa",
    "random": "losowa",
    "bitbybit.math.random_description": "Generuje losową liczbę dziesiętną pomiędzy 0 (włącznie) a 1 (wyłącznie). Przykład: Wyniki takie jak 0.342, 0.891 lub dowolna wartość w [0, 1)",
    "generate": "generuj",
    "bitbybit.math.randomNumber": "liczba losowa",
    "randomNumber": "liczba losowa",
    "bitbybit.math.randomNumber_description": "Generuje losową liczbę w określonym zakresie (od dolnego do górnego). Przykład: Zakres [0, 10] → wyniki takie jak 3.7, 8.2 lub dowolna wartość pomiędzy 0 a 10",
    "low": "dolny",
    "high": "górny",
    "bitbybit.math.randomNumbers": "liczby losowe",
    "randomNumbers": "liczby losowe",
    "bitbybit.math.randomNumbers_description": "Generuje wiele losowych liczb w określonym zakresie. Przykład: Zakres [0, 10] z 3 elementami → [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "Zwraca stałą matematyczną π (pi) ≈ 3.14159. Przykład: Zwraca 3.141592653589793",
    "bitbybit.math.toFixed": "do stałej liczby miejsc",
    "toFixed": "do stałej liczby miejsc",
    "bitbybit.math.toFixed_description": "Formatuje liczbę jako ciąg znaków ze stałą liczbą miejsc dziesiętnych (zawsze pokazuje końcowe zera). Przykład: 3.14159 z 2 miejscami → '3.14', 5 z 3 miejscami → '5.000'",
    "bitbybit.math.add": "dodaj",
    "bitbybit.math.add_description": "Dodaje do siebie dwie liczby. Przykład: 5 + 3 → 8, -2 + 7 → 5",
    "basics": "podstawy",
    "bitbybit.math.subtract": "odejmij",
    "bitbybit.math.subtract_description": "Odejmuje drugą liczbę od pierwszej. Przykład: 10 - 3 → 7, 5 - 8 → -3",
    "bitbybit.math.multiply": "mnóż",
    "bitbybit.math.multiply_description": "Mnoży dwie liczby. Przykład: 5 × 3 → 15, -2 × 4 → -8",
    "bitbybit.math.divide": "dziel",
    "divide": "dziel",
    "bitbybit.math.divide_description": "Dzieli pierwszą liczbę przez drugą. Przykład: 10 ÷ 2 → 5, 7 ÷ 2 → 3.5",
    "bitbybit.math.power": "potęga",
    "power": "potęga",
    "bitbybit.math.power_description": "Podnosi pierwszą liczbę do potęgi drugiej (potęgowanie). Przykład: 2³ → 8, 5² → 25, 10⁻¹ → 0.1",
    "bitbybit.math.sqrt": "pierwiastek",
    "sqrt": "pierwiastek",
    "bitbybit.math.sqrt_description": "Oblicza pierwiastek kwadratowy liczby. Przykład: √9 → 3, √2 → 1.414, √16 → 4",
    "bitbybit.math.abs": "wartość bezwzględna",
    "abs": "wartość bezwzględna",
    "bitbybit.math.abs_description": "Zwraca wartość bezwzględną (usuwa znak minus, zawsze dodatnia lub zero). Przykład: |-5| → 5, |3| → 3, |0| → 0",
    "bitbybit.math.round": "zaokrąglij",
    "round": "zaokrąglij",
    "bitbybit.math.round_description": "Zaokrągla liczbę do najbliższej liczby całkowitej. Przykład: 3.7 → 4, 2.3 → 2, 5.5 → 6",
    "bitbybit.math.floor": "podłoga",
    "floor": "podłoga",
    "bitbybit.math.floor_description": "Zaokrągla liczbę w dół do najbliższej liczby całkowitej (w stronę minus nieskończoności). Przykład: 3.7 → 3, -2.3 → -3, 5 → 5",
    "bitbybit.math.ceil": "sufit",
    "ceil": "sufit",
    "bitbybit.math.ceil_description": "Zaokrągla liczbę w górę do najbliższej liczby całkowitej (w stronę plus nieskończoności). Przykład: 3.2 → 4, -2.8 → -2, 5 → 5",
    "bitbybit.math.negate": "neguj",
    "negate": "neguj",
    "bitbybit.math.negate_description": "Neguje liczbę (odwraca jej znak: dodatnia staje się ujemna, ujemna staje się dodatnia). Przykład: 5 → -5, -3 → 3, 0 → 0",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "Oblicza logarytm naturalny (podstawa e) liczby. Przykład: ln(2.718) → ~1, ln(7.389) → ~2, ln(1) → 0",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "Oblicza logarytm dziesiętny liczby. Przykład: log₁₀(100) → 2, log₁₀(1000) → 3, log₁₀(10) → 1",
    "bitbybit.math.tenPow": "dziesięć do potęgi",
    "tenPow": "dziesięć do potęgi",
    "bitbybit.math.tenPow_description": "Podnosi 10 do potęgi liczby wejściowej. Przykład: 10² → 100, 10³ → 1000, 10⁻¹ → 0.1",
    "bitbybit.math.sin": "sin",
    "sin": "sin",
    "bitbybit.math.sin_description": "Oblicza sinus kąta w radianach. Przykład: sin(0) → 0, sin(π2) → 1, sin(π) → ~0",
    "bitbybit.math.cos": "cos",
    "cos": "cos",
    "bitbybit.math.cos_description": "Oblicza cosinus kąta w radianach. Przykład: cos(0) → 1, cos(π2) → ~0, cos(π) → -1",
    "bitbybit.math.tan": "tan",
    "tan": "tan",
    "bitbybit.math.tan_description": "Oblicza tangens kąta w radianach. Przykład: tan(0) → 0, tan(π4) → ~1, tan(π2) → nieskończoność",
    "bitbybit.math.asin": "asin",
    "asin": "asin",
    "bitbybit.math.asin_description": "Oblicza arcus sinus (odwrotny sinus) w radianach, zwraca kąt, którego sinus jest wartością wejściową. Przykład: asin(0) → 0, asin(1) → π2 (~1.57), asin(0.5) → π6 (~0.524)",
    "bitbybit.math.acos": "acos",
    "acos": "acos",
    "bitbybit.math.acos_description": "Oblicza arcus cosinus (odwrotny cosinus) w radianach, zwraca kąt, którego cosinus jest wartością wejściową. Przykład: acos(1) → 0, acos(0) → π2 (~1.57), acos(-1) → π (~3.14)",
    "bitbybit.math.atan": "atan",
    "atan": "atan",
    "bitbybit.math.atan_description": "Oblicza arcus tangens (odwrotny tangens) w radianach, zwraca kąt, którego tangens jest wartością wejściową. Przykład: atan(0) → 0, atan(1) → π4 (~0.785), atan(-1) → -π4",
    "bitbybit.math.exp": "exp",
    "exp": "exp",
    "bitbybit.math.exp_description": "Oblicza e podniesione do potęgi wejściowej (funkcja wykładnicza). Przykład: e⁰ → 1, e¹ → ~2.718, e² → ~7.389",
    "bitbybit.math.degToRad": "stopnie na radiany",
    "degToRad": "stopnie na radiany",
    "bitbybit.math.degToRad_description": "Konwertuje kąt ze stopni na radiany. Przykład: 180° → π (~3.14159), 90° → π2 (~1.5708), 360° → 2π",
    "bitbybit.math.radToDeg": "radiany na stopnie",
    "radToDeg": "radiany na stopnie",
    "bitbybit.math.radToDeg_description": "Konwertuje kąt z radianów na stopnie. Przykład: π → 180°, π2 → 90°, 2π → 360°",
    "bitbybit.math.ease": "funkcja łagodząca",
    "bitbybit.math.ease_description": "Stosuje funkcję łagodzącą (easing) do płynnej interpolacji między wartościami min i max. Przykład: x=0.5 z [0,100] z easeInQuad → stosuje kwadratową krzywą przyspieszenia. Przydatne do płynnych animacji z różnymi krzywymi przyspieszeniaopóźnienia.",
    "easeEnum": "enum funkcji łagodzącej",
    "bitbybit.lists.getItem": "pobierz element",
    "lists": "listy",
    "getItem": "pobierz element",
    "bitbybit.lists.getItem_description": "Pobiera element z listy na określonej pozycji używając indeksowania od zera. Przykład: Z [10, 20, 30, 40], pobranie indeksu 2 zwraca 30",
    "list": "lista",
    "bitbybit.lists.randomGetThreshold": "losowe pobranie z progiem",
    "randomGetThreshold": "losowe pobranie z progiem",
    "bitbybit.lists.randomGetThreshold_description": "Losowo zachowuje elementy z listy na podstawie progu prawdopodobieństwa (0 do 1). Przykład: Z [1, 2, 3, 4, 5] z progiem 0.5, może zwrócić [1, 3, 5] (50% szansy dla każdego elementu)",
    "bitbybit.lists.getSubList": "pobierz podlistę",
    "getSubList": "pobierz podlistę",
    "bitbybit.lists.getSubList_description": "Wyodrębnia część listy między pozycjami początkową i końcową (koniec jest wyłączny). Przykład: Z [10, 20, 30, 40, 50] z początkiem=1 i końcem=4, zwraca [20, 30, 40]",
    "indexStart": "indeks początkowy",
    "indexEnd": "indeks końcowy",
    "bitbybit.lists.getNthItem": "pobierz n-ty element",
    "getNthItem": "pobierz n-ty element",
    "bitbybit.lists.getNthItem_description": "Pobiera co n-ty element z listy, zaczynając od opcjonalnej pozycji przesunięcia. Przykład: Z [0, 1, 2, 3, 4, 5, 6, 7, 8] z n=3 i przesunięciem=0, zwraca [0, 3, 6] Przykład: Z [0, 1, 2, 3, 4, 5, 6, 7, 8] z n=2 i przesunięciem=1, zwraca [1, 3, 5, 7]",
    "nth": "n-ty",
    "bitbybit.lists.getByPattern": "pobierz według wzorca",
    "getByPattern": "pobierz według wzorca",
    "bitbybit.lists.getByPattern_description": "Filtruje elementy z listy używając powtarzającego się wzorca prawdafałsz. Przykład: Z [0, 1, 2, 3, 4, 5] z wzorcem [true, true, false], zwraca [0, 1, 3, 4] (zachowuje elementy, gdzie wzorzec jest true)",
    "pattern": "wzorzec",
    "bitbybit.lists.mergeElementsOfLists": "scal elementy list",
    "mergeElementsOfLists": "scal elementy list",
    "bitbybit.lists.mergeElementsOfLists_description": "Scala elementy z wielu list na określonym poziomie zagnieżdżenia, grupując elementy według pozycji. Przykład: Z [[0, 1, 2], [3, 4, 5]] na poziomie 0, zwraca [[0, 3], [1, 4], [2, 5]]",
    "level": "poziom",
    "bitbybit.lists.getLongestListLength": "pobierz długość najdłuższej listy",
    "getLongestListLength": "pobierz długość najdłuższej listy",
    "bitbybit.lists.getLongestListLength_description": "Znajduje długość najdłuższej listy spośród wielu list. Przykład: Z [[1, 2], [3, 4, 5, 6], [7]], zwraca 4 (długość [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "odwróć",
    "bitbybit.lists.reverse_description": "Odwraca kolejność elementów w liście. Przykład: Z [1, 2, 3, 4, 5], zwraca [5, 4, 3, 2, 1]",
    "bitbybit.lists.flipLists": "odwróć listy",
    "flipLists": "odwróć listy",
    "bitbybit.lists.flipLists_description": "Transponuje listę 2D zamieniając wiersze i kolumny (wszystkie podlisty muszą mieć równą długość). Przykład: Z [[0, 1, 2], [3, 4, 5]], zwraca [[0, 3], [1, 4], [2, 5]]",
    "bitbybit.lists.groupNth": "grupuj co n-ty",
    "groupNth": "grupuj co n-ty",
    "bitbybit.lists.groupNth_description": "Dzieli listę na mniejsze listy po n elementów każda. Przykład: Z [0, 1, 2, 3, 4, 5, 6, 7, 8] z n=3, zwraca [[0, 1, 2], [3, 4, 5], [6, 7, 8]] Przykład: Z [0, 1, 2, 3, 4] z n=2 i zachowajResztę=true, zwraca [[0, 1], [2, 3], [4]]",
    "nrElements": "liczba elementów",
    "keepRemainder": "zachowaj resztę",
    "bitbybit.lists.getListDepth": "pobierz głębokość listy",
    "getListDepth": "pobierz głębokość listy",
    "bitbybit.lists.getListDepth_description": "Określa maksymalny poziom zagnieżdżenia (głębokość) struktury listy. Przykład: [1, 2, 3] ma głębokość 1, [[1, 2], [3, 4]] ma głębokość 2, [[[1]]] ma głębokość 3",
    "bitbybit.lists.listLength": "długość listy",
    "listLength": "długość listy",
    "bitbybit.lists.listLength_description": "Zwraca liczbę elementów w liście. Przykład: [10, 20, 30, 40, 50] zwraca 5, [] zwraca 0",
    "bitbybit.lists.addItemAtIndex": "dodaj element na indeksie",
    "addItemAtIndex": "dodaj element na indeksie",
    "bitbybit.lists.addItemAtIndex_description": "Wstawia element na określonej pozycji w liście. Przykład: W [10, 20, 30, 40], dodanie 99 na indeksie 2 daje [10, 20, 99, 30, 40]",
    "item": "element",
    "bitbybit.lists.addItemAtIndexes": "dodaj element na indeksach",
    "addItemAtIndexes": "dodaj element na indeksach",
    "bitbybit.lists.addItemAtIndexes_description": "Wstawia ten sam element na wielu określonych pozycjach w liście. Przykład: W [10, 20, 30], dodanie 99 na indeksach [0, 2] daje [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "dodaj elementy na indeksach",
    "addItemsAtIndexes": "dodaj elementy na indeksach",
    "bitbybit.lists.addItemsAtIndexes_description": "Wstawia wiele elementów na odpowiednich pozycjach (pierwszy element na pierwszym indeksie, drugi element na drugim indeksie itd.). Przykład: W [10, 20, 30], dodanie elementów [88, 99] na indeksach [1, 2] daje [10, 88, 20, 99, 30]",
    "items": "elementy",
    "bitbybit.lists.removeItemAtIndex": "usuń element na indeksie",
    "removeItemAtIndex": "usuń element na indeksie",
    "bitbybit.lists.removeItemAtIndex_description": "Usuwa element na określonej pozycji w liście. Przykład: Z [10, 20, 30, 40, 50], usunięcie indeksu 2 daje [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "usuń elementy na indeksach",
    "removeItemsAtIndexes": "usuń elementy na indeksach",
    "bitbybit.lists.removeItemsAtIndexes_description": "Usuwa elementy na wielu określonych pozycjach z listy. Przykład: Z [10, 20, 30, 40, 50], usunięcie indeksów [1, 3] daje [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "usuń wszystkie elementy",
    "removeAllItems": "usuń wszystkie elementy",
    "bitbybit.lists.removeAllItems_description": "Czyści wszystkie elementy z listy, co skutkuje pustą listą. Przykład: Z [10, 20, 30, 40], zwraca []",
    "bitbybit.lists.removeNthItem": "usuń n-ty element",
    "removeNthItem": "usuń n-ty element",
    "bitbybit.lists.removeNthItem_description": "Usuwa co n-ty element z listy, zaczynając od opcjonalnej pozycji przesunięcia. Przykład: Z [0, 1, 2, 3, 4, 5, 6, 7, 8] z n=3 i przesunięciem=0, zwraca [1, 2, 4, 5, 7, 8] (usuwa 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "losowe usuwanie z progiem",
    "randomRemoveThreshold": "losowe usuwanie z progiem",
    "bitbybit.lists.randomRemoveThreshold_description": "Losowo usuwa elementy z listy na podstawie progu prawdopodobieństwa (0 do 1). Przykład: Z [1, 2, 3, 4, 5] z progiem 0.5, może zwrócić [2, 4] (50% szansy na usunięcie każdego elementu)",
    "bitbybit.lists.removeDuplicateNumbers": "usuń zduplikowane liczby",
    "removeDuplicateNumbers": "usuń zduplikowane liczby",
    "bitbybit.lists.removeDuplicateNumbers_description": "Usuwa zduplikowane liczby z listy, zachowując tylko pierwsze wystąpienie każdej wartości. Przykład: Z [1, 2, 3, 2, 4, 3, 5], zwraca [1, 2, 3, 4, 5]",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "usuń zduplikowane liczby z tolerancją",
    "removeDuplicateNumbersTolerance": "usuń zduplikowane liczby z tolerancją",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Usuwa zduplikowane liczby, które znajdują się w określonym zakresie tolerancji względem siebie. Przykład: Z [1.0, 1.001, 2.0, 2.002, 3.0] z tolerancją 0.01, zwraca [1.0, 2.0, 3.0]",
    "bitbybit.lists.addItem": "dodaj element",
    "addItem": "dodaj element",
    "bitbybit.lists.addItem_description": "Dołącza element na końcu listy. Przykład: Do [10, 20, 30], dodanie 40 daje [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "dołącz element na początku",
    "prependItem": "dołącz element na początku",
    "bitbybit.lists.prependItem_description": "Dodaje element na początku listy. Przykład: Do [10, 20, 30], dołączenie 5 na początku daje [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "dodaj element na początku lub końcu",
    "addItemFirstLast": "dodaj element na początku lub końcu",
    "bitbybit.lists.addItemFirstLast_description": "Dodaje element na początku lub na końcu listy w zależności od parametru pozycji. Przykład: Do [10, 20, 30], dodanie 5 jako 'pierwszy' daje [5, 10, 20, 30], jako 'ostatni' daje [10, 20, 30, 5]",
    "firstLastEnum": "początek koniec enum",
    "bitbybit.lists.createEmptyList": "pusta lista",
    "createEmptyList": "pusta lista",
    "bitbybit.lists.createEmptyList_description": "Tworzy nową pustą listę bez elementów. Przykład: Zwraca []",
    "bitbybit.lists.repeat": "powtórz",
    "repeat": "powtórz",
    "bitbybit.lists.repeat_description": "Tworzy nową listę powtarzając element określoną liczbę razy. Przykład: Powtórzenie 5 trzy razy zwraca [5, 5, 5]",
    "times": "razy",
    "bitbybit.lists.repeatInPattern": "powtórz we wzorze",
    "repeatInPattern": "powtórz we wzorze",
    "bitbybit.lists.repeatInPattern_description": "Powtarza wzór elementów cyklicznie aż do osiągnięcia docelowej długości listy. Przykład: Wzór [1, 2, 3] o długości 7 zwraca [1, 2, 3, 1, 2, 3, 1]",
    "lengthLimit": "limit długości",
    "bitbybit.lists.sortNumber": "sortuj liczby",
    "sortNumber": "sortuj liczby",
    "bitbybit.lists.sortNumber_description": "Sortuje liczby rosnąco (od najniższej do najwyższej) lub malejąco (od najwyższej do najniższej). Przykład: [5, 2, 8, 1, 9] rosnąco zwraca [1, 2, 5, 8, 9], malejąco zwraca [9, 8, 5, 2, 1]",
    "sorting": "sortowanie",
    "orderAsc": "kolejność rosnąca",
    "bitbybit.lists.sortTexts": "sortuj teksty",
    "sortTexts": "sortuj teksty",
    "bitbybit.lists.sortTexts_description": "Sortuje ciągi tekstowe alfabetycznie rosnąco (A do Z) lub malejąco (Z do A). Przykład: ['pies', 'jabłko', 'kot', 'banan'] rosnąco zwraca ['banan', 'jabłko', 'kot', 'pies']",
    "bitbybit.lists.sortByPropValue": "sortuj według wartości właściwości",
    "sortByPropValue": "sortuj według wartości właściwości",
    "bitbybit.lists.sortByPropValue_description": "Sortuje obiekty porównując wartości liczbowe określonej właściwości. Przykład: [{wiek: 30}, {wiek: 20}, {wiek: 25}] posortowane według 'wiek' rosnąco zwraca [{wiek: 20}, {wiek: 25}, {wiek: 30}]",
    "property": "właściwość",
    "bitbybit.color.hexColor": "kolor hex",
    "hexColor": "kolor hex",
    "bitbybit.color.hexColor_description": "Tworzy i zwraca ciąg koloru hex (przekazuje wartość wejściową). Przykład: '#FF5733' → '#FF5733'",
    "bitbybit.color.hexToRgb": "hex na rgb",
    "hexToRgb": "hex na rgb",
    "bitbybit.color.hexToRgb_description": "Konwertuje kolor hex na obiekt RGB z wartościami r, g, b (zakres 0-255). Przykład: '#FF5733' → {r: 255, g: 87, b: 51}",
    "convert": "konwertuj",
    "bitbybit.color.rgbToHex": "rgb na hex",
    "rgbToHex": "rgb na hex",
    "bitbybit.color.rgbToHex_description": "Konwertuje wartości RGB na ciąg koloru hex (obsługuje niestandardowe zakresy minmax, automatycznie przemapowuje na 0-255). Przykład: r=255, g=87, b=51 z zakresem [0,255] → '#ff5733' Przykład: r=1, g=0.5, b=0.2 z zakresem [0,1] → '#ff7f33'",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "obiekt rgb na hex",
    "rgbObjToHex": "obiekt rgb na hex",
    "bitbybit.color.rgbObjToHex_description": "Konwertuje obiekt RGB na ciąg koloru hex (obsługuje niestandardowe zakresy minmax). Przykład: {r: 1, g: 0.5, b: 0.2} z zakresem [0,1] → '#ff7f33'",
    "rgb": "rgb",
    "Base.ColorRGB": "bazowy kolor rgb",
    "bitbybit.color.hexToRgbMapped": "hex na zmapowane rgb",
    "hexToRgbMapped": "hex na zmapowane rgb",
    "bitbybit.color.hexToRgbMapped_description": "Konwertuje kolor hex na RGB i przemapowuje wartości na niestandardowy zakres. Przykład: '#FF5733' zmapowane na [0,1] → {r: 1, g: 0.341, b: 0.2} Przykład: '#FF5733' zmapowane na [0,100] → {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "pobierz parametr czerwony",
    "getRedParam": "pobierz parametr czerwony",
    "bitbybit.color.getRedParam_description": "Wyodrębnia wartość kanału czerwonego z koloru hex (może być zmapowana na niestandardowy zakres). Przykład: '#FF5733' z zakresem [0,1] → 1",
    "hex to": "hex na",
    "bitbybit.color.getGreenParam": "pobierz parametr zielony",
    "getGreenParam": "pobierz parametr zielony",
    "bitbybit.color.getGreenParam_description": "Wyodrębnia wartość kanału zielonego z koloru hex (może być zmapowana na niestandardowy zakres). Przykład: '#FF5733' z zakresem [0,1] → 0.341",
    "bitbybit.color.getBlueParam": "pobierz parametr niebieski",
    "getBlueParam": "pobierz parametr niebieski",
    "bitbybit.color.getBlueParam_description": "Wyodrębnia wartość kanału niebieskiego z koloru hex (może być zmapowana na niestandardowy zakres). Przykład: '#FF5733' z zakresem [0,1] → 0.2",
    "bitbybit.color.rgbToRed": "rgb na czerwony",
    "rgbToRed": "rgb na czerwony",
    "bitbybit.color.rgbToRed_description": "Wyodrębnia wartość kanału czerwonego z obiektu RGB. Przykład: {r: 255, g: 87, b: 51} → 255",
    "rgb to": "rgb na",
    "bitbybit.color.rgbToGreen": "rgb na zielony",
    "rgbToGreen": "rgb na zielony",
    "bitbybit.color.rgbToGreen_description": "Wyodrębnia wartość kanału zielonego z obiektu RGB. Przykład: {r: 255, g: 87, b: 51} → 87",
    "bitbybit.color.rgbToBlue": "rgb na niebieski",
    "rgbToBlue": "rgb na niebieski",
    "bitbybit.color.rgbToBlue_description": "Wyodrębnia wartość kanału niebieskiego z obiektu RGB. Przykład: {r: 255, g: 87, b: 51} → 51",
    "bitbybit.color.invert": "odwróć",
    "invert": "odwróć",
    "bitbybit.color.invert_description": "Odwraca kolor hex (odwraca kanały RGB: 255-r, 255-g, 255-b). Z blackAndWhite=true → zwraca '#000000' lub '#ffffff' w zależności od jasności. Przykład: '#FF5733' → '#00a8cc', '#FF5733' z blackAndWhite=true → '#ffffff'",
    "blackAndWhite": "czarno biały",
    "bitbybit.text.create": "utwórz",
    "bitbybit.text.create_description": "Tworzy i zwraca ciąg tekstowy (przekazuje wartość wejściową). Przykład: tekst='Witaj Świecie' → 'Witaj Świecie'",
    "bitbybit.text.split": "podziel",
    "bitbybit.text.split_description": "Dzieli tekst na wiele części używając ciągu separatora. Przykład: tekst='jabłko,banan,wiśnia', separator=',' → ['jabłko', 'banan', 'wiśnia']",
    "separator": "separator",
    "bitbybit.text.replaceAll": "zamień wszystko",
    "replaceAll": "zamień wszystko",
    "bitbybit.text.replaceAll_description": "Zamienia wszystkie wystąpienia szukanego ciągu na ciąg zastępczy. Przykład: tekst='cześć cześć', szukaj='cześć', zamieńNa='hej' → 'hej hej'",
    "search": "szukaj",
    "replaceWith": "zamień na",
    "bitbybit.text.join": "połącz",
    "join": "połącz",
    "bitbybit.text.join_description": "Łączy wiele elementów w jeden ciąg tekstowy używając separatora. Przykład: lista=['jabłko', 'banan', 'wiśnia'], separator=', ' → 'jabłko, banan, wiśnia'",
    "string[]": "tablica ciągów znaków",
    "bitbybit.text.toString": "na ciąg znaków",
    "toString": "na ciąg znaków",
    "bitbybit.text.toString_description": "Przekształć dowolny element na tekst",
    "bitbybit.text.toStringEach": "każdy na ciąg znaków",
    "toStringEach": "każdy na ciąg znaków",
    "bitbybit.text.toStringEach_description": "Przekształć każdy element w liście na tekst",
    "bitbybit.text.format": "formatuj",
    "format": "formatuj",
    "bitbybit.text.format_description": "Formatuje tekst z wartościami zastępczymi używając składni {0}, {1} itd. Przykład: tekst='Punkt: ({0}, {1})', wartości=[10, 5] → 'Punkt: (10, 5)'",
    "values": "wartości",
    "bitbybit.text.vectorChar": "znak wektorowy",
    "vectorChar": "znak wektorowy",
    "bitbybit.text.vectorChar_description": "Konwertuje znak na ścieżki wektorowe (polilinie) z danymi szerokości i wysokości do renderowania. Używa czcionki simplex stroke do generowania segmentów linii 2D reprezentujących kształt znaku. Przykład: znak='A', wysokość=10 → {szerokość:8, wysokość:10, ścieżki:[[punkty tworzące kształt A]]}",
    "char": "znak",
    "bitbybit.text.vectorText": "tekst wektorowy",
    "vectorText": "tekst wektorowy",
    "bitbybit.text.vectorText_description": "Konwertuje tekst wielowierszowy na ścieżki wektorowe (polilinie) z kontrolą wyrównania i odstępów. Obsługuje łamanie linii, odstępy między literami, odstępy między wierszami, wyrównanie poziome i centrowanie początku. Przykład: text='Hello\nWorld', height=10, align=center → [{line1 chars}, {line2 chars}]",
    "bitbybit.dates.toDateString": "na ciąg daty",
    "dates": "daty",
    "toDateString": "na ciąg daty",
    "bitbybit.dates.toDateString_description": "Konwertuje datę na czytelny dla człowieka ciąg daty (bez czasu). Przykład: Date(2024,0,15,14,30) → 'Mon Jan 15 2024'",
    "date": "data",
    "Date": "data",
    "bitbybit.dates.toISOString": "na ciąg iso",
    "toISOString": "na ciąg iso",
    "bitbybit.dates.toISOString_description": "Konwertuje datę na ciąg formatu ISO 8601 (standardowy format dla API i wymiany danych). Przykład: Date(2024,0,15,14,30,45) → '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "na json",
    "toJSON": "na json",
    "bitbybit.dates.toJSON_description": "Konwertuje datę na ciąg zgodny z JSON (taki sam jak format ISO, używany w JSON.stringify). Przykład: Date(2024,0,15,14,30) → '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "na ciąg znaków",
    "bitbybit.dates.toString_description": "Konwertuje datę na pełny ciąg specyficzny dla lokalizacji (zawiera datę, godzinę i strefę czasową). Przykład: Date(2024,0,15,14,30) → 'Mon Jan 15 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "na ciąg czasu",
    "toTimeString": "na ciąg czasu",
    "bitbybit.dates.toTimeString_description": "Konwertuje datę na ciąg czasu (bez daty, zawiera strefę czasową). Przykład: Date(2024,0,15,14,30,45) → '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "na ciąg utc",
    "toUTCString": "na ciąg utc",
    "bitbybit.dates.toUTCString_description": "Konwertuje datę na format ciągu UTC (Uniwersalny Czas Koordynowany, bez przesunięcia strefy czasowej). Przykład: Date(2024,0,15,14,30) → 'Mon, 15 Jan 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "teraz",
    "now": "teraz",
    "bitbybit.dates.now_description": "Zwraca bieżącą datę i godzinę w momencie wykonania. Przykład: wywołanie now() → obiekt Date reprezentujący bieżącą chwilę (np. '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "utwórz datę",
    "createDate": "utwórz datę",
    "bitbybit.dates.createDate_description": "Tworzy nową datę z poszczególnych komponentów przy użyciu czasu lokalnego. Miesiąc jest indeksowany od 0: 0=Styczeń, 11=Grudzień. Przykład: rok=2024, miesiąc=0, dzień=15, godziny=14, minuty=30 → Date(Sty 15, 2024 14:30)",
    "year": "rok",
    "month": "miesiąc",
    "day": "dzień",
    "hours": "godziny",
    "minutes": "minuty",
    "seconds": "sekundy",
    "milliseconds": "milisekundy",
    "bitbybit.dates.createDateUTC": "utwórz datę utc",
    "createDateUTC": "utwórz datę utc",
    "bitbybit.dates.createDateUTC_description": "Tworzy nową datę z poszczególnych komponentów przy użyciu UTC (ignoruje strefę czasową). Zwraca milisekundy od epoki uniksowej (1 stycznia 1970 00:00:00 UTC). Przykład: rok=2024, miesiąc=0, dzień=15 → Data reprezentująca 15 Sty 2024 00:00 UTC",
    "bitbybit.dates.createFromUnixTimeStamp": "utwórz ze znacznika czasu unix",
    "createFromUnixTimeStamp": "utwórz ze znacznika czasu unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Tworzy datę ze znacznika czasu Unix (milisekundy od 1 stycznia 1970 UTC). Przykład: znacznikCzasuUnix=1705329000000 → Date(15 Sty 2024 14:30:00)",
    "unixTimeStamp": "znacznik czasu unix",
    "bitbybit.dates.parseDate": "parsuj datę",
    "parseDate": "parsuj datę",
    "bitbybit.dates.parseDate_description": "Parsuje ciąg daty i zwraca znacznik czasu Unix (milisekundy od 1 stycznia 1970 UTC). Przykład: ciagDaty='2024-01-15' → 1705276800000",
    "parse": "parsuj",
    "dateString": "ciąg daty",
    "bitbybit.dates.getDayOfMonth": "pobierz dzień miesiąca",
    "getDayOfMonth": "pobierz dzień miesiąca",
    "bitbybit.dates.getDayOfMonth_description": "Wyodrębnia dzień miesiąca z daty (1-31) używając czasu lokalnego. Przykład: Date(2024,0,15) → 15",
    "bitbybit.dates.getWeekday": "pobierz dzień tygodnia",
    "getWeekday": "pobierz dzień tygodnia",
    "bitbybit.dates.getWeekday_description": "Wyodrębnia dzień tygodnia z daty (0=Niedziela, 6=Sobota) używając czasu lokalnego. Przykład: Date(2024,0,15) → 1 (Poniedziałek)",
    "bitbybit.dates.getYear": "pobierz rok",
    "getYear": "pobierz rok",
    "bitbybit.dates.getYear_description": "Wyodrębnia pełny rok z daty używając czasu lokalnego. Przykład: Date(2024,0,15) → 2024",
    "bitbybit.dates.getMonth": "pobierz miesiąc",
    "getMonth": "pobierz miesiąc",
    "bitbybit.dates.getMonth_description": "Wyodrębnia miesiąc z daty (0=Styczeń, 11=Grudzień) używając czasu lokalnego. Przykład: Date(2024,0,15) → 0 (Styczeń)",
    "bitbybit.dates.getHours": "pobierz godziny",
    "getHours": "pobierz godziny",
    "bitbybit.dates.getHours_description": "Wyodrębnia godziny z daty (0-23) używając czasu lokalnego. Przykład: Date(2024,0,15,14,30) → 14",
    "bitbybit.dates.getMinutes": "pobierz minuty",
    "getMinutes": "pobierz minuty",
    "bitbybit.dates.getMinutes_description": "Wyodrębnia minuty z daty (0-59) używając czasu lokalnego. Przykład: Date(2024,0,15,14,30) → 30",
    "bitbybit.dates.getSeconds": "pobierz sekundy",
    "getSeconds": "pobierz sekundy",
    "bitbybit.dates.getSeconds_description": "Wyodrębnia sekundy z daty (0-59) używając czasu lokalnego. Przykład: Date(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getMilliseconds": "pobierz milisekundy",
    "getMilliseconds": "pobierz milisekundy",
    "bitbybit.dates.getMilliseconds_description": "Wyodrębnia milisekundy z daty (0-999) używając czasu lokalnego. Przykład: Date(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.getTime": "pobierz czas",
    "getTime": "pobierz czas",
    "bitbybit.dates.getTime_description": "Konwertuje datę na znacznik czasu Unix (milisekundy od 1 stycznia 1970 UTC). Przykład: Date(2024,0,15,14,30) → 1705329000000",
    "bitbybit.dates.getUTCYear": "pobierz rok utc",
    "getUTCYear": "pobierz rok utc",
    "bitbybit.dates.getUTCYear_description": "Wyodrębnia pełny rok z daty używając UTC (ignoruje strefę czasową). Przykład: Date(2024,0,15) → 2024",
    "bitbybit.dates.getUTCMonth": "pobierz miesiąc utc",
    "getUTCMonth": "pobierz miesiąc utc",
    "bitbybit.dates.getUTCMonth_description": "Wyodrębnia miesiąc z daty (0=Styczeń, 11=Grudzień) używając UTC. Przykład: Date.UTC(2024,0,15) → 0 (Styczeń)",
    "bitbybit.dates.getUTCDay": "pobierz dzień utc",
    "getUTCDay": "pobierz dzień utc",
    "bitbybit.dates.getUTCDay_description": "Wyodrębnia dzień miesiąca z daty (1-31) używając UTC. Przykład: Date.UTC(2024,0,15) → 15",
    "bitbybit.dates.getUTCHours": "pobierz godziny utc",
    "getUTCHours": "pobierz godziny utc",
    "bitbybit.dates.getUTCHours_description": "Wyodrębnia godziny z daty (0-23) używając UTC. Przykład: Date.UTC(2024,0,15,14) → 14",
    "bitbybit.dates.getUTCMinutes": "pobierz minuty utc",
    "getUTCMinutes": "pobierz minuty utc",
    "bitbybit.dates.getUTCMinutes_description": "Wyodrębnia minuty z daty (0-59) używając UTC. Przykład: Date.UTC(2024,0,15,14,30) → 30",
    "bitbybit.dates.getUTCSeconds": "pobierz sekundy utc",
    "getUTCSeconds": "pobierz sekundy utc",
    "bitbybit.dates.getUTCSeconds_description": "Wyodrębnia sekundy z daty (0-59) używając UTC. Przykład: Date.UTC(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getUTCMilliseconds": "pobierz milisekundy utc",
    "getUTCMilliseconds": "pobierz milisekundy utc",
    "bitbybit.dates.getUTCMilliseconds_description": "Wyodrębnia milisekundy z daty (0-999) używając UTC. Przykład: Date.UTC(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.setYear": "ustaw rok",
    "setYear": "ustaw rok",
    "bitbybit.dates.setYear_description": "Tworzy nową datę ze zmodyfikowanym rokiem (zwraca nową datę, oryginał bez zmian). Przykład: Date(2024,0,15) z rokiem=2025 → Date(2025,0,15)",
    "bitbybit.dates.setMonth": "ustaw miesiąc",
    "setMonth": "ustaw miesiąc",
    "bitbybit.dates.setMonth_description": "Tworzy nową datę ze zmodyfikowanym miesiącem (0=Styczeń, 11=Grudzień, zwraca nową datę). Przykład: Date(2024,0,15) z miesiącem=5 → Date(2024,5,15) (15 Czerwca)",
    "bitbybit.dates.setDayOfMonth": "ustaw dzień miesiąca",
    "setDayOfMonth": "ustaw dzień miesiąca",
    "bitbybit.dates.setDayOfMonth_description": "Tworzy nową datę ze zmodyfikowanym dniem miesiąca (1-31, zwraca nową datę). Przykład: Date(2024,0,15) z dniem=20 → Date(2024,0,20)",
    "bitbybit.dates.setHours": "ustaw godziny",
    "setHours": "ustaw godziny",
    "bitbybit.dates.setHours_description": "Ustawia wartość godzin w obiekcie Date używając czasu lokalnego.",
    "bitbybit.dates.setMinutes": "ustaw minuty",
    "setMinutes": "ustaw minuty",
    "bitbybit.dates.setMinutes_description": "Ustawia wartość minut w obiekcie Date używając czasu lokalnego.",
    "bitbybit.dates.setSeconds": "ustaw sekundy",
    "setSeconds": "ustaw sekundy",
    "bitbybit.dates.setSeconds_description": "Ustawia wartość sekund w obiekcie Date używając czasu lokalnego.",
    "bitbybit.dates.setMilliseconds": "ustaw milisekundy",
    "setMilliseconds": "ustaw milisekundy",
    "bitbybit.dates.setMilliseconds_description": "Ustawia wartość milisekund w obiekcie Date używając czasu lokalnego.",
    "bitbybit.dates.setTime": "ustaw czas",
    "setTime": "ustaw czas",
    "bitbybit.dates.setTime_description": "Ustawia wartość daty i czasu w obiekcie Date.",
    "time": "czas",
    "bitbybit.dates.setUTCYear": "ustaw rok utc",
    "setUTCYear": "ustaw rok utc",
    "bitbybit.dates.setUTCYear_description": "Ustawia wartość roku w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.dates.setUTCMonth": "ustaw miesiąc utc",
    "setUTCMonth": "ustaw miesiąc utc",
    "bitbybit.dates.setUTCMonth_description": "Ustawia wartość miesiąca w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.dates.setUTCDay": "ustaw dzień utc",
    "setUTCDay": "ustaw dzień utc",
    "bitbybit.dates.setUTCDay_description": "Ustawia numeryczny dzień miesiąca w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.dates.setUTCHours": "ustaw godziny utc",
    "setUTCHours": "ustaw godziny utc",
    "bitbybit.dates.setUTCHours_description": "Ustawia wartość godzin w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.dates.setUTCMinutes": "ustaw minuty utc",
    "setUTCMinutes": "ustaw minuty utc",
    "bitbybit.dates.setUTCMinutes_description": "Ustawia wartość minut w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.dates.setUTCSeconds": "ustaw sekundy utc",
    "setUTCSeconds": "ustaw sekundy utc",
    "bitbybit.dates.setUTCSeconds_description": "Ustawia wartość sekund w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "ustaw milisekundy utc",
    "setUTCMilliseconds": "ustaw milisekundy utc",
    "bitbybit.dates.setUTCMilliseconds_description": "Ustawia wartość milisekund w obiekcie Date używając Uniwersalnego Czasu Koordynowanego (UTC).",
    "bitbybit.json.stringify": "konwertuj na string",
    "json": "json",
    "stringify": "konwertuj na string",
    "bitbybit.json.stringify_description": "Konwertuje wartość wejściową na ciąg znaków (string)",
    "bitbybit.json.parse": "parsuj",
    "bitbybit.json.parse_description": "Parsuje wartość wejściową",
    "bitbybit.json.query": "zapytanie",
    "query": "zapytanie",
    "bitbybit.json.query_description": "Odpytuje wartość wejściową",
    "jsonpath": "ścieżka json",
    "bitbybit.json.setValueOnProp": "ustaw wartość we właściwości",
    "setValueOnProp": "ustaw wartość we właściwości",
    "bitbybit.json.setValueOnProp_description": "Ustawia wartość w danej właściwości danego json",
    "props": "właściwości",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "pobierz json z tablicy przez pierwsze dopasowanie właściwości",
    "getJsonFromArrayByFirstPropMatch": "pobierz json z tablicy przez pierwsze dopasowanie właściwości",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Pobiera json z tablicy przez pierwsze dopasowanie właściwości. Jest to bardzo uproszczone wyszukiwanie i zwraca tylko pierwsze dopasowanie. Jeśli potrzebujesz bardziej złożonego wyszukiwania, możesz użyć zapytania jsonpath z filtrami.",
    "jsonArray": "tablica json",
    "any[]": "tablica dowolnych",
    "match": "dopasuj",
    "bitbybit.json.getValueOnProp": "pobierz wartość z właściwości",
    "getValueOnProp": "pobierz wartość z właściwości",
    "bitbybit.json.getValueOnProp_description": "Pobiera wartość właściwości w danym json",
    "bitbybit.json.setValue": "ustaw wartość",
    "bitbybit.json.setValue_description": "Ustawia wartość w json podając ścieżkę",
    "prop": "właściwość",
    "bitbybit.json.setValuesOnPaths": "ustaw wartości na ścieżkach",
    "setValuesOnPaths": "ustaw wartości na ścieżkach",
    "bitbybit.json.setValuesOnPaths_description": "Ustawia wiele wartości w json podając ścieżki",
    "paths": "ścieżki",
    "bitbybit.json.paths": "ścieżki",
    "bitbybit.json.paths_description": "Znajdź ścieżki do elementów w obiekcie pasujące do wyrażenia ścieżki",
    "bitbybit.json.createEmpty": "pusty",
    "bitbybit.json.createEmpty_description": "Tworzy pusty obiekt JavaScript",
    "bitbybit.json.previewAndSaveJson": "podgląd i zapisz json",
    "previewAndSaveJson": "podgląd i zapisz json",
    "bitbybit.json.previewAndSaveJson_description": "Podgląda json i daje opcję zapisania go",
    "preview": "podgląd",
    "bitbybit.json.previewJson": "podgląd json",
    "previewJson": "podgląd json",
    "bitbybit.json.previewJson_description": "podgląda json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "krzywa przez węzły punkty kontrolne wagi",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "krzywa przez węzły punkty kontrolne wagi",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Tworzy krzywą Nurbs podając węzły, punkty kontrolne i wagi",
    "degree": "stopień",
    "knots": "węzły",
    "bitbybit.verb.curve.createCurveByPoints": "krzywa przez punkty",
    "createCurveByPoints": "krzywa przez punkty",
    "bitbybit.verb.curve.createCurveByPoints_description": "Tworzy krzywą Nurbs podając punkty kontrolne",
    "bitbybit.verb.curve.createBezierCurve": "krzywa beziera",
    "createBezierCurve": "krzywa beziera",
    "bitbybit.verb.curve.createBezierCurve_description": "Tworzy krzywą Beziera Nurbs podając punkty kontrolne i wagi",
    "bitbybit.verb.curve.clone": "klonuj",
    "bitbybit.verb.curve.clone_description": "Klonuj krzywą Nurbs",
    "bitbybit.verb.curve.closestParam": "najbliższy parametr",
    "closestParam": "najbliższy parametr",
    "bitbybit.verb.curve.closestParam_description": "Znajduje najbliższy parametr na krzywej Nurbs od punktu",
    "bitbybit.verb.curve.closestParams": "najbliższe parametry",
    "closestParams": "najbliższe parametry",
    "bitbybit.verb.curve.closestParams_description": "Znajduje najbliższe parametry na krzywej Nurbs od punktów",
    "bitbybit.verb.curve.closestPoint": "najbliższy punkt",
    "closestPoint": "najbliższy punkt",
    "bitbybit.verb.curve.closestPoint_description": "Znajduje najbliższy punkt na krzywej Nurbs od punktu",
    "bitbybit.verb.curve.closestPoints": "najbliższe punkty",
    "closestPoints": "najbliższe punkty",
    "bitbybit.verb.curve.closestPoints_description": "Znajduje najbliższe punkty na krzywej Nurbs od listy punktów",
    "bitbybit.verb.curve.controlPoints": "punkty kontrolne",
    "controlPoints": "punkty kontrolne",
    "bitbybit.verb.curve.controlPoints_description": "Znajduje punkty kontrolne krzywej Nurbs",
    "bitbybit.verb.curve.degree": "stopień",
    "bitbybit.verb.curve.degree_description": "Znajduje stopień krzywej Nurbs",
    "bitbybit.verb.curve.derivatives": "pochodne",
    "derivatives": "pochodne",
    "bitbybit.verb.curve.derivatives_description": "Znajduje pochodne krzywej Nurbs przy parametrze",
    "numDerivatives": "liczba pochodnych",
    "parameter": "parametr",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "podziel równą długością łuku na parametry",
    "divideByEqualArcLengthToParams": "podziel równą długością łuku na parametry",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Dzieli krzywą równą długością łuku na parametry",
    "subdivision": "podział",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "podziel równą długością łuku na punkty",
    "divideByEqualArcLengthToPoints": "podziel równą długością łuku na punkty",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Dzieli krzywą równą długością łuku na punkty",
    "bitbybit.verb.curve.divideByArcLengthToParams": "podziel długością łuku na parametry",
    "divideByArcLengthToParams": "podziel długością łuku na parametry",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Dzieli krzywą długością łuku na parametry",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "podziel długością łuku na punkty",
    "divideByArcLengthToPoints": "podziel długością łuku na punkty",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Dzieli krzywą długością łuku na punkty",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "podziel krzywe równą długością łuku na punkty",
    "divideCurvesByEqualArcLengthToPoints": "podziel krzywe równą długością łuku na punkty",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "dzieli wiele krzywych równą długością łuku na punkty",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "podziel krzywe długością łuku na punkty",
    "divideCurvesByArcLengthToPoints": "podziel krzywe długością łuku na punkty",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "dzieli wiele krzywych długością łuku na punkty",
    "bitbybit.verb.curve.domain": "dziedzina",
    "bitbybit.verb.curve.domain_description": "Znajduje przedział dziedziny parametrów krzywej",
    "bitbybit.verb.curve.startPoint": "punkt początkowy",
    "bitbybit.verb.curve.startPoint_description": "Punkt początkowy krzywej",
    "bitbybit.verb.curve.endPoint": "punkt końcowy",
    "bitbybit.verb.curve.endPoint_description": "Punkt końcowy krzywej",
    "bitbybit.verb.curve.startPoints": "punkty początkowe",
    "bitbybit.verb.curve.startPoints_description": "Punkty początkowe krzywych",
    "bitbybit.verb.curve.endPoints": "punkty końcowe",
    "bitbybit.verb.curve.endPoints_description": "Punkty końcowe krzywych",
    "bitbybit.verb.curve.knots": "węzły",
    "bitbybit.verb.curve.knots_description": "Znajduje węzły krzywej Nurbs",
    "bitbybit.verb.curve.lengthAtParam": "długość przy parametrze",
    "lengthAtParam": "długość przy parametrze",
    "bitbybit.verb.curve.lengthAtParam_description": "Pobiera długość krzywej Nurbs przy określonym parametrze",
    "bitbybit.verb.curve.length": "długość",
    "bitbybit.verb.curve.length_description": "Pobiera długość krzywej Nurbs",
    "bitbybit.verb.curve.paramAtLength": "parametr przy długości",
    "paramAtLength": "parametr przy długości",
    "bitbybit.verb.curve.paramAtLength_description": "Pobiera parametr przy określonej długości na krzywej Nurbs",
    "bitbybit.verb.curve.pointAtParam": "punkt przy parametrze",
    "pointAtParam": "punkt przy parametrze",
    "bitbybit.verb.curve.pointAtParam_description": "Pobiera punkt przy określonym parametrze na krzywej Nurbs",
    "bitbybit.verb.curve.pointsAtParam": "punkty przy parametrze",
    "pointsAtParam": "punkty przy parametrze",
    "bitbybit.verb.curve.pointsAtParam_description": "Pobiera punkty przy określonym parametrze na krzywych Nurbs",
    "bitbybit.verb.curve.reverse": "odwróć",
    "bitbybit.verb.curve.reverse_description": "Odwraca krzywą Nurbs",
    "bitbybit.verb.curve.split": "podziel",
    "bitbybit.verb.curve.split_description": "Dzieli krzywą Nurbs na dwie przy danym parametrze",
    "bitbybit.verb.curve.tangent": "styczna",
    "bitbybit.verb.curve.tangent_description": "Styczna krzywej Nurbs przy danym parametrze",
    "bitbybit.verb.curve.tessellate": "teseluj",
    "tessellate": "teseluj",
    "bitbybit.verb.curve.tessellate_description": "Teseluje krzywą Nurbs na listę punktów",
    "bitbybit.verb.curve.transform": "przekształć",
    "bitbybit.verb.curve.transform_description": "Przekształca krzywą Nurbs",
    "bitbybit.verb.curve.transformCurves": "przekształć krzywe",
    "transformCurves": "przekształć krzywe",
    "bitbybit.verb.curve.transformCurves_description": "Przekształca krzywe Nurbs",
    "bitbybit.verb.curve.weights": "wagi",
    "bitbybit.verb.curve.weights_description": "Wagi krzywej Nurbs",
    "bitbybit.verb.curve.circle.createCircle": "okrąg",
    "createCircle": "okrąg",
    "bitbybit.verb.curve.circle.createCircle_description": "Tworzy krzywą Nurbs okręgu",
    "xAxis": "oś x",
    "yAxis": "oś y",
    "bitbybit.verb.curve.circle.createArc": "łuk",
    "createArc": "łuk",
    "bitbybit.verb.curve.circle.createArc_description": "Tworzy krzywą Nurbs łuku",
    "minAngle": "min kąt",
    "maxAngle": "maks kąt",
    "bitbybit.verb.curve.circle.center": "środek",
    "bitbybit.verb.curve.circle.center_description": "Pobiera punkt środkowy okręgu lub łuku",
    "bitbybit.verb.curve.circle.radius": "promień",
    "bitbybit.verb.curve.circle.radius_description": "Pobiera promień okręgu lub łuku",
    "bitbybit.verb.curve.circle.maxAngle": "maks kąt",
    "bitbybit.verb.curve.circle.maxAngle_description": "Pobiera maksymalny kąt łuku w stopniach",
    "bitbybit.verb.curve.circle.minAngle": "min kąt",
    "bitbybit.verb.curve.circle.minAngle_description": "Pobiera minimalny kąt łuku w stopniach",
    "bitbybit.verb.curve.circle.xAxis": "oś x",
    "bitbybit.verb.curve.circle.xAxis_description": "Pobiera kąt x łuku",
    "bitbybit.verb.curve.circle.yAxis": "oś y",
    "bitbybit.verb.curve.circle.yAxis_description": "Pobiera kąt y łuku",
    "bitbybit.verb.curve.ellipse.createEllipse": "elipsa",
    "createEllipse": "elipsa",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Tworzy krzywą Nurbs elipsy",
    "bitbybit.verb.curve.ellipse.createArc": "łuk",
    "bitbybit.verb.curve.ellipse.createArc_description": "Tworzy krzywą Nurbs łuku elipsy",
    "bitbybit.verb.curve.ellipse.center": "środek",
    "bitbybit.verb.curve.ellipse.center_description": "Pobiera punkt środkowy elipsy lub łuku",
    "bitbybit.verb.curve.ellipse.maxAngle": "maks kąt",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Pobiera maksymalny kąt łuku w stopniach",
    "bitbybit.verb.curve.ellipse.minAngle": "min kąt",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Pobiera minimalny kąt łuku w stopniach",
    "bitbybit.verb.curve.ellipse.xAxis": "oś x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Pobiera kąt x łuku lub elipsy",
    "bitbybit.verb.curve.ellipse.yAxis": "oś y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Pobiera kąt y łuku lub elipsy",
    "bitbybit.verb.surface.boundaries": "granice",
    "boundaries": "granice",
    "bitbybit.verb.surface.boundaries_description": "Pobiera krawędzie graniczne Nurbs powierzchni w liście",
    "bitbybit.verb.surface.createSurfaceByCorners": "powierzchnia przez narożniki",
    "createSurfaceByCorners": "powierzchnia przez narożniki",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Tworzy powierzchnię podając 4 punkty jako narożniki",
    "point3": "punkt 3",
    "point4": "punkt 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "powierzchnia przez węzły punkty kontrolne wagi",
    "createSurfaceByKnotsControlPointsWeights": "powierzchnia przez węzły punkty kontrolne wagi",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Tworzy powierzchnię Nurbs podając węzły uv, stopnie uv, punkty i wagi",
    "degreeU": "stopień u",
    "degreeV": "stopień v",
    "knotsU": "węzły u",
    "knotsV": "węzły v",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "powierzchnia przez lofting krzywych",
    "createSurfaceByLoftingCurves": "powierzchnia przez lofting krzywych",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Tworzy powierzchnię Nurbs poprzez lofting krzywych",
    "bitbybit.verb.surface.clone": "klonuj",
    "bitbybit.verb.surface.clone_description": "Klonuj powierzchnię Nurbs",
    "bitbybit.verb.surface.closestParam": "najbliższy parametr",
    "bitbybit.verb.surface.closestParam_description": "Znajduje najbliższy parametr na powierzchni od punktu",
    "bitbybit.verb.surface.closestPoint": "najbliższy punkt",
    "bitbybit.verb.surface.closestPoint_description": "Znajduje najbliższy punkt na powierzchni od punktu",
    "bitbybit.verb.surface.controlPoints": "punkty kontrolne",
    "bitbybit.verb.surface.controlPoints_description": "Pobiera punkty kontrolne na powierzchni",
    "bitbybit.verb.surface.degreeU": "stopień u",
    "bitbybit.verb.surface.degreeU_description": "Pobiera stopień U powierzchni",
    "bitbybit.verb.surface.degreeV": "stopień v",
    "bitbybit.verb.surface.degreeV_description": "Pobiera stopień V powierzchni",
    "bitbybit.verb.surface.derivatives": "pochodne",
    "bitbybit.verb.surface.derivatives_description": "Pobiera pochodne powierzchni przy określonych współrzędnych uv",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "dziedzina u",
    "domainU": "dziedzina u",
    "bitbybit.verb.surface.domainU_description": "Pobiera dziedzinę U powierzchni",
    "bitbybit.verb.surface.domainV": "dziedzina v",
    "domainV": "dziedzina v",
    "bitbybit.verb.surface.domainV_description": "Pobiera dziedzinę V powierzchni",
    "bitbybit.verb.surface.isocurve": "izokrzywa",
    "isocurve": "izokrzywa",
    "bitbybit.verb.surface.isocurve_description": "Pobiera izokrzywę Nurbs na powierzchni",
    "useV": "użyj v",
    "bitbybit.verb.surface.isocurvesSubdivision": "podział izokrzyw",
    "isocurvesSubdivision": "podział izokrzyw",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Dzieli powierzchnię na preferowaną liczbę izokrzyw",
    "isocurveSegments": "segmenty izokrzyw",
    "bitbybit.verb.surface.isocurvesAtParams": "izokrzywe przy parametrach",
    "isocurvesAtParams": "izokrzywe przy parametrach",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Dzieli powierzchnię na izokrzywe przy określonej tablicy parametrów",
    "parameters": "parametry",
    "bitbybit.verb.surface.knotsU": "węzły u",
    "bitbybit.verb.surface.knotsU_description": "Pobiera węzły U powierzchni",
    "bitbybit.verb.surface.knotsV": "węzły v",
    "bitbybit.verb.surface.knotsV_description": "Pobiera węzły V powierzchni",
    "bitbybit.verb.surface.normal": "normalna",
    "bitbybit.verb.surface.normal_description": "Pobiera normalną na powierzchni przy współrzędnych uv",
    "bitbybit.verb.surface.point": "punkt",
    "bitbybit.verb.surface.point_description": "Pobiera punkt na powierzchni przy współrzędnych uv",
    "bitbybit.verb.surface.reverse": "odwróć",
    "bitbybit.verb.surface.reverse_description": "Odwróć powierzchnię Nurbs. Spowoduje to odwrócenie początku UV i kierunków izokrzyw",
    "bitbybit.verb.surface.split": "podziel",
    "bitbybit.verb.surface.split_description": "Dzieli powierzchnię Nurbs na dwie połówki.",
    "bitbybit.verb.surface.transformSurface": "przekształć powierzchnię",
    "transformSurface": "przekształć powierzchnię",
    "bitbybit.verb.surface.transformSurface_description": "Przekształca powierzchnię Nurbs za pomocą podanej listy transformacji.",
    "bitbybit.verb.surface.weights": "wagi",
    "bitbybit.verb.surface.weights_description": "Pobiera wagi powierzchni",
    "bitbybit.verb.surface.cone.create": "utwórz",
    "cone": "stożek",
    "bitbybit.verb.surface.cone.create_description": "Tworzy stożkową powierzchnię Nurbs",
    "bitbybit.verb.surface.cone.axis": "oś",
    "bitbybit.verb.surface.cone.axis_description": "Pobiera oś stożka",
    "bitbybit.verb.surface.cone.base": "podstawa",
    "bitbybit.verb.surface.cone.base_description": "Pobiera podstawę stożka",
    "bitbybit.verb.surface.cone.height": "wysokość",
    "bitbybit.verb.surface.cone.height_description": "Pobiera wysokość stożka",
    "bitbybit.verb.surface.cone.radius": "promień",
    "bitbybit.verb.surface.cone.radius_description": "Pobiera promień stożka",
    "bitbybit.verb.surface.cone.xAxis": "oś x",
    "bitbybit.verb.surface.cone.xAxis_description": "Pobiera oś x stożka",
    "bitbybit.verb.surface.cylinder.create": "utwórz",
    "bitbybit.verb.surface.cylinder.create_description": "Tworzy cylindryczną powierzchnię Nurbs",
    "bitbybit.verb.surface.cylinder.axis": "oś",
    "bitbybit.verb.surface.cylinder.axis_description": "Pobiera oś walca",
    "bitbybit.verb.surface.cylinder.base": "podstawa",
    "bitbybit.verb.surface.cylinder.base_description": "Pobiera podstawę walca",
    "bitbybit.verb.surface.cylinder.height": "wysokość",
    "bitbybit.verb.surface.cylinder.height_description": "Pobiera wysokość walca",
    "bitbybit.verb.surface.cylinder.radius": "promień",
    "bitbybit.verb.surface.cylinder.radius_description": "Pobiera promień walca",
    "bitbybit.verb.surface.cylinder.xAxis": "oś x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Pobiera oś x walca",
    "bitbybit.verb.surface.extrusion.create": "utwórz",
    "extrusion": "wyciągnięcie",
    "bitbybit.verb.surface.extrusion.create_description": "Tworzy powierzchnię Nurbs wyciągnięcia z krzywej",
    "profile": "profil",
    "bitbybit.verb.surface.extrusion.direction": "kierunek",
    "bitbybit.verb.surface.extrusion.direction_description": "Pobiera wektor kierunku wyciągnięcia",
    "bitbybit.verb.surface.extrusion.profile": "profil",
    "bitbybit.verb.surface.extrusion.profile_description": "Pobiera krzywą Nurbs profilu wyciągnięcia",
    "bitbybit.verb.surface.sphere.create": "utwórz",
    "bitbybit.verb.surface.sphere.create_description": "Tworzy sferyczną powierzchnię Nurbs",
    "bitbybit.verb.surface.sphere.radius": "promień",
    "bitbybit.verb.surface.sphere.radius_description": "Pobiera promień sferycznej powierzchni Nurbs",
    "bitbybit.verb.surface.sphere.center": "środek",
    "bitbybit.verb.surface.sphere.center_description": "Pobiera środek sferycznej powierzchni Nurbs",
    "bitbybit.verb.surface.revolved.create": "utwórz",
    "revolved": "obrócone",
    "bitbybit.verb.surface.revolved.create_description": "Tworzy obróconą powierzchnię Nurbs",
    "bitbybit.verb.surface.revolved.profile": "profil",
    "bitbybit.verb.surface.revolved.profile_description": "Pobiera krzywą Nurbs profilu obróconej powierzchni Nurbs",
    "revolution": "obrót",
    "bitbybit.verb.surface.revolved.center": "środek",
    "bitbybit.verb.surface.revolved.center_description": "Pobiera krzywą Nurbs środka obróconej powierzchni Nurbs",
    "bitbybit.verb.surface.revolved.axis": "oś",
    "bitbybit.verb.surface.revolved.axis_description": "Pobiera oś obrotu obróconej powierzchni Nurbs",
    "bitbybit.verb.surface.revolved.angle": "kąt",
    "bitbybit.verb.surface.revolved.angle_description": "Pobiera kąt obrotu z obróconej powierzchni Nurbs",
    "bitbybit.verb.surface.sweep.create": "utwórz",
    "sweep": "przeciągnięcie",
    "bitbybit.verb.surface.sweep.create_description": "Tworzy powierzchnię Nurbs przeciągnięcia",
    "rail": "szyna",
    "bitbybit.verb.surface.sweep.profile": "profil",
    "bitbybit.verb.surface.sweep.profile_description": "Pobiera krzywą Nurbs profilu przeciągniętej powierzchni Nurbs",
    "bitbybit.verb.surface.sweep.rail": "szyna",
    "bitbybit.verb.surface.sweep.rail_description": "Pobiera krzywą Nurbs szyny przeciągniętej powierzchni Nurbs",
    "bitbybit.verb.intersect.curves": "krzywe",
    "bitbybit.verb.intersect.curves_description": "Przecina dwie krzywe verb Nurbs ze sobą i zwraca wyniki przecięcia",
    "firstCurve": "pierwsza krzywa",
    "secondCurve": "druga krzywa",
    "bitbybit.verb.intersect.curveAndSurface": "krzywa i powierzchnia",
    "curveAndSurface": "krzywa i powierzchnia",
    "bitbybit.verb.intersect.curveAndSurface_description": "przecina krzywą i powierzchnię",
    "bitbybit.verb.intersect.surfaces": "powierzchnie",
    "bitbybit.verb.intersect.surfaces_description": "przecina dwie powierzchnie",
    "firstSurface": "pierwsza powierzchnia",
    "secondSurface": "druga powierzchnia",
    "bitbybit.verb.intersect.curveCurveFirstParams": "pierwsze parametry krzywa krzywa",
    "curveCurveFirstParams": "pierwsze parametry krzywa krzywa",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Pobiera parametry przecięcia na pierwszej krzywej z przecięcia krzywa-krzywa",
    "intersections": "przecięcia",
    "BaseTypes.CurveCurveIntersection[]": "tablica przecięć krzywa krzywa base types",
    "bitbybit.verb.intersect.curveCurveSecondParams": "drugie parametry krzywa krzywa",
    "curveCurveSecondParams": "drugie parametry krzywa krzywa",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Pobiera parametry przecięcia na drugiej krzywej z przecięcia krzywa-krzywa",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "pierwsze punkty krzywa krzywa",
    "curveCurveFirstPoints": "pierwsze punkty krzywa krzywa",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Pobiera punkty przecięcia na pierwszej krzywej z przecięcia krzywa-krzywa",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "drugie punkty krzywa krzywa",
    "curveCurveSecondPoints": "drugie punkty krzywa krzywa",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Pobiera punkty przecięcia na drugiej krzywej z przecięcia krzywa-krzywa",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "parametry krzywej przecięcia krzywa powierzchnia",
    "curveSurfaceCurveParams": "parametry krzywej przecięcia krzywa powierzchnia",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Pobiera parametry przecięcia na krzywej z przecięcia krzywa-powierzchnia",
    "BaseTypes.CurveSurfaceIntersection[]": "tablica przecięć krzywa powierzchnia base types",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "parametry powierzchni przecięcia krzywa powierzchnia",
    "curveSurfaceSurfaceParams": "parametry powierzchni przecięcia krzywa powierzchnia",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Pobiera parametry przecięcia na powierzchni z przecięcia krzywa-powierzchnia",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "punkty krzywej przecięcia krzywa powierzchnia",
    "curveSurfaceCurvePoints": "punkty krzywej przecięcia krzywa powierzchnia",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Pobiera punkty przecięcia na krzywej z przecięcia krzywa-powierzchnia",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "punkty powierzchni przecięcia krzywa powierzchnia",
    "curveSurfaceSurfacePoints": "punkty powierzchni przecięcia krzywa powierzchnia",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Pobiera punkty przecięcia na powierzchni z przecięcia krzywa-powierzchnia",
    "bitbybit.tag.create": "utwórz",
    "tag": "znacznik",
    "bitbybit.tag.create_description": "Tworzy znacznik dto",
    "adaptDepth": "dostosuj głębokość",
    "needsUpdate": "wymaga aktualizacji",
    "bitbybit.time.registerRenderFunction": "zarejestruj funkcję renderowania",
    "registerRenderFunction": "zarejestruj funkcję renderowania",
    "bitbybit.time.registerRenderFunction_description": "Rejestruje funkcję w pętli renderowania",
    "bitbybit.asset.getFile": "pobierz plik",
    "asset": "zasób",
    "getFile": "pobierz plik",
    "bitbybit.asset.getFile_description": "Pobiera plik zasobu",
    "bitbybit.asset.getLocalFile": "pobierz plik lokalny",
    "getLocalFile": "pobierz plik lokalny",
    "bitbybit.asset.getLocalFile_description": "Pobiera lokalny plik zasobu przechowywany w twojej przeglądarce.",
    "bitbybit.asset.fetchBlob": "pobierz blob",
    "fetchBlob": "pobierz blob",
    "bitbybit.asset.fetchBlob_description": "Pobiera blob z podanego adresu url, musi to być punkt końcowy z włączonym CORS",
    "fetch": "pobierz",
    "bitbybit.asset.fetchFile": "pobierz plik",
    "fetchFile": "pobierz plik",
    "bitbybit.asset.fetchFile_description": "Pobiera plik z podanego adresu url, musi to być punkt końcowy z włączonym CORS",
    "bitbybit.asset.fetchJSON": "pobierz json",
    "fetchJSON": "pobierz json",
    "bitbybit.asset.fetchJSON_description": "Pobiera json z podanego adresu url, musi to być punkt końcowy z włączonym CORS",
    "bitbybit.asset.fetchText": "pobierz tekst",
    "fetchText": "pobierz tekst",
    "bitbybit.asset.fetchText_description": "Pobiera json z podanego adresu url, musi to być punkt końcowy z włączonym CORS",
    "bitbybit.asset.createObjectURL": "url obiektu",
    "createObjectURL": "url obiektu",
    "bitbybit.asset.createObjectURL_description": "Pobiera i tworzy ścieżkę ciągu url do twojego pliku przechowywanego w twojej pamięci.",
    "file": "plik",
    "File | Blob": "plik lub blob",
    "bitbybit.asset.createObjectURLs": "url obiektów",
    "createObjectURLs": "url obiektów",
    "bitbybit.asset.createObjectURLs_description": "Pobiera i tworzy ścieżki ciągów url do twoich plików przechowywanych w twojej pamięci.",
    "files": "pliki",
    "(File | Blob)[]": "tablica plików lub blobów",
    "exec": "wykonaj",
    "Visible": "Widoczne",
    "Hidden": "Ukryte",
    "flatten": "spłaszcz",
    "force exec": "wymuś wykonanie",
    "console log": "log konsoli",
    "preview data": "podgląd danych",
    "flow": "przepływ",
    "code": "kod",
    "runner": "uruchamiacz",
    "counters": "liczniki",
    "actions": "akcje",
    "loops": "pętle",
    "interval": "interwał",
    "delay": "opóźnienie",
    "expire": "wygasa",
    "timeout": "limit czasu",
    "counter min max": "licznik min max",
    "counter steps": "kroki licznika",
    "reset": "resetuj",
    "trigger": "wyzwalacz",
    "mouse": "mysz",
    "mouse click": "kliknięcie myszą",
    "key": "klawisz",
    "pointer": "wskaźnik",
    "pick info": "info wyboru",
    "down": "w dół",
    "wheel": "kółko",
    "tap": "stuknięcie",
    "double tap": "podwójne stuknięcie",
    "render": "renderuj",
    "passed ms": "minęło ms",
    "babylon observable listener": "obserwator babylon",
    "object": "obiekt",
    "observable selector": "selektor obserwowalny",
    "get event data": "pobierz dane zdarzenia",
    "exec click": "wykonaj kliknięcie",
    "exec down": "wykonaj w dół",
    "toggle": "przełącz",
    "flip flop": "przerzutnik",
    "boolean gate": "bramka logiczna",
    "boolean gate silent": "bramka logiczna cicha",
    "is undefined": "jest niezdefiniowane",
    "for loop": "pętla for",
    "last": "ostatni",
    "for each loop": "pętla for each",
    "element": "element",
    "body": "ciało",
    "complete": "zakończone",
    "editors": "edytory",
    "inputs": "wejścia",
    "outputs": "wyjścia",
    "recent": "ostatnie",
    "Clear": "Wyczyść",
    "Run": "Uruchom",
    "Swap Canvas": "Zamień płótno",
    "Local Assets": "Lokalne zasoby",
    "Import": "Importuj",
    "Export": "Eksportuj",
    "Copy to Clipboard": "Kopiuj do schowka",
    "Paste from Clipboard": "Wklej ze schowka",
    "Export to runner": "Eksportuj do uruchamiacza",
    "Clean Cache": "Wyczyść pamięć podręczną",
    "Community": "Społeczność",
    "Sponsors and Partners": "Sponsorzy i Partnerzy",
    "API Documentation": "Dokumentacja API",
    "About": "O nas",
    "Toolbox": "Przybornik",
    "More": "Więcej",
    "bitbybit.code.typeScriptEditor": "edytor typescript",
    "bitbybit.code.typeScriptEditor_description": "Pozwala pisać kod TypeScript z pełnym intellisense bitbybit w jednej funkcji. Cokolwiek zwróci funkcja start, będzie widoczne jako wyjście komponentu.",
    "bitbybit.code.javaScriptEditor": "edytor javascript",
    "bitbybit.code.javaScriptEditor_description": "Pozwala pisać kod JavaScript w jednej funkcji. Cokolwiek zwróci funkcja start, będzie widoczne jako wyjście komponentu.",
    "bitbybit.code.jsonEditor": "edytor json",
    "bitbybit.code.jsonEditor_description": "Pozwala pisać kod JSON. Cokolwiek zwróci funkcja start, będzie widoczne jako wyjście komponentu.",
    "bitbybit.flow.actions.keyboard": "klawiatura",
    "bitbybit.flow.actions.keyboard_description": "Wywoła się na zdarzeniach klawiatury poprzez kliknięcie przycisków.",
    "bitbybit.flow.actions.mouseClick": "kliknięcie myszą",
    "bitbybit.flow.actions.mouseClick_description": "Wywoła się na zdarzeniach myszy poprzez kliknięcie przycisków.",
    "bitbybit.flow.actions.start": "start",
    "bitbybit.flow.actions.start_description": "Uruchamia przepływ sterowania i wyzwala wykonania.",
    "bitbybit.flow.actions.trigger": "wyzwalacz",
    "bitbybit.flow.actions.trigger_description": "Wyzwała wykonanie poprzez kliknięcie przycisku.",
    "bitbybit.flow.babylon.gui.button": "przycisk",
    "bitbybit.flow.babylon.gui.button_description": "Wywoła się na różnych zdarzeniach wskaźnika poprzez kliknięcie lewym przyciskiem myszy na płótnie babylonjs.",
    "bitbybit.flow.babylon.scene.pointerEvents": "wskaźnik",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Wywoła się na różnych zdarzeniach wskaźnika poprzez kliknięcie lewym przyciskiem myszy na płótnie babylonjs.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "pobierz dane zdarzenia",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Pobiera dane zdarzenia z obserwowanego wyniku nasłuchiwacza obserwowalnego.",
    "bitbybit.flow.babylon.observableListener": "nasłuchiwacz obserwowalny babylon",
    "bitbybit.flow.babylon.observableListener_description": "Będzie subskrybować i nasłuchiwać dowolnych obserwowalnych babylonjs.",
    "bitbybit.flow.babylon.render": "renderuj",
    "bitbybit.flow.babylon.render_description": "Wykonuje się na każdej klatce renderowania babylonjs.",
    "bitbybit.flow.counters.counterMinMax": "licznik min max",
    "bitbybit.flow.counters.counterMinMax_description": "Liczy liczbę wykonań przepływu między wartościami min i max. Po osiągnięciu max resetuje się",
    "bitbybit.flow.counters.counterSteps": "kroki licznika",
    "bitbybit.flow.counters.counterSteps_description": "Liczy liczbę wykonań przepływu zaczynając od danej wartości początkowej i zwiększając przy każdym wykonaniu o dany krok z listy, aż kroki się skończą. Po osiągnięciu końca resetuje się",
    "bitbybit.flow.counters.counter": "licznik",
    "bitbybit.flow.counters.counter_description": "Liczy liczbę wykonań przepływu.",
    "bitbybit.flow.logic.booleanGateSilent": "bramka logiczna cicha",
    "bitbybit.flow.logic.booleanGateSilent_description": "Wyzwała różne zdarzenia wykonania na podstawie dostarczonej wartości logicznej, ale wykonuje się tylko wtedy, gdy wartość logiczna zmienia swoją wartość, co zapobiega ciągłemu wyzwalaniu wielu zdarzeń, nawet jeśli nie nastąpiła żadna zmiana.",
    "bitbybit.flow.logic.booleanGate": "bramka logiczna",
    "bitbybit.flow.logic.booleanGate_description": "Wyzwała różne zdarzenia wykonania na podstawie dostarczonej wartości logicznej.",
    "bitbybit.flow.logic.flipFlop": "przerzutnik",
    "bitbybit.flow.logic.flipFlop_description": "Za każdym razem, gdy zdarzenie jest wykonywane, wyzwalane jest inne zdarzenie, w istocie tworząc funkcjonalność przełączania.",
    "bitbybit.flow.logic.isUndefined": "jest niezdefiniowane",
    "bitbybit.flow.logic.isUndefined_description": "Sprawdza, czy podana wartość jest niezdefiniowana i wyzwala zdarzenie prawda lub fałsz.",
    "bitbybit.flow.loops.forEach": "pętla dla każdego",
    "bitbybit.flow.loops.forEach_description": "Pętla dla każdego (for each), która przechodzi przez wszystkie elementy na liście.",
    "bitbybit.flow.loops.for": "pętla for",
    "bitbybit.flow.loops.for_description": "Pętla for, która wykonuje ciało między dwiema wartościami.",
    "bitbybit.flow.time.delay": "opóźnienie",
    "bitbybit.flow.time.delay_description": "Opóźnia wykonanie o podany czas w ms.",
    "bitbybit.flow.time.interval": "interwał",
    "bitbybit.flow.time.interval_description": "Wykonuje przepływ co podany interwał w ms.",
    "bitbybit.lists.createList": "utwórz listę",
    "bitbybit.lists.createList_description": "Tworzy listę z podanych elementów.",
    "bitbybit.lists.flatten": "spłaszcz",
    "bitbybit.lists.flatten_description": "Spłaszcza listę list do pojedynczej listy.",
    "bitbybit.lists.passThrough": "przepuść",
    "bitbybit.lists.passThrough_description": "Rzutuje wartość na typ 'any' i przekazuje wejście do wyjścia bez żadnych zmian.",
    "bitbybit.math.numberSlider": "suwak liczbowy",
    "bitbybit.math.numberSlider_description": "Tworzy liczbę z suwakiem. Możesz ustawić wartości min, max i krok.",
    "bitbybit.consoleLog": "log konsoli",
    "bitbybit.consoleLog_description": "Loguje wejście do konsoli przeglądarki.",
    "bitbybit.previewData": "podgląd danych",
    "bitbybit.previewData_description": "Pokazuje dane wejściowe w obszarze podglądu. Mogą to być tekst, liczby, obiekty json, tablice itp. Cykliczne obiekty Javascript nie są dozwolone.",
    "bitbybit.runner.getRunnerInputValue": "pobierz wartość wejściową uruchamiacza",
    "bitbybit.runner.getRunnerInputValue_description": "Pobierz wartość wejściową uruchamiacza z JSON wejść. Ten komponent zawsze zwróci wartość undefined w kontekście edytora.",
    "bitbybit.runner.getRunnerInputs": "pobierz wejścia uruchamiacza",
    "bitbybit.runner.getRunnerInputs_description": "Pobierz wejścia uruchamiacza w JSON. Ten komponent zawsze zwróci pusty obiekt w kontekście edytora.",
    "bitbybit.runner.run": "uruchom",
    "bitbybit.runner.run_description": "Uruchamia kod javascript uruchamiacza",
    "bitbybit.runner.setRunnerResult": "ustaw wynik uruchamiacza",
    "bitbybit.runner.setRunnerResult_description": "Ustawia kompletny wynik JSON dla uruchamiacza. Pamiętaj, że bezpieczniej jest ustawiać wartości, ponieważ ta metoda nadpisze cały obiekt wyniku podaną wartością.",
    "bitbybit.runner.setRunnerResultArrayValue": "ustaw wartość tablicy wyniku uruchamiacza",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Ustawia wartość wyniku uruchamiacza we właściwości obiektu JSON. Każda wartość zostanie dodana do tablicy, która jest wartością właściwości.",
    "bitbybit.runner.setRunnerResultValue": "ustaw wartość wyniku uruchamiacza",
    "bitbybit.runner.setRunnerResultValue_description": "Ustawia wartość wyniku runnera we właściwości obiektu JSON.",
    "bitbybit.text.areaCreate": "pole tekstowe",
    "bitbybit.text.areaCreate_description": "Tworzy pole tekstowe w edytorze. Możesz ustawić tekst, szerokość i wysokość obszaru.",
    "update on drag": "aktualizuj przy przeciąganiu",
    "paste": "wklej",
    "duplicate": "duplikuj",
    "delete": "usuń",
    "keyboard": "klawiatura",
    "data": "dane",
    "observables": "obserwowalne",
    "buttons": "przyciski",
    "variables": "zmienne",
    "functions": "funkcje",
    "loop": "pętla",
    "apply": "zastosuj",
    "async context": "kontekst asynchroniczny",
    "async context description": "Tworzy kontekst asynchroniczny, który może używać komponentów await, upraszczając wykonywanie kodu asynchronicznego i jego czytelność.",
    "then": "wtedy",
    "await": "oczekuj",
    "await description": "Czeka na rozwiązanie obietnicy i zwraca wartość.",
    "when the": "kiedy",
    "error": "błąd",
    "happens in the promise": "wystąpi w obietnicy",
    "catch": "przechwyć",
    "catch description": "Przechwytuje błąd, który może wystąpić podczas uruchamiania kodu asynchronicznego. Użytkownik może wybrać odpowiednią obsługę błędów.",
    "cancel the interval execution": "anuluj wykonanie interwału",
    "cancel the interval description": "Anuluje wykonanie interwału, podając uchwyt.",
    "cancel the timeout execution": "anuluj wykonanie limitu czasu",
    "cancel the timeout description": "Anuluje wykonanie limitu czasu, podając uchwyt.",
    "key down": "naciśnięcie klawisza",
    "key down descritpion": "Wyzwała kod, gdy nastąpi zdarzenie naciśnięcia klawisza.",
    "key up": "puszczenie klawisza",
    "key up description": "Wyzwała kod, gdy nastąpi zdarzenie puszczenia klawisza.",
    "key press": "wciśnięcie klawisza",
    "key press description": "Wyzwała kod, gdy nastąpi zdarzenie wciśnięcia klawisza.",
    "is key pressed": "czy klawisz jest wciśnięty",
    "block_validation_required": "musi zostać podany",
    "block_validation_of_length": "musi zawierać liczbę elementów",
    "block_validation_higher_or_equal": "musi być większe lub równe",
    "block_validation_lower_or_equal": "musi być mniejsze lub równe",
    "block_validation_range": "musi być w zakresie",
    "block_validation_smaller_than": "musi być mniejsze niż",
    "block_validation_smaller_or_equal_than": "musi być mniejsze lub równe",
    "block_validation_larger_than": "musi być większe niż",
    "block_validation_larger_or_equal_than": "musi być większe lub równe",
    "save text to file": "zapisz tekst do pliku",
    "save text to file description": "Zapisuje tekst do pliku i pozwala wybrać nazwę oraz rozszerzenie. Ten komponent nie wyświetla podglądu tekstu i może być używany w sytuacjach, gdy tekst jest zbyt duży, aby edytować go w polu tekstowym.",
    "print text on screen": "drukuj tekst na ekranie",
    "print text on screen description": "Drukuje tekst na ekranie. Ten komponent jest przydatny do celów debugowania.",
    "preview text and save to file": "podgląd tekstu i zapis do pliku",
    "preview text and save to file description": "Drukuje tekst na ekranie i pozwala zapisać go do pliku. Ten komponent jest przydatny do celów debugowania.",
    "register render loop listener": "zarejestruj nasłuchiwacza pętli renderowania",
    "and update": "i aktualizuj",
    "register render loop listener description": "Uruchamia instrukcję w pętli renderowania i wskazuje, ile czasu minęło od ostatniej klatki w zmiennej timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "czasUplynalOdPoprzedniejKlatki",
    "computing": "obliczanie",
    "result": "wynik",
    "of promise is returned": "obietnicy jest zwrócony",
    "on pointer up": "przy puszczeniu wskaźnika",
    "on pointer move": "przy ruchu wskaźnika",
    "on pointer down": "przy naciśnięciu wskaźnika",
    "of babylonjs observable object": "obiektu obserwowalnego babylonjs",
    "observable name": "nazwa obserwowalnego",
    "is key pressed description": "Sprawdza, czy klawisz jest wciśnięty i zwraca true lub false.",
    "execute code after": "wykonaj kod po",
    "execute code after description": "Wykonuje kod po upływie podanego czasu w sekundach.",
    "execute code every": "wykonuj kod co",
    "second(s)": "sekund(y)",
    "execute code every description": "Wykonuje kod co każdy podany interwał w sekundach.",
    "handler": "uchwyt",
    "workers initialising": "inicjowanie workerów",
    "Assets": "Zasoby",
    "Local assets stored in browser cache:": "Lokalne zasoby przechowywane w pamięci podręcznej przeglądarki:",
    "Asset Name": "Nazwa zasobu",
    "Name is required": "Nazwa jest wymagana",
    "Asset with this name already exists, choose a different one": "Zasób o tej nazwie już istnieje, wybierz inną",
    "Allowed file formats:": "Dozwolone formaty plików:",
    "You must select an asset file": "Musisz wybrać plik zasobu",
    "Upload Local Asset": "Prześlij lokalny zasób",
    "File Name": "Nazwa pliku",
    "File Size": "Rozmiar pliku",
    "Your browser does not support indexDB and you can't upload local asset files.": "Twoja przeglądarka nie obsługuje indexDB i nie możesz przesyłać lokalnych plików zasobów.",
    "Upload": "Prześlij",
    "elements": "elementy",
    "bitbybit.vector.vectorsTheSame": "wektory takie same",
    "vectorsTheSame": "wektory takie same",
    "bitbybit.vector.vectorsTheSame_description": "Sprawdza, czy dwa wektory są takie same w określonej tolerancji (uwzględnia precyzję zmiennoprzecinkową). Przykład: [1,2,3] vs [1.0001,2.0001,3.0001] z tolerancją 0.001 → true",
    "vec1": "wektor 1",
    "vec2": "wektor 2",
    "bitbybit.point.boundingBoxOfPoints": "prostopadłościan otaczający punktów",
    "boundingBoxOfPoints": "prostopadłościan otaczający punktów",
    "bitbybit.point.boundingBoxOfPoints_description": "Oblicza wyrównany do osi prostopadłościan otaczający zawierający wszystkie punkty (min, max, środek, szerokość, wysokość, długość). Przykład: punkty=[[0,0,0], [10,5,3]] → {min:[0,0,0], max:[10,5,3], center:[5,2.5,1.5], width:10, height:5, length:3}",
    "bitbybit.point.normalFromThreePoints": "normalna z trzech punktów",
    "normalFromThreePoints": "normalna z trzech punktów",
    "bitbybit.point.normalFromThreePoints_description": "Oblicza wektor normalny z trzech punktów używając iloczynu wektorowego (prostopadły do płaszczyzny). Przykład: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0] → [0,0,1] (skierowany w górę od płaszczyzny XY)",
    "reverseNormal": "odwróć normalną",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "kontur linii z przedłużeniami",
    "createLineWireWithExtensions": "kontur linii z przedłużeniami",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Tworzy kontur linii OpenCascade z przedłużeniami",
    "extensionStart": "przedłużenie start",
    "extensionEnd": "przedłużenie koniec",
    "bitbybit.occt.shapes.wire.midPointOnWire": "punkt środkowy na konturze",
    "midPointOnWire": "punkt środkowy na konturze",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Oblicza punkt środkowy na konturze przy parametrze 0.5",
    "centerOnOrigin": "wyśrodkuj na początku",
    "bitbybit.occt.shapes.wire.textWiresWithData": "kontury tekstu z danymi",
    "textWiresWithData": "kontury tekstu z danymi",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Tworzy złożenie OpenCascade z konturów tekstu i zwraca dodatkowe informacje w oparciu o czcionkę simplex stworzoną przez dr. A. V. Hersheya",
    "bitbybit.occt.transforms.alignNormAndAxis": "wyrównaj normalną i oś",
    "alignNormAndAxis": "wyrównaj normalną i oś",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Wyrównaj kształt za pomocą normalnej i osi",
    "fromNorm": "z normalnej",
    "fromAx": "z osi",
    "toNorm": "do normalnej",
    "toAx": "do osi",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "prosty liniowy wymiar długości",
    "simpleLinearLengthDimension": "prosty liniowy wymiar długości",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Tworzy prosty liniowy wymiar długości między dwoma punktami - jednostki miary. Decydujesz, jakich jednostek używasz, podając przyrostek.",
    "offsetFromPoints": "przesunięcie od punktów",
    "crossingSize": "rozmiar przecięcia",
    "labelSuffix": "przyrostek etykiety",
    "labelSize": "rozmiar etykiety",
    "labelOffset": "przesunięcie etykiety",
    "bitbybit.occt.dimensions.simpleAngularDimension": "prosty wymiar kątowy",
    "simpleAngularDimension": "prosty wymiar kątowy",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Tworzy prosty wymiar kątowy. Domyślnie wyprowadzamy stopnie, ale możesz wybrać radiany.",
    "direction1": "kierunek 1",
    "direction2": "kierunek 2",
    "offsetFromCenter": "przesunięcie od środka",
    "extraSize": "dodatkowy rozmiar",
    "radians": "radiany",
    "bitbybit.occt.dimensions.pinWithLabel": "szpilka z etykietą",
    "pinWithLabel": "szpilka z etykietą",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Tworzy etykietę pinezki. Może być używana do wyjaśniania rzeczy o modelach lub oznaczania rzeczy w scenie 3D.",
    "offsetFromStart": "przesunięcie od początku",
    "bitbybit.vector.lengthSq": "długość do kwadratu",
    "lengthSq": "długość do kwadratu",
    "bitbybit.vector.lengthSq_description": "Oblicza kwadrat długości (kwadrat wielkości) wektora 3D. Przykład: [3,4,0] → 25 (długość 5 do kwadratu)",
    "bitbybit.point.twoPointsAlmostEqual": "dwa punkty równe",
    "twoPointsAlmostEqual": "dwa punkty równe",
    "bitbybit.point.twoPointsAlmostEqual_description": "Sprawdza, czy dwa punkty są w przybliżeniu równe w granicach tolerancji (porównanie oparte na odległości). Przykład: punkt1=[1.0000001, 2.0, 3.0], punkt2=[1.0, 2.0, 3.0], tolerancja=1e-6 → true",
    "bitbybit.line.lineToSegment": "linia na segment",
    "lineToSegment": "linia na segment",
    "bitbybit.line.lineToSegment_description": "Konwertuje obiekt linii na format tablicy segmentu. Przykład: {start:[0,0,0], end:[10,5,0]} → [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "linie na segmenty",
    "linesToSegments": "linie na segmenty",
    "bitbybit.line.linesToSegments_description": "Konwertuje wiele obiektów linii na format tablicy segmentu (konwersja wsadowa). Przykład: 3 obiekty linii → 3 tablice segmentów [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "segment na linię",
    "segmentToLine": "segment na linię",
    "bitbybit.line.segmentToLine_description": "Konwertuje tablicę segmentu na format obiektu linii. Przykład: [[0,0,0], [10,5,0]] → {start:[0,0,0], end:[10,5,0]}",
    "segment": "segment",
    "Base.Segment3": "bazowy segment 3",
    "bitbybit.line.segmentsToLines": "segmenty na linie",
    "segmentsToLines": "segmenty na linie",
    "bitbybit.line.segmentsToLines_description": "Konwertuje wiele tablic segmentów na format obiektu linii (konwersja wsadowa). Przykład: 3 tablice segmentów → 3 obiekty linii z właściwościami startend",
    "Base.Segment3[]": "tablica bazowych segmentów 3",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "sortuj segmenty w polilinie",
    "sortSegmentsIntoPolylines": "sortuj segmenty w polilinie",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Sortuje pomieszane segmenty w połączone polilinie poprzez dopasowanie punktów końcowych. Wykorzystuje haszowanie przestrzenne do wydajnego znajdowania połączeń. Przykład: 10 losowych segmentów tworzących 2 połączone ścieżki → 2 polilinie",
    "sort": "sortuj",
    "bitbybit.mesh.signedDistanceToPlane": "odległość ze znakiem do płaszczyzny",
    "signedDistanceToPlane": "odległość ze znakiem do płaszczyzny",
    "bitbybit.mesh.signedDistanceToPlane_description": "Oblicza odległość ze znakiem od punktu do płaszczyzny (dodatnia=nad płaszczyzną, ujemna=pod). Przykład: punkt=[0,5,0], płaszczyzna={normal:[0,1,0], d:0} → 5 (punkt jest 5 jednostek nad płaszczyzną XZ)",
    "plane": "płaszczyzna",
    "Base.TrianglePlane3": "bazowa płaszczyzna trójkąta 3",
    "bitbybit.mesh.calculateTrianglePlane": "oblicz płaszczyznę trójkąta",
    "calculateTrianglePlane": "oblicz płaszczyznę trójkąta",
    "bitbybit.mesh.calculateTrianglePlane_description": "Oblicza równanie płaszczyzny z wierzchołków trójkąta (wektor normalny i odległość od początku). Zwraca undefined, jeśli trójkąt jest zdegenerowany (zerowe pole powierzchni, punkty współliniowe). Przykład: trójkąt=[[0,0,0], [1,0,0], [0,1,0]] → {normal:[0,0,1], d:0} (płaszczyzna XY)",
    "triangle": "trójkąt",
    "Base.Triangle3": "bazowy trójkąt 3",
    "bitbybit.mesh.triangleTriangleIntersection": "przecięcie trójkąt trójkąt",
    "triangleTriangleIntersection": "przecięcie trójkąt trójkąt",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Oblicza segment przecięcia dwóch trójkątów (odcinek linii, gdzie się przecinają). Zwraca undefined, jeśli trójkąty się nie przecinają, są równoległe lub współpłaszczyznowe. Przykład: trójkąt1=[[0,0,0], [2,0,0], [1,2,0]], trójkąt2=[[1,-1,1], [1,1,1], [1,1,-1]] → [[1,0,0], [1,1,0]]",
    "triangle1": "trójkąt 1",
    "triangle2": "trójkąt 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segmenty przecięcia siatka siatka",
    "meshMeshIntersectionSegments": "segmenty przecięcia siatka siatka",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Oblicza wszystkie segmenty przecięcia między dwiema siatkami trójkątów (testy par trójkątów). Zwraca tablicę odcinków linii, gdzie powierzchnie siatek się przecinają. Przykład: siatka sześcianu przecinająca się z siatką kuli → wiele segmentów tworzących krzywą przecięcia",
    "mesh1": "siatka 1",
    "Base.Mesh3": "bazowa siatka 3",
    "mesh2": "siatka 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polilinie przecięcia siatka siatka",
    "meshMeshIntersectionPolylines": "polilinie przecięcia siatka siatka",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Oblicza polilinie przecięcia między dwiema siatkami poprzez sortowanie segmentów w połączone ścieżki. Segmenty są łączone koniec-do-końca, tworząc ciągłe lub zamknięte krzywe. Przykład: przecięcie sześcian-kula → zamknięte pętle polilinii, gdzie powierzchnie się spotykają",
    "bitbybit.occt.shapeFacesToPolygonPoints": "ściany kształtu na punkty wielokąta",
    "shapeFacesToPolygonPoints": "ściany kształtu na punkty wielokąta",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Tworzy punkty wielokąta ze ścian kształtu",
    "reversedPoints": "odwrócone punkty",
    "bitbybit.occt.shapeToMesh": "kształt na siatkę",
    "shapeToMesh": "kształt na siatkę",
    "bitbybit.occt.shapeToMesh_description": "Tworzy siatkę z kształtu",
    "bitbybit.occt.shapesToMeshes": "kształty na siatki",
    "shapesToMeshes": "kształty na siatki",
    "bitbybit.occt.shapesToMeshes_description": "Tworzy siatkę z kształtu",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "z punktów wielokąta",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Utwórz Manifold z zestawu punktów wielokąta opisujących trójkąty.",
    "traingle": "trójkąt",
    "bitbybit.point.stretchPointsDirFromCenter": "rozciągnij punkty w kierunku od środka",
    "stretchPointsDirFromCenter": "rozciągnij punkty w kierunku od środka",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Rozciąga wiele punktów wzdłuż kierunku od punktu środkowego (skalowanie kierunkowe). Przykład: punkty=[[10,0,0]], środek=[0,0,0], kierunek=[1,0,0], skala=2 → [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "siatka heksagonalna przeskalowana do dopasowania",
    "hexGridScaledToFit": "siatka heksagonalna przeskalowana do dopasowania",
    "bitbybit.point.hexGridScaledToFit_description": "Tworzy siatkę heksagonalną przeskalowaną tak, aby mieściła się w określonych granicach szerokości i wysokości (automatycznie oblicza rozmiar heksagonu). Zwraca punkty środkowe i wierzchołki heksagonów. Obsługuje orientację wierzchołkiem do góry (pointy-top) lub płaskim bokiem do góry (flat-top). Przykład: szerokość=10, wysokość=10, nrHeksagonowWWysokosci=3 → siatka heksagonalna wypełniająca obszar 10×10 z 3 rzędami",
    "nrHexagonsU": "liczba heksagonów u",
    "nrHexagonsV": "liczba heksagonów v",
    "extendTop": "rozszerz góra",
    "extendBottom": "rozszerz dół",
    "extendLeft": "rozszerz lewo",
    "extendRight": "rozszerz prawo",
    "centerGrid": "wyśrodkuj siatkę",
    "bitbybit.point.sortPoints": "sortuj punkty",
    "sortPoints": "sortuj punkty",
    "bitbybit.point.sortPoints_description": "Sortuje punkty leksykograficznie (według współrzędnych X, następnie Y, następnie Z). Przykład: [[5,0,0], [1,0,0], [3,0,0]] → [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "przecięcie linia linia",
    "lineLineIntersection": "przecięcie linia linia",
    "bitbybit.line.lineLineIntersection_description": "Oblicza punkt przecięcia dwóch linii (lub segmentów, jeśli checkSegmentsOnly=true). Zwraca undefined, jeśli linie są równoległe, skośne lub segmenty się nie nakładają. Przykład: linia1={start:[0,0,0], koniec:[10,0,0]}, linia2={start:[5,-5,0], koniec:[5,5,0]} → [5,0,0]",
    "line1": "linia 1",
    "line2": "linia 2",
    "checkSegmentsOnly": "sprawdź tylko segmenty",
    "bitbybit.polyline.polylineToLines": "polilinia na linie",
    "polylineToLines": "polilinia na linie",
    "bitbybit.polyline.polylineToLines_description": "Konwertuje polilinię na segmenty linii (każdy segment jako obiekt linii ze startkoniec). Zamknięte polilinie zawierają segment zamykający. Przykład: 3 punkty → 2 lub 3 linie (w zależności od isClosed)",
    "bitbybit.polyline.polylineToSegments": "polilinia na segmenty",
    "polylineToSegments": "polilinia na segmenty",
    "bitbybit.polyline.polylineToSegments_description": "Konwertuje polilinię na tablice segmentów (każdy segment jako [punkt1, punkt2]). Zamknięte polilinie zawierają segment zamykający, jeśli punkty końcowe się różnią. Przykład: 4 punkty, zamknięta → 4 segmenty łączące wszystkie punkty w pętlę",
    "bitbybit.polyline.polylineSelfIntersection": "samoprzecięcie polilinii",
    "polylineSelfIntersection": "samoprzecięcie polilinii",
    "bitbybit.polyline.polylineSelfIntersection_description": "Znajduje punkty, w których polilinia przecina samą siebie (punkty samoprzecięcia). Pomija sąsiednie segmenty i usuwa zduplikowane bliskie punkty. Przykład: polilinia w kształcie ósemki → zwraca środkowy punkt przecięcia",
    "bitbybit.polyline.twoPolylineIntersection": "przecięcie dwóch polilinii",
    "twoPolylineIntersection": "przecięcie dwóch polilinii",
    "bitbybit.polyline.twoPolylineIntersection_description": "Znajduje punkty przecięcia między dwiema poliliniami (wszystkie przecięcia segment-segment). Testuje wszystkie pary segmentów i usuwa zduplikowane bliskie punkty. Przykład: krzyżujące się polilinie tworzące X → zwraca środkowy punkt przecięcia",
    "polyline1": "polilinia 1",
    "polyline2": "polilinia 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "podziel na kontury heksagonalne",
    "subdivideToHexagonWires": "podziel na kontury heksagonalne",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Dzieli ścianę na kontury heksagonalne",
    "extendUUp": "rozszerz u góra",
    "extendUBottom": "rozszerz u dół",
    "extendVUp": "rozszerz v góra",
    "extendVBottom": "rozszerz v dół",
    "nrHexagonsInHeight": "liczba heksagonów w wysokości",
    "nrHexagonsInWidth": "liczba heksagonów w szerokości",
    "bitbybit.vector.length": "długość wektora",
    "bitbybit.vector.length_description": "Oblicza długość (wielkość) wektora 3D. Przykład: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.point.maxFilletRadius": "maks promień zaokrąglenia",
    "maxFilletRadius": "maks promień zaokrąglenia",
    "bitbybit.point.maxFilletRadius_description": "Oblicza maksymalny możliwy promień zaokrąglenia w narożniku utworzonym przez dwa segmenty linii dzielące punkt końcowy (C), tak aby łuk zaokrąglenia był styczny do obu segmentów i leżał całkowicie w ich obrębie.",
    "bitbybit.point.maxFilletRadiusHalfLine": "maks promień zaokrąglenia półlinii",
    "maxFilletRadiusHalfLine": "maks promień zaokrąglenia półlinii",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Oblicza maksymalny możliwy promień zaokrąglenia w narożniku C, tak aby łuk zaokrąglenia był styczny do obu segmentów (P1-C, P2-C) a punkty styczności leżały w pierwszej połowie każdego segmentu (mierząc od C).",
    "bitbybit.point.maxFilletsHalfLine": "maks zaokrąglenia półlinii",
    "maxFilletsHalfLine": "maks zaokrąglenia półlinii",
    "bitbybit.point.maxFilletsHalfLine_description": "Oblicza maksymalny możliwy promień zaokrąglenia w każdym narożniku polilinii utworzonej przez serię punktów. Promień zaokrąglenia jest obliczany dla każdego wewnętrznego narożnika i opcjonalnie dla narożników zamykających, jeśli polilinia jest zamknięta.",
    "checkLastWithFirst": "sprawdź ostatni z pierwszym",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "bezpieczne punkty maks zaokrąglenia półlinii",
    "safestPointsMaxFilletHalfLine": "bezpieczne punkty maks zaokrąglenia półlinii",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Oblicza pojedynczy najbezpieczniejszy maksymalny promień zaokrąglenia, który można zastosować równomiernie do wszystkich narożników kolekcji punktów, w oparciu o ograniczenie 'półlinii'. Jest to określane poprzez znalezienie minimum z maksymalnych możliwych promieni zaokrąglenia obliczonych dla każdego pojedynczego narożnika.",
    "bitbybit.polyline.maxFilletsHalfLine": "maks zaokrąglenia półlinii",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Oblicza maksymalny możliwy promień zaokrąglenia półlinii dla każdego narożnika danej polilinii. Dla zamkniętej polilinii obejmuje narożniki łączące ostatni segment z powrotem z pierwszym. Obliczenie wykorzystuje ograniczenie 'półlinii', co oznacza, że punkty styczności zaokrąglenia muszą leżeć w pierwszej połowie każdego segmentu połączonego z narożnikiem.",
    "bitbybit.polyline.safestFilletRadius": "najbezpieczniejszy promień zaokrąglenia",
    "safestFilletRadius": "najbezpieczniejszy promień zaokrąglenia",
    "bitbybit.polyline.safestFilletRadius_description": "Oblicza pojedynczy najbezpieczniejszy maksymalny promień zaokrąglenia, który można zastosować równomiernie do wszystkich narożników polilinii, w oparciu o ograniczenie 'półlinii'. Jest to określane poprzez znalezienie minimum z maksymalnych możliwych promieni zaokrąglenia obliczonych dla każdego pojedynczego narożnika.",
    "flatTop": "płaska góra",
    "bitbybit.mesh.meshMeshIntersectionPoints": "punkty przecięcia siatka siatka",
    "meshMeshIntersectionPoints": "punkty przecięcia siatka siatka",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Oblicza punkty przecięcia między dwiema siatkami jako tablice punktów (jedna tablica na polilinię). Zamknięte polilinie mają pierwszy punkt zduplikowany na końcu. Przykład: przecięcie sześcian-kula → tablice punktów definiujących krzywe przecięcia",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "heksagony w siatce",
    "hexagonsInGrid": "heksagony w siatce",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Tworzy kontury heksagonów OpenCascade w siatce",
    "scalePatternWidth": "skaluj szerokość wzoru",
    "scalePatternHeight": "skaluj wysokość wzoru",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "kontury przecięcia siatka siatka",
    "meshMeshIntersectionWires": "kontury przecięcia siatka siatka",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Wykonuje operację przecięcia siatka-siatka między dwoma kształtami - oba kształty mogą mieć własną precyzję siatkowania. Ten algorytm przecina siatki i zwraca kontury przecięcia, które są poliliniami lub wielokątami.",
    "mesh based": "oparte na siatce",
    "precision1": "precyzja 1",
    "precision2": "precyzja 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "punkty przecięcia siatka siatka",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Wykonuje operację przecięcia siatka-siatka między dwoma kształtami - oba kształty mogą mieć własną precyzję siatkowania. Ten algorytm przecina siatki i zwraca punkty przecięcia, które są poliliniami lub wielokątami.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "kontury przecięcia siatka siatka kształtów",
    "meshMeshIntersectionOfShapesWires": "kontury przecięcia siatka siatka kształtów",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Wykonuje operację przecięcia siatka-siatka między kształtem a wieloma innymi kształtami - wszystkie kształty mogą mieć własną precyzję siatkowania. Ten algorytm przecina siatki i zwraca kontury przecięcia, które są poliliniami lub wielokątami.",
    "precisionShapes": "precyzja kształtów",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "punkty przecięcia siatka siatka kształtów",
    "meshMeshIntersectionOfShapesPoints": "punkty przecięcia siatka siatka kształtów",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Wykonuje operację przecięcia siatka-siatka między kształtem a wieloma innymi kształtami - wszystkie kształty mogą mieć własną precyzję siatkowania. Ten algorytm przecina siatki i zwraca punkty przecięcia.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "heksagony w siatce",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Tworzy heksagony OpenCascade w siatce",
    "bitbybit.jscad.toPolygonPoints": "na punkty wielokąta",
    "toPolygonPoints": "na punkty wielokąta",
    "bitbybit.jscad.toPolygonPoints_description": "Konwertuje siatkę Jscad na punkty wielokąta reprezentujące trójkąty siatki.",
    "conversions": "konwersje",
    "bitbybit.manifold.toPolygonPoints": "na punkty wielokąta",
    "bitbybit.manifold.toPolygonPoints_description": "Zamienia kształt manifold na kolekcję punktów wielokąta reprezentującą siatkę.",
    "flatU": "płaskie u",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "podziel na otwory heksagonalne",
    "subdivideToHexagonHoles": "podziel na otwory heksagonalne",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Dzieli ścianę na otwory heksagonalne",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "konwertuj linie na krzywe nurbs",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Konwertuje linie na krzywe NURBS. Zwraca tablicę obiektów Line verbnurbs",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "konwertuj linię na krzywą nurbs",
    "convertLineToNurbsCurve": "konwertuj linię na krzywą nurbs",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Konwertuje linię na krzywą NURBS. Zwraca obiekt Line verbnurbs",
    "Base.Line3": "bazowa linia 3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "konwertuj polilinię na krzywą nurbs",
    "convertPolylineToNurbsCurve": "konwertuj polilinię na krzywą nurbs",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Konwertuje polilinię na krzywą NURBS. Zwraca obiekt NurbsCurve verbnurbs",
    "Base.Polyline3": "bazowa polilinia 3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "konwertuj polilinie na krzywe nurbs",
    "convertPolylinesToNurbsCurves": "konwertuj polilinie na krzywe nurbs",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Konwertuje polilinie na krzywe NURBS. Zwraca obiekty NurbsCurve verbnurbs",
    "Base.Polyline3[]": "tablica bazowych polilinii 3",
    "bitbybit.line.createSegment": "segment",
    "createSegment": "segment",
    "bitbybit.line.createSegment_description": "Tworzy segment z dwóch punktów (format tablicy: [start, koniec]). Przykład: start=[0,0,0], koniec=[10,5,0] → [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "krawędź z linii bazowej",
    "fromBaseLine": "z linii bazowej",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Tworzy krawędź liniową z formatu linii bazowej {start: Point3, end: Point3}",
    "from base": "z bazowej",
    "bitbybit.occt.shapes.edge.fromBaseLines": "krawędzie z linii bazowych",
    "fromBaseLines": "z linii bazowych",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Tworzy krawędzie liniowe z formatu linii bazowych {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "krawędź z segmentu bazowego",
    "fromBaseSegment": "z segmentu bazowego",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Tworzy krawędź liniową z formatu segmentu bazowego [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "krawędzie z segmentów bazowych",
    "fromBaseSegments": "z segmentów bazowych",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Tworzy krawędzie liniowe z formatu segmentów bazowych [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "krawędzie z punktów",
    "fromPoints": "z punktów",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Tworzy krawędzie liniowe z kolekcji punktów",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "krawędzie z polilinii bazowej",
    "fromBasePolyline": "z polilinii bazowej",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Tworzy krawędzie liniowe z definicji polilinii",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "krawędzie z trójkąta bazowego",
    "fromBaseTriangle": "z trójkąta bazowego",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Tworzy krawędzie liniowe z definicji trójkąta",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "krawędzie z siatki bazowej",
    "fromBaseMesh": "z siatki bazowej",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Tworzy krawędzie liniowe z definicji siatki",
    "bitbybit.occt.shapes.wire.fromBaseLine": "kontur z linii bazowej",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Tworzy kontur liniowy z formatu linii bazowej {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "kontury z linii bazowych",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Tworzy kontury liniowe z formatu linii bazowych {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "kontur z segmentu bazowego",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Tworzy kontur liniowy z formatu segmentu bazowego [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "kontury z segmentów bazowych",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Tworzy kontury liniowe z formatu segmentów bazowych [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "kontur z punktów",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Tworzy kontur z kolekcji punktów",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "kontur z polilinii bazowej",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Tworzy kontur z definicji polilinii",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "kontur z trójkąta bazowego",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Tworzy kontur z definicji trójkąta",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "kontury z siatki bazowej",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Tworzy kontury z definicji siatki",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "ściana z trójkąta bazowego",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Tworzy ścianę z definicji trójkąta",
    "bitbybit.occt.shapes.face.fromBaseMesh": "ściany z siatki bazowej",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Tworzy ściany z definicji siatki",
    "fromRightHanded": "z prawoskrętnego",
    "bitbybit.advanced.text3d.createWithUrl": "tekst z url",
    "createWithUrl": "tekst z url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Tworzy tekst 3d z URL czcionki. Jest to przydatne, gdy chcesz użyć niestandardowej czcionki, która nie jest dołączona do biblioteki. Czcionka zostanie załadowana z podanego adresu URL i użyta do wygenerowania tekstu 3d. Upewnij się, że czcionki nie zawierają samoprzecięć i innych błędnych znaków - jest to częsty problem z niestandardowymi czcionkami. Obsługiwane formaty czcionek to: ttf, otf, woff. Należy pamiętać, że Woff2 nie jest obsługiwany przez opentype.js, ponieważ jest to format skompresowany.",
    "fontUrl": "url czcionki",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "tekst na ścianie url",
    "createTextOnFaceUrl": "tekst na ścianie url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Tworzy tekst 3d na ścianie używając URL czcionki. Jest to przydatne, gdy chcesz użyć niestandardowej czcionki, która nie jest dołączona do biblioteki. Czcionka zostanie załadowana z podanego adresu URL i użyta do wygenerowania tekstu 3d. Upewnij się, że czcionki nie zawierają samoprzecięć i innych błędnych znaków - jest to częsty problem z niestandardowymi czcionkami. Obsługiwane formaty czcionek to: ttf, otf, woff. Należy pamiętać, że Woff2 nie jest obsługiwany przez opentype.js, ponieważ jest to format skompresowany.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "teksty na ścianie url",
    "createTextsOnFaceUrl": "teksty na ścianie url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Tworzy teksty 3d na ścianie z wielu definicji url. Jest to przydatne, gdy chcesz użyć niestandardowej czcionki, która nie jest dołączona do biblioteki. Czcionka zostanie załadowana z podanego adresu URL i użyta do wygenerowania tekstu 3d. Upewnij się, że czcionki nie zawierają samoprzecięć i innych błędnych znaków - jest to częsty problem z niestandardowymi czcionkami. Obsługiwane formaty czcionek to: ttf, otf, woff. Należy pamiętać, że Woff2 nie jest obsługiwany przez opentype.js, ponieważ jest to format skompresowany.",
    "Text3DFaceDefinitionUrlDto[]": "tablica definicji url tekstu 3d na ścianie dto",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "definicja url tekstu 3d na ścianie",
    "definition3dTextOnFaceUrl": "definicja url tekstu 3d na ścianie",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Tworzy tekst 3d, który zostanie użyty na definicji url ściany. Jest to przydatne, gdy chcesz użyć niestandardowej czcionki, która nie jest dołączona do biblioteki. Czcionka zostanie załadowana z podanego adresu URL i użyta do wygenerowania tekstu 3d. Upewnij się, że czcionki nie zawierają samoprzecięć i innych błędnych znaków - jest to częsty problem z niestandardowymi czcionkami. Obsługiwane formaty czcionek to: ttf, otf, woff. Należy pamiętać, że Woff2 nie jest obsługiwany przez opentype.js, ponieważ jest to format skompresowany.",
    "bitbybit.advanced.navigation.pointOfInterest": "punkt zainteresowania",
    "navigation": "nawigacja",
    "pointOfInterest": "punkt zainteresowania",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Tworzy punkt zainteresowania - klikalny wskaźnik w przestrzeni 3D, którego można użyć do przelotu kamery do określonej lokalizacji z predefiniowaną pozycją i celem kamery. Punkt zainteresowania można stylizować za pomocą PointOfInterestStyleDto i animować efektem pulsu. Punkt zainteresowania może mieć również etykietę tekstową.",
    "cameraTarget": "cel kamery",
    "cameraPosition": "pozycja kamery",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "system punktów zainteresowania",
    "pointsOfInterestSystem": "system punktów zainteresowania",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "System zarządzający punktami zainteresowania",
    "pointsOfInterest": "punkty zainteresowania",
    "PointOfInterestDto[]": "tablica punktów zainteresowania dto",
    "point of interest": "punkt zainteresowania",
    "style": "styl",
    "PointOfInterestStyleDto": "styl punktu zainteresowania dto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "styl punktu zainteresowania",
    "pointOfInterestStyle": "styl punktu zainteresowania",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Tworzy styl punktu zainteresowania - używany do stylizacji wskaźników punktów zainteresowania w przestrzeni 3D. Możesz dostosować rozmiar punktu, kolor, kolor po najechaniu, efekt pulsu, kolor i rozmiar etykiety tekstowej.",
    "pointSize": "rozmiar punktu",
    "pointColor": "kolor punktu",
    "hoverPointColor": "kolor punktu po najechaniu",
    "pulseColor": "kolor pulsu",
    "hoverPulseColor": "kolor pulsu po najechaniu",
    "pulseMinSize": "min rozmiar pulsu",
    "pulseMaxSize": "max rozmiar pulsu",
    "pulseThickness": "grubość pulsu",
    "pulseSpeed": "prędkość pulsu",
    "textColor": "kolor tekstu",
    "hoverTextColor": "kolor tekstu po najechaniu",
    "textSize": "rozmiar tekstu",
    "hideSkybox": "ukryj skybox",
    "textureUrl": "url tekstury",
    "hdrTexture": "tekstura hdr",
    "textureSize": "rozmiar tekstury",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "włącz niestandardową teksturę skybox",
    "enableSkyboxCustomTexture": "włącz niestandardową teksturę skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Włącza skybox z niestandardową teksturą",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "obraz tła css płótna",
    "canvasCSSBackgroundImage": "obraz tła css płótna",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Zmienia tło sceny na obraz tła css dla przestrzeni 3D",
    "cssBackgroundImage": "obraz tła css",
    "bitbybit.babylon.scene.twoColorLinearGradient": "dwukolorowy gradient liniowy",
    "twoColorLinearGradient": "dwukolorowy gradient liniowy",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Tworzy dwukolorowe tło z gradientem liniowym dla przestrzeni 3D",
    "colorFrom": "kolor od",
    "colorTo": "kolor do",
    "Base.gradientDirectionEnum": "kierunek gradientu enum",
    "stopFrom": "stop od",
    "stopTo": "stop do",
    "bitbybit.babylon.scene.twoColorRadialGradient": "dwukolorowy gradient radialny",
    "twoColorRadialGradient": "dwukolorowy gradient radialny",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Tworzy dwukolorowe tło z gradientem radialnym dla przestrzeni 3D",
    "Base.gradientPositionEnum": "pozycja gradientu enum",
    "Base.gradientShapeEnum": "kształt gradientu enum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "wielokolorowy gradient liniowy",
    "multiColorLinearGradient": "wielokolorowy gradient liniowy",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Tworzy wielokolorowe tło z gradientem liniowym dla przestrzeni 3D",
    "Base.Color[]": "tablica kolorów bazowych",
    "stops": "punkty stopu",
    "bitbybit.babylon.scene.multiColorRadialGradient": "wielokolorowy gradient radialny",
    "multiColorRadialGradient": "wielokolorowy gradient radialny",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Tworzy wielokolorowe tło z gradientem radialnym dla przestrzeni 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "obraz tła płótna",
    "canvasBackgroundImage": "obraz tła płótna",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Ustawia obraz tła z różnymi opcjami dostosowywania dla przestrzeni 3D",
    "imageUrl": "url obrazu",
    "Base.backgroundRepeatEnum": "powtarzanie tła enum",
    "Base.backgroundSizeEnum": "rozmiar tła enum",
    "attachment": "załącznik",
    "Base.backgroundAttachmentEnum": "załącznik tła enum",
    "Base.backgroundOriginClipEnum": "pochodzenie przycinanie tła enum",
    "clip": "przytnij",
    "labelRotation": "obrót etykiety",
    "bitbybit.advanced.dimensions.linearDimension": "wymiar liniowy",
    "linearDimension": "wymiar liniowy",
    "bitbybit.advanced.dimensions.linearDimension_description": "Tworzy wymiar liniowy - linię pomiarową między dwoma punktami z liniami pomocniczymi i etykietą tekstową. Wymiar pokazuje odległość między punktami i może być stylizowany za pomocą DimensionStyleDto.",
    "linear dimension": "wymiar liniowy",
    "DimensionStyleDto": "styl wymiaru dto",
    "bitbybit.advanced.dimensions.angularDimension": "wymiar kątowy",
    "angularDimension": "wymiar kątowy",
    "bitbybit.advanced.dimensions.angularDimension_description": "Tworzy wymiar kątowy - łuk pomiarowy między dwoma wektorami kierunku z liniami pomocniczymi i etykietą tekstową. Wymiar pokazuje kąt między kierunkami i może być stylizowany za pomocą DimensionStyleDto.",
    "angular dimension": "wymiar kątowy",
    "centerPoint": "punkt środkowy",
    "bitbybit.advanced.dimensions.dimensionStyle": "styl wymiaru",
    "dimensionStyle": "styl wymiaru",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Tworzy styl wymiaru - używany do stylizacji linii wymiarowych, strzałek i tekstu w przestrzeni 3D. Możesz dostosować kolory linii, grubość, rozmiar tekstu, rozmiar strzałki i kolory tła.",
    "dimension style": "styl wymiaru",
    "lineColor": "kolor linii",
    "lineThickness": "grubość linii",
    "extensionLineLength": "długość linii pomocniczej",
    "textBackgroundColor": "kolor tła tekstu",
    "textBackgroundOpacity": "przezroczystość tła tekstu",
    "arrowSize": "rozmiar strzałki",
    "arrowColor": "kolor strzałki",
    "textRenderMode": "tryb renderowania tekstu",
    "textRenderModeEnum": "tryb renderowania tekstu enum",
    "textBillboard": "billboard tekstu",
    "occlusionCheckInterval": "interwał sprawdzania okluzji",
    "arrowTailLength": "długość ogona strzałki",
    "showArrows": "pokaż strzałki",
    "labelOverwrite": "nadpisanie etykiety",
    "bitbybit.advanced.dimensions.radialDimension": "wymiar promieniowy",
    "radialDimension": "wymiar promieniowy",
    "bitbybit.advanced.dimensions.radialDimension_description": "Tworzy wymiar promieniowy - linię pomiarową od środka do obwodu pokazującą promień lub średnicę. Pokazuje przedrostek 'R' dla promienia lub '⌀' dla średnicy z opcjonalnym znacznikiem środka.",
    "radial dimension": "wymiar promieniowy",
    "radiusPoint": "punkt promienia",
    "showDiameter": "pokaż średnicę",
    "showCenterMark": "pokaż znacznik środka",
    "bitbybit.advanced.dimensions.diametralDimension": "wymiar średnicowy",
    "diametralDimension": "wymiar średnicowy",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Tworzy wymiar średnicowy - linię pomiarową obejmującą pełną średnicę elementów kołowych. Pokazuje przedrostek '⌀' z opcjonalnym znacznikiem środka i strzałkami na obu końcach.",
    "diametral dimension": "wymiar średnicowy",
    "bitbybit.advanced.dimensions.ordinateDimension": "wymiar rzędnych",
    "ordinateDimension": "wymiar rzędnych",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Tworzy wymiar rzędnych - pokazuje współrzędną X, Y lub Z od punktu odniesienia z linią odniesienia. Przydatne do adnotacji współrzędnych i odniesień bazowych na rysunkach technicznych.",
    "ordinate dimension": "wymiar rzędnych",
    "measurementPoint": "punkt pomiarowy",
    "referencePoint": "punkt odniesienia",
    "ordinateAxisEnum": "oś rzędnych enum",
    "showLeaderLine": "pokaż linię odniesienia",
    "viewMode": "tryb widoku",
    "schema": "schemat",
    "json schema": "schemat json",
    "metadata": "metadane",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "tło dwukolorowy gradient liniowy",
    "twoColorLinearGradientBackground": "tło dwukolorowy gradient liniowy",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Tworzy dwukolorowe tło z gradientem liniowym dla przestrzeni 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "tło dwukolorowy gradient radialny",
    "twoColorRadialGradientBackground": "tło dwukolorowy gradient radialny",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Tworzy dwukolorowe tło z gradientem radialnym dla przestrzeni 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "tło wielokolorowy gradient liniowy",
    "multiColorLinearGradientBackground": "tło wielokolorowy gradient liniowy",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Tworzy wielokolorowe tło z gradientem liniowym dla przestrzeni 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "tło wielokolorowy gradient radialny",
    "multiColorRadialGradientBackground": "tło wielokolorowy gradient radialny",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Tworzy wielokolorowe tło z gradientem radialnym dla przestrzeni 3D",
    "textBackgroundStroke": "obrys tła tekstu",
    "textBackgroundRadius": "promień tła tekstu",
    "stableSize": "stabilny rozmiar",
    "alwaysOnTop": "zawsze na wierzchu",
    "textStableSize": "stabilny rozmiar tekstu",
    "bitbybit.occt.io.shapeToDxfPaths": "kształt na ścieżki dxf",
    "shapeToDxfPaths": "kształt na ścieżki dxf",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Tworzy ścieżki DXF z kształtu OCCT. Ważne - kształty zawierające kontury muszą leżeć na płaszczyźnie XZ (Y=0) dla poprawnego eksportu DXF 2D.",
    "dxf": "dxf",
    "bitbybit.occt.io.dxfPathsWithLayer": "ścieżki dxf z warstwą",
    "dxfPathsWithLayer": "ścieżki dxf z warstwą",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Dodaje informacje o warstwie i kolorze do ścieżek DXF. Ważne - kształty zawierające kontury muszą leżeć na płaszczyźnie XZ (Y=0) dla poprawnego eksportu DXF 2D.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "warstwa",
    "bitbybit.occt.io.dxfCreate": "utwórz dxf",
    "dxfCreate": "utwórz dxf",
    "bitbybit.occt.io.dxfCreate_description": "Składa wiele części ścieżek w kompletny plik DXF. Ważne - kształty zawierające kontury muszą leżeć na płaszczyźnie XZ (Y=0) dla poprawnego eksportu DXF 2D.",
    "pathsParts": "części ścieżek",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "waga czcionki tekstu",
    "textPosition": "pozycja tekstu",
    "textBackgroundStrokeThickness": "grubość obrysu",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Wyczyść",
    "recompute": "Przelicz ponownie",
    "clear tooltip": "Wyczyść całą pamięć podręczną i komponenty",
    "recompute tooltip": "Czyści pamięć podręczną i przelicza ponownie",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "kontur profilu dwuteownika",
    "createIBeamProfileWire": "kontur profilu dwuteownika",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Tworzy kontur profilu dwuteownika OpenCascade",
    "beam profiles": "profile belek",
    "webThickness": "grubość środnika",
    "flangeThickness": "grubość półki",
    "alignment": "wyrównanie",
    "Base.basicAlignmentEnum": "bazowe wyrównanie enum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "kontur profilu dwuteownika H",
    "createHBeamProfileWire": "kontur profilu dwuteownika H",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Tworzy kontur profilu dwuteownika H OpenCascade",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "kontur profilu teownika",
    "createTBeamProfileWire": "kontur profilu teownika",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Tworzy kontur profilu teownika OpenCascade",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "kontur profilu ceownika",
    "createUBeamProfileWire": "kontur profilu ceownika",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Tworzy kontur profilu ceownika OpenCascade",
    "flangeWidth": "szerokość półki",
    "bitbybit.occt.shapes.face.createLPolygonFace": "ściana wielokąta L",
    "createLPolygonFace": "ściana wielokąta L",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Tworzy ścianę wielokąta L OpenCascade",
    "bitbybit.occt.shapes.face.createStarFace": "ściana gwiazdy",
    "createStarFace": "ściana gwiazdy",
    "bitbybit.occt.shapes.face.createStarFace_description": "Tworzy ścianę gwiazdy OpenCascade",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "ściana choinki",
    "createChristmasTreeFace": "ściana choinki",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Tworzy ścianę choinki OpenCascade",
    "bitbybit.occt.shapes.face.createParallelogramFace": "ściana równoległoboku",
    "createParallelogramFace": "ściana równoległoboku",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Tworzy ścianę równoległoboku OpenCascade",
    "bitbybit.occt.shapes.face.createHeartFace": "ściana serca",
    "createHeartFace": "ściana serca",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Tworzy ścianę serca OpenCascade",
    "bitbybit.occt.shapes.face.createNGonFace": "ściana n-kąta",
    "createNGonFace": "ściana n-kąta",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Tworzy ścianę n-kąta OpenCascade",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "ściana profilu dwuteownika",
    "createIBeamProfileFace": "ściana profilu dwuteownika",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Tworzy ścianę profilu dwuteownika OpenCascade",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "ściana profilu dwuteownika H",
    "createHBeamProfileFace": "ściana profilu dwuteownika H",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Tworzy ścianę profilu dwuteownika H OpenCascade",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "ściana profilu teownika",
    "createTBeamProfileFace": "ściana profilu teownika",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Tworzy ścianę profilu teownika OpenCascade",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "ściana profilu ceownika",
    "createUBeamProfileFace": "ściana profilu ceownika",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Tworzy ścianę profilu ceownika OpenCascade",
    "bitbybit.occt.shapes.solid.createStarSolid": "bryła gwiazdy",
    "createStarSolid": "bryła gwiazdy",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Tworzy bryłę gwiazdy OpenCascade",
    "extrusionLengthFront": "długość wyciągnięcia przód",
    "extrusionLengthBack": "długość wyciągnięcia tył",
    "bitbybit.occt.shapes.solid.createNGonSolid": "bryła n-kąta",
    "createNGonSolid": "bryła n-kąta",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Tworzy bryłę n-kąta OpenCascade",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "bryła równoległoboku",
    "createParallelogramSolid": "bryła równoległoboku",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Tworzy bryłę równoległoboku OpenCascade",
    "bitbybit.occt.shapes.solid.createHeartSolid": "bryła serca",
    "createHeartSolid": "bryła serca",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Tworzy bryłę serca OpenCascade",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "bryła choinki",
    "createChristmasTreeSolid": "bryła choinki",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Tworzy bryłę choinki OpenCascade",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "bryła wielokąta L",
    "createLPolygonSolid": "bryła wielokąta L",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Tworzy bryłę wielokąta L OpenCascade",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "bryła profilu dwuteownika",
    "createIBeamProfileSolid": "bryła profilu dwuteownika",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Tworzy bryłę profilu dwuteownika OpenCascade",
    "beam": "belka",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "bryła profilu dwuteownika H",
    "createHBeamProfileSolid": "bryła profilu dwuteownika H",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Tworzy bryłę profilu dwuteownika H OpenCascade",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "bryła profilu teownika",
    "createTBeamProfileSolid": "bryła profilu teownika",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Tworzy bryłę profilu teownika OpenCascade",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "bryła profilu ceownika",
    "createUBeamProfileSolid": "bryła profilu ceownika",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Tworzy bryłę profilu ceownika OpenCascade",
    "endType": "typ końca",
    "dimensionEndTypeEnum": "typ końca wymiaru enum",
    "arrowAngle": "kąt strzałki",
    "arrowsFlipped": "odwrócone strzałki",
    "colorFormat": "format koloru",
    "dxfColorFormatEnum": "format koloru dxf enum",
    "acadVersion": "wersja acad",
    "dxfAcadVersionEnum": "wersja dxf acad enum",
    "bitbybit.advanced.navigation.zoomOn": "zoom na",
    "zoomOn": "zoom na",
    "bitbybit.advanced.navigation.zoomOn_description": "Powiększa kamerę, aby dopasować określone siatki w scenie z płynną animacją. Działa tylko z ArcRotateCamera. Animacja może zostać przerwana, jeśli zostanie wywołana wielokrotnie.",
    "animationSpeed": "prędkość animacji",
    "doNotUpdateMaxZ": "nie aktualizuj max z",
    "bitbybit.advanced.navigation.focusFromAngle": "ogniskuj z kąta",
    "focusFromAngle": "ogniskuj z kąta",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Ustawia ostrość kamery na określone siatki z określonego kąta z płynną animacją. Oblicza środek prostopadłościanu otaczającego wszystkich siatek i ustawia kamerę w określonym wektorze orientacji, aby patrzyła na środek. Działa tylko z ArcRotateCamera. Animacja może zostać przerwana, jeśli zostanie wywołana wielokrotnie.",
    "padding": "dopełnienie",
    "shadowRefreshRate": "częstotliwość odświeżania cieni",
    "labelFlipHorizontal": "odwróć etykietę poziomo",
    "labelFlipVertical": "odwróć etykietę pionowo",
    "bitbybit.advanced.navigation.zoomOnAspect": "zoom na aspekt",
    "zoomOnAspect": "zoom na aspekt",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Powiększa kamerę, aby dopasować określone siatki w scenie z płynną animacją, biorąc pod uwagę dokładny współczynnik proporcji ekranu. W przeciwieństwie do zoomOn, ta metoda precyzyjnie oblicza odległość kamery na podstawie wymiarów rzutni i prostopadłościanu otaczającego siatki, aby zapewnić lepsze dopasowanie przy padding=0. Działa tylko z ArcRotateCamera. Animacja może zostać przerwana, jeśli zostanie wywołana wielokrotnie.",
    "bitbybit.vector.parseNumbers": "parsuj liczby",
    "parseNumbers": "parsuj liczby",
    "bitbybit.vector.parseNumbers_description": "Konwertuje tablicę ciągów liczbowych na liczby rzeczywiste. Przykład: ['1', '2.5', '3'] → [1, 2.5, 3], ['10', '-5', '0.1'] → [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "uprość",
    "bitbybit.manifold.manifold.operations.simplify_description": "Zwraca kopię manifoldu uproszczoną do podanej tolerancji, ale z niezmienioną rzeczywistą wartością tolerancji. Wynik będzie zawierał podzbiór oryginalnych wierzchołków, a wszystkie powierzchnie przesuną się o mniej niż tolerancja.",
    "bitbybit.manifold.manifold.operations.setProperties": "ustaw właściwości",
    "setProperties": "ustaw właściwości",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Tworzy nową kopię tego manifoldu ze zaktualizowanymi właściwościami wierzchołków, dostarczając funkcję, która jako dane wejściowe przyjmuje istniejącą pozycję i właściwości. Możesz określić dowolną liczbę właściwości wyjściowych, umożliwiając tworzenie i usuwanie kanałów. Uwaga: niezdefiniowane zachowanie wystąpi, jeśli odczytasz poza liczbę właściwości wejściowych lub zapiszesz poza liczbę właściwości wyjściowych.",
    "propFunc": "funkcja właściwości",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], pozycja: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "wypacz",
    "warp": "wypacz",
    "bitbybit.manifold.manifold.transforms.warp_description": "Przesuwa wierzchołki tego Manifoldu (tworząc nowy) zgodnie z dowolną funkcją wejściową. Łatwo jest stworzyć funkcję, która wypacza poprawny geometrycznie obiekt w taki, który się nakłada, ale nie jest to tutaj sprawdzane, więc do użytkownika należy wybór funkcji z rozwagą.",
    "warpFunc": "funkcja wypaczania",
    "(vert: Base.Vector3) => void": "(wierzch: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "status",
    "status": "status",
    "bitbybit.manifold.manifold.evaluate.status_description": "Zwraca przyczynę, dla której wejściowa siatka tworzy pusty Manifold. Ten Status będzie przenoszony przez operacje takie jak propagacja NaN, zapewniając, że błędna siatka nie zaginie tajemniczo. Puste siatki mogą nadal pokazywać NoError, na przykład przecięcie nienakładających się siatek.",
    "bitbybit.manifold.crossSection.transforms.warp": "wypacz",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Przesuwa wierzchołki tego Przekroju (tworząc nowy) zgodnie z dowolną funkcją wejściową, po czym następuje operacja sumy (z regułą wypełniania Positive), która zapewnia, że wszelkie wprowadzone przecięcia nie zostaną uwzględnione w wyniku.",
    "(vert: Base.Vector2) => void": "(wierzch: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "zaokrąglij i usuń końcowe zera",
    "roundAndRemoveTrailingZeros": "zaokrąglij i usuń końcowe zera",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Zaokrągla liczbę do określonej liczby miejsc po przecinku i usuwa końcowe zera. Przykład: 1.32156 z 3 miejscami zwraca 1.322, ale 1.320000001 zwraca 1.32, a 1.000 zwraca 1",
    "bitbybit.math.clamp": "ogranicz",
    "clamp": "ogranicz",
    "bitbybit.math.clamp_description": "Ogranicza wartość między wartością minimalną a maksymalną. Przykład: clamp(5, 0, 3) zwraca 3, clamp(-1, 0, 3) zwraca 0, clamp(1.5, 0, 3) zwraca 1.5",
    "bitbybit.math.lerp": "lerp",
    "bitbybit.math.lerp_description": "Liniowa interpolacja między dwiema wartościami przy użyciu parametru t (0 do 1). Przykład: Od 0 do 100 przy t=0.5 → 50, Od 10 do 20 przy t=0.25 → 12.5 Gdy t=0 zwraca początek, gdy t=1 zwraca koniec. Przydatne do płynnych przejść.",
    "t": "t",
    "bitbybit.math.inverseLerp": "odwrotny lerp",
    "inverseLerp": "odwrotny lerp",
    "bitbybit.math.inverseLerp_description": "Oblicza parametr interpolacji t dla wartości pomiędzy początkiem a końcem (odwrotność lerp). Przykład: Wartość 5 w zakresie [0,10] → t=0.5, Wartość 2.5 w zakresie [0,10] → t=0.25 Zwraca, jaka wartość t dałaby daną wartość w lerp. Przydatne do znajdowania pozycji względnej.",
    "bitbybit.math.smoothstep": "gładki krok",
    "smoothstep": "gładki krok",
    "bitbybit.math.smoothstep_description": "Interpolacja Hermite'a z płynnym przyspieszaniem i zwalnianiem (gładsza niż liniowy lerp). Przykład: x=0 → 0, x=0.5 → 0.5, x=1 → 1 (ale z gładką krzywą S pomiędzy) Wejście jest automatycznie ograniczone do [0,1]. Wyjście płynnie wchodzi i wychodzi. Świetne do animacji.",
    "bitbybit.math.sign": "znak",
    "sign": "znak",
    "bitbybit.math.sign_description": "Zwraca znak liczby: -1 dla ujemnej, 0 dla zera, 1 dla dodatniej. Przykład: -5 → -1, 0 → 0, 3.14 → 1 Przydatne do określania kierunku lub biegunowości.",
    "bitbybit.math.fract": "część ułamkowa",
    "fract": "część ułamkowa",
    "bitbybit.math.fract_description": "Zwraca część ułamkową liczby (usuwa część całkowitą, zachowuje dziesiętne). Przykład: 3.14 → 0.14, 5.9 → 0.9, -2.3 → 0.7 Przydatne do zawijania wartości i tworzenia powtarzających się wzorów.",
    "bitbybit.math.wrap": "zawiń",
    "bitbybit.math.wrap_description": "Zawija liczbę w określonym zakresie (tworzy powtarzający się cykl). Przykład: 1.5 w zakresie [0,1) → 0.5, -0.3 w zakresie [0,1) → 0.7, 370° w zakresie [0,360) → 10° Przydatne do kątów, UV lub dowolnej powtarzającej się domeny. Jak modulo, ale poprawnie obsługuje liczby ujemne.",
    "bitbybit.math.pingPong": "ping pong",
    "pingPong": "ping pong",
    "bitbybit.math.pingPong_description": "Tworzy efekt ping-pong (tam i z powrotem), który odbija wartość między 0 a długością. Wartość idzie od 0→długość, następnie z powrotem długość→0, powtarzając ten cykl. Przykład: Przy długości=1: t=0→0, t=0.5→0.5, t=1→1 (szczyt), t=1.5→0.5, t=2→0, t=2.5→0.5 (powtarza się) Przydatne do tworzenia odbijających się animacji, takich jak piłka lub ruch oscylacyjny.",
    "bitbybit.math.moveTowards": "przesuń w kierunku",
    "moveTowards": "przesuń w kierunku",
    "bitbybit.math.moveTowards_description": "Przesuwa wartość w kierunku celu o maksymalną wielkość delta (nigdy nie przekraczając celu). Przykład: Od 0 w kierunku 10 o max 3 → 3, Od 8 w kierunku 10 o max 3 → 10 (osiągnięto) Przydatne do płynnego ruchu z ograniczeniami maksymalnej prędkości.",
    "current": "bieżący",
    "maxDelta": "maks delta",
    "bitbybit.lists.getFirstItem": "pobierz pierwszy element",
    "getFirstItem": "pobierz pierwszy element",
    "bitbybit.lists.getFirstItem_description": "Pobiera pierwszy element z listy. Przykład: Z [10, 20, 30, 40], zwraca 10",
    "bitbybit.lists.getLastItem": "pobierz ostatni element",
    "getLastItem": "pobierz ostatni element",
    "bitbybit.lists.getLastItem_description": "Pobiera ostatni element z listy. Przykład: Z [10, 20, 30, 40], zwraca 40",
    "bitbybit.lists.shuffle": "tasuj",
    "shuffle": "tasuj",
    "bitbybit.lists.shuffle_description": "Losowo zmienia kolejność wszystkich elementów na liście (używając algorytmu Fishera-Yatesa). Przykład: Z [1, 2, 3, 4, 5], może zwrócić [3, 1, 5, 2, 4] (kolejność zmienia się za każdym razem)",
    "bitbybit.lists.includes": "zawiera",
    "includes": "zawiera",
    "bitbybit.lists.includes_description": "Sprawdza, czy lista zawiera określony element. Przykład: Lista [10, 20, 30, 40] z elementem 30 zwraca true, z elementem 50 zwraca false",
    "bitbybit.lists.findIndex": "znajdź indeks",
    "findIndex": "znajdź indeks",
    "bitbybit.lists.findIndex_description": "Znajduje pozycję (indeks) pierwszego wystąpienia elementu na liście. Przykład: W [10, 20, 30, 20, 40], znalezienie 20 zwraca 1 (pierwsze wystąpienie), znalezienie 50 zwraca -1 (nie znaleziono)",
    "bitbybit.lists.removeFirstItem": "usuń pierwszy element",
    "removeFirstItem": "usuń pierwszy element",
    "bitbybit.lists.removeFirstItem_description": "Usuwa pierwszy element z listy. Przykład: Z [10, 20, 30, 40], zwraca [20, 30, 40]",
    "bitbybit.lists.removeLastItem": "usuń ostatni element",
    "removeLastItem": "usuń ostatni element",
    "bitbybit.lists.removeLastItem_description": "Usuwa ostatni element z listy. Przykład: Z [10, 20, 30, 40], zwraca [10, 20, 30]",
    "bitbybit.lists.removeItemAtIndexFromEnd": "usuń element na indeksie od końca",
    "removeItemAtIndexFromEnd": "usuń element na indeksie od końca",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Usuwa element licząc od końca listy (indeks 0 = ostatni element, 1 = przedostatni, itd.). Przykład: Z [10, 20, 30, 40, 50], usunięcie indeksu 1 od końca daje [10, 20, 30, 50] (usuwa 40)",
    "bitbybit.lists.removeDuplicates": "usuń duplikaty",
    "removeDuplicates": "usuń duplikaty",
    "bitbybit.lists.removeDuplicates_description": "Usuwa zduplikowane elementy z listy używając ścisłego porównania równości (działa z każdym typem). Przykład: Z ['a', 'b', 'c', 'a', 'd', 'b'], zwraca ['a', 'b', 'c', 'd']",
    "bitbybit.lists.concatenate": "złącz",
    "concatenate": "złącz",
    "bitbybit.lists.concatenate_description": "Łączy wiele list w jedną listę, łącząc je koniec-do-końca. Przykład: Z [[1, 2], [3, 4], [5, 6]], zwraca [1, 2, 3, 4, 5, 6]",
    "bitbybit.lists.interleave": "przeplataj",
    "interleave": "przeplataj",
    "bitbybit.lists.interleave_description": "Łączy wiele list, naprzemiennie biorąc elementy z każdej listy (pierwszy z listy1, pierwszy z listy2, drugi z listy1 itd.). Przykład: Z [[0, 1, 2], [3, 4, 5]], zwraca [0, 3, 1, 4, 2, 5]",
    "bitbybit.text.includes": "zawiera",
    "bitbybit.text.includes_description": "Sprawdza, czy tekst zawiera szukany ciąg. Przykład: tekst='witaj świecie', szukaj='świecie' → true",
    "bitbybit.text.startsWith": "zaczyna się od",
    "startsWith": "zaczyna się od",
    "bitbybit.text.startsWith_description": "Sprawdza, czy tekst zaczyna się od szukanego ciągu. Przykład: tekst='witaj świecie', szukaj='witaj' → true",
    "bitbybit.text.endsWith": "kończy się na",
    "endsWith": "kończy się na",
    "bitbybit.text.endsWith_description": "Sprawdza, czy tekst kończy się na szukany ciąg. Przykład: tekst='witaj świecie', szukaj='świecie' → true",
    "bitbybit.text.indexOf": "indeks",
    "indexOf": "indeks",
    "bitbybit.text.indexOf_description": "Zwraca indeks pierwszego wystąpienia szukanego ciągu. Przykład: tekst='witaj świecie', szukaj='świecie' → 6",
    "bitbybit.text.lastIndexOf": "ostatni indeks",
    "lastIndexOf": "ostatni indeks",
    "bitbybit.text.lastIndexOf_description": "Zwraca indeks ostatniego wystąpienia szukanego ciągu. Przykład: tekst='witaj świecie witaj', szukaj='witaj' → 12",
    "bitbybit.text.substring": "podciąg",
    "substring": "podciąg",
    "bitbybit.text.substring_description": "Wyodrębnia fragment tekstu między dwoma indeksami. Przykład: tekst='witaj świecie', start=0, koniec=5 → 'witaj'",
    "bitbybit.text.slice": "wytnij",
    "bitbybit.text.slice_description": "Wyodrębnia fragment tekstu i zwraca nowy ciąg. Przykład: tekst='witaj świecie', start=0, koniec=5 → 'witaj'",
    "bitbybit.text.charAt": "znak na pozycji",
    "charAt": "znak na pozycji",
    "bitbybit.text.charAt_description": "Zwraca znak na określonym indeksie. Przykład: tekst='witaj', indeks=1 → 'i'",
    "bitbybit.text.trim": "przytnij",
    "bitbybit.text.trim_description": "Usuwa białe znaki z obu końców tekstu. Przykład: tekst='  witaj  ' → 'witaj'",
    "bitbybit.text.trimStart": "przytnij początek",
    "trimStart": "przytnij początek",
    "bitbybit.text.trimStart_description": "Usuwa białe znaki z początku tekstu. Przykład: tekst='  witaj  ' → 'witaj  '",
    "bitbybit.text.trimEnd": "przytnij koniec",
    "trimEnd": "przytnij koniec",
    "bitbybit.text.trimEnd_description": "Usuwa białe znaki z końca tekstu. Przykład: tekst='  witaj  ' → '  witaj'",
    "bitbybit.text.padStart": "dopełnij początek",
    "padStart": "dopełnij początek",
    "bitbybit.text.padStart_description": "Dopełnia tekst od początku, aby osiągnąć docelową długość. Przykład: tekst='x', długość=3, ciagDopelniajacy='a' → 'aax'",
    "padString": "ciąg dopełniający",
    "bitbybit.text.padEnd": "dopełnij koniec",
    "padEnd": "dopełnij koniec",
    "bitbybit.text.padEnd_description": "Dopełnia tekst od końca, aby osiągnąć docelową długość. Przykład: tekst='x', długość=3, ciagDopelniajacy='a' → 'xaa'",
    "bitbybit.text.toUpperCase": "na wielkie litery",
    "toUpperCase": "na wielkie litery",
    "bitbybit.text.toUpperCase_description": "Konwertuje tekst na wielkie litery. Przykład: tekst='witaj' → 'WITAJ'",
    "bitbybit.text.toLowerCase": "na małe litery",
    "toLowerCase": "na małe litery",
    "bitbybit.text.toLowerCase_description": "Konwertuje tekst na małe litery. Przykład: tekst='WITAJ' → 'witaj'",
    "bitbybit.text.toUpperCaseFirst": "pierwsza wielka",
    "toUpperCaseFirst": "pierwsza wielka",
    "bitbybit.text.toUpperCaseFirst_description": "Zamienia pierwszą literę tekstu na wielką. Przykład: tekst='witaj świecie' → 'Witaj świecie'",
    "bitbybit.text.toLowerCaseFirst": "pierwsza mała",
    "toLowerCaseFirst": "pierwsza mała",
    "bitbybit.text.toLowerCaseFirst_description": "Zamienia pierwszą literę tekstu na małą. Przykład: tekst='Witaj Świecie' → 'witaj Świecie'",
    "bitbybit.text.repeat": "powtórz",
    "bitbybit.text.repeat_description": "Powtarza tekst określoną liczbę razy. Przykład: tekst='ha', liczba=3 → 'hahaha'",
    "bitbybit.text.reverse": "odwróć",
    "bitbybit.text.reverse_description": "Odwraca znaki w tekście. Przykład: tekst='witaj' → 'jatiw'",
    "bitbybit.text.length": "długość",
    "bitbybit.text.length_description": "Zwraca długość tekstu. Przykład: tekst='witaj' → 5",
    "bitbybit.text.isEmpty": "jest pusty",
    "bitbybit.text.isEmpty_description": "Sprawdza, czy tekst jest pusty lub zawiera tylko białe znaki. Przykład: tekst='   ' → true",
    "bitbybit.text.concat": "złącz",
    "concat": "złącz",
    "bitbybit.text.concat_description": "Łączy wiele ciągów tekstowych. Przykład: teksty=['witaj', ' ', 'świecie'] → 'witaj świecie'",
    "texts": "teksty",
    "bitbybit.text.regexTest": "test regex",
    "regexTest": "test regex",
    "bitbybit.text.regexTest_description": "Testuje, czy tekst pasuje do wzorca wyrażenia regularnego. Przykład: tekst='witaj123', wzorzec='[0-9]+' → true",
    "regex": "regex",
    "flags": "flagi",
    "bitbybit.text.regexMatch": "dopasowanie regex",
    "regexMatch": "dopasowanie regex",
    "bitbybit.text.regexMatch_description": "Dopasowuje tekst do wyrażenia regularnego i zwraca dopasowania. Przykład: tekst='witaj123swiecie456', wzorzec='[0-9]+', flagi='g' → ['123', '456']",
    "bitbybit.text.regexReplace": "zamiana regex",
    "regexReplace": "zamiana regex",
    "bitbybit.text.regexReplace_description": "Zamienia tekst pasujący do wzorca wyrażenia regularnego. Przykład: tekst='witaj123swiecie456', wzorzec='[0-9]+', flagi='g', zamienNa='X' → 'witajXswiecieX'",
    "bitbybit.text.regexSearch": "wyszukiwanie regex",
    "regexSearch": "wyszukiwanie regex",
    "bitbybit.text.regexSearch_description": "Przeszukuje tekst pod kątem wzorca wyrażenia regularnego i zwraca indeks. Przykład: tekst='witaj123', wzorzec='[0-9]+' → 5",
    "bitbybit.text.regexSplit": "podział regex",
    "regexSplit": "podział regex",
    "bitbybit.text.regexSplit_description": "Dzieli tekst używając wzorca wyrażenia regularnego. Przykład: tekst='a1b2c3', wzorzec='[0-9]+' → ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "parsuj do tablicy",
    "csv": "csv",
    "parseToArray": "parsuj do tablicy",
    "bitbybit.csv.parseToArray_description": "Parsuje tekst CSV na tablicę 2D ciągów znaków (wiersze i kolumny). Przykład: csv='a,b,c\n1,2,3' → [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "separator wierszy",
    "columnSeparator": "separator kolumn",
    "bitbybit.csv.parseToJson": "parsuj do json",
    "parseToJson": "parsuj do json",
    "bitbybit.csv.parseToJson_description": "Parsuje tekst CSV na tablicę obiektów JSON używając nagłówków. Przykład: csv='name,age\nJohn,30\nJane,25', headerRow=0, dataStartRow=1 → [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headerRow": "wiersz nagłówka",
    "dataStartRow": "wiersz startu danych",
    "numberColumns": "kolumny liczbowe",
    "bitbybit.csv.parseToJsonWithHeaders": "parsuj do json z nagłówkami",
    "parseToJsonWithHeaders": "parsuj do json z nagłówkami",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Parsuje tekst CSV na JSON używając niestandardowych nagłówków (ignoruje nagłówki CSV jeśli obecne). Przykład: csv='John,30\nJane,25', headers=['name','age'] → [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headers": "nagłówki",
    "bitbybit.csv.queryColumn": "zapytanie o kolumnę",
    "queryColumn": "zapytanie o kolumnę",
    "bitbybit.csv.queryColumn_description": "Odpytuje dane CSV według nazwy nagłówka kolumny i zwraca wszystkie wartości w tej kolumnie. Przykład: csv='name,age\nJohn,30\nJane,25', column='name' → ['John', 'Jane']",
    "column": "kolumna",
    "asNumber": "jako liczba",
    "bitbybit.csv.queryRowsByValue": "zapytanie o wiersze po wartości",
    "queryRowsByValue": "zapytanie o wiersze po wartości",
    "bitbybit.csv.queryRowsByValue_description": "Odpytuje dane CSV i filtruje wiersze gdzie kolumna pasuje do wartości. Przykład: csv='name,age\nJohn,30\nJane,25', column='age', value='30' → [{'name':'John','age':'30'}]",
    "bitbybit.csv.arrayToCsv": "tablica do csv",
    "arrayToCsv": "tablica do csv",
    "bitbybit.csv.arrayToCsv_description": "Konwertuje tablicę 2D na tekst CSV. Przykład: array=[['name','age'], ['John','30']] → 'name,age\nJohn,30'",
    "array": "tablica",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "json do csv",
    "jsonToCsv": "json do csv",
    "bitbybit.csv.jsonToCsv_description": "Konwertuje tablicę obiektów JSON na tekst CSV. Przykład: json=[{'name':'John','age':'30'}], headers=['name','age'] → 'name,age\nJohn,30'",
    "includeHeaders": "uwzględnij nagłówki",
    "bitbybit.csv.jsonToCsvAuto": "json do csv auto",
    "jsonToCsvAuto": "json do csv auto",
    "bitbybit.csv.jsonToCsvAuto_description": "Konwertuje tablicę obiektów JSON na tekst CSV używając kluczy obiektów jako nagłówków. Przykład: json=[{'name':'John','age':'30'}] → 'name,age\nJohn,30'",
    "bitbybit.csv.getHeaders": "pobierz nagłówki",
    "getHeaders": "pobierz nagłówki",
    "bitbybit.csv.getHeaders_description": "Pobiera nagłówki z pliku CSV. Przykład: csv='name,age\nJohn,30', headerRow=0 → ['name', 'age']",
    "bitbybit.csv.getRowCount": "pobierz liczbę wierszy",
    "getRowCount": "pobierz liczbę wierszy",
    "bitbybit.csv.getRowCount_description": "Pobiera liczbę wierszy w pliku CSV (z wyłączeniem nagłówków jeśli określono). Przykład: csv='name,age\nJohn,30\nJane,25', headerRow=0 → 2",
    "hasHeaders": "ma nagłówki",
    "bitbybit.csv.getColumnCount": "pobierz liczbę kolumn",
    "getColumnCount": "pobierz liczbę kolumn",
    "bitbybit.csv.getColumnCount_description": "Pobiera liczbę kolumn w pliku CSV. Przykład: csv='name,age,city\nJohn,30,NYC' → 3",
    "removeTrailingZeros": "usuń końcowe zera",
    "bitbybit.asset.getTextFile": "pobierz plik tekstowy",
    "getTextFile": "pobierz plik tekstowy",
    "bitbybit.asset.getTextFile_description": "Pobiera tekst z pliku zasobu dostępnego pod podanym cloud account.",
    "bitbybit.asset.getLocalTextFile": "pobierz lokalny plik tekstowy",
    "getLocalTextFile": "pobierz lokalny plik tekstowy",
    "bitbybit.asset.getLocalTextFile_description": "Pobiera tekst z pliku zasobu przechowywanego w Twojej przeglądarce.",
    "bitbybit.asset.download": "pobierz",
    "bitbybit.asset.download_description": "Pobiera plik z podanym zawartością, rozszerzeniem i typem zawartości.",
    "content": "zawartość",
    "string | Blob": "string | Blob",
    "extension": "rozszerzenie",
    "contentType": "typ zawartości",
    "preview csv": "podgląd csv",
    "startRow": "start wiersza",
    "maxRows": "maksymalna liczba wierszy",
    "colorMapStrategy": "strategia mapy kolorów",
    "Base.colorMapStrategyEnum": "Base.colorMapStrategyEnum",
    "drawTwoSided": "rysuj dwustronne",
    "backFaceColour": "kolor tylnej ściany",
    "backFaceOpacity": "przezroczystość tylnej ściany",
    "edgeArrowSize": "rozmiar strzałki krawędzi",
    "edgeArrowAngle": "kąt strzałki krawędzi",
    "bitbybit.draw.createTexture": "utwórz teksturę",
    "createTexture": "utwórz teksturę",
    "bitbybit.draw.createTexture_description": "Tworzy ogólną teksturę, która może być używana z materiałami PBR. Ta metoda zapewnia sposób kompatybilny między silnikami do tworzenia tekstur.",
    "bitbybit.draw.createPBRMaterial": "utwórz materiał pbr",
    "createPBRMaterial": "utwórz materiał pbr",
    "bitbybit.draw.createPBRMaterial_description": "Tworzy ogólny materiał PBR (renderowanie oparte na fizyce). Ta metoda zapewnia sposób kompatybilny między silnikami do tworzenia materiałów, które mogą być używane z opcjami rysowania dla kształtów OCCT i innej geometrii.",
    "emissiveIntensity": "intensywność emisji",
    "zOffsetUnits": "jednostki przesunięcia z",
    "baseColorTexture": "tekstura koloru bazowego",
    "Base.Texture": "Base.Texture",
    "metallicRoughnessTexture": "tekstura szorstkości metalicznej",
    "normalTexture": "tekstura normalna",
    "emissiveTexture": "tekstura emisyjna",
    "occlusionTexture": "tekstura okluzji",
    "alphaMode": "tryb alpha",
    "alphaModeEnum": "wyliczenie trybu alpha",
    "alphaCutoff": "odcięcie alpha",
    "doubleSided": "dwustronna",
    "wireframe": "szkielet",
    "unlit": "nieoświetlony",
    "bitbybit.babylon.mesh.setLocalScale": "ustaw lokalną skalę",
    "setLocalScale": "ustaw lokalną skalę",
    "bitbybit.babylon.mesh.setLocalScale_description": "Skaluje siatkę BabylonJS lub siatkę instancji w miejscu o podany współczynnik",
    "transparencyShadow": "cień przezroczystości",
    "bitbybit.manifold.crossSection.crossSectionFromPoints": "przekrój z punktów",
    "crossSectionFromPoints": "przekrój z punktów",
    "bitbybit.manifold.crossSection.crossSectionFromPoints_description": "Tworzy przekrój z punktów pojedynczego wielokąta",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons": "przekrój z wielokątów",
    "crossSectionFromPolygons": "przekrój z wielokątów",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons_description": "Tworzy przekrój z punktów wielu wielokątów",
    "bitbybit.manifold.crossSection.crossSectionToPoints": "przekrój do punktów",
    "crossSectionToPoints": "przekrój do punktów",
    "bitbybit.manifold.crossSection.crossSectionToPoints_description": "Wyodrębnia punkty z przekroju",
    "bitbybit.manifold.crossSection.crossSectionsToPoints": "przekroje do punktów",
    "crossSectionsToPoints": "przekroje do punktów",
    "bitbybit.manifold.crossSection.crossSectionsToPoints_description": "Wyodrębnia punkty z przekrojów",
    "bitbybit.previewCSV": "podgląd csv",
    "bitbybit.occt.shapes.wire.createHelixWire": "utwórz drut spiralny",
    "createHelixWire": "utwórz drut spiralny",
    "bitbybit.occt.shapes.wire.createHelixWire_description": "Tworzy drut spiralny 3D",
    "bitbybit.occt.shapes.wire.createHelixWireByTurns": "utwórz drut spiralny według obrotów",
    "createHelixWireByTurns": "utwórz drut spiralny według obrotów",
    "bitbybit.occt.shapes.wire.createHelixWireByTurns_description": "Tworzy drut spiralny 3D określając liczbę obrotów",
    "numTurns": "liczba obrotów",
    "bitbybit.occt.shapes.wire.createTaperedHelixWire": "utwórz stożkowy drut spiralny",
    "createTaperedHelixWire": "utwórz stożkowy drut spiralny",
    "bitbybit.occt.shapes.wire.createTaperedHelixWire_description": "Tworzy stożkowy (zwężający się) drut spiralny o zmiennym promieniu",
    "bitbybit.occt.shapes.wire.createFlatSpiralWire": "utwórz płaski drut spiralny",
    "createFlatSpiralWire": "utwórz płaski drut spiralny",
    "bitbybit.occt.shapes.wire.createFlatSpiralWire_description": "Tworzy płaski (archimedesowy) drut spiralny leżący w płaszczyźnie",
    "bitbybit.occt.shapes.solid.createTorus": "utwórz torus",
    "bitbybit.occt.shapes.solid.createTorus_description": "Tworzy torus OpenCascade",
    "majorRadius": "promień główny",
    "minorRadius": "promień mniejszy",
    "bitbybit.babylon.io.loadGlbFromArrayBuffer": "załaduj glb z bufora tablicy",
    "loadGlbFromArrayBuffer": "załaduj glb z bufora tablicy",
    "bitbybit.babylon.io.loadGlbFromArrayBuffer_description": "Ładuje dane binarne GLB bezpośrednio do sceny z Uint8Array. Przydatne, gdy masz dane GLB ze źródeł takich jak metoda convertStepToGltf OCCT.",
    "glbData": "dane glb",
    "Uint8Array": "Uint8Array",
    "bitbybit.babylon.io.loadGlbFromArrayBufferNoReturn": "załaduj glb z bufora tablicy bez zwracania",
    "loadGlbFromArrayBufferNoReturn": "załaduj glb z bufora tablicy bez zwracania",
    "bitbybit.babylon.io.loadGlbFromArrayBufferNoReturn_description": "Ładuje dane binarne GLB bezpośrednio do sceny z Uint8Array bez zwracania siatki. Przydatne, gdy masz dane GLB ze źródeł takich jak metoda convertStepToGltf OCCT.",
    "bitbybit.occt.assembly.manager.createPart": "utwórz część",
    "assembly": "zespół",
    "createPart": "utwórz część",
    "bitbybit.occt.assembly.manager.createPart_description": "Tworzy definicję części do użycia w strukturach zespołów. Jest to narzędzie do programowania wizualnego - po prostu opakowuje dane wejściowe w obiekt części.",
    "colorRgba": "kolor rgba",
    "Base.ColorRGBA": "Base.ColorRGBA",
    "bitbybit.occt.assembly.manager.createAssemblyNode": "utwórz węzeł zespołu",
    "createAssemblyNode": "utwórz węzeł zespołu",
    "bitbybit.occt.assembly.manager.createAssemblyNode_description": "Tworzy definicję węzła zespołu (kontener dla innych węzłów). Węzły zespołu grupują instancje i inne zespoły w hierarchii.",
    "parentId": "id rodzica",
    "bitbybit.occt.assembly.manager.createInstanceNode": "utwórz węzeł instancji",
    "createInstanceNode": "utwórz węzeł instancji",
    "bitbybit.occt.assembly.manager.createInstanceNode_description": "Tworzy definicję węzła instancji (odniesienie do części z transformacją). Węzły instancji umieszczają część w określonej lokalizacji z opcjonalnym przesunięciem, obrotem i skalą.",
    "partId": "id części",
    "bitbybit.occt.assembly.manager.createPartUpdate": "utwórz aktualizację części",
    "createPartUpdate": "utwórz aktualizację części",
    "bitbybit.occt.assembly.manager.createPartUpdate_description": "Tworzy definicję aktualizacji części do modyfikacji istniejącej części w dokumencie. Aktualizacje części mogą zmienić kształt, nazwę i/lub kolor istniejącej części.",
    "bitbybit.occt.assembly.manager.combineStructure": "połącz strukturę",
    "combineStructure": "połącz strukturę",
    "bitbybit.occt.assembly.manager.combineStructure_description": "Łączy części i węzły w pełną definicję struktury zespołu. Jest to ostatni krok przed wywołaniem buildAssemblyDocument.",
    "parts": "części",
    "Models.OCCT.AssemblyPartDef<T>[]": "Models.OCCT.AssemblyPartDef<T>[]",
    "Models.OCCT.AssemblyNodeDef[]": "Models.OCCT.AssemblyNodeDef[]",
    "removals": "usunięcia",
    "partUpdates": "aktualizacje części",
    "Models.OCCT.AssemblyPartUpdateDef<T>[]": "Models.OCCT.AssemblyPartUpdateDef<T>[]",
    "clearDocument": "wyczyść dokument",
    "bitbybit.occt.assembly.manager.buildAssemblyDocument": "zbuduj dokument zespołu",
    "buildAssemblyDocument": "zbuduj dokument zespołu",
    "bitbybit.occt.assembly.manager.buildAssemblyDocument_description": "Buduje dokument zespołu z definicji struktury. Zwraca uchwyt dokumentu bezpośrednio - dokument pozostaje w pamięci workera.",
    "structure": "struktura",
    "Models.OCCT.AssemblyStructureDef<T>": "Models.OCCT.AssemblyStructureDef<T>",
    "existingDocument": "istniejący dokument",
    "D": "D",
    "bitbybit.occt.assembly.manager.loadStepToDoc": "załaduj step do dokumentu",
    "loadStepToDoc": "załaduj step do dokumentu",
    "bitbybit.occt.assembly.manager.loadStepToDoc_description": "Ładuje plik STEP do nowego dokumentu zespołu. Obsługuje zarówno standardowy STEP, jak i skompresowany gzip STEP-Z.",
    "stepData": "dane step",
    "string | ArrayBuffer | Uint8Array | File | Blob": "string | ArrayBuffer | Uint8Array | File | Blob",
    "bitbybit.occt.assembly.manager.setDocLabelColor": "ustaw kolor etykiety dokumentu",
    "setDocLabelColor": "ustaw kolor etykiety dokumentu",
    "bitbybit.occt.assembly.manager.setDocLabelColor_description": "Ustawia kolor etykiety w dokumencie. Kolory są zachowywane podczas eksportu do STEP i innych formatów.",
    "modify": "modyfikuj",
    "document": "dokument",
    "a": "a",
    "bitbybit.occt.assembly.manager.setDocLabelName": "ustaw nazwę etykiety dokumentu",
    "setDocLabelName": "ustaw nazwę etykiety dokumentu",
    "bitbybit.occt.assembly.manager.setDocLabelName_description": "Ustawia lub zmienia nazwę etykiety (części, instancji lub zespołu).",
    "bitbybit.occt.assembly.manager.exportDocumentToStep": "eksportuj dokument do step",
    "exportDocumentToStep": "eksportuj dokument do step",
    "bitbybit.occt.assembly.manager.exportDocumentToStep_description": "Eksportuje dokument zespołu do formatu STEP.",
    "author": "autor",
    "organization": "organizacja",
    "compress": "kompresuj",
    "bitbybit.occt.assembly.manager.exportDocumentToGltf": "eksportuj dokument do gltf",
    "exportDocumentToGltf": "eksportuj dokument do gltf",
    "bitbybit.occt.assembly.manager.exportDocumentToGltf_description": "Eksportuje dokument zespołu do formatu binarnego glTF (GLB).",
    "meshDeflection": "odchylenie siatki",
    "meshAngle": "kąt siatki",
    "mergeFaces": "połącz ściany",
    "forceUVExport": "wymuś eksport UV",
    "bitbybit.occt.assembly.manager.deleteDocument": "usuń dokument",
    "deleteDocument": "usuń dokument",
    "bitbybit.occt.assembly.manager.deleteDocument_description": "Usuwa dokument zespołu i zwalnia jego pamięć. Wywołaj to, gdy skończysz z dokumentem, aby zwolnić zasoby.",
    "lifecycle": "cykl życia",
    "bitbybit.occt.assembly.query.getDocumentParts": "pobierz części dokumentu",
    "getDocumentParts": "pobierz części dokumentu",
    "bitbybit.occt.assembly.query.getDocumentParts_description": "Pobiera wszystkie części i zespoły w dokumencie.",
    "bitbybit.occt.assembly.query.getShapeFromLabel": "pobierz kształt z etykiety",
    "getShapeFromLabel": "pobierz kształt z etykiety",
    "bitbybit.occt.assembly.query.getShapeFromLabel_description": "Pobiera kształt z etykiety w dokumencie zespołu.",
    "bitbybit.occt.assembly.query.getLabelColor": "pobierz kolor etykiety",
    "getLabelColor": "pobierz kolor etykiety",
    "bitbybit.occt.assembly.query.getLabelColor_description": "Pobiera kolor etykiety.",
    "bitbybit.occt.assembly.query.getLabelTransform": "pobierz transformację etykiety",
    "getLabelTransform": "pobierz transformację etykiety",
    "bitbybit.occt.assembly.query.getLabelTransform_description": "Pobiera transformację etykiety instancji.",
    "bitbybit.occt.assembly.query.getLabelInfo": "pobierz informacje o etykiecie",
    "getLabelInfo": "pobierz informacje o etykiecie",
    "bitbybit.occt.assembly.query.getLabelInfo_description": "Pobiera szczegółowe informacje o etykiecie.",
    "bitbybit.occt.assembly.query.getAssemblyHierarchy": "pobierz hierarchię zespołu",
    "getAssemblyHierarchy": "pobierz hierarchię zespołu",
    "bitbybit.occt.assembly.query.getAssemblyHierarchy_description": "Pobiera pełną hierarchię zespołu jako dane strukturalne.",
    "bitbybit.occt.io.convertStepToGltf": "konwertuj step na gltf",
    "convertStepToGltf": "konwertuj step na gltf",
    "bitbybit.occt.io.convertStepToGltf_description": "Konwertuje plik STEP na glTF (binarny GLB). Używa natywnego RWGltf_CafWriter OCCT do szybkiej konwersji.",
    "meshPrecision": "precyzja siatki",
    "bitbybit.occt.io.convertStepToGltfAdvanced": "konwertuj step na gltf zaawansowany",
    "convertStepToGltfAdvanced": "konwertuj step na gltf zaawansowany",
    "bitbybit.occt.io.convertStepToGltfAdvanced_description": "Konwertuje plik STEP na glTF z pełną kontrolą nad wszystkimi ustawieniami.",
    "readColors": "czytaj kolory",
    "readNames": "czytaj nazwy",
    "readMaterials": "czytaj materiały",
    "readLayers": "czytaj warstwy",
    "readProps": "czytaj właściwości",
    "meshParallel": "równoległa siatka",
    "faceCountThreshold": "próg liczby ścian",
    "splitIndices16": "podziel indeksy 16",
    "parallelWrite": "równoległy zapis",
    "embedTextures": "osadź tekstury",
    "nodeNameFormat": "format nazwy węzła",
    "gltfNameFormatEnum": "enum formatu nazwy gltf",
    "meshNameFormat": "format nazwy siatki",
    "transformFormat": "format transformacji",
    "gltfTransformFormatEnum": "enum formatu transformacji gltf",
    "bitbybit.occt.io.parseStepToJson": "parsuj step do json",
    "parseStepToJson": "parsuj step do json",
    "bitbybit.occt.io.parseStepToJson_description": "Parsuje plik STEP i zwraca strukturę zespołu jako JSON.",
    "bitbybit.color.rgb255Color": "kolor rgb 255",
    "rgb255Color": "kolor rgb 255",
    "bitbybit.color.rgb255Color_description": "Tworzy i zwraca obiekt koloru rgb",
    "colorRgb": "kolor rgb",
    "bitbybit.color.rgb1Color": "kolor rgb 1",
    "rgb1Color": "kolor rgb 1",
    "bitbybit.color.rgb1Color_description": "Tworzy i zwraca obiekt koloru rgb",
    "bitbybit.color.rgba255Color": "kolor rgba 255",
    "rgba255Color": "kolor rgba 255",
    "bitbybit.color.rgba255Color_description": "Tworzy i zwraca obiekt koloru rgba",
    "bitbybit.color.rgba1Color": "kolor rgba 1",
    "rgba1Color": "kolor rgba 1",
    "bitbybit.color.rgba1Color_description": "Tworzy i zwraca obiekt koloru rgba",
    "bitbybit.color.rgbAtomic255Color": "kolor rgb atomowy 255",
    "rgbAtomic255Color": "kolor rgb atomowy 255",
    "bitbybit.color.rgbAtomic255Color_description": "Tworzy atomowy obiekt koloru rgb",
    "bitbybit.color.rgbAtomic1Color": "kolor rgb atomowy 1",
    "rgbAtomic1Color": "kolor rgb atomowy 1",
    "bitbybit.color.rgbAtomic1Color_description": "Tworzy atomowy obiekt koloru rgb",
    "bitbybit.asset.toArrayBuffer": "do bufora tablicy",
    "toArrayBuffer": "do bufora tablicy",
    "bitbybit.asset.toArrayBuffer_description": "Konwertuje plik lub Blob na ArrayBuffer.",
    "bitbybit.asset.toUint8Array": "do uint8 array",
    "toUint8Array": "do uint8 array",
    "bitbybit.asset.toUint8Array_description": "Konwertuje plik lub Blob na Uint8Array.",
    "bitbybit.asset.blobToFile": "blob do pliku",
    "blobToFile": "blob do pliku",
    "bitbybit.asset.blobToFile_description": "Konwertuje Blob na plik.",
    "blob": "blob",
    "Blob": "Blob",
    "bitbybit.asset.fileToBlob": "plik do blob",
    "fileToBlob": "plik do blob",
    "bitbybit.asset.fileToBlob_description": "Konwertuje plik na Blob.",
    "bitbybit.asset.arrayBufferToUint8Array": "bufor tablicy do uint8 array",
    "arrayBufferToUint8Array": "bufor tablicy do uint8 array",
    "bitbybit.asset.arrayBufferToUint8Array_description": "Konwertuje ArrayBuffer na Uint8Array.",
    "arrayBuffer": "bufor tablicy",
    "ArrayBuffer": "ArrayBuffer",
    "bitbybit.asset.uint8ArrayToArrayBuffer": "uint8 array do bufora tablicy",
    "uint8ArrayToArrayBuffer": "uint8 array do bufora tablicy",
    "bitbybit.asset.uint8ArrayToArrayBuffer_description": "Konwertuje Uint8Array na ArrayBuffer.",
    "uint8Array": "uint8 array",
    "preview assembly hierarchy": "podgląd hierarchii zespołu occt"
}