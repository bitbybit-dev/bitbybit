{
    "bitbybit.draw.drawAnyAsyncNoReturn": "dessiner tout async sans retour",
    "bitbybit": "bitbybit",
    "draw": "dessiner",
    "drawAnyAsyncNoReturn": "dessiner tout async sans retour",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Dessine tout type de géométrie et ne renvoie rien",
    "draw async": "dessiner async",
    "entity": "entité",
    "Entity": "entité",
    "options": "options",
    "DrawOptions": "options de dessin",
    "babylonMesh": "maillage babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "maillage babylon ou maillage de lignes babylon",
    "bitbybit.draw.drawAnyAsync": "dessiner tout async",
    "drawAnyAsync": "dessiner tout async",
    "bitbybit.draw.drawAnyAsync_description": "Dessine tout type de géométrie et renvoie le maillage babylon",
    "bitbybit.draw.drawAnyNoReturn": "dessiner tout sans retour",
    "drawAnyNoReturn": "dessiner tout sans retour",
    "bitbybit.draw.drawAnyNoReturn_description": "Dessine tout type de géométrie qui ne nécessite pas de calcul asynchrone, donc ne peut pas être utilisée avec des formes provenant d'occt ou de jscad",
    "draw sync": "dessiner sync",
    "bitbybit.draw.drawAny": "dessiner tout",
    "drawAny": "dessiner tout",
    "bitbybit.draw.drawAny_description": "Dessine tout type de géométrie qui ne nécessite pas de calcul asynchrone, donc ne peut pas être utilisée avec des formes provenant d'occt ou de jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "dessiner grille maillée sans retour",
    "drawGridMeshNoReturn": "dessiner grille maillée sans retour",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Dessine un maillage de grille sur le plan du sol dans l'espace 3D. Cela aide à s'orienter dans le monde.",
    "grid": "grille",
    "width": "largeur",
    "number": "nombre",
    "height": "hauteur",
    "subdivisions": "subdivisions",
    "majorUnitFrequency": "fréquence unité majeure",
    "minorUnitVisibility": "visibilité unité mineure",
    "gridRatio": "ratio grille",
    "opacity": "opacité",
    "backFaceCulling": "élimination faces arrière",
    "boolean": "booléen",
    "mainColor": "couleur principale",
    "Base.Color": "couleur de base",
    "secondaryColor": "couleur secondaire",
    "bitbybit.draw.drawGridMesh": "dessiner grille maillée",
    "drawGridMesh": "dessiner grille maillée",
    "bitbybit.draw.drawGridMesh_description": "Dessine un maillage de grille sur le plan du sol dans l'espace 3D. Cela aide à s'orienter dans le monde.",
    "bitbybit.draw.optionsSimple": "options simples",
    "optionsSimple": "options simples",
    "bitbybit.draw.optionsSimple_description": "Crée des options de dessin pour des types de géométrie de base comme des points, des lignes, des polylignes, des surfaces et des maillages jscad",
    "colours": "couleurs",
    "string | string[]": "chaîne ou tableau de chaînes",
    "size": "taille",
    "updatable": "actualisable",
    "hidden": "caché",
    "bitbybit.draw.optionsOcctShape": "options forme occt",
    "optionsOcctShape": "options forme occt",
    "bitbybit.draw.optionsOcctShape_description": "Crée des options de dessin pour la géométrie de forme occt comme les arêtes, les fils, les faces, les coques, les solides et les composés",
    "faceOpacity": "opacité face",
    "edgeOpacity": "opacité arête",
    "edgeColour": "couleur arête",
    "faceColour": "couleur face",
    "vertexColour": "couleur sommet",
    "faceMaterial": "matériau face",
    "Base.Material": "matériau de base",
    "edgeWidth": "largeur arête",
    "vertexSize": "taille sommet",
    "drawEdges": "dessiner arêtes",
    "drawFaces": "dessiner faces",
    "drawVertices": "dessiner sommets",
    "precision": "précision",
    "drawEdgeIndexes": "dessiner indices arête",
    "edgeIndexHeight": "hauteur indice arête",
    "edgeIndexColour": "couleur indice arête",
    "drawFaceIndexes": "dessiner indices face",
    "faceIndexHeight": "hauteur indice face",
    "faceIndexColour": "couleur indice face",
    "bitbybit.draw.optionsOcctShapeSimple": "options forme occt simple",
    "optionsOcctShapeSimple": "options forme occt simple",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Crée des options de dessin simples pour la géométrie de forme occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "options forme occt matériau",
    "optionsOcctShapeMaterial": "options forme occt matériau",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Crée des options de dessin simples avec un matériau de face personnalisé pour la géométrie de forme occt",
    "any": "tout",
    "bitbybit.draw.optionsManifoldShapeMaterial": "options matériau forme manifold",
    "optionsManifoldShapeMaterial": "options matériau forme manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Crée des options de dessin pour la géométrie manifold",
    "crossSectionColour": "couleur section transversale",
    "crossSectionWidth": "largeur section transversale",
    "crossSectionOpacity": "opacité section transversale",
    "computeNormals": "calculer normales",
    "bitbybit.draw.optionsBabylonNode": "options noeud babylon",
    "optionsBabylonNode": "options noeud babylon",
    "bitbybit.draw.optionsBabylonNode_description": "Crée des options de dessin pour les nœuds babylon js",
    "colorX": "couleur x",
    "colorY": "couleur y",
    "colorZ": "couleur z",
    "bitbybit.babylon.mesh.dispose": "détruire maillage",
    "babylon": "babylon",
    "mesh": "maillage",
    "dispose": "détruire",
    "bitbybit.babylon.mesh.dispose_description": "Supprime l'objet maillage dessiné de la scène",
    "memory": "mémoire",
    "BABYLON.Mesh": "maillage babylon",
    "bitbybit.babylon.mesh.updateDrawn": "mettre à jour dessiné",
    "updateDrawn": "mettre à jour dessiné",
    "bitbybit.babylon.mesh.updateDrawn_description": "Met à jour l'objet maillage BabylonJS dessiné sans le supprimer",
    "updates": "mises à jour",
    "position": "position",
    "Base.Point3": "point de base 3",
    "rotation": "rotation",
    "Base.Vector3": "vecteur de base 3",
    "scaling": "mise à l'échelle",
    "bitbybit.babylon.mesh.setVisibility": "définir visibilité",
    "setVisibility": "définir visibilité",
    "bitbybit.babylon.mesh.setVisibility_description": "Change la visibilité d'un maillage BabylonJS dessiné",
    "visibility": "visibilité",
    "includeChildren": "inclure enfants",
    "bitbybit.babylon.mesh.hide": "cacher",
    "hide": "cacher",
    "bitbybit.babylon.mesh.hide_description": "cache le maillage",
    "bitbybit.babylon.mesh.show": "montrer",
    "show": "montrer",
    "bitbybit.babylon.mesh.show_description": "Affiche le maillage",
    "bitbybit.babylon.mesh.setParent": "définir parent",
    "setParent": "définir parent",
    "bitbybit.babylon.mesh.setParent_description": "Change le parent du maillage dessiné",
    "set": "définir",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "maillage babylon ou maillage instancié ou maillage abstrait",
    "parentMesh": "maillage parent",
    "bitbybit.babylon.mesh.getParent": "obtenir parent",
    "getParent": "obtenir parent",
    "bitbybit.babylon.mesh.getParent_description": "Obtient le parent du maillage dessiné",
    "get": "obtenir",
    "bitbybit.babylon.mesh.setCheckCollisions": "définir vérif collisions",
    "setCheckCollisions": "définir vérif collisions",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Change la propriété de vérification des collisions du maillage dessiné",
    "checkCollisions": "vérifier collisions",
    "bitbybit.babylon.mesh.getCheckCollisions": "obtenir vérif collisions",
    "getCheckCollisions": "obtenir vérif collisions",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Obtient la propriété de vérification des collisions du maillage dessiné",
    "bitbybit.babylon.mesh.setPickable": "définir sélectionnable",
    "setPickable": "définir sélectionnable",
    "bitbybit.babylon.mesh.setPickable_description": "Change la propriété de sélection du maillage dessiné",
    "pickable": "sélectionnable",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "activer événements mouvement pointeur",
    "enablePointerMoveEvents": "activer événements mouvement pointeur",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Force le maillage à être sélectionnable par les événements de déplacement du pointeur, la valeur par défaut est false car cela consomme beaucoup de ressources",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "désactiver événements mouvement pointeur",
    "disablePointerMoveEvents": "désactiver événements mouvement pointeur",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Rend le maillage insensible aux événements de déplacement du pointeur, la valeur par défaut est false",
    "bitbybit.babylon.mesh.getPickable": "obtenir sélectionnable",
    "getPickable": "obtenir sélectionnable",
    "bitbybit.babylon.mesh.getPickable_description": "Change la propriété de sélection du maillage dessiné",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "obtenir maillages où nom contient",
    "getMeshesWhereNameContains": "obtenir maillages où nom contient",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Obtient les maillages dont les noms contiennent un texte donné",
    "name": "nom",
    "string": "chaîne",
    "bitbybit.babylon.mesh.getChildMeshes": "obtenir maillages enfants",
    "getChildMeshes": "obtenir maillages enfants",
    "bitbybit.babylon.mesh.getChildMeshes_description": "obtient les maillages enfants",
    "directDescendantsOnly": "descendants directs seulement",
    "bitbybit.babylon.mesh.getMeshesOfId": "obtenir maillages par id",
    "getMeshesOfId": "obtenir maillages par id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Obtient les maillages avec l'identifiant",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "obtenir maillage par id",
    "getMeshOfId": "obtenir maillage par id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Obtient le maillage avec l'identifiant",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "obtenir maillage par id unique",
    "getMeshOfUniqueId": "obtenir maillage par id unique",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Obtient le maillage avec l'identifiant unique",
    "uniqueId": "id unique",
    "bitbybit.babylon.mesh.mergeMeshes": "fusionner maillages",
    "mergeMeshes": "fusionner maillages",
    "bitbybit.babylon.mesh.mergeMeshes_description": "fusionne plusieurs maillages en un seul",
    "edit": "modifier",
    "arrayOfMeshes": "tableau de maillages",
    "BABYLON.Mesh[]": "tableau de maillages babylon",
    "disposeSource": "détruire source",
    "allow32BitsIndices": "autoriser indices 32 bits",
    "meshSubclass": "sous-classe maillage",
    "subdivideWithSubMeshes": "subdiviser avec sous-maillages",
    "multiMultiMaterials": "matériaux multi multi",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "convertir en maillage ombré plat",
    "convertToFlatShadedMesh": "convertir en maillage ombré plat",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Convertit le maillage en maillage à ombrage plat",
    "bitbybit.babylon.mesh.clone": "cloner",
    "clone": "cloner",
    "bitbybit.babylon.mesh.clone_description": "clone le maillage",
    "bitbybit.babylon.mesh.cloneToPositions": "cloner aux positions",
    "cloneToPositions": "cloner aux positions",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Clone le maillage aux positions",
    "positions": "positions",
    "Base.Point3[]": "tableau de points de base 3",
    "bitbybit.babylon.mesh.setId": "définir id",
    "setId": "définir id",
    "bitbybit.babylon.mesh.setId_description": "Change l'identifiant du maillage dessiné",
    "bitbybit.babylon.mesh.getId": "obtenir id",
    "getId": "obtenir id",
    "bitbybit.babylon.mesh.getId_description": "Obtient l'identifiant du maillage dessiné",
    "bitbybit.babylon.mesh.getUniqueId": "obtenir id unique",
    "getUniqueId": "obtenir id unique",
    "bitbybit.babylon.mesh.getUniqueId_description": "Obtient l'identifiant unique du maillage dessiné",
    "bitbybit.babylon.mesh.setName": "définir nom",
    "setName": "définir nom",
    "bitbybit.babylon.mesh.setName_description": "Change le nom du maillage dessiné",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "obtenir sommets comme points polygone",
    "getVerticesAsPolygonPoints": "obtenir sommets comme points polygone",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Obtient les sommets sous forme de points de polygone. Ceux-ci peuvent être utilisés avec d'autres méthodes de construction pour créer des maillages. Le maillage doit être triangulé.",
    "bitbybit.babylon.mesh.getName": "obtenir nom",
    "getName": "obtenir nom",
    "bitbybit.babylon.mesh.getName_description": "Obtient le nom du maillage babylon",
    "bitbybit.babylon.mesh.setMaterial": "définir matériau",
    "setMaterial": "définir matériau",
    "bitbybit.babylon.mesh.setMaterial_description": "Change le matériau du maillage dessiné",
    "material": "matériau",
    "BABYLON.Material": "matériau babylon",
    "bitbybit.babylon.mesh.getMaterial": "obtenir matériau",
    "getMaterial": "obtenir matériau",
    "bitbybit.babylon.mesh.getMaterial_description": "Obtient le matériau du maillage babylon",
    "bitbybit.babylon.mesh.getPosition": "obtenir position",
    "getPosition": "obtenir position",
    "bitbybit.babylon.mesh.getPosition_description": "Obtient la position sous forme de point du maillage babylonjs",
    "bitbybit.babylon.mesh.getAbsolutePosition": "obtenir position absolue",
    "getAbsolutePosition": "obtenir position absolue",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Obtient la position absolue dans le monde sous forme de point du maillage babylonjs",
    "bitbybit.babylon.mesh.getRotation": "obtenir rotation",
    "getRotation": "obtenir rotation",
    "bitbybit.babylon.mesh.getRotation_description": "Obtient le vecteur de rotation du maillage babylonjs",
    "bitbybit.babylon.mesh.getScale": "obtenir échelle",
    "getScale": "obtenir échelle",
    "bitbybit.babylon.mesh.getScale_description": "Obtient le vecteur d'échelle du maillage babylonjs",
    "bitbybit.babylon.mesh.moveForward": "avancer",
    "moveForward": "avancer",
    "bitbybit.babylon.mesh.moveForward_description": "Déplace le maillage babylonjs vers l'avant dans l'espace local",
    "move": "déplacer",
    "distance": "distance",
    "bitbybit.babylon.mesh.moveBackward": "reculer",
    "moveBackward": "reculer",
    "bitbybit.babylon.mesh.moveBackward_description": "Déplace le maillage babylonjs vers l'arrière dans l'espace local",
    "bitbybit.babylon.mesh.moveUp": "monter",
    "moveUp": "monter",
    "bitbybit.babylon.mesh.moveUp_description": "Déplace le maillage babylonjs vers le haut dans l'espace local",
    "bitbybit.babylon.mesh.moveDown": "descendre",
    "moveDown": "descendre",
    "bitbybit.babylon.mesh.moveDown_description": "Déplace le maillage babylonjs vers le bas dans l'espace local",
    "bitbybit.babylon.mesh.moveRight": "aller à droite",
    "moveRight": "aller à droite",
    "bitbybit.babylon.mesh.moveRight_description": "Déplace le maillage babylonjs vers la droite dans l'espace local",
    "bitbybit.babylon.mesh.moveLeft": "aller à gauche",
    "moveLeft": "aller à gauche",
    "bitbybit.babylon.mesh.moveLeft_description": "Déplace le maillage babylonjs vers la gauche dans l'espace local",
    "bitbybit.babylon.mesh.yaw": "lacet",
    "yaw": "lacet",
    "bitbybit.babylon.mesh.yaw_description": "Fait pivoter le maillage babylonjs autour de l'axe y local",
    "rotate": "pivoter",
    "bitbybit.babylon.mesh.pitch": "tangage",
    "pitch": "tangage",
    "bitbybit.babylon.mesh.pitch_description": "Fait pivoter le maillage babylonjs autour de l'axe x local",
    "bitbybit.babylon.mesh.roll": "roulis",
    "roll": "roulis",
    "bitbybit.babylon.mesh.roll_description": "Fait pivoter le maillage babylonjs autour de l'axe z local",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "pivoter autour axe avec position",
    "rotateAroundAxisWithPosition": "pivoter autour axe avec position",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Fait pivoter le maillage autour d'un axe et d'une position donnée d'un angle donné",
    "axis": "axe",
    "angle": "angle",
    "bitbybit.babylon.mesh.setPosition": "définir position",
    "setPosition": "définir position",
    "bitbybit.babylon.mesh.setPosition_description": "Met à jour la position du maillage BabylonJS ou du maillage instancié",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "maillage babylon ou maillage instancié",
    "bitbybit.babylon.mesh.setRotation": "définir rotation",
    "setRotation": "définir rotation",
    "bitbybit.babylon.mesh.setRotation_description": "Met à jour la rotation du maillage BabylonJS ou du maillage instancié",
    "bitbybit.babylon.mesh.setScale": "définir échelle",
    "setScale": "définir échelle",
    "bitbybit.babylon.mesh.setScale_description": "Met à jour l'échelle du maillage BabylonJS ou du maillage instancié",
    "scale": "échelle",
    "bitbybit.babylon.mesh.intersectsMesh": "intersecte maillage",
    "intersectsMesh": "intersecte maillage",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Vérifie si le maillage coupe un autre maillage",
    "intersects": "intersecte",
    "babylonMesh2": "maillage babylon 2",
    "precise": "précis",
    "includeDescendants": "inclure descendants",
    "bitbybit.babylon.mesh.intersectsPoint": "intersecte point",
    "intersectsPoint": "intersecte point",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Vérifie si le maillage coupe un point",
    "point": "point",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instance maillage et transformer sans retour",
    "createMeshInstanceAndTransformNoReturn": "instance maillage et transformer sans retour",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Crée une instance de maillage pour un rendu optimisé. Cette méthode vérifiera si le maillage contient des enfants et créera des instances pour chaque enfant. Celles-ci sont optimisées pour des performances maximales lors du rendu de nombreux objets similaires dans la scène. Cette méthode renvoie les instances en tant qu'enfants dans un nouveau maillage. Si le maillage a des enfants, alors chaque enfant devient une instance de maillage.",
    "instance": "instance",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instance maillage et transformer",
    "createMeshInstanceAndTransform": "instance maillage et transformer",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Crée une instance de maillage pour un rendu optimisé. Cette méthode vérifiera si le maillage contient des enfants et créera des instances pour chaque enfant. Celles-ci sont optimisées pour des performances maximales lors du rendu de nombreux objets similaires dans la scène. Cette méthode renvoie les instances en tant qu'enfants dans un nouveau maillage. Si le maillage a des enfants, alors chaque enfant devient une instance de maillage.",
    "bitbybit.babylon.mesh.createMeshInstance": "instance maillage",
    "createMeshInstance": "instance maillage",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Crée une instance de maillage. Celles-ci sont optimisées pour des performances maximales lors du rendu de nombreux objets similaires dans la scène. Si le maillage a des enfants, alors chaque enfant obtient une instance de maillage.",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussien",
    "gaussianSplatting": "splatting gaussien",
    "create": "créer",
    "bitbybit.babylon.gaussianSplatting.create_description": "crée un maillage de splatting gaussien",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "cloner splatting gaussien",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clone le maillage de splatting gaussien",
    "multiply": "multiplier",
    "BABYLON.GaussianSplattingMesh": "maillage de splatting gaussien babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "obtenir positions splat",
    "getSplatPositions": "obtenir positions splat",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Obtient les positions des splats du maillage gaussian splat",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "figer matrice projection",
    "camera": "caméra",
    "freezeProjectionMatrix": "figer matrice projection",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Gèle la matrice de projection de la caméra",
    "adjust": "ajuster",
    "BABYLON.Camera": "caméra babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "défiger matrice projection",
    "unfreezeProjectionMatrix": "défiger matrice projection",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Dégèle la matrice de projection de la caméra",
    "bitbybit.babylon.camera.setPosition": "définir position",
    "bitbybit.babylon.camera.setPosition_description": "Change la position d'une caméra",
    "BABYLON.TargetCamera": "caméra cible babylon",
    "bitbybit.babylon.camera.getPosition": "obtenir position",
    "bitbybit.babylon.camera.getPosition_description": "Obtient la position d'une caméra",
    "bitbybit.babylon.camera.setTarget": "définir cible",
    "setTarget": "définir cible",
    "bitbybit.babylon.camera.setTarget_description": "Change la cible d'une caméra",
    "target": "cible",
    "bitbybit.babylon.camera.getTarget": "obtenir cible",
    "getTarget": "obtenir cible",
    "bitbybit.babylon.camera.getTarget_description": "Obtient la cible d'une caméra",
    "bitbybit.babylon.camera.setSpeed": "définir vitesse",
    "setSpeed": "définir vitesse",
    "bitbybit.babylon.camera.setSpeed_description": "Change la vitesse d'une caméra",
    "speed": "vitesse",
    "bitbybit.babylon.camera.getSpeed": "obtenir vitesse",
    "getSpeed": "obtenir vitesse",
    "bitbybit.babylon.camera.getSpeed_description": "Obtient la vitesse d'une caméra",
    "bitbybit.babylon.camera.setMinZ": "définir min z",
    "setMinZ": "définir min z",
    "bitbybit.babylon.camera.setMinZ_description": "Change le minZ d'une caméra",
    "minZ": "min z",
    "bitbybit.babylon.camera.setMaxZ": "définir max z",
    "setMaxZ": "définir max z",
    "bitbybit.babylon.camera.setMaxZ_description": "Change le maxZ d'une caméra",
    "maxZ": "max z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "rendre caméra orthographique",
    "makeCameraOrthographic": "rendre caméra orthographique",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Change le mode de la caméra en orthographique",
    "orthoLeft": "ortho gauche",
    "orthoRight": "ortho droite",
    "orthoBottom": "ortho bas",
    "orthoTop": "ortho haut",
    "bitbybit.babylon.camera.makeCameraPerspective": "rendre caméra perspective",
    "makeCameraPerspective": "rendre caméra perspective",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Change le mode d'une caméra en perspective",
    "bitbybit.babylon.camera.free.create": "caméra libre",
    "free": "libre",
    "bitbybit.babylon.camera.free.create_description": "Crée une caméra libre",
    "bitbybit.babylon.camera.arcRotate.create": "caméra arc rotation",
    "arcRotate": "arc rotation",
    "bitbybit.babylon.camera.arcRotate.create_description": "Crée une caméra qui tourne autour d'une cible donnée tout en parcourant le chemin de l'arc. Cette caméra convient à la navigation 3D simple et est une caméra par défaut utilisée par bitbybit.",
    "radius": "rayon",
    "alpha": "alpha",
    "beta": "bêta",
    "lowerRadiusLimit": "limite inférieure rayon",
    "upperRadiusLimit": "limite supérieure rayon",
    "lowerAlphaLimit": "limite inférieure alpha",
    "upperAlphaLimit": "limite supérieure alpha",
    "lowerBetaLimit": "limite inférieure bêta",
    "upperBetaLimit": "limite supérieure bêta",
    "angularSensibilityX": "sensibilité angulaire x",
    "angularSensibilityY": "sensibilité angulaire y",
    "panningSensibility": "sensibilité panoramique",
    "wheelPrecision": "précision molette",
    "bitbybit.babylon.camera.target.create": "caméra cible",
    "bitbybit.babylon.camera.target.create_description": "Crée une caméra cible",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "expérience ar immersive",
    "webXr": "web xr",
    "simple": "simple",
    "createImmersiveARExperience": "expérience ar immersive",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Crée une expérience XR par défaut en mode immersive-ar",
    "scene": "scène",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "expérience xr par défaut avec téléportation",
    "createDefaultXRExperienceWithTeleportation": "expérience xr par défaut avec téléportation",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Crée une expérience XR par défaut avec téléportation qui est très basique et fonctionne pour des scénarios simples",
    "groundMeshes": "maillages sol",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "expérience xr par défaut avec téléportation retour",
    "createDefaultXRExperienceWithTeleportationReturn": "expérience xr par défaut avec téléportation retour",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Crée une expérience XR par défaut avec téléportation qui est très basique et fonctionne pour des scénarios simples",
    "bitbybit.babylon.node.drawNode": "dessiner noeud",
    "node": "noeud",
    "drawNode": "dessiner noeud",
    "bitbybit.babylon.node.drawNode_description": "Dessine un nœud d'une taille donnée avec des couleurs données pour chaque axe",
    "BABYLON.TransformNode": "noeud de transformation babylon",
    "bitbybit.babylon.node.drawNodes": "dessiner noeuds",
    "drawNodes": "dessiner noeuds",
    "bitbybit.babylon.node.drawNodes_description": "Dessine des nœuds d'une taille donnée avec des couleurs données pour chaque axe",
    "nodes": "noeuds",
    "BABYLON.TransformNode[]": "tableau de noeuds de transformation babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "noeud depuis rotation",
    "createNodeFromRotation": "noeud depuis rotation",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Crée un nœud à l'origine avec les rotations données dans le système de coordonnées parent",
    "parent": "parent",
    "BABYLON.TransformNode | null": "noeud de transformation babylon ou null",
    "origin": "origine",
    "bitbybit.babylon.node.createWorldNode": "noeud monde",
    "createWorldNode": "noeud monde",
    "bitbybit.babylon.node.createWorldNode_description": "Crée un nœud monde qui a le nœud racine comme parent",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "obtenir vecteur avant absolu",
    "getAbsoluteForwardVector": "obtenir vecteur avant absolu",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Obtient le vecteur absolu orienté vers l'avant dans l'espace mondial",
    "bitbybit.babylon.node.getAbsoluteRightVector": "obtenir vecteur droite absolu",
    "getAbsoluteRightVector": "obtenir vecteur droite absolu",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Obtient le vecteur absolu orienté vers la droite dans l'espace mondial",
    "bitbybit.babylon.node.getAbsoluteUpVector": "obtenir vecteur haut absolu",
    "getAbsoluteUpVector": "obtenir vecteur haut absolu",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Obtient le vecteur absolu orienté vers le haut dans l'espace mondial",
    "bitbybit.babylon.node.getAbsolutePosition": "obtenir position absolue",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Obtient la position absolue du nœud en tant que vecteur d'origine dans l'espace mondial",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "obtenir transformation rotation absolue",
    "getAbsoluteRotationTransformation": "obtenir transformation rotation absolue",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Obtient la rotation absolue du nœud en tant que matrice de transformation codée dans un tableau de 16 nombres",
    "bitbybit.babylon.node.getRotationTransformation": "obtenir transformation rotation",
    "getRotationTransformation": "obtenir transformation rotation",
    "bitbybit.babylon.node.getRotationTransformation_description": "Obtient la rotation du nœud dans l'espace de coordonnées parent local en tant que matrice de transformation codée dans un tableau de 16 nombres",
    "bitbybit.babylon.node.getChildren": "obtenir enfants",
    "getChildren": "obtenir enfants",
    "bitbybit.babylon.node.getChildren_description": "Obtient les enfants du nœud",
    "bitbybit.babylon.node.getParent": "obtenir parent",
    "bitbybit.babylon.node.getParent_description": "Obtient le parent du nœud",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "obtenir position dans espace local",
    "getPositionExpressedInLocalSpace": "obtenir position dans espace local",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Obtient la position du nœud exprimée dans l'espace local",
    "bitbybit.babylon.node.getRootNode": "obtenir noeud racine",
    "getRootNode": "obtenir noeud racine",
    "bitbybit.babylon.node.getRootNode_description": "Obtient le nœud racine",
    "bitbybit.babylon.node.getRotation": "obtenir rotation",
    "bitbybit.babylon.node.getRotation_description": "Obtient les rotations d'Euler",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "pivoter autour axe avec position",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Fait pivoter le nœud autour d'un axe et d'une position donnée d'un angle donné",
    "bitbybit.babylon.node.rotate": "pivoter",
    "bitbybit.babylon.node.rotate_description": "Fait pivoter le nœud autour de l'origine et d'un axe donné",
    "bitbybit.babylon.node.setAbsolutePosition": "définir position absolue",
    "setAbsolutePosition": "définir position absolue",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Définit la position absolue du nœud",
    "bitbybit.babylon.node.setDirection": "définir direction",
    "setDirection": "définir direction",
    "bitbybit.babylon.node.setDirection_description": "Définit la direction du nœud",
    "direction": "direction",
    "number[]": "tableau de nombres",
    "bitbybit.babylon.node.setParent": "définir parent",
    "bitbybit.babylon.node.setParent_description": "Définit le nouveau parent du nœud",
    "parentNode": "noeud parent",
    "bitbybit.babylon.node.translate": "translater",
    "translate": "translater",
    "bitbybit.babylon.node.translate_description": "Translate le nœud par un vecteur de direction donné et une distance",
    "bitbybit.babylon.scene.backgroundColour": "couleur arrière-plan",
    "backgroundColour": "couleur arrière-plan",
    "bitbybit.babylon.scene.backgroundColour_description": "Change la couleur d'arrière-plan de la scène pour l'espace 3D",
    "environment": "environnement",
    "colour": "couleur",
    "bitbybit.babylon.scene.activateCamera": "activer caméra",
    "activateCamera": "activer caméra",
    "bitbybit.babylon.scene.activateCamera_description": "Active la caméra en écrasant la caméra actuellement active",
    "bitbybit.babylon.scene.useRightHandedSystem": "utiliser système droitier",
    "useRightHandedSystem": "utiliser système droitier",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Utilise le système main droite",
    "system": "système",
    "use": "utiliser",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "dessiner lumière ponctuelle sans retour",
    "drawPointLightNoReturn": "dessiner lumière ponctuelle sans retour",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Crée et dessine une lumière ponctuelle dans la scène mais ne renvoie rien",
    "lights": "lumières",
    "intensity": "intensité",
    "diffuse": "diffuse",
    "specular": "spéculaire",
    "shadowGeneratorMapSize": "taille carte générateur ombres",
    "enableShadows": "activer ombres",
    "shadowDarkness": "obscurité ombre",
    "shadowUsePercentageCloserFiltering": "ombre utiliser filtrage pourcentage rapproché",
    "shadowContactHardeningLightSizeUVRatio": "ombre durcissement contact taille lumière ratio uv",
    "shadowBias": "biais ombre",
    "shadowNormalBias": "biais normal ombre",
    "shadowMaxZ": "ombre max z",
    "shadowMinZ": "ombre min z",
    "bitbybit.babylon.scene.getShadowGenerators": "obtenir générateurs ombres",
    "getShadowGenerators": "obtenir générateurs ombres",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Obtient les générateurs d'ombres ajoutés par les sources lumineuses via bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "dessiner lumière ponctuelle",
    "drawPointLight": "dessiner lumière ponctuelle",
    "bitbybit.babylon.scene.drawPointLight_description": "Crée et dessine une lumière ponctuelle dans la scène",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "dessiner lumière directionnelle sans retour",
    "drawDirectionalLightNoReturn": "dessiner lumière directionnelle sans retour",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Crée et dessine une lumière directionnelle dans la scène",
    "bitbybit.babylon.scene.drawDirectionalLight": "dessiner lumière directionnelle",
    "drawDirectionalLight": "dessiner lumière directionnelle",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Crée et dessine une lumière directionnelle dans la scène",
    "bitbybit.babylon.scene.getActiveCamera": "obtenir caméra active",
    "getActiveCamera": "obtenir caméra active",
    "bitbybit.babylon.scene.getActiveCamera_description": "Obtient la caméra active de la scène",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "ajuster caméra arc rotation active",
    "adjustActiveArcRotateCamera": "ajuster caméra arc rotation active",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Ajuste la caméra arc rotate active avec des paramètres de configuration",
    "lookAt": "regarder vers",
    "bitbybit.babylon.scene.clearAllDrawn": "effacer tout dessiné",
    "clearAllDrawn": "effacer tout dessiné",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Efface tous les objets dessinés dans la scène 3D",
    "bitbybit.babylon.scene.enableSkybox": "activer skybox",
    "enableSkybox": "activer skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "Active la skybox",
    "skybox": "skybox",
    "Base.skyboxEnum": "énumération skybox de base",
    "blur": "flou",
    "environmentIntensity": "intensité environnement",
    "bitbybit.babylon.scene.fog": "brouillard",
    "fog": "brouillard",
    "bitbybit.babylon.scene.fog_description": "Active le mode brouillard",
    "mode": "mode",
    "Base.fogModeEnum": "énumération mode brouillard de base",
    "color": "couleur",
    "density": "densité",
    "start": "début",
    "end": "fin",
    "bitbybit.babylon.transforms.rotationCenterAxis": "rotation centre axe",
    "transforms": "transformations",
    "rotationCenterAxis": "rotation centre axe",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Crée une transformation de rotation autour du centre et d'un axe",
    "center": "centre",
    "bitbybit.babylon.transforms.rotationCenterX": "rotation centre x",
    "rotationCenterX": "rotation centre x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Crée une transformation de rotation autour du centre et d'un axe X",
    "bitbybit.babylon.transforms.rotationCenterY": "rotation centre y",
    "rotationCenterY": "rotation centre y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Crée une transformation de rotation autour du centre et d'un axe Y",
    "bitbybit.babylon.transforms.rotationCenterZ": "rotation centre z",
    "rotationCenterZ": "rotation centre z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Crée une transformation de rotation autour du centre et d'un axe Z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "rotation centre lacet tangage roulis",
    "rotationCenterYawPitchRoll": "rotation centre lacet tangage roulis",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Crée une transformation de rotation avec lacet, tangage et roulis",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "échelle centre xyz",
    "scaleCenterXYZ": "échelle centre xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Transformation d'échelle autour du centre et des directions xyz",
    "scaleXyz": "échelle xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "échelle xyz",
    "scaleXYZ": "échelle xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Crée la transformation d'échelle dans les directions x, y et z",
    "bitbybit.babylon.transforms.uniformScale": "échelle uniforme",
    "uniformScale": "échelle uniforme",
    "bitbybit.babylon.transforms.uniformScale_description": "Crée une transformation d'échelle uniforme",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "échelle uniforme depuis centre",
    "uniformScaleFromCenter": "échelle uniforme depuis centre",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Crée une transformation d'échelle uniforme à partir du centre",
    "bitbybit.babylon.transforms.translationXYZ": "translation xyz",
    "translationXYZ": "translation xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "Crée la transformation de translation",
    "translation": "translation",
    "bitbybit.babylon.transforms.translationsXYZ": "translations xyz",
    "translationsXYZ": "translations xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Crée la transformation de translation",
    "translations": "translations",
    "Base.Vector3[]": "tableau de vecteurs de base 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "charger actif dans scène",
    "io": "io",
    "loadAssetIntoScene": "charger actif dans scène",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Importe un maillage à partir de l'actif que vous avez téléchargé pour le projet. Vous devez télécharger vos actifs dans votre projet via la page de gestion de projet.",
    "load": "charger",
    "assetFile": "fichier actif",
    "File": "fichier",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "charger actif dans scène sans retour",
    "loadAssetIntoSceneNoReturn": "charger actif dans scène sans retour",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Importe un maillage à partir de l'actif que vous avez téléchargé pour le projet. Vous devez télécharger vos actifs dans votre projet via la page de gestion de projet.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "charger actif dans scène depuis url racine",
    "loadAssetIntoSceneFromRootUrl": "charger actif dans scène depuis url racine",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Importe un maillage à partir de l'URL de l'actif que vous avez téléchargé sur un stockage web accessible. Gardez à l'esprit que les fichiers doivent être accessibles publiquement pour que cela fonctionne, assurez-vous que l'accès CORS est activé pour les actifs.",
    "rootUrl": "url racine",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "charger actif dans scène depuis url racine sans retour",
    "loadAssetIntoSceneFromRootUrlNoReturn": "charger actif dans scène depuis url racine sans retour",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Importe un maillage à partir de l'URL de l'actif que vous avez téléchargé sur un stockage web accessible. Gardez à l'esprit que les fichiers doivent être accessibles publiquement pour que cela fonctionne, assurez-vous que l'accès CORS est activé pour les actifs.",
    "bitbybit.babylon.io.exportBabylon": "exporter babylon",
    "exportBabylon": "exporter babylon",
    "bitbybit.babylon.io.exportBabylon_description": "Exporte toute la scène au format de scène .babylon. Vous pouvez ensuite la modifier davantage dans les éditeurs babylonjs.",
    "export": "exporter",
    "fileName": "nom de fichier",
    "bitbybit.babylon.io.exportGLB": "exporter glb",
    "exportGLB": "exporter glb",
    "bitbybit.babylon.io.exportGLB_description": "Exporte toute la scène au format .glb. Ce format de fichier est devenu la norme de l'industrie pour les modèles web.",
    "discardSkyboxAndGrid": "rejeter skybox et grille",
    "bitbybit.babylon.io.exportMeshToStl": "exporter maillage vers stl",
    "exportMeshToStl": "exporter maillage vers stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "Exporte le maillage avec ses enfants en stl",
    "bitbybit.babylon.io.exportMeshesToStl": "exporter maillages vers stl",
    "exportMeshesToStl": "exporter maillages vers stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Exporte les maillages en stl",
    "meshes": "maillages",
    "bitbybit.babylon.ray.createPickingRay": "rayon de sélection",
    "ray": "rayon",
    "createPickingRay": "rayon de sélection",
    "bitbybit.babylon.ray.createPickingRay_description": "Crée un rayon de sélection de la position actuelle de la souris dans la caméra active",
    "bitbybit.babylon.ray.createRay": "rayon",
    "createRay": "rayon",
    "bitbybit.babylon.ray.createRay_description": "Crée un rayon qui commence à l'origine, a un vecteur de direction et éventuellement une longueur",
    "length": "longueur",
    "bitbybit.babylon.ray.createRayFromTo": "rayon de à",
    "createRayFromTo": "rayon de à",
    "bitbybit.babylon.ray.createRayFromTo_description": "Crée un rayon d'un point à un autre",
    "from": "de",
    "to": "à",
    "bitbybit.babylon.ray.getOrigin": "obtenir origine",
    "getOrigin": "obtenir origine",
    "bitbybit.babylon.ray.getOrigin_description": "Obtient l'origine du rayon",
    "BABYLON.Ray": "rayon babylon",
    "bitbybit.babylon.ray.getDirection": "obtenir direction",
    "getDirection": "obtenir direction",
    "bitbybit.babylon.ray.getDirection_description": "Obtient la direction du rayon",
    "bitbybit.babylon.ray.getLength": "obtenir longueur",
    "getLength": "obtenir longueur",
    "bitbybit.babylon.ray.getLength_description": "Obtient la longueur du rayon",
    "bitbybit.babylon.pick.pickWithRay": "sélectionner avec rayon",
    "pick": "sélectionner",
    "pickWithRay": "sélectionner avec rayon",
    "bitbybit.babylon.pick.pickWithRay_description": "Obtient un résultat d'impact de sélection avec un rayon",
    "bitbybit.babylon.pick.pickWithPickingRay": "sélectionner avec rayon sélection",
    "pickWithPickingRay": "sélectionner avec rayon sélection",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Sélectionne avec un rayon de sélection de la position actuelle de la souris dans la caméra active",
    "bitbybit.babylon.pick.getDistance": "obtenir distance",
    "getDistance": "obtenir distance",
    "bitbybit.babylon.pick.getDistance_description": "Obtient la distance à l'objet si un résultat de sélection existe",
    "get from pick info": "obtenir depuis info sélection",
    "pickInfo": "info sélection",
    "BABYLON.PickingInfo": "info sélection babylon",
    "bitbybit.babylon.pick.getPickedMesh": "obtenir maillage sélectionné",
    "getPickedMesh": "obtenir maillage sélectionné",
    "bitbybit.babylon.pick.getPickedMesh_description": "Obtient le maillage sélectionné",
    "bitbybit.babylon.pick.getPickedPoint": "obtenir point sélectionné",
    "getPickedPoint": "obtenir point sélectionné",
    "bitbybit.babylon.pick.getPickedPoint_description": "Obtient le point sélectionné",
    "bitbybit.babylon.pick.hit": "touché",
    "hit": "touché",
    "bitbybit.babylon.pick.hit_description": "Vérifie si le rayon de sélection a touché quelque chose dans la scène ou non",
    "bitbybit.babylon.pick.getSubMeshId": "obtenir id sous-maillage",
    "getSubMeshId": "obtenir id sous-maillage",
    "bitbybit.babylon.pick.getSubMeshId_description": "Obtient l'identifiant unique du sous-maillage s'il a été sélectionné",
    "bitbybit.babylon.pick.getSubMeshFaceId": "obtenir id face sous-maillage",
    "getSubMeshFaceId": "obtenir id face sous-maillage",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Obtient l'identifiant unique de la face du sous-maillage s'il a été sélectionné",
    "bitbybit.babylon.pick.getBU": "obtenir bu",
    "getBU": "obtenir bu",
    "bitbybit.babylon.pick.getBU_description": "Obtient la coordonnée barycentrique U qui est utilisée lors du calcul des coordonnées de texture de la collision",
    "bitbybit.babylon.pick.getBV": "obtenir bv",
    "getBV": "obtenir bv",
    "bitbybit.babylon.pick.getBV_description": "Obtient la coordonnée barycentrique V qui est utilisée lors du calcul des coordonnées de texture de la collision",
    "bitbybit.babylon.pick.getPickedSprite": "obtenir sprite sélectionné",
    "getPickedSprite": "obtenir sprite sélectionné",
    "bitbybit.babylon.pick.getPickedSprite_description": "Obtient le sprite sélectionné",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr métallique rugosité",
    "pbrMetallicRoughness": "pbr métallique rugosité",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Crée un matériau PBR métallique rugueux.",
    "baseColor": "couleur de base",
    "emissiveColor": "couleur émissive",
    "metallic": "métallique",
    "roughness": "rugosité",
    "zOffset": "décalage z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "définir couleur de base",
    "setBaseColor": "définir couleur de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Définit la couleur de base du matériau",
    "BABYLON.PBRMetallicRoughnessMaterial": "matériau pbr métallique rugosité babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "définir métallique",
    "setMetallic": "définir métallique",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Définit la propriété métallique du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "définir rugosité",
    "setRoughness": "définir rugosité",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Définit la rugosité du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "définir alpha",
    "setAlpha": "définir alpha",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Définit l'alpha du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "définir élimination faces arrière",
    "setBackFaceCulling": "définir élimination faces arrière",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Définit le masquage des faces arrière du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "définir texture de base",
    "setBaseTexture": "définir texture de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Définit la texture du matériau",
    "baseTexture": "texture de base",
    "BABYLON.Texture": "texture babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "obtenir couleur de base",
    "getBaseColor": "obtenir couleur de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Obtient la couleur de base du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "obtenir métallique",
    "getMetallic": "obtenir métallique",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Obtient la propriété métallique du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "obtenir rugosité",
    "getRoughness": "obtenir rugosité",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Obtient la rugosité du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "obtenir alpha",
    "getAlpha": "obtenir alpha",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Obtient l'alpha du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "obtenir élimination faces arrière",
    "getBackFaceCulling": "obtenir élimination faces arrière",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Obtient le masquage des faces arrière du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "obtenir texture de base",
    "getBaseTexture": "obtenir texture de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Obtient la texture de base du matériau",
    "bitbybit.babylon.material.skyMaterial.create": "matériau ciel",
    "skyMaterial": "matériau ciel",
    "bitbybit.babylon.material.skyMaterial.create_description": "Crée un matériau de ciel",
    "luminance": "luminance",
    "turbidity": "turbidité",
    "rayleigh": "rayleigh",
    "mieCoefficient": "coefficient mie",
    "mieDirectionalG": "mie directionnel g",
    "inclination": "inclinaison",
    "azimuth": "azimut",
    "sunPosition": "position soleil",
    "useSunPosition": "utiliser position soleil",
    "cameraOffset": "décalage caméra",
    "up": "haut",
    "dithering": "tramage",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "définir luminance",
    "setLuminance": "définir luminance",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Définit la luminance du matériau de ciel",
    "MATERIALS.SkyMaterial": "matériaux matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "définir turbidité",
    "setTurbidity": "définir turbidité",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Définit la turbidité du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "définir rayleigh",
    "setRayleigh": "définir rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Définit le rayleigh du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "définir coefficient mie",
    "setMieCoefficient": "définir coefficient mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Définit le coefficient mie du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "définir mie directionnel g",
    "setMieDirectionalG": "définir mie directionnel g",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Définit le G directionnel mie du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setDistance": "définir distance",
    "setDistance": "définir distance",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Définit la distance du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setInclination": "définir inclinaison",
    "setInclination": "définir inclinaison",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Définit l'inclinaison du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "définir azimut",
    "setAzimuth": "définir azimut",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Définit l'azimut du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "définir position soleil",
    "setSunPosition": "définir position soleil",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Définit la position du soleil du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "définir utiliser position soleil",
    "setUseSunPosition": "définir utiliser position soleil",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Définit l'utilisation de la position du soleil du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "définir décalage caméra",
    "setCameraOffset": "définir décalage caméra",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Définit le décalage de la caméra du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setUp": "définir haut",
    "setUp": "définir haut",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Définit le haut du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.setDithering": "définir tramage",
    "setDithering": "définir tramage",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Définit le tramage du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "obtenir luminance",
    "getLuminance": "obtenir luminance",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Obtient la luminance du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "obtenir turbidité",
    "getTurbidity": "obtenir turbidité",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Obtient la turbidité du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "obtenir rayleigh",
    "getRayleigh": "obtenir rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Obtient le rayleigh du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "obtenir coefficient mie",
    "getMieCoefficient": "obtenir coefficient mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Obtient le coefficient mie du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "obtenir mie directionnel g",
    "getMieDirectionalG": "obtenir mie directionnel g",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Obtient le G directionnel mie du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getDistance": "obtenir distance",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Obtient la distance du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getInclination": "obtenir inclinaison",
    "getInclination": "obtenir inclinaison",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Obtient l'inclinaison du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "obtenir azimut",
    "getAzimuth": "obtenir azimut",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Obtient l'azimut du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "obtenir position soleil",
    "getSunPosition": "obtenir position soleil",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Obtient la position du soleil du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "obtenir utiliser position soleil",
    "getUseSunPosition": "obtenir utiliser position soleil",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Obtient l'utilisation de la position du soleil du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "obtenir décalage caméra",
    "getCameraOffset": "obtenir décalage caméra",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Obtient le décalage de la caméra du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getUp": "obtenir haut",
    "getUp": "obtenir haut",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Obtient le haut du matériau de ciel",
    "bitbybit.babylon.material.skyMaterial.getDithering": "obtenir tramage",
    "getDithering": "obtenir tramage",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Obtient le tramage du matériau de ciel",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "définir direction vers cible",
    "shadowLight": "lumière ombre",
    "setDirectionToTarget": "définir direction vers cible",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Définit la direction de la lumière d'ombre",
    "BABYLON.ShadowLight": "lumière ombre babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "définir position",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Définit la position de la lumière d'ombre",
    "bitbybit.babylon.meshBuilder.createBox": "boîte",
    "meshBuilder": "constructeur maillage",
    "createBox": "boîte",
    "bitbybit.babylon.meshBuilder.createBox_description": "Crée un maillage de boîte",
    "create simple": "créer simple",
    "depth": "profondeur",
    "sideOrientation": "orientation côté",
    "BabylonMesh.sideOrientationEnum": "énumération orientation côté maillage babylon",
    "bitbybit.babylon.meshBuilder.createCube": "cube",
    "createCube": "cube",
    "bitbybit.babylon.meshBuilder.createCube_description": "Crée un maillage de cube",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "plan carré",
    "createSquarePlane": "plan carré",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Crée un maillage de plan carré",
    "bitbybit.babylon.meshBuilder.createSphere": "sphère",
    "createSphere": "sphère",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Crée un maillage de sphère",
    "diameter": "diamètre",
    "segments": "segments",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "icosphère",
    "createIcoSphere": "icosphère",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Crée une sphère ico",
    "radiusX": "rayon x",
    "radiusY": "rayon y",
    "radiusZ": "rayon z",
    "flat": "plat",
    "bitbybit.babylon.meshBuilder.createDisc": "disque",
    "createDisc": "disque",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Crée un disque",
    "tessellation": "tessellation",
    "arc": "arc",
    "bitbybit.babylon.meshBuilder.createTorus": "tore",
    "createTorus": "tore",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Crée un maillage de tore",
    "thickness": "épaisseur",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "noeud de tore",
    "createTorusKnot": "noeud de tore",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Crée un maillage de nœud de tore",
    "tube": "tube",
    "radialSegments": "segments radiaux",
    "tubularSegments": "segments tubulaires",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polygone",
    "createPolygon": "polygone",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Crée un maillage de polygone",
    "shape": "forme",
    "holes": "trous",
    "Base.Vector3[][]": "tableau de tableau de vecteurs de base 3",
    "smoothingThreshold": "seuil lissage",
    "wrap": "envelopper",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extruder polygone",
    "extrudePolygon": "extruder polygone",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Crée un maillage de polygone extrudé",
    "bitbybit.babylon.meshBuilder.createTube": "tube",
    "createTube": "tube",
    "bitbybit.babylon.meshBuilder.createTube_description": "Crée un maillage de tube",
    "path": "chemin",
    "cap": "capuchon",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "polyèdre",
    "createPolyhedron": "polyèdre",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Crée un maillage de polyèdre",
    "type": "type",
    "sizeX": "taille x",
    "sizeY": "taille y",
    "sizeZ": "taille z",
    "custom": "personnalisé",
    "bitbybit.babylon.meshBuilder.createGeodesic": "géodésique",
    "createGeodesic": "géodésique",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Crée un maillage géodésique",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Crée un maillage goldberg",
    "bitbybit.babylon.meshBuilder.createCapsule": "capsule",
    "createCapsule": "capsule",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Crée un maillage de capsule",
    "orientation": "orientation",
    "capSubdivisions": "subdivisions capuchon",
    "radiusTop": "rayon haut",
    "radiusBottom": "rayon bas",
    "topCapSubdivisions": "subdivisions capuchon haut",
    "bottomCapSubdivisions": "subdivisions capuchon bas",
    "bitbybit.babylon.meshBuilder.createCylinder": "cylindre",
    "createCylinder": "cylindre",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Crée un maillage de cylindre",
    "diameterTop": "diamètre haut",
    "diameterBottom": "diamètre bas",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "forme extrudée",
    "createExtrudedSahpe": "forme extrudée",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Crée une forme extrudée",
    "closeShape": "fermer forme",
    "closePath": "fermer chemin",
    "bitbybit.babylon.meshBuilder.createRibbon": "ruban",
    "createRibbon": "ruban",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Crée un maillage de ruban",
    "pathArray": "tableau de chemins",
    "closeArray": "fermer tableau",
    "offset": "décalage",
    "bitbybit.babylon.meshBuilder.createLathe": "tour",
    "createLathe": "tour",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Crée un maillage de tour (lathe)",
    "closed": "fermé",
    "bitbybit.babylon.meshBuilder.createGround": "sol",
    "createGround": "sol",
    "bitbybit.babylon.meshBuilder.createGround_description": "Crée le maillage de sol",
    "subdivisionsX": "subdivisions x",
    "subdivisionsY": "subdivisions y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "plan rectangle",
    "createRectanglePlane": "plan rectangle",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Crée un maillage de plan rectangulaire",
    "bitbybit.babylon.texture.createSimple": "texture simple",
    "texture": "texture",
    "createSimple": "simple",
    "bitbybit.babylon.texture.createSimple_description": "Crée une texture à partir d'une URL avec quelques options de base. Si vous avez chargé l'actif via le fichier, créez une URL d'objet et passez-la ici.",
    "invertY": "inverser y",
    "invertZ": "inverser z",
    "wAng": "angle w",
    "uScale": "échelle u",
    "vScale": "échelle v",
    "uOffset": "décalage u",
    "vOffset": "décalage v",
    "samplingMode": "mode d'échantillonnage",
    "samplingModeEnum": "énumération mode d'échantillonnage",
    "bitbybit.babylon.tools.createScreenshot": "capture d'écran",
    "tools": "outils",
    "createScreenshot": "capture d'écran",
    "bitbybit.babylon.tools.createScreenshot_description": "Crée une capture d'écran de la scène",
    "screenshots": "captures d'écran",
    "mimeType": "type mime",
    "quality": "qualité",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "capture d'écran et télécharger",
    "createScreenshotAndDownload": "capture d'écran et télécharger",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Crée une capture d'écran de la scène et télécharge le fichier",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interface utilisateur plein écran",
    "gui": "gui",
    "advancedDynamicTexture": "texture dynamique avancée",
    "createFullScreenUI": "interface utilisateur plein écran",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "crée une interface utilisateur plein écran",
    "spaces": "espaces",
    "foreground": "premier plan",
    "adaptiveScaling": "mise à l'échelle adaptative",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "pour maillage",
    "createForMesh": "pour maillage",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Crée une texture dynamique avancée pour un maillage",
    "BABYLON.AbstractMesh": "maillage abstrait babylon",
    "supportPointerMove": "support mouvement pointeur",
    "onlyAlphaTesting": "test alpha seulement",
    "sampling": "échantillonnage",
    "BabylonTexture.samplingModeEnum": "énumération mode échantillonnage texture babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "changer rembourrage contrôle",
    "control": "contrôle",
    "changeControlPadding": "changer rembourrage contrôle",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Change le rembourrage pour le contrôle",
    "positioning": "positionnement",
    "BABYLON.GUI.Control": "contrôle gui babylon",
    "paddingLeft": "rembourrage gauche",
    "number | string": "nombre ou chaîne",
    "paddingRight": "rembourrage droit",
    "paddingTop": "rembourrage haut",
    "paddingBottom": "rembourrage bas",
    "bitbybit.babylon.gui.control.changeControlAlignment": "changer alignement contrôle",
    "changeControlAlignment": "changer alignement contrôle",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Change l'alignement pour le contrôle",
    "T": "t",
    "horizontalAlignment": "alignement horizontal",
    "horizontalAlignmentEnum": "énumération alignement horizontal",
    "verticalAlignment": "alignement vertical",
    "verticalAlignmentEnum": "énumération alignement vertical",
    "bitbybit.babylon.gui.control.cloneControl": "cloner contrôle",
    "cloneControl": "cloner contrôle",
    "bitbybit.babylon.gui.control.cloneControl_description": "Clone le contrôle",
    "container": "conteneur",
    "BABYLON.GUI.Container": "conteneur gui babylon",
    "host": "hôte",
    "BABYLON.GUI.AdvancedDynamicTexture": "texture dynamique avancée gui babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "sélecteur observable contrôle",
    "createControlObservableSelector": "sélecteur observable contrôle",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Crée le sélecteur d'un observable pour un contrôle",
    "selector": "sélecteur",
    "controlObservableSelectorEnum": "énumération sélecteur observable contrôle",
    "bitbybit.babylon.gui.control.getControlByName": "obtenir contrôle par nom",
    "getControlByName": "obtenir contrôle par nom",
    "bitbybit.babylon.gui.control.getControlByName_description": "Obtient le contrôle par nom",
    "bitbybit.babylon.gui.control.setIsVisible": "définir est visible",
    "setIsVisible": "définir est visible",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Définit si le contrôle est visible",
    "isVisible": "est visible",
    "bitbybit.babylon.gui.control.setIsReadonly": "définir est lecture seule",
    "setIsReadonly": "définir est lecture seule",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Définit si le contrôle est en lecture seule",
    "isReadOnly": "est lecture seule",
    "bitbybit.babylon.gui.control.setIsEnabled": "définir est activé",
    "setIsEnabled": "définir est activé",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Définit si le contrôle est activé",
    "isEnabled": "est activé",
    "bitbybit.babylon.gui.control.setHeight": "définir hauteur",
    "setHeight": "définir hauteur",
    "bitbybit.babylon.gui.control.setHeight_description": "Définit la hauteur du contrôle",
    "bitbybit.babylon.gui.control.setWidth": "définir largeur",
    "setWidth": "définir largeur",
    "bitbybit.babylon.gui.control.setWidth_description": "Définit la largeur du contrôle",
    "bitbybit.babylon.gui.control.setColor": "définir couleur",
    "setColor": "définir couleur",
    "bitbybit.babylon.gui.control.setColor_description": "Définit la couleur du contrôle",
    "bitbybit.babylon.gui.control.setFontSize": "définir taille police",
    "setFontSize": "définir taille police",
    "bitbybit.babylon.gui.control.setFontSize_description": "Définit la taille de la police",
    "fontSize": "taille police",
    "bitbybit.babylon.gui.control.getHeight": "obtenir hauteur",
    "getHeight": "obtenir hauteur",
    "bitbybit.babylon.gui.control.getHeight_description": "Obtient la hauteur",
    "bitbybit.babylon.gui.control.getWidth": "obtenir largeur",
    "getWidth": "obtenir largeur",
    "bitbybit.babylon.gui.control.getWidth_description": "Obtient la largeur",
    "bitbybit.babylon.gui.control.getColor": "obtenir couleur",
    "getColor": "obtenir couleur",
    "bitbybit.babylon.gui.control.getColor_description": "Obtient la couleur",
    "bitbybit.babylon.gui.control.getFontSize": "obtenir taille police",
    "getFontSize": "obtenir taille police",
    "bitbybit.babylon.gui.control.getFontSize_description": "Obtient la taille de police du contrôle",
    "bitbybit.babylon.gui.control.getIsVisible": "obtenir est visible",
    "getIsVisible": "obtenir est visible",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Obtient si le contrôle est visible",
    "bitbybit.babylon.gui.control.getIsReadonly": "obtenir est lecture seule",
    "getIsReadonly": "obtenir est lecture seule",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Obtient si le contrôle est en lecture seule",
    "bitbybit.babylon.gui.control.getIsEnabled": "obtenir est activé",
    "getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Obtient si le contrôle est activé",
    "bitbybit.babylon.gui.container.addControls": "ajouter contrôles",
    "addControls": "ajouter contrôles",
    "bitbybit.babylon.gui.container.addControls_description": "Ajoute des contrôles au conteneur et conserve l'ordre",
    "controls": "contrôles",
    "BABYLON.GUI.Control[]": "tableau de contrôles gui babylon",
    "clearControlsFirst": "effacer contrôles d'abord",
    "bitbybit.babylon.gui.container.setBackground": "définir arrière-plan",
    "setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.container.setBackground_description": "Définit l'arrière-plan du conteneur",
    "background": "arrière-plan",
    "bitbybit.babylon.gui.container.setIsReadonly": "définir est lecture seule",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Définit si le conteneur est en lecture seule",
    "bitbybit.babylon.gui.container.getBackground": "obtenir arrière-plan",
    "getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.container.getBackground_description": "Obtient l'arrière-plan du conteneur",
    "bitbybit.babylon.gui.container.getIsReadonly": "obtenir est lecture seule",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Obtient si le conteneur est en lecture seule",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "panneau empilé",
    "stackPanel": "panneau empilé",
    "createStackPanel": "panneau empilé",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "crée un panneau empilé",
    "isVertical": "est vertical",
    "spacing": "espacement",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "définir est vertical",
    "setIsVertical": "définir est vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Définit si le panneau empilé est vertical",
    "BABYLON.GUI.StackPanel": "panneau empilé gui babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "définir espacement",
    "setSpacing": "définir espacement",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Définit l'espacement du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.setWidth": "définir largeur",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Définit la largeur du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.setHeight": "définir hauteur",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Définit la hauteur du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "obtenir est vertical",
    "getIsVertical": "obtenir est vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Obtient si le panneau empilé est vertical",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "obtenir espacement",
    "getSpacing": "obtenir espacement",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Obtient l'espacement du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.getWidth": "obtenir largeur",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Obtient la largeur du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.getHeight": "obtenir hauteur",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Obtient la hauteur du panneau empilé",
    "bitbybit.babylon.gui.button.createSimpleButton": "bouton simple",
    "button": "bouton",
    "createSimpleButton": "bouton simple",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "crée un bouton simple",
    "label": "étiquette",
    "bitbybit.babylon.gui.button.setButtonText": "définir texte bouton",
    "setButtonText": "définir texte bouton",
    "bitbybit.babylon.gui.button.setButtonText_description": "Définit le texte du bouton",
    "BABYLON.GUI.Button": "bouton gui babylon",
    "text": "texte",
    "bitbybit.babylon.gui.button.getButtonText": "obtenir texte bouton",
    "getButtonText": "obtenir texte bouton",
    "bitbybit.babylon.gui.button.getButtonText_description": "Obtient le texte du bouton",
    "bitbybit.babylon.gui.slider.createSlider": "curseur",
    "slider": "curseur",
    "createSlider": "curseur",
    "bitbybit.babylon.gui.slider.createSlider_description": "crée un curseur",
    "minimum": "minimum",
    "maximum": "maximum",
    "value": "valeur",
    "step": "pas",
    "displayThumb": "afficher pouce",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "changer pouce curseur",
    "changeSliderThumb": "changer pouce curseur",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "change les propriétés du pouce du curseur",
    "BABYLON.GUI.Slider": "curseur gui babylon",
    "isThumbCircle": "est pouce cercle",
    "thumbColor": "couleur pouce",
    "thumbWidth": "largeur pouce",
    "string | number": "chaîne ou nombre",
    "isThumbClamped": "est pouce limité",
    "bitbybit.babylon.gui.slider.setBorderColor": "définir couleur bordure",
    "setBorderColor": "définir couleur bordure",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Change la couleur de la bordure du curseur",
    "borderColor": "couleur bordure",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "définir couleur arrière-plan",
    "setBackgroundColor": "définir couleur arrière-plan",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Change la couleur d'arrière-plan du curseur",
    "backgroundColor": "couleur arrière-plan",
    "bitbybit.babylon.gui.slider.setMaximum": "définir maximum",
    "setMaximum": "définir maximum",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Change la valeur maximale du curseur",
    "bitbybit.babylon.gui.slider.setMinimum": "définir minimum",
    "setMinimum": "définir minimum",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Change la valeur minimale du curseur",
    "bitbybit.babylon.gui.slider.setStep": "définir pas",
    "setStep": "définir pas",
    "bitbybit.babylon.gui.slider.setStep_description": "Change la valeur de pas du curseur",
    "bitbybit.babylon.gui.slider.setValue": "définir valeur",
    "setValue": "définir valeur",
    "bitbybit.babylon.gui.slider.setValue_description": "Change la valeur du curseur",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "sélecteur observable curseur",
    "createSliderObservableSelector": "sélecteur observable curseur",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Crée le sélecteur d'un observable pour un curseur",
    "sliderObservableSelectorEnum": "énumération sélecteur observable curseur",
    "bitbybit.babylon.gui.slider.getBorderColor": "obtenir couleur bordure",
    "getBorderColor": "obtenir couleur bordure",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Obtient la couleur de bordure du curseur",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "obtenir couleur arrière-plan",
    "getBackgroundColor": "obtenir couleur arrière-plan",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Obtient la couleur d'arrière-plan du curseur",
    "bitbybit.babylon.gui.slider.getMaximum": "obtenir maximum",
    "getMaximum": "obtenir maximum",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Obtient la valeur maximale du curseur",
    "bitbybit.babylon.gui.slider.getMinimum": "obtenir minimum",
    "getMinimum": "obtenir minimum",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Obtient la valeur minimale du curseur",
    "bitbybit.babylon.gui.slider.getStep": "obtenir pas",
    "getStep": "obtenir pas",
    "bitbybit.babylon.gui.slider.getStep_description": "Obtient la valeur de pas du curseur",
    "bitbybit.babylon.gui.slider.getValue": "obtenir valeur",
    "getValue": "obtenir valeur",
    "bitbybit.babylon.gui.slider.getValue_description": "Obtient la valeur du curseur",
    "bitbybit.babylon.gui.slider.getThumbColor": "obtenir couleur pouce",
    "getThumbColor": "obtenir couleur pouce",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Obtient la couleur du pouce du curseur",
    "bitbybit.babylon.gui.slider.getThumbWidth": "obtenir largeur pouce",
    "getThumbWidth": "obtenir largeur pouce",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Obtient la largeur du pouce du curseur",
    "bitbybit.babylon.gui.slider.getIsVertical": "obtenir est vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Obtient si le curseur est vertical",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "obtenir afficher pouce",
    "getDisplayThumb": "obtenir afficher pouce",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Obtient l'affichage du pouce du curseur",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "obtenir est pouce cercle",
    "getIsThumbCircle": "obtenir est pouce cercle",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Obtient si le pouce du curseur est un cercle",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "obtenir est pouce limité",
    "getIsThumbClamped": "obtenir est pouce limité",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Obtient si le pouce du curseur est bridé",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "bloc de texte",
    "textBlock": "bloc de texte",
    "createTextBlock": "bloc de texte",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "crée un bloc de texte",
    "bitbybit.babylon.gui.textBlock.alignText": "aligner texte",
    "alignText": "aligner texte",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Change l'alignement pour le texte",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "définir contour texte",
    "setTextOutline": "définir contour texte",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Change le contour du texte pour le texte",
    "BABYLON.GUI.TextBlock": "bloc de texte gui babylon",
    "outlineWidth": "largeur contour",
    "outlineColor": "couleur contour",
    "bitbybit.babylon.gui.textBlock.setText": "définir texte",
    "setText": "définir texte",
    "bitbybit.babylon.gui.textBlock.setText_description": "Définit le nouveau texte pour le bloc de texte",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "définir redimensionner pour ajuster",
    "setRsizeToFit": "définir redimensionner pour ajuster",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Active ou désactive le redimensionnement pour s'adapter",
    "resizeToFit": "redimensionner pour ajuster",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "définir retour à la ligne",
    "setTextWrapping": "définir retour à la ligne",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Définit le nouvel habillage de texte pour le bloc de texte",
    "textWrapping": "retour à la ligne",
    "boolean | BABYLON.GUI.TextWrapping": "booléen ou retour à la ligne gui babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "définir interligne",
    "setLineSpacing": "définir interligne",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Définit l'espacement des lignes du texte",
    "lineSpacing": "interligne",
    "bitbybit.babylon.gui.textBlock.getText": "obtenir texte",
    "getText": "obtenir texte",
    "bitbybit.babylon.gui.textBlock.getText_description": "Obtient le texte du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "obtenir retour à la ligne",
    "getTextWrapping": "obtenir retour à la ligne",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Obtient l'habillage de texte du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "obtenir interligne",
    "getLineSpacing": "obtenir interligne",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Obtient l'espacement des lignes du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "obtenir largeur contour",
    "getOutlineWidth": "obtenir largeur contour",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Obtient la largeur du contour du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "obtenir redimensionner pour ajuster",
    "getResizeToFit": "obtenir redimensionner pour ajuster",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Obtient le redimensionnement pour s'adapter du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "obtenir alignement horizontal texte",
    "getTextHorizontalAlignment": "obtenir alignement horizontal texte",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Obtient l'alignement horizontal du texte du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "obtenir alignement vertical texte",
    "getTextVerticalAlignment": "obtenir alignement vertical texte",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Obtient l'alignement vertical du texte du bloc de texte",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "sélecteur observable bloc de texte",
    "createTextBlockObservableSelector": "sélecteur observable bloc de texte",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Crée le sélecteur d'un observable pour un bloc de texte",
    "textBlockObservableSelectorEnum": "énumération sélecteur observable bloc de texte",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "bouton radio",
    "radioButton": "bouton radio",
    "createRadioButton": "bouton radio",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "crée un bouton radio",
    "group": "groupe",
    "isChecked": "est coché",
    "checkSizeRatio": "ratio taille coche",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "définir ratio taille coche",
    "setCheckSizeRatio": "définir ratio taille coche",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Définit le rapport de taille de la coche du bouton radio",
    "BABYLON.GUI.RadioButton": "bouton radio gui babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "définir groupe",
    "setGroup": "définir groupe",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Définit le groupe du bouton radio",
    "bitbybit.babylon.gui.radioButton.setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Définit l'arrière-plan du bouton radio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "obtenir ratio taille coche",
    "getCheckSizeRatio": "obtenir ratio taille coche",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Obtient le rapport de taille de la coche du bouton radio",
    "bitbybit.babylon.gui.radioButton.getGroup": "obtenir groupe",
    "getGroup": "obtenir groupe",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Obtient le groupe du bouton radio",
    "bitbybit.babylon.gui.radioButton.getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Obtient l'arrière-plan du bouton radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "sélecteur observable bouton radio",
    "createRadioButtonObservableSelector": "sélecteur observable bouton radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Crée le sélecteur d'un observable pour le bouton radio",
    "radioButtonObservableSelectorEnum": "énumération sélecteur observable bouton radio",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "case à cocher",
    "checkbox": "case à cocher",
    "createCheckbox": "case à cocher",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "crée une case à cocher",
    "bitbybit.babylon.gui.checkbox.setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Définit l'arrière-plan de la case à cocher",
    "BABYLON.GUI.Checkbox": "case à cocher gui babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "définir ratio taille coche",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Définit le rapport de taille de la coche de la case à cocher",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "définir est coché",
    "setIsChecked": "définir est coché",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Définit si la case à cocher est cochée",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "obtenir ratio taille coche",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Obtient le rapport de taille de la coche",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "obtenir est coché",
    "getIsChecked": "obtenir est coché",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Obtient si elle est cochée",
    "bitbybit.babylon.gui.checkbox.getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Obtient l'arrière-plan",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "sélecteur observable case à cocher",
    "createCheckboxObservableSelector": "sélecteur observable case à cocher",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Crée le sélecteur d'un observable pour la case à cocher",
    "checkboxObservableSelectorEnum": "énumération sélecteur observable case à cocher",
    "bitbybit.babylon.gui.inputText.createInputText": "saisie de texte",
    "inputText": "saisie de texte",
    "createInputText": "saisie de texte",
    "bitbybit.babylon.gui.inputText.createInputText_description": "crée une saisie de texte",
    "placeholder": "texte indicatif",
    "bitbybit.babylon.gui.inputText.setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Définit l'arrière-plan du texte de saisie",
    "BABYLON.GUI.InputText": "saisie de texte gui babylon",
    "bitbybit.babylon.gui.inputText.setText": "définir texte",
    "bitbybit.babylon.gui.inputText.setText_description": "Définit le texte du texte de saisie",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "définir texte indicatif",
    "setPlaceholder": "définir texte indicatif",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Définit l'espace réservé du texte de saisie",
    "bitbybit.babylon.gui.inputText.getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Obtient l'arrière-plan du texte de saisie",
    "bitbybit.babylon.gui.inputText.getText": "obtenir texte",
    "bitbybit.babylon.gui.inputText.getText_description": "Obtient le texte du texte de saisie",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "obtenir texte indicatif",
    "getPlaceholder": "obtenir texte indicatif",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Obtient l'espace réservé du texte de saisie",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "sélecteur observable saisie de texte",
    "createInputTextObservableSelector": "sélecteur observable saisie de texte",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Crée le sélecteur d'un observable pour le texte de saisie",
    "inputTextObservableSelectorEnum": "énumération sélecteur observable saisie de texte",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "sélecteur de couleur",
    "colorPicker": "sélecteur de couleur",
    "createColorPicker": "sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "crée un sélecteur de couleur",
    "defaultColor": "couleur par défaut",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "définir valeur sélecteur couleur",
    "setColorPickerValue": "définir valeur sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Définit la valeur de couleur du sélecteur de couleur",
    "BABYLON.GUI.ColorPicker": "sélecteur couleur gui babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "définir taille sélecteur couleur",
    "setColorPickerSize": "définir taille sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Définit la taille du sélecteur de couleur (largeur et hauteur)",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "obtenir valeur sélecteur couleur",
    "getColorPickerValue": "obtenir valeur sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Obtient la valeur de couleur du sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "obtenir taille sélecteur couleur",
    "getColorPickerSize": "obtenir taille sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "obtient la taille du sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "sélecteur observable sélecteur couleur",
    "createColorPickerObservableSelector": "sélecteur observable sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Crée le sélecteur d'un observable pour le sélecteur de couleur",
    "colorPickerObservableSelectorEnum": "énumération sélecteur observable sélecteur couleur",
    "bitbybit.babylon.gui.image.createImage": "image",
    "image": "image",
    "createImage": "image",
    "bitbybit.babylon.gui.image.createImage_description": "crée une image",
    "bitbybit.babylon.gui.image.setSourceUrl": "définir url source",
    "setSourceUrl": "définir url source",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "définit l'url source de l'image",
    "BABYLON.GUI.Image": "image gui babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "obtenir url source",
    "getSourceUrl": "obtenir url source",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "obtient l'url source de l'image",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gestionnaire de gizmo",
    "gizmo": "gizmo",
    "manager": "gestionnaire",
    "createGizmoManager": "gestionnaire de gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Crée un gestionnaire de gizmo",
    "positionGizmoEnabled": "gizmo position activé",
    "rotationGizmoEnabled": "gizmo rotation activé",
    "scaleGizmoEnabled": "gizmo échelle activé",
    "boundingBoxGizmoEnabled": "gizmo boîte englobante activé",
    "usePointerToAttachGizmos": "utiliser pointeur pour attacher gizmos",
    "clearGizmoOnEmptyPointerEvent": "effacer gizmo sur événement pointeur vide",
    "scaleRatio": "ratio échelle",
    "attachableMeshes": "maillages attachables",
    "BABYLON.AbstractMesh[]": "tableau maillages abstraits babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "obtenir gizmo position",
    "getPositionGizmo": "obtenir gizmo position",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Obtient le gizmo de position",
    "gizmoManager": "gestionnaire gizmo",
    "BABYLON.GizmoManager": "gestionnaire gizmo babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "obtenir gizmo rotation",
    "getRotationGizmo": "obtenir gizmo rotation",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Obtient le gizmo de rotation",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "obtenir gizmo échelle",
    "getScaleGizmo": "obtenir gizmo échelle",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Obtient le gizmo d'échelle",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "obtenir gizmo boîte englobante",
    "getBoundingBoxGizmo": "obtenir gizmo boîte englobante",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Obtient le gizmo de boîte englobante",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "attacher au maillage",
    "attachToMesh": "attacher au maillage",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Attache le gestionnaire de gizmo au maillage",
    "update": "mettre à jour",
    "bitbybit.babylon.gizmo.manager.detachMesh": "détacher maillage",
    "detachMesh": "détacher maillage",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Détache le gestionnaire de gizmo du maillage",
    "bitbybit.babylon.gizmo.base.scaleRatio": "définir ratio échelle",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Définit le rapport d'échelle du gizmo",
    "BABYLON.IGizmo": "i gizmo babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "obtenir ratio échelle",
    "getScaleRatio": "obtenir ratio échelle",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Obtient le rapport d'échelle",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "définir gizmo planaire activé",
    "positionGizmo": "gizmo position",
    "planarGizmoEnabled": "gizmo planaire activé",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Définit le gizmo planaire activé",
    "BABYLON.IPositionGizmo": "i gizmo position babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "définir distance accrochage",
    "snapDistance": "distance accrochage",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Définit la distance d'accrochage du gizmo de position",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "obtenir maillage attaché",
    "getAttachedMesh": "obtenir maillage attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Obtient le maillage attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "obtenir noeud attaché",
    "getAttachedNode": "obtenir noeud attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Obtient le nœud attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "obtenir gizmo x",
    "getXGizmo": "obtenir gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Obtient le gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "obtenir gizmo y",
    "getYGizmo": "obtenir gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Obtient le gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "obtenir gizmo z",
    "getZGizmo": "obtenir gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Obtient le gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "obtenir gizmo plan x",
    "getXPlaneGizmo": "obtenir gizmo plan x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Obtient le gizmo de plan x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "obtenir gizmo plan y",
    "getYPlaneGizmo": "obtenir gizmo plan y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Obtient le gizmo de plan y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "obtenir gizmo plan z",
    "getZPlaneGizmo": "obtenir gizmo plan z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Obtient le gizmo de plan z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "obtenir gizmo planaire activé",
    "getPlanarGizmoEnabled": "obtenir gizmo planaire activé",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Obtient si le gizmo planaire est activé",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "obtenir distance accrochage",
    "getSnapDistance": "obtenir distance accrochage",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Obtient la distance d'accrochage",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "obtenir est en train de glisser",
    "getIsDragging": "obtenir est en train de glisser",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Obtient si on est en train de faire glisser",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "sélecteur observable gizmo position",
    "createPositionGizmoObservableSelector": "sélecteur observable gizmo position",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Crée le sélecteur d'un observable pour un gizmo de position",
    "positionGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo position",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "définir distance accrochage",
    "rotationGizmo": "gizmo rotation",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Définit la distance d'accrochage du gizmo de rotation",
    "BABYLON.IRotationGizmo": "i gizmo rotation babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "définir sensibilité",
    "sensitivity": "sensibilité",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Définit la sensibilité du gizmo de rotation",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "obtenir maillage attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Obtient le maillage attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "obtenir noeud attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Obtient le nœud attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "obtenir gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Obtient le gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "obtenir gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Obtient le gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "obtenir gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Obtient le gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "obtenir distance accrochage",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Obtient la distance d'accrochage",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "obtenir sensibilité",
    "getSensitivity": "obtenir sensibilité",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Obtient la sensibilité",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "sélecteur observable gizmo rotation",
    "createRotationGizmoObservableSelector": "sélecteur observable gizmo rotation",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Crée le sélecteur d'un observable pour un gizmo de rotation",
    "rotationGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo rotation",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "obtenir gizmo x",
    "scaleGizmo": "gizmo échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Obtient le gizmo x",
    "BABYLON.IScaleGizmo": "i gizmo échelle babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "obtenir gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Obtient le gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "obtenir gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Obtient le gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "définir distance accrochage",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Définit la distance d'accrochage du gizmo d'échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "définir accrochage incrémentiel",
    "setIncrementalSnap": "définir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Définit l'accrochage incrémentiel du gizmo d'échelle",
    "incrementalSnap": "accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "définir sensibilité",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Définit la sensibilité du gizmo d'échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "obtenir accrochage incrémentiel",
    "getIncrementalSnap": "obtenir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Obtient l'accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "obtenir distance accrochage",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Obtient la distance d'accrochage",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "obtenir sensibilité",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Obtient la sensibilité",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "sélecteur observable gizmo échelle",
    "createScaleGizmoObservableSelector": "sélecteur observable gizmo échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Crée le sélecteur d'un observable pour un gizmo d'échelle",
    "scaleGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "définir taille sphère rotation",
    "boundingBoxGizmo": "gizmo boîte englobante",
    "setRotationSphereSize": "définir taille sphère rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Définit la taille de la sphère de rotation du gizmo de boîte englobante",
    "BABYLON.BoundingBoxGizmo": "gizmo boîte englobante babylon",
    "rotationSphereSize": "taille sphère rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "définir taille écran maillage glissement fixe",
    "setFixedDragMeshScreenSize": "définir taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "Si défini, les ancres de rotation et les boîtes d'échelle augmenteront en taille en fonction de la distance à la caméra pour avoir une taille d'écran cohérente (Par défaut : false). Remarque : fixedDragMeshScreenSize a la priorité sur fixedDragMeshBoundsSize si les deux sont vrais",
    "fixedDragMeshScreenSize": "taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "définir taille limites maillage glissement fixe",
    "setFixedDragMeshBoundsSize": "définir taille limites maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Définit la taille des limites du maillage de glissement fixe du gizmo de boîte englobante",
    "fixedDragMeshBoundsSize": "taille limites maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "définir facteur distance taille écran maillage glissement fixe",
    "setFixedDragMeshScreenSizeDistanceFactor": "définir facteur distance taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "La distance de l'objet à laquelle les maillages glissables devraient apparaître à la taille du monde lorsque fixedDragMeshScreenSize est défini sur true (par défaut : 10)",
    "fixedDragMeshScreenSizeDistanceFactor": "facteur distance taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "définir distance accrochage échelle",
    "setScalingSnapDistance": "définir distance accrochage échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Définit la distance d'accrochage de mise à l'échelle du gizmo de boîte englobante. Distance de glissement en unités babylon à laquelle le gizmo accrochera la mise à l'échelle lorsqu'il est glissé.",
    "scalingSnapDistance": "distance accrochage échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "définir distance accrochage rotation",
    "setRotationSnapDistance": "définir distance accrochage rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Définit la distance d'accrochage de rotation du gizmo de boîte englobante. Distance de glissement en unités babylon à laquelle le gizmo accrochera la rotation lorsqu'il est glissé.",
    "rotationSnapDistance": "distance accrochage rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "définir taille boîte échelle",
    "setScaleBoxSize": "définir taille boîte échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Définit la taille de la boîte d'échelle du gizmo de boîte englobante",
    "scaleBoxSize": "taille boîte échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "définir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Définit l'accrochage incrémentiel du gizmo de boîte englobante. Accrochage incrémentiel de la mise à l'échelle (par défaut false). Si vrai, avec une distance d'accrochage de 0.1, l'échelle sera 1.1, 1.2, 1.3 au lieu de, si faux : 1.1, 1.21, 1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "définir pivot échelle",
    "setScalePivot": "définir pivot échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Définit le pivot d'échelle du gizmo de boîte englobante. Pivot de boîte englobante relatif utilisé lors de la mise à l'échelle du nœud attaché. Si null, l'objet est mis à l'échelle depuis le coin opposé. 0.5,0.5,0.5 pour le centre et 0.5,0,0.5 pour le bas (Par défaut : null)",
    "scalePivot": "pivot échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "définir facteur axe",
    "setAxisFactor": "définir facteur axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Définit le facteur d'axe du gizmo de boîte englobante. Définit une valeur de sensibilité personnalisée pour chaque axe",
    "axisFactor": "facteur axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "définir vitesse glissement échelle",
    "setScaleDragSpeed": "définir vitesse glissement échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Définit la vitesse de glissement de l'échelle du gizmo de boîte englobante",
    "scaleDragSpeed": "vitesse glissement échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "obtenir taille sphère rotation",
    "getRotationSphereSize": "obtenir taille sphère rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Obtient la taille de la sphère de rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "obtenir taille boîte échelle",
    "getScaleBoxSize": "obtenir taille boîte échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Obtient la taille de la boîte d'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "obtenir taille écran maillage glissement fixe",
    "getFixedDragMeshScreenSize": "obtenir taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Obtient la taille d'écran du maillage de glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "obtenir taille limites maillage glissement fixe",
    "getFixedDragMeshBoundsSize": "obtenir taille limites maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Obtient la taille des limites du maillage de glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "obtenir facteur distance taille écran maillage glissement fixe",
    "getFixedDragMeshScreenSizeDistanceFactor": "obtenir facteur distance taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Obtient le facteur de distance de la taille d'écran du maillage de glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "obtenir distance accrochage échelle",
    "getScalingSnapDistance": "obtenir distance accrochage échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Obtient la distance d'accrochage de mise à l'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "obtenir distance accrochage rotation",
    "getRotationSnapDistance": "obtenir distance accrochage rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Obtient la distance d'accrochage de rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "obtenir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Obtient l'accrochage incrémentiel",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "obtenir pivot échelle",
    "getScalePivot": "obtenir pivot échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Obtient le pivot d'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "obtenir facteur axe",
    "getAxisFactor": "obtenir facteur axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Obtient le facteur d'axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "obtenir vitesse glissement échelle",
    "getScaleDragSpeed": "obtenir vitesse glissement échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Obtient la vitesse de glissement de l'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "sélecteur observable gizmo boîte englobante",
    "createBoundingBoxGizmoObservableSelector": "sélecteur observable gizmo boîte englobante",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Crée le sélecteur d'un observable pour un gizmo de boîte englobante",
    "boundingBoxGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo boîte englobante",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "définir est activé",
    "axisDragGizmo": "gizmo glissement axe",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Définit si l'axe est activé ou non",
    "BABYLON.IAxisDragGizmo": "i gizmo glissement axe babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Vérifie si l'axe est activé",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "définir est activé",
    "axisScaleGizmo": "gizmo échelle axe",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Définit si l'axe est activé ou non",
    "BABYLON.IAxisScaleGizmo": "i gizmo échelle axe babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Vérifie si l'axe est activé",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "définir est activé",
    "planeDragGizmo": "gizmo glissement plan",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Définit si le plan est activé ou non",
    "BABYLON.IPlaneDragGizmo": "i gizmo glissement plan babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Vérifie si le plan est activé",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "définir est activé",
    "planeRotationGizmo": "gizmo rotation plan",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Définit si le plan est activé ou non",
    "BABYLON.IPlaneRotationGizmo": "i gizmo rotation plan babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Vérifie si le plan est activé",
    "bitbybit.vector.removeAllDuplicateVectors": "supprimer tous vecteurs dupliqués",
    "vector": "vecteur",
    "removeAllDuplicateVectors": "supprimer tous vecteurs dupliqués",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Supprime tous les vecteurs dupliqués du tableau d'entrée (ne conserve que les vecteurs uniques). Exemple : [[1,2,3], [4,5,6], [1,2,3], [7,8,9]] → [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "supprimer",
    "vectors": "vecteurs",
    "number[][]": "tableau de tableau de nombres",
    "tolerance": "tolérance",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "supprimer vecteurs dupliqués consécutifs",
    "removeConsecutiveDuplicateVectors": "supprimer vecteurs dupliqués consécutifs",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Supprime les vecteurs dupliqués consécutifs du tableau d'entrée (ne supprime que les doublons qui apparaissent l'un à côté de l'autre). Exemple : [[1,2], [1,2], [3,4], [1,2]] → [[1,2], [3,4], [1,2]] (seul le doublon consécutif est supprimé)",
    "checkFirstAndLast": "vérifier premier et dernier",
    "bitbybit.vector.angleBetween": "angle entre",
    "angleBetween": "angle entre",
    "bitbybit.vector.angleBetween_description": "Mesure l'angle entre deux vecteurs en degrés (renvoie toujours un angle positif 0-180°). Exemple : [1,0,0] et [0,1,0] → 90° (vecteurs perpendiculaires)",
    "angles": "angles",
    "first": "premier",
    "second": "deuxième",
    "bitbybit.vector.angleBetweenNormalized2d": "angle entre normalisés 2d",
    "angleBetweenNormalized2d": "angle entre normalisés 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Mesure l'angle normalisé 2D entre deux vecteurs en degrés (prend en compte la direction, peut être négatif). Exemple : [1,0] à [0,1] → 90°, [0,1] à [1,0] → -90°",
    "bitbybit.vector.positiveAngleBetween": "angle positif entre",
    "positiveAngleBetween": "angle positif entre",
    "bitbybit.vector.positiveAngleBetween_description": "Mesure un angle positif entre deux vecteurs étant donné le vecteur de référence en degrés (toujours 0-360°). Exemple : convertit les angles signés négatifs en positifs en ajoutant 360° si nécessaire",
    "reference": "référence",
    "bitbybit.vector.addAll": "additionner tout",
    "addAll": "additionner tout",
    "bitbybit.vector.addAll_description": "Ajoute toutes les valeurs xyz des vecteurs élément par élément et crée un nouveau vecteur. Exemple : [[1,2,3], [4,5,6], [7,8,9]] → [12,15,18] (somme chaque colonne)",
    "sum": "somme",
    "bitbybit.vector.add": "additionner",
    "add": "additionner",
    "bitbybit.vector.add_description": "Ajoute deux vecteurs ensemble élément par élément. Exemple : [1,2,3] + [4,5,6] → [5,7,9]",
    "bitbybit.vector.all": "tout",
    "all": "tout",
    "bitbybit.vector.all_description": "Vérifie si le tableau booléen ne contient que des valeurs vraies, renvoie faux s'il y a un seul faux. Exemple : [true, true, true] → true, [true, false, true] → false",
    "boolean[]": "tableau booléen",
    "bitbybit.vector.cross": "produit vectoriel",
    "cross": "produit vectoriel",
    "bitbybit.vector.cross_description": "Calcule le produit vectoriel de deux vecteurs 3D (vecteur perpendiculaire aux deux entrées). Exemple : [1,0,0] × [0,1,0] → [0,0,1] (règle de la main droite)",
    "bitbybit.vector.distSquared": "distance au carré",
    "distSquared": "distance au carré",
    "bitbybit.vector.distSquared_description": "Calcule la distance au carré entre deux vecteurs (plus rapide que la distance, évite la racine carrée). Exemple : [0,0,0] à [3,4,0] → 25 (distance 5 au carré)",
    "bitbybit.vector.dist": "distance",
    "dist": "distance",
    "bitbybit.vector.dist_description": "Calcule la distance euclidienne entre deux vecteurs. Exemple : [0,0,0] à [3,4,0] → 5, [1,1] à [4,5] → 5",
    "bitbybit.vector.div": "diviser",
    "div": "diviser",
    "bitbybit.vector.div_description": "Divise chaque élément du vecteur par une valeur scalaire. Exemple : [10,20,30] ÷ 2 → [5,10,15]",
    "scalar": "scalaire",
    "bitbybit.vector.domain": "domaine",
    "domain": "domaine",
    "bitbybit.vector.domain_description": "Calcule le domaine (plage) entre les valeurs minimales et maximales du vecteur. Exemple : [1,3,5,9] → 8 (différence entre le dernier et le premier : 9-1)",
    "bitbybit.vector.dot": "produit scalaire",
    "dot": "produit scalaire",
    "bitbybit.vector.dot_description": "Calcule le produit scalaire entre deux vecteurs (mesure la similarité/projection). Exemple : [1,2,3] • [4,5,6] → 32 (1×4 + 2×5 + 3×6), vecteurs perpendiculaires → 0",
    "bitbybit.vector.finite": "fini",
    "finite": "fini",
    "bitbybit.vector.finite_description": "Vérifie si chaque élément du vecteur est fini et renvoie un tableau booléen. Exemple : [1, 2, Infinity, 3] → [true, true, false, true]",
    "validate": "valider",
    "bitbybit.vector.isZero": "est nul",
    "isZero": "est nul",
    "bitbybit.vector.isZero_description": "Vérifie si le vecteur a une longueur nulle (tous les éléments sont zéro). Exemple : [0,0,0] → true, [0,0,0.001] → false",
    "bitbybit.vector.lerp": "interpolation linéaire",
    "lerp": "interpolation linéaire",
    "bitbybit.vector.lerp_description": "Trouve un vecteur interpolé entre deux vecteurs en utilisant une fraction (interpolation linéaire). Exemple : [0,0,0] à [10,10,10] à 0.5 → [5,5,5], fraction=0 → premier, fraction=1 → second",
    "fraction": "fraction",
    "bitbybit.vector.max": "max",
    "max": "max",
    "bitbybit.vector.max_description": "Trouve la valeur maximale (la plus grande) dans le vecteur. Exemple : [3, 7, 2, 9, 1] → 9",
    "extract": "extraire",
    "bitbybit.vector.min": "min",
    "min": "min",
    "bitbybit.vector.min_description": "Trouve la valeur minimale (la plus petite) dans le vecteur. Exemple : [3, 7, 2, 9, 1] → 1",
    "bitbybit.vector.mul": "multiplier",
    "mul": "multiplier",
    "bitbybit.vector.mul_description": "Multiplie chaque élément du vecteur par une valeur scalaire. Exemple : [2,3,4] × 5 → [10,15,20]",
    "bitbybit.vector.neg": "opposer",
    "neg": "opposer",
    "bitbybit.vector.neg_description": "Inverse le vecteur (inverse le signe de chaque élément). Exemple : [5,-3,2] → [-5,3,-2]",
    "bitbybit.vector.normSquared": "norme au carré",
    "normSquared": "norme au carré",
    "bitbybit.vector.normSquared_description": "Calcule la norme au carré (grandeur/longueur au carré) du vecteur. Exemple : [3,4,0] → 25 (longueur 5 au carré)",
    "bitbybit.vector.norm": "norme",
    "norm": "norme",
    "bitbybit.vector.norm_description": "Calcule la norme (grandeur/longueur) du vecteur. Exemple : [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.vector.normalized": "normalisé",
    "normalized": "normalisé",
    "bitbybit.vector.normalized_description": "Normalise le vecteur en un vecteur unitaire qui a une longueur de 1 (maintient la direction, met à l'échelle la grandeur à 1). Exemple : [3,4,0] → [0.6,0.8,0], [10,0,0] → [1,0,0]",
    "bitbybit.vector.onRay": "sur rayon",
    "onRay": "sur rayon",
    "bitbybit.vector.onRay_description": "Trouve un point sur un rayon à une distance donnée de l'origine le long du vecteur de direction. Exemple : Point [0,0,0] + direction [1,0,0] à distance 5 → [5,0,0]",
    "bitbybit.vector.vectorXYZ": "vecteur xyz",
    "vectorXYZ": "vecteur xyz",
    "bitbybit.vector.vectorXYZ_description": "Crée un vecteur 3D à partir des coordonnées x, y, z. Exemple : x=1, y=2, z=3 → [1,2,3]",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vecteur xy",
    "vectorXY": "vecteur xy",
    "bitbybit.vector.vectorXY_description": "Crée un vecteur 2D à partir des coordonnées x, y. Exemple : x=3, y=4 → [3,4]",
    "bitbybit.vector.range": "plage",
    "range": "plage",
    "bitbybit.vector.range_description": "Crée un vecteur d'entiers de 0 à max (exclusif). Exemple : max=5 → [0,1,2,3,4], max=3 → [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "angle signé entre",
    "signedAngleBetween": "angle signé entre",
    "bitbybit.vector.signedAngleBetween_description": "Calcule l'angle signé entre deux vecteurs en utilisant un vecteur de référence (détermine la direction de rotation). Exemple : Renvoie un angle positif ou négatif selon la direction de rotation relative à la référence",
    "bitbybit.vector.span": "étendue",
    "span": "étendue",
    "bitbybit.vector.span_description": "Crée un vecteur contenant des nombres de min à max à un incrément de pas donné. Exemple : min=0, max=10, pas=2 → [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "étendue objets lissés",
    "spanEaseItems": "étendue objets lissés",
    "bitbybit.vector.spanEaseItems_description": "Crée un vecteur avec des nombres de min à max en utilisant une fonction d'assouplissement pour une distribution non linéaire. Exemple : min=0, max=100, nrItems=5, ease='easeInQuad' → crée des intervalles accélérés",
    "nrItems": "nb objets",
    "ease": "lissage",
    "Math.easeEnum": "énumération lissage math",
    "intervals": "intervalles",
    "bitbybit.vector.spanLinearItems": "étendue objets linéaires",
    "spanLinearItems": "étendue objets linéaires",
    "bitbybit.vector.spanLinearItems_description": "Crée un vecteur avec des nombres espacés uniformément de min à max avec un nombre spécifié d'éléments. Exemple : min=0, max=10, nrItems=5 → [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "soustraire",
    "sub": "soustraire",
    "bitbybit.vector.sub_description": "Soustrait le second vecteur du premier élément par élément. Exemple : [10,20,30] - [1,2,3] → [9,18,27]",
    "bitbybit.vector.sum": "somme",
    "bitbybit.vector.sum_description": "Somme toutes les valeurs dans le vecteur et renvoie un seul nombre. Exemple : [1,2,3,4] → 10, [5,10,15] → 30",
    "bitbybit.point.transformPoint": "transformer point",
    "transformPoint": "transformer point",
    "bitbybit.point.transformPoint_description": "Applique une matrice de transformation à un seul point (pivote, met à l'échelle ou translate). Exemple : point=[0,0,0] avec translation [5,5,0] → [5,5,0]",
    "transformation": "transformation",
    "Base.TransformMatrixes": "matrices transformation base",
    "bitbybit.point.transformPoints": "transformer points",
    "transformPoints": "transformer points",
    "bitbybit.point.transformPoints_description": "Applique la même matrice de transformation à plusieurs points (transformation par lot). Exemple : 5 points avec rotation 90° → les 5 points pivotés ensemble",
    "points": "points",
    "bitbybit.point.transformsForPoints": "transformations pour points",
    "transformsForPoints": "transformations pour points",
    "bitbybit.point.transformsForPoints_description": "Applique différentes matrices de transformation aux points correspondants (une transformation par point). Les tableaux doivent avoir la même longueur. Exemple : 3 points avec 3 translations différentes → chaque point déplacé indépendamment",
    "Base.TransformMatrixes[]": "tableau matrices transformation base",
    "bitbybit.point.translatePoints": "translater points",
    "translatePoints": "translater points",
    "bitbybit.point.translatePoints_description": "Déplace plusieurs points par un vecteur de translation (même décalage pour tous les points). Exemple : points=[[0,0,0], [1,0,0]], translation=[5,5,0] → [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "translater points avec vecteurs",
    "translatePointsWithVectors": "translater points avec vecteurs",
    "bitbybit.point.translatePointsWithVectors_description": "Déplace plusieurs points par des vecteurs de translation correspondants (un vecteur par point). Les tableaux doivent avoir la même longueur. Exemple : 3 points avec 3 vecteurs différents → chaque point déplacé par son vecteur correspondant",
    "bitbybit.point.translateXYZPoints": "translater points xyz",
    "translateXYZPoints": "translater points xyz",
    "bitbybit.point.translateXYZPoints_description": "Déplace plusieurs points par des valeurs X, Y, Z séparées (méthode pratique pour la translation). Exemple : points=[[0,0,0]], x=10, y=5, z=0 → [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "mettre à l'échelle points centre xyz",
    "scalePointsCenterXYZ": "mettre à l'échelle points centre xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "Met à l'échelle plusieurs points autour d'un point central avec différents facteurs par axe. Exemple : points=[[10,0,0]], centre=[5,0,0], echelleXyz=[2,1,1] → [[15,0,0]] (double la distance X du centre)",
    "bitbybit.point.rotatePointsCenterAxis": "pivoter points centre axe",
    "rotatePointsCenterAxis": "pivoter points centre axe",
    "bitbybit.point.rotatePointsCenterAxis_description": "Fait pivoter plusieurs points autour d'un point central le long d'un axe personnalisé. Exemple : points=[[10,0,0]], centre=[0,0,0], axe=[0,1,0], angle=90° → [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "distance point le plus proche des points",
    "closestPointFromPointsDistance": "distance point le plus proche des points",
    "bitbybit.point.closestPointFromPointsDistance_description": "Calcule la distance au point le plus proche dans une collection. Exemple : point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]] → 3 (distance à [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "index point le plus proche des points",
    "closestPointFromPointsIndex": "index point le plus proche des points",
    "bitbybit.point.closestPointFromPointsIndex_description": "Trouve l'index de tableau du point le plus proche dans une collection (index basé sur 1, pas sur 0). Exemple : point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]] → 3 (index de [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "point le plus proche des points",
    "closestPointFromPoints": "point le plus proche des points",
    "bitbybit.point.closestPointFromPoints_description": "Trouve le point le plus proche dans une collection par rapport à un point de référence. Exemple : point=[0,0,0], points=[[5,0,0], [10,0,0], [3,0,0]] → [3,0,0]",
    "bitbybit.point.distance": "distance",
    "bitbybit.point.distance_description": "Calcule la distance euclidienne entre deux points. Exemple : début=[0,0,0], fin=[3,4,0] → 5 (en utilisant le théorème de Pythagore : √(3²+4²))",
    "measure": "mesurer",
    "startPoint": "point de départ",
    "endPoint": "point d'arrivée",
    "bitbybit.point.distancesToPoints": "distances aux points",
    "distancesToPoints": "distances aux points",
    "bitbybit.point.distancesToPoints_description": "Calcule les distances d'un point de départ à plusieurs points de fin. Exemple : début=[0,0,0], pointsFin=[[3,0,0], [0,4,0], [5,0,0]] → [3, 4, 5]",
    "endPoints": "points d'arrivée",
    "bitbybit.point.multiplyPoint": "multiplier point",
    "multiplyPoint": "multiplier point",
    "bitbybit.point.multiplyPoint_description": "Duplique un point N fois (crée un tableau avec N copies du même point). Exemple : point=[5,5,0], quantitéPoints=3 → [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "nombre de points",
    "bitbybit.point.getX": "obtenir x",
    "getX": "obtenir x",
    "bitbybit.point.getX_description": "Extrait la coordonnée X d'un point. Exemple : point=[5,10,3] → 5",
    "bitbybit.point.getY": "obtenir y",
    "getY": "obtenir y",
    "bitbybit.point.getY_description": "Extrait la coordonnée Y d'un point. Exemple : point=[5,10,3] → 10",
    "bitbybit.point.getZ": "obtenir z",
    "getZ": "obtenir z",
    "bitbybit.point.getZ_description": "Extrait la coordonnée Z d'un point. Exemple : point=[5,10,3] → 3",
    "bitbybit.point.averagePoint": "point moyen",
    "averagePoint": "point moyen",
    "bitbybit.point.averagePoint_description": "Calcule le centroïde (position moyenne) de plusieurs points. Exemple : points=[[0,0,0], [10,0,0], [10,10,0]] → [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "point xyz",
    "pointXYZ": "point xyz",
    "bitbybit.point.pointXYZ_description": "Crée un point 3D à partir des coordonnées X, Y, Z. Exemple : x=10, y=5, z=3 → [10,5,3]",
    "bitbybit.point.pointXY": "point xy",
    "pointXY": "point xy",
    "bitbybit.point.pointXY_description": "Crée un point 2D à partir des coordonnées X, Y. Exemple : x=10, y=5 → [10,5]",
    "bitbybit.point.spiral": "spirale",
    "spiral": "spirale",
    "bitbybit.point.spiral_description": "Crée des points en spirale logarithmique en utilisant l'angle d'or ou un facteur d'élargissement personnalisé. Génère des motifs de spirale naturels courants dans la nature (tournesol, coquille de nautile). Exemple : nombrePoints=100, rayon=10, phi=1.618 → 100 points formant une spirale vers l'extérieur",
    "phi": "phi",
    "numberPoints": "nombre points",
    "widening": "élargissement",
    "factor": "facteur",
    "bitbybit.point.hexGrid": "grille hexagonale",
    "hexGrid": "grille hexagonale",
    "bitbybit.point.hexGrid_description": "Crée des points centraux de grille hexagonale sur le plan XY (motif en nid d'abeille). Taille de la grille contrôlée par le nombre d'hexagones, pas la largeur/hauteur. Exemple : rayonHexagone=1, nrHexagonesX=3, nrHexagonesY=3 → 9 centres hex en motif de grille",
    "nrHexagonsY": "nb hexagones y",
    "nrHexagonsX": "nb hexagones x",
    "radiusHexagon": "rayon hexagone",
    "orientOnCenter": "orienter sur centre",
    "pointsOnGround": "points au sol",
    "bitbybit.point.removeConsecutiveDuplicates": "supprimer doublons consécutifs",
    "removeConsecutiveDuplicates": "supprimer doublons consécutifs",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Supprime les points consécutifs en double du tableau dans la tolérance. Exemple : [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]] → [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "nettoyer",
    "bitbybit.line.convertToNurbsCurve": "convertir en courbe nurbs",
    "line": "ligne",
    "convertToNurbsCurve": "convertir en courbe nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "convertit la ligne en courbe nurbs",
    "LinePointsDto": "dto points ligne",
    "bitbybit.line.convertLinesToNurbsCurves": "convertir lignes en courbes nurbs",
    "convertLinesToNurbsCurves": "convertir lignes en courbes nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "convertit les lignes en tableau de courbes nurbs",
    "lines": "lignes",
    "LinePointsDto[]": "tableau dto points ligne",
    "bitbybit.line.getStartPoint": "obtenir point départ",
    "getStartPoint": "obtenir point départ",
    "bitbybit.line.getStartPoint_description": "Extrait le point de départ d'une ligne. Exemple : ligne={start:[0,0,0], end:[10,5,0]} → [0,0,0]",
    "bitbybit.line.getEndPoint": "obtenir point arrivée",
    "getEndPoint": "obtenir point arrivée",
    "bitbybit.line.getEndPoint_description": "Extrait le point de fin d'une ligne. Exemple : ligne={start:[0,0,0], end:[10,5,0]} → [10,5,0]",
    "bitbybit.line.length": "longueur",
    "bitbybit.line.length_description": "Calcule la longueur (distance) d'un segment de ligne. Exemple : ligne={start:[0,0,0], end:[3,4,0]} → 5 (en utilisant le théorème de Pythagore)",
    "bitbybit.line.reverse": "inverser",
    "reverse": "inverser",
    "bitbybit.line.reverse_description": "Inverse la direction de la ligne en échangeant les points de début et de fin. Exemple : ligne={start:[0,0,0], end:[10,5,0]} → {start:[10,5,0], end:[0,0,0]}",
    "bitbybit.line.transformLine": "transformer ligne",
    "transformLine": "transformer ligne",
    "bitbybit.line.transformLine_description": "Applique une matrice de transformation à la ligne (pivote, met à l'échelle ou translate les deux extrémités). Exemple : ligne={start:[0,0,0], end:[10,0,0]} avec translation [5,5,0] → {start:[5,5,0], end:[15,5,0]}",
    "bitbybit.line.transformsForLines": "transformations pour lignes",
    "transformsForLines": "transformations pour lignes",
    "bitbybit.line.transformsForLines_description": "Applique plusieurs transformations à plusieurs lignes (une transformation par ligne). Exemple : 3 lignes avec 3 matrices de transformation différentes → chaque ligne déplacée indépendamment",
    "bitbybit.line.create": "créer",
    "bitbybit.line.create_description": "Crée une ligne à partir de deux points (objet ligne avec propriétés start et end). Exemple : start=[0,0,0], end=[10,5,0] → {start:[0,0,0], end:[10,5,0]}",
    "bitbybit.line.createAsync": "async",
    "createAsync": "async",
    "bitbybit.line.createAsync_description": "crée une ligne à partir de points async",
    "bitbybit.line.getPointOnLine": "obtenir point sur ligne",
    "getPointOnLine": "obtenir point sur ligne",
    "bitbybit.line.getPointOnLine_description": "Calcule le point au paramètre t le long du segment de ligne (0=début, 1=fin, interpolation linéaire). Exemple : ligne={start:[0,0,0], end:[10,0,0]}, param=0.5 → [5,0,0] (point médian)",
    "param": "param",
    "bitbybit.line.linesBetweenPoints": "lignes entre points",
    "linesBetweenPoints": "lignes entre points",
    "bitbybit.line.linesBetweenPoints_description": "Crée des segments de ligne reliant des points consécutifs dans une liste (forme un chemin polyligne). Exemple : points=[[0,0,0], [5,0,0], [5,5,0]] → 2 lignes : [0→5] et [5→5,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "lignes entre points départ et arrivée",
    "linesBetweenStartAndEndPoints": "lignes entre points départ et arrivée",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Crée des lignes en appariant les points de début et de fin correspondants de deux tableaux. Filtre les lignes de longueur nulle. Exemple : débuts=[[0,0,0], [5,0,0]], fins=[[0,5,0], [5,5,0]] → 2 lignes reliant les points appariés",
    "startPoints": "points de départ",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "lignes entre points départ et arrivée async",
    "linesBetweenStartAndEndPointsAsync": "lignes entre points départ et arrivée async",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "crée des lignes entre les points de départ et d'arrivée avec des entrées async",
    "bitbybit.polyline.convertToNurbsCurve": "convertir en courbe nurbs",
    "polyline": "polyligne",
    "bitbybit.polyline.convertToNurbsCurve_description": "convertit la polyligne en courbe nurbs",
    "PolylinePropertiesDto": "dto propriétés polyligne",
    "bitbybit.polyline.length": "longueur",
    "bitbybit.polyline.length_description": "Calcule la longueur totale de la polyligne en additionnant les distances entre les points consécutifs. Exemple : points=[[0,0,0], [3,0,0], [3,4,0]] → 3 + 4 = 7",
    "bitbybit.polyline.countPoints": "compter points",
    "countPoints": "compter points",
    "bitbybit.polyline.countPoints_description": "Compte le nombre de points dans la polyligne. Exemple : polyligne avec points=[[0,0,0], [1,0,0], [1,1,0]] → 3",
    "bitbybit.polyline.getPoints": "obtenir points",
    "getPoints": "obtenir points",
    "bitbybit.polyline.getPoints_description": "Extrait le tableau de points de l'objet polyligne. Exemple : polyligne={points:[[0,0,0], [1,0,0]]} → [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "inverser",
    "bitbybit.polyline.reverse_description": "Inverse l'ordre des points de la polyligne (inverse la direction). Exemple : points=[[0,0,0], [1,0,0], [2,0,0]] → [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "transformer polyligne",
    "transformPolyline": "transformer polyligne",
    "bitbybit.polyline.transformPolyline_description": "Applique une matrice de transformation à tous les points de la polyligne (pivote, met à l'échelle ou translate). Exemple : polyligne avec 4 points, translation [5,0,0] → tous les points déplacés de +5 dans la direction X",
    "bitbybit.polyline.create": "créer",
    "bitbybit.polyline.create_description": "Crée une polyligne à partir d'un tableau de points avec un indicateur isClosed optionnel. Exemple : points=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true → {points:..., isClosed:true}",
    "isClosed": "est fermé",
    "string | number[]": "chaîne ou tableau de nombres",
    "bitbybit.occt.deleteShape": "supprimer forme",
    "occt": "occt",
    "deleteShape": "supprimer forme",
    "bitbybit.occt.deleteShape_description": "Supprime la forme du cache pour maintenir une faible utilisation de la mémoire",
    "bitbybit.occt.deleteShapes": "supprimer formes",
    "deleteShapes": "supprimer formes",
    "bitbybit.occt.deleteShapes_description": "Supprime les formes du cache pour maintenir une faible utilisation de la mémoire",
    "shapes": "formes",
    "T[]": "tableau t",
    "bitbybit.occt.cleanAllCache": "nettoyer tout le cache",
    "cleanAllCache": "nettoyer tout le cache",
    "bitbybit.occt.cleanAllCache_description": "Nettoie tout le cache et toutes les formes de la mémoire",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "sommet depuis xyz",
    "vertex": "sommet",
    "vertexFromXYZ": "sommet depuis xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Crée une forme de sommet à partir des coordonnées x y z",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "sommet depuis point",
    "vertexFromPoint": "sommet depuis point",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Crée une forme de sommet à partir d'un point",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "sommets depuis points",
    "verticesFromPoints": "sommets depuis points",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "crée des sommets à partir de points",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "composé sommets depuis points",
    "verticesCompoundFromPoints": "composé sommets depuis points",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Crée une forme composée contenant plusieurs sommets. Cela accélère simplement le rendu et permet d'appliquer facilement des transformations occt sur des groupes de sommets.",
    "bitbybit.occt.shapes.vertex.getVertices": "obtenir sommets",
    "getVertices": "obtenir sommets",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Obtenir tous les sommets dans la liste d'une forme",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "obtenir sommets comme points",
    "getVerticesAsPoints": "obtenir sommets comme points",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Obtenir tous les sommets dans la liste d'une forme sous forme de points",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "sommets vers points",
    "verticesToPoints": "sommets vers points",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforme les sommets en points",
    "transform": "transformer",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "sommet vers point",
    "vertexToPoint": "sommet vers point",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Transformer le sommet en point",
    "bitbybit.occt.shapes.vertex.projectPoints": "projeter points",
    "projectPoints": "projeter points",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "projette les points sur la forme",
    "place": "placer",
    "projectionType": "type projection",
    "pointProjectionTypeEnum": "énumération type projection point",
    "bitbybit.occt.shapes.edge.line": "ligne",
    "edge": "arête",
    "bitbybit.occt.shapes.edge.line_description": "crée une arête linéaire entre deux points",
    "primitives": "primitives",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arc par trois points",
    "arcThroughThreePoints": "arc par trois points",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Crée une arête en arc entre trois points",
    "middle": "milieu",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arc par deux points et tangente",
    "arcThroughTwoPointsAndTangent": "arc par deux points et tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Crée une arête en arc entre deux points étant donné le vecteur de direction tangent au premier point.",
    "tangentVec": "vecteur tangente",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arc depuis cercle et deux points",
    "arcFromCircleAndTwoPoints": "arc depuis cercle et deux points",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Crée une arête en arc entre deux points sur un cercle",
    "circle": "cercle",
    "sense": "sens",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arc depuis cercle et deux angles",
    "arcFromCircleAndTwoAngles": "arc depuis cercle et deux angles",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Crée une arête en arc entre deux angles alpha sur un cercle",
    "alphaAngle1": "angle alpha 1",
    "alphaAngle2": "angle alpha 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arc depuis cercle point et angle",
    "arcFromCirclePointAndAngle": "arc depuis cercle point et angle",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Crée une arête en arc entre le point sur un cercle et un angle alpha donné",
    "alphaAngle": "angle alpha",
    "bitbybit.occt.shapes.edge.createCircleEdge": "arête cercle",
    "createCircleEdge": "arête cercle",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "crée une arête de cercle opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "arête ellipse",
    "createEllipseEdge": "arête ellipse",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "crée une arête d'ellipse opencascade",
    "radiusMinor": "rayon mineur",
    "radiusMajor": "rayon majeur",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "supprimer arêtes internes",
    "removeInternalEdges": "supprimer arêtes internes",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Supprime les faces internes pour la forme",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "créer arête depuis courbe geom 2d et surface",
    "makeEdgeFromGeom2dCurveAndSurface": "créer arête depuis courbe geom 2d et surface",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Crée une arête à partir d'une courbe géométrique et d'une surface géométrique",
    "curve": "courbe",
    "surface": "surface",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "obtenir arête",
    "getEdge": "obtenir arête",
    "bitbybit.occt.shapes.edge.getEdge_description": "Obtient l'arête en fournissant un index de la forme",
    "index": "index",
    "bitbybit.occt.shapes.edge.getEdges": "obtenir arêtes",
    "getEdges": "obtenir arêtes",
    "bitbybit.occt.shapes.edge.getEdges_description": "Obtient les arêtes d'une forme dans une liste",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "obtenir arêtes le long du fil",
    "getEdgesAlongWire": "obtenir arêtes le long du fil",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Obtient les arêtes d'un fil ordonnées le long de la direction du fil",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "obtenir arêtes circulaires le long du fil",
    "getCircularEdgesAlongWire": "obtenir arêtes circulaires le long du fil",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Obtient les arêtes circulaires d'un fil ordonnées le long de la direction du fil",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "obtenir arêtes linéaires le long du fil",
    "getLinearEdgesAlongWire": "obtenir arêtes linéaires le long du fil",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Obtient les arêtes linéaires d'un fil ordonnées le long de la direction du fil",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "obtenir points coins arêtes pour forme",
    "getCornerPointsOfEdgesForShape": "obtenir points coins arêtes pour forme",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Obtient les points de coin des arêtes pour une forme. Il n'y a pas de garantie d'ordre ici. Tous les doublons sont supprimés, donc lorsque trois arêtes forment un coin, cela sera représenté par un seul point dans la liste.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "obtenir longueur arête",
    "getEdgeLength": "obtenir longueur arête",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Obtient la longueur de l'arête",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "obtenir longueurs arêtes de forme",
    "getEdgeLengthsOfShape": "obtenir longueurs arêtes de forme",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Obtient les longueurs des arêtes de la forme",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "obtenir longueurs arêtes",
    "getEdgesLengths": "obtenir longueurs arêtes",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Obtient les longueurs des arêtes",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "obtenir centre masse arête",
    "getEdgeCenterOfMass": "obtenir centre masse arête",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Obtient le centre de masse pour l'arête",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "obtenir centres masse arêtes",
    "getEdgesCentersOfMass": "obtenir centres masse arêtes",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Obtient les centres de masse pour les arêtes",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "obtenir point centre arête circulaire",
    "getCircularEdgeCenterPoint": "obtenir point centre arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Obtient le point central de l'arête circulaire. Si l'arête n'est pas circulaire, le point ne sera pas renvoyé.",
    "get circular edge": "obtenir arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "obtenir rayon arête circulaire",
    "getCircularEdgeRadius": "obtenir rayon arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Obtient le rayon de l'arête circulaire. Si l'arête n'est pas circulaire, le rayon ne sera pas renvoyé.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "obtenir direction plan arête circulaire",
    "getCircularEdgePlaneDirection": "obtenir direction plan arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Obtient le vecteur de direction du plan de l'arête circulaire. Si l'arête n'est pas circulaire, le vecteur de direction ne sera pas renvoyé.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "point sur arête au param",
    "pointOnEdgeAtParam": "point sur arête au param",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Obtient le point sur l'arête au paramètre",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "points sur arêtes au param",
    "pointsOnEdgesAtParam": "points sur arêtes au param",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Obtient les points sur les arêtes au paramètre",
    "bitbybit.occt.shapes.edge.edgesToPoints": "arêtes vers points",
    "edgesToPoints": "arêtes vers points",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Obtient les points de toutes les arêtes d'une forme dans des listes séparées pour chaque arête",
    "angularDeflection": "déviation angulaire",
    "curvatureDeflection": "déviation courbure",
    "minimumOfPoints": "minimum de points",
    "uTolerance": "tolérance u",
    "minimumLength": "longueur minimale",
    "bitbybit.occt.shapes.edge.reversedEdge": "arête inversée",
    "reversedEdge": "arête inversée",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Calcule l'arête inversée à partir de l'arête d'entrée",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangente sur arête au param",
    "tangentOnEdgeAtParam": "tangente sur arête au param",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Obtient le vecteur tangent sur l'arête au paramètre",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangentes sur arêtes au param",
    "tangentsOnEdgesAtParam": "tangentes sur arêtes au param",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Obtient les vecteurs tangents sur les arêtes au paramètre",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "point sur arête à la longueur",
    "pointOnEdgeAtLength": "point sur arête à la longueur",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Obtient le point sur l'arête à la longueur",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "points sur arêtes à la longueur",
    "pointsOnEdgesAtLength": "points sur arêtes à la longueur",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Obtient les points sur les arêtes à la longueur",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangente sur arête à la longueur",
    "tangentOnEdgeAtLength": "tangente sur arête à la longueur",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Obtient le vecteur tangent sur l'arête à la longueur",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangentes sur arêtes à la longueur",
    "tangentsOnEdgesAtLength": "tangentes sur arêtes à la longueur",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Obtient les vecteurs tangents sur les arêtes à la longueur",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "point départ sur arête",
    "startPointOnEdge": "point départ sur arête",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Obtient le point de départ sur l'arête",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "points départ sur arêtes",
    "startPointsOnEdges": "points départ sur arêtes",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Obtient les points de départ sur les arêtes",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "point arrivée sur arête",
    "endPointOnEdge": "point arrivée sur arête",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Obtient le point de fin sur l'arête",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "points arrivée sur arêtes",
    "endPointsOnEdges": "points arrivée sur arêtes",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Obtient les points de fin sur les arêtes",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "diviser arête par params en points",
    "divideEdgeByParamsToPoints": "diviser arête par params en points",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divise l'arête par paramètres en points",
    "nrOfDivisions": "nb divisions",
    "removeStartPoint": "supprimer point départ",
    "removeEndPoint": "supprimer point arrivée",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "diviser arêtes par params en points",
    "divideEdgesByParamsToPoints": "diviser arêtes par params en points",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divise les arêtes par paramètres en points",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "diviser arête par distance égale en points",
    "divideEdgeByEqualDistanceToPoints": "diviser arête par distance égale en points",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divise l'arête par longueur en points",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "diviser arêtes par distance égale en points",
    "divideEdgesByEqualDistanceToPoints": "diviser arêtes par distance égale en points",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divise les arêtes par longueur en points",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "lignes tan contraintes de deux pts à cercle",
    "constraintTanLinesFromTwoPtsToCircle": "lignes tan contraintes de deux pts à cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Crée des lignes à partir de deux points donnés jusqu'aux emplacements tangents du cercle",
    "constraint": "contrainte",
    "point1": "point 1",
    "point2": "point 2",
    "positionResult": "résultat position",
    "positionResultEnum": "énumération résultat position",
    "circleRemainder": "reste cercle",
    "circleInclusionEnum": "énumération inclusion cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "lignes tan contraintes de pt à cercle",
    "constraintTanLinesFromPtToCircle": "lignes tan contraintes de pt à cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Crée des lignes à partir d'un point donné jusqu'aux emplacements tangents du cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "lignes tan contraintes sur deux cercles",
    "constraintTanLinesOnTwoCircles": "lignes tan contraintes sur deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Crée des lignes tangentes entre deux cercles.",
    "circle1": "cercle 1",
    "circle2": "cercle 2",
    "circleRemainders": "restes cercles",
    "twoCircleInclusionEnum": "énumération inclusion deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "cercles tan contraints sur deux cercles",
    "constraintTanCirclesOnTwoCircles": "cercles tan contraints sur deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Crée des cercles tangents entre deux cercles.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "cercles tan contraints sur cercle et pt",
    "constraintTanCirclesOnCircleAndPnt": "cercles tan contraints sur cercle et pt",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Crée des cercles tangents entre un point et un cercle.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "est arête linéaire",
    "isEdgeLinear": "est arête linéaire",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Vérifie si une arête est linéaire",
    "is": "est",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "est arête circulaire",
    "isEdgeCircular": "est arête circulaire",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Vérifie si une arête est circulaire",
    "bitbybit.occt.shapes.wire.createPolygonWire": "fil polygone",
    "wire": "fil",
    "createPolygonWire": "fil polygone",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "crée un fil polygone opencascade",
    "via points": "via points",
    "bitbybit.occt.shapes.wire.createPolygons": "polygones",
    "createPolygons": "polygones",
    "bitbybit.occt.shapes.wire.createPolygons_description": "crée des polygones opencascade",
    "multiple": "multiple",
    "polygons": "polygones",
    "PolygonDto[]": "tableau dto polygone",
    "returnCompound": "retourner composé",
    "bitbybit.occt.shapes.wire.createLineWire": "fil ligne",
    "createLineWire": "fil ligne",
    "bitbybit.occt.shapes.wire.createLineWire_description": "crée un fil ligne opencascade",
    "bitbybit.occt.shapes.wire.createLines": "lignes",
    "createLines": "lignes",
    "bitbybit.occt.shapes.wire.createLines_description": "crée des lignes opencascade",
    "LineDto[]": "tableau dto ligne",
    "bitbybit.occt.shapes.wire.splitOnPoints": "diviser sur points",
    "splitOnPoints": "diviser sur points",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Divise un fil sur un ensemble de points donnés",
    "bitbybit.occt.shapes.wire.wiresToPoints": "fils vers points",
    "wiresToPoints": "fils vers points",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Transforme les fils de forme en points ordonnés dans des listes. Cela supprime également les points dupliqués entre les points de début et de fin des arêtes consécutives sur le fil",
    "bitbybit.occt.shapes.wire.createPolylineWire": "fil polyligne",
    "createPolylineWire": "fil polyligne",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "crée un fil polyligne opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zig zag entre deux fils",
    "createZigZagBetweenTwoWires": "zig zag entre deux fils",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "crée un zig zag entre deux fils",
    "via wires": "via fils",
    "wire1": "fil 1",
    "wire2": "fil 2",
    "nrZigZags": "nb zig zags",
    "inverse": "inverse",
    "divideByEqualDistance": "diviser par distance égale",
    "zigZagsPerEdge": "zig zags par arête",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "fil depuis deux cercles tan",
    "createWireFromTwoCirclesTan": "fil depuis deux cercles tan",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Crée un fil tangent enfermant deux cercles planaires",
    "keepLines": "garder lignes",
    "twoSidesStrictEnum": "énumération strict deux côtés",
    "fourSidesStrictEnum": "énumération strict quatre côtés",
    "bitbybit.occt.shapes.wire.createPolylines": "polylignes",
    "createPolylines": "polylignes",
    "bitbybit.occt.shapes.wire.createPolylines_description": "crée des fils polylignes opencascade",
    "polylines": "polylignes",
    "PolylineDto[]": "tableau dto polyligne",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "crée un fil bezier opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "bezier poids",
    "createBezierWeights": "bezier poids",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "crée un fil bezier opencascade avec poids",
    "weights": "poids",
    "bitbybit.occt.shapes.wire.createBezierWires": "fils bezier",
    "createBezierWires": "fils bezier",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "crée des fils bezier opencascade",
    "bezierWires": "fils bezier",
    "BezierDto[]": "tableau dto bezier",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpoler points",
    "interpolatePoints": "interpoler points",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Crée un fil BSpline OpenCascade à partir de points. Cette méthode peut être utilisée pour créer des boucles (périodiques) bien formées.",
    "periodic": "périodique",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpoler fils",
    "interpolateWires": "interpoler fils",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Crée plusieurs fils interpolés OpenCascade",
    "interpolations": "interpolations",
    "InterpolationDto[]": "tableau dto interpolation",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "crée un fil bspline opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "crée des fils bspline opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "tableau dto bspline",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combiner arêtes et fils en un fil",
    "combineEdgesAndWiresIntoAWire": "combiner arêtes et fils en un fil",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Combine des arêtes et des fils OpenCascade en un seul fil",
    "build": "construire",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "fil depuis arête",
    "createWireFromEdge": "fil depuis arête",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "crée un fil à partir d'une arête",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "ajouter arêtes et fils au fil",
    "addEdgesAndWiresToWire": "ajouter arêtes et fils au fil",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Ajoute des arêtes et des fils OpenCascade dans un autre fil",
    "U[]": "tableau u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "diviser fil par params en points",
    "divideWireByParamsToPoints": "diviser fil par params en points",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Divise le fil OpenCascade en points en suivant aveuglément son espace paramétrique",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "diviser fils par params en points",
    "divideWiresByParamsToPoints": "diviser fils par params en points",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Divise les fils OpenCascade en points en suivant aveuglément son espace paramétrique",
    "extract from wires": "extraire des fils",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "diviser fil par distance égale en points",
    "divideWireByEqualDistanceToPoints": "diviser fil par distance égale en points",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Divise le fil OpenCascade en points à distance égale",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "diviser fils par distance égale en points",
    "divideWiresByEqualDistanceToPoints": "diviser fils par distance égale en points",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Divise les fils OpenCascade en points à distance égale",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "point sur fil au param",
    "pointOnWireAtParam": "point sur fil au param",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Évalue un point sur un fil à une valeur de paramètre entre 0 et 1, étant les points de début et de fin",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "point sur fil à la longueur",
    "pointOnWireAtLength": "point sur fil à la longueur",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Évalue un point sur un fil à une certaine longueur",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "points sur fil aux longueurs",
    "pointsOnWireAtLengths": "points sur fil aux longueurs",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Évalue des points sur un fil à certaines longueurs",
    "lengths": "longueurs",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "points sur fil à longueur égale",
    "pointsOnWireAtEqualLength": "points sur fil à longueur égale",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Évalue des points sur un fil à longueur égale",
    "tryNext": "essayer suivant",
    "includeFirst": "inclure premier",
    "includeLast": "inclure dernier",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "points sur fil au motif de longueurs",
    "pointsOnWireAtPatternOfLengths": "points sur fil au motif de longueurs",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Évalue des points sur un fil selon un motif de longueurs",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangente sur fil au param",
    "tangentOnWireAtParam": "tangente sur fil au param",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Évalue le vecteur tangent sur un fil à une valeur de paramètre entre 0 et 1, étant les points de début et de fin",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangente sur fil à la longueur",
    "tangentOnWireAtLength": "tangente sur fil à la longueur",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Évalue le vecteur tangent sur un fil à une certaine longueur",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "dérivées sur fil à la longueur",
    "derivativesOnWireAtLength": "dérivées sur fil à la longueur",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Calcule 3 vecteurs dérivés d'une courbe à une longueur donnée",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "dérivées sur fil au param",
    "derivativesOnWireAtParam": "dérivées sur fil au param",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Calcule 3 vecteurs dérivés d'une courbe sur un paramètre entre 0 et 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "point départ sur fil",
    "startPointOnWire": "point départ sur fil",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Calcule le point de départ sur le fil au paramètre 0",
    "bitbybit.occt.shapes.wire.endPointOnWire": "point arrivée sur fil",
    "endPointOnWire": "point arrivée sur fil",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Calcule le point de fin sur le fil au paramètre 1",
    "bitbybit.occt.shapes.wire.createCircleWire": "fil cercle",
    "createCircleWire": "fil cercle",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "crée un fil cercle opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "fil carré",
    "createSquareWire": "fil carré",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "crée un fil carré opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "fil étoile",
    "createStarWire": "fil étoile",
    "bitbybit.occt.shapes.wire.createStarWire_description": "crée un fil étoile opencascade",
    "numRays": "nb rayons",
    "outerRadius": "rayon extérieur",
    "innerRadius": "rayon intérieur",
    "offsetOuterEdges": "décalage arêtes extérieures",
    "half": "moitié",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "fil sapin noël",
    "createChristmasTreeWire": "fil sapin noël",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "crée un fil en forme de sapin de noël",
    "innerDist": "dist intérieure",
    "outerDist": "dist extérieure",
    "nrSkirts": "nb jupes",
    "trunkHeight": "hauteur tronc",
    "trunkWidth": "largeur tronc",
    "bitbybit.occt.shapes.wire.createNGonWire": "fil ngon",
    "createNGonWire": "fil ngon",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Crée un fil n-gone OpenCascade",
    "nrCorners": "nb coins",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "fil parallélogramme",
    "createParallelogramWire": "fil parallélogramme",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Crée un fil parallélogramme n",
    "aroundCenter": "autour centre",
    "bitbybit.occt.shapes.wire.createHeartWire": "fil coeur",
    "createHeartWire": "fil coeur",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Crée un fil en cœur",
    "sizeApprox": "taille approx",
    "bitbybit.occt.shapes.wire.createRectangleWire": "fil rectangle",
    "createRectangleWire": "fil rectangle",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "crée un fil rectangle opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "fil polygone L",
    "createLPolygonWire": "fil polygone L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "crée un fil polygone L opencascade",
    "widthFirst": "largeur première",
    "lengthFirst": "longueur première",
    "widthSecond": "largeur seconde",
    "lengthSecond": "longueur seconde",
    "align": "aligner",
    "directionEnum": "énumération direction",
    "bitbybit.occt.shapes.wire.createEllipseWire": "fil ellipse",
    "createEllipseWire": "fil ellipse",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "crée un fil ellipse opencascade",
    "bitbybit.occt.shapes.wire.textWires": "Contours de texte",
    "textWires": "Contours de texte",
    "bitbybit.occt.shapes.wire.textWires_description": "Crée des contours de texte OpenCascade basés sur la police simplex créée par le Dr A. V. Hershey.",
    "xOffset": "décalage x",
    "yOffset": "décalage y",
    "letterSpacing": "espacement des lettres",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "décalage d'extrusion",
    "bitbybit.occt.shapes.wire.getWire": "obtenir fil",
    "getWire": "obtenir fil",
    "bitbybit.occt.shapes.wire.getWire_description": "Obtient le fil en fournissant un index de la forme",
    "bitbybit.occt.shapes.wire.getWires": "obtenir fils",
    "getWires": "obtenir fils",
    "bitbybit.occt.shapes.wire.getWires_description": "Obtient tous les fils de la forme",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "obtenir centre masse fil",
    "getWireCenterOfMass": "obtenir centre masse fil",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Obtenir le point centre de masse du fil",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "obtenir centres masse fils",
    "getWiresCentersOfMass": "obtenir centres masse fils",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Obtenir les points centres de masse des fils",
    "bitbybit.occt.shapes.wire.reversedWire": "fil inversé",
    "reversedWire": "fil inversé",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Calcule le fil inversé à partir du fil d'entrée",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "fil inversé depuis arêtes inversées",
    "reversedWireFromReversedEdges": "fil inversé depuis arêtes inversées",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Calcule le fil inversé en inversant toutes les arêtes et en les combinant en un nouveau fil",
    "bitbybit.occt.shapes.wire.isWireClosed": "est fil fermé",
    "isWireClosed": "est fil fermé",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Vérifie si le fil est fermé",
    "bitbybit.occt.shapes.wire.getWireLength": "obtenir longueur fil",
    "getWireLength": "obtenir longueur fil",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Obtient la longueur du fil",
    "bitbybit.occt.shapes.wire.getWiresLengths": "obtenir longueurs fils",
    "getWiresLengths": "obtenir longueurs fils",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Obtient les longueurs des fils",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "placer fil sur face",
    "placeWireOnFace": "placer fil sur face",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Place un fil sur la face en mappant ses coordonnées 2d sur l'espace UV. Le fil doit être positionné sur le plan XZ du sol pour que cela fonctionne.",
    "face": "face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "placer fils sur face",
    "placeWiresOnFace": "placer fils sur face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Place plusieurs fils sur la face en mappant leurs coordonnées 2d sur l'espace UV. Les fils doivent être positionnés sur le plan XZ du sol pour que cela fonctionne.",
    "wires": "fils",
    "bitbybit.occt.shapes.wire.closeOpenWire": "fermer fil ouvert",
    "closeOpenWire": "fermer fil ouvert",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Ferme le fil ouvert avec une arête droite supplémentaire joignant les points de début et de fin",
    "bitbybit.occt.shapes.wire.project": "projeter",
    "project": "projeter",
    "bitbybit.occt.shapes.wire.project_description": "Projeter le fil sur la forme",
    "bitbybit.occt.shapes.wire.projectWires": "projeter fils",
    "projectWires": "projeter fils",
    "bitbybit.occt.shapes.wire.projectWires_description": "Projeter plusieurs fils sur la forme",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "faces depuis fils sur face",
    "createFacesFromWiresOnFace": "faces depuis fils sur face",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Crée des faces à partir de fils sur face",
    "inside": "intérieur",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "face depuis fil sur face",
    "createFaceFromWireOnFace": "face depuis fil sur face",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Crée une face à partir d'un fil sur face",
    "bitbybit.occt.shapes.face.createFaceFromWire": "face depuis fil",
    "createFaceFromWire": "face depuis fil",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Crée une face à partir d'un fil",
    "planar": "planaire",
    "bitbybit.occt.shapes.face.createFaceFromWires": "face depuis fils",
    "createFaceFromWires": "face depuis fils",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Crée une face à partir de fils. Cela peut produire des faces creuses.",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "face depuis fils sur face",
    "createFaceFromWiresOnFace": "face depuis fils sur face",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Crée une face à partir de fils sur la face guide. Cela peut produire des faces creuses.",
    "bitbybit.occt.shapes.face.createFacesFromWires": "faces depuis fils",
    "createFacesFromWires": "faces depuis fils",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "crée des faces à partir de fils",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "face depuis multiples fils tan cercles",
    "createFaceFromMultipleCircleTanWires": "face depuis multiples fils tan cercles",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "crée une face à partir de multiples fils tangents de cercles",
    "circles": "cercles",
    "combination": "combinaison",
    "combinationCirclesForFaceEnum": "énumération combinaison cercles pour face",
    "unify": "unifier",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "face depuis multiples collections fils tan cercles",
    "createFaceFromMultipleCircleTanWireCollections": "face depuis multiples collections fils tan cercles",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "crée une face à partir de multiples collections de fils tangents de cercles",
    "listsOfCircles": "listes de cercles",
    "T[][]": "tableau tableau t",
    "bitbybit.occt.shapes.face.faceFromSurface": "face depuis surface",
    "faceFromSurface": "face depuis surface",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Crée une face à partir de la surface",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "face depuis surface et fil",
    "faceFromSurfaceAndWire": "face depuis surface et fil",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Crée une face à partir de la surface et d'un fil",
    "bitbybit.occt.shapes.face.createPolygonFace": "face polygone",
    "createPolygonFace": "face polygone",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "crée une face polygone opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "face cercle",
    "createCircleFace": "face cercle",
    "bitbybit.occt.shapes.face.createCircleFace_description": "crée une face cercle opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "face ellipse",
    "createEllipseFace": "face ellipse",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "crée une face ellipse opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "face carrée",
    "createSquareFace": "face carrée",
    "bitbybit.occt.shapes.face.createSquareFace_description": "crée une face carrée opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "face rectangle",
    "createRectangleFace": "face rectangle",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "crée une face rectangle opencascade",
    "bitbybit.occt.shapes.face.getFace": "obtenir face",
    "getFace": "obtenir face",
    "bitbybit.occt.shapes.face.getFace_description": "Obtient la face en fournissant un index de la forme",
    "bitbybit.occt.shapes.face.getFaces": "obtenir faces",
    "getFaces": "obtenir faces",
    "bitbybit.occt.shapes.face.getFaces_description": "Obtient les faces de la forme dans une liste",
    "bitbybit.occt.shapes.face.reversedFace": "face inversée",
    "reversedFace": "face inversée",
    "bitbybit.occt.shapes.face.reversedFace_description": "Calcule la face inversée à partir de la face d'entrée",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdiviser en points",
    "subdivideToPoints": "subdiviser en points",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Subdivise une face en grille de points",
    "nrDivisionsU": "nb divisions u",
    "nrDivisionsV": "nb divisions v",
    "shiftHalfStepU": "décaler demi pas u",
    "removeStartEdgeU": "supprimer arête début u",
    "removeEndEdgeU": "supprimer arête fin u",
    "shiftHalfStepV": "décaler demi pas v",
    "removeStartEdgeV": "supprimer arête début v",
    "removeEndEdgeV": "supprimer arête fin v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdiviser en fils",
    "subdivideToWires": "subdiviser en fils",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Subdivise une face en fils",
    "nrDivisions": "nb divisions",
    "isU": "est u",
    "shiftHalfStep": "décaler demi pas",
    "removeStart": "supprimer début",
    "removeEnd": "supprimer fin",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdiviser en fils rectangle",
    "subdivideToRectangleWires": "subdiviser en fils rectangle",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Subdivise une face en fils rectangulaires",
    "patterns": "motifs",
    "nrRectanglesU": "nb rectangles u",
    "nrRectanglesV": "nb rectangles v",
    "scalePatternU": "motif échelle u",
    "scalePatternV": "motif échelle v",
    "filletPattern": "motif congé",
    "inclusionPattern": "motif inclusion",
    "offsetFromBorderU": "décalage bordure u",
    "offsetFromBorderV": "décalage bordure v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdiviser en trous rectangle",
    "subdivideToRectangleHoles": "subdiviser en trous rectangle",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Subdivise une face en fils rectangulaires",
    "holesToFaces": "trous vers faces",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdiviser en points contrôlés",
    "subdivideToPointsControlled": "subdiviser en points contrôlés",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Subdivise une face en grille de points avec décalages et suppressions sur les énièmes rangées ou colonnes uv",
    "shiftHalfStepNthU": "décaler demi pas nième u",
    "shiftHalfStepUOffsetN": "décaler demi pas décalage u n",
    "removeStartEdgeNthU": "supprimer arête début nième u",
    "removeStartEdgeUOffsetN": "supprimer arête début décalage u n",
    "removeEndEdgeNthU": "supprimer arête fin nième u",
    "removeEndEdgeUOffsetN": "supprimer arête fin décalage u n",
    "shiftHalfStepNthV": "décaler demi pas nième v",
    "shiftHalfStepVOffsetN": "décaler demi pas décalage v n",
    "removeStartEdgeNthV": "supprimer arête début nième v",
    "removeStartEdgeVOffsetN": "supprimer arête début décalage v n",
    "removeEndEdgeNthV": "supprimer arête fin nième v",
    "removeEndEdgeVOffsetN": "supprimer arête fin décalage v n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdiviser en normales",
    "subdivideToNormals": "subdiviser en normales",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Subdivise une face en grille de normales",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdiviser en uv",
    "subdivideToUV": "subdiviser en uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Subdivise une face en grille uv",
    "bitbybit.occt.shapes.face.pointOnUV": "point sur uv",
    "pointOnUV": "point sur uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Obtenir un point sur UV où U et V sont décrits entre 0 et 1. Ceux-ci seront mappés aux limites réelles.",
    "paramU": "param u",
    "paramV": "param v",
    "bitbybit.occt.shapes.face.normalOnUV": "normale sur uv",
    "normalOnUV": "normale sur uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Obtenir une normale sur UV où U et V sont décrits entre 0 et 1. Ceux-ci seront mappés aux limites réelles.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "points sur uvs",
    "pointsOnUVs": "points sur uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Obtenir des points sur UVs où U et V sont décrits entre 0 et 1 dans des tableaux bidimensionnels. Ceux-ci seront mappés aux limites réelles.",
    "paramsUV": "params uv",
    "[number, number][]": "tableau paire nombres",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normales sur uvs",
    "normalsOnUVs": "normales sur uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Obtenir des normales sur UVs où U et V sont décrits entre 0 et 1 dans des tableaux bidimensionnels. Ceux-ci seront mappés aux limites réelles.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdiviser en points sur param",
    "subdivideToPointsOnParam": "subdiviser en points sur param",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Subdivise une face en points le long d'une ligne sur paramètre",
    "nrPoints": "nb points",
    "bitbybit.occt.shapes.face.wireAlongParam": "fil le long param",
    "wireAlongParam": "fil le long param",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Obtient le fil le long du paramètre sur la face",
    "bitbybit.occt.shapes.face.wiresAlongParams": "fils le long params",
    "wiresAlongParams": "fils le long params",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Obtient les fils le long des paramètres sur la face",
    "params": "params",
    "bitbybit.occt.shapes.face.getUMinBound": "obtenir borne u min",
    "getUMinBound": "obtenir borne u min",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Obtient la limite U min de la face",
    "bitbybit.occt.shapes.face.getUMaxBound": "obtenir borne u max",
    "getUMaxBound": "obtenir borne u max",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Obtient la limite U max de la face",
    "bitbybit.occt.shapes.face.getVMinBound": "obtenir borne v min",
    "getVMinBound": "obtenir borne v min",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Obtient la limite V min de la face",
    "bitbybit.occt.shapes.face.getVMaxBound": "obtenir borne v max",
    "getVMaxBound": "obtenir borne v max",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Obtient la limite V max de la face",
    "bitbybit.occt.shapes.face.getFaceArea": "obtenir aire face",
    "getFaceArea": "obtenir aire face",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Obtenir l'aire de la face",
    "bitbybit.occt.shapes.face.getFacesAreas": "obtenir aires faces",
    "getFacesAreas": "obtenir aires faces",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Obtenir les aires des faces",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "obtenir centre masse face",
    "getFaceCenterOfMass": "obtenir centre masse face",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Obtenir le point centre de masse de la face",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "obtenir centres masse faces",
    "getFacesCentersOfMass": "obtenir centres masse faces",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Obtenir les points centres de masse pour les faces",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtrer points face",
    "filterFacePoints": "filtrer points face",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtre les points sur la face",
    "filter": "filtrer",
    "useBndBox": "utiliser bnd box",
    "gapTolerance": "tolérance écart",
    "keepIn": "garder dedans",
    "keepOn": "garder dessus",
    "keepOut": "garder dehors",
    "keepUnknown": "garder inconnu",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtrer points faces",
    "filterFacesPoints": "filtrer points faces",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtre les points sur les faces",
    "flatPointsArray": "tableau points plat",
    "bitbybit.occt.shapes.shell.sewFaces": "coudre faces",
    "shell": "coque",
    "sewFaces": "coudre faces",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Crée une coque à partir de faces",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "obtenir aire surface coque",
    "getShellSurfaceArea": "obtenir aire surface coque",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Obtenir l'aire de surface de la coque",
    "bitbybit.occt.shapes.solid.fromClosedShell": "depuis coque fermée",
    "solid": "solide",
    "fromClosedShell": "depuis coque fermée",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Crée un Solide À partir d'une coque qui doit être fermée",
    "bitbybit.occt.shapes.solid.createBox": "boîte",
    "bitbybit.occt.shapes.solid.createBox_description": "crée une boîte opencascade",
    "originOnCenter": "origine au centre",
    "bitbybit.occt.shapes.solid.createCube": "cube",
    "bitbybit.occt.shapes.solid.createCube_description": "crée un cube opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "boîte depuis coin",
    "createBoxFromCorner": "boîte depuis coin",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "crée une boîte opencascade depuis le coin",
    "corner": "coin",
    "bitbybit.occt.shapes.solid.createCylinder": "cylindre",
    "bitbybit.occt.shapes.solid.createCylinder_description": "crée un cylindre opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cylindres sur lignes",
    "createCylindersOnLines": "cylindres sur lignes",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Crée des Cylindres OpenCascade sur des lignes simples bit by bit représentées par deux points",
    "Base.Line3[]": "tableau ligne3 base",
    "bitbybit.occt.shapes.solid.createSphere": "sphère",
    "bitbybit.occt.shapes.solid.createSphere_description": "crée une sphère opencascade",
    "bitbybit.occt.shapes.solid.createCone": "cône",
    "createCone": "cône",
    "bitbybit.occt.shapes.solid.createCone_description": "crée un cône opencascade",
    "radius1": "rayon 1",
    "radius2": "rayon 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "obtenir aire surface solide",
    "getSolidSurfaceArea": "obtenir aire surface solide",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Obtenir l'aire de surface du solide",
    "bitbybit.occt.shapes.solid.getSolidVolume": "obtenir volume solide",
    "getSolidVolume": "obtenir volume solide",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Obtenir le volume du solide",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "obtenir volumes solides",
    "getSolidsVolumes": "obtenir volumes solides",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Obtenir les volumes des solides",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "obtenir centre masse solide",
    "getSolidCenterOfMass": "obtenir centre masse solide",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Obtenir le centre de masse du solide",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "obtenir centres masse solides",
    "getSolidsCentersOfMass": "obtenir centres masse solides",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Obtenir les centres de masse des solides",
    "bitbybit.occt.shapes.solid.getSolids": "obtenir solides",
    "getSolids": "obtenir solides",
    "bitbybit.occt.shapes.solid.getSolids_description": "Obtient les solides de la forme dans une liste",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtrer points solides",
    "filterSolidPoints": "filtrer points solides",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Filtre la collection de points en fonction de la relation avec le solide. Vous pouvez choisir de sortir les points à l'intérieur, dessus ou à l'extérieur.",
    "bitbybit.occt.shapes.compound.makeCompound": "créer composé",
    "compound": "composé",
    "makeCompound": "créer composé",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Crée la forme composée, qui peut inclure n'importe quel type de formes",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "obtenir formes composé",
    "getShapesOfCompound": "obtenir formes composé",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Obtient les formes dont le composé est fait",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "purger arêtes internes",
    "purgeInternalEdges": "purger arêtes internes",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Supprimer les arêtes internes qui ne sont connectées à aucune face dans la forme",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unifier même domaine",
    "unifySameDomain": "unifier même domaine",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Unifie les faces, les arêtes dans le même domaine et a la possibilité de concaténer les bsplines",
    "unifyEdges": "unifier arêtes",
    "unifyFaces": "unifier faces",
    "concatBSplines": "concaténer bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "est fermé",
    "bitbybit.occt.shapes.shape.isClosed_description": "Vérifier si la forme est fermée",
    "analysis": "analyse",
    "bitbybit.occt.shapes.shape.isConvex": "est convexe",
    "isConvex": "est convexe",
    "bitbybit.occt.shapes.shape.isConvex_description": "Vérifier si la forme est convexe",
    "bitbybit.occt.shapes.shape.isChecked": "est vérifié",
    "bitbybit.occt.shapes.shape.isChecked_description": "Vérifier si la forme est vérifiée",
    "bitbybit.occt.shapes.shape.isFree": "est libre",
    "isFree": "est libre",
    "bitbybit.occt.shapes.shape.isFree_description": "Vérifier si la forme est libre",
    "bitbybit.occt.shapes.shape.isInfinite": "est infini",
    "isInfinite": "est infini",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Vérifier si la forme est infinie",
    "bitbybit.occt.shapes.shape.isModified": "est modifié",
    "isModified": "est modifié",
    "bitbybit.occt.shapes.shape.isModified_description": "Vérifier si la forme est modifiée",
    "bitbybit.occt.shapes.shape.isLocked": "est verrouillé",
    "isLocked": "est verrouillé",
    "bitbybit.occt.shapes.shape.isLocked_description": "Vérifier si la forme est verrouillée",
    "bitbybit.occt.shapes.shape.isNull": "est nul",
    "isNull": "est nul",
    "bitbybit.occt.shapes.shape.isNull_description": "Vérifier si la forme est nulle",
    "bitbybit.occt.shapes.shape.isEqual": "est égal",
    "isEqual": "est égal",
    "bitbybit.occt.shapes.shape.isEqual_description": "Vérifier si la forme est égale à une autre forme",
    "otherShape": "autre forme",
    "bitbybit.occt.shapes.shape.isNotEqual": "est différent",
    "isNotEqual": "est différent",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Vérifier si la forme n'est pas égale à une autre forme",
    "bitbybit.occt.shapes.shape.isPartner": "est partenaire",
    "isPartner": "est partenaire",
    "bitbybit.occt.shapes.shape.isPartner_description": "Vérifier si la forme est partenaire d'une autre forme",
    "bitbybit.occt.shapes.shape.isSame": "est même",
    "isSame": "est même",
    "bitbybit.occt.shapes.shape.isSame_description": "Vérifier si la forme est la même que l'autre forme",
    "bitbybit.occt.shapes.shape.getOrientation": "obtenir orientation",
    "getOrientation": "obtenir orientation",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Obtenir l'orientation de la forme",
    "bitbybit.occt.shapes.shape.getShapeType": "obtenir type forme",
    "getShapeType": "obtenir type forme",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Obtenir le type de forme",
    "bitbybit.occt.geom.curves.geom2dEllipse": "geom ellipse 2d",
    "geom": "geom",
    "curves": "courbes",
    "geom2dEllipse": "geom ellipse 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Crée une ellipse 2d. Assurez-vous d'utiliser cette géométrie uniquement à des fins de modélisation constructive, mais pas pour la représentation. Vous devez transformer ces courbes en arêtes pour les dessiner.",
    "Base.Point2": "point2 base",
    "Base.Vector2": "vecteur2 base",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "geom courbe découpée 2d",
    "geom2dTrimmedCurve": "geom courbe découpée 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Crée une courbe découpée à partir de la courbe de base limitée entre U1 et U2. Cette courbe ne peut pas être dessinée.",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "ajuster périodique",
    "bitbybit.occt.geom.curves.geom2dSegment": "geom segment 2d",
    "geom2dSegment": "geom segment 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Crée un segment de courbe 2d découpé entre deux points 2d. Cette courbe ne peut pas être dessinée.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "obtenir point 2d depuis courbe 2d sur param",
    "get2dPointFrom2dCurveOnParam": "obtenir point 2d depuis courbe 2d sur param",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Obtient un point 2d représenté par [nombre, nombre] sur une courbe au paramètre.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "geom courbe cercle",
    "geomCircleCurve": "geom courbe cercle",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Crée une courbe géométrique de cercle",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "geom courbe ellipse",
    "geomEllipseCurve": "geom courbe ellipse",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Crée une courbe géométrique d'ellipse",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "surface cylindrique",
    "surfaces": "surfaces",
    "cylindricalSurface": "surface cylindrique",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Crée une surface cylindrique infinie qui ne peut pas être dessinée. Assurez-vous d'utiliser cette géométrie uniquement à des fins de modélisation constructive, mais pas pour la représentation.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "surface depuis face",
    "surfaceFromFace": "surface depuis face",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Crée une surface à partir de la face",
    "bitbybit.occt.fillets.filletEdges": "congé arêtes",
    "fillets": "congés",
    "filletEdges": "congé arêtes",
    "bitbybit.occt.fillets.filletEdges_description": "arrondit les formes opencascade",
    "3d fillets": "congés 3d",
    "radiusList": "liste rayons",
    "indexes": "indices",
    "bitbybit.occt.fillets.filletEdgesList": "liste congé arêtes",
    "filletEdgesList": "liste congé arêtes",
    "bitbybit.occt.fillets.filletEdgesList_description": "Arrondit la liste des arêtes avec un rayon différent sur chaque arête.",
    "edges": "arêtes",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "liste congé arêtes un rayon",
    "filletEdgesListOneRadius": "liste congé arêtes un rayon",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Arrondit la liste des arêtes avec le rayon unique sur toutes les arêtes.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "congé arête rayon variable",
    "filletEdgeVariableRadius": "congé arête rayon variable",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Arrondit une seule arête avec une liste de rayons variables sur des paramètres u donnés. Vous devez fournir une liste de paramètres pour identifier sur quel paramètre U appliquer le rayon.",
    "paramsU": "params u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "congé arêtes même rayon variable",
    "filletEdgesSameVariableRadius": "congé arêtes même rayon variable",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Arrondit plusieurs arêtes fournies avec les mêmes rayons variables sur les paramètres u pour chaque arête.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "congé arêtes rayon variable",
    "filletEdgesVariableRadius": "congé arêtes rayon variable",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Arrondit plusieurs arêtes fournies avec des listes de rayons variables sur des listes de paramètres données. Vous devez fournir une liste de paramètres pour identifier sur quel paramètre U appliquer le rayon.",
    "radiusLists": "listes rayons",
    "paramsULists": "listes params u",
    "bitbybit.occt.fillets.fillet3DWire": "congé fil 3d",
    "fillet3DWire": "congé fil 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "Arrondit un fil 3d OpenCascade, cet algorithme prend une direction guide pour que les congés soient formés. Il ne respecte pas les directions tangentes à chaque coin arrondi. Cet algorithme est basé sur l'extrusion du fil le long de la direction donnée pour former une coque, puis l'arrondissement de la coque et enfin l'extraction du fil arrondi de la coque elle-même. Assurez-vous de fournir une direction qui n'est pas parallèle au fil et qui forme une extrusion suffisamment haute pour que l'arrondissement réussisse.",
    "bitbybit.occt.fillets.fillet3DWires": "congé fils 3d",
    "fillet3DWires": "congé fils 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "Arrondit des fils 3d OpenCascade, cet algorithme prend une direction guide pour que les congés soient formés. Il ne respecte pas les directions tangentes à chaque coin arrondi. Cet algorithme est basé sur l'extrusion des fils le long de la direction donnée pour former une coque, puis l'arrondissement de la coque et enfin l'extraction du fil arrondi de la coque elle-même. Assurez-vous de fournir une direction qui n'est pas parallèle au fil et qui forme une extrusion suffisamment haute pour que l'arrondissement réussisse.",
    "bitbybit.occt.fillets.chamferEdges": "chanfrein arêtes",
    "chamferEdges": "chanfrein arêtes",
    "bitbybit.occt.fillets.chamferEdges_description": "Chanfreiner les arêtes de la Forme OpenCascade",
    "3d chamfers": "chanfreins 3d",
    "distanceList": "liste distances",
    "bitbybit.occt.fillets.chamferEdgesList": "liste chanfrein arêtes",
    "chamferEdgesList": "liste chanfrein arêtes",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Chanfreine la liste des arêtes avec une distance différente sur chaque arête.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "chanfrein arête deux distances",
    "chamferEdgeTwoDistances": "chanfrein arête deux distances",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Chanfreine l'arête par deux distances. La face indique la première distance à appliquer",
    "F": "f",
    "distance1": "distance 1",
    "distance2": "distance 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "chanfrein arêtes deux distances",
    "chamferEdgesTwoDistances": "chanfrein arêtes deux distances",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Chanfreine les arêtes par deux distances. La face indique la première distance à appliquer",
    "faces": "faces",
    "F[]": "tableau f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "listes chanfrein arêtes deux distances",
    "chamferEdgesTwoDistancesLists": "listes chanfrein arêtes deux distances",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Chanfreine les arêtes par deux distances. La face indique la première distance à appliquer",
    "distances1": "distances 1",
    "distances2": "distances 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "chanfrein arête dist angle",
    "chamferEdgeDistAngle": "chanfrein arête dist angle",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Chanfreine l'arête par une distance et un angle donnés depuis la face",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "chanfrein arêtes dist angle",
    "chamferEdgesDistAngle": "chanfrein arêtes dist angle",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Chanfreine plusieurs arêtes par une distance et un angle donnés depuis les faces",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "chanfrein arêtes dists angles",
    "chamferEdgesDistsAngles": "chanfrein arêtes dists angles",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Chanfreine les arêtes par des distances et des angles donnés depuis les faces",
    "distances": "distances",
    "bitbybit.occt.fillets.fillet2d": "congé 2d",
    "fillet2d": "congé 2d",
    "bitbybit.occt.fillets.fillet2d_description": "arrondit un fil ou une face 2d",
    "2d fillets": "congés 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "congé formes 2d",
    "fillet2dShapes": "congé formes 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "arrondit des fils ou des faces 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "congé deux arêtes dans plan en un fil",
    "filletTwoEdgesInPlaneIntoAWire": "congé deux arêtes dans plan en un fil",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Arrondit deux arêtes planaires en un fil en fournissant un rayon, un plan, des arêtes et un index de solution possible si plus d'un résultat existe",
    "edge1": "arête 1",
    "edge2": "arête 2",
    "planeOrigin": "origine plan",
    "planeDirection": "direction plan",
    "solution": "solution",
    "bitbybit.occt.transforms.transform": "transformer",
    "bitbybit.occt.transforms.transform_description": "Transforme la forme",
    "on single shape": "sur forme unique",
    "rotationAxis": "axe rotation",
    "rotationAngle": "angle rotation",
    "scaleFactor": "facteur échelle",
    "bitbybit.occt.transforms.rotate": "pivoter",
    "bitbybit.occt.transforms.rotate_description": "Fait pivoter la forme",
    "bitbybit.occt.transforms.rotateAroundCenter": "pivoter autour centre",
    "rotateAroundCenter": "pivoter autour centre",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Fait pivoter la forme autour du centre fourni",
    "bitbybit.occt.transforms.align": "aligner",
    "bitbybit.occt.transforms.align_description": "Aligne la forme",
    "fromOrigin": "depuis origine",
    "fromDirection": "depuis direction",
    "toOrigin": "vers origine",
    "toDirection": "vers direction",
    "bitbybit.occt.transforms.alignAndTranslate": "aligner et translater",
    "alignAndTranslate": "aligner et translater",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Aligne et translate la forme",
    "bitbybit.occt.transforms.translate": "translater",
    "bitbybit.occt.transforms.translate_description": "Translate la forme",
    "bitbybit.occt.transforms.scale": "mettre à l'échelle",
    "bitbybit.occt.transforms.scale_description": "Met à l'échelle la forme",
    "bitbybit.occt.transforms.scale3d": "mettre à l'échelle 3d",
    "scale3d": "mettre à l'échelle 3d",
    "bitbybit.occt.transforms.scale3d_description": "Met à l'échelle la forme en 3D",
    "bitbybit.occt.transforms.mirror": "miroir",
    "mirror": "miroir",
    "bitbybit.occt.transforms.mirror_description": "Miroir la forme",
    "bitbybit.occt.transforms.mirrorAlongNormal": "miroir le long normale",
    "mirrorAlongNormal": "miroir le long normale",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Miroir la forme le long de la normale et de l'origine",
    "normal": "normale",
    "bitbybit.occt.transforms.transformShapes": "transformer formes",
    "transformShapes": "transformer formes",
    "bitbybit.occt.transforms.transformShapes_description": "Transforme le tableau de formes avec des transformations",
    "on shapes": "sur formes",
    "rotationAxes": "axes rotation",
    "rotationAngles": "angles rotation",
    "scaleFactors": "facteurs échelle",
    "bitbybit.occt.transforms.rotateShapes": "pivoter formes",
    "rotateShapes": "pivoter formes",
    "bitbybit.occt.transforms.rotateShapes_description": "Fait pivoter les formes avec des rotations",
    "axes": "axes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "pivoter autour centre formes",
    "rotateAroundCenterShapes": "pivoter autour centre formes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Fait pivoter les formes autour du centre et d'un axe",
    "centers": "centres",
    "bitbybit.occt.transforms.alignShapes": "aligner formes",
    "alignShapes": "aligner formes",
    "bitbybit.occt.transforms.alignShapes_description": "Aligne les formes avec des alignements",
    "fromOrigins": "depuis origines",
    "fromDirections": "depuis directions",
    "toOrigins": "vers origines",
    "toDirections": "vers directions",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "aligner et translater formes",
    "alignAndTranslateShapes": "aligner et translater formes",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Aligne et translate les formes",
    "directions": "directions",
    "bitbybit.occt.transforms.translateShapes": "translater formes",
    "translateShapes": "translater formes",
    "bitbybit.occt.transforms.translateShapes_description": "Translate les formes avec des translations",
    "bitbybit.occt.transforms.scaleShapes": "mettre à l'échelle formes",
    "scaleShapes": "mettre à l'échelle formes",
    "bitbybit.occt.transforms.scaleShapes_description": "Met à l'échelle les formes avec des facteurs d'échelle",
    "factors": "facteurs",
    "bitbybit.occt.transforms.scale3dShapes": "mettre à l'échelle 3d formes",
    "scale3dShapes": "mettre à l'échelle 3d formes",
    "bitbybit.occt.transforms.scale3dShapes_description": "Met à l'échelle la forme en 3D",
    "scales": "échelles",
    "bitbybit.occt.transforms.mirrorShapes": "miroir formes",
    "mirrorShapes": "miroir formes",
    "bitbybit.occt.transforms.mirrorShapes_description": "Miroir les formes avec plusieurs miroirs",
    "origins": "origines",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "miroir le long normale formes",
    "mirrorAlongNormalShapes": "miroir le long normale formes",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Miroir les formes le long de la normale et de l'origine",
    "normals": "normales",
    "bitbybit.occt.operations.loft": "extrusion par sections",
    "operations": "opérations",
    "loft": "extrusion par sections",
    "bitbybit.occt.operations.loft_description": "Lisse des fils en une coque",
    "lofts": "extrusions par sections",
    "makeSolid": "créer solide",
    "bitbybit.occt.operations.loftAdvanced": "extrusion par sections avancée",
    "loftAdvanced": "extrusion par sections avancée",
    "bitbybit.occt.operations.loftAdvanced_description": "Lisse des fils en une coque en utilisant de nombreuses options avancées",
    "straight": "droit",
    "nrPeriodicSections": "nb sections périodiques",
    "useSmoothing": "utiliser lissage",
    "maxUDegree": "degré u max",
    "parType": "type param",
    "approxParametrizationTypeEnum": "énumération type paramétrisation approx",
    "startVertex": "sommet départ",
    "endVertex": "sommet arrivée",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "points plus proches entre deux formes",
    "closestPointsBetweenTwoShapes": "points plus proches entre deux formes",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Calcule deux points les plus proches entre deux formes",
    "closest pts": "pts plus proches",
    "shape1": "forme 1",
    "shape2": "forme 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "points plus proches sur forme depuis points",
    "closestPointsOnShapeFromPoints": "points plus proches sur forme depuis points",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Calcule les points les plus proches entre une liste de points et une forme donnée",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "points plus proches sur formes depuis points",
    "closestPointsOnShapesFromPoints": "points plus proches sur formes depuis points",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Calcule les points les plus proches entre une liste de points et des formes",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distances à forme depuis points",
    "distancesToShapeFromPoints": "distances à forme depuis points",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Calcule les distances entre une liste de points et les points les plus proches correspondants sur des formes.",
    "bitbybit.occt.operations.boundingBoxOfShape": "boîte englobante de la forme",
    "boundingBoxOfShape": "boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Calcule les paramètres de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "minimum de la boîte englobante de la forme",
    "boundingBoxMinOfShape": "minimum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Obtient le point minimum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "maximum de la boîte englobante de la forme",
    "boundingBoxMaxOfShape": "maximum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Obtient le point maximum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "centre de la boîte englobante de la forme",
    "boundingBoxCenterOfShape": "centre de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Obtient le point central de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "taille de la boîte englobante de la forme",
    "boundingBoxSizeOfShape": "taille de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Obtient le point de taille de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "forme de la boîte englobante de la forme",
    "boundingBoxShapeOfShape": "forme de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Obtient la forme de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingSphereOfShape": "sphère englobante de la forme",
    "boundingSphereOfShape": "sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Calcule les paramètres de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "centre de la sphère englobante de la forme",
    "boundingSphereCenterOfShape": "centre de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Obtient le point central de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "rayon de la sphère englobante de la forme",
    "boundingSphereRadiusOfShape": "rayon de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Obtient le rayon de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "forme de la sphère englobante de la forme",
    "boundingSphereShapeOfShape": "forme de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Obtient la forme de la sphère englobante de la forme",
    "bitbybit.occt.operations.extrude": "extruder",
    "extrude": "extruder",
    "bitbybit.occt.operations.extrude_description": "Extrude la forme le long de la direction - le fil produira une coque, la face produira un solide",
    "extrusions": "extrusions",
    "bitbybit.occt.operations.extrudeShapes": "extruder formes",
    "extrudeShapes": "extruder formes",
    "bitbybit.occt.operations.extrudeShapes_description": "Extrude les formes le long de la direction",
    "bitbybit.occt.operations.splitShapeWithShapes": "diviser forme avec formes",
    "splitShapeWithShapes": "diviser forme avec formes",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Divise la forme avec des formes",
    "divisions": "divisions",
    "localFuzzyTolerance": "tolérance floue locale",
    "nonDestructive": "non destructif",
    "bitbybit.occt.operations.revolve": "révolution",
    "revolve": "révolution",
    "bitbybit.occt.operations.revolve_description": "Révolutionne la forme autour de la direction donnée",
    "revolutions": "révolutions",
    "copy": "copier",
    "bitbybit.occt.operations.rotatedExtrude": "extrusion pivotée",
    "rotatedExtrude": "extrusion pivotée",
    "bitbybit.occt.operations.rotatedExtrude_description": "Extrusion rotative qui est effectuée sur la forme",
    "bitbybit.occt.operations.pipe": "tuyau",
    "pipe": "tuyau",
    "bitbybit.occt.operations.pipe_description": "Fait passer des formes le long du fil",
    "pipeing": "tuyauterie",
    "bitbybit.occt.operations.pipePolylineWireNGon": "tuyau fil polyligne ngon",
    "pipePolylineWireNGon": "tuyau fil polyligne ngon",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Fait passer un fil polyligne avec un profil n-gone.",
    "trihedronEnum": "énumération trièdre",
    "geomFillTrihedronEnum": "énumération trièdre remplissage geom",
    "forceApproxC1": "forcer approx c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "tuyaux fils cylindriques",
    "pipeWiresCylindrical": "tuyaux fils cylindriques",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Fait passer des fils avec une forme cylindrique",
    "bitbybit.occt.operations.pipeWireCylindrical": "tuyau fil cylindrique",
    "pipeWireCylindrical": "tuyau fil cylindrique",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Fait passer un fil avec une forme cylindrique",
    "bitbybit.occt.operations.offset": "décalage",
    "bitbybit.occt.operations.offset_description": "Décalage pour diverses formes",
    "offsets": "décalages",
    "bitbybit.occt.operations.offsetAdv": "décalage avancé",
    "offsetAdv": "décalage avancé",
    "bitbybit.occt.operations.offsetAdv_description": "Décalage avancé qui donne plus d'options pour le décalage, telles que le type de jointure pour les arêtes et les coins",
    "joinType": "type jonction",
    "joinTypeEnum": "énumération type jonction",
    "removeIntEdges": "supprimer arêtes int",
    "bitbybit.occt.operations.makeThickSolidSimple": "créer solide épais simple",
    "makeThickSolidSimple": "créer solide épais simple",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Épaissit la forme en un solide par une distance de décalage",
    "bitbybit.occt.operations.makeThickSolidByJoin": "créer solide épais par jonction",
    "makeThickSolidByJoin": "créer solide épais par jonction",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Épaissit la forme en un solide par jointure",
    "intersection": "intersection",
    "selfIntersection": "auto-intersection",
    "bitbybit.occt.operations.slice": "trancher",
    "slice": "trancher",
    "bitbybit.occt.operations.slice_description": "Tranche la forme",
    "bitbybit.occt.operations.sliceInStepPattern": "trancher en motif pas",
    "sliceInStepPattern": "trancher en motif pas",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Tranche la forme en motif d'escalier",
    "steps": "pas",
    "bitbybit.occt.operations.offset3DWire": "décalage fil 3d",
    "offset3DWire": "décalage fil 3d",
    "bitbybit.occt.operations.offset3DWire_description": "Décalage du fil 3D. Lorsque vous utilisez cette méthode, envisagez de l'utiliser sur des fils arrondis qui ne contiennent pas de coins pointus. Vous pouvez utiliser le congé 3D dessus.",
    "bitbybit.occt.booleans.union": "union",
    "booleans": "booléens",
    "union": "union",
    "bitbybit.occt.booleans.union_description": "Joint des objets séparés",
    "keepEdges": "garder arêtes",
    "bitbybit.occt.booleans.difference": "différence",
    "difference": "différence",
    "bitbybit.occt.booleans.difference_description": "Fait une opération de différence booléenne entre une forme principale et des formes données",
    "bitbybit.occt.booleans.intersection": "intersection",
    "bitbybit.occt.booleans.intersection_description": "Fait une opération d'intersection booléenne entre une forme principale et des formes données",
    "bitbybit.occt.shapeFix.basicShapeRepair": "réparation forme base",
    "shapeFix": "correction forme",
    "basicShapeRepair": "réparation forme base",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Effectue la réparation de forme de base",
    "maxTolerance": "tolérance max",
    "minTolerance": "tolérance min",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "corriger petite arête sur fil",
    "fixSmallEdgeOnWire": "corriger petite arête sur fil",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Corriger petite arête sur fil",
    "lockvtx": "verrouiller vtx",
    "precsmall": "précision petit",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "corriger orientations arêtes le long fil",
    "fixEdgeOrientationsAlongWire": "corriger orientations arêtes le long fil",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Corriger les orientations des arêtes le long du fil",
    "bitbybit.occt.io.saveShapeSTEP": "sauvegarder forme step",
    "saveShapeSTEP": "sauvegarder forme step",
    "bitbybit.occt.io.saveShapeSTEP_description": "Sauvegarde le fichier step",
    "adjustYtoZ": "ajuster y à z",
    "tryDownload": "essayer télécharger",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "sauvegarder forme step et retourner",
    "saveShapeSTEPAndReturn": "sauvegarder forme step et retourner",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Sauvegarde le fichier step et renvoie la valeur textuelle",
    "bitbybit.occt.io.saveShapeStl": "sauvegarder forme stl",
    "saveShapeStl": "sauvegarder forme stl",
    "bitbybit.occt.io.saveShapeStl_description": "Sauvegarde le fichier stl",
    "binary": "binaire",
    "bitbybit.occt.io.saveShapeStlAndReturn": "sauvegarder forme stl et retourner",
    "saveShapeStlAndReturn": "sauvegarder forme stl et retourner",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Sauvegarde le fichier stl et le renvoie",
    "bitbybit.occt.io.loadSTEPorIGES": "charger step ou iges",
    "loadSTEPorIGES": "charger step ou iges",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Importe le fichier d'actif step ou iges",
    "adjustZtoY": "ajuster z à y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "charger step ou iges depuis texte",
    "loadSTEPorIGESFromText": "charger step ou iges depuis texte",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Importe le fichier d'actif step ou iges à partir de texte",
    "fileType": "type fichier",
    "fileTypeEnum": "énumération type fichier",
    "bitbybit.advanced.text3d.create": "texte 3d",
    "advanced": "avancé",
    "text3d": "texte 3d",
    "bitbybit.advanced.text3d.create_description": "Crée un texte 3d",
    "fontType": "type police",
    "fontsEnum": "énumération polices",
    "fontVariant": "variante police",
    "fontVariantsEnum": "énumération variantes polices",
    "Inputs.Base.Vector3": "entrées base vecteur 3",
    "originAlignment": "alignement origine",
    "recAlignmentEnum": "énumération alignement rec",
    "bitbybit.advanced.text3d.createTextOnFace": "texte sur face",
    "createTextOnFace": "texte sur face",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Crée un texte 3d sur la face",
    "facePlanar": "face planaire",
    "faceTextVar": "var texte face",
    "faceTextVarEnum": "énumération var texte face",
    "originParamU": "origine param u",
    "originParamV": "origine param v",
    "bitbybit.advanced.text3d.createTextsOnFace": "textes sur face",
    "createTextsOnFace": "textes sur face",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Crée des textes 3d sur la face à partir de plusieurs définitions",
    "definitions": "définitions",
    "Text3DFaceDefinitionDto[]": "tableau dto définition face texte 3d",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "définition texte 3d sur face",
    "definition3dTextOnFace": "définition texte 3d sur face",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Crée du texte 3d qui sera utilisé sur la définition de la face",
    "bitbybit.advanced.text3d.getCompoundShape": "obtenir forme composée",
    "getCompoundShape": "obtenir forme composée",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Obtient la forme composée du résultat du texte 3d",
    "model": "modèle",
    "Text3DData<T>": "données texte 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "obtenir forme caractère",
    "getCharacterShape": "obtenir forme caractère",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Obtient la forme du caractère à un index particulier",
    "bitbybit.advanced.text3d.getCharacterShapes": "obtenir formes caractères",
    "getCharacterShapes": "obtenir formes caractères",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Obtient les formes de caractères du résultat du texte 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "obtenir coordonnées centre caractères",
    "getCharacterCenterCoordinates": "obtenir coordonnées centre caractères",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Obtient les coordonnées du centre de masse de tous les caractères",
    "bitbybit.advanced.text3d.getFaceCutout": "obtenir découpe face",
    "getFaceCutout": "obtenir découpe face",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Obtient la découpe de face du texte 3d qui a été créé sur la face",
    "get from face": "obtenir depuis face",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "obtenir toutes faces découpe",
    "getAllFacesOfCutout": "obtenir toutes faces découpe",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Obtient toutes les découpes de face du texte 3d qui a été créé sur la face d'origine",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "obtenir découpes intérieur caractères",
    "getCutoutsInsideCharacters": "obtenir découpes intérieur caractères",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Obtient les découpes de face de caractère du texte 3d qui a été créé sur la face d'origine",
    "bitbybit.advanced.text3d.getAdvanceWidth": "obtenir largeur avance",
    "getAdvanceWidth": "obtenir largeur avance",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Obtenir la largeur d'avance",
    "dimensions": "dimensions",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pyramide simple",
    "facePatterns": "motifs face",
    "pyramidSimple": "pyramide simple",
    "createPyramidSimple": "pyramide simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Crée un motif pyramidal simple sur les faces",
    "uNumber": "nombre u",
    "vNumber": "nombre v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "pyramide simple affecteurs",
    "createPyramidSimpleAffectors": "pyramide simple affecteurs",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Crée un motif pyramidal simple sur les faces avec des affecteurs qui changent la hauteur",
    "affectorPoints": "points affecteurs",
    "Inputs.Base.Point3[]": "tableau de point base 3 (entrées)",
    "affectorRadiusList": "liste rayons affecteur",
    "affectorFactors": "facteurs affecteur",
    "defaultHeight": "hauteur par défaut",
    "affectMinHeight": "hauteur min affectée",
    "affectMaxHeight": "hauteur max affectée",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "obtenir forme composée",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Obtient la forme composée de toutes les pyramides",
    "get shapes": "obtenir formes",
    "PyramidSimpleData<T>": "données pyramide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "obtenir forme composée sur face",
    "getCompoundShapeOnFace": "obtenir forme composée sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Obtient la forme composée sur la face",
    "faceIndex": "index face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "obtenir forme composée cellule sur face",
    "getCompoundShapeCellOnFace": "obtenir forme composée cellule sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Obtient la forme composée de la pyramide sur la face à un index particulier",
    "uIndex": "index u",
    "vIndex": "index v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "obtenir toutes cellules pyramide",
    "getAllPyramidCells": "obtenir toutes cellules pyramide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Obtient toutes les cellules pyramidales. C'est généralement une action intermédiaire pour lire ensuite des informations particulières des cellules elles-mêmes.",
    "get cells": "obtenir cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "obtenir toutes cellules pyramide sur face",
    "getAllPyramidCellsOnFace": "obtenir toutes cellules pyramide sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Obtient les cellules pyramidales sur la face. C'est généralement une action intermédiaire pour lire ensuite des informations particulières des cellules elles-mêmes.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "obtenir toutes cellules pyramide u sur face",
    "getAllPyramidUCellsOnFace": "obtenir toutes cellules pyramide u sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Obtient les cellules pyramidales sur la face. C'est généralement une action intermédiaire pour lire ensuite des informations particulières des cellules elles-mêmes.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "obtenir toutes cellules pyramide u sur face à u",
    "getAllPyramidUCellsOnFaceAtU": "obtenir toutes cellules pyramide u sur face à u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Obtient les cellules pyramidales sur la face à l'index u le long de la direction v. C'est généralement une action intermédiaire pour lire ensuite des informations particulières des cellules elles-mêmes.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "obtenir toutes cellules pyramide u sur face à v",
    "getAllPyramidUCellsOnFaceAtV": "obtenir toutes cellules pyramide u sur face à v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Obtient les cellules pyramidales sur la face à l'index v le long de la direction u. C'est généralement une action intermédiaire pour lire ensuite des informations particulières des cellules elles-mêmes.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "obtenir cellule à l'index",
    "getCellOnIndex": "obtenir cellule à l'index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Obtient la cellule pyramidale sur la face à l'index u et v. C'est généralement une action intermédiaire pour lire ensuite des informations particulières de la cellule elle-même.",
    "get cell": "obtenir cellule",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obtenir points supérieurs cellules",
    "getTopPointsOfCells": "obtenir points supérieurs cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Obtient les points supérieurs des cellules",
    "get from cells": "obtenir depuis cellules",
    "cells": "cellules",
    "PyramidSimpleCellPart<T>[]": "tableau partie cellule pyramide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "obtenir points centraux cellules",
    "getCenterPointsOfCells": "obtenir points centraux cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Obtient le point central entre les coins des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "obtenir points coins cellules",
    "getCornerPointsOfCells": "obtenir points coins cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Obtient les points de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "obtenir point coin cellules",
    "getCornerPointOfCells": "obtenir point coin cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Obtient les points de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "obtenir normale coin cellules",
    "getCornerNormalOfCells": "obtenir normale coin cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Obtient la normale de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "obtenir normales coins cellules",
    "getCornerNormalsOfCells": "obtenir normales coins cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Obtient les normales de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "obtenir formes composées cellules",
    "getCompoundShapesOfCells": "obtenir formes composées cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Obtient les formes composées des cellules pyramidales",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "obtenir formes faces cellules",
    "getFaceShapesOfCells": "obtenir formes faces cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Obtient les formes de face des cellules pyramidales fournies",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "obtenir formes fils cellules",
    "getWireShapesOfCells": "obtenir formes fils cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Obtient les formes de face des cellules pyramidales fournies",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "obtenir fil polyligne départ u",
    "getStartPolylineWireU": "obtenir fil polyligne départ u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Obtient le fil polyligne le long du bord de départ de la direction U de la face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "obtenir fil polyligne fin u",
    "getEndPolylineWireU": "obtenir fil polyligne fin u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Obtient le fil polyligne le long du bord de fin de la direction U de la face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "obtenir fil polyligne départ v",
    "getStartPolylineWireV": "obtenir fil polyligne départ v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Obtient le fil polyligne le long du bord de départ de la direction V de la face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "obtenir fil polyligne fin v",
    "getEndPolylineWireV": "obtenir fil polyligne fin v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Obtient le fil polyligne le long du bord de fin de la direction V de la face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "obtenir fils polyligne u composé",
    "getPolylineWiresUCompound": "obtenir fils polyligne u composé",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Obtient les fils polylignes le long de la direction U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "obtenir fils polyligne v composé",
    "getPolylineWiresVCompound": "obtenir fils polyligne v composé",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Obtient les fils polylignes le long de la direction V",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "wingtip villa",
    "things": "choses",
    "kidsCorner": "coin enfants",
    "birdhouses": "nichoirs",
    "wingtipVilla": "wingtip villa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Crée une villa wingtip pour oiseaux avec un toit à 45 degrés",
    "birdhouse": "nichoir",
    "interiorWidth": "largeur intérieure",
    "interiorLength": "longueur intérieure",
    "interiorHeight": "hauteur intérieure",
    "holeDiameter": "diamètre trou",
    "holeDistToBottom": "distance trou au bas",
    "stickLength": "longueur bâton",
    "stickDiameter": "diamètre bâton",
    "baseAttachmentHeight": "hauteur fixation base",
    "roofOverhang": "débord toit",
    "chimneyHeight": "hauteur cheminée",
    "Inputs.Base.Point3": "point base 3 (entrées)",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chirpy chalet",
    "chirpyChalet": "chirpy chalet",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Crée un chalet chirpy pour oiseaux avec un toit à 45 degrés",
    "roofAngle": "angle toit",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "serenity swirl",
    "threeDPrinting": "impression 3d",
    "vases": "vases",
    "serenitySwirl": "serenity swirl",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Crée un tourbillon de sérénité",
    "swirl": "tourbillon",
    "addRadiusNarrow": "ajouter rayon étroit",
    "addRadiusWide": "ajouter rayon large",
    "addMiddleHeight": "ajouter hauteur milieu",
    "addTopHeight": "ajouter hauteur haut",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arabic archway",
    "arabicArchway": "arabic archway",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Crée un vase en arche arabe",
    "profilePoints": "points profil",
    "nrOfSides": "nb côtés",
    "nrOfVerticalArches": "nb arches verticales",
    "archCenterThickness": "épaisseur centre arche",
    "edgesThickness": "épaisseur arêtes",
    "baseHeight": "hauteur base",
    "patchHoles": "colmater trous",
    "lod": "lod",
    "Things.Enums.lodEnum": "énumération lod enums choses",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "eternal love",
    "medals": "médailles",
    "eternalLove": "eternal love",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Crée un modèle de médaille d'amour éternel",
    "textHeading": "texte titre",
    "textName": "texte nom",
    "fullModel": "modèle complet",
    "decorationThickness": "épaisseur décoration",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "calm cup",
    "cups": "tasses",
    "calmCup": "calm cup",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Crée un modèle de tasse pour vos moments calmes",
    "radiusTopOffset": "décalage rayon haut",
    "fillet": "congé",
    "nrOfHandles": "nb poignées",
    "handleDist": "distance poignée",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "dragon cup",
    "dragonCup": "dragon cup",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Crée un modèle de tasse pour votre dragon intérieur",
    "radiusMidOffset": "décalage rayon milieu",
    "rotationTopAngle": "angle rotation haut",
    "rotationMidAngle": "angle rotation milieu",
    "nrSkinCellsVertical": "nb cellules peau verticales",
    "nrSkinCellsHorizontal": "nb cellules peau horizontales",
    "nrSkinCellDivisionsTop": "nb divisions cellule peau haut",
    "nrSkinCellDivisionsBottom": "nb divisions cellule peau bas",
    "skinCellOuterHeight": "hauteur extérieure cellule peau",
    "skinCellInnerHeight": "hauteur intérieure cellule peau",
    "skinCellBottomHeight": "hauteur bas cellule peau",
    "skinCellTopHeight": "hauteur haut cellule peau",
    "bottomThickness": "épaisseur bas",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Obtient la forme composée de la tasse dragon",
    "DragonCupData<T>": "données dragon cup t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "phone nest",
    "desktop": "bureau",
    "phoneNest": "phone nest",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Crée un modèle de nid de téléphone",
    "heightBottom": "hauteur bas",
    "heightTop": "hauteur haut",
    "widthBack": "largeur arrière",
    "widthFront": "largeur avant",
    "backOffset": "décalage arrière",
    "applyOrnaments": "appliquer ornements",
    "filletRadius": "rayon congé",
    "phoneHeight": "hauteur téléphone",
    "phoneWidth": "largeur téléphone",
    "phoneThickness": "épaisseur téléphone",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Obtient la forme composée du nid de téléphone",
    "PhoneNestData<T>": "données phone nest t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "options dessin",
    "drawOptions": "options dessin",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "crée les options de dessin pour le modèle",
    "mainMaterial": "matériau principal",
    "phoneMaterial": "matériau téléphone",
    "Inputs.Base.Color": "couleur base (entrées)",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "droplets phone holder",
    "laserCutting": "découpe laser",
    "gadgets": "gadgets",
    "dropletsPhoneHolder": "droplets phone holder",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "crée le support téléphone droplets",
    "title": "titre",
    "subtitle": "sous-titre",
    "includeLogo": "inclure logo",
    "kerf": "kerf",
    "backLength": "longueur arrière",
    "offsetAroundPhone": "décalage autour téléphone",
    "penShelf": "étagère stylo",
    "phoneLockHeight": "hauteur verrouillage téléphone",
    "includePattern": "inclure motif",
    "densityPattern": "densité motif",
    "holesForWire": "trous pour fil",
    "wireInputThickness": "épaisseur entrée fil",
    "includeModel": "inclure modèle",
    "includeDrawings": "inclure dessins",
    "spacingDrawings": "espacement dessins",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Obtient la forme composée du support de téléphone gouttelettes",
    "DropletsPhoneHolderData<T>": "données droplets phone holder t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "obtenir fils coupe composé",
    "getCutWiresCompound": "obtenir fils coupe composé",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Obtient le composé des fils de coupe",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "obtenir fils gravure composé",
    "getEngravingWiresCompound": "obtenir fils gravure composé",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Obtient le composé des fils de gravure",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "télécharger dessins dxf",
    "downloadDXFDrawings": "télécharger dessins dxf",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "télécharge le dessin dxf",
    "download": "télécharger",
    "cutWiresColor": "couleur fils coupe",
    "engravingWiresColor": "couleur fils gravure",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "télécharger dessins step",
    "downloadSTEPDrawings": "télécharger dessins step",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "télécharge le dessin step",
    "adjustYZ": "ajuster yz",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "télécharger modèle step 3d",
    "download3dSTEPModel": "télécharger modèle step 3d",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "télécharge le modèle step 3d",
    "bitbybit.things.architecture.houses.zenHideout.create": "zen hideout",
    "architecture": "architecture",
    "houses": "maisons",
    "zenHideout": "zen hideout",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Crée une cachette zen",
    "widthFirstWing": "largeur première aile",
    "lengthFirstWing": "longueur première aile",
    "terraceWidth": "largeur terrasse",
    "widthSecondWing": "largeur seconde aile",
    "lengthSecondWing": "longueur seconde aile",
    "heightWalls": "hauteur murs",
    "roofAngleFirstWing": "angle toit première aile",
    "roofAngleSecondWing": "angle toit seconde aile",
    "roofOffset": "décalage toit",
    "roofInsideOverhang": "débord toit intérieur",
    "roofMaxDistAttachmentBeams": "distance max toit poutres fixation",
    "roofAttachmentBeamWidth": "largeur poutre fixation toit",
    "roofAttachmentBeamHeight": "hauteur poutre fixation toit",
    "roofOutsideOverhang": "débord toit extérieur",
    "columnSize": "taille colonne",
    "ceilingBeamHeight": "hauteur poutre plafond",
    "ceilingBeamWidth": "largeur poutre plafond",
    "nrCeilingBeamsBetweenColumns": "nb poutres plafond entre colonnes",
    "distBetweenColumns": "distance entre colonnes",
    "floorHeight": "hauteur étage",
    "groundLevel": "niveau sol",
    "facadePanelThickness": "épaisseur panneau façade",
    "windowWidthOffset": "décalage largeur fenêtre",
    "windowHeightOffset": "décalage hauteur fenêtre",
    "windowFrameThickness": "épaisseur cadre fenêtre",
    "windowGlassFrameThickness": "épaisseur cadre vitre fenêtre",
    "skinOpacity": "opacité peau",
    "bitbybit.things.furniture.chairs.snakeChair.create": "snake chair",
    "furniture": "mobilier",
    "chairs": "chaises",
    "snakeChair": "snake chair",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Crée un modèle de chaise serpent",
    "sittingHeight": "hauteur assise",
    "backRestOffset": "décalage dossier",
    "backRestHeight": "hauteur dossier",
    "nrOrnamentPlanks": "nb planches ornement",
    "ornamentDepth": "profondeur ornement",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Obtient la forme composée de la chaise",
    "SnakeChairData<T>": "données snake chair t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "obtenir forme fil assise",
    "getSittingWireShape": "obtenir forme fil assise",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Obtient la forme de fil de la zone d'assise de la chaise",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "obtenir point central zone assise",
    "getSittingAreaCenterPoint": "obtenir point central zone assise",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Obtient le point central de la zone d'assise de la chaise",
    "get points": "obtenir points",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "options dessin",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "crée les options de dessin pour la chaise snake",
    "bitbybit.things.furniture.tables.elegantTable.create": "elegant table",
    "tables": "tables",
    "elegantTable": "elegant table",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Crée un modèle de table élégante",
    "topThickness": "épaisseur plateau",
    "topOffset": "décalage plateau",
    "minFillet": "congé min",
    "radiusLegTop": "rayon pied haut",
    "radiusLegBottom": "rayon pied bas",
    "nrLegPairs": "nb paires pieds",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Obtient la forme composée de la table",
    "ElegantTableData<T>": "données elegant table t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "obtenir formes pieds",
    "getLegShapes": "obtenir formes pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Obtient les formes de pied sous forme de liste",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "obtenir forme pied par index",
    "getLegShapeByIndex": "obtenir forme pied par index",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Obtient la forme de pied par index",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "obtenir forme panneau supérieur",
    "getTopPanelShape": "obtenir forme panneau supérieur",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Obtient la forme du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "obtenir forme fil panneau supérieur",
    "getTopPanelWireShape": "obtenir forme fil panneau supérieur",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Obtient la forme de fil du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "obtenir forme fil panneau inférieur",
    "getBottomPanelWireShape": "obtenir forme fil panneau inférieur",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Obtient la forme de fil du panneau inférieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "obtenir forme panneau inférieur",
    "getBottomPanelShape": "obtenir forme panneau inférieur",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Obtient la forme du panneau inférieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "obtenir forme composée pieds",
    "getLegsCompoundShape": "obtenir forme composée pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Obtient les formes de pied sous forme de forme composée",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "obtenir point central plateau table",
    "getTableTopCenterPoint": "obtenir point central plateau table",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Obtient le point central supérieur",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "obtenir point central bas table",
    "getTableBottomCenterPoint": "obtenir point central bas table",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Obtient le point central inférieur",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "obtenir points bas pieds",
    "getLegBottomPoints": "obtenir points bas pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Obtient les points inférieurs des pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obtenir points haut pieds",
    "getLegTopPoints": "obtenir points haut pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Obtient les points supérieurs des pieds",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "options dessin",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "crée les options de dessin pour la table elegant",
    "topMaterial": "matériau plateau",
    "topBaseMaterial": "matériau base plateau",
    "legsMaterial": "matériau pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "good coffee table",
    "goodCoffeeTable": "good coffee table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Crée un bon modèle de table basse",
    "chamfer": "chanfrein",
    "topGlassOffset": "décalage verre supérieur",
    "glassThickness": "épaisseur verre",
    "glassHolderLength": "longueur support verre",
    "shelfTopOffset": "décalage haut étagère",
    "shelfThickness": "épaisseur étagère",
    "legWidth": "largeur pied",
    "legDepth": "profondeur pied",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Obtient la forme composée de la table",
    "GoodCoffeeTableData<T>": "données good coffee table t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "obtenir formes pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Obtient les formes de pied sous forme de liste",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "obtenir forme pied par index",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Obtient la forme de pied par index",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "obtenir forme panneau supérieur",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Obtient la forme du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "obtenir forme fil panneau supérieur",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Obtient la forme de fil du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "obtenir forme panneau verre",
    "getGlassPanelShape": "obtenir forme panneau verre",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Obtient la forme du panneau en verre de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "obtenir forme fil panneau verre",
    "getGlassPanelWireShape": "obtenir forme fil panneau verre",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Obtient la forme de fil du panneau en verre de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "obtenir forme étagère",
    "getShelfShape": "obtenir forme étagère",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Obtient la forme de l'étagère de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "obtenir forme fil haut étagère",
    "getShelfTopWireShape": "obtenir forme fil haut étagère",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Obtient la forme de fil supérieure de l'étagère de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "obtenir forme composée pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Obtient les formes de pied sous forme de forme composée",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "obtenir point central plateau table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Obtient le point central supérieur",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "obtenir point central haut étagère table",
    "getTableShelfTopCenterPoint": "obtenir point central haut étagère table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Obtient le point central supérieur de l'étagère",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "obtenir points bas pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Obtient les points inférieurs des pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obtenir points haut pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Obtient les points supérieurs des pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "options dessin",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "crée les options de dessin pour la table good coffee table",
    "topGlassMaterial": "matériau verre supérieur",
    "shelfMaterial": "matériau étagère",
    "bitbybit.things.furniture.tables.snakeTable.create": "snake table",
    "snakeTable": "snake table",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Crée un modèle de table serpent",
    "supportLength": "longueur support",
    "shelfHeight": "hauteur étagère",
    "glassOffset": "décalage verre",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Obtient la forme composée de la table",
    "SnakeTableData<T>": "données snake table t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "obtenir forme verre",
    "getGlassShape": "obtenir forme verre",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Obtient la forme en verre de la table",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "obtenir forme principale",
    "getMainShape": "obtenir forme principale",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Obtient la forme solide principale de la table",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "obtenir point central haut",
    "getTopCenterPoint": "obtenir point central haut",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Obtient le point central du dessus de la table",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "options dessin",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "crée les options de dessin pour la table snake",
    "glassMaterial": "matériau verre",
    "bitbybit.things.enums.lodEnum": "énumération lod",
    "enums": "énumérations",
    "lodEnum": "énumération lod",
    "bitbybit.things.enums.lodEnum_description": "Crée une valeur d'énumération de niveau de détail",
    "bitbybit.jscad.transformSolids": "transformer solides",
    "jscad": "jscad",
    "transformSolids": "transformer solides",
    "bitbybit.jscad.transformSolids_description": "Transforme les maillages solides Jscad avec une liste donnée de transformations.",
    "JSCADEntity[]": "tableau entité jscad",
    "bitbybit.jscad.transformSolid": "transformer solide",
    "transformSolid": "transformer solide",
    "bitbybit.jscad.transformSolid_description": "Transforme le maillage solide Jscad avec une liste donnée de transformations.",
    "JSCADEntity": "entité jscad",
    "bitbybit.jscad.downloadSolidSTL": "télécharger solide stl",
    "downloadSolidSTL": "télécharger solide stl",
    "bitbybit.jscad.downloadSolidSTL_description": "Télécharge le fichier STL binaire à partir d'un solide 3D",
    "bitbybit.jscad.downloadSolidsSTL": "télécharger solides stl",
    "downloadSolidsSTL": "télécharger solides stl",
    "bitbybit.jscad.downloadSolidsSTL_description": "Télécharge le fichier STL binaire à partir de solides 3D",
    "bitbybit.jscad.downloadGeometryDxf": "télécharger géométrie dxf",
    "downloadGeometryDxf": "télécharger géométrie dxf",
    "bitbybit.jscad.downloadGeometryDxf_description": "Télécharge le fichier dxf de la géométrie jscad. Prend en charge les chemins et les maillages dans un tableau.",
    "geometry": "géométrie",
    "JSCADEntity | JSCADEntity[]": "entité jscad ou tableau",
    "bitbybit.jscad.downloadGeometry3MF": "télécharger géométrie 3mf",
    "downloadGeometry3MF": "télécharger géométrie 3mf",
    "bitbybit.jscad.downloadGeometry3MF_description": "Télécharge le fichier 3MF de la géométrie jscad.",
    "bitbybit.jscad.booleans.intersect": "intersecter",
    "intersect": "intersecter",
    "bitbybit.jscad.booleans.intersect_description": "Intersection de plusieurs objets de maillage solide",
    "bitbybit.jscad.booleans.subtract": "soustraire",
    "subtract": "soustraire",
    "bitbybit.jscad.booleans.subtract_description": "Soustraction de plusieurs objets de maillage solide",
    "bitbybit.jscad.booleans.union": "unir",
    "bitbybit.jscad.booleans.union_description": "Union de plusieurs objets de maillage solide",
    "bitbybit.jscad.booleans.intersectTwo": "intersecter deux",
    "intersectTwo": "intersecter deux",
    "bitbybit.jscad.booleans.intersectTwo_description": "Intersection de deux objets de maillage solide",
    "bitbybit.jscad.booleans.subtractTwo": "soustraire deux",
    "subtractTwo": "soustraire deux",
    "bitbybit.jscad.booleans.subtractTwo_description": "Soustraction de deux objets de maillage solide",
    "bitbybit.jscad.booleans.unionTwo": "unir deux",
    "unionTwo": "unir deux",
    "bitbybit.jscad.booleans.unionTwo_description": "Union de deux objets de maillage solide",
    "bitbybit.jscad.booleans.subtractFrom": "soustraire de",
    "subtractFrom": "soustraire de",
    "bitbybit.jscad.booleans.subtractFrom_description": "Soustraction de plusieurs maillages d'un objet de maillage",
    "bitbybit.jscad.expansions.expand": "étendre",
    "expansions": "expansions",
    "expand": "étendre",
    "bitbybit.jscad.expansions.expand_description": "Étendre les géométries de catégorie solide",
    "expansion": "expansion",
    "delta": "delta",
    "corners": "coins",
    "solidCornerTypeEnum": "énumération type coin solide",
    "bitbybit.jscad.expansions.offset": "décaler",
    "bitbybit.jscad.expansions.offset_description": "Décalage des géométries 2d de catégorie solide",
    "bitbybit.jscad.extrusions.extrudeLinear": "extruder linéaire",
    "extrudeLinear": "extruder linéaire",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Extruder linéairement les géométries 2D de catégorie solide",
    "twistAngle": "angle torsion",
    "twistSteps": "pas torsion",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extruder rectangulaire",
    "extrudeRectangular": "extruder rectangulaire",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Extruder rectangulairement les géométries 2D de catégorie solide. Crée une extrusion de type mur d'une certaine hauteur et taille.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extruder points rectangulaires",
    "extrudeRectangularPoints": "extruder points rectangulaires",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Extruder rectangulairement une liste de points 2D. Crée une extrusion de type mur d'une certaine hauteur et taille.",
    "bitbybit.jscad.extrusions.extrudeRotate": "extruder pivoter",
    "extrudeRotate": "extruder pivoter",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Extruder rectangulairement une liste de points 2D. Crée une extrusion de type mur d'une certaine hauteur et taille.",
    "polygon": "polygone",
    "startAngle": "angle départ",
    "bitbybit.jscad.hulls.hullChain": "enveloppe chaîne",
    "hulls": "enveloppes",
    "hullChain": "enveloppe chaîne",
    "bitbybit.jscad.hulls.hullChain_description": "La chaîne d'enveloppe connecte des solides ou des géométries 2d en remplissant un espace vide entre les objets dans l'ordre. Les géométries doivent être du même type.",
    "bitbybit.jscad.hulls.hull": "enveloppe",
    "hull": "enveloppe",
    "bitbybit.jscad.hulls.hull_description": "L'enveloppe convexe connecte des solides ou des géométries 2d en remplissant un espace vide entre eux sans suivre l'ordre. Les géométries doivent être du même type.",
    "bitbybit.jscad.path.createFromPoints": "depuis points",
    "createFromPoints": "depuis points",
    "bitbybit.jscad.path.createFromPoints_description": "Crée un chemin 2D à partir d'une liste de points",
    "Base.Point2[]": "tableau point2 base",
    "bitbybit.jscad.path.createPathsFromPoints": "chemins depuis points",
    "createPathsFromPoints": "chemins depuis points",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Crée des chemins 2D à partir de listes de points",
    "pointsLists": "listes points",
    "Base.Point3[][] | Base.Point2[][]": "tableau tableau point3 ou point2 base",
    "bitbybit.jscad.path.createFromPolyline": "depuis polyligne",
    "createFromPolyline": "depuis polyligne",
    "bitbybit.jscad.path.createFromPolyline_description": "Crée un chemin 2D à partir d'une polyligne",
    "bitbybit.jscad.path.createEmpty": "vide",
    "createEmpty": "vide",
    "bitbybit.jscad.path.createEmpty_description": "Crée un chemin 2D vide",
    "bitbybit.jscad.path.close": "fermer",
    "close": "fermer",
    "bitbybit.jscad.path.close_description": "Ferme un chemin 2D ouvert",
    "bitbybit.jscad.path.appendPoints": "ajouter points",
    "appendPoints": "ajouter points",
    "bitbybit.jscad.path.appendPoints_description": "Ajoute le chemin avec des points 2D",
    "append": "ajouter",
    "bitbybit.jscad.path.appendPolyline": "ajouter polyligne",
    "appendPolyline": "ajouter polyligne",
    "bitbybit.jscad.path.appendPolyline_description": "Ajoute le chemin avec une polyligne",
    "bitbybit.jscad.path.appendArc": "ajouter arc",
    "appendArc": "ajouter arc",
    "bitbybit.jscad.path.appendArc_description": "Ajoute l'arc au chemin",
    "xAxisRotation": "rotation axe x",
    "clockwise": "sens horaire",
    "large": "grand",
    "bitbybit.jscad.polygon.createFromPoints": "depuis points",
    "bitbybit.jscad.polygon.createFromPoints_description": "Crée un polygone 2D à partir d'une liste de points",
    "bitbybit.jscad.polygon.createFromPolyline": "depuis polyligne",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Crée un polygone 2D à partir d'une polyligne",
    "bitbybit.jscad.polygon.createFromCurve": "depuis courbe",
    "createFromCurve": "depuis courbe",
    "bitbybit.jscad.polygon.createFromCurve_description": "Crée un polygone 2D à partir d'une courbe",
    "bitbybit.jscad.polygon.createFromPath": "depuis chemin",
    "createFromPath": "depuis chemin",
    "bitbybit.jscad.polygon.createFromPath_description": "Crée un polygone 2D à partir d'un chemin",
    "bitbybit.jscad.polygon.circle": "cercle",
    "bitbybit.jscad.polygon.circle_description": "Crée un polygone cercle 2D",
    "bitbybit.jscad.polygon.ellipse": "ellipse",
    "ellipse": "ellipse",
    "bitbybit.jscad.polygon.ellipse_description": "Crée un polygone ellipse 2D",
    "bitbybit.jscad.polygon.rectangle": "rectangle",
    "rectangle": "rectangle",
    "bitbybit.jscad.polygon.rectangle_description": "Crée un polygone rectangle 2D",
    "bitbybit.jscad.polygon.roundedRectangle": "rectangle arrondi",
    "roundedRectangle": "rectangle arrondi",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Crée un rectangle arrondi 2D",
    "roundRadius": "rayon arrondi",
    "bitbybit.jscad.polygon.square": "carré",
    "square": "carré",
    "bitbybit.jscad.polygon.square_description": "Crée un polygone carré 2D",
    "bitbybit.jscad.polygon.star": "étoile",
    "star": "étoile",
    "bitbybit.jscad.polygon.star_description": "Crée un polygone étoile 2D",
    "vertices": "sommets",
    "bitbybit.jscad.shapes.cube": "cube",
    "cube": "cube",
    "bitbybit.jscad.shapes.cube_description": "Crée une forme de cube 3D",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubes sur points centraux",
    "cubesOnCenterPoints": "cubes sur points centraux",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Crée des cubes 3D sur plusieurs points centraux",
    "primitives on centers": "primitives sur centres",
    "bitbybit.jscad.shapes.cuboid": "parallélépipède rectangle",
    "cuboid": "parallélépipède rectangle",
    "bitbybit.jscad.shapes.cuboid_description": "Crée une forme de cuboïde 3D",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "parallélépipèdes rectangles sur points centraux",
    "cuboidsOnCenterPoints": "parallélépipèdes rectangles sur points centraux",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Crée des cuboïdes 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.cylinderElliptic": "cylindre elliptique",
    "cylinderElliptic": "cylindre elliptique",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Crée un solide cylindre elliptique 3D",
    "startRadius": "rayon départ",
    "endRadius": "rayon fin",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cylindre elliptique sur points centraux",
    "cylinderEllipticOnCenterPoints": "cylindre elliptique sur points centraux",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Crée des cylindres elliptiques 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.cylinder": "cylindre",
    "cylinder": "cylindre",
    "bitbybit.jscad.shapes.cylinder_description": "Crée un solide cylindre 3D",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cylindres sur points centraux",
    "cylindersOnCenterPoints": "cylindres sur points centraux",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Crée des cylindres 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.ellipsoid": "ellipsoïde",
    "ellipsoid": "ellipsoïde",
    "bitbybit.jscad.shapes.ellipsoid_description": "Crée un solide ellipsoïde 3D",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "ellipsoïdes sur points centraux",
    "ellipsoidsOnCenterPoints": "ellipsoïdes sur points centraux",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Crée des ellipsoïdes 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.geodesicSphere": "sphère géodésique",
    "geodesicSphere": "sphère géodésique",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Crée un solide sphère géodésique 3D",
    "frequency": "fréquence",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "sphères géodésiques sur points centraux",
    "geodesicSpheresOnCenterPoints": "sphères géodésiques sur points centraux",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Crée des sphères géodésiques 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.roundedCuboid": "parallélépipède rectangle arrondi",
    "roundedCuboid": "parallélépipède rectangle arrondi",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Crée un solide cuboïde arrondi 3D",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "parallélépipèdes rectangles arrondis sur points centraux",
    "roundedCuboidsOnCenterPoints": "parallélépipèdes rectangles arrondis sur points centraux",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Crée des cuboïdes arrondis 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.roundedCylinder": "cylindre arrondi",
    "roundedCylinder": "cylindre arrondi",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Crée un solide cylindre arrondi 3D",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "cylindres arrondis sur points centraux",
    "roundedCylindersOnCenterPoints": "cylindres arrondis sur points centraux",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Crée des cylindres arrondis 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.sphere": "sphère",
    "sphere": "sphère",
    "bitbybit.jscad.shapes.sphere_description": "Crée un solide sphère 3D",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "sphères sur points centraux",
    "spheresOnCenterPoints": "sphères sur points centraux",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Crée une sphère 3D sur plusieurs points centraux",
    "bitbybit.jscad.shapes.torus": "tore",
    "torus": "tore",
    "bitbybit.jscad.shapes.torus_description": "Crée un solide tore 3D",
    "innerSegments": "segments intérieurs",
    "outerSegments": "segments extérieurs",
    "innerRotation": "rotation intérieure",
    "outerRotation": "rotation extérieure",
    "bitbybit.jscad.shapes.fromPolygonPoints": "depuis points polygone",
    "fromPolygonPoints": "depuis points polygone",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Crée une forme 3D à partir de points de polygone qui doivent être des tableaux imbriqués de points",
    "polygonPoints": "points polygone",
    "Base.Point3[][]": "tableau tableau point3 base",
    "bitbybit.jscad.text.cylindricalText": "texte cylindrique",
    "cylindricalText": "texte cylindrique",
    "bitbybit.jscad.text.cylindricalText_description": "Crée un texte basé sur l'enveloppe de chaîne de cylindres",
    "extrusionHeight": "hauteur extrusion",
    "extrusionSize": "taille extrusion",
    "jscadTextAlignEnum": "énumération alignement texte jscad",
    "bitbybit.jscad.text.sphericalText": "texte sphérique",
    "sphericalText": "texte sphérique",
    "bitbybit.jscad.text.sphericalText_description": "Crée un texte basé sur l'enveloppe de chaîne de sphères",
    "bitbybit.jscad.text.createVectorText": "texte vectoriel",
    "createVectorText": "texte vectoriel",
    "bitbybit.jscad.text.createVectorText_description": "Crée un texte vectoriel",
    "bitbybit.jscad.colors.colorize": "coloriser",
    "colors": "couleurs",
    "colorize": "coloriser",
    "bitbybit.jscad.colors.colorize_description": "Colorise la géométrie de jscad. Si la géométrie est dans le tableau, il colorisera tous les éléments et les renverra. Si la géométrie est un élément unique, il renverra un élément unique. Gardez à l'esprit que la géométrie colorisée dans jscad sera toujours dessinée dans cette couleur même si vous essayez de la changer via les options de dessin.",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold vers pointeur maillage",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold vers pointeur maillage",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Transforme la forme manifold en un pointeur de maillage qui vit dans la mémoire du travailleur. Ce pointeur peut être utilisé avec les fonctions bitbybit.manifold.mesh",
    "meshing": "maillage",
    "normalIdx": "idx normale",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "décomposer manifold ou section transversale",
    "decomposeManifoldOrCrossSection": "décomposer manifold ou section transversale",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Décompose la forme manifold ou la section transversale en un maillage ou des polygones simples",
    "decompose": "décomposer",
    "manifoldOrCrossSection": "manifold ou section transversale",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "décomposer manifolds ou sections transversales",
    "decomposeManifoldsOrCrossSections": "décomposer manifolds ou sections transversales",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Décompose la forme manifold ou la section transversale en un maillage ou des polygones simples",
    "manifoldsOrCrossSections": "manifolds ou sections transversales",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "supprimer manifold ou section transversale",
    "deleteManifoldOrCrossSection": "supprimer manifold ou section transversale",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Supprime le manifold ou la section transversale de la mémoire",
    "cleanup": "nettoyage",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "supprimer manifolds ou sections transversales",
    "deleteManifoldsOrCrossSections": "supprimer manifolds ou sections transversales",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Supprime les manifolds ou les sections transversales de la mémoire",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold vers maillage",
    "manifoldToMesh": "manifold vers maillage",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Transforme la forme manifold en un maillage",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds vers maillages",
    "manifoldsToMeshes": "manifolds vers maillages",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "transforme les formes manifold en maillages",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold depuis maillage",
    "manifoldFromMesh": "manifold depuis maillage",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Convertit un Maillage en un Manifold, en conservant ses propriétés et en fusionnant uniquement les positions selon les vecteurs de fusion. Lancera une erreur si le résultat n'est pas un 2-manifold orienté. Réduira les triangles dégénérés et les sommets inutiles. Tous les champs sont lus, ce qui rend cette structure adaptée à un aller-retour sans perte de données depuis manifoldToMesh(). Pour une entrée multi-matériaux, utilisez reserveIDs() pour définir un originalID unique pour chaque matériau, et triez les matériaux en séries de triangles.",
    "DecomposedManifoldMeshDto": "dto maillage manifold décomposé",
    "bitbybit.manifold.manifold.shapes.cube": "cube",
    "bitbybit.manifold.manifold.shapes.cube_description": "Crée une forme de cube 3D",
    "bitbybit.manifold.manifold.shapes.sphere": "sphère",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Crée une forme de sphère 3D",
    "circularSegments": "segments circulaires",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tétraèdre",
    "tetrahedron": "tétraèdre",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Crée une forme de tétraèdre 3D",
    "bitbybit.manifold.manifold.shapes.cylinder": "cylindre",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Crée une forme de cylindre 3D",
    "radiusLow": "rayon bas",
    "radiusHigh": "rayon haut",
    "bitbybit.manifold.manifold.booleans.subtract": "soustraire",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Soustrait deux formes manifold",
    "a to b": "a à b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "ajouter",
    "bitbybit.manifold.manifold.booleans.add_description": "Ajoute deux formes manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "intersecter",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Intersecte deux formes manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "différence deux",
    "differenceTwo": "différence deux",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "différence de deux formes manifold",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "union deux",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "union de deux formes manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "intersection deux",
    "intersectionTwo": "intersection deux",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "intersection de deux formes manifold",
    "bitbybit.manifold.manifold.booleans.difference": "différence",
    "bitbybit.manifold.manifold.booleans.difference_description": "différence de plusieurs formes manifold",
    "bitbybit.manifold.manifold.booleans.union": "union",
    "bitbybit.manifold.manifold.booleans.union_description": "union de plusieurs formes manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "intersection",
    "bitbybit.manifold.manifold.booleans.intersection_description": "intersection de plusieurs formes manifold",
    "bitbybit.manifold.manifold.booleans.split": "diviser",
    "split": "diviser",
    "bitbybit.manifold.manifold.booleans.split_description": "Divise le manifold par un autre manifold",
    "manifoldToSplit": "manifold à diviser",
    "manifoldCutter": "coupeur manifold",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "diviser par plan",
    "splitByPlane": "diviser par plan",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Divise le manifold par un plan",
    "originOffset": "décalage origine",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "diviser par plan sur décalages",
    "splitByPlaneOnOffsets": "diviser par plan sur décalages",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Divise le manifold par un plan sur divers décalages",
    "originOffsets": "décalages origine",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "couper par plan",
    "trimByPlane": "couper par plan",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Coupe le manifold par un plan",
    "trim": "couper",
    "bitbybit.manifold.manifold.operations.hull": "enveloppe",
    "bitbybit.manifold.manifold.operations.hull_description": "Calcule l'enveloppe convexe de la forme manifold fournie",
    "bitbybit.manifold.manifold.operations.hullPoints": "envelopper points",
    "hullPoints": "envelopper points",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Enveloppe de points ou manifolds",
    "bitbybit.manifold.manifold.operations.slice": "tranche",
    "bitbybit.manifold.manifold.operations.slice_description": "Renvoie la section transversale de cet objet parallèle au plan X-Y à la hauteur spécifiée. L'utilisation d'une hauteur égale au bas de la boîte englobante renverra les faces inférieures, tandis que l'utilisation d'une hauteur égale au haut de la boîte englobante renverra vide.",
    "cross sections": "sections transversales",
    "bitbybit.manifold.manifold.operations.project": "projeter",
    "bitbybit.manifold.manifold.operations.project_description": "Crée une projection sur le plan xy à partir du contour de la forme",
    "bitbybit.manifold.manifold.operations.setTolerance": "définir tolérance",
    "setTolerance": "définir tolérance",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Renvoie une copie du manifold avec la valeur de tolérance définie. Cela effectue une simplification du maillage lorsque la valeur de tolérance est augmentée.",
    "basic": "basique",
    "bitbybit.manifold.manifold.operations.reserveIds": "réserver ids",
    "reserveIds": "réserver ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Renvoie le premier de n nouveaux ID de maillage uniques séquentiels pour marquer des ensembles de triangles qui peuvent être recherchés après d'autres opérations. Assigner au vecteur Mesh.runOriginalID.",
    "count": "compter",
    "bitbybit.manifold.manifold.operations.asOriginal": "comme original",
    "asOriginal": "comme original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "Si vous copiez un manifold, mais que vous souhaitez que cette nouvelle copie ait de nouvelles propriétés (par exemple, un mappage UV différent), vous pouvez réinitialiser ses ID à un nouvel original, ce qui signifie qu'il sera désormais référencé par ses descendants au lieu des maillages à partir desquels il a été construit, vous permettant de différencier les copies lors de l'application de vos propriétés au résultat final. Cette fonction condense également toutes les faces coplanaires dans la relation et réduit ces arêtes. Si vous souhaitez avoir des propriétés incohérentes sur ces faces, ce qui signifie que vous souhaitez préserver certaines de ces arêtes, vous devez plutôt appeler GetMesh(), calculer vos propriétés et les utiliser pour construire un nouveau manifold.",
    "bitbybit.manifold.manifold.operations.compose": "composer",
    "compose": "composer",
    "bitbybit.manifold.manifold.operations.compose_description": "Construit un nouveau manifold à partir d'une liste d'autres manifolds. Il s'agit d'une opération purement topologique, il faut donc veiller à éviter de créer des résultats qui se chevauchent. C'est l'opération inverse de Decompose().",
    "composition": "composition",
    "bitbybit.manifold.manifold.operations.decompose": "décomposer",
    "bitbybit.manifold.manifold.operations.decompose_description": "Cette opération renvoie un vecteur de Manifolds qui sont topologiquement déconnectés. Si tout est connecté, le vecteur est de longueur un, contenant une copie de l'original. C'est l'opération inverse de Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calculer normales",
    "calculateNormals": "calculer normales",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Remplit les propriétés de sommet pour les vecteurs normaux, calculées à partir de la géométrie du maillage. Les faces plates composées de trois triangles ou plus resteront plates.",
    "adjustments": "ajustements",
    "minSharpAngle": "angle aigu min",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calculer courbure",
    "calculateCurvature": "calculer courbure",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "La courbure est l'inverse du rayon de courbure, et signée de telle sorte que positif est convexe et négatif est concave. Il y a deux courbures principales orthogonales en tout point d'un manifold, avec un maximum et l'autre minimum. La courbure gaussienne est leur produit, tandis que la courbure moyenne est leur somme. Cela les approxime pour chaque sommet et les affecte comme propriétés de sommet sur les canaux donnés.",
    "gaussianIdx": "idx gaussien",
    "meanIdx": "idx moyen",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "affiner à tolérance",
    "refineToTolerance": "affiner à tolérance",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Augmente la densité du maillage en divisant chaque arête en morceaux de sorte que tout point sur les triangles résultants soit grossièrement dans la tolérance de la surface doucement courbée définie par les vecteurs tangents. Cela signifie que les régions à forte courbure seront divisées plus finement que les régions plus douces. Si halfedgeTangents ne sont pas présents, le résultat sera simplement une copie de l'original. Les quads ignoreront leur bissectrice de triangle intérieur.",
    "bitbybit.manifold.manifold.operations.refineToLength": "affiner à longueur",
    "refineToLength": "affiner à longueur",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Augmente la densité du maillage en divisant chaque arête en morceaux d'environ la longueur d'entrée. Des sommets intérieurs sont ajoutés pour garder le reste des arêtes de triangulation également d'environ la même longueur. Si halfedgeTangents sont présents (par exemple, du constructeur Smooth()), les nouveaux sommets seront déplacés vers la surface interpolée selon leurs coordonnées barycentriques.",
    "bitbybit.manifold.manifold.operations.refine": "affiner",
    "refine": "affiner",
    "bitbybit.manifold.manifold.operations.refine_description": "Augmente la densité du maillage en divisant chaque arête en n morceaux. Par exemple, avec n = 2, chaque triangle sera divisé en 4 triangles. Ceux-ci seront tous coplanaires (et ne seront pas immédiatement réduits) à moins que le MeshManifold ait halfedgeTangents spécifiés (par exemple, du constructeur Smooth()), auquel cas les nouveaux sommets seront déplacés vers la surface interpolée selon leurs coordonnées barycentriques.",
    "bitbybit.manifold.manifold.operations.smoothOut": "lisser",
    "smoothOut": "lisser",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Lisse le Manifold en remplissant les vecteurs halfedgeTangent. La géométrie restera inchangée jusqu'à ce que Refine ou RefineToLength soit appelé pour interpoler la surface. Cette version utilise la géométrie des triangles et des pseudo-normales pour définir les vecteurs tangents.",
    "minSmoothness": "lissité min",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "lisser par normales",
    "smoothByNormals": "lisser par normales",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Lisse le Manifold en remplissant les vecteurs halfedgeTangent. La géométrie restera inchangée jusqu'à ce que Refine ou RefineToLength soit appelé pour interpoler la surface. Cette version utilise les propriétés normales de sommet fournies pour définir les vecteurs tangents.",
    "bitbybit.manifold.manifold.transforms.scale3D": "échelle 3d",
    "scale3D": "échelle 3d",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Met à l'échelle une forme manifold avec un vecteur 3D",
    "bitbybit.manifold.manifold.transforms.scale": "échelle",
    "bitbybit.manifold.manifold.transforms.scale_description": "Met à l'échelle une forme manifold avec un facteur unique",
    "bitbybit.manifold.manifold.transforms.mirror": "miroir",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Miroir une forme manifold sur un plan défini par un vecteur normal",
    "bitbybit.manifold.manifold.transforms.translate": "translater",
    "bitbybit.manifold.manifold.transforms.translate_description": "Translate une forme manifold le long du vecteur",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "translater par vecteurs",
    "translateByVectors": "translater par vecteurs",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Translate une forme manifold par plusieurs vecteurs",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "translater xyz",
    "translateXYZ": "translater xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Translate une forme manifold le long de x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "pivoter",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Fait pivoter une forme manifold le long du vecteur contenant des angles d'euler",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "pivoter xyz",
    "rotateXYZ": "pivoter xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Fait pivoter une forme manifold le long des angles d'euler x y z",
    "bitbybit.manifold.manifold.transforms.transform": "transformer",
    "bitbybit.manifold.manifold.transforms.transform_description": "Transforme une forme manifold en utilisant la matrice de transformation 4x4",
    "matrix": "matrice",
    "Base.TransformMatrix": "matrice transformation base",
    "bitbybit.manifold.manifold.transforms.transforms": "transformations",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Transforme une forme manifold en utilisant les matrices de transformation 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "aire surface",
    "evaluate": "évaluer",
    "surfaceArea": "aire surface",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Obtenir la surface du manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volume",
    "volume": "volume",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Obtenir le volume du manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "est vide",
    "isEmpty": "est vide",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Vérifier si le manifold contient des triangles",
    "bitbybit.manifold.manifold.evaluate.numVert": "nb sommets",
    "numVert": "nb sommets",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Obtenir le nombre de sommets dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "nb triangles",
    "numTri": "nb triangles",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Obtenir le nombre de triangles dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "nb arêtes",
    "numEdge": "nb arêtes",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Obtenir le nombre d'arêtes dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "nb propriétés",
    "numProp": "nb propriétés",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Obtenir le nombre de propriétés dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "nb sommets propriété",
    "numPropVert": "nb sommets propriété",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "Le nombre de sommets de propriété dans le Manifold. Ce sera toujours >= numVert, car certains sommets physiques peuvent être dupliqués pour tenir compte de différentes propriétés sur différents triangles voisins.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "boîte englobante",
    "boundingBox": "boîte englobante",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Renvoie la boîte englobante alignée sur l'axe de tous les sommets du Manifold.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolérance",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Renvoie la tolérance des sommets de ce Manifold, qui suit l'erreur d'arrondi approximative sur toutes les transformations et opérations qui ont conduit à cet état. Tout triangle colinéaire dans cette tolérance est considéré comme dégénéré et supprimé.",
    "bitbybit.manifold.manifold.evaluate.genus": "genre",
    "genus": "genre",
    "bitbybit.manifold.manifold.evaluate.genus_description": "Le genre est une propriété topologique du manifold, représentant le nombre d'anses. Une sphère est 0, un tore 1, etc. Cela n'est significatif que pour un seul maillage, il est donc préférable d'appeler Decompose() d'abord.",
    "bitbybit.manifold.manifold.evaluate.minGap": "écart min",
    "minGap": "écart min",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Renvoie l'espace minimum entre deux manifolds. Renvoie un flottant entre 0 et searchLength.",
    "searchLength": "longueur recherche",
    "bitbybit.manifold.manifold.evaluate.originalID": "id original",
    "originalID": "id original",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "Si ce maillage est un original, cela renvoie son ID qui peut être référencé par des manifolds produits. Si ce manifold est un produit, cela renvoie -1.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "section transversale vers polygones",
    "crossSection": "section transversale",
    "crossSectionToPolygons": "section transversale vers polygones",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "transforme la section transversale en polygones",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "sections transversales vers polygones",
    "crossSectionsToPolygons": "sections transversales vers polygones",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "transforme les sections transversales en polygones",
    "crossSections": "sections transversales",
    "bitbybit.manifold.crossSection.shapes.create": "créer",
    "bitbybit.manifold.crossSection.shapes.create_description": "Crée une section transversale 2d à partir d'un ensemble de contours (polygones complexes). Une opération d'union booléenne (avec une règle de remplissage Positive par défaut) est effectuée pour combiner les polygones qui se chevauchent et garantir que la section transversale résultante est exempte d'intersections.",
    "Base.Vector2[][]": "tableau tableau vecteur2 base",
    "fillRule": "règle remplissage",
    "fillRuleEnum": "énumération règle remplissage",
    "bitbybit.manifold.crossSection.shapes.square": "carré",
    "bitbybit.manifold.crossSection.shapes.square_description": "Crée une section transversale carrée 2D",
    "bitbybit.manifold.crossSection.shapes.circle": "cercle",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Crée une section transversale circulaire 2D",
    "bitbybit.manifold.crossSection.shapes.rectangle": "rectangle",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Crée une section transversale rectangulaire 2D",
    "bitbybit.manifold.crossSection.operations.hull": "enveloppe",
    "bitbybit.manifold.crossSection.operations.hull_description": "Calcule l'enveloppe convexe pour la section transversale",
    "bitbybit.manifold.crossSection.operations.extrude": "extruder",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Extrude la section transversale pour créer une forme 3D",
    "nDivisions": "n divisions",
    "twistDegrees": "degrés torsion",
    "scaleTopX": "échelle haut x",
    "scaleTopY": "échelle haut y",
    "bitbybit.manifold.crossSection.operations.revolve": "révolution",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Révolutionne la section transversale pour créer une forme 3D",
    "revolveDegrees": "degrés révolution",
    "matchProfile": "correspondre profil",
    "bitbybit.manifold.crossSection.operations.offset": "décaler",
    "bitbybit.manifold.crossSection.operations.offset_description": "Décale la section transversale pour créer une nouvelle section transversale avec un delta donné (utilise l'algorithme Clipper2 derrière).",
    "manifoldJoinTypeEnum": "énumération type jonction manifold",
    "miterLimit": "limite onglet",
    "bitbybit.manifold.crossSection.operations.simplify": "simplifier",
    "simplify": "simplifier",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Supprime les sommets des contours de cette section transversale qui sont à moins de la distance epsilon spécifiée d'une ligne imaginaire qui passe par ses deux sommets adjacents. Les sommets presque dupliqués et les points colinéaires seront supprimés à des epsilons inférieurs, l'élimination des segments de ligne devenant de plus en plus agressive avec des epsilons plus grands. Il est recommandé d'appliquer cette fonction après Offset, afin de nettoyer tout minuscule segment de ligne parasite introduit qui n'améliore pas les opérations de décalage à effectuer, ce qui aggraverait le problème.",
    "epsilon": "epsilon",
    "bitbybit.manifold.crossSection.operations.compose": "composer",
    "bitbybit.manifold.crossSection.operations.compose_description": "Compose plusieurs sections transversales ou polygones en une seule section transversale",
    "bitbybit.manifold.crossSection.operations.decompose": "décomposer",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Décompose les sections transversales qui sont topologiquement déconnectées, chacune contenant un contour extérieur avec zéro ou plusieurs trous.",
    "bitbybit.manifold.crossSection.booleans.subtract": "soustraire",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Soustrait deux sections transversales",
    "crossSection1": "section transversale 1",
    "crossSection2": "section transversale 2",
    "bitbybit.manifold.crossSection.booleans.add": "ajouter",
    "bitbybit.manifold.crossSection.booleans.add_description": "Ajoute deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.intersect": "intersecter",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Intersecte deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "différence deux",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "différence de deux sections transversales",
    "2 cross sections": "2 sections transversales",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "union deux",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "union de deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "intersection deux",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "intersection de deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.difference": "différence",
    "bitbybit.manifold.crossSection.booleans.difference_description": "différence de plusieurs sections transversales",
    "bitbybit.manifold.crossSection.booleans.union": "union",
    "bitbybit.manifold.crossSection.booleans.union_description": "union de plusieurs sections transversales",
    "bitbybit.manifold.crossSection.booleans.intersection": "intersection",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "intersection de plusieurs sections transversales",
    "bitbybit.manifold.crossSection.transforms.scale2D": "échelle 2d",
    "scale2D": "échelle 2d",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Met à l'échelle une forme de section transversale avec un vecteur 2D",
    "bitbybit.manifold.crossSection.transforms.scale": "échelle",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Met à l'échelle une forme de section transversale avec un facteur unique",
    "bitbybit.manifold.crossSection.transforms.mirror": "miroir",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Miroir une forme de section transversale sur un plan défini par un vecteur normal",
    "bitbybit.manifold.crossSection.transforms.translate": "translater",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Translate une forme de section transversale le long du vecteur",
    "bitbybit.manifold.crossSection.transforms.translateXY": "translater xy",
    "translateXY": "translater xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Translate une forme de section transversale le long de x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "pivoter",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Fait pivoter une forme de section transversale le long des degrés contenus",
    "degrees": "degrés",
    "bitbybit.manifold.crossSection.transforms.transform": "transformer",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Transforme une forme de section transversale en utilisant la matrice de transformation 3x3",
    "Base.TransformMatrix3x3": "matrice transformation base 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "aire",
    "area": "aire",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Obtenir l'aire de la section transversale",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "est vide",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Vérifier si la section transversale est vide",
    "bitbybit.manifold.crossSection.evaluate.numVert": "nb sommets",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Obtenir le nombre de sommets dans la section transversale",
    "bitbybit.manifold.crossSection.evaluate.numContour": "nb contours",
    "numContour": "nb contours",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Obtenir le nombre de contours dans la section transversale",
    "bitbybit.manifold.crossSection.evaluate.bounds": "limites",
    "bounds": "limites",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Obtenir les limites du contour sous forme de rectangle. La sortie est donnée en deux points vec2 dans le tableau. Le premier tableau est le point min et le deuxième tableau est le point max.",
    "bitbybit.manifold.mesh.operations.merge": "fusionner",
    "merge": "fusionner",
    "bitbybit.manifold.mesh.operations.merge_description": "Met à jour les vecteurs mergeFromVert et mergeToVert afin de créer un solide manifold. Si le MeshGL est déjà manifold, aucun changement ne se produira et la fonction renverra faux. Sinon, cela fusionnera les sommets le long des arêtes ouvertes dans la tolérance (le maximum de la tolérance MeshGL et de la tolérance de la boîte englobante de base), en gardant ceux des vecteurs de fusion existants. Il n'y a aucune garantie que le résultat soit manifold - il s'agit d'une fonction d'aide au mieux conçue principalement pour aider dans le cas où un MeshGL multi-matériaux manifold a été produit, mais ses vecteurs de fusion ont été perdus en raison d'un aller-retour via un format de fichier. La construction d'un Manifold à partir du résultat signalera un Statut s'il n'est pas manifold.",
    "bitbybit.manifold.mesh.evaluate.position": "position",
    "bitbybit.manifold.mesh.evaluate.position_description": "Obtenir la position sur l'index de sommet de maillage",
    "vertexIndex": "index sommet",
    "bitbybit.manifold.mesh.evaluate.verts": "sommets",
    "verts": "sommets",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Obtient les trois indices de sommet de ce triangle dans l'ordre CCW.",
    "triangleIndex": "index triangle",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangente",
    "tangent": "tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Obtient le vecteur tangent commençant à verts(tri)[j] pointant vers le prochain point de Bezier le long de l'arête CCW. La quatrième valeur est son poids.",
    "halfEdgeIndex": "index demi-arête",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Obtient toutes les autres propriétés associées à ce sommet.",
    "bitbybit.manifold.mesh.evaluate.transform": "transformer",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Obtient la transformation matricielle 4x4 majeure de colonne du maillage d'origine à ces triangles liés.",
    "bitbybit.manifold.mesh.evaluate.numProp": "nb propriétés",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Nombre de propriétés par sommet, toujours >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "nb sommets",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Nombre de sommets de propriété",
    "bitbybit.manifold.mesh.evaluate.numTri": "nb triangles",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Obtenir le nombre de triangles sur le maillage",
    "bitbybit.manifold.mesh.evaluate.numRun": "nb passes",
    "numRun": "nb passes",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Nombre d'exécutions de triangles. Chaque exécution de triangle est un ensemble de triangles consécutifs qui proviennent tous de la même instance du même maillage d'entrée.",
    "bitbybit.logic.boolean": "booléen",
    "logic": "logique",
    "bitbybit.logic.boolean_description": "Crée et renvoie une valeur booléenne (transfert pour l'entrée booléenne). Exemple : true → true, false → false",
    "bitbybit.logic.randomBooleans": "booléens aléatoires",
    "randomBooleans": "booléens aléatoires",
    "bitbybit.logic.randomBooleans_description": "Génère une liste booléenne aléatoire où chaque valeur a une chance seuil d'être vraie. Exemple : longueur=5, seuil=0.7 → pourrait produire [true, true, false, true, true]",
    "trueThreshold": "seuil vrai",
    "bitbybit.logic.twoThresholdRandomGradient": "gradient aléatoire deux seuils",
    "twoThresholdRandomGradient": "gradient aléatoire deux seuils",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Convertit des nombres en booléens en utilisant deux seuils avec une randomisation par gradient entre eux. Valeurs inférieures à trueThreshold → toujours true, supérieures à falseThreshold → toujours false. Entre les seuils → gradient de probabilité (plus proche du seuil faux = plus grande chance de faux). Exemple : [0.1, 0.4, 0.6, 0.9] avec seuils [0.3, 0.7] → [true, gradient, gradient, false]",
    "numbers": "nombres",
    "thresholdTotalTrue": "seuil total vrai",
    "thresholdTotalFalse": "seuil total faux",
    "nrLevels": "nb niveaux",
    "bitbybit.logic.thresholdBooleanList": "liste booléenne seuil",
    "thresholdBooleanList": "liste booléenne seuil",
    "bitbybit.logic.thresholdBooleanList_description": "Convertit des nombres en booléens en fonction d'un seuil (inférieur au seuil → true, supérieur → false). Peut être inversé pour retourner la logique. Exemple : [0.3, 0.7, 0.5] avec seuil=0.6 → [true, false, true]",
    "threshold": "seuil",
    "bitbybit.logic.thresholdGapsBooleanList": "liste booléenne seuils écarts",
    "thresholdGapsBooleanList": "liste booléenne seuils écarts",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Convertit des nombres en booléens en utilisant plusieurs seuils de plage (les écarts définissent les plages vraies). Valeurs dans n'importe quelle plage d'écart → true, en dehors de tous les écarts → false. Peut être inversé. Exemple : [0.2, 0.5, 0.8] avec écarts [[0.3, 0.6], [0.7, 0.9]] → [false, true, true]",
    "gapThresholds": "seuils écarts",
    "Base.Vector2[]": "tableau vecteur2 base",
    "bitbybit.logic.not": "non",
    "not": "non",
    "bitbybit.logic.not_description": "Applique l'opérateur NON pour inverser une valeur booléenne. Exemple : true → false, false → true",
    "bitbybit.logic.notList": "liste non",
    "notList": "liste non",
    "bitbybit.logic.notList_description": "Applique l'opérateur NON pour inverser toutes les valeurs booléennes dans une liste. Exemple : [true, false, true] → [false, true, false]",
    "bitbybit.logic.compare": "comparer",
    "compare": "comparer",
    "bitbybit.logic.compare_description": "Compare deux valeurs en utilisant divers opérateurs (==, !=, ===, !==, <, <=, >, >=). Exemple : 5 > 3 → true, 'bonjour' === 'monde' → false",
    "operator": "opérateur",
    "BooleanOperatorsEnum": "énumération opérateurs booléens",
    "bitbybit.logic.valueGate": "porte valeur",
    "valueGate": "porte valeur",
    "bitbybit.logic.valueGate_description": "Passe conditionnellement une valeur si le booléen est vrai, sinon renvoie undefined. Exemple : valeur=42, booléen=true → 42, valeur=42, booléen=false → undefined",
    "bitbybit.logic.firstDefinedValueGate": "porte première valeur définie",
    "firstDefinedValueGate": "porte première valeur définie",
    "bitbybit.logic.firstDefinedValueGate_description": "Renvoie la première valeur définie (non undefined) de deux options (modèle de repli). Exemple : valeur1=42, valeur2=10 → 42, valeur1=undefined, valeur2=10 → 10",
    "value1": "valeur 1",
    "value2": "valeur 2",
    "bitbybit.math.number": "nombre",
    "math": "math",
    "bitbybit.math.number_description": "Crée et renvoie une valeur numérique (transfert pour l'entrée numérique). Exemple : Entrée 42 → 42, Entrée 3.14 → 3.14",
    "bitbybit.math.twoNrOperation": "opération deux nb",
    "twoNrOperation": "opération deux nb",
    "bitbybit.math.twoNrOperation_description": "Effectue des opérations arithmétiques de base sur deux nombres (ajouter, soustraire, multiplier, diviser, puissance, modulo). Exemple : 5 + 3 → 8, 10 % 3 → 1, 2 ^ 3 → 8",
    "operation": "opération",
    "mathTwoNrOperatorEnum": "énumération opérateur math deux nb",
    "bitbybit.math.modulus": "module",
    "modulus": "module",
    "bitbybit.math.modulus_description": "Calcule le reste après la division (opération modulo). Exemple : 10 % 3 → 1, 17 % 5 → 2",
    "bitbybit.math.roundToDecimals": "arrondir à décimales",
    "roundToDecimals": "arrondir à décimales",
    "bitbybit.math.roundToDecimals_description": "Arrondit un nombre aux décimales spécifiées. Exemple : 1.32156 avec 3 décimales renvoie 1.322",
    "decimalPlaces": "décimales",
    "bitbybit.math.oneNrOperation": "opération un nb",
    "oneNrOperation": "opération un nb",
    "bitbybit.math.oneNrOperation_description": "Effectue des opérations mathématiques sur un seul nombre (absolu, nier, racine carrée, fonctions trigonométriques, logarithmes, etc.). Exemple : sqrt(5) → 2.236, abs(-3) → 3, sin(π2) → 1",
    "mathOneNrOperatorEnum": "énumération opérateur math un nb",
    "bitbybit.math.remap": "remapper",
    "remap": "remapper",
    "bitbybit.math.remap_description": "Mappe un nombre d'une plage à une autre proportionnellement. Exemple : 5 de [0,10] à [0,100] → 50, 0.5 de [0,1] à [-10,10] → 0",
    "fromLow": "depuis bas",
    "fromHigh": "depuis haut",
    "toLow": "vers bas",
    "toHigh": "vers haut",
    "bitbybit.math.random": "aléatoire",
    "random": "aléatoire",
    "bitbybit.math.random_description": "Génère un nombre décimal aléatoire entre 0 (inclus) et 1 (exclus). Exemple : Sorties comme 0.342, 0.891, ou toute valeur dans [0, 1)",
    "generate": "générer",
    "bitbybit.math.randomNumber": "nombre aléatoire",
    "randomNumber": "nombre aléatoire",
    "bitbybit.math.randomNumber_description": "Génère un nombre aléatoire dans une plage spécifiée (bas à haut). Exemple : Plage [0, 10] → sorties comme 3.7, 8.2, ou toute valeur entre 0 et 10",
    "low": "bas",
    "high": "haut",
    "bitbybit.math.randomNumbers": "nombres aléatoires",
    "randomNumbers": "nombres aléatoires",
    "bitbybit.math.randomNumbers_description": "Génère plusieurs nombres aléatoires dans une plage spécifiée. Exemple : Plage [0, 10] avec 3 éléments → [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "Renvoie la constante mathématique π (pi) ≈ 3.14159. Exemple : Sorties 3.141592653589793",
    "bitbybit.math.toFixed": "à fixe",
    "toFixed": "à fixe",
    "bitbybit.math.toFixed_description": "Formate un nombre sous forme de chaîne avec un nombre fixe de décimales (affiche toujours les zéros de fin). Exemple : 3.14159 avec 2 décimales → '3.14', 5 avec 3 décimales → '5.000'",
    "bitbybit.math.add": "ajouter",
    "bitbybit.math.add_description": "Ajoute deux nombres ensemble. Exemple : 5 + 3 → 8, -2 + 7 → 5",
    "basics": "bases",
    "bitbybit.math.subtract": "soustraire",
    "bitbybit.math.subtract_description": "Soustrait le deuxième nombre du premier. Exemple : 10 - 3 → 7, 5 - 8 → -3",
    "bitbybit.math.multiply": "multiplier",
    "bitbybit.math.multiply_description": "Multiplie deux nombres ensemble. Exemple : 5 × 3 → 15, -2 × 4 → -8",
    "bitbybit.math.divide": "diviser",
    "divide": "diviser",
    "bitbybit.math.divide_description": "Divise le premier nombre par le second. Exemple : 10 ÷ 2 → 5, 7 ÷ 2 → 3.5",
    "bitbybit.math.power": "puissance",
    "power": "puissance",
    "bitbybit.math.power_description": "Élève le premier nombre à la puissance du second (exponentiation). Exemple : 2³ → 8, 5² → 25, 10⁻¹ → 0.1",
    "bitbybit.math.sqrt": "racine carrée",
    "sqrt": "racine carrée",
    "bitbybit.math.sqrt_description": "Calcule la racine carrée d'un nombre. Exemple : √9 → 3, √2 → 1.414, √16 → 4",
    "bitbybit.math.abs": "valeur absolue",
    "abs": "valeur absolue",
    "bitbybit.math.abs_description": "Renvoie la valeur absolue (supprime le signe négatif, toujours positif ou zéro). Exemple : |-5| → 5, |3| → 3, |0| → 0",
    "bitbybit.math.round": "arrondir",
    "round": "arrondir",
    "bitbybit.math.round_description": "Arrondit un nombre à l'entier le plus proche. Exemple : 3.7 → 4, 2.3 → 2, 5.5 → 6",
    "bitbybit.math.floor": "plancher",
    "floor": "plancher",
    "bitbybit.math.floor_description": "Arrondit un nombre à l'entier le plus proche vers le bas (vers l'infini négatif). Exemple : 3.7 → 3, -2.3 → -3, 5 → 5",
    "bitbybit.math.ceil": "plafond",
    "ceil": "plafond",
    "bitbybit.math.ceil_description": "Arrondit un nombre à l'entier le plus proche vers le haut (vers l'infini positif). Exemple : 3.2 → 4, -2.8 → -2, 5 → 5",
    "bitbybit.math.negate": "opposer",
    "negate": "opposer",
    "bitbybit.math.negate_description": "Nie un nombre (inverse son signe : positif devient négatif, négatif devient positif). Exemple : 5 → -5, -3 → 3, 0 → 0",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "Calcule le logarithme naturel (base e) d'un nombre. Exemple : ln(2.718) → ~1, ln(7.389) → ~2, ln(1) → 0",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "Calcule le logarithme base 10 d'un nombre. Exemple : log₁₀(100) → 2, log₁₀(1000) → 3, log₁₀(10) → 1",
    "bitbybit.math.tenPow": "dix puissance",
    "tenPow": "dix puissance",
    "bitbybit.math.tenPow_description": "Élève 10 à la puissance du nombre d'entrée. Exemple : 10² → 100, 10³ → 1000, 10⁻¹ → 0.1",
    "bitbybit.math.sin": "sin",
    "sin": "sin",
    "bitbybit.math.sin_description": "Calcule le sinus d'un angle en radians. Exemple : sin(0) → 0, sin(π2) → 1, sin(π) → ~0",
    "bitbybit.math.cos": "cos",
    "cos": "cos",
    "bitbybit.math.cos_description": "Calcule le cosinus d'un angle en radians. Exemple : cos(0) → 1, cos(π2) → ~0, cos(π) → -1",
    "bitbybit.math.tan": "tan",
    "tan": "tan",
    "bitbybit.math.tan_description": "Calcule la tangente d'un angle en radians. Exemple : tan(0) → 0, tan(π4) → ~1, tan(π2) → infini",
    "bitbybit.math.asin": "asin",
    "asin": "asin",
    "bitbybit.math.asin_description": "Calcule l'arcsinus (sinus inverse) en radians, renvoie l'angle dont le sinus est l'entrée. Exemple : asin(0) → 0, asin(1) → π2 (~1.57), asin(0.5) → π6 (~0.524)",
    "bitbybit.math.acos": "acos",
    "acos": "acos",
    "bitbybit.math.acos_description": "Calcule l'arccosinus (cosinus inverse) en radians, renvoie l'angle dont le cosinus est l'entrée. Exemple : acos(1) → 0, acos(0) → π2 (~1.57), acos(-1) → π (~3.14)",
    "bitbybit.math.atan": "atan",
    "atan": "atan",
    "bitbybit.math.atan_description": "Calcule l'arctangente (tangente inverse) en radians, renvoie l'angle dont la tangente est l'entrée. Exemple : atan(0) → 0, atan(1) → π4 (~0.785), atan(-1) → -π4",
    "bitbybit.math.exp": "exp",
    "exp": "exp",
    "bitbybit.math.exp_description": "Calcule e élevé à la puissance de l'entrée (fonction exponentielle). Exemple : e⁰ → 1, e¹ → ~2.718, e² → ~7.389",
    "bitbybit.math.degToRad": "deg vers rad",
    "degToRad": "deg vers rad",
    "bitbybit.math.degToRad_description": "Convertit un angle de degrés en radians. Exemple : 180° → π (~3.14159), 90° → π2 (~1.5708), 360° → 2π",
    "bitbybit.math.radToDeg": "rad vers deg",
    "radToDeg": "rad vers deg",
    "bitbybit.math.radToDeg_description": "Convertit un angle de radians en degrés. Exemple : π → 180°, π2 → 90°, 2π → 360°",
    "bitbybit.math.ease": "lisser",
    "bitbybit.math.ease_description": "Applique une fonction d'assouplissement pour interpoler en douceur entre les valeurs min et max. Exemple : x=0.5 de [0,100] avec easeInQuad → applique une courbe d'accélération quadratique. Utile pour les animations fluides avec diverses courbes d'accélération/décélération.",
    "easeEnum": "énumération lissage",
    "bitbybit.lists.getItem": "obtenir élément",
    "lists": "listes",
    "getItem": "obtenir élément",
    "bitbybit.lists.getItem_description": "Obtient un élément de la liste à une position spécifique en utilisant une indexation basée sur zéro. Exemple : De [10, 20, 30, 40], obtenir l'index 2 renvoie 30",
    "list": "liste",
    "bitbybit.lists.randomGetThreshold": "seuil obtention aléatoire",
    "randomGetThreshold": "seuil obtention aléatoire",
    "bitbybit.lists.randomGetThreshold_description": "Conserve aléatoirement des éléments de la liste en fonction d'un seuil de probabilité (0 à 1). Exemple : De [1, 2, 3, 4, 5] avec un seuil de 0.5, pourrait renvoyer [1, 3, 5] (50 % de chance pour chaque élément)",
    "bitbybit.lists.getSubList": "obtenir sous-liste",
    "getSubList": "obtenir sous-liste",
    "bitbybit.lists.getSubList_description": "Extrait une partie de la liste entre les positions de début et de fin (la fin est exclusive). Exemple : De [10, 20, 30, 40, 50] avec début=1 et fin=4, renvoie [20, 30, 40]",
    "indexStart": "index début",
    "indexEnd": "index fin",
    "bitbybit.lists.getNthItem": "obtenir nième élément",
    "getNthItem": "obtenir nième élément",
    "bitbybit.lists.getNthItem_description": "Obtient chaque énième élément de la liste, en commençant par une position de décalage optionnelle. Exemple : De [0, 1, 2, 3, 4, 5, 6, 7, 8] avec nth=3 et décalage=0, renvoie [0, 3, 6] Exemple : De [0, 1, 2, 3, 4, 5, 6, 7, 8] avec nth=2 et décalage=1, renvoie [1, 3, 5, 7]",
    "nth": "nième",
    "bitbybit.lists.getByPattern": "obtenir par motif",
    "getByPattern": "obtenir par motif",
    "bitbybit.lists.getByPattern_description": "Filtre les éléments de la liste en utilisant un motif vrai/faux répétitif. Exemple : De [0, 1, 2, 3, 4, 5] avec motif [true, true, false], renvoie [0, 1, 3, 4] (garde les éléments où le motif est vrai)",
    "pattern": "motif",
    "bitbybit.lists.mergeElementsOfLists": "fusionner éléments listes",
    "mergeElementsOfLists": "fusionner éléments listes",
    "bitbybit.lists.mergeElementsOfLists_description": "Fusionne les éléments de plusieurs listes à un niveau d'imbrication spécifique, regroupant les éléments par position. Exemple : De [[0, 1, 2], [3, 4, 5]] au niveau 0, renvoie [[0, 3], [1, 4], [2, 5]]",
    "level": "niveau",
    "bitbybit.lists.getLongestListLength": "obtenir longueur liste la plus longue",
    "getLongestListLength": "obtenir longueur liste la plus longue",
    "bitbybit.lists.getLongestListLength_description": "Trouve la longueur de la liste la plus longue parmi plusieurs listes. Exemple : De [[1, 2], [3, 4, 5, 6], [7]], renvoie 4 (longueur de [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "inverser",
    "bitbybit.lists.reverse_description": "Inverse l'ordre des éléments dans la liste. Exemple : De [1, 2, 3, 4, 5], renvoie [5, 4, 3, 2, 1]",
    "bitbybit.lists.flipLists": "retourner listes",
    "flipLists": "retourner listes",
    "bitbybit.lists.flipLists_description": "Transpose une liste 2D en échangeant les lignes et les colonnes (toutes les sous-listes doivent avoir la même longueur). Exemple : De [[0, 1, 2], [3, 4, 5]], renvoie [[0, 3], [1, 4], [2, 5]]",
    "bitbybit.lists.groupNth": "grouper nième",
    "groupNth": "grouper nième",
    "bitbybit.lists.groupNth_description": "Divise la liste en listes plus petites de n éléments chacune. Exemple : De [0, 1, 2, 3, 4, 5, 6, 7, 8] avec n=3, renvoie [[0, 1, 2], [3, 4, 5], [6, 7, 8]] Exemple : De [0, 1, 2, 3, 4] avec n=2 et keepRemainder=true, renvoie [[0, 1], [2, 3], [4]]",
    "nrElements": "nb éléments",
    "keepRemainder": "garder reste",
    "bitbybit.lists.getListDepth": "obtenir profondeur liste",
    "getListDepth": "obtenir profondeur liste",
    "bitbybit.lists.getListDepth_description": "Détermine le niveau d'imbrication maximum (profondeur) d'une structure de liste. Exemple : [1, 2, 3] a une profondeur de 1, [[1, 2], [3, 4]] a une profondeur de 2, [[[1]]] a une profondeur de 3",
    "bitbybit.lists.listLength": "longueur liste",
    "listLength": "longueur liste",
    "bitbybit.lists.listLength_description": "Renvoie le nombre d'éléments dans la liste. Exemple : [10, 20, 30, 40, 50] renvoie 5, [] renvoie 0",
    "bitbybit.lists.addItemAtIndex": "ajouter élément à index",
    "addItemAtIndex": "ajouter élément à index",
    "bitbybit.lists.addItemAtIndex_description": "Insère un élément à une position spécifique dans la liste. Exemple : Dans [10, 20, 30, 40], ajouter 99 à l'index 2 donne [10, 20, 99, 30, 40]",
    "item": "élément",
    "bitbybit.lists.addItemAtIndexes": "ajouter élément aux index",
    "addItemAtIndexes": "ajouter élément aux index",
    "bitbybit.lists.addItemAtIndexes_description": "Insère le même élément à plusieurs positions spécifiées dans la liste. Exemple : Dans [10, 20, 30], ajouter 99 aux index [0, 2] donne [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "ajouter éléments aux index",
    "addItemsAtIndexes": "ajouter éléments aux index",
    "bitbybit.lists.addItemsAtIndexes_description": "Insère plusieurs éléments aux positions correspondantes (premier élément au premier index, deuxième élément au deuxième index, etc.). Exemple : Dans [10, 20, 30], ajouter les éléments [88, 99] aux index [1, 2] donne [10, 88, 20, 99, 30]",
    "items": "éléments",
    "bitbybit.lists.removeItemAtIndex": "supprimer élément à index",
    "removeItemAtIndex": "supprimer élément à index",
    "bitbybit.lists.removeItemAtIndex_description": "Supprime l'élément à une position spécifique dans la liste. Exemple : De [10, 20, 30, 40, 50], supprimer l'index 2 donne [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "supprimer éléments aux index",
    "removeItemsAtIndexes": "supprimer éléments aux index",
    "bitbybit.lists.removeItemsAtIndexes_description": "Supprime les éléments à plusieurs positions spécifiées de la liste. Exemple : De [10, 20, 30, 40, 50], supprimer les index [1, 3] donne [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "supprimer tous éléments",
    "removeAllItems": "supprimer tous éléments",
    "bitbybit.lists.removeAllItems_description": "Efface tous les éléments de la liste, résultant en une liste vide. Exemple : De [10, 20, 30, 40], renvoie []",
    "bitbybit.lists.removeNthItem": "supprimer nième élément",
    "removeNthItem": "supprimer nième élément",
    "bitbybit.lists.removeNthItem_description": "Supprime chaque énième élément de la liste, en commençant par une position de décalage optionnelle. Exemple : De [0, 1, 2, 3, 4, 5, 6, 7, 8] avec nth=3 et décalage=0, renvoie [1, 2, 4, 5, 7, 8] (supprime 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "seuil suppression aléatoire",
    "randomRemoveThreshold": "seuil suppression aléatoire",
    "bitbybit.lists.randomRemoveThreshold_description": "Supprime aléatoirement des éléments de la liste en fonction d'un seuil de probabilité (0 à 1). Exemple : De [1, 2, 3, 4, 5] avec un seuil de 0.5, pourrait renvoyer [2, 4] (50 % de chance de supprimer chaque élément)",
    "bitbybit.lists.removeDuplicateNumbers": "supprimer nombres dupliqués",
    "removeDuplicateNumbers": "supprimer nombres dupliqués",
    "bitbybit.lists.removeDuplicateNumbers_description": "Supprime les nombres en double de la liste, ne conservant que la première occurrence de chaque valeur. Exemple : De [1, 2, 3, 2, 4, 3, 5], renvoie [1, 2, 3, 4, 5]",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "tolérance suppression nombres dupliqués",
    "removeDuplicateNumbersTolerance": "tolérance suppression nombres dupliqués",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Supprime les nombres en double qui se trouvent dans une plage de tolérance spécifiée les uns des autres. Exemple : De [1.0, 1.001, 2.0, 2.002, 3.0] avec une tolérance de 0.01, renvoie [1.0, 2.0, 3.0]",
    "bitbybit.lists.addItem": "ajouter élément",
    "addItem": "ajouter élément",
    "bitbybit.lists.addItem_description": "Ajoute un élément à la fin de la liste. Exemple : À [10, 20, 30], ajouter 40 donne [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "ajouter élément début",
    "prependItem": "ajouter élément début",
    "bitbybit.lists.prependItem_description": "Ajoute un élément au début de la liste. Exemple : À [10, 20, 30], préfixer 5 donne [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "ajouter élément début fin",
    "addItemFirstLast": "ajouter élément début fin",
    "bitbybit.lists.addItemFirstLast_description": "Ajoute un élément soit au début soit à la fin de la liste en fonction du paramètre de position. Exemple : À [10, 20, 30], ajouter 5 à 'first' donne [5, 10, 20, 30], à 'last' donne [10, 20, 30, 5]",
    "firstLastEnum": "énumération début fin",
    "bitbybit.lists.createEmptyList": "liste vide",
    "createEmptyList": "liste vide",
    "bitbybit.lists.createEmptyList_description": "Crée une nouvelle liste vide sans éléments. Exemple : Renvoie []",
    "bitbybit.lists.repeat": "répéter",
    "repeat": "répéter",
    "bitbybit.lists.repeat_description": "Crée une nouvelle liste en répétant un élément un nombre spécifié de fois. Exemple : Répéter 5 trois fois renvoie [5, 5, 5]",
    "times": "fois",
    "bitbybit.lists.repeatInPattern": "répéter en motif",
    "repeatInPattern": "répéter en motif",
    "bitbybit.lists.repeatInPattern_description": "Répète un motif d'éléments de manière cyclique jusqu'à atteindre une longueur de liste cible. Exemple : Motif [1, 2, 3] avec longueur 7 renvoie [1, 2, 3, 1, 2, 3, 1]",
    "lengthLimit": "limite longueur",
    "bitbybit.lists.sortNumber": "trier nombre",
    "sortNumber": "trier nombre",
    "bitbybit.lists.sortNumber_description": "Trie les nombres dans l'ordre croissant (du plus bas au plus haut) ou décroissant (du plus haut au plus bas). Exemple : [5, 2, 8, 1, 9] croissant renvoie [1, 2, 5, 8, 9], décroissant renvoie [9, 8, 5, 2, 1]",
    "sorting": "tri",
    "orderAsc": "ordre asc",
    "bitbybit.lists.sortTexts": "trier textes",
    "sortTexts": "trier textes",
    "bitbybit.lists.sortTexts_description": "Trie les chaînes de texte par ordre alphabétique croissant (A à Z) ou décroissant (Z à A). Exemple : ['chien', 'pomme', 'chat', 'banane'] croissant renvoie ['pomme', 'banane', 'chat', 'chien']",
    "bitbybit.lists.sortByPropValue": "trier par valeur prop",
    "sortByPropValue": "trier par valeur prop",
    "bitbybit.lists.sortByPropValue_description": "Trie les objets en comparant les valeurs numériques d'une propriété spécifiée. Exemple : [{age: 30}, {age: 20}, {age: 25}] trié par 'age' croissant renvoie [{age: 20}, {age: 25}, {age: 30}]",
    "property": "propriété",
    "bitbybit.color.hexColor": "couleur hex",
    "hexColor": "couleur hex",
    "bitbybit.color.hexColor_description": "Crée et renvoie une chaîne de couleur hexadécimale (transfert pour l'entrée de couleur). Exemple : '#FF5733' → '#FF5733'",
    "bitbybit.color.hexToRgb": "hex vers rgb",
    "hexToRgb": "hex vers rgb",
    "bitbybit.color.hexToRgb_description": "Convertit la couleur hexadécimale en objet RVB avec des valeurs r, g, b (plage 0-255). Exemple : '#FF5733' → {r: 255, g: 87, b: 51}",
    "convert": "convertir",
    "bitbybit.color.rgbToHex": "rgb vers hex",
    "rgbToHex": "rgb vers hex",
    "bitbybit.color.rgbToHex_description": "Convertit les valeurs RVB en chaîne de couleur hexadécimale (prend en charge les plages min/max personnalisées, remappe automatiquement à 0-255). Exemple : r=255, g=87, b=51 avec plage [0,255] → '#ff5733' Exemple : r=1, g=0.5, b=0.2 avec plage [0,1] → '#ff7f33'",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "objet rgb vers hex",
    "rgbObjToHex": "objet rgb vers hex",
    "bitbybit.color.rgbObjToHex_description": "Convertit l'objet RVB en chaîne de couleur hexadécimale (prend en charge les plages min/max personnalisées). Exemple : {r: 1, g: 0.5, b: 0.2} avec plage [0,1] → '#ff7f33'",
    "rgb": "rgb",
    "Base.ColorRGB": "couleur rgb base",
    "bitbybit.color.hexToRgbMapped": "hex vers rgb mappé",
    "hexToRgbMapped": "hex vers rgb mappé",
    "bitbybit.color.hexToRgbMapped_description": "Convertit la couleur hexadécimale en RVB et remappe les valeurs à une plage personnalisée. Exemple : '#FF5733' mappé à [0,1] → {r: 1, g: 0.341, b: 0.2} Exemple : '#FF5733' mappé à [0,100] → {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "obtenir param rouge",
    "getRedParam": "obtenir param rouge",
    "bitbybit.color.getRedParam_description": "Extrait la valeur du canal rouge de la couleur hexadécimale (peut être mappée à une plage personnalisée). Exemple : '#FF5733' avec plage [0,1] → 1",
    "hex to": "hex vers",
    "bitbybit.color.getGreenParam": "obtenir param vert",
    "getGreenParam": "obtenir param vert",
    "bitbybit.color.getGreenParam_description": "Extrait la valeur du canal vert de la couleur hexadécimale (peut être mappée à une plage personnalisée). Exemple : '#FF5733' avec plage [0,1] → 0.341",
    "bitbybit.color.getBlueParam": "obtenir param bleu",
    "getBlueParam": "obtenir param bleu",
    "bitbybit.color.getBlueParam_description": "Extrait la valeur du canal bleu de la couleur hexadécimale (peut être mappée à une plage personnalisée). Exemple : '#FF5733' avec plage [0,1] → 0.2",
    "bitbybit.color.rgbToRed": "rgb vers rouge",
    "rgbToRed": "rgb vers rouge",
    "bitbybit.color.rgbToRed_description": "Extrait la valeur du canal rouge de l'objet RVB. Exemple : {r: 255, g: 87, b: 51} → 255",
    "rgb to": "rgb vers",
    "bitbybit.color.rgbToGreen": "rgb vers vert",
    "rgbToGreen": "rgb vers vert",
    "bitbybit.color.rgbToGreen_description": "Extrait la valeur du canal vert de l'objet RVB. Exemple : {r: 255, g: 87, b: 51} → 87",
    "bitbybit.color.rgbToBlue": "rgb vers bleu",
    "rgbToBlue": "rgb vers bleu",
    "bitbybit.color.rgbToBlue_description": "Extrait la valeur du canal bleu de l'objet RVB. Exemple : {r: 255, g: 87, b: 51} → 51",
    "bitbybit.color.invert": "inverser",
    "invert": "inverser",
    "bitbybit.color.invert_description": "Inverse une couleur hexadécimale (inverse les canaux RVB : 255-r, 255-g, 255-b). Avec blackAndWhite=true → renvoie '#000000' ou '#ffffff' selon la luminosité. Exemple : '#FF5733' → '#00a8cc', '#FF5733' avec blackAndWhite=true → '#ffffff'",
    "blackAndWhite": "noir et blanc",
    "bitbybit.text.create": "créer",
    "bitbybit.text.create_description": "Crée et renvoie une chaîne de texte (transfert pour l'entrée de texte). Exemple : texte='Bonjour Monde' → 'Bonjour Monde'",
    "bitbybit.text.split": "diviser",
    "bitbybit.text.split_description": "Divise le texte en plusieurs morceaux en utilisant une chaîne de séparation. Exemple : texte='pomme,banane,cerise', séparateur=',' → ['pomme', 'banane', 'cerise']",
    "separator": "séparateur",
    "bitbybit.text.replaceAll": "remplacer tout",
    "replaceAll": "remplacer tout",
    "bitbybit.text.replaceAll_description": "Remplace toutes les occurrences d'une chaîne de recherche par une chaîne de remplacement. Exemple : texte='bonjour bonjour', recherche='bonjour', remplacerPar='salut' → 'salut salut'",
    "search": "rechercher",
    "replaceWith": "remplacer par",
    "bitbybit.text.join": "joindre",
    "join": "joindre",
    "bitbybit.text.join_description": "Joint plusieurs éléments en une seule chaîne de texte en utilisant un séparateur. Exemple : liste=['pomme', 'banane', 'cerise'], séparateur=', ' → 'pomme, banane, cerise'",
    "string[]": "tableau chaîne",
    "bitbybit.text.toString": "vers chaîne",
    "toString": "vers chaîne",
    "bitbybit.text.toString_description": "Transformer n'importe quel élément en texte",
    "bitbybit.text.toStringEach": "vers chaîne chacun",
    "toStringEach": "vers chaîne chacun",
    "bitbybit.text.toStringEach_description": "Transformer chaque élément de la liste en texte",
    "bitbybit.text.format": "formater",
    "format": "formater",
    "bitbybit.text.format_description": "Formate le texte avec des valeurs de substitution en utilisant la syntaxe {0}, {1}, etc. Exemple : texte='Point : ({0}, {1})', valeurs=[10, 5] → 'Point : (10, 5)'",
    "values": "valeurs",
    "bitbybit.text.vectorChar": "caractère vectoriel",
    "vectorChar": "caractère vectoriel",
    "bitbybit.text.vectorChar_description": "Convertit un caractère en chemins vectoriels (polylignes) avec des données de largeur et de hauteur pour le rendu. Utilise une police à traits simplex pour générer des segments de ligne 2D représentant la forme du caractère. Exemple : char='A', hauteur=10 → {width:8, height:10, paths:[[points formant la forme A]]}",
    "char": "caractère",
    "bitbybit.text.vectorText": "texte vectoriel",
    "vectorText": "texte vectoriel",
    "bitbybit.text.vectorText_description": "Convertit un texte multiligne en chemins vectoriels (polylignes) avec des contrôles d'alignement et d'espacement. Prend en charge les sauts de ligne, l'espacement des lettres, l'espacement des lignes, l'alignement horizontal et le centrage de l'origine. Exemple : texte='Bonjour Monde', hauteur=10, align=center → [{caractères ligne1}, {caractères ligne2}]",
    "bitbybit.dates.toDateString": "vers chaîne date",
    "dates": "dates",
    "toDateString": "vers chaîne date",
    "bitbybit.dates.toDateString_description": "Convertit la date en chaîne de date lisible par l'homme (exclut l'heure). Exemple : Date(2024,0,15,14,30) → 'Lun 15 Jan 2024'",
    "date": "date",
    "Date": "date",
    "bitbybit.dates.toISOString": "vers chaîne iso",
    "toISOString": "vers chaîne iso",
    "bitbybit.dates.toISOString_description": "Convertit la date en chaîne au format ISO 8601 (format standard pour les API et l'échange de données). Exemple : Date(2024,0,15,14,30,45) → '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "vers json",
    "toJSON": "vers json",
    "bitbybit.dates.toJSON_description": "Convertit la date en chaîne compatible JSON (identique au format ISO, utilisé dans JSON.stringify). Exemple : Date(2024,0,15,14,30) → '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "vers chaîne",
    "bitbybit.dates.toString_description": "Convertit la date en chaîne complète spécifique aux paramètres régionaux (inclut la date, l'heure et le fuseau horaire). Exemple : Date(2024,0,15,14,30) → 'Lun 15 Jan 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "vers chaîne heure",
    "toTimeString": "vers chaîne heure",
    "bitbybit.dates.toTimeString_description": "Convertit la date en chaîne d'heure (exclut la date, inclut le fuseau horaire). Exemple : Date(2024,0,15,14,30,45) → '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "vers chaîne utc",
    "toUTCString": "vers chaîne utc",
    "bitbybit.dates.toUTCString_description": "Convertit la date au format de chaîne UTC (Temps Universel Coordonné, pas de décalage de fuseau horaire). Exemple : Date(2024,0,15,14,30) → 'Lun, 15 Jan 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "maintenant",
    "now": "maintenant",
    "bitbybit.dates.now_description": "Renvoie la date et l'heure actuelles au moment de l'exécution. Exemple : appel de now() → Objet Date représentant le moment présent (par ex., '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "créer date",
    "createDate": "créer date",
    "bitbybit.dates.createDate_description": "Crée une nouvelle date à partir de composants individuels en utilisant l'heure locale. Le mois est indexé à 0 : 0=Janvier, 11=Décembre. Exemple : année=2024, mois=0, jour=15, heures=14, minutes=30 → Date(15 Jan 2024 14:30)",
    "year": "année",
    "month": "mois",
    "day": "jour",
    "hours": "heures",
    "minutes": "minutes",
    "seconds": "secondes",
    "milliseconds": "millisecondes",
    "bitbybit.dates.createDateUTC": "créer date utc",
    "createDateUTC": "créer date utc",
    "bitbybit.dates.createDateUTC_description": "Crée une nouvelle date à partir de composants individuels en utilisant UTC (ignore le fuseau horaire). Renvoie les millisecondes depuis l'époque Unix (1er Jan 1970 00:00:00 UTC). Exemple : année=2024, mois=0, jour=15 → Date représentant le 15 Jan 2024 00:00 UTC",
    "bitbybit.dates.createFromUnixTimeStamp": "créer depuis timestamp unix",
    "createFromUnixTimeStamp": "créer depuis timestamp unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Crée une date à partir de l'horodatage Unix (millisecondes depuis le 1er Jan 1970 UTC). Exemple : unixTimeStamp=1705329000000 → Date(15 Jan 2024 14:30:00)",
    "unixTimeStamp": "timestamp unix",
    "bitbybit.dates.parseDate": "analyser date",
    "parseDate": "analyser date",
    "bitbybit.dates.parseDate_description": "Analyse une chaîne de date et renvoie l'horodatage Unix (millisecondes depuis le 1er Jan 1970 UTC). Exemple : dateString='2024-01-15' → 1705276800000",
    "parse": "analyser",
    "dateString": "chaîne date",
    "bitbybit.dates.getDayOfMonth": "obtenir jour du mois",
    "getDayOfMonth": "obtenir jour du mois",
    "bitbybit.dates.getDayOfMonth_description": "Extrait le jour du mois de la date (1-31) en utilisant l'heure locale. Exemple : Date(2024,0,15) → 15",
    "bitbybit.dates.getWeekday": "obtenir jour semaine",
    "getWeekday": "obtenir jour semaine",
    "bitbybit.dates.getWeekday_description": "Extrait le jour de la semaine de la date (0=Dimanche, 6=Samedi) en utilisant l'heure locale. Exemple : Date(2024,0,15) → 1 (Lundi)",
    "bitbybit.dates.getYear": "obtenir année",
    "getYear": "obtenir année",
    "bitbybit.dates.getYear_description": "Extrait l'année complète de la date en utilisant l'heure locale. Exemple : Date(2024,0,15) → 2024",
    "bitbybit.dates.getMonth": "obtenir mois",
    "getMonth": "obtenir mois",
    "bitbybit.dates.getMonth_description": "Extrait le mois de la date (0=Janvier, 11=Décembre) en utilisant l'heure locale. Exemple : Date(2024,0,15) → 0 (Janvier)",
    "bitbybit.dates.getHours": "obtenir heures",
    "getHours": "obtenir heures",
    "bitbybit.dates.getHours_description": "Extrait les heures de la date (0-23) en utilisant l'heure locale. Exemple : Date(2024,0,15,14,30) → 14",
    "bitbybit.dates.getMinutes": "obtenir minutes",
    "getMinutes": "obtenir minutes",
    "bitbybit.dates.getMinutes_description": "Extrait les minutes de la date (0-59) en utilisant l'heure locale. Exemple : Date(2024,0,15,14,30) → 30",
    "bitbybit.dates.getSeconds": "obtenir secondes",
    "getSeconds": "obtenir secondes",
    "bitbybit.dates.getSeconds_description": "Extrait les secondes de la date (0-59) en utilisant l'heure locale. Exemple : Date(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getMilliseconds": "obtenir millisecondes",
    "getMilliseconds": "obtenir millisecondes",
    "bitbybit.dates.getMilliseconds_description": "Extrait les millisecondes de la date (0-999) en utilisant l'heure locale. Exemple : Date(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.getTime": "obtenir heure",
    "getTime": "obtenir heure",
    "bitbybit.dates.getTime_description": "Convertit la date en horodatage Unix (millisecondes depuis le 1er Jan 1970 UTC). Exemple : Date(2024,0,15,14,30) → 1705329000000",
    "bitbybit.dates.getUTCYear": "obtenir année utc",
    "getUTCYear": "obtenir année utc",
    "bitbybit.dates.getUTCYear_description": "Extrait l'année complète de la date en utilisant UTC (ignore le fuseau horaire). Exemple : Date(2024,0,15) → 2024",
    "bitbybit.dates.getUTCMonth": "obtenir mois utc",
    "getUTCMonth": "obtenir mois utc",
    "bitbybit.dates.getUTCMonth_description": "Extrait le mois de la date (0=Janvier, 11=Décembre) en utilisant UTC. Exemple : Date.UTC(2024,0,15) → 0 (Janvier)",
    "bitbybit.dates.getUTCDay": "obtenir jour utc",
    "getUTCDay": "obtenir jour utc",
    "bitbybit.dates.getUTCDay_description": "Extrait le jour du mois de la date (1-31) en utilisant UTC. Exemple : Date.UTC(2024,0,15) → 15",
    "bitbybit.dates.getUTCHours": "obtenir heures utc",
    "getUTCHours": "obtenir heures utc",
    "bitbybit.dates.getUTCHours_description": "Extrait les heures de la date (0-23) en utilisant UTC. Exemple : Date.UTC(2024,0,15,14) → 14",
    "bitbybit.dates.getUTCMinutes": "obtenir minutes utc",
    "getUTCMinutes": "obtenir minutes utc",
    "bitbybit.dates.getUTCMinutes_description": "Extrait les minutes de la date (0-59) en utilisant UTC. Exemple : Date.UTC(2024,0,15,14,30) → 30",
    "bitbybit.dates.getUTCSeconds": "obtenir secondes utc",
    "getUTCSeconds": "obtenir secondes utc",
    "bitbybit.dates.getUTCSeconds_description": "Extrait les secondes de la date (0-59) en utilisant UTC. Exemple : Date.UTC(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getUTCMilliseconds": "obtenir millisecondes utc",
    "getUTCMilliseconds": "obtenir millisecondes utc",
    "bitbybit.dates.getUTCMilliseconds_description": "Extrait les millisecondes de la date (0-999) en utilisant UTC. Exemple : Date.UTC(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.setYear": "définir année",
    "setYear": "définir année",
    "bitbybit.dates.setYear_description": "Crée une nouvelle date avec l'année modifiée (renvoie une nouvelle date, l'original reste inchangé). Exemple : Date(2024,0,15) avec année=2025 → Date(2025,0,15)",
    "bitbybit.dates.setMonth": "définir mois",
    "setMonth": "définir mois",
    "bitbybit.dates.setMonth_description": "Crée une nouvelle date avec le mois modifié (0=Janvier, 11=Décembre, renvoie une nouvelle date). Exemple : Date(2024,0,15) avec mois=5 → Date(2024,5,15) (15 Juin)",
    "bitbybit.dates.setDayOfMonth": "définir jour du mois",
    "setDayOfMonth": "définir jour du mois",
    "bitbybit.dates.setDayOfMonth_description": "Crée une nouvelle date avec le jour du mois modifié (1-31, renvoie une nouvelle date). Exemple : Date(2024,0,15) avec jour=20 → Date(2024,0,20)",
    "bitbybit.dates.setHours": "définir heures",
    "setHours": "définir heures",
    "bitbybit.dates.setHours_description": "Définit la valeur de l'heure dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setMinutes": "définir minutes",
    "setMinutes": "définir minutes",
    "bitbybit.dates.setMinutes_description": "Définit la valeur des minutes dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setSeconds": "définir secondes",
    "setSeconds": "définir secondes",
    "bitbybit.dates.setSeconds_description": "Définit la valeur des secondes dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setMilliseconds": "définir millisecondes",
    "setMilliseconds": "définir millisecondes",
    "bitbybit.dates.setMilliseconds_description": "Définit la valeur des millisecondes dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setTime": "définir heure",
    "setTime": "définir heure",
    "bitbybit.dates.setTime_description": "Définit la valeur de la date et de l'heure dans l'objet Date.",
    "time": "heure",
    "bitbybit.dates.setUTCYear": "définir année utc",
    "setUTCYear": "définir année utc",
    "bitbybit.dates.setUTCYear_description": "Définit la valeur de l'année dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCMonth": "définir mois utc",
    "setUTCMonth": "définir mois utc",
    "bitbybit.dates.setUTCMonth_description": "Définit la valeur du mois dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCDay": "définir jour utc",
    "setUTCDay": "définir jour utc",
    "bitbybit.dates.setUTCDay_description": "Définit le jour numérique du mois dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCHours": "définir heures utc",
    "setUTCHours": "définir heures utc",
    "bitbybit.dates.setUTCHours_description": "Définit la valeur des heures dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCMinutes": "définir minutes utc",
    "setUTCMinutes": "définir minutes utc",
    "bitbybit.dates.setUTCMinutes_description": "Définit la valeur des minutes dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCSeconds": "définir secondes utc",
    "setUTCSeconds": "définir secondes utc",
    "bitbybit.dates.setUTCSeconds_description": "Définit la valeur des secondes dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "définir millisecondes utc",
    "setUTCMilliseconds": "définir millisecondes utc",
    "bitbybit.dates.setUTCMilliseconds_description": "Définit la valeur des millisecondes dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.json.stringify": "transformer en chaîne",
    "json": "json",
    "stringify": "transformer en chaîne",
    "bitbybit.json.stringify_description": "Stringifie la valeur d'entrée",
    "bitbybit.json.parse": "analyser",
    "bitbybit.json.parse_description": "Analyse la valeur d'entrée",
    "bitbybit.json.query": "requête",
    "query": "requête",
    "bitbybit.json.query_description": "Interroge la valeur d'entrée",
    "jsonpath": "chemin json",
    "bitbybit.json.setValueOnProp": "définir valeur sur prop",
    "setValueOnProp": "définir valeur sur prop",
    "bitbybit.json.setValueOnProp_description": "Définit la valeur sur la propriété donnée du json donné",
    "props": "props",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "obtenir json tableau par première correspondance prop",
    "getJsonFromArrayByFirstPropMatch": "obtenir json tableau par première correspondance prop",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Obtient le json du tableau par la première correspondance de propriété. C'est une recherche très simpliste et renvoie uniquement la première correspondance. Si vous avez besoin d'une recherche plus complexe, vous pouvez utiliser la requête jsonpath avec des filtres.",
    "jsonArray": "tableau json",
    "any[]": "tableau tout",
    "match": "correspondance",
    "bitbybit.json.getValueOnProp": "obtenir valeur sur prop",
    "getValueOnProp": "obtenir valeur sur prop",
    "bitbybit.json.getValueOnProp_description": "Obtient la valeur de la propriété dans le json donné",
    "bitbybit.json.setValue": "définir valeur",
    "bitbybit.json.setValue_description": "Définit la valeur au json en fournissant un chemin",
    "prop": "prop",
    "bitbybit.json.setValuesOnPaths": "définir valeurs sur chemins",
    "setValuesOnPaths": "définir valeurs sur chemins",
    "bitbybit.json.setValuesOnPaths_description": "Définit plusieurs valeurs au json en fournissant des chemins",
    "paths": "chemins",
    "bitbybit.json.paths": "chemins",
    "bitbybit.json.paths_description": "Trouve les chemins vers les éléments dans l'objet correspondant à l'expression de chemin",
    "bitbybit.json.createEmpty": "vide",
    "bitbybit.json.createEmpty_description": "Crée un objet JavaScript vide",
    "bitbybit.json.previewAndSaveJson": "prévisualiser et sauvegarder json",
    "previewAndSaveJson": "prévisualiser et sauvegarder json",
    "bitbybit.json.previewAndSaveJson_description": "Prévisualise le json et donne l'option de l'enregistrer",
    "preview": "prévisualiser",
    "bitbybit.json.previewJson": "prévisualiser json",
    "previewJson": "prévisualiser json",
    "bitbybit.json.previewJson_description": "prévisualise le json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "courbe par nœuds points contrôle poids",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "courbe par nœuds points contrôle poids",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Crée une courbe Nurbs en fournissant des nœuds, des points de contrôle et des poids",
    "degree": "degré",
    "knots": "nœuds",
    "bitbybit.verb.curve.createCurveByPoints": "courbe par points",
    "createCurveByPoints": "courbe par points",
    "bitbybit.verb.curve.createCurveByPoints_description": "Crée une courbe Nurbs en fournissant des points de contrôle",
    "bitbybit.verb.curve.createBezierCurve": "courbe bezier",
    "createBezierCurve": "courbe bezier",
    "bitbybit.verb.curve.createBezierCurve_description": "Crée une courbe Bezier Nurbs en fournissant des points de contrôle et des poids",
    "bitbybit.verb.curve.clone": "cloner",
    "bitbybit.verb.curve.clone_description": "Clone la courbe Nurbs",
    "bitbybit.verb.curve.closestParam": "param plus proche",
    "closestParam": "param plus proche",
    "bitbybit.verb.curve.closestParam_description": "Trouve le paramètre le plus proche sur la courbe Nurbs à partir du point",
    "bitbybit.verb.curve.closestParams": "params plus proches",
    "closestParams": "params plus proches",
    "bitbybit.verb.curve.closestParams_description": "Trouve les paramètres les plus proches sur la courbe Nurbs à partir des points",
    "bitbybit.verb.curve.closestPoint": "point plus proche",
    "closestPoint": "point plus proche",
    "bitbybit.verb.curve.closestPoint_description": "Trouve le point le plus proche sur la courbe Nurbs à partir du point",
    "bitbybit.verb.curve.closestPoints": "points plus proches",
    "closestPoints": "points plus proches",
    "bitbybit.verb.curve.closestPoints_description": "Trouve les points les plus proches sur la courbe Nurbs à partir de la liste de points",
    "bitbybit.verb.curve.controlPoints": "points contrôle",
    "controlPoints": "points contrôle",
    "bitbybit.verb.curve.controlPoints_description": "Trouve les points de contrôle de la courbe Nurbs",
    "bitbybit.verb.curve.degree": "degré",
    "bitbybit.verb.curve.degree_description": "Trouve le degré de la courbe Nurbs",
    "bitbybit.verb.curve.derivatives": "dérivées",
    "derivatives": "dérivées",
    "bitbybit.verb.curve.derivatives_description": "Trouve les dérivées de la courbe Nurbs au paramètre",
    "numDerivatives": "nb dérivées",
    "parameter": "paramètre",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "diviser par longueur arc égale en params",
    "divideByEqualArcLengthToParams": "diviser par longueur arc égale en params",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Divise la courbe par longueur d'arc égale en paramètres",
    "subdivision": "subdivision",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "diviser par longueur arc égale en points",
    "divideByEqualArcLengthToPoints": "diviser par longueur arc égale en points",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Divise la courbe par longueur d'arc égale en points",
    "bitbybit.verb.curve.divideByArcLengthToParams": "diviser par longueur arc en params",
    "divideByArcLengthToParams": "diviser par longueur arc en params",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Divise la courbe par longueur d'arc en paramètres",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "diviser par longueur arc en points",
    "divideByArcLengthToPoints": "diviser par longueur arc en points",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Divise la courbe par longueur d'arc en points",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "diviser courbes par longueur arc égale en points",
    "divideCurvesByEqualArcLengthToPoints": "diviser courbes par longueur arc égale en points",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divise plusieurs courbes par longueur d'arc égale en points",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "diviser courbes par longueur arc en points",
    "divideCurvesByArcLengthToPoints": "diviser courbes par longueur arc en points",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divise plusieurs courbes par longueur d'arc en points",
    "bitbybit.verb.curve.domain": "domaine",
    "bitbybit.verb.curve.domain_description": "Trouve l'intervalle de domaine des paramètres de la courbe",
    "bitbybit.verb.curve.startPoint": "point départ",
    "bitbybit.verb.curve.startPoint_description": "Point de départ de la courbe",
    "bitbybit.verb.curve.endPoint": "point arrivée",
    "bitbybit.verb.curve.endPoint_description": "Point de fin de la courbe",
    "bitbybit.verb.curve.startPoints": "points départ",
    "bitbybit.verb.curve.startPoints_description": "Points de départ des courbes",
    "bitbybit.verb.curve.endPoints": "points arrivée",
    "bitbybit.verb.curve.endPoints_description": "Points de fin des courbes",
    "bitbybit.verb.curve.knots": "nœuds",
    "bitbybit.verb.curve.knots_description": "Trouve les nœuds de la courbe Nurbs",
    "bitbybit.verb.curve.lengthAtParam": "longueur au param",
    "lengthAtParam": "longueur au param",
    "bitbybit.verb.curve.lengthAtParam_description": "Obtient la longueur de la courbe Nurbs au paramètre spécifique",
    "bitbybit.verb.curve.length": "longueur",
    "bitbybit.verb.curve.length_description": "Obtient la longueur de la courbe Nurbs",
    "bitbybit.verb.curve.paramAtLength": "param à longueur",
    "paramAtLength": "param à longueur",
    "bitbybit.verb.curve.paramAtLength_description": "Obtient le param à la longueur spécifiée sur la courbe Nurbs",
    "bitbybit.verb.curve.pointAtParam": "point au param",
    "pointAtParam": "point au param",
    "bitbybit.verb.curve.pointAtParam_description": "Obtient le point au paramètre spécifié sur la courbe Nurbs",
    "bitbybit.verb.curve.pointsAtParam": "points au param",
    "pointsAtParam": "points au param",
    "bitbybit.verb.curve.pointsAtParam_description": "Obtient les points au paramètre spécifié sur les courbes Nurbs",
    "bitbybit.verb.curve.reverse": "inverser",
    "bitbybit.verb.curve.reverse_description": "Inverse la courbe Nurbs",
    "bitbybit.verb.curve.split": "diviser",
    "bitbybit.verb.curve.split_description": "Divise la courbe Nurbs en deux à un paramètre donné",
    "bitbybit.verb.curve.tangent": "tangente",
    "bitbybit.verb.curve.tangent_description": "Tangente de la courbe Nurbs à un paramètre donné",
    "bitbybit.verb.curve.tessellate": "tesseller",
    "tessellate": "tesseller",
    "bitbybit.verb.curve.tessellate_description": "Tesselle la courbe Nurbs en une liste de points",
    "bitbybit.verb.curve.transform": "transformer",
    "bitbybit.verb.curve.transform_description": "Transforme la courbe Nurbs",
    "bitbybit.verb.curve.transformCurves": "transformer courbes",
    "transformCurves": "transformer courbes",
    "bitbybit.verb.curve.transformCurves_description": "Transforme les courbes Nurbs",
    "bitbybit.verb.curve.weights": "poids",
    "bitbybit.verb.curve.weights_description": "Poids de la courbe Nurbs",
    "bitbybit.verb.curve.circle.createCircle": "cercle",
    "createCircle": "cercle",
    "bitbybit.verb.curve.circle.createCircle_description": "Crée la courbe Nurbs de cercle",
    "xAxis": "axe x",
    "yAxis": "axe y",
    "bitbybit.verb.curve.circle.createArc": "arc",
    "createArc": "arc",
    "bitbybit.verb.curve.circle.createArc_description": "Crée la courbe Nurbs d'arc",
    "minAngle": "angle min",
    "maxAngle": "angle max",
    "bitbybit.verb.curve.circle.center": "centre",
    "bitbybit.verb.curve.circle.center_description": "Obtient le point central du cercle ou d'un arc",
    "bitbybit.verb.curve.circle.radius": "rayon",
    "bitbybit.verb.curve.circle.radius_description": "Obtient le rayon du cercle ou d'un arc",
    "bitbybit.verb.curve.circle.maxAngle": "angle max",
    "bitbybit.verb.curve.circle.maxAngle_description": "Obtient l'angle max de l'arc en degrés",
    "bitbybit.verb.curve.circle.minAngle": "angle min",
    "bitbybit.verb.curve.circle.minAngle_description": "Obtient l'angle min de l'arc en degrés",
    "bitbybit.verb.curve.circle.xAxis": "axe x",
    "bitbybit.verb.curve.circle.xAxis_description": "Obtient l'angle x de l'arc",
    "bitbybit.verb.curve.circle.yAxis": "axe y",
    "bitbybit.verb.curve.circle.yAxis_description": "Obtient l'angle y de l'arc",
    "bitbybit.verb.curve.ellipse.createEllipse": "ellipse",
    "createEllipse": "ellipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Crée la courbe Nurbs d'ellipse",
    "bitbybit.verb.curve.ellipse.createArc": "arc",
    "bitbybit.verb.curve.ellipse.createArc_description": "Crée la courbe Nurbs d'arc d'ellipse",
    "bitbybit.verb.curve.ellipse.center": "centre",
    "bitbybit.verb.curve.ellipse.center_description": "Obtient le point central de l'ellipse ou d'un arc",
    "bitbybit.verb.curve.ellipse.maxAngle": "angle max",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Obtient l'angle max de l'arc en degrés",
    "bitbybit.verb.curve.ellipse.minAngle": "angle min",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Obtient l'angle min de l'arc en degrés",
    "bitbybit.verb.curve.ellipse.xAxis": "axe x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Obtient l'angle x de l'arc ou d'une ellipse",
    "bitbybit.verb.curve.ellipse.yAxis": "axe y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Obtient l'angle y de l'arc ou d'une ellipse",
    "bitbybit.verb.surface.boundaries": "limites",
    "boundaries": "limites",
    "bitbybit.verb.surface.boundaries_description": "Obtient les courbes Nurbs de bordure de la surface dans une liste",
    "bitbybit.verb.surface.createSurfaceByCorners": "surface par coins",
    "createSurfaceByCorners": "surface par coins",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Crée la surface en fournissant 4 points comme coins",
    "point3": "point 3",
    "point4": "point 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "surface par nœuds points contrôle poids",
    "createSurfaceByKnotsControlPointsWeights": "surface par nœuds points contrôle poids",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Crée la surface Nurbs en fournissant des nœuds uv, des degrés uv, des points et des poids",
    "degreeU": "degré u",
    "degreeV": "degré v",
    "knotsU": "nœuds u",
    "knotsV": "nœuds v",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "surface par loft courbes",
    "createSurfaceByLoftingCurves": "surface par loft courbes",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Crée la surface Nurbs en lissant des courbes",
    "bitbybit.verb.surface.clone": "cloner",
    "bitbybit.verb.surface.clone_description": "Clone la surface Nurbs",
    "bitbybit.verb.surface.closestParam": "param plus proche",
    "bitbybit.verb.surface.closestParam_description": "Trouve le paramètre le plus proche sur la surface à partir du point",
    "bitbybit.verb.surface.closestPoint": "point plus proche",
    "bitbybit.verb.surface.closestPoint_description": "Trouve le point le plus proche sur la surface à partir du point",
    "bitbybit.verb.surface.controlPoints": "points contrôle",
    "bitbybit.verb.surface.controlPoints_description": "Obtient les points de contrôle sur la surface",
    "bitbybit.verb.surface.degreeU": "degré u",
    "bitbybit.verb.surface.degreeU_description": "Obtient le degré U de la surface",
    "bitbybit.verb.surface.degreeV": "degré v",
    "bitbybit.verb.surface.degreeV_description": "Obtient le degré V de la surface",
    "bitbybit.verb.surface.derivatives": "dérivées",
    "bitbybit.verb.surface.derivatives_description": "Obtient les dérivées de la surface à la coordonnée uv spécifiée",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "domaine u",
    "domainU": "domaine u",
    "bitbybit.verb.surface.domainU_description": "Obtient le domaine U de la surface",
    "bitbybit.verb.surface.domainV": "domaine v",
    "domainV": "domaine v",
    "bitbybit.verb.surface.domainV_description": "Obtient le domaine V de la surface",
    "bitbybit.verb.surface.isocurve": "isocourbe",
    "isocurve": "isocourbe",
    "bitbybit.verb.surface.isocurve_description": "Obtient l'isocourbe Nurbs sur la surface",
    "useV": "utiliser v",
    "bitbybit.verb.surface.isocurvesSubdivision": "subdivision isocourbes",
    "isocurvesSubdivision": "subdivision isocourbes",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Subdivise la surface en nombre préféré d'isocourbes",
    "isocurveSegments": "segments isocourbe",
    "bitbybit.verb.surface.isocurvesAtParams": "isocourbes aux params",
    "isocurvesAtParams": "isocourbes aux params",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Subdivise la surface en isocourbes sur un tableau de paramètres spécifié",
    "parameters": "paramètres",
    "bitbybit.verb.surface.knotsU": "nœuds u",
    "bitbybit.verb.surface.knotsU_description": "Obtient les nœuds U de la surface",
    "bitbybit.verb.surface.knotsV": "nœuds v",
    "bitbybit.verb.surface.knotsV_description": "Obtient les nœuds V de la surface",
    "bitbybit.verb.surface.normal": "normale",
    "bitbybit.verb.surface.normal_description": "Obtient la normale sur la surface à la coordonnée uv",
    "bitbybit.verb.surface.point": "point",
    "bitbybit.verb.surface.point_description": "Obtient le point sur la surface à la coordonnée uv",
    "bitbybit.verb.surface.reverse": "inverser",
    "bitbybit.verb.surface.reverse_description": "Inverse la surface Nurbs. Cela inversera l'origine UV et les directions des isocourbes",
    "bitbybit.verb.surface.split": "diviser",
    "bitbybit.verb.surface.split_description": "Divise la surface Nurbs en deux moitiés.",
    "bitbybit.verb.surface.transformSurface": "transformer surface",
    "transformSurface": "transformer surface",
    "bitbybit.verb.surface.transformSurface_description": "Transforme la surface Nurbs avec une liste de transformations donnée.",
    "bitbybit.verb.surface.weights": "poids",
    "bitbybit.verb.surface.weights_description": "Obtient les poids de la surface",
    "bitbybit.verb.surface.cone.create": "créer",
    "cone": "cône",
    "bitbybit.verb.surface.cone.create_description": "Crée la surface Nurbs conique",
    "bitbybit.verb.surface.cone.axis": "axe",
    "bitbybit.verb.surface.cone.axis_description": "Obtenir l'axe du cône",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "Obtenir la base du cône",
    "bitbybit.verb.surface.cone.height": "hauteur",
    "bitbybit.verb.surface.cone.height_description": "Obtenir la hauteur du cône",
    "bitbybit.verb.surface.cone.radius": "rayon",
    "bitbybit.verb.surface.cone.radius_description": "Obtenir le rayon du cône",
    "bitbybit.verb.surface.cone.xAxis": "axe x",
    "bitbybit.verb.surface.cone.xAxis_description": "Obtenir l'axe x du cône",
    "bitbybit.verb.surface.cylinder.create": "créer",
    "bitbybit.verb.surface.cylinder.create_description": "Crée la surface Nurbs cylindrique",
    "bitbybit.verb.surface.cylinder.axis": "axe",
    "bitbybit.verb.surface.cylinder.axis_description": "Obtenir l'axe du cylindre",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "Obtenir la base du cylindre",
    "bitbybit.verb.surface.cylinder.height": "hauteur",
    "bitbybit.verb.surface.cylinder.height_description": "Obtenir la hauteur du cylindre",
    "bitbybit.verb.surface.cylinder.radius": "rayon",
    "bitbybit.verb.surface.cylinder.radius_description": "Obtenir le rayon du cylindre",
    "bitbybit.verb.surface.cylinder.xAxis": "axe x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Obtenir l'axe x du cylindre",
    "bitbybit.verb.surface.extrusion.create": "créer",
    "extrusion": "extrusion",
    "bitbybit.verb.surface.extrusion.create_description": "Crée l'extrusion de surface Nurbs à partir de la courbe",
    "profile": "profil",
    "bitbybit.verb.surface.extrusion.direction": "direction",
    "bitbybit.verb.surface.extrusion.direction_description": "Obtient le vecteur de direction de l'extrusion",
    "bitbybit.verb.surface.extrusion.profile": "profil",
    "bitbybit.verb.surface.extrusion.profile_description": "Obtient la courbe Nurbs de profil de l'extrusion",
    "bitbybit.verb.surface.sphere.create": "créer",
    "bitbybit.verb.surface.sphere.create_description": "Crée la surface Nurbs sphérique",
    "bitbybit.verb.surface.sphere.radius": "rayon",
    "bitbybit.verb.surface.sphere.radius_description": "Obtenir le rayon de la surface Nurbs sphérique",
    "bitbybit.verb.surface.sphere.center": "centre",
    "bitbybit.verb.surface.sphere.center_description": "Obtenir le centre de la surface Nurbs sphérique",
    "bitbybit.verb.surface.revolved.create": "créer",
    "revolved": "révolution",
    "bitbybit.verb.surface.revolved.create_description": "Crée la surface Nurbs tournée",
    "bitbybit.verb.surface.revolved.profile": "profil",
    "bitbybit.verb.surface.revolved.profile_description": "Obtenir la courbe Nurbs de profil de la surface Nurbs tournée",
    "revolution": "révolution",
    "bitbybit.verb.surface.revolved.center": "centre",
    "bitbybit.verb.surface.revolved.center_description": "Obtenir la courbe Nurbs centrale de la surface Nurbs tournée",
    "bitbybit.verb.surface.revolved.axis": "axe",
    "bitbybit.verb.surface.revolved.axis_description": "Obtenir l'axe de rotation de la surface Nurbs tournée",
    "bitbybit.verb.surface.revolved.angle": "angle",
    "bitbybit.verb.surface.revolved.angle_description": "Obtenir l'angle de rotation de la surface Nurbs tournée",
    "bitbybit.verb.surface.sweep.create": "créer",
    "sweep": "balayage",
    "bitbybit.verb.surface.sweep.create_description": "Crée la surface Nurbs balayée",
    "rail": "rail",
    "bitbybit.verb.surface.sweep.profile": "profil",
    "bitbybit.verb.surface.sweep.profile_description": "Obtenir la courbe Nurbs de profil de la surface Nurbs balayée",
    "bitbybit.verb.surface.sweep.rail": "rail",
    "bitbybit.verb.surface.sweep.rail_description": "Obtenir la courbe Nurbs de rail de la surface Nurbs balayée",
    "bitbybit.verb.intersect.curves": "courbes",
    "bitbybit.verb.intersect.curves_description": "Intersecte deux courbes Nurbs verb ensemble et renvoie les résultats d'intersection",
    "firstCurve": "première courbe",
    "secondCurve": "seconde courbe",
    "bitbybit.verb.intersect.curveAndSurface": "courbe et surface",
    "curveAndSurface": "courbe et surface",
    "bitbybit.verb.intersect.curveAndSurface_description": "intersecte courbe et surface",
    "bitbybit.verb.intersect.surfaces": "surfaces",
    "bitbybit.verb.intersect.surfaces_description": "intersecte deux surfaces",
    "firstSurface": "première surface",
    "secondSurface": "seconde surface",
    "bitbybit.verb.intersect.curveCurveFirstParams": "courbe courbe premiers params",
    "curveCurveFirstParams": "courbe courbe premiers params",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Obtient les paramètres d'intersection sur la première courbe de l'intersection courbe-courbe",
    "intersections": "intersections",
    "BaseTypes.CurveCurveIntersection[]": "tableau intersection courbe courbe types base",
    "bitbybit.verb.intersect.curveCurveSecondParams": "courbe courbe seconds params",
    "curveCurveSecondParams": "courbe courbe seconds params",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Obtient les paramètres d'intersection sur la seconde courbe de l'intersection courbe-courbe",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "courbe courbe premiers points",
    "curveCurveFirstPoints": "courbe courbe premiers points",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Obtient les points d'intersection sur la première courbe de l'intersection courbe-courbe",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "courbe courbe seconds points",
    "curveCurveSecondPoints": "courbe courbe seconds points",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Obtient les points d'intersection sur la seconde courbe de l'intersection courbe-courbe",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "courbe surface params courbe",
    "curveSurfaceCurveParams": "courbe surface params courbe",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Obtient les paramètres d'intersection sur la courbe de l'intersection courbe-surface",
    "BaseTypes.CurveSurfaceIntersection[]": "tableau intersection courbe surface types base",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "courbe surface params surface",
    "curveSurfaceSurfaceParams": "courbe surface params surface",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Obtient les paramètres d'intersection sur la surface de l'intersection courbe-surface",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "courbe surface points courbe",
    "curveSurfaceCurvePoints": "courbe surface points courbe",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Obtient les points d'intersection sur la courbe de l'intersection courbe-surface",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "courbe surface points surface",
    "curveSurfaceSurfacePoints": "courbe surface points surface",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Obtient les points d'intersection sur la surface de l'intersection courbe-surface",
    "bitbybit.tag.create": "créer",
    "tag": "balise",
    "bitbybit.tag.create_description": "Crée un dto de balise",
    "adaptDepth": "adapter profondeur",
    "needsUpdate": "nécessite mise à jour",
    "bitbybit.time.registerRenderFunction": "enregistrer fonction rendu",
    "registerRenderFunction": "enregistrer fonction rendu",
    "bitbybit.time.registerRenderFunction_description": "Enregistre une fonction dans la boucle de rendu",
    "bitbybit.asset.getFile": "obtenir fichier",
    "asset": "actif",
    "getFile": "obtenir fichier",
    "bitbybit.asset.getFile_description": "Obtient le fichier d'actif",
    "bitbybit.asset.getLocalFile": "obtenir fichier local",
    "getLocalFile": "obtenir fichier local",
    "bitbybit.asset.getLocalFile_description": "Obtient le fichier d'actif local stocké dans votre navigateur.",
    "bitbybit.asset.fetchBlob": "récupérer blob",
    "fetchBlob": "récupérer blob",
    "bitbybit.asset.fetchBlob_description": "Récupère le blob à partir de l'url donnée, doit être un point de terminaison accessible compatible CORS",
    "fetch": "récupérer",
    "bitbybit.asset.fetchFile": "récupérer fichier",
    "fetchFile": "récupérer fichier",
    "bitbybit.asset.fetchFile_description": "Récupère le fichier à partir de l'url donnée, doit être un point de terminaison accessible compatible CORS",
    "bitbybit.asset.fetchJSON": "récupérer json",
    "fetchJSON": "récupérer json",
    "bitbybit.asset.fetchJSON_description": "Récupère le json à partir de l'url donnée, doit être un point de terminaison accessible compatible CORS",
    "bitbybit.asset.fetchText": "récupérer texte",
    "fetchText": "récupérer texte",
    "bitbybit.asset.fetchText_description": "Récupère le texte à partir de l'url donnée, doit être un point de terminaison accessible compatible CORS",
    "bitbybit.asset.createObjectURL": "url objet",
    "createObjectURL": "url objet",
    "bitbybit.asset.createObjectURL_description": "Obtient et crée le chemin de chaîne url vers votre fichier stocké dans votre mémoire.",
    "file": "fichier",
    "File | Blob": "Fichier | Blob",
    "bitbybit.asset.createObjectURLs": "urls objet",
    "createObjectURLs": "urls objet",
    "bitbybit.asset.createObjectURLs_description": "Obtient et crée les chemins de chaîne url vers vos fichiers stockés dans votre mémoire.",
    "files": "fichiers",
    "(File | Blob)[]": "tableau Fichier | Blob",
    "exec": "exécuter",
    "Visible": "Visible",
    "Hidden": "Caché",
    "flatten": "aplatir",
    "force exec": "forcer exécution",
    "console log": "log console",
    "preview data": "prévisualiser données",
    "flow": "flux",
    "code": "code",
    "runner": "exécuteur",
    "counters": "compteurs",
    "actions": "actions",
    "loops": "boucles",
    "interval": "intervalle",
    "delay": "délai",
    "expire": "expirer",
    "timeout": "délai",
    "counter min max": "compteur min max",
    "counter steps": "compteur pas",
    "reset": "réinitialiser",
    "trigger": "déclencher",
    "mouse": "souris",
    "mouse click": "clic souris",
    "key": "touche",
    "pointer": "pointeur",
    "pick info": "info sélection",
    "down": "bas",
    "wheel": "molette",
    "tap": "tap",
    "double tap": "double tap",
    "render": "rendu",
    "passed ms": "ms écoulées",
    "babylon observable listener": "écouteur observable babylon",
    "object": "objet",
    "observable selector": "sélecteur observable",
    "get event data": "obtenir données événement",
    "exec click": "exécuter clic",
    "exec down": "exécuter bas",
    "toggle": "basculer",
    "flip flop": "bascule",
    "boolean gate": "porte booléenne",
    "boolean gate silent": "porte booléenne silencieuse",
    "is undefined": "est indéfini",
    "for loop": "boucle for",
    "last": "dernier",
    "for each loop": "boucle for each",
    "element": "élément",
    "body": "corps",
    "complete": "terminé",
    "editors": "éditeurs",
    "inputs": "entrées",
    "outputs": "sorties",
    "recent": "récent",
    "Clear": "Effacer",
    "Run": "Exécuter",
    "Swap Canvas": "Échanger Canvas",
    "Local Assets": "Actifs Locaux",
    "Import": "Importer",
    "Copy to Clipboard": "Copier dans le Presse-papiers",
    "Paste from Clipboard": "Coller du Presse-papiers",
    "Export": "Exporter",
    "Export to runner": "Exporter vers exécuteur",
    "Clean Cache": "Nettoyer Cache",
    "Community": "Communauté",
    "Sponsors and Partners": "Sponsors et Partenaires",
    "API Documentation": "Documentation API",
    "About": "À propos",
    "Toolbox": "Boîte à outils",
    "More": "Plus",
    "bitbybit.code.typeScriptEditor": "éditeur typescript",
    "bitbybit.code.typeScriptEditor_description": "Permet d'écrire du code TypeScript avec l'intellisense complet de bitbybit dans une seule fonction. Ce que la fonction start retourne sera vu comme une sortie du composant.",
    "bitbybit.code.javaScriptEditor": "éditeur javascript",
    "bitbybit.code.javaScriptEditor_description": "Permet d'écrire du code JavaScript dans une seule fonction. Ce que la fonction start retourne sera vu comme une sortie du composant.",
    "bitbybit.code.jsonEditor": "éditeur json",
    "bitbybit.code.jsonEditor_description": "Permet d'écrire du code JSON. Ce que la fonction start retourne sera vu comme une sortie du composant.",
    "bitbybit.flow.actions.keyboard": "clavier",
    "bitbybit.flow.actions.keyboard_description": "S'exécutera sur les événements clavier en cliquant sur les boutons.",
    "bitbybit.flow.actions.mouseClick": "clic souris",
    "bitbybit.flow.actions.mouseClick_description": "S'exécutera sur les événements souris en cliquant sur les boutons.",
    "bitbybit.flow.actions.start": "démarrer",
    "bitbybit.flow.actions.start_description": "Démarre le flux de contrôle et déclenche les exécutions.",
    "bitbybit.flow.actions.trigger": "déclencher",
    "bitbybit.flow.actions.trigger_description": "Déclenche l'exécution en cliquant sur le bouton.",
    "bitbybit.flow.babylon.gui.button": "bouton",
    "bitbybit.flow.babylon.gui.button_description": "S'exécutera sur divers événements de pointeur en cliquant sur le bouton gauche de la souris sur le canvas babylonjs.",
    "bitbybit.flow.babylon.scene.pointerEvents": "pointeur",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "S'exécutera sur divers événements de pointeur en cliquant sur le bouton gauche de la souris sur le canvas babylonjs.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "obtenir données événement",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Obtient les données d'événement du résultat observé de l'écouteur observable.",
    "bitbybit.flow.babylon.observableListener": "écouteur observable babylon",
    "bitbybit.flow.babylon.observableListener_description": "S'abonnera et écoutera n'importe quel observable babylonjs.",
    "bitbybit.flow.babylon.render": "rendu",
    "bitbybit.flow.babylon.render_description": "S'exécute à chaque frame de rendu babylonjs.",
    "bitbybit.flow.counters.counterMinMax": "compteur min max",
    "bitbybit.flow.counters.counterMinMax_description": "Compte le nombre d'exécutions de flux entre les valeurs min et max. Quand max est atteint, il se réinitialise",
    "bitbybit.flow.counters.counterSteps": "compteur pas",
    "bitbybit.flow.counters.counterSteps_description": "Compte le nombre d'exécutions de flux en commençant par la valeur de comptage donnée et en augmentant à chaque exécution par le pas donné de la liste, jusqu'à ce que les pas soient terminés. Quand la fin est atteinte, il se réinitialise",
    "bitbybit.flow.counters.counter": "compteur",
    "bitbybit.flow.counters.counter_description": "Compte le nombre d'exécutions de flux.",
    "bitbybit.flow.logic.booleanGateSilent": "porte booléenne silencieuse",
    "bitbybit.flow.logic.booleanGateSilent_description": "Déclenche différents événements d'exécution en fonction de la valeur du booléen fourni, mais ne s'exécute que lorsque le booléen change de valeur, ce qui empêche plusieurs événements de se déclencher constamment même si aucun changement ne s'est produit.",
    "bitbybit.flow.logic.booleanGate": "porte booléenne",
    "bitbybit.flow.logic.booleanGate_description": "Déclenche différents événements d'exécution en fonction de la valeur du booléen fourni.",
    "bitbybit.flow.logic.flipFlop": "bascule",
    "bitbybit.flow.logic.flipFlop_description": "Chaque fois qu'un événement est exécuté, un événement différent se déclenche, créant essentiellement une fonctionnalité de bascule.",
    "bitbybit.flow.logic.isUndefined": "est indéfini",
    "bitbybit.flow.logic.isUndefined_description": "Vérifie si la valeur fournie est indéfinie et déclenche un événement vrai ou faux.",
    "bitbybit.flow.loops.forEach": "boucle for each",
    "bitbybit.flow.loops.forEach_description": "Boucle For each qui parcourt tous les éléments de la liste.",
    "bitbybit.flow.loops.for": "boucle for",
    "bitbybit.flow.loops.for_description": "Boucle For qui exécute le corps entre deux valeurs.",
    "bitbybit.flow.time.delay": "délai",
    "bitbybit.flow.time.delay_description": "Retarde l'exécution par le délai donné en ms.",
    "bitbybit.flow.time.interval": "intervalle",
    "bitbybit.flow.time.interval_description": "Exécute le flux à chaque intervalle donné en ms.",
    "bitbybit.lists.createList": "créer liste",
    "bitbybit.lists.createList_description": "Crée une liste à partir des éléments donnés.",
    "bitbybit.lists.flatten": "aplatir",
    "bitbybit.lists.flatten_description": "Aplatit la liste de listes en une seule liste.",
    "bitbybit.lists.passThrough": "laisser passer",
    "bitbybit.lists.passThrough_description": "Caste la valeur au type 'any' et passe l'entrée à la sortie sans aucune modification.",
    "bitbybit.math.numberSlider": "curseur nombre",
    "bitbybit.math.numberSlider_description": "Crée un nombre avec un curseur. Vous pouvez configurer les valeurs min, max et pas.",
    "bitbybit.consoleLog": "log console",
    "bitbybit.consoleLog_description": "Enregistre l'entrée dans la console du navigateur.",
    "bitbybit.previewData": "prévisualiser données",
    "bitbybit.previewData_description": "Affiche les données d'entrée dans une zone d'aperçu. Il peut s'agir de texte, de nombres, d'objets json, de tableaux, etc. Les objets Javascript circulaires ne sont pas autorisés.",
    "bitbybit.runner.getRunnerInputValue": "obtenir valeur entrée exécuteur",
    "bitbybit.runner.getRunnerInputValue_description": "Obtenir la valeur d'entrée de l'exécuteur à partir du JSON d'entrées. Ce composant retournera toujours une valeur indéfinie dans le contexte de l'éditeur.",
    "bitbybit.runner.getRunnerInputs": "obtenir entrées exécuteur",
    "bitbybit.runner.getRunnerInputs_description": "Obtenir les entrées de l'exécuteur en JSON. Ce composant retournera toujours un objet vide dans le contexte de l'éditeur.",
    "bitbybit.runner.run": "exécuter",
    "bitbybit.runner.run_description": "Exécute le code javascript de l'exécuteur",
    "bitbybit.runner.setRunnerResult": "définir résultat exécuteur",
    "bitbybit.runner.setRunnerResult_description": "Définit le résultat JSON complet pour l'exécuteur. Gardez à l'esprit qu'il est plus sûr de définir des valeurs car cette méthode écrasera tout l'objet de résultat avec la valeur fournie.",
    "bitbybit.runner.setRunnerResultArrayValue": "définir valeur tableau résultat exécuteur",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Définit la valeur du résultat de l'exécuteur sur la propriété de l'objet JSON. Chaque valeur sera ajoutée à un tableau, qui est la valeur de la propriété.",
    "bitbybit.runner.setRunnerResultValue": "définir valeur résultat exécuteur",
    "bitbybit.runner.setRunnerResultValue_description": "Définit la valeur du résultat de l'exécuteur sur la propriété de l'objet JSON.",
    "bitbybit.text.areaCreate": "zone texte",
    "bitbybit.text.areaCreate_description": "Crée une zone de texte dans l'éditeur. Vous pouvez configurer le texte, la largeur et la hauteur de la zone.",
    "update on drag": "mettre à jour au glisser",
    "paste": "coller",
    "duplicate": "dupliquer",
    "delete": "supprimer",
    "keyboard": "clavier",
    "data": "données",
    "observables": "observables",
    "buttons": "boutons",
    "variables": "variables",
    "functions": "fonctions",
    "loop": "boucle",
    "apply": "appliquer",
    "async context": "contexte async",
    "async context description": "Créer un contexte asynchrone pouvant utiliser des composants await, simplifiant l'exécution et la lisibilité du code asynchrone.",
    "then": "ensuite",
    "await": "attendre",
    "await description": "Attend que la promesse soit résolue et retourne la valeur.",
    "when the": "quand le",
    "error": "erreur",
    "happens in the promise": "se produit dans la promesse",
    "catch": "capturer",
    "catch description": "Capture l'erreur qui peut se produire lors de l'exécution de code asynchrone. L'utilisateur peut choisir de gérer les erreurs de manière appropriée.",
    "cancel the interval execution": "annuler l'exécution de l'intervalle",
    "cancel the interval description": "Annule l'exécution de l'intervalle en fournissant le gestionnaire.",
    "cancel the timeout execution": "annuler l'exécution du délai",
    "cancel the timeout description": "Annule l'exécution du délai en fournissant le gestionnaire.",
    "key down": "touche enfoncée",
    "key down descritpion": "Déclenche le code lorsque l'événement touche enfoncée se produit.",
    "key up": "touche relâchée",
    "key up description": "Déclenche le code lorsque l'événement touche relâchée se produit.",
    "key press": "touche pressée",
    "key press description": "Déclenche le code lorsque l'événement touche pressée se produit.",
    "is key pressed": "est touche pressée",
    "block_validation_required": "doit être fourni",
    "block_validation_of_length": "doit contenir un nombre d'éléments de",
    "block_validation_higher_or_equal": "doit être supérieur ou égal à",
    "block_validation_lower_or_equal": "doit être inférieur ou égal à",
    "block_validation_range": "doit être dans la plage",
    "block_validation_smaller_than": "doit être inférieur à",
    "block_validation_smaller_or_equal_than": "doit être inférieur ou égal à",
    "block_validation_larger_than": "doit être supérieur à",
    "block_validation_larger_or_equal_than": "doit être supérieur ou égal à",
    "save text to file": "sauvegarder texte fichier",
    "save text to file description": "Sauvegarde le texte dans un fichier et vous permet de choisir le nom et l'extension. Ce composant ne prévisualise pas le texte et peut être utilisé dans des situations où le texte peut être trop volumineux pour être édité dans un champ de zone de texte.",
    "print text on screen": "imprimer texte écran",
    "print text on screen description": "Imprime le texte à l'écran. Ce composant est utile à des fins de débogage.",
    "preview text and save to file": "prévisualiser texte et sauvegarder fichier",
    "preview text and save to file description": "Imprime le texte à l'écran et vous permet de le sauvegarder dans un fichier. Ce composant est utile à des fins de débogage.",
    "register render loop listener": "enregistrer écouteur boucle rendu",
    "and update": "et mettre à jour",
    "register render loop listener description": "Exécute l'instruction dans la boucle de rendu et indique combien de temps s'est écoulé depuis la dernière image dans la variable timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "tempsEcouleDepuisImagePrecedente",
    "computing": "calcul en cours",
    "result": "résultat",
    "of promise is returned": "de la promesse est retourné",
    "on pointer up": "sur pointeur haut",
    "on pointer move": "sur pointeur mouvement",
    "on pointer down": "sur pointeur bas",
    "of babylonjs observable object": "de l'objet observable babylonjs",
    "observable name": "nom observable",
    "is key pressed description": "Vérifie si la touche est pressée et retourne vrai ou faux.",
    "execute code after": "exécuter code après",
    "execute code after description": "Exécute le code après le délai donné en secondes.",
    "execute code every": "exécuter code toutes les",
    "second(s)": "seconde(s)",
    "execute code every description": "Exécute le code à chaque intervalle donné en secondes.",
    "handler": "gestionnaire",
    "workers initialising": "initialisation workers",
    "Assets": "Actifs",
    "Local assets stored in browser cache:": "Actifs locaux stockés dans le cache du navigateur :",
    "Asset Name": "Nom Actif",
    "Name is required": "Nom requis",
    "Asset with this name already exists, choose a different one": "Un actif avec ce nom existe déjà, choisissez-en un autre",
    "Allowed file formats:": "Formats de fichiers autorisés :",
    "You must select an asset file": "Vous devez sélectionner un fichier actif",
    "Upload Local Asset": "Téléverser Actif Local",
    "File Name": "Nom Fichier",
    "File Size": "Taille Fichier",
    "Your browser does not support indexDB and you can't upload local asset files.": "Votre navigateur ne prend pas en charge indexDB et vous ne pouvez pas téléverser de fichiers actifs locaux.",
    "Upload": "Téléverser",
    "elements": "éléments",
    "bitbybit.vector.vectorsTheSame": "vecteurs identiques",
    "vectorsTheSame": "vecteurs identiques",
    "bitbybit.vector.vectorsTheSame_description": "Vérifie si deux vecteurs sont identiques dans une tolérance donnée (tient compte de la précision en virgule flottante). Exemple : [1,2,3] vs [1.0001,2.0001,3.0001] avec tolérance 0.001 → true",
    "vec1": "vecteur 1",
    "vec2": "vecteur 2",
    "bitbybit.point.boundingBoxOfPoints": "boîte englobante des points",
    "boundingBoxOfPoints": "boîte englobante des points",
    "bitbybit.point.boundingBoxOfPoints_description": "Calcule la boîte englobante alignée sur l'axe contenant tous les points (min, max, centre, largeur, hauteur, longueur). Exemple : points=[[0,0,0], [10,5,3]] → {min:[0,0,0], max:[10,5,3], centre:[5,2.5,1.5], largeur:10, hauteur:5, longueur:3}",
    "bitbybit.point.normalFromThreePoints": "normale à partir de trois points",
    "normalFromThreePoints": "normale à partir de trois points",
    "bitbybit.point.normalFromThreePoints_description": "Calcule le vecteur normal à partir de trois points en utilisant le produit vectoriel (perpendiculaire au plan). Exemple : p1=[0,0,0], p2=[1,0,0], p3=[0,1,0] → [0,0,1] (pointant vers le haut depuis le plan XY)",
    "reverseNormal": "normale inversée",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "polyligne avec extensions",
    "createLineWireWithExtensions": "polyligne avec extensions",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Crée une polyligne OpenCascade avec extensions",
    "extensionStart": "début ext.",
    "extensionEnd": "fin ext.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "point médian sur polyligne",
    "midPointOnWire": "point médian sur polyligne",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Calcule le point médian sur la polyligne au paramètre 0.5",
    "centerOnOrigin": "centrer sur l'origine",
    "bitbybit.occt.shapes.wire.textWiresWithData": "polylignes de texte avec données",
    "textWiresWithData": "polylignes de texte avec données",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Crée un composé OpenCascade à partir de polylignes de texte et renvoie des informations supplémentaires basées sur la police simplex créée par le Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "aligner normale et axe",
    "alignNormAndAxis": "aligner normale et axe",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Aligne la forme avec la normale et l'axe",
    "fromNorm": "depuis normale",
    "fromAx": "depuis axe",
    "toNorm": "vers normale",
    "toAx": "vers axe",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "cote de longueur linéaire simple",
    "simpleLinearLengthDimension": "cote de longueur linéaire simple",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Crée une dimension de longueur linéaire simple entre deux points - unités de mesure. Vous décidez quel type d'unités vous utilisez en fournissant un suffixe.",
    "offsetFromPoints": "décalage depuis les points",
    "crossingSize": "taille de croisement",
    "labelSuffix": "suffixe d'étiquette",
    "labelSize": "taille d'étiquette",
    "labelOffset": "décalage d'étiquette",
    "bitbybit.occt.dimensions.simpleAngularDimension": "cote angulaire simple",
    "simpleAngularDimension": "cote angulaire simple",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Crée une cote angulaire simple. Par défaut, affiche les degrés, mais vous pouvez choisir d'utiliser les radians.",
    "direction1": "direction 1",
    "direction2": "direction 2",
    "offsetFromCenter": "décalage par rapport au centre",
    "extraSize": "taille supplémentaire",
    "radians": "radians",
    "bitbybit.occt.dimensions.pinWithLabel": "repère avec étiquette",
    "pinWithLabel": "repère avec étiquette",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Crée un repère avec étiquette. Il peut être utilisé pour expliquer des choses sur les modèles ou marquer des éléments importants dans la scène 3D.",
    "offsetFromStart": "décalage par rapport au début",
    "bitbybit.vector.lengthSq": "longueur au carré",
    "lengthSq": "longueur au carré",
    "bitbybit.vector.lengthSq_description": "Calcule la longueur au carré (grandeur au carré) d'un vecteur 3D. Exemple : [3,4,0] → 25 (longueur 5 au carré)",
    "bitbybit.point.twoPointsAlmostEqual": "deux points égaux",
    "twoPointsAlmostEqual": "deux points égaux",
    "bitbybit.point.twoPointsAlmostEqual_description": "Vérifie si deux points sont approximativement égaux dans la tolérance (comparaison basée sur la distance). Exemple : point1=[1.0000001, 2.0, 3.0], point2=[1.0, 2.0, 3.0], tolérance=1e-6 → true",
    "bitbybit.line.lineToSegment": "ligne vers segment",
    "lineToSegment": "ligne vers segment",
    "bitbybit.line.lineToSegment_description": "Convertit l'objet ligne au format tableau de segment. Exemple : {start:[0,0,0], end:[10,5,0]} → [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "lignes vers segments",
    "linesToSegments": "lignes vers segments",
    "bitbybit.line.linesToSegments_description": "Convertit plusieurs objets ligne au format tableau de segment (conversion par lot). Exemple : 3 objets ligne → 3 tableaux de segments [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "segment vers ligne",
    "segmentToLine": "segment vers ligne",
    "bitbybit.line.segmentToLine_description": "Convertit le format tableau de segment en format objet ligne. Exemple : [[0,0,0], [10,5,0]] → {start:[0,0,0], end:[10,5,0]}",
    "segment": "segment",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segments vers lignes",
    "segmentsToLines": "segments vers lignes",
    "bitbybit.line.segmentsToLines_description": "Convertit plusieurs tableaux de segments en format objet ligne (conversion par lot). Exemple : 3 tableaux de segments → 3 objets ligne avec propriétés start/end",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "trier les segments en polylignes",
    "sortSegmentsIntoPolylines": "trier les segments en polylignes",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Trie les segments mélangés en polylignes connectées en faisant correspondre les points d'extrémité. Utilise le hachage spatial pour une recherche de connexion efficace. Exemple : 10 segments aléatoires qui forment 2 chemins connectés → 2 polylignes",
    "sort": "trier",
    "bitbybit.mesh.signedDistanceToPlane": "distance signée au plan",
    "signedDistanceToPlane": "distance signée au plan",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calcule la distance signée d'un point à un plan (positif=au-dessus du plan, négatif=en dessous). Exemple : point=[0,5,0], plan={normal:[0,1,0], d:0} → 5 (le point est à 5 unités au-dessus du plan XZ)",
    "plane": "plan",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calculer le plan du triangle",
    "calculateTrianglePlane": "calculer le plan du triangle",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calcule l'équation du plan à partir des sommets du triangle (vecteur normal et distance de l'origine). Renvoie undefined si le triangle est dégénéré (aire nulle, points colinéaires). Exemple : triangle=[[0,0,0], [1,0,0], [0,1,0]] → {normal:[0,0,1], d:0} (plan XY)",
    "triangle": "triangle",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "intersection triangle-triangle",
    "triangleTriangleIntersection": "intersection triangle-triangle",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calcule le segment d'intersection de deux triangles (segment de ligne où ils se croisent). Renvoie undefined si les triangles ne se croisent pas, sont parallèles ou sont coplanaires. Exemple : triangle1=[[0,0,0], [2,0,0], [1,2,0]], triangle2=[[1,-1,1], [1,1,1], [1,1,-1]] → [[1,0,0], [1,1,0]]",
    "triangle1": "triangle 1",
    "triangle2": "triangle 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segments d'intersection maillage-maillage",
    "meshMeshIntersectionSegments": "segments d'intersection maillage-maillage",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calcule tous les segments d'intersection entre deux maillages triangulaires (tests triangulaires par paires). Renvoie un tableau de segments de ligne où les surfaces de maillage se croisent. Exemple : maillage cube intersectant avec maillage sphère → plusieurs segments formant une courbe d'intersection",
    "mesh1": "maillage 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "maillage 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polylignes d'intersection maillage-maillage",
    "meshMeshIntersectionPolylines": "polylignes d'intersection maillage-maillage",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calcule les polylignes d'intersection entre deux maillages en triant les segments en chemins connectés. Les segments sont joints bout à bout pour former des courbes continues ou fermées. Exemple : intersection cube-sphère → boucles de polylignes fermées où les surfaces se rencontrent",
    "bitbybit.occt.shapeFacesToPolygonPoints": "faces de forme vers points de polygone",
    "shapeFacesToPolygonPoints": "faces de forme vers points de polygone",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Crée des points de polygone à partir des faces de la forme",
    "reversedPoints": "points inversés",
    "bitbybit.occt.shapeToMesh": "forme vers maillage",
    "shapeToMesh": "forme vers maillage",
    "bitbybit.occt.shapeToMesh_description": "Crée un maillage à partir de la forme",
    "bitbybit.occt.shapesToMeshes": "formes vers maillages",
    "shapesToMeshes": "formes vers maillages",
    "bitbybit.occt.shapesToMeshes_description": "Crée un maillage à partir de la forme",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "à partir de points de polygone",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Créer une variété (Manifold) à partir d'un ensemble de points de polygone décrivant des triangles.",
    "traingle": "triangle",
    "bitbybit.point.stretchPointsDirFromCenter": "étirer les points depuis le centre dans une direction",
    "stretchPointsDirFromCenter": "étirer les points depuis le centre dans une direction",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Étire plusieurs points le long d'une direction depuis un point central (mise à l'échelle directionnelle). Exemple : points=[[10,0,0]], centre=[0,0,0], direction=[1,0,0], echelle=2 → [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "grille hexagonale mise à l'échelle pour s'adapter",
    "hexGridScaledToFit": "grille hexagonale mise à l'échelle pour s'adapter",
    "bitbybit.point.hexGridScaledToFit_description": "Crée une grille hexagonale mise à l'échelle pour s'adapter aux limites de largeur/hauteur spécifiées (calcule automatiquement la taille de l'hexagone). Renvoie les points centraux et les sommets de l'hexagone. Prend en charge l'orientation pointe en haut ou plat en haut. Exemple : largeur=10, hauteur=10, nrHexagonesEnHauteur=3 → grille hex remplissant la zone 10×10 avec 3 rangées",
    "nrHexagonsU": "nb hexagones U",
    "nrHexagonsV": "nb hexagones V",
    "extendTop": "étendre haut",
    "extendBottom": "étendre bas",
    "extendLeft": "étendre gauche",
    "extendRight": "étendre droite",
    "centerGrid": "centrer la grille",
    "bitbybit.point.sortPoints": "trier les points",
    "sortPoints": "trier les points",
    "bitbybit.point.sortPoints_description": "Trie les points lexicographiquement (par coordonnées X, puis Y, puis Z). Exemple : [[5,0,0], [1,0,0], [3,0,0]] → [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "intersection ligne-ligne",
    "lineLineIntersection": "intersection ligne-ligne",
    "bitbybit.line.lineLineIntersection_description": "Calcule le point d'intersection de deux lignes (ou segments si checkSegmentsOnly=true). Renvoie undefined si les lignes sont parallèles, gauches, ou si les segments ne se chevauchent pas. Exemple : ligne1={start:[0,0,0], end:[10,0,0]}, ligne2={start:[5,-5,0], end:[5,5,0]} → [5,0,0]",
    "line1": "ligne 1",
    "line2": "ligne 2",
    "checkSegmentsOnly": "vérifier les segments uniquement",
    "bitbybit.polyline.polylineToLines": "polyligne vers lignes",
    "polylineToLines": "polyligne vers lignes",
    "bitbybit.polyline.polylineToLines_description": "Convertit la polyligne en segments de ligne (chaque segment comme un objet ligne avec start/end). Les polylignes fermées incluent le segment de fermeture. Exemple : 3 points → 2 ou 3 lignes (selon isClosed)",
    "bitbybit.polyline.polylineToSegments": "polyligne vers segments",
    "polylineToSegments": "polyligne vers segments",
    "bitbybit.polyline.polylineToSegments_description": "Convertit la polyligne en tableaux de segments (chaque segment comme [point1, point2]). Les polylignes fermées incluent le segment de fermeture si les points d'extrémité diffèrent. Exemple : 4 points, fermé → 4 segments reliant tous les points dans une boucle",
    "bitbybit.polyline.polylineSelfIntersection": "auto-intersection de polyligne",
    "polylineSelfIntersection": "auto-intersection de polyligne",
    "bitbybit.polyline.polylineSelfIntersection_description": "Trouve les points où la polyligne se croise elle-même (points d'auto-intersection). Ignore les segments adjacents et déduplique les points proches. Exemple : polyligne en forme de 8 → renvoie le point de croisement central",
    "bitbybit.polyline.twoPolylineIntersection": "intersection de deux polylignes",
    "twoPolylineIntersection": "intersection de deux polylignes",
    "bitbybit.polyline.twoPolylineIntersection_description": "Trouve les points d'intersection entre deux polylignes (tous les croisements segment-segment). Teste toutes les paires de segments et déduplique les points proches. Exemple : polylignes se croisant formant un X → renvoie le point d'intersection central",
    "polyline1": "polyligne 1",
    "polyline2": "polyligne 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdiviser en fils hexagonaux",
    "subdivideToHexagonWires": "subdiviser en fils hexagonaux",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivise une face en fils hexagonaux",
    "extendUUp": "étendre U haut",
    "extendUBottom": "étendre U bas",
    "extendVUp": "étendre V haut",
    "extendVBottom": "étendre V bas",
    "nrHexagonsInHeight": "nb hexagones hauteur",
    "nrHexagonsInWidth": "nb hexagones largeur",
    "bitbybit.vector.length": "longueur du vecteur",
    "bitbybit.vector.length_description": "Calcule la longueur (grandeur) d'un vecteur 3D. Exemple : [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.point.maxFilletRadius": "rayon de congé maximal",
    "maxFilletRadius": "rayon de congé maximal",
    "bitbybit.point.maxFilletRadius_description": "Calcule le rayon de congé maximal possible à un coin formé par deux segments de ligne partageant une extrémité (C), de sorte que l'arc de congé soit tangent aux deux segments et se situe entièrement à l'intérieur de ceux-ci.",
    "bitbybit.point.maxFilletRadiusHalfLine": "rayon de congé maximal demi-ligne",
    "maxFilletRadiusHalfLine": "rayon de congé maximal demi-ligne",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calcule le rayon de congé maximal possible à un coin C, de sorte que l'arc de congé soit tangent aux deux segments (P1-C, P2-C) et que les points tangents se situent dans la première moitié de chaque segment (mesurée à partir de C).",
    "bitbybit.point.maxFilletsHalfLine": "congés maximaux demi-ligne",
    "maxFilletsHalfLine": "congés maximaux demi-ligne",
    "bitbybit.point.maxFilletsHalfLine_description": "Calcule le rayon de congé maximal possible à chaque coin d'une polyligne formée par une série de points. Le rayon de congé est calculé pour chaque coin interne et éventuellement pour les coins de fermeture si la polyligne est fermée.",
    "checkLastWithFirst": "vérifier dernier avec premier",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "rayon de congé maximal le plus sûr (points, demi-ligne)",
    "safestPointsMaxFilletHalfLine": "rayon de congé maximal le plus sûr (points, demi-ligne)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calcule le rayon de congé maximal le plus sûr unique qui peut être appliqué uniformément à tous les coins d'une collection de points, basé sur la contrainte 'demi-ligne'. Ceci est déterminé en trouvant le minimum des rayons de congé maximaux possibles calculés pour chaque coin individuel.",
    "bitbybit.polyline.maxFilletsHalfLine": "congés maximaux demi-ligne",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calcule le rayon de congé maximal possible 'demi-ligne' pour chaque coin d'une polyligne donnée. Pour une polyligne fermée, il inclut les coins reliant le dernier segment au premier. Le calcul utilise la contrainte 'demi-ligne', ce qui signifie que les points tangents du congé doivent se situer dans la première moitié de chaque segment connecté au coin.",
    "bitbybit.polyline.safestFilletRadius": "rayon de congé le plus sûr",
    "safestFilletRadius": "rayon de congé le plus sûr",
    "bitbybit.polyline.safestFilletRadius_description": "Calcule le rayon de congé maximal le plus sûr unique qui peut être appliqué uniformément à tous les coins d'une polyligne, basé sur la contrainte 'demi-ligne'. Ceci est déterminé en trouvant le minimum des rayons de congé maximaux possibles calculés pour chaque coin individuel.",
    "flatTop": "sommet plat",
    "bitbybit.mesh.meshMeshIntersectionPoints": "points d'intersection maillage-maillage",
    "meshMeshIntersectionPoints": "points d'intersection maillage-maillage",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calcule les points d'intersection entre deux maillages sous forme de tableaux de points (un tableau par polyligne). Les polylignes fermées ont le premier point dupliqué à la fin. Exemple : intersection cube-sphère → tableaux de points définissant les courbes d'intersection",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexagones dans la grille",
    "hexagonsInGrid": "hexagones dans la grille",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Crée des fils hexagonaux OpenCascade dans une grille",
    "scalePatternWidth": "échelle largeur motif",
    "scalePatternHeight": "échelle hauteur motif",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "fils d'intersection maillage-maillage",
    "meshMeshIntersectionWires": "fils d'intersection maillage-maillage",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Effectue une opération d'intersection maillage-maillage entre deux formes - les deux formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les fils de l'intersection, qui sont des polylignes ou des polygones.",
    "mesh based": "basé sur maillage",
    "precision1": "précision 1",
    "precision2": "précision 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "points d'intersection maillage-maillage",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Effectue une opération d'intersection maillage-maillage entre deux formes - les deux formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les points de l'intersection.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "intersection maillage-maillage vers fils",
    "meshMeshIntersectionOfShapesWires": "intersection maillage-maillage vers fils",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Effectue une opération d'intersection maillage-maillage entre la forme et plusieurs autres formes - toutes les formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les fils de l'intersection, qui sont des polylignes ou des polygones.",
    "precisionShapes": "précision formes",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "intersection maillage-maillage vers points",
    "meshMeshIntersectionOfShapesPoints": "intersection maillage-maillage vers points",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Effectue une opération d'intersection maillage-maillage entre la forme et plusieurs autres formes - toutes les formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les points de l'intersection.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexagones dans la grille",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Crée des hexagones OpenCascade dans une grille (faces)",
    "bitbybit.jscad.toPolygonPoints": "vers points de polygone",
    "toPolygonPoints": "vers points de polygone",
    "bitbybit.jscad.toPolygonPoints_description": "Convertit le maillage Jscad en points de polygone représentant les triangles du maillage.",
    "conversions": "conversions",
    "bitbybit.manifold.toPolygonPoints": "vers points de polygone",
    "bitbybit.manifold.toPolygonPoints_description": "Transforme la forme manifold en une collection de points de polygone représentant le maillage.",
    "flatU": "plat U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdiviser en trous hexagonaux",
    "subdivideToHexagonHoles": "subdiviser en trous hexagonaux",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivise une face en trous hexagonaux",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "convertir les lignes en courbes NURBS",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Convertit les lignes en courbes NURBS. Renvoie un tableau d'objets verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "convertir une ligne en courbe NURBS",
    "convertLineToNurbsCurve": "convertir une ligne en courbe NURBS",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Convertit une ligne en courbe NURBS. Renvoie l'objet verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "convertir une polyligne en courbe NURBS",
    "convertPolylineToNurbsCurve": "convertir une polyligne en courbe NURBS",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Convertit une polyligne en courbe NURBS. Renvoie l'objet verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "convertir les polylignes en courbes NURBS",
    "convertPolylinesToNurbsCurves": "convertir les polylignes en courbes NURBS",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Convertit les polylignes en courbes NURBS. Renvoie les objets verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segment",
    "createSegment": "segment",
    "bitbybit.line.createSegment_description": "Crée un segment à partir de deux points (format tableau : [start, end]). Exemple : start=[0,0,0], end=[10,5,0] → [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "arête depuis ligne de base",
    "fromBaseLine": "depuis ligne de base",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Crée une arête linéaire à partir du format de ligne de base {start: Point3, end: Point3}",
    "from base": "depuis base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "arête depuis lignes de base",
    "fromBaseLines": "depuis lignes de base",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Crée des arêtes linéaires à partir du format de lignes de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "arête depuis segment de base",
    "fromBaseSegment": "depuis segment de base",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Crée une arête linéaire à partir du format de segment de base [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "arêtes depuis segments de base",
    "fromBaseSegments": "depuis segments de base",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Crée une arête linéaire à partir du format de segments de base [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "arêtes depuis points",
    "fromPoints": "depuis points",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Crée des arêtes linéaires à partir d'une collection de points",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "arêtes depuis polyligne de base",
    "fromBasePolyline": "depuis polyligne de base",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Crée des arêtes linéaires à partir de la définition de la polyligne",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "arêtes depuis triangle de base",
    "fromBaseTriangle": "depuis triangle de base",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Crée des arêtes linéaires à partir de la définition du triangle",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "arêtes depuis maillage de base",
    "fromBaseMesh": "depuis maillage de base",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Crée des arêtes linéaires à partir de la définition du maillage",
    "bitbybit.occt.shapes.wire.fromBaseLine": "fil depuis ligne de base",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Crée un fil linéaire à partir du format de ligne de base {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "fils depuis lignes de base",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Crée des fils linéaires à partir du format de lignes de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "fil depuis segment de base",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Crée un fil linéaire à partir du format de segment de base [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "fils depuis segments de base",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Crée des fils linéaires à partir du format de segments de base [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "fil depuis points",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Crée un fil à partir d'une collection de points",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "fil depuis polyligne de base",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Crée un fil à partir de la définition de la polyligne",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "fil depuis triangle de base",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Crée un fil à partir de la définition du triangle",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "fils depuis maillage de base",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Crée des fils à partir de la définition du maillage",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "face depuis triangle de base",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Crée une face à partir de la définition du triangle",
    "bitbybit.occt.shapes.face.fromBaseMesh": "faces depuis maillage de base",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Crée des faces à partir de la définition du maillage",
    "fromRightHanded": "depuis droitier",
    "bitbybit.advanced.text3d.createWithUrl": "texte avec url",
    "createWithUrl": "texte avec url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Crée un texte 3d avec une URL de police. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3d. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "fontUrl": "url de la police",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "texte sur face url",
    "createTextOnFaceUrl": "texte sur face url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Crée un texte 3D sur la face à l'aide d'une URL de police. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3D. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "textes sur face url",
    "createTextsOnFaceUrl": "textes sur face url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Crée des textes 3d sur la face à partir de plusieurs définitions d'url. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3d. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "définition texte 3d sur face url",
    "definition3dTextOnFaceUrl": "définition texte 3d sur face url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Crée du texte 3d qui sera utilisé sur la définition d'url de la face. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3d. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "bitbybit.advanced.navigation.pointOfInterest": "point d'intérêt",
    "navigation": "navigation",
    "pointOfInterest": "point d'intérêt",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Crée un point d'intérêt - indicateur cliquable dans l'espace 3D qui peut être utilisé pour faire voler la caméra vers un emplacement spécifique avec une position et une cible de caméra prédéfinies. Le point d'intérêt peut être stylisé avec PointOfInterestStyleDto et animé avec un effet d'impulsion. Le point d'intérêt peut également avoir une étiquette textuelle.",
    "cameraTarget": "cible de la caméra",
    "cameraPosition": "position de la caméra",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "système de points d'intérêt",
    "pointsOfInterestSystem": "système de points d'intérêt",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "points d'intérêt",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "point d'intérêt",
    "style": "style",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "style de point d'intérêt",
    "pointOfInterestStyle": "style de point d'intérêt",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Créer un style de point d'intérêt - utilisé pour styliser les indicateurs de points d'intérêt dans l'espace 3D. Vous pouvez personnaliser la taille du point, la couleur, la couleur au survol, l'effet de pulsation, la couleur et la taille de l'étiquette de texte.",
    "pointSize": "taille du point",
    "pointColor": "couleur du point",
    "hoverPointColor": "couleur du point au survol",
    "pulseColor": "couleur de la pulsation",
    "hoverPulseColor": "couleur de la pulsation au survol",
    "pulseMinSize": "taille min de la pulsation",
    "pulseMaxSize": "taille max de la pulsation",
    "pulseThickness": "épaisseur de la pulsation",
    "pulseSpeed": "vitesse de la pulsation",
    "textColor": "couleur du texte",
    "hoverTextColor": "couleur du texte au survol",
    "textSize": "taille du texte",
    "hideSkybox": "masquer la skybox",
    "textureUrl": "URL de la texture",
    "hdrTexture": "texture HDR",
    "textureSize": "taille de la texture",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "activer la texture personnalisée de la skybox",
    "enableSkyboxCustomTexture": "activer la texture personnalisée de la skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Active la skybox avec une texture personnalisée",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "image de fond CSS du canvas",
    "canvasCSSBackgroundImage": "image de fond CSS du canvas",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Change l'arrière-plan de la scène en image de fond CSS pour l'espace 3D",
    "cssBackgroundImage": "image de fond CSS",
    "bitbybit.babylon.scene.twoColorLinearGradient": "dégradé linéaire à deux couleurs",
    "twoColorLinearGradient": "dégradé linéaire à deux couleurs",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Crée un arrière-plan dégradé linéaire à deux couleurs pour l'espace 3D",
    "colorFrom": "couleur de départ",
    "colorTo": "couleur d'arrivée",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "arrêt de départ",
    "stopTo": "arrêt d'arrivée",
    "bitbybit.babylon.scene.twoColorRadialGradient": "dégradé radial à deux couleurs",
    "twoColorRadialGradient": "dégradé radial à deux couleurs",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Crée un arrière-plan dégradé radial à deux couleurs pour l'espace 3D",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "dégradé linéaire multicolore",
    "multiColorLinearGradient": "dégradé linéaire multicolore",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Crée un arrière-plan dégradé linéaire multicolore pour l'espace 3D",
    "Base.Color[]": "Base.Color[]",
    "stops": "arrêts",
    "bitbybit.babylon.scene.multiColorRadialGradient": "dégradé radial multicolore",
    "multiColorRadialGradient": "dégradé radial multicolore",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Crée un arrière-plan dégradé radial multicolore pour l'espace 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "image de fond du canvas",
    "canvasBackgroundImage": "image de fond du canvas",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Définit une image de fond avec diverses options de personnalisation pour l'espace 3D",
    "imageUrl": "URL de l'image",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "attachement",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "découpage",
    "labelRotation": "rotation de l'étiquette",
    "bitbybit.advanced.dimensions.linearDimension": "dimension linéaire",
    "linearDimension": "dimension linéaire",
    "bitbybit.advanced.dimensions.linearDimension_description": "Crée une dimension linéaire - une ligne de mesure entre deux points avec des lignes d'extension et une étiquette de texte. La dimension montre la distance entre les points et peut être stylisée avec DimensionStyleDto.",
    "linear dimension": "dimension linéaire",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "dimension angulaire",
    "angularDimension": "dimension angulaire",
    "bitbybit.advanced.dimensions.angularDimension_description": "Crée une dimension angulaire - un arc de mesure entre deux vecteurs de direction avec des lignes d'extension et une étiquette de texte. La dimension montre l'angle entre les directions et peut être stylisée avec DimensionStyleDto.",
    "angular dimension": "dimension angulaire",
    "centerPoint": "point central",
    "bitbybit.advanced.dimensions.dimensionStyle": "style de dimension",
    "dimensionStyle": "style de dimension",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Créer un style de dimension - utilisé pour styliser les lignes de dimension, les flèches et le texte dans l'espace 3D. Vous pouvez personnaliser les couleurs de ligne, l'épaisseur, la taille du texte, la taille des flèches et les couleurs d'arrière-plan.",
    "dimension style": "style de dimension",
    "lineColor": "couleur de ligne",
    "lineThickness": "épaisseur de ligne",
    "extensionLineLength": "longueur de ligne d'extension",
    "textBackgroundColor": "couleur d'arrière-plan du texte",
    "textBackgroundOpacity": "opacité d'arrière-plan du texte",
    "arrowSize": "taille de flèche",
    "arrowColor": "couleur de flèche",
    "textRenderMode": "mode de rendu du texte",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "panneau de texte",
    "occlusionCheckInterval": "intervalle de vérification d'occlusion",
    "arrowTailLength": "longueur de queue de flèche",
    "showArrows": "afficher les flèches",
    "labelOverwrite": "écraser l'étiquette",
    "bitbybit.advanced.dimensions.radialDimension": "dimension radiale",
    "radialDimension": "dimension radiale",
    "bitbybit.advanced.dimensions.radialDimension_description": "Crée une dimension radiale - une ligne de mesure du centre au périmètre montrant le rayon ou le diamètre. Affiche le préfixe 'R' pour le rayon ou le préfixe '⌀' pour le diamètre avec une marque centrale optionnelle.",
    "radial dimension": "dimension radiale",
    "radiusPoint": "point de rayon",
    "showDiameter": "afficher le diamètre",
    "showCenterMark": "afficher la marque centrale",
    "bitbybit.advanced.dimensions.diametralDimension": "dimension diamétrale",
    "diametralDimension": "dimension diamétrale",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Crée une dimension diamétrale - une ligne de mesure couvrant le diamètre complet des caractéristiques circulaires. Affiche le préfixe '⌀' avec une marque centrale optionnelle et des flèches aux deux extrémités.",
    "diametral dimension": "dimension diamétrale",
    "bitbybit.advanced.dimensions.ordinateDimension": "dimension d'ordonnée",
    "ordinateDimension": "dimension d'ordonnée",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Crée une dimension d'ordonnée - affiche la coordonnée X, Y ou Z à partir d'un point de référence avec une ligne de repère. Utile pour les annotations de coordonnées et le référencement de données dans les dessins techniques.",
    "ordinate dimension": "dimension d'ordonnée",
    "measurementPoint": "point de mesure",
    "referencePoint": "point de référence",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "afficher la ligne de repère",
    "viewMode": "mode d'affichage",
    "schema": "schéma",
    "json schema": "schéma JSON",
    "metadata": "métadonnées",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "arrière-plan dégradé linéaire deux couleurs",
    "twoColorLinearGradientBackground": "arrière-plan dégradé linéaire deux couleurs",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Crée un arrière-plan dégradé linéaire deux couleurs pour l'espace 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "arrière-plan dégradé radial deux couleurs",
    "twoColorRadialGradientBackground": "arrière-plan dégradé radial deux couleurs",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Crée un arrière-plan dégradé radial deux couleurs pour l'espace 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "arrière-plan dégradé linéaire multicolore",
    "multiColorLinearGradientBackground": "arrière-plan dégradé linéaire multicolore",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Crée un arrière-plan dégradé linéaire multicolore pour l'espace 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "arrière-plan dégradé radial multicolore",
    "multiColorRadialGradientBackground": "arrière-plan dégradé radial multicolore",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Crée un arrière-plan dégradé radial multicolore pour l'espace 3D",
    "textBackgroundStroke": "contour d'arrière-plan de texte",
    "textBackgroundRadius": "rayon d'arrière-plan de texte",
    "stableSize": "taille stable",
    "alwaysOnTop": "toujours au premier plan",
    "textStableSize": "taille de texte stable",
    "bitbybit.occt.io.shapeToDxfPaths": "forme vers chemins DXF",
    "shapeToDxfPaths": "forme vers chemins DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Crée des chemins DXF à partir d'une forme OCCT Important - les formes contenant des fils doivent reposer sur le plan XZ (Y=0) pour une exportation DXF 2D correcte.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "chemins DXF avec calque",
    "dxfPathsWithLayer": "chemins DXF avec calque",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Ajoute des informations de calque et de couleur aux chemins DXF Important - les formes contenant des fils doivent reposer sur le plan XZ (Y=0) pour une exportation DXF 2D correcte.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "calque",
    "bitbybit.occt.io.dxfCreate": "créer DXF",
    "dxfCreate": "créer DXF",
    "bitbybit.occt.io.dxfCreate_description": "Assemble plusieurs parties de chemin dans un fichier DXF complet",
    "pathsParts": "parties de chemins",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "graisse de police de texte",
    "textPosition": "position du texte",
    "textBackgroundStrokeThickness": "épaisseur du trait",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Effacer",
    "recompute": "Recalculer",
    "clear tooltip": "Effacer tous les caches et composants",
    "recompute tooltip": "Efface le cache et recalcule",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "fil de profil de poutre I",
    "createIBeamProfileWire": "fil de profil de poutre I",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Crée un fil de profil de poutre I OpenCascade",
    "beam profiles": "profils de poutres",
    "webThickness": "épaisseur de l'âme",
    "flangeThickness": "épaisseur de la semelle",
    "alignment": "alignement",
    "Base.basicAlignmentEnum": "Base.basicAlignmentEnum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "fil de profil de poutre H",
    "createHBeamProfileWire": "fil de profil de poutre H",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Crée un fil de profil de poutre H OpenCascade",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "fil de profil de poutre T",
    "createTBeamProfileWire": "fil de profil de poutre T",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Crée un fil de profil de poutre T OpenCascade",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "fil de profil de poutre U",
    "createUBeamProfileWire": "fil de profil de poutre U",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Crée un fil de profil de poutre U OpenCascade",
    "flangeWidth": "largeur de la semelle",
    "bitbybit.occt.shapes.face.createLPolygonFace": "face de polygone L",
    "createLPolygonFace": "face de polygone L",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Crée une face de polygone L OpenCascade",
    "bitbybit.occt.shapes.face.createStarFace": "face d'étoile",
    "createStarFace": "face d'étoile",
    "bitbybit.occt.shapes.face.createStarFace_description": "Crée une face d'étoile OpenCascade",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "face de sapin de Noël",
    "createChristmasTreeFace": "face de sapin de Noël",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Crée une face de sapin de Noël OpenCascade",
    "bitbybit.occt.shapes.face.createParallelogramFace": "face de parallélogramme",
    "createParallelogramFace": "face de parallélogramme",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Crée une face de parallélogramme OpenCascade",
    "bitbybit.occt.shapes.face.createHeartFace": "face de cœur",
    "createHeartFace": "face de cœur",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Crée une face de cœur OpenCascade",
    "bitbybit.occt.shapes.face.createNGonFace": "face de n-gone",
    "createNGonFace": "face de n-gone",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Crée une face de n-gone OpenCascade",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "face de profil de poutre I",
    "createIBeamProfileFace": "face de profil de poutre I",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Crée une face de profil de poutre I OpenCascade",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "face de profil de poutre H",
    "createHBeamProfileFace": "face de profil de poutre H",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Crée une face de profil de poutre H OpenCascade",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "face de profil de poutre T",
    "createTBeamProfileFace": "face de profil de poutre T",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Crée une face de profil de poutre T OpenCascade",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "face de profil de poutre U",
    "createUBeamProfileFace": "face de profil de poutre U",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Crée une face de profil de poutre U OpenCascade",
    "bitbybit.occt.shapes.solid.createStarSolid": "solide d'étoile",
    "createStarSolid": "solide d'étoile",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Crée un solide d'étoile OpenCascade",
    "extrusionLengthFront": "longueur d'extrusion avant",
    "extrusionLengthBack": "longueur d'extrusion arrière",
    "bitbybit.occt.shapes.solid.createNGonSolid": "solide de n-gone",
    "createNGonSolid": "solide de n-gone",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Crée un solide de n-gone OpenCascade",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "solide de parallélogramme",
    "createParallelogramSolid": "solide de parallélogramme",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Crée un solide de parallélogramme OpenCascade",
    "bitbybit.occt.shapes.solid.createHeartSolid": "solide de cœur",
    "createHeartSolid": "solide de cœur",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Crée un solide de cœur OpenCascade",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "solide de sapin de Noël",
    "createChristmasTreeSolid": "solide de sapin de Noël",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Crée un solide de sapin de Noël OpenCascade",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "solide de polygone L",
    "createLPolygonSolid": "solide de polygone L",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Crée un solide de polygone L OpenCascade",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "solide de profil de poutre I",
    "createIBeamProfileSolid": "solide de profil de poutre I",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Crée un solide de profil de poutre I OpenCascade",
    "beam": "poutre",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "solide de profil de poutre H",
    "createHBeamProfileSolid": "solide de profil de poutre H",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Crée un solide de profil de poutre H OpenCascade",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "solide de profil de poutre T",
    "createTBeamProfileSolid": "solide de profil de poutre T",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Crée un solide de profil de poutre T OpenCascade",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "solide de profil de poutre U",
    "createUBeamProfileSolid": "solide de profil de poutre U",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Crée un solide de profil de poutre U OpenCascade",
    "endType": "type d'extrémité",
    "dimensionEndTypeEnum": "dimensionEndTypeEnum",
    "arrowAngle": "angle de flèche",
    "arrowsFlipped": "flèches inversées",
    "colorFormat": "format de couleur",
    "dxfColorFormatEnum": "dxfColorFormatEnum",
    "acadVersion": "version acad",
    "dxfAcadVersionEnum": "dxfAcadVersionEnum",
    "bitbybit.advanced.navigation.zoomOn": "zoomer sur",
    "zoomOn": "zoomer sur",
    "bitbybit.advanced.navigation.zoomOn_description": "Zoome la caméra pour ajuster les maillages spécifiés dans la scène avec animation fluide. Fonctionne uniquement avec ArcRotateCamera. L'animation peut être interrompue si appelée plusieurs fois.",
    "animationSpeed": "vitesse d'animation",
    "doNotUpdateMaxZ": "ne pas mettre à jour max z",
    "bitbybit.advanced.navigation.focusFromAngle": "focaliser depuis angle",
    "focusFromAngle": "focaliser depuis angle",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Focalise la caméra sur les maillages spécifiés depuis un angle spécifique avec animation fluide. Calcule le centre de la boîte englobante de tous les maillages et positionne la caméra au vecteur d'orientation spécifié pour regarder le centre. Fonctionne uniquement avec ArcRotateCamera. L'animation peut être interrompue si appelée plusieurs fois.",
    "padding": "espacement",
    "shadowRefreshRate": "Taux de rafraîchissement de l'ombre",
    "labelFlipHorizontal": "Retourner l'étiquette horizontalement",
    "labelFlipVertical": "Retourner l'étiquette verticalement",
    "bitbybit.advanced.navigation.zoomOnAspect": "Zoom sur l'aspect",
    "zoomOnAspect": "Zoom sur l'aspect",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Zoome la caméra pour ajuster les maillages spécifiés dans la scène avec une animation fluide, en tenant compte du rapport d'aspect exact de l'écran. Contrairement à zoomOn, cette méthode calcule précisément la distance de la caméra en fonction des dimensions de la fenêtre d'affichage et de la boîte englobante du maillage pour assurer un meilleur ajustement à padding=0. Fonctionne uniquement avec ArcRotateCamera. L'animation peut être interrompue si appelée plusieurs fois.",
    "bitbybit.vector.parseNumbers": "analyser les nombres",
    "parseNumbers": "analyser les nombres",
    "bitbybit.vector.parseNumbers_description": "Convertit un tableau de nombres sous forme de chaîne en nombres réels. Exemple : ['1', '2.5', '3'] → [1, 2.5, 3], ['10', '-5', '0.1'] → [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "simplifier",
    "bitbybit.manifold.manifold.operations.simplify_description": "Renvoie une copie du manifold simplifiée selon la tolérance donnée, mais avec sa valeur de tolérance réelle inchangée. Le résultat contiendra un sous-ensemble des sommets d'origine et toutes les surfaces se seront déplacées de moins que la tolérance.",
    "bitbybit.manifold.manifold.operations.setProperties": "définir les propriétés",
    "setProperties": "définir les propriétés",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Crée une nouvelle copie de ce manifold avec des propriétés de sommet mises à jour en fournissant une fonction qui prend la position existante et les propriétés en entrée. Vous pouvez spécifier n'importe quel nombre de propriétés de sortie, permettant la création et la suppression de canaux. Remarque : un comportement indéfini résultera si vous lisez au-delà du nombre de propriétés d'entrée ou écrivez au-delà du nombre de propriétés de sortie.",
    "propFunc": "fonction de propriété",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "déformer",
    "warp": "déformer",
    "bitbybit.manifold.manifold.transforms.warp_description": "Déplace les sommets de ce Manifold (en en créant un nouveau) selon n'importe quelle fonction d'entrée arbitraire. Il est facile de créer une fonction qui déforme un objet géométriquement valide en un objet qui se chevauche, mais cela n'est pas vérifié ici, c'est donc à l'utilisateur de choisir sa fonction avec discernement.",
    "warpFunc": "fonction de déformation",
    "(vert: Base.Vector3) => void": "(vert: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "statut",
    "status": "statut",
    "bitbybit.manifold.manifold.evaluate.status_description": "Renvoie la raison pour laquelle un maillage d'entrée produit un Manifold vide. Ce statut sera conservé lors d'opérations telles que la propagation de NaN, garantissant qu'un maillage erroné ne soit pas mystérieusement perdu. Les maillages vides peuvent toujours afficher NoError, par exemple l'intersection de maillages qui ne se chevauchent pas.",
    "bitbybit.manifold.crossSection.transforms.warp": "déformer",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Déplace les sommets de cette section transversale (en en créant une nouvelle) selon n'importe quelle fonction d'entrée arbitraire, suivie d'une opération d'union (avec une règle de remplissage Positive) qui garantit que toute intersection introduite n'est pas incluse dans le résultat.",
    "(vert: Base.Vector2) => void": "(vert: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "arrondir et supprimer les zéros de fin",
    "roundAndRemoveTrailingZeros": "arrondir et supprimer les zéros de fin",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Arrondit un nombre aux décimales spécifiées et supprime les zéros de fin. Exemple : 1.32156 avec 3 décimales renvoie 1.322, mais 1.320000001 renvoie 1.32, et 1.000 renvoie 1",
    "bitbybit.math.clamp": "limiter (clamp)",
    "clamp": "limiter (clamp)",
    "bitbybit.math.clamp_description": "Contraint une valeur entre une valeur minimale et une valeur maximale. Exemple : clamp(5, 0, 3) renvoie 3, clamp(-1, 0, 3) renvoie 0, clamp(1.5, 0, 3) renvoie 1.5",
    "bitbybit.math.lerp": "lerp",
    "bitbybit.math.lerp_description": "Interpolation linéaire entre deux valeurs utilisant le paramètre t (0 à 1). Exemple : De 0 à 100 à t=0.5 → 50, De 10 à 20 à t=0.25 → 12.5. Quand t=0 renvoie le début, quand t=1 renvoie la fin. Utile pour des transitions fluides.",
    "t": "t",
    "bitbybit.math.inverseLerp": "lerp inverse",
    "inverseLerp": "lerp inverse",
    "bitbybit.math.inverseLerp_description": "Calcule le paramètre d'interpolation t pour une valeur entre début et fin (inverse de lerp). Exemple : Valeur 5 dans la plage [0,10] → t=0.5, Valeur 2.5 dans la plage [0,10] → t=0.25. Renvoie quelle valeur t produirait la valeur donnée dans un lerp. Utile pour trouver la position relative.",
    "bitbybit.math.smoothstep": "lissage (smoothstep)",
    "smoothstep": "lissage (smoothstep)",
    "bitbybit.math.smoothstep_description": "Interpolation Hermite avec accélération et décélération douces (plus doux que lerp linéaire). Exemple : x=0 → 0, x=0.5 → 0.5, x=1 → 1 (mais avec une courbe en S douce entre les deux). L'entrée est automatiquement limitée à [0,1]. La sortie entre et sort en douceur. Idéal pour les animations.",
    "bitbybit.math.sign": "signe",
    "sign": "signe",
    "bitbybit.math.sign_description": "Renvoie le signe d'un nombre : -1 pour négatif, 0 pour zéro, 1 pour positif. Exemple : -5 → -1, 0 → 0, 3.14 → 1. Utile pour déterminer la direction ou la polarité.",
    "bitbybit.math.fract": "partie fractionnaire",
    "fract": "partie fractionnaire",
    "bitbybit.math.fract_description": "Renvoie la partie fractionnaire d'un nombre (supprime la partie entière, garde les décimales). Exemple : 3.14 → 0.14, 5.9 → 0.9, -2.3 → 0.7. Utile pour enrouler les valeurs et créer des motifs répétitifs.",
    "bitbybit.math.wrap": "enrouler (wrap)",
    "bitbybit.math.wrap_description": "Enroule un nombre dans une plage spécifiée (crée un cycle répétitif). Exemple : 1.5 dans la plage [0,1) → 0.5, -0.3 dans la plage [0,1) → 0.7, 370° dans la plage [0,360) → 10°. Utile pour les angles, les UV ou tout domaine répétitif. Comme le modulo mais gère correctement les négatifs.",
    "bitbybit.math.pingPong": "ping-pong",
    "pingPong": "ping-pong",
    "bitbybit.math.pingPong_description": "Crée un effet de ping-pong (aller-retour) qui fait rebondir une valeur entre 0 et la longueur. La valeur va de 0→longueur, puis revient longueur→0, répétant ce cycle. Exemple : Avec longueur=1 : t=0→0, t=0.5→0.5, t=1→1 (pic), t=1.5→0.5, t=2→0, t=2.5→0.5 (répète). Utile pour créer des animations rebondissantes comme une balle ou un mouvement oscillant.",
    "bitbybit.math.moveTowards": "déplacer vers",
    "moveTowards": "déplacer vers",
    "bitbybit.math.moveTowards_description": "Déplace une valeur vers une cible d'une quantité delta maximale (sans dépassement). Exemple : De 0 vers 10 par max 3 → 3, De 8 vers 10 par max 3 → 10 (atteint). Utile pour un mouvement fluide avec des limites de vitesse maximale.",
    "current": "actuel",
    "maxDelta": "delta max",
    "bitbybit.lists.getFirstItem": "obtenir le premier élément",
    "getFirstItem": "obtenir le premier élément",
    "bitbybit.lists.getFirstItem_description": "Obtient le premier élément de la liste. Exemple : De [10, 20, 30, 40], renvoie 10",
    "bitbybit.lists.getLastItem": "obtenir le dernier élément",
    "getLastItem": "obtenir le dernier élément",
    "bitbybit.lists.getLastItem_description": "Obtient le dernier élément de la liste. Exemple : De [10, 20, 30, 40], renvoie 40",
    "bitbybit.lists.shuffle": "mélanger",
    "shuffle": "mélanger",
    "bitbybit.lists.shuffle_description": "Réorganise aléatoirement tous les éléments de la liste (en utilisant l'algorithme de Fisher-Yates). Exemple : De [1, 2, 3, 4, 5], pourrait renvoyer [3, 1, 5, 2, 4] (l'ordre varie à chaque fois)",
    "bitbybit.lists.includes": "inclut",
    "includes": "inclut",
    "bitbybit.lists.includes_description": "Vérifie si la liste contient un élément spécifique. Exemple : Liste [10, 20, 30, 40] avec l'élément 30 renvoie true, avec l'élément 50 renvoie false",
    "bitbybit.lists.findIndex": "trouver l'index",
    "findIndex": "trouver l'index",
    "bitbybit.lists.findIndex_description": "Trouve la position (index) de la première occurrence d'un élément dans la liste. Exemple : Dans [10, 20, 30, 20, 40], trouver 20 renvoie 1 (première occurrence), trouver 50 renvoie -1 (non trouvé)",
    "bitbybit.lists.removeFirstItem": "supprimer le premier élément",
    "removeFirstItem": "supprimer le premier élément",
    "bitbybit.lists.removeFirstItem_description": "Supprime le premier élément de la liste. Exemple : De [10, 20, 30, 40], renvoie [20, 30, 40]",
    "bitbybit.lists.removeLastItem": "supprimer le dernier élément",
    "removeLastItem": "supprimer le dernier élément",
    "bitbybit.lists.removeLastItem_description": "Supprime le dernier élément de la liste. Exemple : De [10, 20, 30, 40], renvoie [10, 20, 30]",
    "bitbybit.lists.removeItemAtIndexFromEnd": "supprimer l'élément à l'index depuis la fin",
    "removeItemAtIndexFromEnd": "supprimer l'élément à l'index depuis la fin",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Supprime un élément en comptant depuis la fin de la liste (index 0 = dernier élément, 1 = avant-dernier, etc.). Exemple : De [10, 20, 30, 40, 50], supprimer l'index 1 depuis la fin donne [10, 20, 30, 50] (supprime 40)",
    "bitbybit.lists.removeDuplicates": "supprimer les doublons",
    "removeDuplicates": "supprimer les doublons",
    "bitbybit.lists.removeDuplicates_description": "Supprime les éléments en double de la liste en utilisant une comparaison d'égalité stricte (fonctionne avec n'importe quel type). Exemple : De ['a', 'b', 'c', 'a', 'd', 'b'], renvoie ['a', 'b', 'c', 'd']",
    "bitbybit.lists.concatenate": "concaténer",
    "concatenate": "concaténer",
    "bitbybit.lists.concatenate_description": "Combine plusieurs listes en une seule liste en les joignant bout à bout. Exemple : De [[1, 2], [3, 4], [5, 6]], renvoie [1, 2, 3, 4, 5, 6]",
    "bitbybit.lists.interleave": "entrelacer",
    "interleave": "entrelacer",
    "bitbybit.lists.interleave_description": "Combine plusieurs listes en alternant les éléments de chaque liste (premier de liste1, premier de liste2, deuxième de liste1, etc.). Exemple : De [[0, 1, 2], [3, 4, 5]], renvoie [0, 3, 1, 4, 2, 5]",
    "bitbybit.text.includes": "inclut",
    "bitbybit.text.includes_description": "Vérifie si le texte contient une chaîne de recherche. Exemple : texte='bonjour monde', recherche='monde' → true",
    "bitbybit.text.startsWith": "commence par",
    "startsWith": "commence par",
    "bitbybit.text.startsWith_description": "Vérifie si le texte commence par une chaîne de recherche. Exemple : texte='bonjour monde', recherche='bonjour' → true",
    "bitbybit.text.endsWith": "se termine par",
    "endsWith": "se termine par",
    "bitbybit.text.endsWith_description": "Vérifie si le texte se termine par une chaîne de recherche. Exemple : texte='bonjour monde', recherche='monde' → true",
    "bitbybit.text.indexOf": "index de",
    "indexOf": "index de",
    "bitbybit.text.indexOf_description": "Renvoie l'index de la première occurrence d'une chaîne de recherche. Exemple : texte='bonjour monde', recherche='monde' → 8",
    "bitbybit.text.lastIndexOf": "dernier index de",
    "lastIndexOf": "dernier index de",
    "bitbybit.text.lastIndexOf_description": "Renvoie l'index de la dernière occurrence d'une chaîne de recherche. Exemple : texte='bonjour monde bonjour', recherche='bonjour' → 14",
    "bitbybit.text.substring": "sous-chaîne",
    "substring": "sous-chaîne",
    "bitbybit.text.substring_description": "Extrait une section de texte entre deux index. Exemple : texte='bonjour monde', début=0, fin=7 → 'bonjour'",
    "bitbybit.text.slice": "trancher (slice)",
    "bitbybit.text.slice_description": "Extrait une section de texte et renvoie une nouvelle chaîne. Exemple : texte='bonjour monde', début=0, fin=7 → 'bonjour'",
    "bitbybit.text.charAt": "caractère à",
    "charAt": "caractère à",
    "bitbybit.text.charAt_description": "Renvoie le caractère à l'index spécifié. Exemple : texte='bonjour', index=1 → 'o'",
    "bitbybit.text.trim": "supprimer les espaces",
    "bitbybit.text.trim_description": "Supprime les espaces blancs aux deux extrémités du texte. Exemple : texte='  bonjour  ' → 'bonjour'",
    "bitbybit.text.trimStart": "supprimer les espaces au début",
    "trimStart": "supprimer les espaces au début",
    "bitbybit.text.trimStart_description": "Supprime les espaces blancs au début du texte. Exemple : texte='  bonjour  ' → 'bonjour  '",
    "bitbybit.text.trimEnd": "supprimer les espaces à la fin",
    "trimEnd": "supprimer les espaces à la fin",
    "bitbybit.text.trimEnd_description": "Supprime les espaces blancs à la fin du texte. Exemple : texte='  bonjour  ' → '  bonjour'",
    "bitbybit.text.padStart": "remplir au début",
    "padStart": "remplir au début",
    "bitbybit.text.padStart_description": "Remplit le texte depuis le début pour atteindre la longueur cible. Exemple : texte='x', longueur=3, padString='a' → 'aax'",
    "padString": "chaîne de remplissage",
    "bitbybit.text.padEnd": "remplir à la fin",
    "padEnd": "remplir à la fin",
    "bitbybit.text.padEnd_description": "Remplit le texte depuis la fin pour atteindre la longueur cible. Exemple : texte='x', longueur=3, padString='a' → 'xaa'",
    "bitbybit.text.toUpperCase": "en majuscules",
    "toUpperCase": "en majuscules",
    "bitbybit.text.toUpperCase_description": "Convertit le texte en majuscules. Exemple : texte='bonjour' → 'BONJOUR'",
    "bitbybit.text.toLowerCase": "en minuscules",
    "toLowerCase": "en minuscules",
    "bitbybit.text.toLowerCase_description": "Convertit le texte en minuscules. Exemple : texte='BONJOUR' → 'bonjour'",
    "bitbybit.text.toUpperCaseFirst": "première lettre majuscule",
    "toUpperCaseFirst": "première lettre majuscule",
    "bitbybit.text.toUpperCaseFirst_description": "Met en majuscule le premier caractère du texte. Exemple : texte='bonjour monde' → 'Bonjour monde'",
    "bitbybit.text.toLowerCaseFirst": "première lettre minuscule",
    "toLowerCaseFirst": "première lettre minuscule",
    "bitbybit.text.toLowerCaseFirst_description": "Met en minuscule le premier caractère du texte. Exemple : texte='Bonjour Monde' → 'bonjour Monde'",
    "bitbybit.text.repeat": "répéter",
    "bitbybit.text.repeat_description": "Répète le texte un nombre spécifié de fois. Exemple : texte='ha', nombre=3 → 'hahaha'",
    "bitbybit.text.reverse": "inverser",
    "bitbybit.text.reverse_description": "Inverse les caractères du texte. Exemple : texte='bonjour' → 'ruojnob'",
    "bitbybit.text.length": "longueur",
    "bitbybit.text.length_description": "Renvoie la longueur du texte. Exemple : texte='bonjour' → 7",
    "bitbybit.text.isEmpty": "est vide",
    "bitbybit.text.isEmpty_description": "Vérifie si le texte est vide ou ne contient que des espaces. Exemple : texte='   ' → true",
    "bitbybit.text.concat": "concaténer",
    "concat": "concaténer",
    "bitbybit.text.concat_description": "Concatène plusieurs chaînes de texte. Exemple : textes=['bonjour', ' ', 'monde'] → 'bonjour monde'",
    "texts": "textes",
    "bitbybit.text.regexTest": "test regex",
    "regexTest": "test regex",
    "bitbybit.text.regexTest_description": "Teste si le texte correspond à un motif d'expression régulière. Exemple : texte='bonjour123', motif='[0-9]+' → true",
    "regex": "regex",
    "flags": "drapeaux",
    "bitbybit.text.regexMatch": "correspondance regex",
    "regexMatch": "correspondance regex",
    "bitbybit.text.regexMatch_description": "Fait correspondre le texte à une expression régulière et renvoie les correspondances. Exemple : texte='bonjour123monde456', motif='[0-9]+', drapeaux='g' → ['123', '456']",
    "bitbybit.text.regexReplace": "remplacement regex",
    "regexReplace": "remplacement regex",
    "bitbybit.text.regexReplace_description": "Remplace le texte correspondant à un motif d'expression régulière. Exemple : texte='bonjour123monde456', motif='[0-9]+', drapeaux='g', remplacerPar='X' → 'bonjourXmondeX'",
    "bitbybit.text.regexSearch": "recherche regex",
    "regexSearch": "recherche regex",
    "bitbybit.text.regexSearch_description": "Recherche un motif d'expression régulière dans le texte et renvoie l'index. Exemple : texte='bonjour123', motif='[0-9]+' → 7",
    "bitbybit.text.regexSplit": "découpage regex",
    "regexSplit": "découpage regex",
    "bitbybit.text.regexSplit_description": "Divise le texte en utilisant un motif d'expression régulière. Exemple : texte='a1b2c3', motif='[0-9]+' → ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "analyser en tableau",
    "csv": "csv",
    "parseToArray": "analyser en tableau",
    "bitbybit.csv.parseToArray_description": "Analyse le texte CSV en un tableau 2D de chaînes (lignes et colonnes). Exemple : csv='a,b,c 1,2,3' → [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "séparateur de ligne",
    "columnSeparator": "séparateur de colonne",
    "bitbybit.csv.parseToJson": "analyser en json",
    "parseToJson": "analyser en json",
    "bitbybit.csv.parseToJson_description": "Analyse le texte CSV en un tableau d'objets JSON en utilisant les en-têtes. Exemple : csv='nom,age Jean,30 Jeanne,25', ligneEnTête=0, ligneDébutDonnées=1 → [{'nom':'Jean','age':'30'}, {'nom':'Jeanne','age':'25'}]",
    "headerRow": "ligne d'en-tête",
    "dataStartRow": "ligne de début des données",
    "numberColumns": "nombre de colonnes",
    "bitbybit.csv.parseToJsonWithHeaders": "analyser en json avec en-têtes",
    "parseToJsonWithHeaders": "analyser en json avec en-têtes",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Analyse le texte CSV en JSON en utilisant des en-têtes personnalisés (ignore les en-têtes CSV s'ils sont présents). Exemple : csv='Jean,30 Jeanne,25', enTêtes=['nom','age'] → [{'nom':'Jean','age':'30'}, {'nom':'Jeanne','age':'25'}]",
    "headers": "en-têtes",
    "bitbybit.csv.queryColumn": "interroger la colonne",
    "queryColumn": "interroger la colonne",
    "bitbybit.csv.queryColumn_description": "Interroge les données CSV par nom d'en-tête de colonne et renvoie toutes les valeurs de cette colonne. Exemple : csv='nom,age Jean,30 Jeanne,25', colonne='nom' → ['Jean', 'Jeanne']",
    "column": "colonne",
    "asNumber": "comme nombre",
    "bitbybit.csv.queryRowsByValue": "interroger les lignes par valeur",
    "queryRowsByValue": "interroger les lignes par valeur",
    "bitbybit.csv.queryRowsByValue_description": "Interroge les données CSV et filtre les lignes où une colonne correspond à une valeur. Exemple : csv='nom,age Jean,30 Jeanne,25', colonne='age', valeur='30' → [{'nom':'Jean','age':'30'}]",
    "bitbybit.csv.arrayToCsv": "tableau vers csv",
    "arrayToCsv": "tableau vers csv",
    "bitbybit.csv.arrayToCsv_description": "Convertit un tableau 2D en texte CSV. Exemple : tableau=[['nom','age'], ['Jean','30']] → 'nom,age Jean,30'",
    "array": "tableau",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "json vers csv",
    "jsonToCsv": "json vers csv",
    "bitbybit.csv.jsonToCsv_description": "Convertit un tableau d'objets JSON en texte CSV. Exemple : json=[{'nom':'Jean','age':'30'}], enTêtes=['nom','age'] → 'nom,age Jean,30'",
    "includeHeaders": "inclure les en-têtes",
    "bitbybit.csv.jsonToCsvAuto": "json vers csv auto",
    "jsonToCsvAuto": "json vers csv auto",
    "bitbybit.csv.jsonToCsvAuto_description": "Convertit un tableau d'objets JSON en texte CSV en utilisant les clés d'objet comme en-têtes. Exemple : json=[{'nom':'Jean','age':'30'}] → 'nom,age Jean,30'",
    "bitbybit.csv.getHeaders": "obtenir les en-têtes",
    "getHeaders": "obtenir les en-têtes",
    "bitbybit.csv.getHeaders_description": "Obtient les en-têtes d'un fichier CSV. Exemple : csv='nom,age Jean,30', ligneEnTête=0 → ['nom', 'age']",
    "bitbybit.csv.getRowCount": "obtenir le nombre de lignes",
    "getRowCount": "obtenir le nombre de lignes",
    "bitbybit.csv.getRowCount_description": "Obtient le nombre de lignes dans un fichier CSV (en excluant les en-têtes si spécifié). Exemple : csv='nom,age Jean,30 Jeanne,25', ligneEnTête=0 → 2",
    "hasHeaders": "a des en-têtes",
    "bitbybit.csv.getColumnCount": "obtenir le nombre de colonnes",
    "getColumnCount": "obtenir le nombre de colonnes",
    "bitbybit.csv.getColumnCount_description": "Obtient le nombre de colonnes dans un fichier CSV. Exemple : csv='nom,age,ville Jean,30,Paris' → 3",
    "removeTrailingZeros": "supprimer les zéros de fin",
    "bitbybit.asset.getTextFile": "obtenir le fichier texte",
    "getTextFile": "obtenir le fichier texte",
    "bitbybit.asset.getTextFile_description": "Obtient le texte du fichier d'actif stocké dans votre compte cloud.",
    "bitbybit.asset.getLocalTextFile": "obtenir le fichier texte local",
    "getLocalTextFile": "obtenir le fichier texte local",
    "bitbybit.asset.getLocalTextFile_description": "Obtient le texte du fichier d'actif stocké dans votre navigateur.",
    "bitbybit.asset.download": "télécharger",
    "bitbybit.asset.download_description": "Télécharge un fichier avec le contenu, l'extension et le type de contenu donnés.",
    "content": "contenu",
    "string | Blob": "string | Blob",
    "extension": "extension",
    "contentType": "type de contenu",
    "preview csv": "aperçu csv",
    "startRow": "ligne de départ",
    "maxRows": "nombre maximal de lignes",
    "colorMapStrategy": "stratégie de carte de couleurs",
    "Base.colorMapStrategyEnum": "Base.colorMapStrategyEnum",
    "drawTwoSided": "dessiner recto-verso",
    "backFaceColour": "couleur de la face arrière",
    "backFaceOpacity": "opacité de la face arrière",
    "edgeArrowSize": "taille de la flèche de bord",
    "edgeArrowAngle": "angle de la flèche de bord",
    "bitbybit.draw.createTexture": "créer une texture",
    "createTexture": "créer une texture",
    "bitbybit.draw.createTexture_description": "Crée une texture générique qui peut être utilisée avec des matériaux PBR. Cette méthode fournit une manière compatible entre les moteurs de créer des textures.",
    "bitbybit.draw.createPBRMaterial": "créer un matériau pbr",
    "createPBRMaterial": "créer un matériau pbr",
    "bitbybit.draw.createPBRMaterial_description": "Crée un matériau PBR (rendu basé sur la physique) générique. Cette méthode fournit une manière compatible entre les moteurs de créer des matériaux qui peuvent être utilisés avec des options de dessin pour les formes OCCT et autres géométries.",
    "emissiveIntensity": "intensité émissive",
    "zOffsetUnits": "unités de décalage z",
    "baseColorTexture": "texture de couleur de base",
    "Base.Texture": "Base.Texture",
    "metallicRoughnessTexture": "texture de rugosité métallique",
    "normalTexture": "texture normale",
    "emissiveTexture": "texture émissive",
    "occlusionTexture": "texture d'occlusion",
    "alphaMode": "mode alpha",
    "alphaModeEnum": "énumération du mode alpha",
    "alphaCutoff": "seuil alpha",
    "doubleSided": "double face",
    "wireframe": "fil de fer",
    "unlit": "non éclairé",
    "bitbybit.babylon.mesh.setLocalScale": "définir l'échelle locale",
    "setLocalScale": "définir l'échelle locale",
    "bitbybit.babylon.mesh.setLocalScale_description": "Redimensionne le maillage BabylonJS ou le maillage instancié sur place par un facteur donné",
    "transparencyShadow": "ombre de transparence",
    "bitbybit.manifold.crossSection.crossSectionFromPoints": "section transversale à partir de points",
    "crossSectionFromPoints": "section transversale à partir de points",
    "bitbybit.manifold.crossSection.crossSectionFromPoints_description": "Crée une section transversale à partir des points d'un seul polygone",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons": "section transversale à partir de polygones",
    "crossSectionFromPolygons": "section transversale à partir de polygones",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons_description": "Crée une section transversale à partir des points de plusieurs polygones",
    "bitbybit.manifold.crossSection.crossSectionToPoints": "section transversale vers points",
    "crossSectionToPoints": "section transversale vers points",
    "bitbybit.manifold.crossSection.crossSectionToPoints_description": "Extrait les points d'une section transversale",
    "bitbybit.manifold.crossSection.crossSectionsToPoints": "sections transversales vers points",
    "crossSectionsToPoints": "sections transversales vers points",
    "bitbybit.manifold.crossSection.crossSectionsToPoints_description": "Extrait les points des sections transversales",
    "bitbybit.previewCSV": "aperçu csv"
}