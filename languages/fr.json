{
    "bitbybit.draw.drawAnyAsyncNoReturn": "dessiner tout async sans retour",
    "bitbybit": "bitbybit",
    "draw": "dessiner",
    "drawAnyAsyncNoReturn": "dessiner tout async sans retour",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "dessine toute géométrie sans rien retourner",
    "draw async": "dessiner async",
    "entity": "entité",
    "Entity": "entité",
    "options": "options",
    "DrawOptions": "options de dessin",
    "babylonMesh": "maillage babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "maillage babylon ou maillage de lignes babylon",
    "bitbybit.draw.drawAnyAsync": "dessiner tout async",
    "drawAnyAsync": "dessiner tout async",
    "bitbybit.draw.drawAnyAsync_description": "dessine toute géométrie et retourne le maillage babylon",
    "bitbybit.draw.drawAnyNoReturn": "dessiner tout sans retour",
    "drawAnyNoReturn": "dessiner tout sans retour",
    "bitbybit.draw.drawAnyNoReturn_description": "dessine la géométrie sync, pas pour les formes occt ou jscad",
    "draw sync": "dessiner sync",
    "bitbybit.draw.drawAny": "dessiner tout",
    "drawAny": "dessiner tout",
    "bitbybit.draw.drawAny_description": "dessine la géométrie sync, pas pour les formes occt ou jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "dessiner grille maillée sans retour",
    "drawGridMeshNoReturn": "dessiner grille maillée sans retour",
    "bitbybit.draw.drawGridMeshNoReturn_description": "dessine une grille maillée au sol pour aider à l'orientation",
    "grid": "grille",
    "width": "largeur",
    "number": "nombre",
    "height": "hauteur",
    "subdivisions": "subdivisions",
    "majorUnitFrequency": "fréquence unité majeure",
    "minorUnitVisibility": "visibilité unité mineure",
    "gridRatio": "ratio grille",
    "opacity": "opacité",
    "backFaceCulling": "élimination faces arrière",
    "boolean": "booléen",
    "mainColor": "couleur principale",
    "Base.Color": "couleur de base",
    "secondaryColor": "couleur secondaire",
    "bitbybit.draw.drawGridMesh": "dessiner grille maillée",
    "drawGridMesh": "dessiner grille maillée",
    "bitbybit.draw.drawGridMesh_description": "dessine une grille maillée au sol pour aider à l'orientation",
    "bitbybit.draw.optionsSimple": "options simples",
    "optionsSimple": "options simples",
    "bitbybit.draw.optionsSimple_description": "définit les options de dessin pour la géométrie de base comme les points et les lignes",
    "colours": "couleurs",
    "string | string[]": "chaîne ou tableau de chaînes",
    "size": "taille",
    "updatable": "actualisable",
    "hidden": "caché",
    "bitbybit.draw.optionsOcctShape": "options forme occt",
    "optionsOcctShape": "options forme occt",
    "bitbybit.draw.optionsOcctShape_description": "définit les options de dessin pour les formes occt comme les arêtes et les solides",
    "faceOpacity": "opacité face",
    "edgeOpacity": "opacité arête",
    "edgeColour": "couleur arête",
    "faceColour": "couleur face",
    "vertexColour": "couleur sommet",
    "faceMaterial": "matériau face",
    "Base.Material": "matériau de base",
    "edgeWidth": "largeur arête",
    "vertexSize": "taille sommet",
    "drawEdges": "dessiner arêtes",
    "drawFaces": "dessiner faces",
    "drawVertices": "dessiner sommets",
    "precision": "précision",
    "drawEdgeIndexes": "dessiner indices arête",
    "edgeIndexHeight": "hauteur indice arête",
    "edgeIndexColour": "couleur indice arête",
    "drawFaceIndexes": "dessiner indices face",
    "faceIndexHeight": "hauteur indice face",
    "faceIndexColour": "couleur indice face",
    "bitbybit.draw.optionsOcctShapeSimple": "options forme occt simple",
    "optionsOcctShapeSimple": "options forme occt simple",
    "bitbybit.draw.optionsOcctShapeSimple_description": "définit les options de dessin simples pour les formes occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "options forme occt matériau",
    "optionsOcctShapeMaterial": "options forme occt matériau",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "définit les options de dessin avec matériau de face personnalisé pour les formes occt",
    "any": "tout",
    "bitbybit.draw.optionsManifoldShapeMaterial": "options matériau forme manifold",
    "optionsManifoldShapeMaterial": "options matériau forme manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "définit les options de dessin pour la géométrie manifold",
    "crossSectionColour": "couleur section transversale",
    "crossSectionWidth": "largeur section transversale",
    "crossSectionOpacity": "opacité section transversale",
    "computeNormals": "calculer normales",
    "bitbybit.draw.optionsBabylonNode": "options noeud babylon",
    "optionsBabylonNode": "options noeud babylon",
    "bitbybit.draw.optionsBabylonNode_description": "définit les options de dessin pour les noeuds babylon js",
    "colorX": "couleur x",
    "colorY": "couleur y",
    "colorZ": "couleur z",
    "bitbybit.babylon.mesh.dispose": "détruire maillage",
    "babylon": "babylon",
    "mesh": "maillage",
    "dispose": "détruire",
    "bitbybit.babylon.mesh.dispose_description": "supprime le maillage dessiné de la scène",
    "memory": "mémoire",
    "BABYLON.Mesh": "maillage babylon",
    "bitbybit.babylon.mesh.updateDrawn": "mettre à jour dessiné",
    "updateDrawn": "mettre à jour dessiné",
    "bitbybit.babylon.mesh.updateDrawn_description": "met à jour le maillage babylon js sans le détruire",
    "updates": "mises à jour",
    "position": "position",
    "Base.Point3": "point de base 3",
    "rotation": "rotation",
    "Base.Vector3": "vecteur de base 3",
    "scaling": "mise à l'échelle",
    "bitbybit.babylon.mesh.setVisibility": "définir visibilité",
    "setVisibility": "définir visibilité",
    "bitbybit.babylon.mesh.setVisibility_description": "change la visibilité du maillage babylon js",
    "visibility": "visibilité",
    "includeChildren": "inclure enfants",
    "bitbybit.babylon.mesh.hide": "cacher",
    "hide": "cacher",
    "bitbybit.babylon.mesh.hide_description": "cache le maillage",
    "bitbybit.babylon.mesh.show": "montrer",
    "show": "montrer",
    "bitbybit.babylon.mesh.show_description": "montre le maillage",
    "bitbybit.babylon.mesh.setParent": "définir parent",
    "setParent": "définir parent",
    "bitbybit.babylon.mesh.setParent_description": "change le parent du maillage dessiné",
    "set": "définir",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "maillage babylon ou maillage instancié ou maillage abstrait",
    "parentMesh": "maillage parent",
    "bitbybit.babylon.mesh.getParent": "obtenir parent",
    "getParent": "obtenir parent",
    "bitbybit.babylon.mesh.getParent_description": "obtient le parent du maillage dessiné",
    "get": "obtenir",
    "bitbybit.babylon.mesh.setCheckCollisions": "définir vérif collisions",
    "setCheckCollisions": "définir vérif collisions",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "change la propriété de vérification des collisions du maillage dessiné",
    "checkCollisions": "vérifier collisions",
    "bitbybit.babylon.mesh.getCheckCollisions": "obtenir vérif collisions",
    "getCheckCollisions": "obtenir vérif collisions",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "obtient la propriété de vérification des collisions du maillage dessiné",
    "bitbybit.babylon.mesh.setPickable": "définir sélectionnable",
    "setPickable": "définir sélectionnable",
    "bitbybit.babylon.mesh.setPickable_description": "change la propriété sélectionnable du maillage dessiné",
    "pickable": "sélectionnable",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "activer événements mouvement pointeur",
    "enablePointerMoveEvents": "activer événements mouvement pointeur",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "rend le maillage sélectionnable par les événements de mouvement du pointeur, coûteux en performance",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "désactiver événements mouvement pointeur",
    "disablePointerMoveEvents": "désactiver événements mouvement pointeur",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "fait ignorer au maillage les événements de mouvement du pointeur",
    "bitbybit.babylon.mesh.getPickable": "obtenir sélectionnable",
    "getPickable": "obtenir sélectionnable",
    "bitbybit.babylon.mesh.getPickable_description": "obtient la propriété sélectionnable du maillage dessiné",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "obtenir maillages où nom contient",
    "getMeshesWhereNameContains": "obtenir maillages où nom contient",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "obtient les maillages dont le nom contient le texte donné",
    "name": "nom",
    "string": "chaîne",
    "bitbybit.babylon.mesh.getChildMeshes": "obtenir maillages enfants",
    "getChildMeshes": "obtenir maillages enfants",
    "bitbybit.babylon.mesh.getChildMeshes_description": "obtient les maillages enfants",
    "directDescendantsOnly": "descendants directs seulement",
    "bitbybit.babylon.mesh.getMeshesOfId": "obtenir maillages par id",
    "getMeshesOfId": "obtenir maillages par id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "obtient les maillages par id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "obtenir maillage par id",
    "getMeshOfId": "obtenir maillage par id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "obtient le maillage par id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "obtenir maillage par id unique",
    "getMeshOfUniqueId": "obtenir maillage par id unique",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "obtient le maillage par id unique",
    "uniqueId": "id unique",
    "bitbybit.babylon.mesh.mergeMeshes": "fusionner maillages",
    "mergeMeshes": "fusionner maillages",
    "bitbybit.babylon.mesh.mergeMeshes_description": "fusionne plusieurs maillages en un seul",
    "edit": "modifier",
    "arrayOfMeshes": "tableau de maillages",
    "BABYLON.Mesh[]": "tableau de maillages babylon",
    "disposeSource": "détruire source",
    "allow32BitsIndices": "autoriser indices 32 bits",
    "meshSubclass": "sous-classe maillage",
    "subdivideWithSubMeshes": "subdiviser avec sous-maillages",
    "multiMultiMaterials": "matériaux multi multi",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "convertir en maillage ombré plat",
    "convertToFlatShadedMesh": "convertir en maillage ombré plat",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "convertit le maillage en maillage ombré plat",
    "bitbybit.babylon.mesh.clone": "cloner",
    "clone": "cloner",
    "bitbybit.babylon.mesh.clone_description": "clone le maillage",
    "bitbybit.babylon.mesh.cloneToPositions": "cloner aux positions",
    "cloneToPositions": "cloner aux positions",
    "bitbybit.babylon.mesh.cloneToPositions_description": "clone le maillage à plusieurs positions",
    "positions": "positions",
    "Base.Point3[]": "tableau de points de base 3",
    "bitbybit.babylon.mesh.setId": "définir id",
    "setId": "définir id",
    "bitbybit.babylon.mesh.setId_description": "change l'id du maillage dessiné",
    "bitbybit.babylon.mesh.getId": "obtenir id",
    "getId": "obtenir id",
    "bitbybit.babylon.mesh.getId_description": "obtient l'id du maillage dessiné",
    "bitbybit.babylon.mesh.getUniqueId": "obtenir id unique",
    "getUniqueId": "obtenir id unique",
    "bitbybit.babylon.mesh.getUniqueId_description": "obtient l'id unique du maillage dessiné",
    "bitbybit.babylon.mesh.setName": "définir nom",
    "setName": "définir nom",
    "bitbybit.babylon.mesh.setName_description": "change le nom du maillage dessiné",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "obtenir sommets comme points polygone",
    "getVerticesAsPolygonPoints": "obtenir sommets comme points polygone",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "obtient les sommets comme points de polygone pour la construction de maillage, nécessite une triangulation",
    "bitbybit.babylon.mesh.getName": "obtenir nom",
    "getName": "obtenir nom",
    "bitbybit.babylon.mesh.getName_description": "obtient le nom du maillage babylon",
    "bitbybit.babylon.mesh.setMaterial": "définir matériau",
    "setMaterial": "définir matériau",
    "bitbybit.babylon.mesh.setMaterial_description": "change le matériau du maillage dessiné",
    "material": "matériau",
    "BABYLON.Material": "matériau babylon",
    "bitbybit.babylon.mesh.getMaterial": "obtenir matériau",
    "getMaterial": "obtenir matériau",
    "bitbybit.babylon.mesh.getMaterial_description": "obtient le matériau du maillage babylon",
    "bitbybit.babylon.mesh.getPosition": "obtenir position",
    "getPosition": "obtenir position",
    "bitbybit.babylon.mesh.getPosition_description": "obtient la position comme point du maillage babylon js",
    "bitbybit.babylon.mesh.getAbsolutePosition": "obtenir position absolue",
    "getAbsolutePosition": "obtenir position absolue",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "obtient la position absolue dans le monde comme point du maillage babylon js",
    "bitbybit.babylon.mesh.getRotation": "obtenir rotation",
    "getRotation": "obtenir rotation",
    "bitbybit.babylon.mesh.getRotation_description": "obtient le vecteur de rotation du maillage babylon js",
    "bitbybit.babylon.mesh.getScale": "obtenir échelle",
    "getScale": "obtenir échelle",
    "bitbybit.babylon.mesh.getScale_description": "obtient le vecteur d'échelle du maillage babylon js",
    "bitbybit.babylon.mesh.moveForward": "avancer",
    "moveForward": "avancer",
    "bitbybit.babylon.mesh.moveForward_description": "déplace le maillage babylon js vers l'avant dans l'espace local",
    "move": "déplacer",
    "distance": "distance",
    "bitbybit.babylon.mesh.moveBackward": "reculer",
    "moveBackward": "reculer",
    "bitbybit.babylon.mesh.moveBackward_description": "déplace le maillage babylon js vers l'arrière dans l'espace local",
    "bitbybit.babylon.mesh.moveUp": "monter",
    "moveUp": "monter",
    "bitbybit.babylon.mesh.moveUp_description": "déplace le maillage babylon js vers le haut dans l'espace local",
    "bitbybit.babylon.mesh.moveDown": "descendre",
    "moveDown": "descendre",
    "bitbybit.babylon.mesh.moveDown_description": "déplace le maillage babylon js vers le bas dans l'espace local",
    "bitbybit.babylon.mesh.moveRight": "aller à droite",
    "moveRight": "aller à droite",
    "bitbybit.babylon.mesh.moveRight_description": "déplace le maillage babylon js vers la droite dans l'espace local",
    "bitbybit.babylon.mesh.moveLeft": "aller à gauche",
    "moveLeft": "aller à gauche",
    "bitbybit.babylon.mesh.moveLeft_description": "déplace le maillage babylon js vers la gauche dans l'espace local",
    "bitbybit.babylon.mesh.yaw": "lacet",
    "yaw": "lacet",
    "bitbybit.babylon.mesh.yaw_description": "fait pivoter le maillage babylon js autour de l'axe y local",
    "rotate": "pivoter",
    "bitbybit.babylon.mesh.pitch": "tangage",
    "pitch": "tangage",
    "bitbybit.babylon.mesh.pitch_description": "fait pivoter le maillage babylon js autour de l'axe x local",
    "bitbybit.babylon.mesh.roll": "roulis",
    "roll": "roulis",
    "bitbybit.babylon.mesh.roll_description": "fait pivoter le maillage babylon js autour de l'axe z local",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "pivoter autour axe avec position",
    "rotateAroundAxisWithPosition": "pivoter autour axe avec position",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "fait pivoter le maillage autour d'un axe et d'une position selon un angle",
    "axis": "axe",
    "angle": "angle",
    "bitbybit.babylon.mesh.setPosition": "définir position",
    "setPosition": "définir position",
    "bitbybit.babylon.mesh.setPosition_description": "met à jour la position du maillage babylon js ou du maillage instancié",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "maillage babylon ou maillage instancié",
    "bitbybit.babylon.mesh.setRotation": "définir rotation",
    "setRotation": "définir rotation",
    "bitbybit.babylon.mesh.setRotation_description": "met à jour la rotation du maillage babylon js ou du maillage instancié",
    "bitbybit.babylon.mesh.setScale": "définir échelle",
    "setScale": "définir échelle",
    "bitbybit.babylon.mesh.setScale_description": "met à jour l'échelle du maillage babylon js ou du maillage instancié",
    "scale": "échelle",
    "bitbybit.babylon.mesh.intersectsMesh": "intersecte maillage",
    "intersectsMesh": "intersecte maillage",
    "bitbybit.babylon.mesh.intersectsMesh_description": "vérifie si le maillage intersecte un autre maillage",
    "intersects": "intersecte",
    "babylonMesh2": "maillage babylon 2",
    "precise": "précis",
    "includeDescendants": "inclure descendants",
    "bitbybit.babylon.mesh.intersectsPoint": "intersecte point",
    "intersectsPoint": "intersecte point",
    "bitbybit.babylon.mesh.intersectsPoint_description": "vérifie si le maillage intersecte un point",
    "point": "point",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instance maillage et transformer sans retour",
    "createMeshInstanceAndTransformNoReturn": "instance maillage et transformer sans retour",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "crée une instance de maillage avec enfants pour un rendu optimisé, sans retour",
    "instance": "instance",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instance maillage et transformer",
    "createMeshInstanceAndTransform": "instance maillage et transformer",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "crée une instance de maillage avec enfants pour un rendu optimisé, retourne le maillage",
    "bitbybit.babylon.mesh.createMeshInstance": "instance maillage",
    "createMeshInstance": "instance maillage",
    "bitbybit.babylon.mesh.createMeshInstance_description": "crée une instance de maillage pour un rendu optimisé avec enfants",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussien",
    "gaussianSplatting": "splatting gaussien",
    "create": "créer",
    "bitbybit.babylon.gaussianSplatting.create_description": "crée un maillage de splatting gaussien",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "cloner splatting gaussien",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clone le maillage de splatting gaussien",
    "multiply": "multiplier",
    "BABYLON.GaussianSplattingMesh": "maillage de splatting gaussien babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "obtenir positions splat",
    "getSplatPositions": "obtenir positions splat",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "obtient les positions splat du maillage de splatting gaussien",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "figer matrice projection",
    "camera": "caméra",
    "freezeProjectionMatrix": "figer matrice projection",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "fige la matrice de projection de la caméra",
    "adjust": "ajuster",
    "BABYLON.Camera": "caméra babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "défiger matrice projection",
    "unfreezeProjectionMatrix": "défiger matrice projection",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "défige la matrice de projection de la caméra",
    "bitbybit.babylon.camera.setPosition": "définir position",
    "bitbybit.babylon.camera.setPosition_description": "change la position de la caméra",
    "BABYLON.TargetCamera": "caméra cible babylon",
    "bitbybit.babylon.camera.getPosition": "obtenir position",
    "bitbybit.babylon.camera.getPosition_description": "obtient la position de la caméra",
    "bitbybit.babylon.camera.setTarget": "définir cible",
    "setTarget": "définir cible",
    "bitbybit.babylon.camera.setTarget_description": "change la cible de la caméra",
    "target": "cible",
    "bitbybit.babylon.camera.getTarget": "obtenir cible",
    "getTarget": "obtenir cible",
    "bitbybit.babylon.camera.getTarget_description": "obtient la cible de la caméra",
    "bitbybit.babylon.camera.setSpeed": "définir vitesse",
    "setSpeed": "définir vitesse",
    "bitbybit.babylon.camera.setSpeed_description": "change la vitesse de la caméra",
    "speed": "vitesse",
    "bitbybit.babylon.camera.getSpeed": "obtenir vitesse",
    "getSpeed": "obtenir vitesse",
    "bitbybit.babylon.camera.getSpeed_description": "obtient la vitesse de la caméra",
    "bitbybit.babylon.camera.setMinZ": "définir min z",
    "setMinZ": "définir min z",
    "bitbybit.babylon.camera.setMinZ_description": "change le min z de la caméra",
    "minZ": "min z",
    "bitbybit.babylon.camera.setMaxZ": "définir max z",
    "setMaxZ": "définir max z",
    "bitbybit.babylon.camera.setMaxZ_description": "change le max z de la caméra",
    "maxZ": "max z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "rendre caméra orthographique",
    "makeCameraOrthographic": "rendre caméra orthographique",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "définit la caméra en mode orthographique",
    "orthoLeft": "ortho gauche",
    "orthoRight": "ortho droite",
    "orthoBottom": "ortho bas",
    "orthoTop": "ortho haut",
    "bitbybit.babylon.camera.makeCameraPerspective": "rendre caméra perspective",
    "makeCameraPerspective": "rendre caméra perspective",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "définit la caméra en mode perspective",
    "bitbybit.babylon.camera.free.create": "caméra libre",
    "free": "libre",
    "bitbybit.babylon.camera.free.create_description": "crée une caméra libre",
    "bitbybit.babylon.camera.arcRotate.create": "caméra arc rotation",
    "arcRotate": "arc rotation",
    "bitbybit.babylon.camera.arcRotate.create_description": "crée une caméra tournant autour de la cible sur une trajectoire en arc, par défaut pour bitbybit",
    "radius": "rayon",
    "alpha": "alpha",
    "beta": "bêta",
    "lowerRadiusLimit": "limite inférieure rayon",
    "upperRadiusLimit": "limite supérieure rayon",
    "lowerAlphaLimit": "limite inférieure alpha",
    "upperAlphaLimit": "limite supérieure alpha",
    "lowerBetaLimit": "limite inférieure bêta",
    "upperBetaLimit": "limite supérieure bêta",
    "angularSensibilityX": "sensibilité angulaire x",
    "angularSensibilityY": "sensibilité angulaire y",
    "panningSensibility": "sensibilité panoramique",
    "wheelPrecision": "précision molette",
    "bitbybit.babylon.camera.target.create": "caméra cible",
    "bitbybit.babylon.camera.target.create_description": "crée une caméra cible",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "expérience ar immersive",
    "webXr": "web xr",
    "simple": "simple",
    "createImmersiveARExperience": "expérience ar immersive",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "crée une expérience xr par défaut en mode ar immersif",
    "scene": "scène",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "expérience xr par défaut avec téléportation",
    "createDefaultXRExperienceWithTeleportation": "expérience xr par défaut avec téléportation",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "crée une expérience xr de base avec téléportation",
    "groundMeshes": "maillages sol",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "expérience xr par défaut avec téléportation retour",
    "createDefaultXRExperienceWithTeleportationReturn": "expérience xr par défaut avec téléportation retour",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "crée une expérience xr de base avec téléportation, retourne le résultat",
    "bitbybit.babylon.node.drawNode": "dessiner noeud",
    "node": "noeud",
    "drawNode": "dessiner noeud",
    "bitbybit.babylon.node.drawNode_description": "dessine un noeud avec taille et couleurs des axes",
    "BABYLON.TransformNode": "noeud de transformation babylon",
    "bitbybit.babylon.node.drawNodes": "dessiner noeuds",
    "drawNodes": "dessiner noeuds",
    "bitbybit.babylon.node.drawNodes_description": "dessine plusieurs noeuds avec taille et couleurs des axes",
    "nodes": "noeuds",
    "BABYLON.TransformNode[]": "tableau de noeuds de transformation babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "noeud depuis rotation",
    "createNodeFromRotation": "noeud depuis rotation",
    "bitbybit.babylon.node.createNodeFromRotation_description": "crée un noeud à l'origine avec rotations dans l'espace parent",
    "parent": "parent",
    "BABYLON.TransformNode | null": "noeud de transformation babylon ou null",
    "origin": "origine",
    "bitbybit.babylon.node.createWorldNode": "noeud monde",
    "createWorldNode": "noeud monde",
    "bitbybit.babylon.node.createWorldNode_description": "crée un noeud avec la racine comme parent",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "obtenir vecteur avant absolu",
    "getAbsoluteForwardVector": "obtenir vecteur avant absolu",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "obtient le vecteur avant absolu dans l'espace monde",
    "bitbybit.babylon.node.getAbsoluteRightVector": "obtenir vecteur droite absolu",
    "getAbsoluteRightVector": "obtenir vecteur droite absolu",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "obtient le vecteur droite absolu dans l'espace monde",
    "bitbybit.babylon.node.getAbsoluteUpVector": "obtenir vecteur haut absolu",
    "getAbsoluteUpVector": "obtenir vecteur haut absolu",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "obtient le vecteur haut absolu dans l'espace monde",
    "bitbybit.babylon.node.getAbsolutePosition": "obtenir position absolue",
    "bitbybit.babylon.node.getAbsolutePosition_description": "obtient la position absolue du noeud dans l'espace monde",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "obtenir transformation rotation absolue",
    "getAbsoluteRotationTransformation": "obtenir transformation rotation absolue",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "obtient la rotation absolue comme matrice de transformation (16 nombres)",
    "bitbybit.babylon.node.getRotationTransformation": "obtenir transformation rotation",
    "getRotationTransformation": "obtenir transformation rotation",
    "bitbybit.babylon.node.getRotationTransformation_description": "obtient la rotation locale comme matrice de transformation (16 nombres)",
    "bitbybit.babylon.node.getChildren": "obtenir enfants",
    "getChildren": "obtenir enfants",
    "bitbybit.babylon.node.getChildren_description": "obtient les enfants du noeud",
    "bitbybit.babylon.node.getParent": "obtenir parent",
    "bitbybit.babylon.node.getParent_description": "obtient le parent du noeud",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "obtenir position dans espace local",
    "getPositionExpressedInLocalSpace": "obtenir position dans espace local",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "obtient la position du noeud dans l'espace local",
    "bitbybit.babylon.node.getRootNode": "obtenir noeud racine",
    "getRootNode": "obtenir noeud racine",
    "bitbybit.babylon.node.getRootNode_description": "obtient le noeud racine",
    "bitbybit.babylon.node.getRotation": "obtenir rotation",
    "bitbybit.babylon.node.getRotation_description": "obtient les rotations euler du noeud",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "pivoter autour axe avec position",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "fait pivoter le noeud autour d'un axe et d'une position selon un angle",
    "bitbybit.babylon.node.rotate": "pivoter",
    "bitbybit.babylon.node.rotate_description": "fait pivoter le noeud autour de l'origine et d'un axe",
    "bitbybit.babylon.node.setAbsolutePosition": "définir position absolue",
    "setAbsolutePosition": "définir position absolue",
    "bitbybit.babylon.node.setAbsolutePosition_description": "définit la position absolue du noeud",
    "bitbybit.babylon.node.setDirection": "définir direction",
    "setDirection": "définir direction",
    "bitbybit.babylon.node.setDirection_description": "définit la direction du noeud",
    "direction": "direction",
    "number[]": "tableau de nombres",
    "bitbybit.babylon.node.setParent": "définir parent",
    "bitbybit.babylon.node.setParent_description": "définit un nouveau parent pour le noeud",
    "parentNode": "noeud parent",
    "bitbybit.babylon.node.translate": "translater",
    "translate": "translater",
    "bitbybit.babylon.node.translate_description": "déplace le noeud par un vecteur de direction et une distance",
    "bitbybit.babylon.scene.backgroundColour": "couleur arrière-plan",
    "backgroundColour": "couleur arrière-plan",
    "bitbybit.babylon.scene.backgroundColour_description": "change la couleur d'arrière-plan de la scène dans l'espace 3d",
    "environment": "environnement",
    "colour": "couleur",
    "bitbybit.babylon.scene.activateCamera": "activer caméra",
    "activateCamera": "activer caméra",
    "bitbybit.babylon.scene.activateCamera_description": "définit la caméra comme active, remplaçant la caméra actuelle",
    "bitbybit.babylon.scene.useRightHandedSystem": "utiliser système droitier",
    "useRightHandedSystem": "utiliser système droitier",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "passe au système de coordonnées droitier",
    "system": "système",
    "use": "utiliser",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "dessiner lumière ponctuelle sans retour",
    "drawPointLightNoReturn": "dessiner lumière ponctuelle sans retour",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "ajoute une lumière ponctuelle à la scène, sans sortie",
    "lights": "lumières",
    "intensity": "intensité",
    "diffuse": "diffuse",
    "specular": "spéculaire",
    "shadowGeneratorMapSize": "taille carte générateur ombres",
    "enableShadows": "activer ombres",
    "shadowDarkness": "obscurité ombre",
    "shadowUsePercentageCloserFiltering": "ombre utiliser filtrage pourcentage rapproché",
    "shadowContactHardeningLightSizeUVRatio": "ombre durcissement contact taille lumière ratio uv",
    "shadowBias": "biais ombre",
    "shadowNormalBias": "biais normal ombre",
    "shadowMaxZ": "ombre max z",
    "shadowMinZ": "ombre min z",
    "bitbybit.babylon.scene.getShadowGenerators": "obtenir générateurs ombres",
    "getShadowGenerators": "obtenir générateurs ombres",
    "bitbybit.babylon.scene.getShadowGenerators_description": "obtient les générateurs d'ombres des lumières bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "dessiner lumière ponctuelle",
    "drawPointLight": "dessiner lumière ponctuelle",
    "bitbybit.babylon.scene.drawPointLight_description": "ajoute une lumière ponctuelle à la scène",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "dessiner lumière directionnelle sans retour",
    "drawDirectionalLightNoReturn": "dessiner lumière directionnelle sans retour",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "ajoute une lumière directionnelle à la scène, sans sortie",
    "bitbybit.babylon.scene.drawDirectionalLight": "dessiner lumière directionnelle",
    "drawDirectionalLight": "dessiner lumière directionnelle",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "ajoute une lumière directionnelle à la scène",
    "bitbybit.babylon.scene.getActiveCamera": "obtenir caméra active",
    "getActiveCamera": "obtenir caméra active",
    "bitbybit.babylon.scene.getActiveCamera_description": "obtient la caméra active actuelle dans la scène",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "ajuster caméra arc rotation active",
    "adjustActiveArcRotateCamera": "ajuster caméra arc rotation active",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "ajuste les paramètres de la caméra arc rotation active",
    "lookAt": "regarder vers",
    "bitbybit.babylon.scene.clearAllDrawn": "effacer tout dessiné",
    "clearAllDrawn": "effacer tout dessiné",
    "bitbybit.babylon.scene.clearAllDrawn_description": "supprime tous les objets dessinés de la scène 3d",
    "bitbybit.babylon.scene.enableSkybox": "activer skybox",
    "enableSkybox": "activer skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "active le skybox dans la scène",
    "skybox": "skybox",
    "Base.skyboxEnum": "énumération skybox de base",
    "blur": "flou",
    "environmentIntensity": "intensité environnement",
    "bitbybit.babylon.scene.fog": "brouillard",
    "fog": "brouillard",
    "bitbybit.babylon.scene.fog_description": "active le mode brouillard dans la scène",
    "mode": "mode",
    "Base.fogModeEnum": "énumération mode brouillard de base",
    "color": "couleur",
    "density": "densité",
    "start": "début",
    "end": "fin",
    "bitbybit.babylon.transforms.rotationCenterAxis": "rotation centre axe",
    "transforms": "transformations",
    "rotationCenterAxis": "rotation centre axe",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "crée une transformation de rotation autour du centre et de l'axe",
    "center": "centre",
    "bitbybit.babylon.transforms.rotationCenterX": "rotation centre x",
    "rotationCenterX": "rotation centre x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "crée une transformation de rotation autour du centre et de l'axe x",
    "bitbybit.babylon.transforms.rotationCenterY": "rotation centre y",
    "rotationCenterY": "rotation centre y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "crée une transformation de rotation autour du centre et de l'axe y",
    "bitbybit.babylon.transforms.rotationCenterZ": "rotation centre z",
    "rotationCenterZ": "rotation centre z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "crée une transformation de rotation autour du centre et de l'axe z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "rotation centre lacet tangage roulis",
    "rotationCenterYawPitchRoll": "rotation centre lacet tangage roulis",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "crée une transformation de rotation avec lacet, tangage, roulis",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "échelle centre xyz",
    "scaleCenterXYZ": "échelle centre xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "crée une transformation d'échelle autour du centre en xyz",
    "scaleXyz": "échelle xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "échelle xyz",
    "scaleXYZ": "échelle xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "crée une transformation d'échelle dans les directions x y z",
    "bitbybit.babylon.transforms.uniformScale": "échelle uniforme",
    "uniformScale": "échelle uniforme",
    "bitbybit.babylon.transforms.uniformScale_description": "crée une transformation d'échelle uniforme",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "échelle uniforme depuis centre",
    "uniformScaleFromCenter": "échelle uniforme depuis centre",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "crée une transformation d'échelle uniforme depuis le centre",
    "bitbybit.babylon.transforms.translationXYZ": "translation xyz",
    "translationXYZ": "translation xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "crée une transformation de translation",
    "translation": "translation",
    "bitbybit.babylon.transforms.translationsXYZ": "translations xyz",
    "translationsXYZ": "translations xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "crée plusieurs transformations de translation",
    "translations": "translations",
    "Base.Vector3[]": "tableau de vecteurs de base 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "charger actif dans scène",
    "io": "io",
    "loadAssetIntoScene": "charger actif dans scène",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "importe un maillage depuis un actif de projet téléversé",
    "load": "charger",
    "assetFile": "fichier actif",
    "File": "fichier",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "charger actif dans scène sans retour",
    "loadAssetIntoSceneNoReturn": "charger actif dans scène sans retour",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "importe un maillage depuis un actif de projet téléversé, sans sortie",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "charger actif dans scène depuis url racine",
    "loadAssetIntoSceneFromRootUrl": "charger actif dans scène depuis url racine",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "importe un maillage depuis une url web publique, nécessite cors",
    "rootUrl": "url racine",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "charger actif dans scène depuis url racine sans retour",
    "loadAssetIntoSceneFromRootUrlNoReturn": "charger actif dans scène depuis url racine sans retour",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "importe un maillage depuis une url web publique, sans sortie, nécessite cors",
    "bitbybit.babylon.io.exportBabylon": "exporter babylon",
    "exportBabylon": "exporter babylon",
    "bitbybit.babylon.io.exportBabylon_description": "exporte la scène au format .babylon pour édition",
    "export": "exporter",
    "fileName": "nom de fichier",
    "bitbybit.babylon.io.exportGLB": "exporter glb",
    "exportGLB": "exporter glb",
    "bitbybit.babylon.io.exportGLB_description": "exporte la scène au format .glb, standard web",
    "discardSkyboxAndGrid": "rejeter skybox et grille",
    "bitbybit.babylon.io.exportMeshToStl": "exporter maillage vers stl",
    "exportMeshToStl": "exporter maillage vers stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "exporte le maillage et les enfants vers stl",
    "bitbybit.babylon.io.exportMeshesToStl": "exporter maillages vers stl",
    "exportMeshesToStl": "exporter maillages vers stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "exporte plusieurs maillages vers stl",
    "meshes": "maillages",
    "bitbybit.babylon.ray.createPickingRay": "rayon de sélection",
    "ray": "rayon",
    "createPickingRay": "rayon de sélection",
    "bitbybit.babylon.ray.createPickingRay_description": "crée un rayon de sélection depuis la position de la souris dans la caméra active",
    "bitbybit.babylon.ray.createRay": "rayon",
    "createRay": "rayon",
    "bitbybit.babylon.ray.createRay_description": "crée un rayon depuis l'origine avec une direction et une longueur optionnelle",
    "length": "longueur",
    "bitbybit.babylon.ray.createRayFromTo": "rayon de à",
    "createRayFromTo": "rayon de à",
    "bitbybit.babylon.ray.createRayFromTo_description": "crée un rayon entre deux points",
    "from": "de",
    "to": "à",
    "bitbybit.babylon.ray.getOrigin": "obtenir origine",
    "getOrigin": "obtenir origine",
    "bitbybit.babylon.ray.getOrigin_description": "obtient l'origine du rayon",
    "BABYLON.Ray": "rayon babylon",
    "bitbybit.babylon.ray.getDirection": "obtenir direction",
    "getDirection": "obtenir direction",
    "bitbybit.babylon.ray.getDirection_description": "obtient la direction du rayon",
    "bitbybit.babylon.ray.getLength": "obtenir longueur",
    "getLength": "obtenir longueur",
    "bitbybit.babylon.ray.getLength_description": "obtient la longueur du rayon",
    "bitbybit.babylon.pick.pickWithRay": "sélectionner avec rayon",
    "pick": "sélectionner",
    "pickWithRay": "sélectionner avec rayon",
    "bitbybit.babylon.pick.pickWithRay_description": "obtient le résultat de la sélection par rayon",
    "bitbybit.babylon.pick.pickWithPickingRay": "sélectionner avec rayon sélection",
    "pickWithPickingRay": "sélectionner avec rayon sélection",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "sélectionne avec un rayon depuis la position de la souris dans la caméra active",
    "bitbybit.babylon.pick.getDistance": "obtenir distance",
    "getDistance": "obtenir distance",
    "bitbybit.babylon.pick.getDistance_description": "obtient la distance à l'objet si sélectionné",
    "get from pick info": "obtenir depuis info sélection",
    "pickInfo": "info sélection",
    "BABYLON.PickingInfo": "info sélection babylon",
    "bitbybit.babylon.pick.getPickedMesh": "obtenir maillage sélectionné",
    "getPickedMesh": "obtenir maillage sélectionné",
    "bitbybit.babylon.pick.getPickedMesh_description": "obtient le maillage qui a été sélectionné",
    "bitbybit.babylon.pick.getPickedPoint": "obtenir point sélectionné",
    "getPickedPoint": "obtenir point sélectionné",
    "bitbybit.babylon.pick.getPickedPoint_description": "obtient le point qui a été sélectionné",
    "bitbybit.babylon.pick.hit": "touché",
    "hit": "touché",
    "bitbybit.babylon.pick.hit_description": "vérifie si le rayon a touché quelque chose dans la scène",
    "bitbybit.babylon.pick.getSubMeshId": "obtenir id sous-maillage",
    "getSubMeshId": "obtenir id sous-maillage",
    "bitbybit.babylon.pick.getSubMeshId_description": "obtient l'id unique du sous-maillage si sélectionné",
    "bitbybit.babylon.pick.getSubMeshFaceId": "obtenir id face sous-maillage",
    "getSubMeshFaceId": "obtenir id face sous-maillage",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "obtient l'id unique de la face du sous-maillage si sélectionnée",
    "bitbybit.babylon.pick.getBU": "obtenir bu",
    "getBU": "obtenir bu",
    "bitbybit.babylon.pick.getBU_description": "obtient le u barycentrique pour la collision de texture",
    "bitbybit.babylon.pick.getBV": "obtenir bv",
    "getBV": "obtenir bv",
    "bitbybit.babylon.pick.getBV_description": "obtient le v barycentrique pour la collision de texture",
    "bitbybit.babylon.pick.getPickedSprite": "obtenir sprite sélectionné",
    "getPickedSprite": "obtenir sprite sélectionné",
    "bitbybit.babylon.pick.getPickedSprite_description": "obtient le sprite sélectionné",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr métallique rugosité",
    "pbrMetallicRoughness": "pbr métallique rugosité",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "crée un matériau pbr métallique rugosité",
    "baseColor": "couleur de base",
    "emissiveColor": "couleur émissive",
    "metallic": "métallique",
    "roughness": "rugosité",
    "zOffset": "décalage z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "définir couleur de base",
    "setBaseColor": "définir couleur de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "définit la couleur de base du matériau",
    "BABYLON.PBRMetallicRoughnessMaterial": "matériau pbr métallique rugosité babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "définir métallique",
    "setMetallic": "définir métallique",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "définit la propriété métallique du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "définir rugosité",
    "setRoughness": "définir rugosité",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "définit la rugosité du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "définir alpha",
    "setAlpha": "définir alpha",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "définit l'alpha du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "définir élimination faces arrière",
    "setBackFaceCulling": "définir élimination faces arrière",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "définit l'élimination des faces arrière du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "définir texture de base",
    "setBaseTexture": "définir texture de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "définit la texture du matériau",
    "baseTexture": "texture de base",
    "BABYLON.Texture": "texture babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "obtenir couleur de base",
    "getBaseColor": "obtenir couleur de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "obtient la couleur de base du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "obtenir métallique",
    "getMetallic": "obtenir métallique",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "obtient la propriété métallique du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "obtenir rugosité",
    "getRoughness": "obtenir rugosité",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "obtient la rugosité du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "obtenir alpha",
    "getAlpha": "obtenir alpha",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "obtient l'alpha du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "obtenir élimination faces arrière",
    "getBackFaceCulling": "obtenir élimination faces arrière",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "obtient l'élimination des faces arrière du matériau",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "obtenir texture de base",
    "getBaseTexture": "obtenir texture de base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "obtient la texture de base du matériau",
    "bitbybit.babylon.material.skyMaterial.create": "matériau ciel",
    "skyMaterial": "matériau ciel",
    "bitbybit.babylon.material.skyMaterial.create_description": "crée un matériau ciel",
    "luminance": "luminance",
    "turbidity": "turbidité",
    "rayleigh": "rayleigh",
    "mieCoefficient": "coefficient mie",
    "mieDirectionalG": "mie directionnel g",
    "inclination": "inclinaison",
    "azimuth": "azimut",
    "sunPosition": "position soleil",
    "useSunPosition": "utiliser position soleil",
    "cameraOffset": "décalage caméra",
    "up": "haut",
    "dithering": "tramage",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "définir luminance",
    "setLuminance": "définir luminance",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "définit la luminance du matériau ciel",
    "MATERIALS.SkyMaterial": "matériaux matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "définir turbidité",
    "setTurbidity": "définir turbidité",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "définit la turbidité du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "définir rayleigh",
    "setRayleigh": "définir rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "définit le rayleigh du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "définir coefficient mie",
    "setMieCoefficient": "définir coefficient mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "définit le coefficient mie du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "définir mie directionnel g",
    "setMieDirectionalG": "définir mie directionnel g",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "définit le mie directionnel g du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setDistance": "définir distance",
    "setDistance": "définir distance",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "définit la distance du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setInclination": "définir inclinaison",
    "setInclination": "définir inclinaison",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "définit l'inclinaison du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "définir azimut",
    "setAzimuth": "définir azimut",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "définit l'azimut du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "définir position soleil",
    "setSunPosition": "définir position soleil",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "définit la position du soleil du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "définir utiliser position soleil",
    "setUseSunPosition": "définir utiliser position soleil",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "définit l'utilisation de la position du soleil du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "définir décalage caméra",
    "setCameraOffset": "définir décalage caméra",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "définit le décalage de la caméra du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setUp": "définir haut",
    "setUp": "définir haut",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "définit la direction haut du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.setDithering": "définir tramage",
    "setDithering": "définir tramage",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "définit le tramage du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "obtenir luminance",
    "getLuminance": "obtenir luminance",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "obtient la luminance du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "obtenir turbidité",
    "getTurbidity": "obtenir turbidité",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "obtient la turbidité du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "obtenir rayleigh",
    "getRayleigh": "obtenir rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "obtient le rayleigh du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "obtenir coefficient mie",
    "getMieCoefficient": "obtenir coefficient mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "obtient le coefficient mie du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "obtenir mie directionnel g",
    "getMieDirectionalG": "obtenir mie directionnel g",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "obtient le mie directionnel g du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getDistance": "obtenir distance",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "obtient la distance du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getInclination": "obtenir inclinaison",
    "getInclination": "obtenir inclinaison",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "obtient l'inclinaison du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "obtenir azimut",
    "getAzimuth": "obtenir azimut",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "obtient l'azimut du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "obtenir position soleil",
    "getSunPosition": "obtenir position soleil",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "obtient la position du soleil du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "obtenir utiliser position soleil",
    "getUseSunPosition": "obtenir utiliser position soleil",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "obtient l'utilisation de la position du soleil du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "obtenir décalage caméra",
    "getCameraOffset": "obtenir décalage caméra",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "obtient le décalage de la caméra du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getUp": "obtenir haut",
    "getUp": "obtenir haut",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "obtient la direction haut du matériau ciel",
    "bitbybit.babylon.material.skyMaterial.getDithering": "obtenir tramage",
    "getDithering": "obtenir tramage",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "obtient le tramage du matériau ciel",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "définir direction vers cible",
    "shadowLight": "lumière ombre",
    "setDirectionToTarget": "définir direction vers cible",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "définit la direction de la lumière ombre",
    "BABYLON.ShadowLight": "lumière ombre babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "définir position",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "définit la position de la lumière ombre",
    "bitbybit.babylon.meshBuilder.createBox": "boîte",
    "meshBuilder": "constructeur maillage",
    "createBox": "boîte",
    "bitbybit.babylon.meshBuilder.createBox_description": "crée un maillage boîte",
    "create simple": "créer simple",
    "depth": "profondeur",
    "sideOrientation": "orientation côté",
    "BabylonMesh.sideOrientationEnum": "énumération orientation côté maillage babylon",
    "bitbybit.babylon.meshBuilder.createCube": "cube",
    "createCube": "cube",
    "bitbybit.babylon.meshBuilder.createCube_description": "crée un maillage cube",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "plan carré",
    "createSquarePlane": "plan carré",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "crée un maillage plan carré",
    "bitbybit.babylon.meshBuilder.createSphere": "sphère",
    "createSphere": "sphère",
    "bitbybit.babylon.meshBuilder.createSphere_description": "crée un maillage sphère",
    "diameter": "diamètre",
    "segments": "segments",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "icosphère",
    "createIcoSphere": "icosphère",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "crée un maillage icosphère",
    "radiusX": "rayon x",
    "radiusY": "rayon y",
    "radiusZ": "rayon z",
    "flat": "plat",
    "bitbybit.babylon.meshBuilder.createDisc": "disque",
    "createDisc": "disque",
    "bitbybit.babylon.meshBuilder.createDisc_description": "crée un maillage disque",
    "tessellation": "tessellation",
    "arc": "arc",
    "bitbybit.babylon.meshBuilder.createTorus": "tore",
    "createTorus": "tore",
    "bitbybit.babylon.meshBuilder.createTorus_description": "crée un maillage tore",
    "thickness": "épaisseur",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "noeud de tore",
    "createTorusKnot": "noeud de tore",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "crée un maillage noeud de tore",
    "tube": "tube",
    "radialSegments": "segments radiaux",
    "tubularSegments": "segments tubulaires",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polygone",
    "createPolygon": "polygone",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "crée un maillage polygone",
    "shape": "forme",
    "holes": "trous",
    "Base.Vector3[][]": "tableau de tableau de vecteurs de base 3",
    "smoothingThreshold": "seuil lissage",
    "wrap": "envelopper",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extruder polygone",
    "extrudePolygon": "extruder polygone",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "crée un maillage polygone extrudé",
    "bitbybit.babylon.meshBuilder.createTube": "tube",
    "createTube": "tube",
    "bitbybit.babylon.meshBuilder.createTube_description": "crée un maillage tube",
    "path": "chemin",
    "cap": "capuchon",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "polyèdre",
    "createPolyhedron": "polyèdre",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "crée un maillage polyèdre",
    "type": "type",
    "sizeX": "taille x",
    "sizeY": "taille y",
    "sizeZ": "taille z",
    "custom": "personnalisé",
    "bitbybit.babylon.meshBuilder.createGeodesic": "géodésique",
    "createGeodesic": "géodésique",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "crée un maillage géodésique",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "crée un maillage goldberg",
    "bitbybit.babylon.meshBuilder.createCapsule": "capsule",
    "createCapsule": "capsule",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "crée un maillage capsule",
    "orientation": "orientation",
    "capSubdivisions": "subdivisions capuchon",
    "radiusTop": "rayon haut",
    "radiusBottom": "rayon bas",
    "topCapSubdivisions": "subdivisions capuchon haut",
    "bottomCapSubdivisions": "subdivisions capuchon bas",
    "bitbybit.babylon.meshBuilder.createCylinder": "cylindre",
    "createCylinder": "cylindre",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "crée un maillage cylindre",
    "diameterTop": "diamètre haut",
    "diameterBottom": "diamètre bas",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "forme extrudée",
    "createExtrudedSahpe": "forme extrudée",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "crée un maillage forme extrudée",
    "closeShape": "fermer forme",
    "closePath": "fermer chemin",
    "bitbybit.babylon.meshBuilder.createRibbon": "ruban",
    "createRibbon": "ruban",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "crée un maillage ruban",
    "pathArray": "tableau de chemins",
    "closeArray": "fermer tableau",
    "offset": "décalage",
    "bitbybit.babylon.meshBuilder.createLathe": "tour",
    "createLathe": "tour",
    "bitbybit.babylon.meshBuilder.createLathe_description": "crée un maillage de tour",
    "closed": "fermé",
    "bitbybit.babylon.meshBuilder.createGround": "sol",
    "createGround": "sol",
    "bitbybit.babylon.meshBuilder.createGround_description": "crée un maillage de sol",
    "subdivisionsX": "subdivisions x",
    "subdivisionsY": "subdivisions y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "plan rectangle",
    "createRectanglePlane": "plan rectangle",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "crée un maillage plan rectangle",
    "bitbybit.babylon.texture.createSimple": "texture simple",
    "texture": "texture",
    "createSimple": "simple",
    "bitbybit.babylon.texture.createSimple_description": "crée une texture à partir d'une URL avec des options de base",
    "invertY": "inverser y",
    "invertZ": "inverser z",
    "wAng": "angle w",
    "uScale": "échelle u",
    "vScale": "échelle v",
    "uOffset": "décalage u",
    "vOffset": "décalage v",
    "samplingMode": "mode d'échantillonnage",
    "samplingModeEnum": "énumération mode d'échantillonnage",
    "bitbybit.babylon.tools.createScreenshot": "capture d'écran",
    "tools": "outils",
    "createScreenshot": "capture d'écran",
    "bitbybit.babylon.tools.createScreenshot_description": "capture une capture d'écran de la scène",
    "screenshots": "captures d'écran",
    "mimeType": "type mime",
    "quality": "qualité",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "capture d'écran et télécharger",
    "createScreenshotAndDownload": "capture d'écran et télécharger",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "capture et télécharge une capture d'écran de la scène",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interface utilisateur plein écran",
    "gui": "gui",
    "advancedDynamicTexture": "texture dynamique avancée",
    "createFullScreenUI": "interface utilisateur plein écran",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "crée une interface utilisateur plein écran",
    "spaces": "espaces",
    "foreground": "premier plan",
    "adaptiveScaling": "mise à l'échelle adaptative",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "pour maillage",
    "createForMesh": "pour maillage",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "crée une texture pour le maillage",
    "BABYLON.AbstractMesh": "maillage abstrait babylon",
    "supportPointerMove": "support mouvement pointeur",
    "onlyAlphaTesting": "test alpha seulement",
    "sampling": "échantillonnage",
    "BabylonTexture.samplingModeEnum": "énumération mode échantillonnage texture babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "changer rembourrage contrôle",
    "control": "contrôle",
    "changeControlPadding": "changer rembourrage contrôle",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "définit le rembourrage du contrôle",
    "positioning": "positionnement",
    "BABYLON.GUI.Control": "contrôle gui babylon",
    "paddingLeft": "rembourrage gauche",
    "number | string": "nombre ou chaîne",
    "paddingRight": "rembourrage droit",
    "paddingTop": "rembourrage haut",
    "paddingBottom": "rembourrage bas",
    "bitbybit.babylon.gui.control.changeControlAlignment": "changer alignement contrôle",
    "changeControlAlignment": "changer alignement contrôle",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "définit l'alignement du contrôle",
    "T": "t",
    "horizontalAlignment": "alignement horizontal",
    "horizontalAlignmentEnum": "énumération alignement horizontal",
    "verticalAlignment": "alignement vertical",
    "verticalAlignmentEnum": "énumération alignement vertical",
    "bitbybit.babylon.gui.control.cloneControl": "cloner contrôle",
    "cloneControl": "cloner contrôle",
    "bitbybit.babylon.gui.control.cloneControl_description": "clone le contrôle",
    "container": "conteneur",
    "BABYLON.GUI.Container": "conteneur gui babylon",
    "host": "hôte",
    "BABYLON.GUI.AdvancedDynamicTexture": "texture dynamique avancée gui babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "sélecteur observable contrôle",
    "createControlObservableSelector": "sélecteur observable contrôle",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "crée un sélecteur observable pour le contrôle",
    "selector": "sélecteur",
    "controlObservableSelectorEnum": "énumération sélecteur observable contrôle",
    "bitbybit.babylon.gui.control.getControlByName": "obtenir contrôle par nom",
    "getControlByName": "obtenir contrôle par nom",
    "bitbybit.babylon.gui.control.getControlByName_description": "obtient le contrôle par nom",
    "bitbybit.babylon.gui.control.setIsVisible": "définir est visible",
    "setIsVisible": "définir est visible",
    "bitbybit.babylon.gui.control.setIsVisible_description": "définit la visibilité du contrôle",
    "isVisible": "est visible",
    "bitbybit.babylon.gui.control.setIsReadonly": "définir est lecture seule",
    "setIsReadonly": "définir est lecture seule",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "définit le contrôle en lecture seule",
    "isReadOnly": "est lecture seule",
    "bitbybit.babylon.gui.control.setIsEnabled": "définir est activé",
    "setIsEnabled": "définir est activé",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "définit le contrôle activé",
    "isEnabled": "est activé",
    "bitbybit.babylon.gui.control.setHeight": "définir hauteur",
    "setHeight": "définir hauteur",
    "bitbybit.babylon.gui.control.setHeight_description": "définit la hauteur du contrôle",
    "bitbybit.babylon.gui.control.setWidth": "définir largeur",
    "setWidth": "définir largeur",
    "bitbybit.babylon.gui.control.setWidth_description": "définit la largeur du contrôle",
    "bitbybit.babylon.gui.control.setColor": "définir couleur",
    "setColor": "définir couleur",
    "bitbybit.babylon.gui.control.setColor_description": "définit la couleur du contrôle",
    "bitbybit.babylon.gui.control.setFontSize": "définir taille police",
    "setFontSize": "définir taille police",
    "bitbybit.babylon.gui.control.setFontSize_description": "définit la taille de police du contrôle",
    "fontSize": "taille police",
    "bitbybit.babylon.gui.control.getHeight": "obtenir hauteur",
    "getHeight": "obtenir hauteur",
    "bitbybit.babylon.gui.control.getHeight_description": "obtient la hauteur du contrôle",
    "bitbybit.babylon.gui.control.getWidth": "obtenir largeur",
    "getWidth": "obtenir largeur",
    "bitbybit.babylon.gui.control.getWidth_description": "obtient la largeur du contrôle",
    "bitbybit.babylon.gui.control.getColor": "obtenir couleur",
    "getColor": "obtenir couleur",
    "bitbybit.babylon.gui.control.getColor_description": "obtient la couleur du contrôle",
    "bitbybit.babylon.gui.control.getFontSize": "obtenir taille police",
    "getFontSize": "obtenir taille police",
    "bitbybit.babylon.gui.control.getFontSize_description": "obtient la taille de police du contrôle",
    "bitbybit.babylon.gui.control.getIsVisible": "obtenir est visible",
    "getIsVisible": "obtenir est visible",
    "bitbybit.babylon.gui.control.getIsVisible_description": "obtient la visibilité du contrôle",
    "bitbybit.babylon.gui.control.getIsReadonly": "obtenir est lecture seule",
    "getIsReadonly": "obtenir est lecture seule",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "obtient le contrôle en lecture seule",
    "bitbybit.babylon.gui.control.getIsEnabled": "obtenir est activé",
    "getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "obtient le contrôle activé",
    "bitbybit.babylon.gui.container.addControls": "ajouter contrôles",
    "addControls": "ajouter contrôles",
    "bitbybit.babylon.gui.container.addControls_description": "ajoute les contrôles au conteneur dans l'ordre",
    "controls": "contrôles",
    "BABYLON.GUI.Control[]": "tableau de contrôles gui babylon",
    "clearControlsFirst": "effacer contrôles d'abord",
    "bitbybit.babylon.gui.container.setBackground": "définir arrière-plan",
    "setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.container.setBackground_description": "définit l'arrière-plan du conteneur",
    "background": "arrière-plan",
    "bitbybit.babylon.gui.container.setIsReadonly": "définir est lecture seule",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "définit le conteneur en lecture seule",
    "bitbybit.babylon.gui.container.getBackground": "obtenir arrière-plan",
    "getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.container.getBackground_description": "obtient l'arrière-plan du conteneur",
    "bitbybit.babylon.gui.container.getIsReadonly": "obtenir est lecture seule",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "obtient le conteneur en lecture seule",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "panneau empilé",
    "stackPanel": "panneau empilé",
    "createStackPanel": "panneau empilé",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "crée un panneau empilé",
    "isVertical": "est vertical",
    "spacing": "espacement",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "définir est vertical",
    "setIsVertical": "définir est vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "définit le panneau empilé vertical",
    "BABYLON.GUI.StackPanel": "panneau empilé gui babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "définir espacement",
    "setSpacing": "définir espacement",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "définit l'espacement du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.setWidth": "définir largeur",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "définit la largeur du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.setHeight": "définir hauteur",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "définit la hauteur du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "obtenir est vertical",
    "getIsVertical": "obtenir est vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "obtient le panneau empilé vertical",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "obtenir espacement",
    "getSpacing": "obtenir espacement",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "obtient l'espacement du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.getWidth": "obtenir largeur",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "obtient la largeur du panneau empilé",
    "bitbybit.babylon.gui.stackPanel.getHeight": "obtenir hauteur",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "obtient la hauteur du panneau empilé",
    "bitbybit.babylon.gui.button.createSimpleButton": "bouton simple",
    "button": "bouton",
    "createSimpleButton": "bouton simple",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "crée un bouton simple",
    "label": "étiquette",
    "bitbybit.babylon.gui.button.setButtonText": "définir texte bouton",
    "setButtonText": "définir texte bouton",
    "bitbybit.babylon.gui.button.setButtonText_description": "définit le texte du bouton",
    "BABYLON.GUI.Button": "bouton gui babylon",
    "text": "texte",
    "bitbybit.babylon.gui.button.getButtonText": "obtenir texte bouton",
    "getButtonText": "obtenir texte bouton",
    "bitbybit.babylon.gui.button.getButtonText_description": "obtient le texte du bouton",
    "bitbybit.babylon.gui.slider.createSlider": "curseur",
    "slider": "curseur",
    "createSlider": "curseur",
    "bitbybit.babylon.gui.slider.createSlider_description": "crée un curseur",
    "minimum": "minimum",
    "maximum": "maximum",
    "value": "valeur",
    "step": "pas",
    "displayThumb": "afficher pouce",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "changer pouce curseur",
    "changeSliderThumb": "changer pouce curseur",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "change les propriétés du pouce du curseur",
    "BABYLON.GUI.Slider": "curseur gui babylon",
    "isThumbCircle": "est pouce cercle",
    "thumbColor": "couleur pouce",
    "thumbWidth": "largeur pouce",
    "string | number": "chaîne ou nombre",
    "isThumbClamped": "est pouce limité",
    "bitbybit.babylon.gui.slider.setBorderColor": "définir couleur bordure",
    "setBorderColor": "définir couleur bordure",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "définit la couleur de la bordure du curseur",
    "borderColor": "couleur bordure",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "définir couleur arrière-plan",
    "setBackgroundColor": "définir couleur arrière-plan",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "définit la couleur d'arrière-plan du curseur",
    "backgroundColor": "couleur arrière-plan",
    "bitbybit.babylon.gui.slider.setMaximum": "définir maximum",
    "setMaximum": "définir maximum",
    "bitbybit.babylon.gui.slider.setMaximum_description": "définit la valeur maximale du curseur",
    "bitbybit.babylon.gui.slider.setMinimum": "définir minimum",
    "setMinimum": "définir minimum",
    "bitbybit.babylon.gui.slider.setMinimum_description": "définit la valeur minimale du curseur",
    "bitbybit.babylon.gui.slider.setStep": "définir pas",
    "setStep": "définir pas",
    "bitbybit.babylon.gui.slider.setStep_description": "définit la valeur de pas du curseur",
    "bitbybit.babylon.gui.slider.setValue": "définir valeur",
    "setValue": "définir valeur",
    "bitbybit.babylon.gui.slider.setValue_description": "définit la valeur du curseur",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "sélecteur observable curseur",
    "createSliderObservableSelector": "sélecteur observable curseur",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "crée un sélecteur observable pour le curseur",
    "sliderObservableSelectorEnum": "énumération sélecteur observable curseur",
    "bitbybit.babylon.gui.slider.getBorderColor": "obtenir couleur bordure",
    "getBorderColor": "obtenir couleur bordure",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "obtient la couleur de la bordure du curseur",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "obtenir couleur arrière-plan",
    "getBackgroundColor": "obtenir couleur arrière-plan",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "obtient la couleur d'arrière-plan du curseur",
    "bitbybit.babylon.gui.slider.getMaximum": "obtenir maximum",
    "getMaximum": "obtenir maximum",
    "bitbybit.babylon.gui.slider.getMaximum_description": "obtient la valeur maximale du curseur",
    "bitbybit.babylon.gui.slider.getMinimum": "obtenir minimum",
    "getMinimum": "obtenir minimum",
    "bitbybit.babylon.gui.slider.getMinimum_description": "obtient la valeur minimale du curseur",
    "bitbybit.babylon.gui.slider.getStep": "obtenir pas",
    "getStep": "obtenir pas",
    "bitbybit.babylon.gui.slider.getStep_description": "obtient la valeur de pas du curseur",
    "bitbybit.babylon.gui.slider.getValue": "obtenir valeur",
    "getValue": "obtenir valeur",
    "bitbybit.babylon.gui.slider.getValue_description": "obtient la valeur du curseur",
    "bitbybit.babylon.gui.slider.getThumbColor": "obtenir couleur pouce",
    "getThumbColor": "obtenir couleur pouce",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "obtient la couleur du pouce du curseur",
    "bitbybit.babylon.gui.slider.getThumbWidth": "obtenir largeur pouce",
    "getThumbWidth": "obtenir largeur pouce",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "obtient la largeur du pouce du curseur",
    "bitbybit.babylon.gui.slider.getIsVertical": "obtenir est vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "obtient si le curseur est vertical",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "obtenir afficher pouce",
    "getDisplayThumb": "obtenir afficher pouce",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "obtient si le pouce du curseur est affiché",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "obtenir est pouce cercle",
    "getIsThumbCircle": "obtenir est pouce cercle",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "obtient si le pouce du curseur est un cercle",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "obtenir est pouce limité",
    "getIsThumbClamped": "obtenir est pouce limité",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "obtient si le pouce du curseur est limité",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "bloc de texte",
    "textBlock": "bloc de texte",
    "createTextBlock": "bloc de texte",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "crée un bloc de texte",
    "bitbybit.babylon.gui.textBlock.alignText": "aligner texte",
    "alignText": "aligner texte",
    "bitbybit.babylon.gui.textBlock.alignText_description": "définit l'alignement du texte",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "définir contour texte",
    "setTextOutline": "définir contour texte",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "définit le contour du texte",
    "BABYLON.GUI.TextBlock": "bloc de texte gui babylon",
    "outlineWidth": "largeur contour",
    "outlineColor": "couleur contour",
    "bitbybit.babylon.gui.textBlock.setText": "définir texte",
    "setText": "définir texte",
    "bitbybit.babylon.gui.textBlock.setText_description": "définit le texte du bloc de texte",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "définir redimensionner pour ajuster",
    "setRsizeToFit": "définir redimensionner pour ajuster",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "définit le redimensionnement pour ajuster",
    "resizeToFit": "redimensionner pour ajuster",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "définir retour à la ligne",
    "setTextWrapping": "définir retour à la ligne",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "définit le retour à la ligne du texte",
    "textWrapping": "retour à la ligne",
    "boolean | BABYLON.GUI.TextWrapping": "booléen ou retour à la ligne gui babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "définir interligne",
    "setLineSpacing": "définir interligne",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "définit l'interligne du texte",
    "lineSpacing": "interligne",
    "bitbybit.babylon.gui.textBlock.getText": "obtenir texte",
    "getText": "obtenir texte",
    "bitbybit.babylon.gui.textBlock.getText_description": "obtient le texte du bloc de texte",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "obtenir retour à la ligne",
    "getTextWrapping": "obtenir retour à la ligne",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "obtient le retour à la ligne du texte",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "obtenir interligne",
    "getLineSpacing": "obtenir interligne",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "obtient l'interligne du texte",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "obtenir largeur contour",
    "getOutlineWidth": "obtenir largeur contour",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "obtient la largeur du contour du texte",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "obtenir redimensionner pour ajuster",
    "getResizeToFit": "obtenir redimensionner pour ajuster",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "obtient si le redimensionnement pour ajuster est activé",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "obtenir alignement horizontal texte",
    "getTextHorizontalAlignment": "obtenir alignement horizontal texte",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "obtient l'alignement horizontal du texte",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "obtenir alignement vertical texte",
    "getTextVerticalAlignment": "obtenir alignement vertical texte",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "obtient l'alignement vertical du texte",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "sélecteur observable bloc de texte",
    "createTextBlockObservableSelector": "sélecteur observable bloc de texte",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "crée un sélecteur observable pour le bloc de texte",
    "textBlockObservableSelectorEnum": "énumération sélecteur observable bloc de texte",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "bouton radio",
    "radioButton": "bouton radio",
    "createRadioButton": "bouton radio",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "crée un bouton radio",
    "group": "groupe",
    "isChecked": "est coché",
    "checkSizeRatio": "ratio taille coche",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "définir ratio taille coche",
    "setCheckSizeRatio": "définir ratio taille coche",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "définit le ratio de taille de coche du bouton radio",
    "BABYLON.GUI.RadioButton": "bouton radio gui babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "définir groupe",
    "setGroup": "définir groupe",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "définit le groupe du bouton radio",
    "bitbybit.babylon.gui.radioButton.setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "définit l'arrière-plan du bouton radio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "obtenir ratio taille coche",
    "getCheckSizeRatio": "obtenir ratio taille coche",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "obtient le ratio de taille de coche du bouton radio",
    "bitbybit.babylon.gui.radioButton.getGroup": "obtenir groupe",
    "getGroup": "obtenir groupe",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "obtient le groupe du bouton radio",
    "bitbybit.babylon.gui.radioButton.getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "obtient l'arrière-plan du bouton radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "sélecteur observable bouton radio",
    "createRadioButtonObservableSelector": "sélecteur observable bouton radio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "crée un sélecteur observable pour le bouton radio",
    "radioButtonObservableSelectorEnum": "énumération sélecteur observable bouton radio",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "case à cocher",
    "checkbox": "case à cocher",
    "createCheckbox": "case à cocher",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "crée une case à cocher",
    "bitbybit.babylon.gui.checkbox.setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "définit l'arrière-plan de la case à cocher",
    "BABYLON.GUI.Checkbox": "case à cocher gui babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "définir ratio taille coche",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "définit le ratio de taille de coche de la case à cocher",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "définir est coché",
    "setIsChecked": "définir est coché",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "définit si la case à cocher est cochée",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "obtenir ratio taille coche",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "obtient le ratio de taille de coche de la case à cocher",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "obtenir est coché",
    "getIsChecked": "obtenir est coché",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "obtient si la case à cocher est cochée",
    "bitbybit.babylon.gui.checkbox.getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "obtient l'arrière-plan de la case à cocher",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "sélecteur observable case à cocher",
    "createCheckboxObservableSelector": "sélecteur observable case à cocher",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "crée un sélecteur observable pour la case à cocher",
    "checkboxObservableSelectorEnum": "énumération sélecteur observable case à cocher",
    "bitbybit.babylon.gui.inputText.createInputText": "saisie de texte",
    "inputText": "saisie de texte",
    "createInputText": "saisie de texte",
    "bitbybit.babylon.gui.inputText.createInputText_description": "crée une saisie de texte",
    "placeholder": "texte indicatif",
    "bitbybit.babylon.gui.inputText.setBackground": "définir arrière-plan",
    "bitbybit.babylon.gui.inputText.setBackground_description": "définit l'arrière-plan de la saisie de texte",
    "BABYLON.GUI.InputText": "saisie de texte gui babylon",
    "bitbybit.babylon.gui.inputText.setText": "définir texte",
    "bitbybit.babylon.gui.inputText.setText_description": "définit le texte de la saisie",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "définir texte indicatif",
    "setPlaceholder": "définir texte indicatif",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "définit le texte indicatif de la saisie",
    "bitbybit.babylon.gui.inputText.getBackground": "obtenir arrière-plan",
    "bitbybit.babylon.gui.inputText.getBackground_description": "obtient l'arrière-plan de la saisie de texte",
    "bitbybit.babylon.gui.inputText.getText": "obtenir texte",
    "bitbybit.babylon.gui.inputText.getText_description": "obtient le texte de la saisie",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "obtenir texte indicatif",
    "getPlaceholder": "obtenir texte indicatif",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "obtient le texte indicatif de la saisie",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "sélecteur observable saisie de texte",
    "createInputTextObservableSelector": "sélecteur observable saisie de texte",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "crée un sélecteur observable pour la saisie de texte",
    "inputTextObservableSelectorEnum": "énumération sélecteur observable saisie de texte",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "sélecteur de couleur",
    "colorPicker": "sélecteur de couleur",
    "createColorPicker": "sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "crée un sélecteur de couleur",
    "defaultColor": "couleur par défaut",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "définir valeur sélecteur couleur",
    "setColorPickerValue": "définir valeur sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "définit la valeur du sélecteur de couleur",
    "BABYLON.GUI.ColorPicker": "sélecteur couleur gui babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "définir taille sélecteur couleur",
    "setColorPickerSize": "définir taille sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "définit la taille du sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "obtenir valeur sélecteur couleur",
    "getColorPickerValue": "obtenir valeur sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "obtient la valeur du sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "obtenir taille sélecteur couleur",
    "getColorPickerSize": "obtenir taille sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "obtient la taille du sélecteur de couleur",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "sélecteur observable sélecteur couleur",
    "createColorPickerObservableSelector": "sélecteur observable sélecteur couleur",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "crée un sélecteur observable pour le sélecteur de couleur",
    "colorPickerObservableSelectorEnum": "énumération sélecteur observable sélecteur couleur",
    "bitbybit.babylon.gui.image.createImage": "image",
    "image": "image",
    "createImage": "image",
    "bitbybit.babylon.gui.image.createImage_description": "crée une image",
    "bitbybit.babylon.gui.image.setSourceUrl": "définir url source",
    "setSourceUrl": "définir url source",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "définit l'url source de l'image",
    "BABYLON.GUI.Image": "image gui babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "obtenir url source",
    "getSourceUrl": "obtenir url source",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "obtient l'url source de l'image",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gestionnaire de gizmo",
    "gizmo": "gizmo",
    "manager": "gestionnaire",
    "createGizmoManager": "gestionnaire de gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "crée un gestionnaire de gizmo",
    "positionGizmoEnabled": "gizmo position activé",
    "rotationGizmoEnabled": "gizmo rotation activé",
    "scaleGizmoEnabled": "gizmo échelle activé",
    "boundingBoxGizmoEnabled": "gizmo boîte englobante activé",
    "usePointerToAttachGizmos": "utiliser pointeur pour attacher gizmos",
    "clearGizmoOnEmptyPointerEvent": "effacer gizmo sur événement pointeur vide",
    "scaleRatio": "ratio échelle",
    "attachableMeshes": "maillages attachables",
    "BABYLON.AbstractMesh[]": "tableau maillages abstraits babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "obtenir gizmo position",
    "getPositionGizmo": "obtenir gizmo position",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "obtient le gizmo de position",
    "gizmoManager": "gestionnaire gizmo",
    "BABYLON.GizmoManager": "gestionnaire gizmo babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "obtenir gizmo rotation",
    "getRotationGizmo": "obtenir gizmo rotation",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "obtient le gizmo de rotation",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "obtenir gizmo échelle",
    "getScaleGizmo": "obtenir gizmo échelle",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "obtient le gizmo d'échelle",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "obtenir gizmo boîte englobante",
    "getBoundingBoxGizmo": "obtenir gizmo boîte englobante",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "obtient le gizmo de boîte englobante",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "attacher au maillage",
    "attachToMesh": "attacher au maillage",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "attache le gestionnaire de gizmo au maillage",
    "update": "mettre à jour",
    "bitbybit.babylon.gizmo.manager.detachMesh": "détacher maillage",
    "detachMesh": "détacher maillage",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "détache le gestionnaire de gizmo du maillage",
    "bitbybit.babylon.gizmo.base.scaleRatio": "définir ratio échelle",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "définit le ratio d'échelle du gizmo",
    "BABYLON.IGizmo": "i gizmo babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "obtenir ratio échelle",
    "getScaleRatio": "obtenir ratio échelle",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "obtient le ratio d'échelle du gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "définir gizmo planaire activé",
    "positionGizmo": "gizmo position",
    "planarGizmoEnabled": "gizmo planaire activé",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "définit si le gizmo planaire est activé",
    "BABYLON.IPositionGizmo": "i gizmo position babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "définir distance accrochage",
    "snapDistance": "distance accrochage",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "définit la distance d'accrochage du gizmo de position",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "obtenir maillage attaché",
    "getAttachedMesh": "obtenir maillage attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "obtient le maillage attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "obtenir noeud attaché",
    "getAttachedNode": "obtenir noeud attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "obtient le noeud attaché",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "obtenir gizmo x",
    "getXGizmo": "obtenir gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "obtient le gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "obtenir gizmo y",
    "getYGizmo": "obtenir gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "obtient le gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "obtenir gizmo z",
    "getZGizmo": "obtenir gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "obtient le gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "obtenir gizmo plan x",
    "getXPlaneGizmo": "obtenir gizmo plan x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "obtient le gizmo plan x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "obtenir gizmo plan y",
    "getYPlaneGizmo": "obtenir gizmo plan y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "obtient le gizmo plan y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "obtenir gizmo plan z",
    "getZPlaneGizmo": "obtenir gizmo plan z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "obtient le gizmo plan z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "obtenir gizmo planaire activé",
    "getPlanarGizmoEnabled": "obtenir gizmo planaire activé",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "obtient si le gizmo planaire est activé",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "obtenir distance accrochage",
    "getSnapDistance": "obtenir distance accrochage",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "obtient la distance d'accrochage",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "obtenir est en train de glisser",
    "getIsDragging": "obtenir est en train de glisser",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "obtient l'état de glissement",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "sélecteur observable gizmo position",
    "createPositionGizmoObservableSelector": "sélecteur observable gizmo position",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "crée un sélecteur observable pour le gizmo de position",
    "positionGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo position",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "définir distance accrochage",
    "rotationGizmo": "gizmo rotation",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "définit la distance d'accrochage du gizmo de rotation",
    "BABYLON.IRotationGizmo": "i gizmo rotation babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "définir sensibilité",
    "sensitivity": "sensibilité",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "définit la sensibilité du gizmo de rotation",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "obtenir maillage attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "obtient le maillage attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "obtenir noeud attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "obtient le noeud attaché",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "obtenir gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "obtient le gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "obtenir gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "obtient le gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "obtenir gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "obtient le gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "obtenir distance accrochage",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "obtient la distance d'accrochage",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "obtenir sensibilité",
    "getSensitivity": "obtenir sensibilité",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "obtient la sensibilité",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "sélecteur observable gizmo rotation",
    "createRotationGizmoObservableSelector": "sélecteur observable gizmo rotation",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "crée un sélecteur observable pour le gizmo de rotation",
    "rotationGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo rotation",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "obtenir gizmo x",
    "scaleGizmo": "gizmo échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "obtient le gizmo x",
    "BABYLON.IScaleGizmo": "i gizmo échelle babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "obtenir gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "obtient le gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "obtenir gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "obtient le gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "définir distance accrochage",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "définit la distance d'accrochage du gizmo d'échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "définir accrochage incrémentiel",
    "setIncrementalSnap": "définir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "définit l'accrochage incrémentiel du gizmo d'échelle",
    "incrementalSnap": "accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "définir sensibilité",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "définit la sensibilité du gizmo d'échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "obtenir accrochage incrémentiel",
    "getIncrementalSnap": "obtenir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "obtient si l'accrochage incrémentiel est activé",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "obtenir distance accrochage",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "obtient la distance d'accrochage",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "obtenir sensibilité",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "obtient la sensibilité",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "sélecteur observable gizmo échelle",
    "createScaleGizmoObservableSelector": "sélecteur observable gizmo échelle",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "crée un sélecteur observable pour le gizmo d'échelle",
    "scaleGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "définir taille sphère rotation",
    "boundingBoxGizmo": "gizmo boîte englobante",
    "setRotationSphereSize": "définir taille sphère rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "définit la taille de la sphère de rotation du gizmo de boîte englobante",
    "BABYLON.BoundingBoxGizmo": "gizmo boîte englobante babylon",
    "rotationSphereSize": "taille sphère rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "définir taille écran maillage glissement fixe",
    "setFixedDragMeshScreenSize": "définir taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "définit la taille d'écran du maillage de glissement fixe pour une mise à l'échelle cohérente",
    "fixedDragMeshScreenSize": "taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "définir taille limites maillage glissement fixe",
    "setFixedDragMeshBoundsSize": "définir taille limites maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "définit la taille des limites du maillage de glissement fixe",
    "fixedDragMeshBoundsSize": "taille limites maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "définir facteur distance taille écran maillage glissement fixe",
    "setFixedDragMeshScreenSizeDistanceFactor": "définir facteur distance taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "définit le facteur de distance pour la taille d'écran du maillage de glissement fixe",
    "fixedDragMeshScreenSizeDistanceFactor": "facteur distance taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "définir distance accrochage échelle",
    "setScalingSnapDistance": "définir distance accrochage échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "définit la distance d'accrochage de l'échelle du gizmo de boîte englobante",
    "scalingSnapDistance": "distance accrochage échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "définir distance accrochage rotation",
    "setRotationSnapDistance": "définir distance accrochage rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "définit la distance d'accrochage de la rotation du gizmo de boîte englobante",
    "rotationSnapDistance": "distance accrochage rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "définir taille boîte échelle",
    "setScaleBoxSize": "définir taille boîte échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "définit la taille de la boîte d'échelle du gizmo de boîte englobante",
    "scaleBoxSize": "taille boîte échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "définir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "définit l'accrochage incrémentiel du gizmo de boîte englobante",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "définir pivot échelle",
    "setScalePivot": "définir pivot échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "définit le pivot d'échelle du gizmo de boîte englobante",
    "scalePivot": "pivot échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "définir facteur axe",
    "setAxisFactor": "définir facteur axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "définit le facteur d'axe du gizmo de boîte englobante",
    "axisFactor": "facteur axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "définir vitesse glissement échelle",
    "setScaleDragSpeed": "définir vitesse glissement échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "définit la vitesse de glissement de l'échelle du gizmo de boîte englobante",
    "scaleDragSpeed": "vitesse glissement échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "obtenir taille sphère rotation",
    "getRotationSphereSize": "obtenir taille sphère rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "obtient la taille de la sphère de rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "obtenir taille boîte échelle",
    "getScaleBoxSize": "obtenir taille boîte échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "obtient la taille de la boîte d'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "obtenir taille écran maillage glissement fixe",
    "getFixedDragMeshScreenSize": "obtenir taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "obtient la taille d'écran du maillage de glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "obtenir taille limites maillage glissement fixe",
    "getFixedDragMeshBoundsSize": "obtenir taille limites maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "obtient la taille des limites du maillage de glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "obtenir facteur distance taille écran maillage glissement fixe",
    "getFixedDragMeshScreenSizeDistanceFactor": "obtenir facteur distance taille écran maillage glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "obtient le facteur de distance de la taille d'écran du maillage de glissement fixe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "obtenir distance accrochage échelle",
    "getScalingSnapDistance": "obtenir distance accrochage échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "obtient la distance d'accrochage de l'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "obtenir distance accrochage rotation",
    "getRotationSnapDistance": "obtenir distance accrochage rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "obtient la distance d'accrochage de la rotation",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "obtenir accrochage incrémentiel",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "obtient si l'accrochage incrémentiel est activé",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "obtenir pivot échelle",
    "getScalePivot": "obtenir pivot échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "obtient le pivot d'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "obtenir facteur axe",
    "getAxisFactor": "obtenir facteur axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "obtient le facteur d'axe",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "obtenir vitesse glissement échelle",
    "getScaleDragSpeed": "obtenir vitesse glissement échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "obtient la vitesse de glissement de l'échelle",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "sélecteur observable gizmo boîte englobante",
    "createBoundingBoxGizmoObservableSelector": "sélecteur observable gizmo boîte englobante",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "crée un sélecteur observable pour le gizmo de boîte englobante",
    "boundingBoxGizmoObservableSelectorEnum": "énumération sélecteur observable gizmo boîte englobante",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "définir est activé",
    "axisDragGizmo": "gizmo glissement axe",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "définit l'axe activé",
    "BABYLON.IAxisDragGizmo": "i gizmo glissement axe babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "obtient si l'axe est activé",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "définir est activé",
    "axisScaleGizmo": "gizmo échelle axe",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "définit l'axe activé",
    "BABYLON.IAxisScaleGizmo": "i gizmo échelle axe babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "obtient si l'axe est activé",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "définir est activé",
    "planeDragGizmo": "gizmo glissement plan",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "définit le plan activé",
    "BABYLON.IPlaneDragGizmo": "i gizmo glissement plan babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "obtient si le plan est activé",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "définir est activé",
    "planeRotationGizmo": "gizmo rotation plan",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "définit le plan activé",
    "BABYLON.IPlaneRotationGizmo": "i gizmo rotation plan babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "obtenir est activé",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "obtient si le plan est activé",
    "bitbybit.vector.removeAllDuplicateVectors": "supprimer tous vecteurs dupliqués",
    "vector": "vecteur",
    "removeAllDuplicateVectors": "supprimer tous vecteurs dupliqués",
    "bitbybit.vector.removeAllDuplicateVectors_description": "supprime tous les vecteurs dupliqués du tableau",
    "remove": "supprimer",
    "vectors": "vecteurs",
    "number[][]": "tableau de tableau de nombres",
    "tolerance": "tolérance",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "supprimer vecteurs dupliqués consécutifs",
    "removeConsecutiveDuplicateVectors": "supprimer vecteurs dupliqués consécutifs",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "supprime les vecteurs dupliqués consécutifs du tableau",
    "checkFirstAndLast": "vérifier premier et dernier",
    "bitbybit.vector.angleBetween": "angle entre",
    "angleBetween": "angle entre",
    "bitbybit.vector.angleBetween_description": "mesure l'angle entre deux vecteurs en degrés",
    "angles": "angles",
    "first": "premier",
    "second": "deuxième",
    "bitbybit.vector.angleBetweenNormalized2d": "angle entre normalisés 2d",
    "angleBetweenNormalized2d": "angle entre normalisés 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "mesure l'angle 2d normalisé entre deux vecteurs en degrés",
    "bitbybit.vector.positiveAngleBetween": "angle positif entre",
    "positiveAngleBetween": "angle positif entre",
    "bitbybit.vector.positiveAngleBetween_description": "mesure l'angle positif entre deux vecteurs avec référence en degrés",
    "reference": "référence",
    "bitbybit.vector.addAll": "additionner tout",
    "addAll": "additionner tout",
    "bitbybit.vector.addAll_description": "additionne toutes les valeurs xyz des vecteurs dans un nouveau vecteur",
    "sum": "somme",
    "bitbybit.vector.add": "additionner",
    "add": "additionner",
    "bitbybit.vector.add_description": "additionne deux vecteurs",
    "bitbybit.vector.all": "tout",
    "all": "tout",
    "bitbybit.vector.all_description": "vérifie si le tableau booléen est entièrement vrai",
    "boolean[]": "tableau booléen",
    "bitbybit.vector.cross": "produit vectoriel",
    "cross": "produit vectoriel",
    "bitbybit.vector.cross_description": "calcule le produit vectoriel de deux vecteurs",
    "bitbybit.vector.distSquared": "distance au carré",
    "distSquared": "distance au carré",
    "bitbybit.vector.distSquared_description": "distance au carré entre deux vecteurs",
    "bitbybit.vector.dist": "distance",
    "dist": "distance",
    "bitbybit.vector.dist_description": "distance entre deux vecteurs",
    "bitbybit.vector.div": "diviser",
    "div": "diviser",
    "bitbybit.vector.div_description": "divise un vecteur par un scalaire",
    "scalar": "scalaire",
    "bitbybit.vector.domain": "domaine",
    "domain": "domaine",
    "bitbybit.vector.domain_description": "calcule le domaine entre le min et le max du vecteur",
    "bitbybit.vector.dot": "produit scalaire",
    "dot": "produit scalaire",
    "bitbybit.vector.dot_description": "produit scalaire de deux vecteurs",
    "bitbybit.vector.finite": "fini",
    "finite": "fini",
    "bitbybit.vector.finite_description": "vérifie si les nombres du vecteur sont finis",
    "validate": "valider",
    "bitbybit.vector.isZero": "est nul",
    "isZero": "est nul",
    "bitbybit.vector.isZero_description": "vérifie si la longueur du vecteur est nulle",
    "bitbybit.vector.lerp": "interpolation linéaire",
    "lerp": "interpolation linéaire",
    "bitbybit.vector.lerp_description": "trouve un vecteur entre deux vecteurs par fraction",
    "fraction": "fraction",
    "bitbybit.vector.max": "max",
    "max": "max",
    "bitbybit.vector.max_description": "trouve la valeur maximale dans le vecteur",
    "extract": "extraire",
    "bitbybit.vector.min": "min",
    "min": "min",
    "bitbybit.vector.min_description": "trouve la valeur minimale dans le vecteur",
    "bitbybit.vector.mul": "multiplier",
    "mul": "multiplier",
    "bitbybit.vector.mul_description": "multiplie un vecteur par un scalaire",
    "bitbybit.vector.neg": "opposer",
    "neg": "opposer",
    "bitbybit.vector.neg_description": "prend l'opposé du vecteur",
    "bitbybit.vector.normSquared": "norme au carré",
    "normSquared": "norme au carré",
    "bitbybit.vector.normSquared_description": "calcule la norme au carré",
    "bitbybit.vector.norm": "norme",
    "norm": "norme",
    "bitbybit.vector.norm_description": "calcule la norme du vecteur",
    "bitbybit.vector.normalized": "normalisé",
    "normalized": "normalisé",
    "bitbybit.vector.normalized_description": "normalise le vecteur à une longueur unitaire",
    "bitbybit.vector.onRay": "sur rayon",
    "onRay": "sur rayon",
    "bitbybit.vector.onRay_description": "trouve un point sur le rayon à une distance donnée",
    "bitbybit.vector.vectorXYZ": "vecteur xyz",
    "vectorXYZ": "vecteur xyz",
    "bitbybit.vector.vectorXYZ_description": "crée un vecteur xyz",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vecteur xy",
    "vectorXY": "vecteur xy",
    "bitbybit.vector.vectorXY_description": "crée un vecteur 2d xy",
    "bitbybit.vector.range": "plage",
    "range": "plage",
    "bitbybit.vector.range_description": "crée un vecteur d'entiers de 0 à max",
    "bitbybit.vector.signedAngleBetween": "angle signé entre",
    "signedAngleBetween": "angle signé entre",
    "bitbybit.vector.signedAngleBetween_description": "calcule l'angle signé entre deux vecteurs avec référence",
    "bitbybit.vector.span": "étendue",
    "span": "étendue",
    "bitbybit.vector.span_description": "crée un vecteur allant de min à max avec un pas",
    "bitbybit.vector.spanEaseItems": "étendue objets lissés",
    "spanEaseItems": "étendue objets lissés",
    "bitbybit.vector.spanEaseItems_description": "crée un vecteur allant de min à max avec une fonction de lissage",
    "nrItems": "nb objets",
    "ease": "lissage",
    "Math.easeEnum": "énumération lissage math",
    "intervals": "intervalles",
    "bitbybit.vector.spanLinearItems": "étendue objets linéaires",
    "spanLinearItems": "étendue objets linéaires",
    "bitbybit.vector.spanLinearItems_description": "crée un vecteur allant de min à max avec un nombre d'objets",
    "bitbybit.vector.sub": "soustraire",
    "sub": "soustraire",
    "bitbybit.vector.sub_description": "soustrait deux vecteurs",
    "bitbybit.vector.sum": "somme",
    "bitbybit.vector.sum_description": "additionne les valeurs du vecteur",
    "bitbybit.point.transformPoint": "transformer point",
    "transformPoint": "transformer point",
    "bitbybit.point.transformPoint_description": "transforme un seul point",
    "transformation": "transformation",
    "Base.TransformMatrixes": "matrices transformation base",
    "bitbybit.point.transformPoints": "transformer points",
    "transformPoints": "transformer points",
    "bitbybit.point.transformPoints_description": "transforme plusieurs points",
    "points": "points",
    "bitbybit.point.transformsForPoints": "transformations pour points",
    "transformsForPoints": "transformations pour points",
    "bitbybit.point.transformsForPoints_description": "transforme plusieurs points avec plusieurs transformations",
    "Base.TransformMatrixes[]": "tableau matrices transformation base",
    "bitbybit.point.translatePoints": "translater points",
    "translatePoints": "translater points",
    "bitbybit.point.translatePoints_description": "translate plusieurs points",
    "bitbybit.point.translatePointsWithVectors": "translater points avec vecteurs",
    "translatePointsWithVectors": "translater points avec vecteurs",
    "bitbybit.point.translatePointsWithVectors_description": "translate plusieurs points avec des vecteurs",
    "bitbybit.point.translateXYZPoints": "translater points xyz",
    "translateXYZPoints": "translater points xyz",
    "bitbybit.point.translateXYZPoints_description": "translate plusieurs points par valeurs xyz",
    "bitbybit.point.scalePointsCenterXYZ": "mettre à l'échelle points centre xyz",
    "scalePointsCenterXYZ": "mettre à l'échelle points centre xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "met à l'échelle plusieurs points depuis le centre avec des facteurs xyz",
    "bitbybit.point.rotatePointsCenterAxis": "pivoter points centre axe",
    "rotatePointsCenterAxis": "pivoter points centre axe",
    "bitbybit.point.rotatePointsCenterAxis_description": "pivote plusieurs points autour du centre et d'un axe",
    "bitbybit.point.closestPointFromPointsDistance": "distance point le plus proche des points",
    "closestPointFromPointsDistance": "distance point le plus proche des points",
    "bitbybit.point.closestPointFromPointsDistance_description": "mesure la distance la plus proche des points",
    "bitbybit.point.closestPointFromPointsIndex": "index point le plus proche des points",
    "closestPointFromPointsIndex": "index point le plus proche des points",
    "bitbybit.point.closestPointFromPointsIndex_description": "trouve l'index du point le plus proche commençant à 1",
    "bitbybit.point.closestPointFromPoints": "point le plus proche des points",
    "closestPointFromPoints": "point le plus proche des points",
    "bitbybit.point.closestPointFromPoints_description": "trouve le point le plus proche dans la collection",
    "bitbybit.point.distance": "distance",
    "bitbybit.point.distance_description": "mesure la distance entre deux points",
    "measure": "mesurer",
    "startPoint": "point de départ",
    "endPoint": "point d'arrivée",
    "bitbybit.point.distancesToPoints": "distances aux points",
    "distancesToPoints": "distances aux points",
    "bitbybit.point.distancesToPoints_description": "mesure les distances du point de départ à plusieurs points d'arrivée",
    "endPoints": "points d'arrivée",
    "bitbybit.point.multiplyPoint": "multiplier point",
    "multiplyPoint": "multiplier point",
    "bitbybit.point.multiplyPoint_description": "multiplie un point par un montant",
    "amountOfPoints": "nombre de points",
    "bitbybit.point.getX": "obtenir x",
    "getX": "obtenir x",
    "bitbybit.point.getX_description": "obtient la coordonnée x du point",
    "bitbybit.point.getY": "obtenir y",
    "getY": "obtenir y",
    "bitbybit.point.getY_description": "obtient la coordonnée y du point",
    "bitbybit.point.getZ": "obtenir z",
    "getZ": "obtenir z",
    "bitbybit.point.getZ_description": "obtient la coordonnée z du point",
    "bitbybit.point.averagePoint": "point moyen",
    "averagePoint": "point moyen",
    "bitbybit.point.averagePoint_description": "obtient le point moyen des points",
    "bitbybit.point.pointXYZ": "point xyz",
    "pointXYZ": "point xyz",
    "bitbybit.point.pointXYZ_description": "crée un point xyz",
    "bitbybit.point.pointXY": "point xy",
    "pointXY": "point xy",
    "bitbybit.point.pointXY_description": "crée un point xy",
    "bitbybit.point.spiral": "spirale",
    "spiral": "spirale",
    "bitbybit.point.spiral_description": "crée une spirale à partir de plusieurs points",
    "phi": "phi",
    "numberPoints": "nombre points",
    "widening": "élargissement",
    "factor": "facteur",
    "bitbybit.point.hexGrid": "grille hexagonale",
    "hexGrid": "grille hexagonale",
    "bitbybit.point.hexGrid_description": "crée une grille hexagonale plate sur le plan xy",
    "nrHexagonsY": "nb hexagones y",
    "nrHexagonsX": "nb hexagones x",
    "radiusHexagon": "rayon hexagone",
    "orientOnCenter": "orienter sur centre",
    "pointsOnGround": "points au sol",
    "bitbybit.point.removeConsecutiveDuplicates": "supprimer doublons consécutifs",
    "removeConsecutiveDuplicates": "supprimer doublons consécutifs",
    "bitbybit.point.removeConsecutiveDuplicates_description": "supprime les doublons consécutifs du tableau de points",
    "clean": "nettoyer",
    "bitbybit.line.convertToNurbsCurve": "convertir en courbe nurbs",
    "line": "ligne",
    "convertToNurbsCurve": "convertir en courbe nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "convertit la ligne en courbe nurbs",
    "LinePointsDto": "dto points ligne",
    "bitbybit.line.convertLinesToNurbsCurves": "convertir lignes en courbes nurbs",
    "convertLinesToNurbsCurves": "convertir lignes en courbes nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "convertit les lignes en tableau de courbes nurbs",
    "lines": "lignes",
    "LinePointsDto[]": "tableau dto points ligne",
    "bitbybit.line.getStartPoint": "obtenir point départ",
    "getStartPoint": "obtenir point départ",
    "bitbybit.line.getStartPoint_description": "obtient le point de départ de la ligne",
    "bitbybit.line.getEndPoint": "obtenir point arrivée",
    "getEndPoint": "obtenir point arrivée",
    "bitbybit.line.getEndPoint_description": "obtient le point d'arrivée de la ligne",
    "bitbybit.line.length": "longueur",
    "bitbybit.line.length_description": "obtient la longueur de la ligne",
    "bitbybit.line.reverse": "inverser",
    "reverse": "inverser",
    "bitbybit.line.reverse_description": "inverse les extrémités de la ligne",
    "bitbybit.line.transformLine": "transformer ligne",
    "transformLine": "transformer ligne",
    "bitbybit.line.transformLine_description": "transforme la ligne",
    "bitbybit.line.transformsForLines": "transformations pour lignes",
    "transformsForLines": "transformations pour lignes",
    "bitbybit.line.transformsForLines_description": "transforme plusieurs lignes",
    "bitbybit.line.create": "créer",
    "bitbybit.line.create_description": "crée une ligne",
    "bitbybit.line.createAsync": "async",
    "createAsync": "async",
    "bitbybit.line.createAsync_description": "crée une ligne à partir de points async",
    "bitbybit.line.getPointOnLine": "obtenir point sur ligne",
    "getPointOnLine": "obtenir point sur ligne",
    "bitbybit.line.getPointOnLine_description": "obtient un point sur la ligne au paramètre",
    "param": "param",
    "bitbybit.line.linesBetweenPoints": "lignes entre points",
    "linesBetweenPoints": "lignes entre points",
    "bitbybit.line.linesBetweenPoints_description": "crée des segments de ligne entre les points",
    "bitbybit.line.linesBetweenStartAndEndPoints": "lignes entre points départ et arrivée",
    "linesBetweenStartAndEndPoints": "lignes entre points départ et arrivée",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "crée des lignes entre les listes de points de départ et d'arrivée",
    "startPoints": "points de départ",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "lignes entre points départ et arrivée async",
    "linesBetweenStartAndEndPointsAsync": "lignes entre points départ et arrivée async",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "crée des lignes entre les points de départ et d'arrivée avec des entrées async",
    "bitbybit.polyline.convertToNurbsCurve": "convertir en courbe nurbs",
    "polyline": "polyligne",
    "bitbybit.polyline.convertToNurbsCurve_description": "convertit la polyligne en courbe nurbs",
    "PolylinePropertiesDto": "dto propriétés polyligne",
    "bitbybit.polyline.length": "longueur",
    "bitbybit.polyline.length_description": "obtient la longueur de la polyligne",
    "bitbybit.polyline.countPoints": "compter points",
    "countPoints": "compter points",
    "bitbybit.polyline.countPoints_description": "obtient le nombre de points de la polyligne",
    "bitbybit.polyline.getPoints": "obtenir points",
    "getPoints": "obtenir points",
    "bitbybit.polyline.getPoints_description": "obtient les points de la polyligne",
    "bitbybit.polyline.reverse": "inverser",
    "bitbybit.polyline.reverse_description": "inverse les points de la polyligne",
    "bitbybit.polyline.transformPolyline": "transformer polyligne",
    "transformPolyline": "transformer polyligne",
    "bitbybit.polyline.transformPolyline_description": "transforme la polyligne",
    "bitbybit.polyline.create": "créer",
    "bitbybit.polyline.create_description": "crée une polyligne",
    "isClosed": "est fermé",
    "string | number[]": "chaîne ou tableau de nombres",
    "bitbybit.occt.deleteShape": "supprimer forme",
    "occt": "occt",
    "deleteShape": "supprimer forme",
    "bitbybit.occt.deleteShape_description": "supprime la forme du cache",
    "bitbybit.occt.deleteShapes": "supprimer formes",
    "deleteShapes": "supprimer formes",
    "bitbybit.occt.deleteShapes_description": "supprime les formes du cache",
    "shapes": "formes",
    "T[]": "tableau t",
    "bitbybit.occt.cleanAllCache": "nettoyer tout le cache",
    "cleanAllCache": "nettoyer tout le cache",
    "bitbybit.occt.cleanAllCache_description": "nettoie tout le cache et les formes de la mémoire",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "sommet depuis xyz",
    "vertex": "sommet",
    "vertexFromXYZ": "sommet depuis xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "crée un sommet à partir des coordonnées xyz",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "sommet depuis point",
    "vertexFromPoint": "sommet depuis point",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "crée un sommet à partir d'un point",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "sommets depuis points",
    "verticesFromPoints": "sommets depuis points",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "crée des sommets à partir de points",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "composé sommets depuis points",
    "verticesCompoundFromPoints": "composé sommets depuis points",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "crée une forme composée de sommets",
    "bitbybit.occt.shapes.vertex.getVertices": "obtenir sommets",
    "getVertices": "obtenir sommets",
    "bitbybit.occt.shapes.vertex.getVertices_description": "obtient tous les sommets de la forme",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "obtenir sommets comme points",
    "getVerticesAsPoints": "obtenir sommets comme points",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "obtient tous les sommets comme points",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "sommets vers points",
    "verticesToPoints": "sommets vers points",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforme les sommets en points",
    "transform": "transformer",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "sommet vers point",
    "vertexToPoint": "sommet vers point",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "transforme un sommet en point",
    "bitbybit.occt.shapes.vertex.projectPoints": "projeter points",
    "projectPoints": "projeter points",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "projette les points sur la forme",
    "place": "placer",
    "projectionType": "type projection",
    "pointProjectionTypeEnum": "énumération type projection point",
    "bitbybit.occt.shapes.edge.line": "ligne",
    "edge": "arête",
    "bitbybit.occt.shapes.edge.line_description": "crée une arête linéaire entre deux points",
    "primitives": "primitives",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arc par trois points",
    "arcThroughThreePoints": "arc par trois points",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "crée une arête en arc passant par trois points",
    "middle": "milieu",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arc par deux points et tangente",
    "arcThroughTwoPointsAndTangent": "arc par deux points et tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "crée une arête en arc avec tangente au premier point",
    "tangentVec": "vecteur tangente",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arc depuis cercle et deux points",
    "arcFromCircleAndTwoPoints": "arc depuis cercle et deux points",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "crée une arête en arc sur un cercle entre deux points",
    "circle": "cercle",
    "sense": "sens",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arc depuis cercle et deux angles",
    "arcFromCircleAndTwoAngles": "arc depuis cercle et deux angles",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "crée une arête en arc sur un cercle entre deux angles",
    "alphaAngle1": "angle alpha 1",
    "alphaAngle2": "angle alpha 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arc depuis cercle point et angle",
    "arcFromCirclePointAndAngle": "arc depuis cercle point et angle",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "crée une arête en arc sur un cercle d'un point à un angle",
    "alphaAngle": "angle alpha",
    "bitbybit.occt.shapes.edge.createCircleEdge": "arête cercle",
    "createCircleEdge": "arête cercle",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "crée une arête de cercle opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "arête ellipse",
    "createEllipseEdge": "arête ellipse",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "crée une arête d'ellipse opencascade",
    "radiusMinor": "rayon mineur",
    "radiusMajor": "rayon majeur",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "supprimer arêtes internes",
    "removeInternalEdges": "supprimer arêtes internes",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "supprime les arêtes internes de la forme",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "créer arête depuis courbe geom 2d et surface",
    "makeEdgeFromGeom2dCurveAndSurface": "créer arête depuis courbe geom 2d et surface",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "crée une arête à partir d'une courbe géométrique et d'une surface",
    "curve": "courbe",
    "surface": "surface",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "obtenir arête",
    "getEdge": "obtenir arête",
    "bitbybit.occt.shapes.edge.getEdge_description": "obtient l'arête par index de la forme",
    "index": "index",
    "bitbybit.occt.shapes.edge.getEdges": "obtenir arêtes",
    "getEdges": "obtenir arêtes",
    "bitbybit.occt.shapes.edge.getEdges_description": "obtient les arêtes de la forme",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "obtenir arêtes le long du fil",
    "getEdgesAlongWire": "obtenir arêtes le long du fil",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "obtient les arêtes le long de la direction du fil",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "obtenir arêtes circulaires le long du fil",
    "getCircularEdgesAlongWire": "obtenir arêtes circulaires le long du fil",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "obtient les arêtes circulaires le long de la direction du fil",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "obtenir arêtes linéaires le long du fil",
    "getLinearEdgesAlongWire": "obtenir arêtes linéaires le long du fil",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "obtient les arêtes linéaires le long de la direction du fil",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "obtenir points coins arêtes pour forme",
    "getCornerPointsOfEdgesForShape": "obtenir points coins arêtes pour forme",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "obtient les points de coin uniques des arêtes",
    "bitbybit.occt.shapes.edge.getEdgeLength": "obtenir longueur arête",
    "getEdgeLength": "obtenir longueur arête",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "obtient la longueur de l'arête",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "obtenir longueurs arêtes de forme",
    "getEdgeLengthsOfShape": "obtenir longueurs arêtes de forme",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "obtient les longueurs des arêtes de la forme",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "obtenir longueurs arêtes",
    "getEdgesLengths": "obtenir longueurs arêtes",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "obtient les longueurs des arêtes",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "obtenir centre masse arête",
    "getEdgeCenterOfMass": "obtenir centre masse arête",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "obtient le centre de masse de l'arête",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "obtenir centres masse arêtes",
    "getEdgesCentersOfMass": "obtenir centres masse arêtes",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "obtient les centres de masse des arêtes",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "obtenir point centre arête circulaire",
    "getCircularEdgeCenterPoint": "obtenir point centre arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "obtient le point central de l'arête circulaire",
    "get circular edge": "obtenir arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "obtenir rayon arête circulaire",
    "getCircularEdgeRadius": "obtenir rayon arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "obtient le rayon de l'arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "obtenir direction plan arête circulaire",
    "getCircularEdgePlaneDirection": "obtenir direction plan arête circulaire",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "obtient la direction du plan de l'arête circulaire",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "point sur arête au param",
    "pointOnEdgeAtParam": "point sur arête au param",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "obtient un point sur l'arête au paramètre",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "points sur arêtes au param",
    "pointsOnEdgesAtParam": "points sur arêtes au param",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "obtient des points sur les arêtes au paramètre",
    "bitbybit.occt.shapes.edge.edgesToPoints": "arêtes vers points",
    "edgesToPoints": "arêtes vers points",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "obtient les points des arêtes dans des listes séparées",
    "angularDeflection": "déviation angulaire",
    "curvatureDeflection": "déviation courbure",
    "minimumOfPoints": "minimum de points",
    "uTolerance": "tolérance u",
    "minimumLength": "longueur minimale",
    "bitbybit.occt.shapes.edge.reversedEdge": "arête inversée",
    "reversedEdge": "arête inversée",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "calcule l'arête inversée",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangente sur arête au param",
    "tangentOnEdgeAtParam": "tangente sur arête au param",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "obtient le vecteur tangent sur l'arête au paramètre",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangentes sur arêtes au param",
    "tangentsOnEdgesAtParam": "tangentes sur arêtes au param",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "obtient les vecteurs tangents sur les arêtes au paramètre",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "point sur arête à la longueur",
    "pointOnEdgeAtLength": "point sur arête à la longueur",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "obtient un point sur l'arête à la longueur",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "points sur arêtes à la longueur",
    "pointsOnEdgesAtLength": "points sur arêtes à la longueur",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "obtient des points sur les arêtes à la longueur",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangente sur arête à la longueur",
    "tangentOnEdgeAtLength": "tangente sur arête à la longueur",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "obtient le vecteur tangent sur l'arête à la longueur",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangentes sur arêtes à la longueur",
    "tangentsOnEdgesAtLength": "tangentes sur arêtes à la longueur",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "obtient les vecteurs tangents sur les arêtes à la longueur",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "point départ sur arête",
    "startPointOnEdge": "point départ sur arête",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "obtient le point de départ sur l'arête",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "points départ sur arêtes",
    "startPointsOnEdges": "points départ sur arêtes",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "obtient les points de départ sur les arêtes",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "point arrivée sur arête",
    "endPointOnEdge": "point arrivée sur arête",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "obtient le point d'arrivée sur l'arête",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "points arrivée sur arêtes",
    "endPointsOnEdges": "points arrivée sur arêtes",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "obtient les points d'arrivée sur les arêtes",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "diviser arête par params en points",
    "divideEdgeByParamsToPoints": "diviser arête par params en points",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divise l'arête par paramètres en points",
    "nrOfDivisions": "nb divisions",
    "removeStartPoint": "supprimer point départ",
    "removeEndPoint": "supprimer point arrivée",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "diviser arêtes par params en points",
    "divideEdgesByParamsToPoints": "diviser arêtes par params en points",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divise les arêtes par paramètres en points",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "diviser arête par distance égale en points",
    "divideEdgeByEqualDistanceToPoints": "diviser arête par distance égale en points",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divise l'arête par longueur en points",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "diviser arêtes par distance égale en points",
    "divideEdgesByEqualDistanceToPoints": "diviser arêtes par distance égale en points",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divise les arêtes par longueur en points",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "lignes tan contraintes de deux pts à cercle",
    "constraintTanLinesFromTwoPtsToCircle": "lignes tan contraintes de deux pts à cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "crée des lignes des deux points aux tangentes du cercle",
    "constraint": "contrainte",
    "point1": "point 1",
    "point2": "point 2",
    "positionResult": "résultat position",
    "positionResultEnum": "énumération résultat position",
    "circleRemainder": "reste cercle",
    "circleInclusionEnum": "énumération inclusion cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "lignes tan contraintes de pt à cercle",
    "constraintTanLinesFromPtToCircle": "lignes tan contraintes de pt à cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "crée des lignes du point aux tangentes du cercle",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "lignes tan contraintes sur deux cercles",
    "constraintTanLinesOnTwoCircles": "lignes tan contraintes sur deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "crée des lignes tangentes entre deux cercles",
    "circle1": "cercle 1",
    "circle2": "cercle 2",
    "circleRemainders": "restes cercles",
    "twoCircleInclusionEnum": "énumération inclusion deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "cercles tan contraints sur deux cercles",
    "constraintTanCirclesOnTwoCircles": "cercles tan contraints sur deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "crée des cercles tangents entre deux cercles",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "cercles tan contraints sur cercle et pt",
    "constraintTanCirclesOnCircleAndPnt": "cercles tan contraints sur cercle et pt",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "crée des cercles tangents entre un point et un cercle",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "est arête linéaire",
    "isEdgeLinear": "est arête linéaire",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "vérifie si l'arête est linéaire",
    "is": "est",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "est arête circulaire",
    "isEdgeCircular": "est arête circulaire",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "vérifie si l'arête est circulaire",
    "bitbybit.occt.shapes.wire.createPolygonWire": "fil polygone",
    "wire": "fil",
    "createPolygonWire": "fil polygone",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "crée un fil polygone opencascade",
    "via points": "via points",
    "bitbybit.occt.shapes.wire.createPolygons": "polygones",
    "createPolygons": "polygones",
    "bitbybit.occt.shapes.wire.createPolygons_description": "crée des polygones opencascade",
    "multiple": "multiple",
    "polygons": "polygones",
    "PolygonDto[]": "tableau dto polygone",
    "returnCompound": "retourner composé",
    "bitbybit.occt.shapes.wire.createLineWire": "fil ligne",
    "createLineWire": "fil ligne",
    "bitbybit.occt.shapes.wire.createLineWire_description": "crée un fil ligne opencascade",
    "bitbybit.occt.shapes.wire.createLines": "lignes",
    "createLines": "lignes",
    "bitbybit.occt.shapes.wire.createLines_description": "crée des lignes opencascade",
    "LineDto[]": "tableau dto ligne",
    "bitbybit.occt.shapes.wire.splitOnPoints": "diviser sur points",
    "splitOnPoints": "diviser sur points",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "divise le fil sur les points donnés",
    "bitbybit.occt.shapes.wire.wiresToPoints": "fils vers points",
    "wiresToPoints": "fils vers points",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "transforme les fils en points dans des listes ordonnées",
    "bitbybit.occt.shapes.wire.createPolylineWire": "fil polyligne",
    "createPolylineWire": "fil polyligne",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "crée un fil polyligne opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zig zag entre deux fils",
    "createZigZagBetweenTwoWires": "zig zag entre deux fils",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "crée un zig zag entre deux fils",
    "via wires": "via fils",
    "wire1": "fil 1",
    "wire2": "fil 2",
    "nrZigZags": "nb zig zags",
    "inverse": "inverse",
    "divideByEqualDistance": "diviser par distance égale",
    "zigZagsPerEdge": "zig zags par arête",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "fil depuis deux cercles tan",
    "createWireFromTwoCirclesTan": "fil depuis deux cercles tan",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "crée un fil tangent entourant deux cercles planaires",
    "keepLines": "garder lignes",
    "twoSidesStrictEnum": "énumération strict deux côtés",
    "fourSidesStrictEnum": "énumération strict quatre côtés",
    "bitbybit.occt.shapes.wire.createPolylines": "polylignes",
    "createPolylines": "polylignes",
    "bitbybit.occt.shapes.wire.createPolylines_description": "crée des fils polylignes opencascade",
    "polylines": "polylignes",
    "PolylineDto[]": "tableau dto polyligne",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "crée un fil bezier opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "bezier poids",
    "createBezierWeights": "bezier poids",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "crée un fil bezier opencascade avec poids",
    "weights": "poids",
    "bitbybit.occt.shapes.wire.createBezierWires": "fils bezier",
    "createBezierWires": "fils bezier",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "crée des fils bezier opencascade",
    "bezierWires": "fils bezier",
    "BezierDto[]": "tableau dto bezier",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpoler points",
    "interpolatePoints": "interpoler points",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "crée un fil bspline opencascade à partir de points",
    "periodic": "périodique",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpoler fils",
    "interpolateWires": "interpoler fils",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "crée plusieurs fils interpolés opencascade",
    "interpolations": "interpolations",
    "InterpolationDto[]": "tableau dto interpolation",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "crée un fil bspline opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "crée des fils bspline opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "tableau dto bspline",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combiner arêtes et fils en un fil",
    "combineEdgesAndWiresIntoAWire": "combiner arêtes et fils en un fil",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "combine les arêtes et les fils en un seul fil",
    "build": "construire",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "fil depuis arête",
    "createWireFromEdge": "fil depuis arête",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "crée un fil à partir d'une arête",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "ajouter arêtes et fils au fil",
    "addEdgesAndWiresToWire": "ajouter arêtes et fils au fil",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "ajoute des arêtes et des fils au fil",
    "U[]": "tableau u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "diviser fil par params en points",
    "divideWireByParamsToPoints": "diviser fil par params en points",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "divise le fil en points par paramètres",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "diviser fils par params en points",
    "divideWiresByParamsToPoints": "diviser fils par params en points",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "divise les fils en points par paramètres",
    "extract from wires": "extraire des fils",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "diviser fil par distance égale en points",
    "divideWireByEqualDistanceToPoints": "diviser fil par distance égale en points",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "divise le fil en points à distance égale",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "diviser fils par distance égale en points",
    "divideWiresByEqualDistanceToPoints": "diviser fils par distance égale en points",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "divise les fils en points à distance égale",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "point sur fil au param",
    "pointOnWireAtParam": "point sur fil au param",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "obtient un point sur le fil au paramètre",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "point sur fil à la longueur",
    "pointOnWireAtLength": "point sur fil à la longueur",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "obtient un point sur le fil à la longueur",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "points sur fil aux longueurs",
    "pointsOnWireAtLengths": "points sur fil aux longueurs",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "obtient des points sur le fil aux longueurs",
    "lengths": "longueurs",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "points sur fil à longueur égale",
    "pointsOnWireAtEqualLength": "points sur fil à longueur égale",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "obtient des points sur le fil à longueur égale",
    "tryNext": "essayer suivant",
    "includeFirst": "inclure premier",
    "includeLast": "inclure dernier",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "points sur fil au motif de longueurs",
    "pointsOnWireAtPatternOfLengths": "points sur fil au motif de longueurs",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "obtient des points sur le fil au motif de longueurs",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangente sur fil au param",
    "tangentOnWireAtParam": "tangente sur fil au param",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "obtient le vecteur tangent sur le fil au paramètre",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangente sur fil à la longueur",
    "tangentOnWireAtLength": "tangente sur fil à la longueur",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "obtient le vecteur tangent sur le fil à la longueur",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "dérivées sur fil à la longueur",
    "derivativesOnWireAtLength": "dérivées sur fil à la longueur",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "calcule 3 dérivées sur le fil à la longueur",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "dérivées sur fil au param",
    "derivativesOnWireAtParam": "dérivées sur fil au param",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "calcule 3 dérivées sur le fil au paramètre",
    "bitbybit.occt.shapes.wire.startPointOnWire": "point départ sur fil",
    "startPointOnWire": "point départ sur fil",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "obtient le point de départ sur le fil",
    "bitbybit.occt.shapes.wire.endPointOnWire": "point arrivée sur fil",
    "endPointOnWire": "point arrivée sur fil",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "obtient le point d'arrivée sur le fil",
    "bitbybit.occt.shapes.wire.createCircleWire": "fil cercle",
    "createCircleWire": "fil cercle",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "crée un fil cercle opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "fil carré",
    "createSquareWire": "fil carré",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "crée un fil carré opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "fil étoile",
    "createStarWire": "fil étoile",
    "bitbybit.occt.shapes.wire.createStarWire_description": "crée un fil étoile opencascade",
    "numRays": "nb rayons",
    "outerRadius": "rayon extérieur",
    "innerRadius": "rayon intérieur",
    "offsetOuterEdges": "décalage arêtes extérieures",
    "half": "moitié",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "fil sapin noël",
    "createChristmasTreeWire": "fil sapin noël",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "crée un fil en forme de sapin de noël",
    "innerDist": "dist intérieure",
    "outerDist": "dist extérieure",
    "nrSkirts": "nb jupes",
    "trunkHeight": "hauteur tronc",
    "trunkWidth": "largeur tronc",
    "bitbybit.occt.shapes.wire.createNGonWire": "fil ngon",
    "createNGonWire": "fil ngon",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "crée un fil ngon opencascade",
    "nrCorners": "nb coins",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "fil parallélogramme",
    "createParallelogramWire": "fil parallélogramme",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "crée un fil parallélogramme",
    "aroundCenter": "autour centre",
    "bitbybit.occt.shapes.wire.createHeartWire": "fil coeur",
    "createHeartWire": "fil coeur",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "crée un fil coeur",
    "sizeApprox": "taille approx",
    "bitbybit.occt.shapes.wire.createRectangleWire": "fil rectangle",
    "createRectangleWire": "fil rectangle",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "crée un fil rectangle opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "fil polygone L",
    "createLPolygonWire": "fil polygone L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "crée un fil polygone L opencascade",
    "widthFirst": "largeur première",
    "lengthFirst": "longueur première",
    "widthSecond": "largeur seconde",
    "lengthSecond": "longueur seconde",
    "align": "aligner",
    "directionEnum": "énumération direction",
    "bitbybit.occt.shapes.wire.createEllipseWire": "fil ellipse",
    "createEllipseWire": "fil ellipse",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "crée un fil ellipse opencascade",
    "bitbybit.occt.shapes.wire.textWires": "Contours de texte",
    "textWires": "Contours de texte",
    "bitbybit.occt.shapes.wire.textWires_description": "Crée des contours de texte OpenCascade basés sur la police simplex créée par le Dr A. V. Hershey.",
    "xOffset": "décalage x",
    "yOffset": "décalage y",
    "letterSpacing": "espacement des lettres",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "décalage d'extrusion",
    "bitbybit.occt.shapes.wire.getWire": "obtenir fil",
    "getWire": "obtenir fil",
    "bitbybit.occt.shapes.wire.getWire_description": "obtient le fil par index de la forme",
    "bitbybit.occt.shapes.wire.getWires": "obtenir fils",
    "getWires": "obtenir fils",
    "bitbybit.occt.shapes.wire.getWires_description": "obtient tous les fils de la forme",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "obtenir centre masse fil",
    "getWireCenterOfMass": "obtenir centre masse fil",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "obtient le point du centre de masse du fil",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "obtenir centres masse fils",
    "getWiresCentersOfMass": "obtenir centres masse fils",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "obtient les points des centres de masse des fils",
    "bitbybit.occt.shapes.wire.reversedWire": "fil inversé",
    "reversedWire": "fil inversé",
    "bitbybit.occt.shapes.wire.reversedWire_description": "calcule le fil inversé",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "fil inversé depuis arêtes inversées",
    "reversedWireFromReversedEdges": "fil inversé depuis arêtes inversées",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "calcule le fil inversé à partir des arêtes inversées",
    "bitbybit.occt.shapes.wire.isWireClosed": "est fil fermé",
    "isWireClosed": "est fil fermé",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "vérifie si le fil est fermé",
    "bitbybit.occt.shapes.wire.getWireLength": "obtenir longueur fil",
    "getWireLength": "obtenir longueur fil",
    "bitbybit.occt.shapes.wire.getWireLength_description": "obtient la longueur du fil",
    "bitbybit.occt.shapes.wire.getWiresLengths": "obtenir longueurs fils",
    "getWiresLengths": "obtenir longueurs fils",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "obtient les longueurs des fils",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "placer fil sur face",
    "placeWireOnFace": "placer fil sur face",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "place le fil sur la face en utilisant l'espace uv",
    "face": "face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "placer fils sur face",
    "placeWiresOnFace": "placer fils sur face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "place plusieurs fils sur la face en utilisant l'espace uv",
    "wires": "fils",
    "bitbybit.occt.shapes.wire.closeOpenWire": "fermer fil ouvert",
    "closeOpenWire": "fermer fil ouvert",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "ferme le fil ouvert avec une arête droite",
    "bitbybit.occt.shapes.wire.project": "projeter",
    "project": "projeter",
    "bitbybit.occt.shapes.wire.project_description": "projette le fil sur la forme",
    "bitbybit.occt.shapes.wire.projectWires": "projeter fils",
    "projectWires": "projeter fils",
    "bitbybit.occt.shapes.wire.projectWires_description": "projette plusieurs fils sur la forme",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "faces depuis fils sur face",
    "createFacesFromWiresOnFace": "faces depuis fils sur face",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "crée des faces à partir de fils sur une face",
    "inside": "intérieur",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "face depuis fil sur face",
    "createFaceFromWireOnFace": "face depuis fil sur face",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "crée une face à partir d'un fil sur une face",
    "bitbybit.occt.shapes.face.createFaceFromWire": "face depuis fil",
    "createFaceFromWire": "face depuis fil",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "crée une face à partir d'un fil",
    "planar": "planaire",
    "bitbybit.occt.shapes.face.createFaceFromWires": "face depuis fils",
    "createFaceFromWires": "face depuis fils",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "crée une face à partir de fils",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "face depuis fils sur face",
    "createFaceFromWiresOnFace": "face depuis fils sur face",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "crée une face à partir de fils sur une face guide",
    "bitbybit.occt.shapes.face.createFacesFromWires": "faces depuis fils",
    "createFacesFromWires": "faces depuis fils",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "crée des faces à partir de fils",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "face depuis multiples fils tan cercles",
    "createFaceFromMultipleCircleTanWires": "face depuis multiples fils tan cercles",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "crée une face à partir de multiples fils tangents de cercles",
    "circles": "cercles",
    "combination": "combinaison",
    "combinationCirclesForFaceEnum": "énumération combinaison cercles pour face",
    "unify": "unifier",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "face depuis multiples collections fils tan cercles",
    "createFaceFromMultipleCircleTanWireCollections": "face depuis multiples collections fils tan cercles",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "crée une face à partir de multiples collections de fils tangents de cercles",
    "listsOfCircles": "listes de cercles",
    "T[][]": "tableau tableau t",
    "bitbybit.occt.shapes.face.faceFromSurface": "face depuis surface",
    "faceFromSurface": "face depuis surface",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "crée une face à partir d'une surface",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "face depuis surface et fil",
    "faceFromSurfaceAndWire": "face depuis surface et fil",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "crée une face à partir d'une surface et d'un fil",
    "bitbybit.occt.shapes.face.createPolygonFace": "face polygone",
    "createPolygonFace": "face polygone",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "crée une face polygone opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "face cercle",
    "createCircleFace": "face cercle",
    "bitbybit.occt.shapes.face.createCircleFace_description": "crée une face cercle opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "face ellipse",
    "createEllipseFace": "face ellipse",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "crée une face ellipse opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "face carrée",
    "createSquareFace": "face carrée",
    "bitbybit.occt.shapes.face.createSquareFace_description": "crée une face carrée opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "face rectangle",
    "createRectangleFace": "face rectangle",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "crée une face rectangle opencascade",
    "bitbybit.occt.shapes.face.getFace": "obtenir face",
    "getFace": "obtenir face",
    "bitbybit.occt.shapes.face.getFace_description": "obtient la face par index de la forme",
    "bitbybit.occt.shapes.face.getFaces": "obtenir faces",
    "getFaces": "obtenir faces",
    "bitbybit.occt.shapes.face.getFaces_description": "obtient les faces de la forme",
    "bitbybit.occt.shapes.face.reversedFace": "face inversée",
    "reversedFace": "face inversée",
    "bitbybit.occt.shapes.face.reversedFace_description": "calcule la face inversée",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdiviser en points",
    "subdivideToPoints": "subdiviser en points",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "subdivise la face en grille de points",
    "nrDivisionsU": "nb divisions u",
    "nrDivisionsV": "nb divisions v",
    "shiftHalfStepU": "décaler demi pas u",
    "removeStartEdgeU": "supprimer arête début u",
    "removeEndEdgeU": "supprimer arête fin u",
    "shiftHalfStepV": "décaler demi pas v",
    "removeStartEdgeV": "supprimer arête début v",
    "removeEndEdgeV": "supprimer arête fin v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdiviser en fils",
    "subdivideToWires": "subdiviser en fils",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "subdivise la face en fils",
    "nrDivisions": "nb divisions",
    "isU": "est u",
    "shiftHalfStep": "décaler demi pas",
    "removeStart": "supprimer début",
    "removeEnd": "supprimer fin",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdiviser en fils rectangle",
    "subdivideToRectangleWires": "subdiviser en fils rectangle",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "subdivise la face en fils rectangle",
    "patterns": "motifs",
    "nrRectanglesU": "nb rectangles u",
    "nrRectanglesV": "nb rectangles v",
    "scalePatternU": "motif échelle u",
    "scalePatternV": "motif échelle v",
    "filletPattern": "motif congé",
    "inclusionPattern": "motif inclusion",
    "offsetFromBorderU": "décalage bordure u",
    "offsetFromBorderV": "décalage bordure v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdiviser en trous rectangle",
    "subdivideToRectangleHoles": "subdiviser en trous rectangle",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "subdivise la face en fils rectangle",
    "holesToFaces": "trous vers faces",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdiviser en points contrôlés",
    "subdivideToPointsControlled": "subdiviser en points contrôlés",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "subdivise la face en grille de points avec décalages contrôlés",
    "shiftHalfStepNthU": "décaler demi pas nième u",
    "shiftHalfStepUOffsetN": "décaler demi pas décalage u n",
    "removeStartEdgeNthU": "supprimer arête début nième u",
    "removeStartEdgeUOffsetN": "supprimer arête début décalage u n",
    "removeEndEdgeNthU": "supprimer arête fin nième u",
    "removeEndEdgeUOffsetN": "supprimer arête fin décalage u n",
    "shiftHalfStepNthV": "décaler demi pas nième v",
    "shiftHalfStepVOffsetN": "décaler demi pas décalage v n",
    "removeStartEdgeNthV": "supprimer arête début nième v",
    "removeStartEdgeVOffsetN": "supprimer arête début décalage v n",
    "removeEndEdgeNthV": "supprimer arête fin nième v",
    "removeEndEdgeVOffsetN": "supprimer arête fin décalage v n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdiviser en normales",
    "subdivideToNormals": "subdiviser en normales",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "subdivise la face en grille de normales",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdiviser en uv",
    "subdivideToUV": "subdiviser en uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "subdivise la face en grille uv",
    "bitbybit.occt.shapes.face.pointOnUV": "point sur uv",
    "pointOnUV": "point sur uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "obtient un point sur uv mappé aux limites",
    "paramU": "param u",
    "paramV": "param v",
    "bitbybit.occt.shapes.face.normalOnUV": "normale sur uv",
    "normalOnUV": "normale sur uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "obtient la normale sur uv mappée aux limites",
    "bitbybit.occt.shapes.face.pointsOnUVs": "points sur uvs",
    "pointsOnUVs": "points sur uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "obtient des points sur uvs mappés aux limites",
    "paramsUV": "params uv",
    "[number, number][]": "tableau paire nombres",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normales sur uvs",
    "normalsOnUVs": "normales sur uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "obtient les normales sur uvs mappées aux limites",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdiviser en points sur param",
    "subdivideToPointsOnParam": "subdiviser en points sur param",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "subdivise la face en points sur paramètre",
    "nrPoints": "nb points",
    "bitbybit.occt.shapes.face.wireAlongParam": "fil le long param",
    "wireAlongParam": "fil le long param",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "obtient le fil le long du paramètre sur la face",
    "bitbybit.occt.shapes.face.wiresAlongParams": "fils le long params",
    "wiresAlongParams": "fils le long params",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "obtient les fils le long des paramètres sur la face",
    "params": "params",
    "bitbybit.occt.shapes.face.getUMinBound": "obtenir borne u min",
    "getUMinBound": "obtenir borne u min",
    "bitbybit.occt.shapes.face.getUMinBound_description": "obtient la borne u minimale de la face",
    "bitbybit.occt.shapes.face.getUMaxBound": "obtenir borne u max",
    "getUMaxBound": "obtenir borne u max",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "obtient la borne u maximale de la face",
    "bitbybit.occt.shapes.face.getVMinBound": "obtenir borne v min",
    "getVMinBound": "obtenir borne v min",
    "bitbybit.occt.shapes.face.getVMinBound_description": "obtient la borne v minimale de la face",
    "bitbybit.occt.shapes.face.getVMaxBound": "obtenir borne v max",
    "getVMaxBound": "obtenir borne v max",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "obtient la borne v maximale de la face",
    "bitbybit.occt.shapes.face.getFaceArea": "obtenir aire face",
    "getFaceArea": "obtenir aire face",
    "bitbybit.occt.shapes.face.getFaceArea_description": "obtient l'aire de la face",
    "bitbybit.occt.shapes.face.getFacesAreas": "obtenir aires faces",
    "getFacesAreas": "obtenir aires faces",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "obtient les aires des faces",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "obtenir centre masse face",
    "getFaceCenterOfMass": "obtenir centre masse face",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "obtient le point du centre de masse de la face",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "obtenir centres masse faces",
    "getFacesCentersOfMass": "obtenir centres masse faces",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "obtient les centres de masse des faces",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtrer points face",
    "filterFacePoints": "filtrer points face",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtre les points sur la face",
    "filter": "filtrer",
    "useBndBox": "utiliser bnd box",
    "gapTolerance": "tolérance écart",
    "keepIn": "garder dedans",
    "keepOn": "garder dessus",
    "keepOut": "garder dehors",
    "keepUnknown": "garder inconnu",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtrer points faces",
    "filterFacesPoints": "filtrer points faces",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtre les points sur les faces",
    "flatPointsArray": "tableau points plat",
    "bitbybit.occt.shapes.shell.sewFaces": "coudre faces",
    "shell": "coque",
    "sewFaces": "coudre faces",
    "bitbybit.occt.shapes.shell.sewFaces_description": "crée une coque à partir de faces",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "obtenir aire surface coque",
    "getShellSurfaceArea": "obtenir aire surface coque",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "obtient l'aire de la surface de la coque",
    "bitbybit.occt.shapes.solid.fromClosedShell": "depuis coque fermée",
    "solid": "solide",
    "fromClosedShell": "depuis coque fermée",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "crée un solide à partir d'une coque fermée",
    "bitbybit.occt.shapes.solid.createBox": "boîte",
    "bitbybit.occt.shapes.solid.createBox_description": "crée une boîte opencascade",
    "originOnCenter": "origine au centre",
    "bitbybit.occt.shapes.solid.createCube": "cube",
    "bitbybit.occt.shapes.solid.createCube_description": "crée un cube opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "boîte depuis coin",
    "createBoxFromCorner": "boîte depuis coin",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "crée une boîte opencascade depuis le coin",
    "corner": "coin",
    "bitbybit.occt.shapes.solid.createCylinder": "cylindre",
    "bitbybit.occt.shapes.solid.createCylinder_description": "crée un cylindre opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cylindres sur lignes",
    "createCylindersOnLines": "cylindres sur lignes",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "crée des cylindres opencascade sur des lignes",
    "Base.Line3[]": "tableau ligne3 base",
    "bitbybit.occt.shapes.solid.createSphere": "sphère",
    "bitbybit.occt.shapes.solid.createSphere_description": "crée une sphère opencascade",
    "bitbybit.occt.shapes.solid.createCone": "cône",
    "createCone": "cône",
    "bitbybit.occt.shapes.solid.createCone_description": "crée un cône opencascade",
    "radius1": "rayon 1",
    "radius2": "rayon 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "obtenir aire surface solide",
    "getSolidSurfaceArea": "obtenir aire surface solide",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "obtient l'aire de la surface du solide",
    "bitbybit.occt.shapes.solid.getSolidVolume": "obtenir volume solide",
    "getSolidVolume": "obtenir volume solide",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "obtient le volume du solide",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "obtenir volumes solides",
    "getSolidsVolumes": "obtenir volumes solides",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "obtient les volumes des solides",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "obtenir centre masse solide",
    "getSolidCenterOfMass": "obtenir centre masse solide",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "obtient le centre de masse du solide",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "obtenir centres masse solides",
    "getSolidsCentersOfMass": "obtenir centres masse solides",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "obtient les centres de masse des solides",
    "bitbybit.occt.shapes.solid.getSolids": "obtenir solides",
    "getSolids": "obtenir solides",
    "bitbybit.occt.shapes.solid.getSolids_description": "obtient les solides de la forme",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtrer points solides",
    "filterSolidPoints": "filtrer points solides",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "filtre les points en fonction de la relation avec le solide",
    "bitbybit.occt.shapes.compound.makeCompound": "créer composé",
    "compound": "composé",
    "makeCompound": "créer composé",
    "bitbybit.occt.shapes.compound.makeCompound_description": "crée une forme composée à partir de formes",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "obtenir formes composé",
    "getShapesOfCompound": "obtenir formes composé",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "obtient les formes du composé",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "purger arêtes internes",
    "purgeInternalEdges": "purger arêtes internes",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "supprime les arêtes internes de la forme",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unifier même domaine",
    "unifySameDomain": "unifier même domaine",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "unifie les faces et les arêtes dans le même domaine",
    "unifyEdges": "unifier arêtes",
    "unifyFaces": "unifier faces",
    "concatBSplines": "concaténer bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "est fermé",
    "bitbybit.occt.shapes.shape.isClosed_description": "vérifie si la forme est fermée",
    "analysis": "analyse",
    "bitbybit.occt.shapes.shape.isConvex": "est convexe",
    "isConvex": "est convexe",
    "bitbybit.occt.shapes.shape.isConvex_description": "vérifie si la forme est convexe",
    "bitbybit.occt.shapes.shape.isChecked": "est vérifié",
    "bitbybit.occt.shapes.shape.isChecked_description": "vérifie si la forme est vérifiée",
    "bitbybit.occt.shapes.shape.isFree": "est libre",
    "isFree": "est libre",
    "bitbybit.occt.shapes.shape.isFree_description": "vérifie si la forme est libre",
    "bitbybit.occt.shapes.shape.isInfinite": "est infini",
    "isInfinite": "est infini",
    "bitbybit.occt.shapes.shape.isInfinite_description": "vérifie si la forme est infinie",
    "bitbybit.occt.shapes.shape.isModified": "est modifié",
    "isModified": "est modifié",
    "bitbybit.occt.shapes.shape.isModified_description": "vérifie si la forme est modifiée",
    "bitbybit.occt.shapes.shape.isLocked": "est verrouillé",
    "isLocked": "est verrouillé",
    "bitbybit.occt.shapes.shape.isLocked_description": "vérifie si la forme est verrouillée",
    "bitbybit.occt.shapes.shape.isNull": "est nul",
    "isNull": "est nul",
    "bitbybit.occt.shapes.shape.isNull_description": "vérifie si la forme est nulle",
    "bitbybit.occt.shapes.shape.isEqual": "est égal",
    "isEqual": "est égal",
    "bitbybit.occt.shapes.shape.isEqual_description": "vérifie si la forme est égale à une autre forme",
    "otherShape": "autre forme",
    "bitbybit.occt.shapes.shape.isNotEqual": "est différent",
    "isNotEqual": "est différent",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "vérifie si la forme diffère d'une autre forme",
    "bitbybit.occt.shapes.shape.isPartner": "est partenaire",
    "isPartner": "est partenaire",
    "bitbybit.occt.shapes.shape.isPartner_description": "vérifie si la forme est partenaire d'une autre forme",
    "bitbybit.occt.shapes.shape.isSame": "est même",
    "isSame": "est même",
    "bitbybit.occt.shapes.shape.isSame_description": "vérifie si la forme est la même qu'une autre forme",
    "bitbybit.occt.shapes.shape.getOrientation": "obtenir orientation",
    "getOrientation": "obtenir orientation",
    "bitbybit.occt.shapes.shape.getOrientation_description": "obtient l'orientation de la forme",
    "bitbybit.occt.shapes.shape.getShapeType": "obtenir type forme",
    "getShapeType": "obtenir type forme",
    "bitbybit.occt.shapes.shape.getShapeType_description": "obtient le type de la forme",
    "bitbybit.occt.geom.curves.geom2dEllipse": "geom ellipse 2d",
    "geom": "geom",
    "curves": "courbes",
    "geom2dEllipse": "geom ellipse 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "crée une ellipse 2d pour la modélisation",
    "Base.Point2": "point2 base",
    "Base.Vector2": "vecteur2 base",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "geom courbe découpée 2d",
    "geom2dTrimmedCurve": "geom courbe découpée 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "crée une courbe découpée entre u1 et u2",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "ajuster périodique",
    "bitbybit.occt.geom.curves.geom2dSegment": "geom segment 2d",
    "geom2dSegment": "geom segment 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "crée un segment de courbe 2d entre deux points",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "obtenir point 2d depuis courbe 2d sur param",
    "get2dPointFrom2dCurveOnParam": "obtenir point 2d depuis courbe 2d sur param",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "obtient un point 2d sur la courbe au paramètre",
    "bitbybit.occt.geom.curves.geomCircleCurve": "geom courbe cercle",
    "geomCircleCurve": "geom courbe cercle",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "crée une courbe géométrique cercle",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "geom courbe ellipse",
    "geomEllipseCurve": "geom courbe ellipse",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "crée une courbe géométrique ellipse",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "surface cylindrique",
    "surfaces": "surfaces",
    "cylindricalSurface": "surface cylindrique",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "crée une surface cylindrique infinie pour la modélisation",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "surface depuis face",
    "surfaceFromFace": "surface depuis face",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "crée une surface à partir d'une face",
    "bitbybit.occt.fillets.filletEdges": "congé arêtes",
    "fillets": "congés",
    "filletEdges": "congé arêtes",
    "bitbybit.occt.fillets.filletEdges_description": "arrondit les formes opencascade",
    "3d fillets": "congés 3d",
    "radiusList": "liste rayons",
    "indexes": "indices",
    "bitbybit.occt.fillets.filletEdgesList": "liste congé arêtes",
    "filletEdgesList": "liste congé arêtes",
    "bitbybit.occt.fillets.filletEdgesList_description": "arrondit les arêtes avec différents rayons",
    "edges": "arêtes",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "liste congé arêtes un rayon",
    "filletEdgesListOneRadius": "liste congé arêtes un rayon",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "arrondit les arêtes avec un seul rayon",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "congé arête rayon variable",
    "filletEdgeVariableRadius": "congé arête rayon variable",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "arrondit l'arête avec un rayon variable sur les paramètres u",
    "paramsU": "params u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "congé arêtes même rayon variable",
    "filletEdgesSameVariableRadius": "congé arêtes même rayon variable",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "arrondit les arêtes avec les mêmes rayons variables",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "congé arêtes rayon variable",
    "filletEdgesVariableRadius": "congé arêtes rayon variable",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "arrondit les arêtes avec des rayons variables sur les paramètres",
    "radiusLists": "listes rayons",
    "paramsULists": "listes params u",
    "bitbybit.occt.fillets.fillet3DWire": "congé fil 3d",
    "fillet3DWire": "congé fil 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "arrondit le fil 3d avec une direction guide",
    "bitbybit.occt.fillets.fillet3DWires": "congé fils 3d",
    "fillet3DWires": "congé fils 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "arrondit les fils 3d avec une direction guide",
    "bitbybit.occt.fillets.chamferEdges": "chanfrein arêtes",
    "chamferEdges": "chanfrein arêtes",
    "bitbybit.occt.fillets.chamferEdges_description": "chanfreine les arêtes de forme opencascade",
    "3d chamfers": "chanfreins 3d",
    "distanceList": "liste distances",
    "bitbybit.occt.fillets.chamferEdgesList": "liste chanfrein arêtes",
    "chamferEdgesList": "liste chanfrein arêtes",
    "bitbybit.occt.fillets.chamferEdgesList_description": "chanfreine les arêtes avec différentes distances",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "chanfrein arête deux distances",
    "chamferEdgeTwoDistances": "chanfrein arête deux distances",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "chanfreine l'arête avec deux distances",
    "F": "f",
    "distance1": "distance 1",
    "distance2": "distance 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "chanfrein arêtes deux distances",
    "chamferEdgesTwoDistances": "chanfrein arêtes deux distances",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "chanfreine les arêtes avec deux distances",
    "faces": "faces",
    "F[]": "tableau f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "listes chanfrein arêtes deux distances",
    "chamferEdgesTwoDistancesLists": "listes chanfrein arêtes deux distances",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "chanfreine les arêtes avec deux listes de distances",
    "distances1": "distances 1",
    "distances2": "distances 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "chanfrein arête dist angle",
    "chamferEdgeDistAngle": "chanfrein arête dist angle",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "chanfreine l'arête avec une distance et un angle",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "chanfrein arêtes dist angle",
    "chamferEdgesDistAngle": "chanfrein arêtes dist angle",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "chanfreine les arêtes avec une distance et un angle",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "chanfrein arêtes dists angles",
    "chamferEdgesDistsAngles": "chanfrein arêtes dists angles",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "chanfreine les arêtes avec des distances et des angles",
    "distances": "distances",
    "bitbybit.occt.fillets.fillet2d": "congé 2d",
    "fillet2d": "congé 2d",
    "bitbybit.occt.fillets.fillet2d_description": "arrondit un fil ou une face 2d",
    "2d fillets": "congés 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "congé formes 2d",
    "fillet2dShapes": "congé formes 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "arrondit des fils ou des faces 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "congé deux arêtes dans plan en un fil",
    "filletTwoEdgesInPlaneIntoAWire": "congé deux arêtes dans plan en un fil",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "arrondit deux arêtes planaires en un fil",
    "edge1": "arête 1",
    "edge2": "arête 2",
    "planeOrigin": "origine plan",
    "planeDirection": "direction plan",
    "solution": "solution",
    "bitbybit.occt.transforms.transform": "transformer",
    "bitbybit.occt.transforms.transform_description": "transforme la forme",
    "on single shape": "sur forme unique",
    "rotationAxis": "axe rotation",
    "rotationAngle": "angle rotation",
    "scaleFactor": "facteur échelle",
    "bitbybit.occt.transforms.rotate": "pivoter",
    "bitbybit.occt.transforms.rotate_description": "pivote la forme",
    "bitbybit.occt.transforms.rotateAroundCenter": "pivoter autour centre",
    "rotateAroundCenter": "pivoter autour centre",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "pivote la forme autour du centre",
    "bitbybit.occt.transforms.align": "aligner",
    "bitbybit.occt.transforms.align_description": "aligne la forme",
    "fromOrigin": "depuis origine",
    "fromDirection": "depuis direction",
    "toOrigin": "vers origine",
    "toDirection": "vers direction",
    "bitbybit.occt.transforms.alignAndTranslate": "aligner et translater",
    "alignAndTranslate": "aligner et translater",
    "bitbybit.occt.transforms.alignAndTranslate_description": "aligne et translate la forme",
    "bitbybit.occt.transforms.translate": "translater",
    "bitbybit.occt.transforms.translate_description": "translate la forme",
    "bitbybit.occt.transforms.scale": "mettre à l'échelle",
    "bitbybit.occt.transforms.scale_description": "met à l'échelle la forme",
    "bitbybit.occt.transforms.scale3d": "mettre à l'échelle 3d",
    "scale3d": "mettre à l'échelle 3d",
    "bitbybit.occt.transforms.scale3d_description": "met à l'échelle la forme en 3d",
    "bitbybit.occt.transforms.mirror": "miroir",
    "mirror": "miroir",
    "bitbybit.occt.transforms.mirror_description": "reflète la forme",
    "bitbybit.occt.transforms.mirrorAlongNormal": "miroir le long normale",
    "mirrorAlongNormal": "miroir le long normale",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "reflète la forme le long de la normale et de l'origine",
    "normal": "normale",
    "bitbybit.occt.transforms.transformShapes": "transformer formes",
    "transformShapes": "transformer formes",
    "bitbybit.occt.transforms.transformShapes_description": "transforme un tableau de formes",
    "on shapes": "sur formes",
    "rotationAxes": "axes rotation",
    "rotationAngles": "angles rotation",
    "scaleFactors": "facteurs échelle",
    "bitbybit.occt.transforms.rotateShapes": "pivoter formes",
    "rotateShapes": "pivoter formes",
    "bitbybit.occt.transforms.rotateShapes_description": "pivote les formes",
    "axes": "axes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "pivoter autour centre formes",
    "rotateAroundCenterShapes": "pivoter autour centre formes",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "pivote les formes autour du centre et de l'axe",
    "centers": "centres",
    "bitbybit.occt.transforms.alignShapes": "aligner formes",
    "alignShapes": "aligner formes",
    "bitbybit.occt.transforms.alignShapes_description": "aligne les formes",
    "fromOrigins": "depuis origines",
    "fromDirections": "depuis directions",
    "toOrigins": "vers origines",
    "toDirections": "vers directions",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "aligner et translater formes",
    "alignAndTranslateShapes": "aligner et translater formes",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "aligne et translate les formes",
    "directions": "directions",
    "bitbybit.occt.transforms.translateShapes": "translater formes",
    "translateShapes": "translater formes",
    "bitbybit.occt.transforms.translateShapes_description": "translate les formes",
    "bitbybit.occt.transforms.scaleShapes": "mettre à l'échelle formes",
    "scaleShapes": "mettre à l'échelle formes",
    "bitbybit.occt.transforms.scaleShapes_description": "met à l'échelle les formes",
    "factors": "facteurs",
    "bitbybit.occt.transforms.scale3dShapes": "mettre à l'échelle 3d formes",
    "scale3dShapes": "mettre à l'échelle 3d formes",
    "bitbybit.occt.transforms.scale3dShapes_description": "met à l'échelle les formes en 3d",
    "scales": "échelles",
    "bitbybit.occt.transforms.mirrorShapes": "miroir formes",
    "mirrorShapes": "miroir formes",
    "bitbybit.occt.transforms.mirrorShapes_description": "reflète les formes",
    "origins": "origines",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "miroir le long normale formes",
    "mirrorAlongNormalShapes": "miroir le long normale formes",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "reflète les formes le long de la normale et de l'origine",
    "normals": "normales",
    "bitbybit.occt.operations.loft": "extrusion par sections",
    "operations": "opérations",
    "loft": "extrusion par sections",
    "bitbybit.occt.operations.loft_description": "extrude les fils en coque",
    "lofts": "extrusions par sections",
    "makeSolid": "créer solide",
    "bitbybit.occt.operations.loftAdvanced": "extrusion par sections avancée",
    "loftAdvanced": "extrusion par sections avancée",
    "bitbybit.occt.operations.loftAdvanced_description": "extrude les fils en coque avec options",
    "straight": "droit",
    "nrPeriodicSections": "nb sections périodiques",
    "useSmoothing": "utiliser lissage",
    "maxUDegree": "degré u max",
    "parType": "type param",
    "approxParametrizationTypeEnum": "énumération type paramétrisation approx",
    "startVertex": "sommet départ",
    "endVertex": "sommet arrivée",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "points plus proches entre deux formes",
    "closestPointsBetweenTwoShapes": "points plus proches entre deux formes",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "calcule les points les plus proches entre deux formes",
    "closest pts": "pts plus proches",
    "shape1": "forme 1",
    "shape2": "forme 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "points plus proches sur forme depuis points",
    "closestPointsOnShapeFromPoints": "points plus proches sur forme depuis points",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "calcule les points les plus proches des points à la forme",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "points plus proches sur formes depuis points",
    "closestPointsOnShapesFromPoints": "points plus proches sur formes depuis points",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "calcule les points les plus proches des points aux formes",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distances à forme depuis points",
    "distancesToShapeFromPoints": "distances à forme depuis points",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "calcule les distances des points à la forme",
    "bitbybit.occt.operations.boundingBoxOfShape": "boîte englobante de la forme",
    "boundingBoxOfShape": "boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "Calcule les paramètres de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "minimum de la boîte englobante de la forme",
    "boundingBoxMinOfShape": "minimum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "Obtient le point minimum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "maximum de la boîte englobante de la forme",
    "boundingBoxMaxOfShape": "maximum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "Obtient le point maximum de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "centre de la boîte englobante de la forme",
    "boundingBoxCenterOfShape": "centre de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "Obtient le point central de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "taille de la boîte englobante de la forme",
    "boundingBoxSizeOfShape": "taille de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "Obtient le point de taille de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "forme de la boîte englobante de la forme",
    "boundingBoxShapeOfShape": "forme de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "Obtient la forme de la boîte englobante de la forme",
    "bitbybit.occt.operations.boundingSphereOfShape": "sphère englobante de la forme",
    "boundingSphereOfShape": "sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "Calcule les paramètres de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "centre de la sphère englobante de la forme",
    "boundingSphereCenterOfShape": "centre de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "Obtient le point central de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "rayon de la sphère englobante de la forme",
    "boundingSphereRadiusOfShape": "rayon de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "Obtient le rayon de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "forme de la sphère englobante de la forme",
    "boundingSphereShapeOfShape": "forme de la sphère englobante de la forme",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "Obtient la forme de la sphère englobante de la forme",
    "bitbybit.occt.operations.extrude": "extruder",
    "extrude": "extruder",
    "bitbybit.occt.operations.extrude_description": "extrude la forme le long de la direction",
    "extrusions": "extrusions",
    "bitbybit.occt.operations.extrudeShapes": "extruder formes",
    "extrudeShapes": "extruder formes",
    "bitbybit.occt.operations.extrudeShapes_description": "extrude les formes le long de la direction",
    "bitbybit.occt.operations.splitShapeWithShapes": "diviser forme avec formes",
    "splitShapeWithShapes": "diviser forme avec formes",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "divise la forme avec des formes",
    "divisions": "divisions",
    "localFuzzyTolerance": "tolérance floue locale",
    "nonDestructive": "non destructif",
    "bitbybit.occt.operations.revolve": "révolution",
    "revolve": "révolution",
    "bitbybit.occt.operations.revolve_description": "fait tourner la forme autour de la direction",
    "revolutions": "révolutions",
    "copy": "copier",
    "bitbybit.occt.operations.rotatedExtrude": "extrusion pivotée",
    "rotatedExtrude": "extrusion pivotée",
    "bitbybit.occt.operations.rotatedExtrude_description": "effectue une extrusion pivotée sur la forme",
    "bitbybit.occt.operations.pipe": "tuyau",
    "pipe": "tuyau",
    "bitbybit.occt.operations.pipe_description": "crée des tuyaux de formes le long du fil",
    "pipeing": "tuyauterie",
    "bitbybit.occt.operations.pipePolylineWireNGon": "tuyau fil polyligne ngon",
    "pipePolylineWireNGon": "tuyau fil polyligne ngon",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "crée un tuyau de fil polyligne avec un profil ngon",
    "trihedronEnum": "énumération trièdre",
    "geomFillTrihedronEnum": "énumération trièdre remplissage geom",
    "forceApproxC1": "forcer approx c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "tuyaux fils cylindriques",
    "pipeWiresCylindrical": "tuyaux fils cylindriques",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "crée des tuyaux de fils de forme cylindrique",
    "bitbybit.occt.operations.pipeWireCylindrical": "tuyau fil cylindrique",
    "pipeWireCylindrical": "tuyau fil cylindrique",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "crée un tuyau de fil de forme cylindrique",
    "bitbybit.occt.operations.offset": "décalage",
    "bitbybit.occt.operations.offset_description": "décale les formes",
    "offsets": "décalages",
    "bitbybit.occt.operations.offsetAdv": "décalage avancé",
    "offsetAdv": "décalage avancé",
    "bitbybit.occt.operations.offsetAdv_description": "décale avec des options avancées",
    "joinType": "type jonction",
    "joinTypeEnum": "énumération type jonction",
    "removeIntEdges": "supprimer arêtes int",
    "bitbybit.occt.operations.makeThickSolidSimple": "créer solide épais simple",
    "makeThickSolidSimple": "créer solide épais simple",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "épaissit la forme en solide",
    "bitbybit.occt.operations.makeThickSolidByJoin": "créer solide épais par jonction",
    "makeThickSolidByJoin": "créer solide épais par jonction",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "épaissit la forme en solide par jonction",
    "intersection": "intersection",
    "selfIntersection": "auto-intersection",
    "bitbybit.occt.operations.slice": "trancher",
    "slice": "trancher",
    "bitbybit.occt.operations.slice_description": "tranche la forme",
    "bitbybit.occt.operations.sliceInStepPattern": "trancher en motif pas",
    "sliceInStepPattern": "trancher en motif pas",
    "bitbybit.occt.operations.sliceInStepPattern_description": "tranche la forme en motif de pas",
    "steps": "pas",
    "bitbybit.occt.operations.offset3DWire": "décalage fil 3d",
    "offset3DWire": "décalage fil 3d",
    "bitbybit.occt.operations.offset3DWire_description": "décale le fil 3d",
    "bitbybit.occt.booleans.union": "union",
    "booleans": "booléens",
    "union": "union",
    "bitbybit.occt.booleans.union_description": "joint les objets",
    "keepEdges": "garder arêtes",
    "bitbybit.occt.booleans.difference": "différence",
    "difference": "différence",
    "bitbybit.occt.booleans.difference_description": "effectue une différence booléenne",
    "bitbybit.occt.booleans.intersection": "intersection",
    "bitbybit.occt.booleans.intersection_description": "effectue une intersection booléenne",
    "bitbybit.occt.shapeFix.basicShapeRepair": "réparation forme base",
    "shapeFix": "correction forme",
    "basicShapeRepair": "réparation forme base",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "répare la forme",
    "maxTolerance": "tolérance max",
    "minTolerance": "tolérance min",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "corriger petite arête sur fil",
    "fixSmallEdgeOnWire": "corriger petite arête sur fil",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "corrige la petite arête sur le fil",
    "lockvtx": "verrouiller vtx",
    "precsmall": "précision petit",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "corriger orientations arêtes le long fil",
    "fixEdgeOrientationsAlongWire": "corriger orientations arêtes le long fil",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "corrige les orientations des arêtes le long du fil",
    "bitbybit.occt.io.saveShapeSTEP": "sauvegarder forme step",
    "saveShapeSTEP": "sauvegarder forme step",
    "bitbybit.occt.io.saveShapeSTEP_description": "sauvegarde le fichier step",
    "adjustYtoZ": "ajuster y à z",
    "tryDownload": "essayer télécharger",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "sauvegarder forme step et retourner",
    "saveShapeSTEPAndReturn": "sauvegarder forme step et retourner",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "sauvegarde le fichier step et retourne le texte",
    "bitbybit.occt.io.saveShapeStl": "sauvegarder forme stl",
    "saveShapeStl": "sauvegarder forme stl",
    "bitbybit.occt.io.saveShapeStl_description": "sauvegarde le fichier stl",
    "binary": "binaire",
    "bitbybit.occt.io.saveShapeStlAndReturn": "sauvegarder forme stl et retourner",
    "saveShapeStlAndReturn": "sauvegarder forme stl et retourner",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "sauvegarde le fichier stl et retourne",
    "bitbybit.occt.io.loadSTEPorIGES": "charger step ou iges",
    "loadSTEPorIGES": "charger step ou iges",
    "bitbybit.occt.io.loadSTEPorIGES_description": "importe le fichier step ou iges",
    "adjustZtoY": "ajuster z à y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "charger step ou iges depuis texte",
    "loadSTEPorIGESFromText": "charger step ou iges depuis texte",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "importe step ou iges depuis le texte",
    "fileType": "type fichier",
    "fileTypeEnum": "énumération type fichier",
    "bitbybit.advanced.text3d.create": "texte 3d",
    "advanced": "avancé",
    "text3d": "texte 3d",
    "bitbybit.advanced.text3d.create_description": "crée un texte 3d",
    "fontType": "type police",
    "fontsEnum": "énumération polices",
    "fontVariant": "variante police",
    "fontVariantsEnum": "énumération variantes polices",
    "Inputs.Base.Vector3": "entrées base vecteur 3",
    "originAlignment": "alignement origine",
    "recAlignmentEnum": "énumération alignement rec",
    "bitbybit.advanced.text3d.createTextOnFace": "texte sur face",
    "createTextOnFace": "texte sur face",
    "bitbybit.advanced.text3d.createTextOnFace_description": "crée un texte 3d sur la face",
    "facePlanar": "face planaire",
    "faceTextVar": "var texte face",
    "faceTextVarEnum": "énumération var texte face",
    "originParamU": "origine param u",
    "originParamV": "origine param v",
    "bitbybit.advanced.text3d.createTextsOnFace": "textes sur face",
    "createTextsOnFace": "textes sur face",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "crée des textes 3d sur la face",
    "definitions": "définitions",
    "Text3DFaceDefinitionDto[]": "tableau dto définition face texte 3d",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "définition texte 3d sur face",
    "definition3dTextOnFace": "définition texte 3d sur face",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "crée un texte 3d pour la définition de face",
    "bitbybit.advanced.text3d.getCompoundShape": "obtenir forme composée",
    "getCompoundShape": "obtenir forme composée",
    "bitbybit.advanced.text3d.getCompoundShape_description": "obtient la forme composée du texte 3d",
    "model": "modèle",
    "Text3DData<T>": "données texte 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "obtenir forme caractère",
    "getCharacterShape": "obtenir forme caractère",
    "bitbybit.advanced.text3d.getCharacterShape_description": "obtient la forme du caractère à l'index",
    "bitbybit.advanced.text3d.getCharacterShapes": "obtenir formes caractères",
    "getCharacterShapes": "obtenir formes caractères",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "obtient les formes des caractères du texte 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "obtenir coordonnées centre caractères",
    "getCharacterCenterCoordinates": "obtenir coordonnées centre caractères",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "obtient les coordonnées du centre des caractères",
    "bitbybit.advanced.text3d.getFaceCutout": "obtenir découpe face",
    "getFaceCutout": "obtenir découpe face",
    "bitbybit.advanced.text3d.getFaceCutout_description": "obtient la découpe de face du texte 3d sur la face",
    "get from face": "obtenir depuis face",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "obtenir toutes faces découpe",
    "getAllFacesOfCutout": "obtenir toutes faces découpe",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "obtient toutes les découpes de face du texte 3d",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "obtenir découpes intérieur caractères",
    "getCutoutsInsideCharacters": "obtenir découpes intérieur caractères",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "obtient les découpes de face des caractères du texte 3d",
    "bitbybit.advanced.text3d.getAdvanceWidth": "obtenir largeur avance",
    "getAdvanceWidth": "obtenir largeur avance",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "obtient la largeur d'avance",
    "dimensions": "dimensions",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pyramide simple",
    "facePatterns": "motifs face",
    "pyramidSimple": "pyramide simple",
    "createPyramidSimple": "pyramide simple",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "crée un motif pyramidal simple sur les faces",
    "uNumber": "nombre u",
    "vNumber": "nombre v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "pyramide simple affecteurs",
    "createPyramidSimpleAffectors": "pyramide simple affecteurs",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "crée un motif pyramidal avec des affecteurs",
    "affectorPoints": "points affecteurs",
    "Inputs.Base.Point3[]": "tableau de point base 3 (entrées)",
    "affectorRadiusList": "liste rayons affecteur",
    "affectorFactors": "facteurs affecteur",
    "defaultHeight": "hauteur par défaut",
    "affectMinHeight": "hauteur min affectée",
    "affectMaxHeight": "hauteur max affectée",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "obtenir forme composée",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "obtient la forme composée des pyramides",
    "get shapes": "obtenir formes",
    "PyramidSimpleData<T>": "données pyramide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "obtenir forme composée sur face",
    "getCompoundShapeOnFace": "obtenir forme composée sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "obtient la forme composée sur la face",
    "faceIndex": "index face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "obtenir forme composée cellule sur face",
    "getCompoundShapeCellOnFace": "obtenir forme composée cellule sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "obtient la forme pyramidale sur la face à l'index",
    "uIndex": "index u",
    "vIndex": "index v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "obtenir toutes cellules pyramide",
    "getAllPyramidCells": "obtenir toutes cellules pyramide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "obtient toutes les cellules pyramidales",
    "get cells": "obtenir cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "obtenir toutes cellules pyramide sur face",
    "getAllPyramidCellsOnFace": "obtenir toutes cellules pyramide sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "obtient les cellules pyramidales sur la face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "obtenir toutes cellules pyramide u sur face",
    "getAllPyramidUCellsOnFace": "obtenir toutes cellules pyramide u sur face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "obtient les cellules pyramidales u sur la face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "obtenir toutes cellules pyramide u sur face à u",
    "getAllPyramidUCellsOnFaceAtU": "obtenir toutes cellules pyramide u sur face à u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "obtient les cellules pyramidales sur la face à u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "obtenir toutes cellules pyramide u sur face à v",
    "getAllPyramidUCellsOnFaceAtV": "obtenir toutes cellules pyramide u sur face à v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "obtient les cellules pyramidales sur la face à v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "obtenir cellule à l'index",
    "getCellOnIndex": "obtenir cellule à l'index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "obtient la cellule pyramidale sur la face à u et v",
    "get cell": "obtenir cellule",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obtenir points supérieurs cellules",
    "getTopPointsOfCells": "obtenir points supérieurs cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "obtient les points supérieurs des cellules",
    "get from cells": "obtenir depuis cellules",
    "cells": "cellules",
    "PyramidSimpleCellPart<T>[]": "tableau partie cellule pyramide simple t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "obtenir points centraux cellules",
    "getCenterPointsOfCells": "obtenir points centraux cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "obtient les points centraux des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "obtenir points coins cellules",
    "getCornerPointsOfCells": "obtenir points coins cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "obtient les points de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "obtenir point coin cellules",
    "getCornerPointOfCells": "obtenir point coin cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "obtient le point de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "obtenir normale coin cellules",
    "getCornerNormalOfCells": "obtenir normale coin cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "obtient la normale de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "obtenir normales coins cellules",
    "getCornerNormalsOfCells": "obtenir normales coins cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "obtient les normales de coin des cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "obtenir formes composées cellules",
    "getCompoundShapesOfCells": "obtenir formes composées cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "obtient les formes composées des cellules pyramidales",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "obtenir formes faces cellules",
    "getFaceShapesOfCells": "obtenir formes faces cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "obtient les formes de face des cellules pyramidales",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "obtenir formes fils cellules",
    "getWireShapesOfCells": "obtenir formes fils cellules",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "obtient les formes de fil des cellules pyramidales",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "obtenir fil polyligne départ u",
    "getStartPolylineWireU": "obtenir fil polyligne départ u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "obtient le fil polyligne le long de l'arête u de départ",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "obtenir fil polyligne fin u",
    "getEndPolylineWireU": "obtenir fil polyligne fin u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "obtient le fil polyligne le long de l'arête u de fin",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "obtenir fil polyligne départ v",
    "getStartPolylineWireV": "obtenir fil polyligne départ v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "obtient le fil polyligne le long de l'arête v de départ",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "obtenir fil polyligne fin v",
    "getEndPolylineWireV": "obtenir fil polyligne fin v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "obtient le fil polyligne le long de l'arête v de fin",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "obtenir fils polyligne u composé",
    "getPolylineWiresUCompound": "obtenir fils polyligne u composé",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "obtient les fils polylignes le long de u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "obtenir fils polyligne v composé",
    "getPolylineWiresVCompound": "obtenir fils polyligne v composé",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "obtient les fils polylignes le long de v",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "wingtip villa",
    "things": "choses",
    "kidsCorner": "coin enfants",
    "birdhouses": "nichoirs",
    "wingtipVilla": "wingtip villa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "crée le nichoir wingtip villa",
    "birdhouse": "nichoir",
    "interiorWidth": "largeur intérieure",
    "interiorLength": "longueur intérieure",
    "interiorHeight": "hauteur intérieure",
    "holeDiameter": "diamètre trou",
    "holeDistToBottom": "distance trou au bas",
    "stickLength": "longueur bâton",
    "stickDiameter": "diamètre bâton",
    "baseAttachmentHeight": "hauteur fixation base",
    "roofOverhang": "débord toit",
    "chimneyHeight": "hauteur cheminée",
    "Inputs.Base.Point3": "point base 3 (entrées)",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chirpy chalet",
    "chirpyChalet": "chirpy chalet",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "crée le nichoir chirpy chalet",
    "roofAngle": "angle toit",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "serenity swirl",
    "threeDPrinting": "impression 3d",
    "vases": "vases",
    "serenitySwirl": "serenity swirl",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "crée le vase serenity swirl",
    "swirl": "tourbillon",
    "addRadiusNarrow": "ajouter rayon étroit",
    "addRadiusWide": "ajouter rayon large",
    "addMiddleHeight": "ajouter hauteur milieu",
    "addTopHeight": "ajouter hauteur haut",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arabic archway",
    "arabicArchway": "arabic archway",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "crée le vase arabic archway",
    "profilePoints": "points profil",
    "nrOfSides": "nb côtés",
    "nrOfVerticalArches": "nb arches verticales",
    "archCenterThickness": "épaisseur centre arche",
    "edgesThickness": "épaisseur arêtes",
    "baseHeight": "hauteur base",
    "patchHoles": "colmater trous",
    "lod": "lod",
    "Things.Enums.lodEnum": "énumération lod enums choses",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "eternal love",
    "medals": "médailles",
    "eternalLove": "eternal love",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "crée la médaille eternal love",
    "textHeading": "texte titre",
    "textName": "texte nom",
    "fullModel": "modèle complet",
    "decorationThickness": "épaisseur décoration",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "calm cup",
    "cups": "tasses",
    "calmCup": "calm cup",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "crée le modèle de tasse calm cup",
    "radiusTopOffset": "décalage rayon haut",
    "fillet": "congé",
    "nrOfHandles": "nb poignées",
    "handleDist": "distance poignée",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "dragon cup",
    "dragonCup": "dragon cup",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "crée le modèle de tasse dragon cup",
    "radiusMidOffset": "décalage rayon milieu",
    "rotationTopAngle": "angle rotation haut",
    "rotationMidAngle": "angle rotation milieu",
    "nrSkinCellsVertical": "nb cellules peau verticales",
    "nrSkinCellsHorizontal": "nb cellules peau horizontales",
    "nrSkinCellDivisionsTop": "nb divisions cellule peau haut",
    "nrSkinCellDivisionsBottom": "nb divisions cellule peau bas",
    "skinCellOuterHeight": "hauteur extérieure cellule peau",
    "skinCellInnerHeight": "hauteur intérieure cellule peau",
    "skinCellBottomHeight": "hauteur bas cellule peau",
    "skinCellTopHeight": "hauteur haut cellule peau",
    "bottomThickness": "épaisseur bas",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "obtient la forme composée de la tasse dragon",
    "DragonCupData<T>": "données dragon cup t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "phone nest",
    "desktop": "bureau",
    "phoneNest": "phone nest",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "crée le modèle phone nest",
    "heightBottom": "hauteur bas",
    "heightTop": "hauteur haut",
    "widthBack": "largeur arrière",
    "widthFront": "largeur avant",
    "backOffset": "décalage arrière",
    "applyOrnaments": "appliquer ornements",
    "filletRadius": "rayon congé",
    "phoneHeight": "hauteur téléphone",
    "phoneWidth": "largeur téléphone",
    "phoneThickness": "épaisseur téléphone",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "obtient la forme composée du phone nest",
    "PhoneNestData<T>": "données phone nest t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "options dessin",
    "drawOptions": "options dessin",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "crée les options de dessin pour le modèle",
    "mainMaterial": "matériau principal",
    "phoneMaterial": "matériau téléphone",
    "Inputs.Base.Color": "couleur base (entrées)",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "droplets phone holder",
    "laserCutting": "découpe laser",
    "gadgets": "gadgets",
    "dropletsPhoneHolder": "droplets phone holder",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "crée le support téléphone droplets",
    "title": "titre",
    "subtitle": "sous-titre",
    "includeLogo": "inclure logo",
    "kerf": "kerf",
    "backLength": "longueur arrière",
    "offsetAroundPhone": "décalage autour téléphone",
    "penShelf": "étagère stylo",
    "phoneLockHeight": "hauteur verrouillage téléphone",
    "includePattern": "inclure motif",
    "densityPattern": "densité motif",
    "holesForWire": "trous pour fil",
    "wireInputThickness": "épaisseur entrée fil",
    "includeModel": "inclure modèle",
    "includeDrawings": "inclure dessins",
    "spacingDrawings": "espacement dessins",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "obtient la forme composée du support téléphone droplets",
    "DropletsPhoneHolderData<T>": "données droplets phone holder t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "obtenir fils coupe composé",
    "getCutWiresCompound": "obtenir fils coupe composé",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "obtient le composé des fils de coupe",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "obtenir fils gravure composé",
    "getEngravingWiresCompound": "obtenir fils gravure composé",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "obtient le composé des fils de gravure",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "télécharger dessins dxf",
    "downloadDXFDrawings": "télécharger dessins dxf",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "télécharge le dessin dxf",
    "download": "télécharger",
    "cutWiresColor": "couleur fils coupe",
    "engravingWiresColor": "couleur fils gravure",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "télécharger dessins step",
    "downloadSTEPDrawings": "télécharger dessins step",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "télécharge le dessin step",
    "adjustYZ": "ajuster yz",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "télécharger modèle step 3d",
    "download3dSTEPModel": "télécharger modèle step 3d",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "télécharge le modèle step 3d",
    "bitbybit.things.architecture.houses.zenHideout.create": "zen hideout",
    "architecture": "architecture",
    "houses": "maisons",
    "zenHideout": "zen hideout",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "crée le refuge zen",
    "widthFirstWing": "largeur première aile",
    "lengthFirstWing": "longueur première aile",
    "terraceWidth": "largeur terrasse",
    "widthSecondWing": "largeur seconde aile",
    "lengthSecondWing": "longueur seconde aile",
    "heightWalls": "hauteur murs",
    "roofAngleFirstWing": "angle toit première aile",
    "roofAngleSecondWing": "angle toit seconde aile",
    "roofOffset": "décalage toit",
    "roofInsideOverhang": "débord toit intérieur",
    "roofMaxDistAttachmentBeams": "distance max toit poutres fixation",
    "roofAttachmentBeamWidth": "largeur poutre fixation toit",
    "roofAttachmentBeamHeight": "hauteur poutre fixation toit",
    "roofOutsideOverhang": "débord toit extérieur",
    "columnSize": "taille colonne",
    "ceilingBeamHeight": "hauteur poutre plafond",
    "ceilingBeamWidth": "largeur poutre plafond",
    "nrCeilingBeamsBetweenColumns": "nb poutres plafond entre colonnes",
    "distBetweenColumns": "distance entre colonnes",
    "floorHeight": "hauteur étage",
    "groundLevel": "niveau sol",
    "facadePanelThickness": "épaisseur panneau façade",
    "windowWidthOffset": "décalage largeur fenêtre",
    "windowHeightOffset": "décalage hauteur fenêtre",
    "windowFrameThickness": "épaisseur cadre fenêtre",
    "windowGlassFrameThickness": "épaisseur cadre vitre fenêtre",
    "skinOpacity": "opacité peau",
    "bitbybit.things.furniture.chairs.snakeChair.create": "snake chair",
    "furniture": "mobilier",
    "chairs": "chaises",
    "snakeChair": "snake chair",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "crée le modèle de chaise snake chair",
    "sittingHeight": "hauteur assise",
    "backRestOffset": "décalage dossier",
    "backRestHeight": "hauteur dossier",
    "nrOrnamentPlanks": "nb planches ornement",
    "ornamentDepth": "profondeur ornement",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "obtient la forme composée de la chaise",
    "SnakeChairData<T>": "données snake chair t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "obtenir forme fil assise",
    "getSittingWireShape": "obtenir forme fil assise",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "obtient la forme de fil de la zone d'assise",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "obtenir point central zone assise",
    "getSittingAreaCenterPoint": "obtenir point central zone assise",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "obtient le point central de la zone d'assise",
    "get points": "obtenir points",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "options dessin",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "crée les options de dessin pour la chaise snake",
    "bitbybit.things.furniture.tables.elegantTable.create": "elegant table",
    "tables": "tables",
    "elegantTable": "elegant table",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "crée le modèle de table elegant table",
    "topThickness": "épaisseur plateau",
    "topOffset": "décalage plateau",
    "minFillet": "congé min",
    "radiusLegTop": "rayon pied haut",
    "radiusLegBottom": "rayon pied bas",
    "nrLegPairs": "nb paires pieds",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "obtient la forme composée de la table",
    "ElegantTableData<T>": "données elegant table t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "obtenir formes pieds",
    "getLegShapes": "obtenir formes pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "obtient les formes des pieds sous forme de liste",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "obtenir forme pied par index",
    "getLegShapeByIndex": "obtenir forme pied par index",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "obtient la forme du pied par index",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "obtenir forme panneau supérieur",
    "getTopPanelShape": "obtenir forme panneau supérieur",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "obtient la forme du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "obtenir forme fil panneau supérieur",
    "getTopPanelWireShape": "obtenir forme fil panneau supérieur",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "obtient la forme de fil du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "obtenir forme fil panneau inférieur",
    "getBottomPanelWireShape": "obtenir forme fil panneau inférieur",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "obtient la forme de fil du panneau inférieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "obtenir forme panneau inférieur",
    "getBottomPanelShape": "obtenir forme panneau inférieur",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "obtient la forme du panneau inférieur de la table",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "obtenir forme composée pieds",
    "getLegsCompoundShape": "obtenir forme composée pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "obtient les formes des pieds comme forme composée",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "obtenir point central plateau table",
    "getTableTopCenterPoint": "obtenir point central plateau table",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "obtient le point central supérieur",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "obtenir point central bas table",
    "getTableBottomCenterPoint": "obtenir point central bas table",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "obtient le point central inférieur",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "obtenir points bas pieds",
    "getLegBottomPoints": "obtenir points bas pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "obtient les points inférieurs des pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obtenir points haut pieds",
    "getLegTopPoints": "obtenir points haut pieds",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "obtient les points supérieurs des pieds",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "options dessin",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "crée les options de dessin pour la table elegant",
    "topMaterial": "matériau plateau",
    "topBaseMaterial": "matériau base plateau",
    "legsMaterial": "matériau pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "good coffee table",
    "goodCoffeeTable": "good coffee table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "crée le modèle de table good coffee table",
    "chamfer": "chanfrein",
    "topGlassOffset": "décalage verre supérieur",
    "glassThickness": "épaisseur verre",
    "glassHolderLength": "longueur support verre",
    "shelfTopOffset": "décalage haut étagère",
    "shelfThickness": "épaisseur étagère",
    "legWidth": "largeur pied",
    "legDepth": "profondeur pied",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "obtient la forme composée de la table",
    "GoodCoffeeTableData<T>": "données good coffee table t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "obtenir formes pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "obtient les formes des pieds sous forme de liste",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "obtenir forme pied par index",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "obtient la forme du pied par index",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "obtenir forme panneau supérieur",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "obtient la forme du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "obtenir forme fil panneau supérieur",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "obtient la forme de fil du panneau supérieur de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "obtenir forme panneau verre",
    "getGlassPanelShape": "obtenir forme panneau verre",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "obtient la forme du panneau de verre de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "obtenir forme fil panneau verre",
    "getGlassPanelWireShape": "obtenir forme fil panneau verre",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "obtient la forme de fil du panneau de verre de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "obtenir forme étagère",
    "getShelfShape": "obtenir forme étagère",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "obtient la forme de l'étagère de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "obtenir forme fil haut étagère",
    "getShelfTopWireShape": "obtenir forme fil haut étagère",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "obtient la forme de fil du haut de l'étagère de la table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "obtenir forme composée pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "obtient les formes des pieds comme forme composée",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "obtenir point central plateau table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "obtient le point central supérieur",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "obtenir point central haut étagère table",
    "getTableShelfTopCenterPoint": "obtenir point central haut étagère table",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "obtient le point central supérieur de l'étagère",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "obtenir points bas pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "obtient les points inférieurs des pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obtenir points haut pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "obtient les points supérieurs des pieds",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "options dessin",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "crée les options de dessin pour la table good coffee table",
    "topGlassMaterial": "matériau verre supérieur",
    "shelfMaterial": "matériau étagère",
    "bitbybit.things.furniture.tables.snakeTable.create": "snake table",
    "snakeTable": "snake table",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "crée le modèle de table snake table",
    "supportLength": "longueur support",
    "shelfHeight": "hauteur étagère",
    "glassOffset": "décalage verre",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "obtenir forme composée",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "obtient la forme composée de la table",
    "SnakeTableData<T>": "données snake table t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "obtenir forme verre",
    "getGlassShape": "obtenir forme verre",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "obtient la forme de verre de la table",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "obtenir forme principale",
    "getMainShape": "obtenir forme principale",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "obtient la forme solide principale de la table",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "obtenir point central haut",
    "getTopCenterPoint": "obtenir point central haut",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "obtient le point central du plateau de la table",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "options dessin",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "crée les options de dessin pour la table snake",
    "glassMaterial": "matériau verre",
    "bitbybit.things.enums.lodEnum": "énumération lod",
    "enums": "énumérations",
    "lodEnum": "énumération lod",
    "bitbybit.things.enums.lodEnum_description": "crée une valeur d'énumération de niveau de détail",
    "bitbybit.jscad.transformSolids": "transformer solides",
    "jscad": "jscad",
    "transformSolids": "transformer solides",
    "bitbybit.jscad.transformSolids_description": "transforme les maillages solides jscad avec des transformations",
    "JSCADEntity[]": "tableau entité jscad",
    "bitbybit.jscad.transformSolid": "transformer solide",
    "transformSolid": "transformer solide",
    "bitbybit.jscad.transformSolid_description": "transforme le maillage solide jscad avec des transformations",
    "JSCADEntity": "entité jscad",
    "bitbybit.jscad.downloadSolidSTL": "télécharger solide stl",
    "downloadSolidSTL": "télécharger solide stl",
    "bitbybit.jscad.downloadSolidSTL_description": "télécharge le fichier stl binaire du solide 3d",
    "bitbybit.jscad.downloadSolidsSTL": "télécharger solides stl",
    "downloadSolidsSTL": "télécharger solides stl",
    "bitbybit.jscad.downloadSolidsSTL_description": "télécharge le fichier stl binaire des solides 3d",
    "bitbybit.jscad.downloadGeometryDxf": "télécharger géométrie dxf",
    "downloadGeometryDxf": "télécharger géométrie dxf",
    "bitbybit.jscad.downloadGeometryDxf_description": "télécharge le fichier dxf de la géométrie jscad",
    "geometry": "géométrie",
    "JSCADEntity | JSCADEntity[]": "entité jscad ou tableau",
    "bitbybit.jscad.downloadGeometry3MF": "télécharger géométrie 3mf",
    "downloadGeometry3MF": "télécharger géométrie 3mf",
    "bitbybit.jscad.downloadGeometry3MF_description": "télécharge le fichier 3mf de la géométrie jscad",
    "bitbybit.jscad.booleans.intersect": "intersecter",
    "intersect": "intersecter",
    "bitbybit.jscad.booleans.intersect_description": "intersecte plusieurs objets de maillage solide",
    "bitbybit.jscad.booleans.subtract": "soustraire",
    "subtract": "soustraire",
    "bitbybit.jscad.booleans.subtract_description": "soustrait plusieurs objets de maillage solide",
    "bitbybit.jscad.booleans.union": "unir",
    "bitbybit.jscad.booleans.union_description": "unit plusieurs objets de maillage solide",
    "bitbybit.jscad.booleans.intersectTwo": "intersecter deux",
    "intersectTwo": "intersecter deux",
    "bitbybit.jscad.booleans.intersectTwo_description": "intersecte deux objets de maillage solide",
    "bitbybit.jscad.booleans.subtractTwo": "soustraire deux",
    "subtractTwo": "soustraire deux",
    "bitbybit.jscad.booleans.subtractTwo_description": "soustrait deux objets de maillage solide",
    "bitbybit.jscad.booleans.unionTwo": "unir deux",
    "unionTwo": "unir deux",
    "bitbybit.jscad.booleans.unionTwo_description": "unit deux objets de maillage solide",
    "bitbybit.jscad.booleans.subtractFrom": "soustraire de",
    "subtractFrom": "soustraire de",
    "bitbybit.jscad.booleans.subtractFrom_description": "soustrait plusieurs maillages d'un maillage",
    "bitbybit.jscad.expansions.expand": "étendre",
    "expansions": "expansions",
    "expand": "étendre",
    "bitbybit.jscad.expansions.expand_description": "étend les géométries solides",
    "expansion": "expansion",
    "delta": "delta",
    "corners": "coins",
    "solidCornerTypeEnum": "énumération type coin solide",
    "bitbybit.jscad.expansions.offset": "décaler",
    "bitbybit.jscad.expansions.offset_description": "décale les géométries 2d",
    "bitbybit.jscad.extrusions.extrudeLinear": "extruder linéaire",
    "extrudeLinear": "extruder linéaire",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "extrude linéairement les géométries 2d",
    "twistAngle": "angle torsion",
    "twistSteps": "pas torsion",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extruder rectangulaire",
    "extrudeRectangular": "extruder rectangulaire",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "extrude rectangulairement les géométries 2d",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extruder points rectangulaires",
    "extrudeRectangularPoints": "extruder points rectangulaires",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "extrude rectangulairement les points 2d",
    "bitbybit.jscad.extrusions.extrudeRotate": "extruder pivoter",
    "extrudeRotate": "extruder pivoter",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "pivote et extrude les points 2d",
    "polygon": "polygone",
    "startAngle": "angle départ",
    "bitbybit.jscad.hulls.hullChain": "enveloppe chaîne",
    "hulls": "enveloppes",
    "hullChain": "enveloppe chaîne",
    "bitbybit.jscad.hulls.hullChain_description": "connecte les solides ou géométries 2d dans l'ordre",
    "bitbybit.jscad.hulls.hull": "enveloppe",
    "hull": "enveloppe",
    "bitbybit.jscad.hulls.hull_description": "l'enveloppe convexe connecte les solides ou géométries 2d",
    "bitbybit.jscad.path.createFromPoints": "depuis points",
    "createFromPoints": "depuis points",
    "bitbybit.jscad.path.createFromPoints_description": "crée un chemin 2d à partir de points",
    "Base.Point2[]": "tableau point2 base",
    "bitbybit.jscad.path.createPathsFromPoints": "chemins depuis points",
    "createPathsFromPoints": "chemins depuis points",
    "bitbybit.jscad.path.createPathsFromPoints_description": "crée des chemins 2d à partir de listes de points",
    "pointsLists": "listes points",
    "Base.Point3[][] | Base.Point2[][]": "tableau tableau point3 ou point2 base",
    "bitbybit.jscad.path.createFromPolyline": "depuis polyligne",
    "createFromPolyline": "depuis polyligne",
    "bitbybit.jscad.path.createFromPolyline_description": "crée un chemin 2d à partir d'une polyligne",
    "bitbybit.jscad.path.createEmpty": "vide",
    "createEmpty": "vide",
    "bitbybit.jscad.path.createEmpty_description": "crée un chemin 2d vide",
    "bitbybit.jscad.path.close": "fermer",
    "close": "fermer",
    "bitbybit.jscad.path.close_description": "ferme le chemin 2d ouvert",
    "bitbybit.jscad.path.appendPoints": "ajouter points",
    "appendPoints": "ajouter points",
    "bitbybit.jscad.path.appendPoints_description": "ajoute des points 2d au chemin",
    "append": "ajouter",
    "bitbybit.jscad.path.appendPolyline": "ajouter polyligne",
    "appendPolyline": "ajouter polyligne",
    "bitbybit.jscad.path.appendPolyline_description": "ajoute une polyligne au chemin",
    "bitbybit.jscad.path.appendArc": "ajouter arc",
    "appendArc": "ajouter arc",
    "bitbybit.jscad.path.appendArc_description": "ajoute un arc au chemin",
    "xAxisRotation": "rotation axe x",
    "clockwise": "sens horaire",
    "large": "grand",
    "bitbybit.jscad.polygon.createFromPoints": "depuis points",
    "bitbybit.jscad.polygon.createFromPoints_description": "crée un polygone 2d à partir de points",
    "bitbybit.jscad.polygon.createFromPolyline": "depuis polyligne",
    "bitbybit.jscad.polygon.createFromPolyline_description": "crée un polygone 2d à partir d'une polyligne",
    "bitbybit.jscad.polygon.createFromCurve": "depuis courbe",
    "createFromCurve": "depuis courbe",
    "bitbybit.jscad.polygon.createFromCurve_description": "crée un polygone 2d à partir d'une courbe",
    "bitbybit.jscad.polygon.createFromPath": "depuis chemin",
    "createFromPath": "depuis chemin",
    "bitbybit.jscad.polygon.createFromPath_description": "crée un polygone 2d à partir d'un chemin",
    "bitbybit.jscad.polygon.circle": "cercle",
    "bitbybit.jscad.polygon.circle_description": "crée un polygone cercle 2d",
    "bitbybit.jscad.polygon.ellipse": "ellipse",
    "ellipse": "ellipse",
    "bitbybit.jscad.polygon.ellipse_description": "crée un polygone ellipse 2d",
    "bitbybit.jscad.polygon.rectangle": "rectangle",
    "rectangle": "rectangle",
    "bitbybit.jscad.polygon.rectangle_description": "crée un polygone rectangle 2d",
    "bitbybit.jscad.polygon.roundedRectangle": "rectangle arrondi",
    "roundedRectangle": "rectangle arrondi",
    "bitbybit.jscad.polygon.roundedRectangle_description": "crée un rectangle arrondi 2d",
    "roundRadius": "rayon arrondi",
    "bitbybit.jscad.polygon.square": "carré",
    "square": "carré",
    "bitbybit.jscad.polygon.square_description": "crée un polygone carré 2d",
    "bitbybit.jscad.polygon.star": "étoile",
    "star": "étoile",
    "bitbybit.jscad.polygon.star_description": "crée un polygone étoile 2d",
    "vertices": "sommets",
    "bitbybit.jscad.shapes.cube": "cube",
    "cube": "cube",
    "bitbybit.jscad.shapes.cube_description": "crée une forme cube 3d",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubes sur points centraux",
    "cubesOnCenterPoints": "cubes sur points centraux",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "crée des cubes 3d sur les points centraux",
    "primitives on centers": "primitives sur centres",
    "bitbybit.jscad.shapes.cuboid": "parallélépipède rectangle",
    "cuboid": "parallélépipède rectangle",
    "bitbybit.jscad.shapes.cuboid_description": "crée une forme parallélépipède rectangle 3d",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "parallélépipèdes rectangles sur points centraux",
    "cuboidsOnCenterPoints": "parallélépipèdes rectangles sur points centraux",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "crée des parallélépipèdes rectangles 3d sur les points centraux",
    "bitbybit.jscad.shapes.cylinderElliptic": "cylindre elliptique",
    "cylinderElliptic": "cylindre elliptique",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "crée un solide cylindre elliptique 3d",
    "startRadius": "rayon départ",
    "endRadius": "rayon fin",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cylindre elliptique sur points centraux",
    "cylinderEllipticOnCenterPoints": "cylindre elliptique sur points centraux",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "crée des cylindres elliptiques 3d sur les points centraux",
    "bitbybit.jscad.shapes.cylinder": "cylindre",
    "cylinder": "cylindre",
    "bitbybit.jscad.shapes.cylinder_description": "crée un solide cylindre 3d",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cylindres sur points centraux",
    "cylindersOnCenterPoints": "cylindres sur points centraux",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "crée des cylindres 3d sur les points centraux",
    "bitbybit.jscad.shapes.ellipsoid": "ellipsoïde",
    "ellipsoid": "ellipsoïde",
    "bitbybit.jscad.shapes.ellipsoid_description": "crée un solide ellipsoïde 3d",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "ellipsoïdes sur points centraux",
    "ellipsoidsOnCenterPoints": "ellipsoïdes sur points centraux",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "crée des ellipsoïdes 3d sur les points centraux",
    "bitbybit.jscad.shapes.geodesicSphere": "sphère géodésique",
    "geodesicSphere": "sphère géodésique",
    "bitbybit.jscad.shapes.geodesicSphere_description": "crée un solide sphère géodésique 3d",
    "frequency": "fréquence",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "sphères géodésiques sur points centraux",
    "geodesicSpheresOnCenterPoints": "sphères géodésiques sur points centraux",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "crée des sphères géodésiques 3d sur les points centraux",
    "bitbybit.jscad.shapes.roundedCuboid": "parallélépipède rectangle arrondi",
    "roundedCuboid": "parallélépipède rectangle arrondi",
    "bitbybit.jscad.shapes.roundedCuboid_description": "crée un solide parallélépipède rectangle arrondi 3d",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "parallélépipèdes rectangles arrondis sur points centraux",
    "roundedCuboidsOnCenterPoints": "parallélépipèdes rectangles arrondis sur points centraux",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "crée des parallélépipèdes rectangles arrondis 3d sur les points centraux",
    "bitbybit.jscad.shapes.roundedCylinder": "cylindre arrondi",
    "roundedCylinder": "cylindre arrondi",
    "bitbybit.jscad.shapes.roundedCylinder_description": "crée un solide cylindre arrondi 3d",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "cylindres arrondis sur points centraux",
    "roundedCylindersOnCenterPoints": "cylindres arrondis sur points centraux",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "crée des cylindres arrondis 3d sur les points centraux",
    "bitbybit.jscad.shapes.sphere": "sphère",
    "sphere": "sphère",
    "bitbybit.jscad.shapes.sphere_description": "crée un solide sphère 3d",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "sphères sur points centraux",
    "spheresOnCenterPoints": "sphères sur points centraux",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "crée des sphères 3d sur les points centraux",
    "bitbybit.jscad.shapes.torus": "tore",
    "torus": "tore",
    "bitbybit.jscad.shapes.torus_description": "crée un solide tore 3d",
    "innerSegments": "segments intérieurs",
    "outerSegments": "segments extérieurs",
    "innerRotation": "rotation intérieure",
    "outerRotation": "rotation extérieure",
    "bitbybit.jscad.shapes.fromPolygonPoints": "depuis points polygone",
    "fromPolygonPoints": "depuis points polygone",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "crée une forme 3d à partir de points de polygone imbriqués",
    "polygonPoints": "points polygone",
    "Base.Point3[][]": "tableau tableau point3 base",
    "bitbybit.jscad.text.cylindricalText": "texte cylindrique",
    "cylindricalText": "texte cylindrique",
    "bitbybit.jscad.text.cylindricalText_description": "crée du texte avec des cylindres enveloppés en chaîne",
    "extrusionHeight": "hauteur extrusion",
    "extrusionSize": "taille extrusion",
    "jscadTextAlignEnum": "énumération alignement texte jscad",
    "bitbybit.jscad.text.sphericalText": "texte sphérique",
    "sphericalText": "texte sphérique",
    "bitbybit.jscad.text.sphericalText_description": "crée du texte avec des sphères enveloppées en chaîne",
    "bitbybit.jscad.text.createVectorText": "texte vectoriel",
    "createVectorText": "texte vectoriel",
    "bitbybit.jscad.text.createVectorText_description": "crée du texte vectoriel",
    "bitbybit.jscad.colors.colorize": "coloriser",
    "colors": "couleurs",
    "colorize": "coloriser",
    "bitbybit.jscad.colors.colorize_description": "colorise la géométrie jscad",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold vers pointeur maillage",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold vers pointeur maillage",
    "bitbybit.manifold.manifoldToMeshPointer_description": "transforme la forme manifold en pointeur de maillage",
    "meshing": "maillage",
    "normalIdx": "idx normale",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "décomposer manifold ou section transversale",
    "decomposeManifoldOrCrossSection": "décomposer manifold ou section transversale",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "décompose le manifold ou la section transversale en maillage ou polygones",
    "decompose": "décomposer",
    "manifoldOrCrossSection": "manifold ou section transversale",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "décomposer manifolds ou sections transversales",
    "decomposeManifoldsOrCrossSections": "décomposer manifolds ou sections transversales",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "décompose les manifolds ou sections transversales en maillages ou polygones",
    "manifoldsOrCrossSections": "manifolds ou sections transversales",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "supprimer manifold ou section transversale",
    "deleteManifoldOrCrossSection": "supprimer manifold ou section transversale",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "supprime le manifold ou la section transversale de la mémoire",
    "cleanup": "nettoyage",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "supprimer manifolds ou sections transversales",
    "deleteManifoldsOrCrossSections": "supprimer manifolds ou sections transversales",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "supprime les manifolds ou sections transversales de la mémoire",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold vers maillage",
    "manifoldToMesh": "manifold vers maillage",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "transforme la forme manifold en maillage",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds vers maillages",
    "manifoldsToMeshes": "manifolds vers maillages",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "transforme les formes manifold en maillages",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold depuis maillage",
    "manifoldFromMesh": "manifold depuis maillage",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "convertit le maillage en manifold",
    "DecomposedManifoldMeshDto": "dto maillage manifold décomposé",
    "bitbybit.manifold.manifold.shapes.cube": "cube",
    "bitbybit.manifold.manifold.shapes.cube_description": "crée une forme cube 3d",
    "bitbybit.manifold.manifold.shapes.sphere": "sphère",
    "bitbybit.manifold.manifold.shapes.sphere_description": "crée une forme sphère 3d",
    "circularSegments": "segments circulaires",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tétraèdre",
    "tetrahedron": "tétraèdre",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "crée une forme tétraèdre 3d",
    "bitbybit.manifold.manifold.shapes.cylinder": "cylindre",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "crée une forme cylindre 3d",
    "radiusLow": "rayon bas",
    "radiusHigh": "rayon haut",
    "bitbybit.manifold.manifold.booleans.subtract": "soustraire",
    "bitbybit.manifold.manifold.booleans.subtract_description": "soustrait deux formes manifold",
    "a to b": "a à b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "ajouter",
    "bitbybit.manifold.manifold.booleans.add_description": "ajoute deux formes manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "intersecter",
    "bitbybit.manifold.manifold.booleans.intersect_description": "intersecte deux formes manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "différence deux",
    "differenceTwo": "différence deux",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "différence de deux formes manifold",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "union deux",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "union de deux formes manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "intersection deux",
    "intersectionTwo": "intersection deux",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "intersection de deux formes manifold",
    "bitbybit.manifold.manifold.booleans.difference": "différence",
    "bitbybit.manifold.manifold.booleans.difference_description": "différence de plusieurs formes manifold",
    "bitbybit.manifold.manifold.booleans.union": "union",
    "bitbybit.manifold.manifold.booleans.union_description": "union de plusieurs formes manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "intersection",
    "bitbybit.manifold.manifold.booleans.intersection_description": "intersection de plusieurs formes manifold",
    "bitbybit.manifold.manifold.booleans.split": "diviser",
    "split": "diviser",
    "bitbybit.manifold.manifold.booleans.split_description": "divise le manifold par un autre manifold",
    "manifoldToSplit": "manifold à diviser",
    "manifoldCutter": "coupeur manifold",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "diviser par plan",
    "splitByPlane": "diviser par plan",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "divise le manifold par un plan",
    "originOffset": "décalage origine",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "diviser par plan sur décalages",
    "splitByPlaneOnOffsets": "diviser par plan sur décalages",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "divise le manifold par un plan sur des décalages",
    "originOffsets": "décalages origine",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "couper par plan",
    "trimByPlane": "couper par plan",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "coupe le manifold par un plan",
    "trim": "couper",
    "bitbybit.manifold.manifold.operations.hull": "enveloppe",
    "bitbybit.manifold.manifold.operations.hull_description": "calcule l'enveloppe convexe de la forme manifold",
    "bitbybit.manifold.manifold.operations.hullPoints": "envelopper points",
    "hullPoints": "envelopper points",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "enveloppe les points ou les manifolds",
    "bitbybit.manifold.manifold.operations.slice": "tranche",
    "bitbybit.manifold.manifold.operations.slice_description": "retourne la section transversale de l'objet à la hauteur",
    "cross sections": "sections transversales",
    "bitbybit.manifold.manifold.operations.project": "projeter",
    "bitbybit.manifold.manifold.operations.project_description": "crée une projection sur le plan xy à partir du contour de la forme",
    "bitbybit.manifold.manifold.operations.setTolerance": "définir tolérance",
    "setTolerance": "définir tolérance",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "définit la valeur de tolérance pour le manifold",
    "basic": "basique",
    "bitbybit.manifold.manifold.operations.reserveIds": "réserver ids",
    "reserveIds": "réserver ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "réserve des ids de maillage séquentiels",
    "count": "compter",
    "bitbybit.manifold.manifold.operations.asOriginal": "comme original",
    "asOriginal": "comme original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "réinitialise les ids du manifold comme originaux",
    "bitbybit.manifold.manifold.operations.compose": "composer",
    "compose": "composer",
    "bitbybit.manifold.manifold.operations.compose_description": "construit un manifold à partir d'une liste de manifolds",
    "composition": "composition",
    "bitbybit.manifold.manifold.operations.decompose": "décomposer",
    "bitbybit.manifold.manifold.operations.decompose_description": "décompose le manifold en parties déconnectées",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calculer normales",
    "calculateNormals": "calculer normales",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "calcule les normales aux sommets",
    "adjustments": "ajustements",
    "minSharpAngle": "angle aigu min",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calculer courbure",
    "calculateCurvature": "calculer courbure",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "calcule la courbure pour les sommets",
    "gaussianIdx": "idx gaussien",
    "meanIdx": "idx moyen",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "affiner à tolérance",
    "refineToTolerance": "affiner à tolérance",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "affine le maillage à la tolérance",
    "bitbybit.manifold.manifold.operations.refineToLength": "affiner à longueur",
    "refineToLength": "affiner à longueur",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "affine le maillage à la longueur",
    "bitbybit.manifold.manifold.operations.refine": "affiner",
    "refine": "affiner",
    "bitbybit.manifold.manifold.operations.refine_description": "affine le maillage en divisant les arêtes",
    "bitbybit.manifold.manifold.operations.smoothOut": "lisser",
    "smoothOut": "lisser",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "lisse le manifold avec des vecteurs tangents",
    "minSmoothness": "lissité min",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "lisser par normales",
    "smoothByNormals": "lisser par normales",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "lisse le manifold en utilisant les normales aux sommets",
    "bitbybit.manifold.manifold.transforms.scale3D": "échelle 3d",
    "scale3D": "échelle 3d",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "met à l'échelle le manifold avec un vecteur 3d",
    "bitbybit.manifold.manifold.transforms.scale": "échelle",
    "bitbybit.manifold.manifold.transforms.scale_description": "met à l'échelle le manifold avec un seul facteur",
    "bitbybit.manifold.manifold.transforms.mirror": "miroir",
    "bitbybit.manifold.manifold.transforms.mirror_description": "reflète le manifold par rapport à un plan",
    "bitbybit.manifold.manifold.transforms.translate": "translater",
    "bitbybit.manifold.manifold.transforms.translate_description": "translate le manifold le long d'un vecteur",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "translater par vecteurs",
    "translateByVectors": "translater par vecteurs",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "translate le manifold par plusieurs vecteurs",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "translater xyz",
    "translateXYZ": "translater xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "translate le manifold le long de x y z",
    "bitbybit.manifold.manifold.transforms.rotate": "pivoter",
    "bitbybit.manifold.manifold.transforms.rotate_description": "pivote le manifold avec des angles d'euler",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "pivoter xyz",
    "rotateXYZ": "pivoter xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "pivote le manifold le long des angles d'euler x y z",
    "bitbybit.manifold.manifold.transforms.transform": "transformer",
    "bitbybit.manifold.manifold.transforms.transform_description": "transforme le manifold avec une matrice 4x4",
    "matrix": "matrice",
    "Base.TransformMatrix": "matrice transformation base",
    "bitbybit.manifold.manifold.transforms.transforms": "transformations",
    "bitbybit.manifold.manifold.transforms.transforms_description": "transforme le manifold avec plusieurs matrices 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "aire surface",
    "evaluate": "évaluer",
    "surfaceArea": "aire surface",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "obtient l'aire de la surface du manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volume",
    "volume": "volume",
    "bitbybit.manifold.manifold.evaluate.volume_description": "obtient le volume du manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "est vide",
    "isEmpty": "est vide",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "vérifie si le manifold a des triangles",
    "bitbybit.manifold.manifold.evaluate.numVert": "nb sommets",
    "numVert": "nb sommets",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "obtient le nombre de sommets dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "nb triangles",
    "numTri": "nb triangles",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "obtient le nombre de triangles dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "nb arêtes",
    "numEdge": "nb arêtes",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "obtient le nombre d'arêtes dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "nb propriétés",
    "numProp": "nb propriétés",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "obtient le nombre de propriétés dans le manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "nb sommets propriété",
    "numPropVert": "nb sommets propriété",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "obtient le nombre de sommets de propriété dans le manifold",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "boîte englobante",
    "boundingBox": "boîte englobante",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "obtient la boîte englobante alignée sur les axes du manifold",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolérance",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "obtient la tolérance des sommets du manifold",
    "bitbybit.manifold.manifold.evaluate.genus": "genre",
    "genus": "genre",
    "bitbybit.manifold.manifold.evaluate.genus_description": "obtient le genre du manifold",
    "bitbybit.manifold.manifold.evaluate.minGap": "écart min",
    "minGap": "écart min",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "obtient l'écart minimum entre deux manifolds",
    "searchLength": "longueur recherche",
    "bitbybit.manifold.manifold.evaluate.originalID": "id original",
    "originalID": "id original",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "obtient l'id original du manifold",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "section transversale vers polygones",
    "crossSection": "section transversale",
    "crossSectionToPolygons": "section transversale vers polygones",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "transforme la section transversale en polygones",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "sections transversales vers polygones",
    "crossSectionsToPolygons": "sections transversales vers polygones",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "transforme les sections transversales en polygones",
    "crossSections": "sections transversales",
    "bitbybit.manifold.crossSection.shapes.create": "créer",
    "bitbybit.manifold.crossSection.shapes.create_description": "crée une section transversale 2d à partir de contours",
    "Base.Vector2[][]": "tableau tableau vecteur2 base",
    "fillRule": "règle remplissage",
    "fillRuleEnum": "énumération règle remplissage",
    "bitbybit.manifold.crossSection.shapes.square": "carré",
    "bitbybit.manifold.crossSection.shapes.square_description": "crée une section transversale carrée 2d",
    "bitbybit.manifold.crossSection.shapes.circle": "cercle",
    "bitbybit.manifold.crossSection.shapes.circle_description": "crée une section transversale circulaire 2d",
    "bitbybit.manifold.crossSection.shapes.rectangle": "rectangle",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "crée une section transversale rectangulaire 2d",
    "bitbybit.manifold.crossSection.operations.hull": "enveloppe",
    "bitbybit.manifold.crossSection.operations.hull_description": "calcule l'enveloppe convexe pour la section transversale",
    "bitbybit.manifold.crossSection.operations.extrude": "extruder",
    "bitbybit.manifold.crossSection.operations.extrude_description": "extrude la section transversale en forme 3d",
    "nDivisions": "n divisions",
    "twistDegrees": "degrés torsion",
    "scaleTopX": "échelle haut x",
    "scaleTopY": "échelle haut y",
    "bitbybit.manifold.crossSection.operations.revolve": "révolution",
    "bitbybit.manifold.crossSection.operations.revolve_description": "fait tourner la section transversale en forme 3d",
    "revolveDegrees": "degrés révolution",
    "matchProfile": "correspondre profil",
    "bitbybit.manifold.crossSection.operations.offset": "décaler",
    "bitbybit.manifold.crossSection.operations.offset_description": "décale la section transversale avec delta",
    "manifoldJoinTypeEnum": "énumération type jonction manifold",
    "miterLimit": "limite onglet",
    "bitbybit.manifold.crossSection.operations.simplify": "simplifier",
    "simplify": "simplifier",
    "bitbybit.manifold.crossSection.operations.simplify_description": "simplifie les contours de la section transversale",
    "epsilon": "epsilon",
    "bitbybit.manifold.crossSection.operations.compose": "composer",
    "bitbybit.manifold.crossSection.operations.compose_description": "compose plusieurs sections transversales en une seule",
    "bitbybit.manifold.crossSection.operations.decompose": "décomposer",
    "bitbybit.manifold.crossSection.operations.decompose_description": "décompose les sections transversales en parties",
    "bitbybit.manifold.crossSection.booleans.subtract": "soustraire",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "soustrait deux sections transversales",
    "crossSection1": "section transversale 1",
    "crossSection2": "section transversale 2",
    "bitbybit.manifold.crossSection.booleans.add": "ajouter",
    "bitbybit.manifold.crossSection.booleans.add_description": "ajoute deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.intersect": "intersecter",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "intersecte deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "différence deux",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "différence de deux sections transversales",
    "2 cross sections": "2 sections transversales",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "union deux",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "union de deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "intersection deux",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "intersection de deux sections transversales",
    "bitbybit.manifold.crossSection.booleans.difference": "différence",
    "bitbybit.manifold.crossSection.booleans.difference_description": "différence de plusieurs sections transversales",
    "bitbybit.manifold.crossSection.booleans.union": "union",
    "bitbybit.manifold.crossSection.booleans.union_description": "union de plusieurs sections transversales",
    "bitbybit.manifold.crossSection.booleans.intersection": "intersection",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "intersection de plusieurs sections transversales",
    "bitbybit.manifold.crossSection.transforms.scale2D": "échelle 2d",
    "scale2D": "échelle 2d",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "met à l'échelle la section transversale avec un vecteur 2d",
    "bitbybit.manifold.crossSection.transforms.scale": "échelle",
    "bitbybit.manifold.crossSection.transforms.scale_description": "met à l'échelle la section transversale avec un seul facteur",
    "bitbybit.manifold.crossSection.transforms.mirror": "miroir",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "reflète la section transversale par rapport à un plan",
    "bitbybit.manifold.crossSection.transforms.translate": "translater",
    "bitbybit.manifold.crossSection.transforms.translate_description": "translate la section transversale le long d'un vecteur",
    "bitbybit.manifold.crossSection.transforms.translateXY": "translater xy",
    "translateXY": "translater xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "translate la section transversale le long de x y",
    "bitbybit.manifold.crossSection.transforms.rotate": "pivoter",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "pivote la section transversale avec des degrés",
    "degrees": "degrés",
    "bitbybit.manifold.crossSection.transforms.transform": "transformer",
    "bitbybit.manifold.crossSection.transforms.transform_description": "transforme la section transversale avec une matrice 3x3",
    "Base.TransformMatrix3x3": "matrice transformation base 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "aire",
    "area": "aire",
    "bitbybit.manifold.crossSection.evaluate.area_description": "obtient l'aire de la section transversale",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "est vide",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "vérifie si la section transversale est vide",
    "bitbybit.manifold.crossSection.evaluate.numVert": "nb sommets",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "obtient le nombre de sommets dans la section transversale",
    "bitbybit.manifold.crossSection.evaluate.numContour": "nb contours",
    "numContour": "nb contours",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "obtient le nombre de contours dans la section transversale",
    "bitbybit.manifold.crossSection.evaluate.bounds": "limites",
    "bounds": "limites",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "obtient les limites du contour comme rectangle",
    "bitbybit.manifold.mesh.operations.merge": "fusionner",
    "merge": "fusionner",
    "bitbybit.manifold.mesh.operations.merge_description": "fusionne les sommets en solide manifold",
    "bitbybit.manifold.mesh.evaluate.position": "position",
    "bitbybit.manifold.mesh.evaluate.position_description": "obtient la position sur l'index de sommet du maillage",
    "vertexIndex": "index sommet",
    "bitbybit.manifold.mesh.evaluate.verts": "sommets",
    "verts": "sommets",
    "bitbybit.manifold.mesh.evaluate.verts_description": "obtient les trois indices de sommet du triangle",
    "triangleIndex": "index triangle",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangente",
    "tangent": "tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "obtient le vecteur tangent de la demi-arête",
    "halfEdgeIndex": "index demi-arête",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "obtient les propriétés supplémentaires du sommet",
    "bitbybit.manifold.mesh.evaluate.transform": "transformer",
    "bitbybit.manifold.mesh.evaluate.transform_description": "obtient la matrice de transformation 4x4 du maillage",
    "bitbybit.manifold.mesh.evaluate.numProp": "nb propriétés",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "obtient le nombre de propriétés par sommet",
    "bitbybit.manifold.mesh.evaluate.numVert": "nb sommets",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "obtient le nombre de sommets de propriété",
    "bitbybit.manifold.mesh.evaluate.numTri": "nb triangles",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "obtient le nombre de triangles sur le maillage",
    "bitbybit.manifold.mesh.evaluate.numRun": "nb passes",
    "numRun": "nb passes",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "obtient le nombre de passes de triangle",
    "bitbybit.logic.boolean": "booléen",
    "logic": "logique",
    "bitbybit.logic.boolean_description": "crée une valeur booléenne",
    "bitbybit.logic.randomBooleans": "booléens aléatoires",
    "randomBooleans": "booléens aléatoires",
    "bitbybit.logic.randomBooleans_description": "crée une liste booléenne aléatoire",
    "trueThreshold": "seuil vrai",
    "bitbybit.logic.twoThresholdRandomGradient": "gradient aléatoire deux seuils",
    "twoThresholdRandomGradient": "gradient aléatoire deux seuils",
    "bitbybit.logic.twoThresholdRandomGradient_description": "crée une liste booléenne aléatoire avec des seuils",
    "numbers": "nombres",
    "thresholdTotalTrue": "seuil total vrai",
    "thresholdTotalFalse": "seuil total faux",
    "nrLevels": "nb niveaux",
    "bitbybit.logic.thresholdBooleanList": "liste booléenne seuil",
    "thresholdBooleanList": "liste booléenne seuil",
    "bitbybit.logic.thresholdBooleanList_description": "crée une liste booléenne avec seuil",
    "threshold": "seuil",
    "bitbybit.logic.thresholdGapsBooleanList": "liste booléenne seuils écarts",
    "thresholdGapsBooleanList": "liste booléenne seuils écarts",
    "bitbybit.logic.thresholdGapsBooleanList_description": "crée une liste booléenne avec des seuils d'écarts",
    "gapThresholds": "seuils écarts",
    "Base.Vector2[]": "tableau vecteur2 base",
    "bitbybit.logic.not": "non",
    "not": "non",
    "bitbybit.logic.not_description": "applique l'opérateur non sur un booléen",
    "bitbybit.logic.notList": "liste non",
    "notList": "liste non",
    "bitbybit.logic.notList_description": "applique l'opérateur non sur une liste booléenne",
    "bitbybit.logic.compare": "comparer",
    "compare": "comparer",
    "bitbybit.logic.compare_description": "compare deux valeurs",
    "operator": "opérateur",
    "BooleanOperatorsEnum": "énumération opérateurs booléens",
    "bitbybit.logic.valueGate": "porte valeur",
    "valueGate": "porte valeur",
    "bitbybit.logic.valueGate_description": "transmet la valeur si le booléen est vrai",
    "bitbybit.logic.firstDefinedValueGate": "porte première valeur définie",
    "firstDefinedValueGate": "porte première valeur définie",
    "bitbybit.logic.firstDefinedValueGate_description": "retourne la première valeur définie",
    "value1": "valeur 1",
    "value2": "valeur 2",
    "bitbybit.math.number": "nombre",
    "math": "math",
    "bitbybit.math.number_description": "crée un nombre",
    "bitbybit.math.twoNrOperation": "opération deux nb",
    "twoNrOperation": "opération deux nb",
    "bitbybit.math.twoNrOperation_description": "effectue des opérations mathématiques de base",
    "operation": "opération",
    "mathTwoNrOperatorEnum": "énumération opérateur math deux nb",
    "bitbybit.math.modulus": "module",
    "modulus": "module",
    "bitbybit.math.modulus_description": "effectue l'opération module",
    "bitbybit.math.roundToDecimals": "arrondir à décimales",
    "roundToDecimals": "arrondir à décimales",
    "bitbybit.math.roundToDecimals_description": "arrondit aux décimales",
    "decimalPlaces": "décimales",
    "bitbybit.math.oneNrOperation": "opération un nb",
    "oneNrOperation": "opération un nb",
    "bitbybit.math.oneNrOperation_description": "effectue des maths sur un nombre",
    "mathOneNrOperatorEnum": "énumération opérateur math un nb",
    "bitbybit.math.remap": "remapper",
    "remap": "remapper",
    "bitbybit.math.remap_description": "remappe le nombre entre des plages",
    "fromLow": "depuis bas",
    "fromHigh": "depuis haut",
    "toLow": "vers bas",
    "toHigh": "vers haut",
    "bitbybit.math.random": "aléatoire",
    "random": "aléatoire",
    "bitbybit.math.random_description": "crée un nombre aléatoire de 0 à 1",
    "generate": "générer",
    "bitbybit.math.randomNumber": "nombre aléatoire",
    "randomNumber": "nombre aléatoire",
    "bitbybit.math.randomNumber_description": "crée un nombre aléatoire dans la plage",
    "low": "bas",
    "high": "haut",
    "bitbybit.math.randomNumbers": "nombres aléatoires",
    "randomNumbers": "nombres aléatoires",
    "bitbybit.math.randomNumbers_description": "crée des nombres aléatoires dans la plage",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "crée le nombre pi",
    "bitbybit.math.toFixed": "à fixe",
    "toFixed": "à fixe",
    "bitbybit.math.toFixed_description": "arrondit le nombre aux décimales",
    "bitbybit.math.add": "ajouter",
    "bitbybit.math.add_description": "ajoute deux nombres",
    "basics": "bases",
    "bitbybit.math.subtract": "soustraire",
    "bitbybit.math.subtract_description": "soustrait deux nombres",
    "bitbybit.math.multiply": "multiplier",
    "bitbybit.math.multiply_description": "multiplie deux nombres",
    "bitbybit.math.divide": "diviser",
    "divide": "diviser",
    "bitbybit.math.divide_description": "divise deux nombres",
    "bitbybit.math.power": "puissance",
    "power": "puissance",
    "bitbybit.math.power_description": "élève un nombre à la puissance",
    "bitbybit.math.sqrt": "racine carrée",
    "sqrt": "racine carrée",
    "bitbybit.math.sqrt_description": "obtient la racine carrée",
    "bitbybit.math.abs": "valeur absolue",
    "abs": "valeur absolue",
    "bitbybit.math.abs_description": "obtient la valeur absolue",
    "bitbybit.math.round": "arrondir",
    "round": "arrondir",
    "bitbybit.math.round_description": "arrondit un nombre",
    "bitbybit.math.floor": "plancher",
    "floor": "plancher",
    "bitbybit.math.floor_description": "arrondit un nombre à l'entier inférieur",
    "bitbybit.math.ceil": "plafond",
    "ceil": "plafond",
    "bitbybit.math.ceil_description": "arrondit un nombre à l'entier supérieur",
    "bitbybit.math.negate": "opposer",
    "negate": "opposer",
    "bitbybit.math.negate_description": "prend l'opposé d'un nombre",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "obtient le logarithme naturel",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "obtient le logarithme base 10",
    "bitbybit.math.tenPow": "dix puissance",
    "tenPow": "dix puissance",
    "bitbybit.math.tenPow_description": "élève 10 à la puissance",
    "bitbybit.math.sin": "sin",
    "sin": "sin",
    "bitbybit.math.sin_description": "obtient le sinus",
    "bitbybit.math.cos": "cos",
    "cos": "cos",
    "bitbybit.math.cos_description": "obtient le cosinus",
    "bitbybit.math.tan": "tan",
    "tan": "tan",
    "bitbybit.math.tan_description": "obtient la tangente",
    "bitbybit.math.asin": "asin",
    "asin": "asin",
    "bitbybit.math.asin_description": "obtient l'arcsinus",
    "bitbybit.math.acos": "acos",
    "acos": "acos",
    "bitbybit.math.acos_description": "obtient l'arccosinus",
    "bitbybit.math.atan": "atan",
    "atan": "atan",
    "bitbybit.math.atan_description": "obtient l'arctangente",
    "bitbybit.math.exp": "exp",
    "exp": "exp",
    "bitbybit.math.exp_description": "obtient l'exposant naturel",
    "bitbybit.math.degToRad": "deg vers rad",
    "degToRad": "deg vers rad",
    "bitbybit.math.degToRad_description": "convertit les degrés en radians",
    "bitbybit.math.radToDeg": "rad vers deg",
    "radToDeg": "rad vers deg",
    "bitbybit.math.radToDeg_description": "convertit les radians en degrés",
    "bitbybit.math.ease": "lisser",
    "bitbybit.math.ease_description": "lisse le nombre avec une plage",
    "easeEnum": "énumération lissage",
    "bitbybit.lists.getItem": "obtenir élément",
    "lists": "listes",
    "getItem": "obtenir élément",
    "bitbybit.lists.getItem_description": "obtient un élément de la liste par index",
    "list": "liste",
    "bitbybit.lists.randomGetThreshold": "seuil obtention aléatoire",
    "randomGetThreshold": "seuil obtention aléatoire",
    "bitbybit.lists.randomGetThreshold_description": "obtient des éléments aléatoirement avec seuil",
    "bitbybit.lists.getSubList": "obtenir sous-liste",
    "getSubList": "obtenir sous-liste",
    "bitbybit.lists.getSubList_description": "obtient une sous-liste entre les index",
    "indexStart": "index début",
    "indexEnd": "index fin",
    "bitbybit.lists.getNthItem": "obtenir nième élément",
    "getNthItem": "obtenir nième élément",
    "bitbybit.lists.getNthItem_description": "obtient le nième élément de la liste",
    "nth": "nième",
    "bitbybit.lists.getByPattern": "obtenir par motif",
    "getByPattern": "obtenir par motif",
    "bitbybit.lists.getByPattern_description": "obtient des éléments par motif",
    "pattern": "motif",
    "bitbybit.lists.mergeElementsOfLists": "fusionner éléments listes",
    "mergeElementsOfLists": "fusionner éléments listes",
    "bitbybit.lists.mergeElementsOfLists_description": "fusionne les éléments des listes au niveau",
    "level": "niveau",
    "bitbybit.lists.getLongestListLength": "obtenir longueur liste la plus longue",
    "getLongestListLength": "obtenir longueur liste la plus longue",
    "bitbybit.lists.getLongestListLength_description": "obtient la longueur de la liste la plus longue",
    "bitbybit.lists.reverse": "inverser",
    "bitbybit.lists.reverse_description": "inverse la liste",
    "bitbybit.lists.flipLists": "retourner listes",
    "flipLists": "retourner listes",
    "bitbybit.lists.flipLists_description": "retourne les listes 2d",
    "bitbybit.lists.groupNth": "grouper nième",
    "groupNth": "grouper nième",
    "bitbybit.lists.groupNth_description": "groupe la liste en n éléments",
    "nrElements": "nb éléments",
    "keepRemainder": "garder reste",
    "bitbybit.lists.getListDepth": "obtenir profondeur liste",
    "getListDepth": "obtenir profondeur liste",
    "bitbybit.lists.getListDepth_description": "obtient la profondeur de la liste",
    "bitbybit.lists.listLength": "longueur liste",
    "listLength": "longueur liste",
    "bitbybit.lists.listLength_description": "obtient la longueur de la liste",
    "bitbybit.lists.addItemAtIndex": "ajouter élément à index",
    "addItemAtIndex": "ajouter élément à index",
    "bitbybit.lists.addItemAtIndex_description": "ajoute un élément à la liste à l'index",
    "item": "élément",
    "bitbybit.lists.addItemAtIndexes": "ajouter élément aux index",
    "addItemAtIndexes": "ajouter élément aux index",
    "bitbybit.lists.addItemAtIndexes_description": "ajoute un élément à la liste aux index",
    "bitbybit.lists.addItemsAtIndexes": "ajouter éléments aux index",
    "addItemsAtIndexes": "ajouter éléments aux index",
    "bitbybit.lists.addItemsAtIndexes_description": "ajoute des éléments à la liste aux index",
    "items": "éléments",
    "bitbybit.lists.removeItemAtIndex": "supprimer élément à index",
    "removeItemAtIndex": "supprimer élément à index",
    "bitbybit.lists.removeItemAtIndex_description": "supprime un élément de la liste à l'index",
    "bitbybit.lists.removeItemsAtIndexes": "supprimer éléments aux index",
    "removeItemsAtIndexes": "supprimer éléments aux index",
    "bitbybit.lists.removeItemsAtIndexes_description": "supprime des éléments de la liste aux index",
    "bitbybit.lists.removeAllItems": "supprimer tous éléments",
    "removeAllItems": "supprimer tous éléments",
    "bitbybit.lists.removeAllItems_description": "supprime tous les éléments de la liste",
    "bitbybit.lists.removeNthItem": "supprimer nième élément",
    "removeNthItem": "supprimer nième élément",
    "bitbybit.lists.removeNthItem_description": "supprime le nième élément de la liste",
    "bitbybit.lists.randomRemoveThreshold": "seuil suppression aléatoire",
    "randomRemoveThreshold": "seuil suppression aléatoire",
    "bitbybit.lists.randomRemoveThreshold_description": "supprime des éléments aléatoirement avec seuil",
    "bitbybit.lists.removeDuplicateNumbers": "supprimer nombres dupliqués",
    "removeDuplicateNumbers": "supprimer nombres dupliqués",
    "bitbybit.lists.removeDuplicateNumbers_description": "supprime les nombres dupliqués de la liste",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "tolérance suppression nombres dupliqués",
    "removeDuplicateNumbersTolerance": "tolérance suppression nombres dupliqués",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "supprime les nombres dupliqués avec tolérance",
    "bitbybit.lists.addItem": "ajouter élément",
    "addItem": "ajouter élément",
    "bitbybit.lists.addItem_description": "ajoute un élément à la fin de la liste",
    "bitbybit.lists.prependItem": "ajouter élément début",
    "prependItem": "ajouter élément début",
    "bitbybit.lists.prependItem_description": "ajoute un élément au début de la liste",
    "bitbybit.lists.addItemFirstLast": "ajouter élément début fin",
    "addItemFirstLast": "ajouter élément début fin",
    "bitbybit.lists.addItemFirstLast_description": "ajoute un élément au début ou à la fin de la liste",
    "firstLastEnum": "énumération début fin",
    "bitbybit.lists.createEmptyList": "liste vide",
    "createEmptyList": "liste vide",
    "bitbybit.lists.createEmptyList_description": "crée une liste vide",
    "bitbybit.lists.repeat": "répéter",
    "repeat": "répéter",
    "bitbybit.lists.repeat_description": "répète l'élément dans une nouvelle liste",
    "times": "fois",
    "bitbybit.lists.repeatInPattern": "répéter en motif",
    "repeatInPattern": "répéter en motif",
    "bitbybit.lists.repeatInPattern_description": "répète les éléments de la liste jusqu'à la limite de longueur",
    "lengthLimit": "limite longueur",
    "bitbybit.lists.sortNumber": "trier nombre",
    "sortNumber": "trier nombre",
    "bitbybit.lists.sortNumber_description": "trie la liste de nombres",
    "sorting": "tri",
    "orderAsc": "ordre asc",
    "bitbybit.lists.sortTexts": "trier textes",
    "sortTexts": "trier textes",
    "bitbybit.lists.sortTexts_description": "trie la liste de textes par ordre alphabétique",
    "bitbybit.lists.sortByPropValue": "trier par valeur prop",
    "sortByPropValue": "trier par valeur prop",
    "bitbybit.lists.sortByPropValue_description": "trie par propriété json numérique",
    "property": "propriété",
    "bitbybit.color.hexColor": "couleur hex",
    "hexColor": "couleur hex",
    "bitbybit.color.hexColor_description": "crée une couleur hexadécimale",
    "bitbybit.color.hexToRgb": "hex vers rgb",
    "hexToRgb": "hex vers rgb",
    "bitbybit.color.hexToRgb_description": "crée rgb à partir de hex",
    "convert": "convertir",
    "bitbybit.color.rgbToHex": "rgb vers hex",
    "rgbToHex": "rgb vers hex",
    "bitbybit.color.rgbToHex_description": "crée hex à partir de rgb",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "objet rgb vers hex",
    "rgbObjToHex": "objet rgb vers hex",
    "bitbybit.color.rgbObjToHex_description": "crée hex à partir d'un objet rgb",
    "rgb": "rgb",
    "Base.ColorRGB": "couleur rgb base",
    "bitbybit.color.hexToRgbMapped": "hex vers rgb mappé",
    "hexToRgbMapped": "hex vers rgb mappé",
    "bitbybit.color.hexToRgbMapped_description": "crée rgb à partir de hex avec mappage de plage",
    "bitbybit.color.getRedParam": "obtenir param rouge",
    "getRedParam": "obtenir param rouge",
    "bitbybit.color.getRedParam_description": "obtient le paramètre rouge",
    "hex to": "hex vers",
    "bitbybit.color.getGreenParam": "obtenir param vert",
    "getGreenParam": "obtenir param vert",
    "bitbybit.color.getGreenParam_description": "obtient le paramètre vert",
    "bitbybit.color.getBlueParam": "obtenir param bleu",
    "getBlueParam": "obtenir param bleu",
    "bitbybit.color.getBlueParam_description": "obtient le paramètre bleu",
    "bitbybit.color.rgbToRed": "rgb vers rouge",
    "rgbToRed": "rgb vers rouge",
    "bitbybit.color.rgbToRed_description": "obtient le rouge de rgb",
    "rgb to": "rgb vers",
    "bitbybit.color.rgbToGreen": "rgb vers vert",
    "rgbToGreen": "rgb vers vert",
    "bitbybit.color.rgbToGreen_description": "obtient le vert de rgb",
    "bitbybit.color.rgbToBlue": "rgb vers bleu",
    "rgbToBlue": "rgb vers bleu",
    "bitbybit.color.rgbToBlue_description": "obtient le bleu de rgb",
    "bitbybit.color.invert": "inverser",
    "invert": "inverser",
    "bitbybit.color.invert_description": "inverse la couleur",
    "blackAndWhite": "noir et blanc",
    "bitbybit.text.create": "créer",
    "bitbybit.text.create_description": "crée du texte",
    "bitbybit.text.split": "diviser",
    "bitbybit.text.split_description": "divise le texte par séparateur",
    "separator": "séparateur",
    "bitbybit.text.replaceAll": "remplacer tout",
    "replaceAll": "remplacer tout",
    "bitbybit.text.replaceAll_description": "remplace toutes les occurrences de texte",
    "search": "rechercher",
    "replaceWith": "remplacer par",
    "bitbybit.text.join": "joindre",
    "join": "joindre",
    "bitbybit.text.join_description": "joint les éléments en texte avec séparateur",
    "string[]": "tableau chaîne",
    "bitbybit.text.toString": "vers chaîne",
    "toString": "vers chaîne",
    "bitbybit.text.toString_description": "convertit l'élément en texte",
    "bitbybit.text.toStringEach": "vers chaîne chacun",
    "toStringEach": "vers chaîne chacun",
    "bitbybit.text.toStringEach_description": "convertit chaque élément de la liste en texte",
    "bitbybit.text.format": "formater",
    "format": "formater",
    "bitbybit.text.format_description": "formate le texte avec des valeurs",
    "values": "valeurs",
    "bitbybit.text.vectorChar": "caractère vectoriel",
    "vectorChar": "caractère vectoriel",
    "bitbybit.text.vectorChar_description": "Crée des segments vectoriels pour un caractère et inclut des informations de largeur et de hauteur.",
    "char": "caractère",
    "bitbybit.text.vectorText": "texte vectoriel",
    "vectorText": "texte vectoriel",
    "bitbybit.text.vectorText_description": "Crée des lignes de texte vectorielles pour un texte donné et inclut des informations de largeur et de hauteur.",
    "bitbybit.dates.toDateString": "vers chaîne date",
    "dates": "dates",
    "toDateString": "vers chaîne date",
    "bitbybit.dates.toDateString_description": "Retourne une date sous forme de chaîne.",
    "date": "date",
    "Date": "date",
    "bitbybit.dates.toISOString": "vers chaîne iso",
    "toISOString": "vers chaîne iso",
    "bitbybit.dates.toISOString_description": "Retourne une date sous forme de chaîne au format ISO.",
    "bitbybit.dates.toJSON": "vers json",
    "toJSON": "vers json",
    "bitbybit.dates.toJSON_description": "Retourne une date sous forme de chaîne au format JSON.",
    "bitbybit.dates.toString": "vers chaîne",
    "bitbybit.dates.toString_description": "Retourne une représentation textuelle d'une date. Le format de la chaîne dépend des paramètres régionaux.",
    "bitbybit.dates.toTimeString": "vers chaîne heure",
    "toTimeString": "vers chaîne heure",
    "bitbybit.dates.toTimeString_description": "Retourne une heure sous forme de chaîne.",
    "bitbybit.dates.toUTCString": "vers chaîne utc",
    "toUTCString": "vers chaîne utc",
    "bitbybit.dates.toUTCString_description": "Retourne une date convertie en chaîne en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.now": "maintenant",
    "now": "maintenant",
    "bitbybit.dates.now_description": "Retourne la date et l'heure actuelles.",
    "bitbybit.dates.createDate": "créer date",
    "createDate": "créer date",
    "bitbybit.dates.createDate_description": "Crée un nouvel objet date en utilisant les paramètres de date fournis.",
    "year": "année",
    "month": "mois",
    "day": "jour",
    "hours": "heures",
    "minutes": "minutes",
    "seconds": "secondes",
    "milliseconds": "millisecondes",
    "bitbybit.dates.createDateUTC": "créer date utc",
    "createDateUTC": "créer date utc",
    "bitbybit.dates.createDateUTC_description": "Retourne le nombre de millisecondes entre minuit, 1er janvier 1970 Temps Universel Coordonné (UTC) (ou GMT) et la date spécifiée.",
    "bitbybit.dates.createFromUnixTimeStamp": "créer depuis timestamp unix",
    "createFromUnixTimeStamp": "créer depuis timestamp unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Crée un nouvel objet date en utilisant le timestamp unix fourni.",
    "unixTimeStamp": "timestamp unix",
    "bitbybit.dates.parseDate": "analyser date",
    "parseDate": "analyser date",
    "bitbybit.dates.parseDate_description": "Analyse une chaîne contenant une date et retourne le nombre de millisecondes entre cette date et minuit, 1er janvier 1970.",
    "parse": "analyser",
    "dateString": "chaîne date",
    "bitbybit.dates.getDayOfMonth": "obtenir jour du mois",
    "getDayOfMonth": "obtenir jour du mois",
    "bitbybit.dates.getDayOfMonth_description": "Obtient le jour du mois, en utilisant l'heure locale.",
    "bitbybit.dates.getWeekday": "obtenir jour semaine",
    "getWeekday": "obtenir jour semaine",
    "bitbybit.dates.getWeekday_description": "Obtient le jour de la semaine, en utilisant l'heure locale.",
    "bitbybit.dates.getYear": "obtenir année",
    "getYear": "obtenir année",
    "bitbybit.dates.getYear_description": "Obtient l'année, en utilisant l'heure locale.",
    "bitbybit.dates.getMonth": "obtenir mois",
    "getMonth": "obtenir mois",
    "bitbybit.dates.getMonth_description": "Obtient le mois, en utilisant l'heure locale.",
    "bitbybit.dates.getHours": "obtenir heures",
    "getHours": "obtenir heures",
    "bitbybit.dates.getHours_description": "Obtient les heures d'une date, en utilisant l'heure locale.",
    "bitbybit.dates.getMinutes": "obtenir minutes",
    "getMinutes": "obtenir minutes",
    "bitbybit.dates.getMinutes_description": "Obtient les minutes d'un objet Date, en utilisant l'heure locale.",
    "bitbybit.dates.getSeconds": "obtenir secondes",
    "getSeconds": "obtenir secondes",
    "bitbybit.dates.getSeconds_description": "Obtient les secondes d'un objet Date, en utilisant l'heure locale.",
    "bitbybit.dates.getMilliseconds": "obtenir millisecondes",
    "getMilliseconds": "obtenir millisecondes",
    "bitbybit.dates.getMilliseconds_description": "Obtient les millisecondes d'une Date, en utilisant l'heure locale.",
    "bitbybit.dates.getTime": "obtenir heure",
    "getTime": "obtenir heure",
    "bitbybit.dates.getTime_description": "Retourne la valeur de temps stockée en millisecondes depuis minuit, 1er janvier 1970 UTC.",
    "bitbybit.dates.getUTCYear": "obtenir année utc",
    "getUTCYear": "obtenir année utc",
    "bitbybit.dates.getUTCYear_description": "Obtient l'année en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.getUTCMonth": "obtenir mois utc",
    "getUTCMonth": "obtenir mois utc",
    "bitbybit.dates.getUTCMonth_description": "Obtient le mois d'un objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.getUTCDay": "obtenir jour utc",
    "getUTCDay": "obtenir jour utc",
    "bitbybit.dates.getUTCDay_description": "Obtient le jour du mois, en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.getUTCHours": "obtenir heures utc",
    "getUTCHours": "obtenir heures utc",
    "bitbybit.dates.getUTCHours_description": "Obtient la valeur des heures dans un objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.getUTCMinutes": "obtenir minutes utc",
    "getUTCMinutes": "obtenir minutes utc",
    "bitbybit.dates.getUTCMinutes_description": "Obtient les minutes d'un objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.getUTCSeconds": "obtenir secondes utc",
    "getUTCSeconds": "obtenir secondes utc",
    "bitbybit.dates.getUTCSeconds_description": "Obtient les secondes d'un objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.getUTCMilliseconds": "obtenir millisecondes utc",
    "getUTCMilliseconds": "obtenir millisecondes utc",
    "bitbybit.dates.getUTCMilliseconds_description": "Obtient les millisecondes d'un objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setYear": "définir année",
    "setYear": "définir année",
    "bitbybit.dates.setYear_description": "Définit l'année de l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setMonth": "définir mois",
    "setMonth": "définir mois",
    "bitbybit.dates.setMonth_description": "Définit la valeur du mois dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setDayOfMonth": "définir jour du mois",
    "setDayOfMonth": "définir jour du mois",
    "bitbybit.dates.setDayOfMonth_description": "Définit la valeur numérique du jour du mois de l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setHours": "définir heures",
    "setHours": "définir heures",
    "bitbybit.dates.setHours_description": "Définit la valeur de l'heure dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setMinutes": "définir minutes",
    "setMinutes": "définir minutes",
    "bitbybit.dates.setMinutes_description": "Définit la valeur des minutes dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setSeconds": "définir secondes",
    "setSeconds": "définir secondes",
    "bitbybit.dates.setSeconds_description": "Définit la valeur des secondes dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setMilliseconds": "définir millisecondes",
    "setMilliseconds": "définir millisecondes",
    "bitbybit.dates.setMilliseconds_description": "Définit la valeur des millisecondes dans l'objet Date en utilisant l'heure locale.",
    "bitbybit.dates.setTime": "définir heure",
    "setTime": "définir heure",
    "bitbybit.dates.setTime_description": "Définit la valeur de la date et de l'heure dans l'objet Date.",
    "time": "heure",
    "bitbybit.dates.setUTCYear": "définir année utc",
    "setUTCYear": "définir année utc",
    "bitbybit.dates.setUTCYear_description": "Définit la valeur de l'année dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCMonth": "définir mois utc",
    "setUTCMonth": "définir mois utc",
    "bitbybit.dates.setUTCMonth_description": "Définit la valeur du mois dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCDay": "définir jour utc",
    "setUTCDay": "définir jour utc",
    "bitbybit.dates.setUTCDay_description": "Définit le jour numérique du mois dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCHours": "définir heures utc",
    "setUTCHours": "définir heures utc",
    "bitbybit.dates.setUTCHours_description": "Définit la valeur des heures dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCMinutes": "définir minutes utc",
    "setUTCMinutes": "définir minutes utc",
    "bitbybit.dates.setUTCMinutes_description": "Définit la valeur des minutes dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCSeconds": "définir secondes utc",
    "setUTCSeconds": "définir secondes utc",
    "bitbybit.dates.setUTCSeconds_description": "Définit la valeur des secondes dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "définir millisecondes utc",
    "setUTCMilliseconds": "définir millisecondes utc",
    "bitbybit.dates.setUTCMilliseconds_description": "Définit la valeur des millisecondes dans l'objet Date en utilisant le Temps Universel Coordonné (UTC).",
    "bitbybit.json.stringify": "transformer en chaîne",
    "json": "json",
    "stringify": "transformer en chaîne",
    "bitbybit.json.stringify_description": "transforme la valeur d'entrée en chaîne",
    "bitbybit.json.parse": "analyser",
    "bitbybit.json.parse_description": "analyse la valeur d'entrée",
    "bitbybit.json.query": "requête",
    "query": "requête",
    "bitbybit.json.query_description": "interroge la valeur d'entrée",
    "jsonpath": "chemin json",
    "bitbybit.json.setValueOnProp": "définir valeur sur prop",
    "setValueOnProp": "définir valeur sur prop",
    "bitbybit.json.setValueOnProp_description": "définit la valeur sur la propriété json",
    "props": "props",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "obtenir json tableau par première correspondance prop",
    "getJsonFromArrayByFirstPropMatch": "obtenir json tableau par première correspondance prop",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "obtient le json du tableau par la première correspondance de propriété",
    "jsonArray": "tableau json",
    "any[]": "tableau tout",
    "match": "correspondance",
    "bitbybit.json.getValueOnProp": "obtenir valeur sur prop",
    "getValueOnProp": "obtenir valeur sur prop",
    "bitbybit.json.getValueOnProp_description": "obtient la valeur de la propriété dans json",
    "bitbybit.json.setValue": "définir valeur",
    "bitbybit.json.setValue_description": "définit la valeur sur json par chemin",
    "prop": "prop",
    "bitbybit.json.setValuesOnPaths": "définir valeurs sur chemins",
    "setValuesOnPaths": "définir valeurs sur chemins",
    "bitbybit.json.setValuesOnPaths_description": "définit plusieurs valeurs sur json par chemins",
    "paths": "chemins",
    "bitbybit.json.paths": "chemins",
    "bitbybit.json.paths_description": "trouve les chemins vers les éléments dans l'objet",
    "bitbybit.json.createEmpty": "vide",
    "bitbybit.json.createEmpty_description": "crée un objet javascript vide",
    "bitbybit.json.previewAndSaveJson": "prévisualiser et sauvegarder json",
    "previewAndSaveJson": "prévisualiser et sauvegarder json",
    "bitbybit.json.previewAndSaveJson_description": "prévisualise le json et propose une option de sauvegarde",
    "preview": "prévisualiser",
    "bitbybit.json.previewJson": "prévisualiser json",
    "previewJson": "prévisualiser json",
    "bitbybit.json.previewJson_description": "prévisualise le json",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "courbe par nœuds points contrôle poids",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "courbe par nœuds points contrôle poids",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "crée une courbe nurbs avec nœuds, points de contrôle, poids",
    "degree": "degré",
    "knots": "nœuds",
    "bitbybit.verb.curve.createCurveByPoints": "courbe par points",
    "createCurveByPoints": "courbe par points",
    "bitbybit.verb.curve.createCurveByPoints_description": "crée une courbe nurbs avec points de contrôle",
    "bitbybit.verb.curve.createBezierCurve": "courbe bezier",
    "createBezierCurve": "courbe bezier",
    "bitbybit.verb.curve.createBezierCurve_description": "crée une courbe nurbs bezier avec points de contrôle et poids",
    "bitbybit.verb.curve.clone": "cloner",
    "bitbybit.verb.curve.clone_description": "clone la courbe nurbs",
    "bitbybit.verb.curve.closestParam": "param plus proche",
    "closestParam": "param plus proche",
    "bitbybit.verb.curve.closestParam_description": "trouve le paramètre le plus proche sur la courbe nurbs depuis un point",
    "bitbybit.verb.curve.closestParams": "params plus proches",
    "closestParams": "params plus proches",
    "bitbybit.verb.curve.closestParams_description": "trouve les paramètres les plus proches sur la courbe nurbs depuis des points",
    "bitbybit.verb.curve.closestPoint": "point plus proche",
    "closestPoint": "point plus proche",
    "bitbybit.verb.curve.closestPoint_description": "trouve le point le plus proche sur la courbe nurbs depuis un point",
    "bitbybit.verb.curve.closestPoints": "points plus proches",
    "closestPoints": "points plus proches",
    "bitbybit.verb.curve.closestPoints_description": "trouve les points les plus proches sur la courbe nurbs depuis des points",
    "bitbybit.verb.curve.controlPoints": "points contrôle",
    "controlPoints": "points contrôle",
    "bitbybit.verb.curve.controlPoints_description": "trouve les points de contrôle de la courbe nurbs",
    "bitbybit.verb.curve.degree": "degré",
    "bitbybit.verb.curve.degree_description": "trouve le degré de la courbe nurbs",
    "bitbybit.verb.curve.derivatives": "dérivées",
    "derivatives": "dérivées",
    "bitbybit.verb.curve.derivatives_description": "trouve les dérivées de la courbe nurbs au paramètre",
    "numDerivatives": "nb dérivées",
    "parameter": "paramètre",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "diviser par longueur arc égale en params",
    "divideByEqualArcLengthToParams": "diviser par longueur arc égale en params",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "divise la courbe par longueur d'arc égale en paramètres",
    "subdivision": "subdivision",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "diviser par longueur arc égale en points",
    "divideByEqualArcLengthToPoints": "diviser par longueur arc égale en points",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "divise la courbe par longueur d'arc égale en points",
    "bitbybit.verb.curve.divideByArcLengthToParams": "diviser par longueur arc en params",
    "divideByArcLengthToParams": "diviser par longueur arc en params",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "divise la courbe par longueur d'arc en paramètres",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "diviser par longueur arc en points",
    "divideByArcLengthToPoints": "diviser par longueur arc en points",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "divise la courbe par longueur d'arc en points",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "diviser courbes par longueur arc égale en points",
    "divideCurvesByEqualArcLengthToPoints": "diviser courbes par longueur arc égale en points",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divise plusieurs courbes par longueur d'arc égale en points",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "diviser courbes par longueur arc en points",
    "divideCurvesByArcLengthToPoints": "diviser courbes par longueur arc en points",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divise plusieurs courbes par longueur d'arc en points",
    "bitbybit.verb.curve.domain": "domaine",
    "bitbybit.verb.curve.domain_description": "trouve l'intervalle de domaine des paramètres de la courbe",
    "bitbybit.verb.curve.startPoint": "point départ",
    "bitbybit.verb.curve.startPoint_description": "point de départ de la courbe",
    "bitbybit.verb.curve.endPoint": "point arrivée",
    "bitbybit.verb.curve.endPoint_description": "point d'arrivée de la courbe",
    "bitbybit.verb.curve.startPoints": "points départ",
    "bitbybit.verb.curve.startPoints_description": "points de départ des courbes",
    "bitbybit.verb.curve.endPoints": "points arrivée",
    "bitbybit.verb.curve.endPoints_description": "points d'arrivée des courbes",
    "bitbybit.verb.curve.knots": "nœuds",
    "bitbybit.verb.curve.knots_description": "trouve les nœuds de la courbe nurbs",
    "bitbybit.verb.curve.lengthAtParam": "longueur au param",
    "lengthAtParam": "longueur au param",
    "bitbybit.verb.curve.lengthAtParam_description": "obtient la longueur de la courbe nurbs au paramètre",
    "bitbybit.verb.curve.length": "longueur",
    "bitbybit.verb.curve.length_description": "obtient la longueur de la courbe nurbs",
    "bitbybit.verb.curve.paramAtLength": "param à longueur",
    "paramAtLength": "param à longueur",
    "bitbybit.verb.curve.paramAtLength_description": "obtient le paramètre à la longueur sur la courbe nurbs",
    "bitbybit.verb.curve.pointAtParam": "point au param",
    "pointAtParam": "point au param",
    "bitbybit.verb.curve.pointAtParam_description": "obtient le point au paramètre sur la courbe nurbs",
    "bitbybit.verb.curve.pointsAtParam": "points au param",
    "pointsAtParam": "points au param",
    "bitbybit.verb.curve.pointsAtParam_description": "obtient les points aux paramètres sur les courbes nurbs",
    "bitbybit.verb.curve.reverse": "inverser",
    "bitbybit.verb.curve.reverse_description": "inverse la courbe nurbs",
    "bitbybit.verb.curve.split": "diviser",
    "bitbybit.verb.curve.split_description": "divise la courbe nurbs au paramètre",
    "bitbybit.verb.curve.tangent": "tangente",
    "bitbybit.verb.curve.tangent_description": "tangente de la courbe nurbs au paramètre",
    "bitbybit.verb.curve.tessellate": "tesseller",
    "tessellate": "tesseller",
    "bitbybit.verb.curve.tessellate_description": "tesselle la courbe nurbs en points",
    "bitbybit.verb.curve.transform": "transformer",
    "bitbybit.verb.curve.transform_description": "transforme la courbe nurbs",
    "bitbybit.verb.curve.transformCurves": "transformer courbes",
    "transformCurves": "transformer courbes",
    "bitbybit.verb.curve.transformCurves_description": "transforme les courbes nurbs",
    "bitbybit.verb.curve.weights": "poids",
    "bitbybit.verb.curve.weights_description": "poids de la courbe nurbs",
    "bitbybit.verb.curve.circle.createCircle": "cercle",
    "createCircle": "cercle",
    "bitbybit.verb.curve.circle.createCircle_description": "crée une courbe nurbs cercle",
    "xAxis": "axe x",
    "yAxis": "axe y",
    "bitbybit.verb.curve.circle.createArc": "arc",
    "createArc": "arc",
    "bitbybit.verb.curve.circle.createArc_description": "crée une courbe nurbs arc",
    "minAngle": "angle min",
    "maxAngle": "angle max",
    "bitbybit.verb.curve.circle.center": "centre",
    "bitbybit.verb.curve.circle.center_description": "obtient le centre du cercle ou de l'arc",
    "bitbybit.verb.curve.circle.radius": "rayon",
    "bitbybit.verb.curve.circle.radius_description": "obtient le rayon du cercle ou de l'arc",
    "bitbybit.verb.curve.circle.maxAngle": "angle max",
    "bitbybit.verb.curve.circle.maxAngle_description": "obtient l'angle max de l'arc en degrés",
    "bitbybit.verb.curve.circle.minAngle": "angle min",
    "bitbybit.verb.curve.circle.minAngle_description": "obtient l'angle min de l'arc en degrés",
    "bitbybit.verb.curve.circle.xAxis": "axe x",
    "bitbybit.verb.curve.circle.xAxis_description": "obtient l'angle x de l'arc",
    "bitbybit.verb.curve.circle.yAxis": "axe y",
    "bitbybit.verb.curve.circle.yAxis_description": "obtient l'angle y de l'arc",
    "bitbybit.verb.curve.ellipse.createEllipse": "ellipse",
    "createEllipse": "ellipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "crée une courbe nurbs ellipse",
    "bitbybit.verb.curve.ellipse.createArc": "arc",
    "bitbybit.verb.curve.ellipse.createArc_description": "crée une courbe nurbs arc d'ellipse",
    "bitbybit.verb.curve.ellipse.center": "centre",
    "bitbybit.verb.curve.ellipse.center_description": "obtient le centre de l'ellipse ou de l'arc",
    "bitbybit.verb.curve.ellipse.maxAngle": "angle max",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "obtient l'angle max de l'arc en degrés",
    "bitbybit.verb.curve.ellipse.minAngle": "angle min",
    "bitbybit.verb.curve.ellipse.minAngle_description": "obtient l'angle min de l'arc en degrés",
    "bitbybit.verb.curve.ellipse.xAxis": "axe x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "obtient l'angle x de l'arc ou de l'ellipse",
    "bitbybit.verb.curve.ellipse.yAxis": "axe y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "obtient l'angle y de l'arc ou de l'ellipse",
    "bitbybit.verb.surface.boundaries": "limites",
    "boundaries": "limites",
    "bitbybit.verb.surface.boundaries_description": "obtient les courbes nurbs des arêtes limites de la surface",
    "bitbybit.verb.surface.createSurfaceByCorners": "surface par coins",
    "createSurfaceByCorners": "surface par coins",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "crée une surface avec 4 points de coin",
    "point3": "point 3",
    "point4": "point 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "surface par nœuds points contrôle poids",
    "createSurfaceByKnotsControlPointsWeights": "surface par nœuds points contrôle poids",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "crée une surface nurbs avec nœuds uv, degrés, points, poids",
    "degreeU": "degré u",
    "degreeV": "degré v",
    "knotsU": "nœuds u",
    "knotsV": "nœuds v",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "surface par loft courbes",
    "createSurfaceByLoftingCurves": "surface par loft courbes",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "crée une surface nurbs par loft de courbes",
    "bitbybit.verb.surface.clone": "cloner",
    "bitbybit.verb.surface.clone_description": "clone la surface nurbs",
    "bitbybit.verb.surface.closestParam": "param plus proche",
    "bitbybit.verb.surface.closestParam_description": "trouve le paramètre le plus proche sur la surface depuis un point",
    "bitbybit.verb.surface.closestPoint": "point plus proche",
    "bitbybit.verb.surface.closestPoint_description": "trouve le point le plus proche sur la surface depuis un point",
    "bitbybit.verb.surface.controlPoints": "points contrôle",
    "bitbybit.verb.surface.controlPoints_description": "obtient les points de contrôle sur la surface",
    "bitbybit.verb.surface.degreeU": "degré u",
    "bitbybit.verb.surface.degreeU_description": "obtient le degré u de la surface",
    "bitbybit.verb.surface.degreeV": "degré v",
    "bitbybit.verb.surface.degreeV_description": "obtient le degré v de la surface",
    "bitbybit.verb.surface.derivatives": "dérivées",
    "bitbybit.verb.surface.derivatives_description": "obtient les dérivées de la surface à uv",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "domaine u",
    "domainU": "domaine u",
    "bitbybit.verb.surface.domainU_description": "obtient le domaine u de la surface",
    "bitbybit.verb.surface.domainV": "domaine v",
    "domainV": "domaine v",
    "bitbybit.verb.surface.domainV_description": "obtient le domaine v de la surface",
    "bitbybit.verb.surface.isocurve": "isocourbe",
    "isocurve": "isocourbe",
    "bitbybit.verb.surface.isocurve_description": "obtient l'isocourbe nurbs sur la surface",
    "useV": "utiliser v",
    "bitbybit.verb.surface.isocurvesSubdivision": "subdivision isocourbes",
    "isocurvesSubdivision": "subdivision isocourbes",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "subdivise la surface en isocourbes",
    "isocurveSegments": "segments isocourbe",
    "bitbybit.verb.surface.isocurvesAtParams": "isocourbes aux params",
    "isocurvesAtParams": "isocourbes aux params",
    "bitbybit.verb.surface.isocurvesAtParams_description": "subdivise la surface en isocourbes aux paramètres",
    "parameters": "paramètres",
    "bitbybit.verb.surface.knotsU": "nœuds u",
    "bitbybit.verb.surface.knotsU_description": "obtient les nœuds u de la surface",
    "bitbybit.verb.surface.knotsV": "nœuds v",
    "bitbybit.verb.surface.knotsV_description": "obtient les nœuds v de la surface",
    "bitbybit.verb.surface.normal": "normale",
    "bitbybit.verb.surface.normal_description": "obtient la normale sur la surface à uv",
    "bitbybit.verb.surface.point": "point",
    "bitbybit.verb.surface.point_description": "obtient le point sur la surface à uv",
    "bitbybit.verb.surface.reverse": "inverser",
    "bitbybit.verb.surface.reverse_description": "inverse les uv et les isocourbes de la surface nurbs",
    "bitbybit.verb.surface.split": "diviser",
    "bitbybit.verb.surface.split_description": "divise la surface nurbs en deux",
    "bitbybit.verb.surface.transformSurface": "transformer surface",
    "transformSurface": "transformer surface",
    "bitbybit.verb.surface.transformSurface_description": "transforme la surface nurbs avec des transformations",
    "bitbybit.verb.surface.weights": "poids",
    "bitbybit.verb.surface.weights_description": "obtient les poids de la surface",
    "bitbybit.verb.surface.cone.create": "créer",
    "cone": "cône",
    "bitbybit.verb.surface.cone.create_description": "crée une surface nurbs conique",
    "bitbybit.verb.surface.cone.axis": "axe",
    "bitbybit.verb.surface.cone.axis_description": "obtient l'axe du cône",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "obtient la base du cône",
    "bitbybit.verb.surface.cone.height": "hauteur",
    "bitbybit.verb.surface.cone.height_description": "obtient la hauteur du cône",
    "bitbybit.verb.surface.cone.radius": "rayon",
    "bitbybit.verb.surface.cone.radius_description": "obtient le rayon du cône",
    "bitbybit.verb.surface.cone.xAxis": "axe x",
    "bitbybit.verb.surface.cone.xAxis_description": "obtient l'axe x du cône",
    "bitbybit.verb.surface.cylinder.create": "créer",
    "bitbybit.verb.surface.cylinder.create_description": "crée une surface nurbs cylindrique",
    "bitbybit.verb.surface.cylinder.axis": "axe",
    "bitbybit.verb.surface.cylinder.axis_description": "obtient l'axe du cylindre",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "obtient la base du cylindre",
    "bitbybit.verb.surface.cylinder.height": "hauteur",
    "bitbybit.verb.surface.cylinder.height_description": "obtient la hauteur du cylindre",
    "bitbybit.verb.surface.cylinder.radius": "rayon",
    "bitbybit.verb.surface.cylinder.radius_description": "obtient le rayon du cylindre",
    "bitbybit.verb.surface.cylinder.xAxis": "axe x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "obtient l'axe x du cylindre",
    "bitbybit.verb.surface.extrusion.create": "créer",
    "extrusion": "extrusion",
    "bitbybit.verb.surface.extrusion.create_description": "crée une extrusion de surface nurbs à partir d'une courbe",
    "profile": "profil",
    "bitbybit.verb.surface.extrusion.direction": "direction",
    "bitbybit.verb.surface.extrusion.direction_description": "obtient le vecteur direction de l'extrusion",
    "bitbybit.verb.surface.extrusion.profile": "profil",
    "bitbybit.verb.surface.extrusion.profile_description": "obtient la courbe nurbs profil de l'extrusion",
    "bitbybit.verb.surface.sphere.create": "créer",
    "bitbybit.verb.surface.sphere.create_description": "crée une surface nurbs sphérique",
    "bitbybit.verb.surface.sphere.radius": "rayon",
    "bitbybit.verb.surface.sphere.radius_description": "obtient le rayon de la surface nurbs sphérique",
    "bitbybit.verb.surface.sphere.center": "centre",
    "bitbybit.verb.surface.sphere.center_description": "obtient le centre de la surface nurbs sphérique",
    "bitbybit.verb.surface.revolved.create": "créer",
    "revolved": "révolution",
    "bitbybit.verb.surface.revolved.create_description": "crée une surface nurbs de révolution",
    "bitbybit.verb.surface.revolved.profile": "profil",
    "bitbybit.verb.surface.revolved.profile_description": "obtient la courbe nurbs profil de la surface de révolution",
    "revolution": "révolution",
    "bitbybit.verb.surface.revolved.center": "centre",
    "bitbybit.verb.surface.revolved.center_description": "obtient la courbe nurbs centrale de la surface de révolution",
    "bitbybit.verb.surface.revolved.axis": "axe",
    "bitbybit.verb.surface.revolved.axis_description": "obtient l'axe de rotation de la surface de révolution",
    "bitbybit.verb.surface.revolved.angle": "angle",
    "bitbybit.verb.surface.revolved.angle_description": "obtient l'angle de rotation de la surface de révolution",
    "bitbybit.verb.surface.sweep.create": "créer",
    "sweep": "balayage",
    "bitbybit.verb.surface.sweep.create_description": "crée une surface nurbs par balayage",
    "rail": "rail",
    "bitbybit.verb.surface.sweep.profile": "profil",
    "bitbybit.verb.surface.sweep.profile_description": "obtient la courbe nurbs profil de la surface balayée",
    "bitbybit.verb.surface.sweep.rail": "rail",
    "bitbybit.verb.surface.sweep.rail_description": "obtient la courbe nurbs rail de la surface balayée",
    "bitbybit.verb.intersect.curves": "courbes",
    "bitbybit.verb.intersect.curves_description": "intersecte deux courbes nurbs verb",
    "firstCurve": "première courbe",
    "secondCurve": "seconde courbe",
    "bitbybit.verb.intersect.curveAndSurface": "courbe et surface",
    "curveAndSurface": "courbe et surface",
    "bitbybit.verb.intersect.curveAndSurface_description": "intersecte courbe et surface",
    "bitbybit.verb.intersect.surfaces": "surfaces",
    "bitbybit.verb.intersect.surfaces_description": "intersecte deux surfaces",
    "firstSurface": "première surface",
    "secondSurface": "seconde surface",
    "bitbybit.verb.intersect.curveCurveFirstParams": "courbe courbe premiers params",
    "curveCurveFirstParams": "courbe courbe premiers params",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "obtient les paramètres d'intersection sur la première courbe",
    "intersections": "intersections",
    "BaseTypes.CurveCurveIntersection[]": "tableau intersection courbe courbe types base",
    "bitbybit.verb.intersect.curveCurveSecondParams": "courbe courbe seconds params",
    "curveCurveSecondParams": "courbe courbe seconds params",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "obtient les paramètres d'intersection sur la seconde courbe",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "courbe courbe premiers points",
    "curveCurveFirstPoints": "courbe courbe premiers points",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "obtient les points d'intersection sur la première courbe",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "courbe courbe seconds points",
    "curveCurveSecondPoints": "courbe courbe seconds points",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "obtient les points d'intersection sur la seconde courbe",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "courbe surface params courbe",
    "curveSurfaceCurveParams": "courbe surface params courbe",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "obtient les paramètres d'intersection sur la courbe",
    "BaseTypes.CurveSurfaceIntersection[]": "tableau intersection courbe surface types base",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "courbe surface params surface",
    "curveSurfaceSurfaceParams": "courbe surface params surface",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "obtient les paramètres d'intersection sur la surface",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "courbe surface points courbe",
    "curveSurfaceCurvePoints": "courbe surface points courbe",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "obtient les points d'intersection sur la courbe",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "courbe surface points surface",
    "curveSurfaceSurfacePoints": "courbe surface points surface",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "obtient les points d'intersection sur la surface",
    "bitbybit.tag.create": "créer",
    "tag": "balise",
    "bitbybit.tag.create_description": "crée un dto de balise",
    "adaptDepth": "adapter profondeur",
    "needsUpdate": "nécessite mise à jour",
    "bitbybit.time.registerRenderFunction": "enregistrer fonction rendu",
    "registerRenderFunction": "enregistrer fonction rendu",
    "bitbybit.time.registerRenderFunction_description": "enregistre la fonction dans la boucle de rendu",
    "bitbybit.asset.getFile": "obtenir fichier",
    "asset": "actif",
    "getFile": "obtenir fichier",
    "bitbybit.asset.getFile_description": "obtient le fichier actif",
    "bitbybit.asset.getLocalFile": "obtenir fichier local",
    "getLocalFile": "obtenir fichier local",
    "bitbybit.asset.getLocalFile_description": "obtient le fichier actif local depuis le navigateur",
    "bitbybit.asset.fetchBlob": "récupérer blob",
    "fetchBlob": "récupérer blob",
    "bitbybit.asset.fetchBlob_description": "récupère le blob depuis l'url cors",
    "fetch": "récupérer",
    "bitbybit.asset.fetchFile": "récupérer fichier",
    "fetchFile": "récupérer fichier",
    "bitbybit.asset.fetchFile_description": "récupère le fichier depuis l'url cors",
    "bitbybit.asset.fetchJSON": "récupérer json",
    "fetchJSON": "récupérer json",
    "bitbybit.asset.fetchJSON_description": "récupère le json depuis l'url cors",
    "bitbybit.asset.fetchText": "récupérer texte",
    "fetchText": "récupérer texte",
    "bitbybit.asset.fetchText_description": "récupère le texte depuis l'url cors",
    "bitbybit.asset.createObjectURL": "url objet",
    "createObjectURL": "url objet",
    "bitbybit.asset.createObjectURL_description": "crée une url vers le fichier en mémoire",
    "file": "fichier",
    "File | Blob": "Fichier | Blob",
    "bitbybit.asset.createObjectURLs": "urls objet",
    "createObjectURLs": "urls objet",
    "bitbybit.asset.createObjectURLs_description": "crée des urls vers les fichiers en mémoire",
    "files": "fichiers",
    "(File | Blob)[]": "tableau Fichier | Blob",
    "exec": "exécuter",
    "Visible": "Visible",
    "Hidden": "Caché",
    "flatten": "aplatir",
    "force exec": "forcer exécution",
    "console log": "log console",
    "preview data": "prévisualiser données",
    "flow": "flux",
    "code": "code",
    "runner": "exécuteur",
    "counters": "compteurs",
    "actions": "actions",
    "loops": "boucles",
    "interval": "intervalle",
    "delay": "délai",
    "expire": "expirer",
    "timeout": "délai",
    "counter min max": "compteur min max",
    "counter steps": "compteur pas",
    "reset": "réinitialiser",
    "trigger": "déclencher",
    "mouse": "souris",
    "mouse click": "clic souris",
    "key": "touche",
    "pointer": "pointeur",
    "pick info": "info sélection",
    "down": "bas",
    "wheel": "molette",
    "tap": "tap",
    "double tap": "double tap",
    "render": "rendu",
    "passed ms": "ms écoulées",
    "babylon observable listener": "écouteur observable babylon",
    "object": "objet",
    "observable selector": "sélecteur observable",
    "get event data": "obtenir données événement",
    "exec click": "exécuter clic",
    "exec down": "exécuter bas",
    "toggle": "basculer",
    "flip flop": "bascule",
    "boolean gate": "porte booléenne",
    "boolean gate silent": "porte booléenne silencieuse",
    "is undefined": "est indéfini",
    "for loop": "boucle for",
    "last": "dernier",
    "for each loop": "boucle for each",
    "element": "élément",
    "body": "corps",
    "complete": "terminé",
    "editors": "éditeurs",
    "inputs": "entrées",
    "outputs": "sorties",
    "recent": "récent",
    "Clear": "Effacer",
    "Run": "Exécuter",
    "Swap Canvas": "Échanger Canvas",
    "Local Assets": "Actifs Locaux",
    "Import": "Importer",
    "Copy to Clipboard": "Copier dans le Presse-papiers",
    "Paste from Clipboard": "Coller du Presse-papiers",
    "Export": "Exporter",
    "Export to runner": "Exporter vers exécuteur",
    "Clean Cache": "Nettoyer Cache",
    "Community": "Communauté",
    "Sponsors and Partners": "Sponsors et Partenaires",
    "API Documentation": "Documentation API",
    "About": "À propos",
    "Toolbox": "Boîte à outils",
    "More": "Plus",
    "bitbybit.code.typeScriptEditor": "éditeur typescript",
    "bitbybit.code.typeScriptEditor_description": "Permet d'écrire du code TypeScript avec l'intellisense complet de bitbybit dans une seule fonction. Ce que la fonction start retourne sera vu comme une sortie du composant.",
    "bitbybit.code.javaScriptEditor": "éditeur javascript",
    "bitbybit.code.javaScriptEditor_description": "Permet d'écrire du code JavaScript dans une seule fonction. Ce que la fonction start retourne sera vu comme une sortie du composant.",
    "bitbybit.code.jsonEditor": "éditeur json",
    "bitbybit.code.jsonEditor_description": "Permet d'écrire du code JSON. Ce que la fonction start retourne sera vu comme une sortie du composant.",
    "bitbybit.flow.actions.keyboard": "clavier",
    "bitbybit.flow.actions.keyboard_description": "S'exécutera sur les événements clavier en cliquant sur les boutons.",
    "bitbybit.flow.actions.mouseClick": "clic souris",
    "bitbybit.flow.actions.mouseClick_description": "S'exécutera sur les événements souris en cliquant sur les boutons.",
    "bitbybit.flow.actions.start": "démarrer",
    "bitbybit.flow.actions.start_description": "Démarre le flux de contrôle et déclenche les exécutions.",
    "bitbybit.flow.actions.trigger": "déclencher",
    "bitbybit.flow.actions.trigger_description": "Déclenche l'exécution en cliquant sur le bouton.",
    "bitbybit.flow.babylon.gui.button": "bouton",
    "bitbybit.flow.babylon.gui.button_description": "S'exécutera sur divers événements de pointeur en cliquant sur le bouton gauche de la souris sur le canvas babylonjs.",
    "bitbybit.flow.babylon.scene.pointerEvents": "pointeur",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "S'exécutera sur divers événements de pointeur en cliquant sur le bouton gauche de la souris sur le canvas babylonjs.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "obtenir données événement",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Obtient les données d'événement du résultat observé de l'écouteur observable.",
    "bitbybit.flow.babylon.observableListener": "écouteur observable babylon",
    "bitbybit.flow.babylon.observableListener_description": "S'abonnera et écoutera n'importe quel observable babylonjs.",
    "bitbybit.flow.babylon.render": "rendu",
    "bitbybit.flow.babylon.render_description": "S'exécute à chaque frame de rendu babylonjs.",
    "bitbybit.flow.counters.counterMinMax": "compteur min max",
    "bitbybit.flow.counters.counterMinMax_description": "Compte le nombre d'exécutions de flux entre les valeurs min et max. Quand max est atteint, il se réinitialise",
    "bitbybit.flow.counters.counterSteps": "compteur pas",
    "bitbybit.flow.counters.counterSteps_description": "Compte le nombre d'exécutions de flux en commençant par la valeur de comptage donnée et en augmentant à chaque exécution par le pas donné de la liste, jusqu'à ce que les pas soient terminés. Quand la fin est atteinte, il se réinitialise",
    "bitbybit.flow.counters.counter": "compteur",
    "bitbybit.flow.counters.counter_description": "Compte le nombre d'exécutions de flux.",
    "bitbybit.flow.logic.booleanGateSilent": "porte booléenne silencieuse",
    "bitbybit.flow.logic.booleanGateSilent_description": "Déclenche différents événements d'exécution en fonction de la valeur du booléen fourni, mais ne s'exécute que lorsque le booléen change de valeur, ce qui empêche plusieurs événements de se déclencher constamment même si aucun changement ne s'est produit.",
    "bitbybit.flow.logic.booleanGate": "porte booléenne",
    "bitbybit.flow.logic.booleanGate_description": "Déclenche différents événements d'exécution en fonction de la valeur du booléen fourni.",
    "bitbybit.flow.logic.flipFlop": "bascule",
    "bitbybit.flow.logic.flipFlop_description": "Chaque fois qu'un événement est exécuté, un événement différent se déclenche, créant essentiellement une fonctionnalité de bascule.",
    "bitbybit.flow.logic.isUndefined": "est indéfini",
    "bitbybit.flow.logic.isUndefined_description": "Vérifie si la valeur fournie est indéfinie et déclenche un événement vrai ou faux.",
    "bitbybit.flow.loops.forEach": "boucle for each",
    "bitbybit.flow.loops.forEach_description": "Boucle For each qui parcourt tous les éléments de la liste.",
    "bitbybit.flow.loops.for": "boucle for",
    "bitbybit.flow.loops.for_description": "Boucle For qui exécute le corps entre deux valeurs.",
    "bitbybit.flow.time.delay": "délai",
    "bitbybit.flow.time.delay_description": "Retarde l'exécution par le délai donné en ms.",
    "bitbybit.flow.time.interval": "intervalle",
    "bitbybit.flow.time.interval_description": "Exécute le flux à chaque intervalle donné en ms.",
    "bitbybit.lists.createList": "créer liste",
    "bitbybit.lists.createList_description": "Crée une liste à partir des éléments donnés.",
    "bitbybit.lists.flatten": "aplatir",
    "bitbybit.lists.flatten_description": "Aplatit la liste de listes en une seule liste.",
    "bitbybit.lists.passThrough": "laisser passer",
    "bitbybit.lists.passThrough_description": "Caste la valeur au type 'any' et passe l'entrée à la sortie sans aucune modification.",
    "bitbybit.math.numberSlider": "curseur nombre",
    "bitbybit.math.numberSlider_description": "Crée un nombre avec un curseur. Vous pouvez configurer les valeurs min, max et pas.",
    "bitbybit.consoleLog": "log console",
    "bitbybit.consoleLog_description": "Enregistre l'entrée dans la console du navigateur.",
    "bitbybit.previewData": "prévisualiser données",
    "bitbybit.previewData_description": "Affiche les données d'entrée dans une zone d'aperçu. Il peut s'agir de texte, de nombres, d'objets json, de tableaux, etc. Les objets Javascript circulaires ne sont pas autorisés.",
    "bitbybit.runner.getRunnerInputValue": "obtenir valeur entrée exécuteur",
    "bitbybit.runner.getRunnerInputValue_description": "Obtenir la valeur d'entrée de l'exécuteur à partir du JSON d'entrées. Ce composant retournera toujours une valeur indéfinie dans le contexte de l'éditeur.",
    "bitbybit.runner.getRunnerInputs": "obtenir entrées exécuteur",
    "bitbybit.runner.getRunnerInputs_description": "Obtenir les entrées de l'exécuteur en JSON. Ce composant retournera toujours un objet vide dans le contexte de l'éditeur.",
    "bitbybit.runner.run": "exécuter",
    "bitbybit.runner.run_description": "Exécute le code javascript de l'exécuteur",
    "bitbybit.runner.setRunnerResult": "définir résultat exécuteur",
    "bitbybit.runner.setRunnerResult_description": "Définit le résultat JSON complet pour l'exécuteur. Gardez à l'esprit qu'il est plus sûr de définir des valeurs car cette méthode écrasera tout l'objet de résultat avec la valeur fournie.",
    "bitbybit.runner.setRunnerResultArrayValue": "définir valeur tableau résultat exécuteur",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Définit la valeur du résultat de l'exécuteur sur la propriété de l'objet JSON. Chaque valeur sera ajoutée à un tableau, qui est la valeur de la propriété.",
    "bitbybit.runner.setRunnerResultValue": "définir valeur résultat exécuteur",
    "bitbybit.runner.setRunnerResultValue_description": "Définit la valeur du résultat de l'exécuteur sur la propriété de l'objet JSON.",
    "bitbybit.text.areaCreate": "zone texte",
    "bitbybit.text.areaCreate_description": "Crée une zone de texte dans l'éditeur. Vous pouvez configurer le texte, la largeur et la hauteur de la zone.",
    "update on drag": "mettre à jour au glisser",
    "paste": "coller",
    "duplicate": "dupliquer",
    "delete": "supprimer",
    "keyboard": "clavier",
    "data": "données",
    "observables": "observables",
    "buttons": "boutons",
    "variables": "variables",
    "functions": "fonctions",
    "loop": "boucle",
    "apply": "appliquer",
    "async context": "contexte async",
    "async context description": "Créer un contexte asynchrone pouvant utiliser des composants await, simplifiant l'exécution et la lisibilité du code asynchrone.",
    "then": "ensuite",
    "await": "attendre",
    "await description": "Attend que la promesse soit résolue et retourne la valeur.",
    "when the": "quand le",
    "error": "erreur",
    "happens in the promise": "se produit dans la promesse",
    "catch": "capturer",
    "catch description": "Capture l'erreur qui peut se produire lors de l'exécution de code asynchrone. L'utilisateur peut choisir de gérer les erreurs de manière appropriée.",
    "cancel the interval execution": "annuler l'exécution de l'intervalle",
    "cancel the interval description": "Annule l'exécution de l'intervalle en fournissant le gestionnaire.",
    "cancel the timeout execution": "annuler l'exécution du délai",
    "cancel the timeout description": "Annule l'exécution du délai en fournissant le gestionnaire.",
    "key down": "touche enfoncée",
    "key down descritpion": "Déclenche le code lorsque l'événement touche enfoncée se produit.",
    "key up": "touche relâchée",
    "key up description": "Déclenche le code lorsque l'événement touche relâchée se produit.",
    "key press": "touche pressée",
    "key press description": "Déclenche le code lorsque l'événement touche pressée se produit.",
    "is key pressed": "est touche pressée",
    "block_validation_required": "doit être fourni",
    "block_validation_of_length": "doit contenir un nombre d'éléments de",
    "block_validation_higher_or_equal": "doit être supérieur ou égal à",
    "block_validation_lower_or_equal": "doit être inférieur ou égal à",
    "block_validation_range": "doit être dans la plage",
    "block_validation_smaller_than": "doit être inférieur à",
    "block_validation_smaller_or_equal_than": "doit être inférieur ou égal à",
    "block_validation_larger_than": "doit être supérieur à",
    "block_validation_larger_or_equal_than": "doit être supérieur ou égal à",
    "save text to file": "sauvegarder texte fichier",
    "save text to file description": "Sauvegarde le texte dans un fichier et vous permet de choisir le nom et l'extension. Ce composant ne prévisualise pas le texte et peut être utilisé dans des situations où le texte peut être trop volumineux pour être édité dans un champ de zone de texte.",
    "print text on screen": "imprimer texte écran",
    "print text on screen description": "Imprime le texte à l'écran. Ce composant est utile à des fins de débogage.",
    "preview text and save to file": "prévisualiser texte et sauvegarder fichier",
    "preview text and save to file description": "Imprime le texte à l'écran et vous permet de le sauvegarder dans un fichier. Ce composant est utile à des fins de débogage.",
    "register render loop listener": "enregistrer écouteur boucle rendu",
    "and update": "et mettre à jour",
    "register render loop listener description": "Exécute l'instruction dans la boucle de rendu et indique combien de temps s'est écoulé depuis la dernière image dans la variable timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "tempsEcouleDepuisImagePrecedente",
    "computing": "calcul en cours",
    "result": "résultat",
    "of promise is returned": "de la promesse est retourné",
    "on pointer up": "sur pointeur haut",
    "on pointer move": "sur pointeur mouvement",
    "on pointer down": "sur pointeur bas",
    "of babylonjs observable object": "de l'objet observable babylonjs",
    "observable name": "nom observable",
    "is key pressed description": "Vérifie si la touche est pressée et retourne vrai ou faux.",
    "execute code after": "exécuter code après",
    "execute code after description": "Exécute le code après le délai donné en secondes.",
    "execute code every": "exécuter code toutes les",
    "second(s)": "seconde(s)",
    "execute code every description": "Exécute le code à chaque intervalle donné en secondes.",
    "handler": "gestionnaire",
    "workers initialising": "initialisation workers",
    "Assets": "Actifs",
    "Local assets stored in browser cache:": "Actifs locaux stockés dans le cache du navigateur :",
    "Asset Name": "Nom Actif",
    "Name is required": "Nom requis",
    "Asset with this name already exists, choose a different one": "Un actif avec ce nom existe déjà, choisissez-en un autre",
    "Allowed file formats:": "Formats de fichiers autorisés :",
    "You must select an asset file": "Vous devez sélectionner un fichier actif",
    "Upload Local Asset": "Téléverser Actif Local",
    "File Name": "Nom Fichier",
    "File Size": "Taille Fichier",
    "Your browser does not support indexDB and you can't upload local asset files.": "Votre navigateur ne prend pas en charge indexDB et vous ne pouvez pas téléverser de fichiers actifs locaux.",
    "Upload": "Téléverser",
    "elements": "éléments",
    "bitbybit.vector.vectorsTheSame": "vecteurs identiques",
    "vectorsTheSame": "vecteurs identiques",
    "bitbybit.vector.vectorsTheSame_description": "Vérifie si deux vecteurs sont identiques dans les limites d'une tolérance donnée",
    "vec1": "vecteur 1",
    "vec2": "vecteur 2",
    "bitbybit.point.boundingBoxOfPoints": "boîte englobante des points",
    "boundingBoxOfPoints": "boîte englobante des points",
    "bitbybit.point.boundingBoxOfPoints_description": "Obtient une boîte englobante des points",
    "bitbybit.point.normalFromThreePoints": "normale à partir de trois points",
    "normalFromThreePoints": "normale à partir de trois points",
    "bitbybit.point.normalFromThreePoints_description": "Crée un vecteur normal à partir de 3 points",
    "reverseNormal": "normale inversée",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "polyligne avec extensions",
    "createLineWireWithExtensions": "polyligne avec extensions",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Crée une polyligne OpenCascade avec extensions",
    "extensionStart": "début ext.",
    "extensionEnd": "fin ext.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "point médian sur polyligne",
    "midPointOnWire": "point médian sur polyligne",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Calcule le point médian sur la polyligne au paramètre 0.5",
    "centerOnOrigin": "centrer sur l'origine",
    "bitbybit.occt.shapes.wire.textWiresWithData": "polylignes de texte avec données",
    "textWiresWithData": "polylignes de texte avec données",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Crée un composé OpenCascade à partir de polylignes de texte et renvoie des informations supplémentaires basées sur la police simplex créée par le Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "aligner normale et axe",
    "alignNormAndAxis": "aligner normale et axe",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Aligne la forme avec la normale et l'axe",
    "fromNorm": "depuis normale",
    "fromAx": "depuis axe",
    "toNorm": "vers normale",
    "toAx": "vers axe",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "cote de longueur linéaire simple",
    "simpleLinearLengthDimension": "cote de longueur linéaire simple",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Crée une cote de longueur linéaire simple entre deux points - unités de mesure",
    "offsetFromPoints": "décalage depuis les points",
    "crossingSize": "taille de croisement",
    "labelSuffix": "suffixe d'étiquette",
    "labelSize": "taille d'étiquette",
    "labelOffset": "décalage d'étiquette",
    "bitbybit.occt.dimensions.simpleAngularDimension": "cote angulaire simple",
    "simpleAngularDimension": "cote angulaire simple",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Crée une cote angulaire simple. Par défaut, affiche les degrés, mais vous pouvez choisir d'utiliser les radians.",
    "direction1": "direction 1",
    "direction2": "direction 2",
    "offsetFromCenter": "décalage par rapport au centre",
    "extraSize": "taille supplémentaire",
    "radians": "radians",
    "bitbybit.occt.dimensions.pinWithLabel": "repère avec étiquette",
    "pinWithLabel": "repère avec étiquette",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Crée un repère avec étiquette. Il peut être utilisé pour expliquer des choses sur les modèles ou marquer des éléments importants dans la scène 3D.",
    "offsetFromStart": "décalage par rapport au début",
    "bitbybit.vector.lengthSq": "longueur au carré",
    "lengthSq": "longueur au carré",
    "bitbybit.vector.lengthSq_description": "Calcule la longueur au carré du vecteur",
    "bitbybit.point.twoPointsAlmostEqual": "deux points égaux",
    "twoPointsAlmostEqual": "deux points égaux",
    "bitbybit.point.twoPointsAlmostEqual_description": "Vérifie si deux points sont presque égaux",
    "bitbybit.line.lineToSegment": "ligne vers segment",
    "lineToSegment": "ligne vers segment",
    "bitbybit.line.lineToSegment_description": "Convertit la ligne en segment",
    "bitbybit.line.linesToSegments": "lignes vers segments",
    "linesToSegments": "lignes vers segments",
    "bitbybit.line.linesToSegments_description": "Convertit les lignes en segments",
    "bitbybit.line.segmentToLine": "segment vers ligne",
    "segmentToLine": "segment vers ligne",
    "bitbybit.line.segmentToLine_description": "Convertit le segment en ligne",
    "segment": "segment",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segments vers lignes",
    "segmentsToLines": "segments vers lignes",
    "bitbybit.line.segmentsToLines_description": "Convertit les segments en lignes",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "trier les segments en polylignes",
    "sortSegmentsIntoPolylines": "trier les segments en polylignes",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Crée les polylignes à partir de segments potentiellement connectés mais mélangés aléatoirement",
    "sort": "trier",
    "bitbybit.mesh.signedDistanceToPlane": "distance signée au plan",
    "signedDistanceToPlane": "distance signée au plan",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calcule la distance signée d'un point à un plan.",
    "plane": "plan",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calculer le plan du triangle",
    "calculateTrianglePlane": "calculer le plan du triangle",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calcule le plan du triangle à partir du triangle.",
    "triangle": "triangle",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "intersection triangle-triangle",
    "triangleTriangleIntersection": "intersection triangle-triangle",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calcule l'intersection de deux triangles.",
    "triangle1": "triangle 1",
    "triangle2": "triangle 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segments d'intersection maillage-maillage",
    "meshMeshIntersectionSegments": "segments d'intersection maillage-maillage",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calcule les segments d'intersection de deux maillages.",
    "mesh1": "maillage 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "maillage 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polylignes d'intersection maillage-maillage",
    "meshMeshIntersectionPolylines": "polylignes d'intersection maillage-maillage",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calcule les polylignes d'intersection de deux maillages.",
    "bitbybit.occt.shapeFacesToPolygonPoints": "faces de forme vers points de polygone",
    "shapeFacesToPolygonPoints": "faces de forme vers points de polygone",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Crée des points de polygone à partir des faces de la forme",
    "reversedPoints": "points inversés",
    "bitbybit.occt.shapeToMesh": "forme vers maillage",
    "shapeToMesh": "forme vers maillage",
    "bitbybit.occt.shapeToMesh_description": "Crée un maillage à partir de la forme",
    "bitbybit.occt.shapesToMeshes": "formes vers maillages",
    "shapesToMeshes": "formes vers maillages",
    "bitbybit.occt.shapesToMeshes_description": "Crée un maillage à partir de la forme",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "à partir de points de polygone",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Créer une variété (Manifold) à partir d'un ensemble de points de polygone décrivant des triangles.",
    "traingle": "triangle",
    "bitbybit.point.stretchPointsDirFromCenter": "étirer les points depuis le centre dans une direction",
    "stretchPointsDirFromCenter": "étirer les points depuis le centre dans une direction",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Étire plusieurs points en fournissant un point central, une direction et un facteur d'échelle uniforme",
    "bitbybit.point.hexGridScaledToFit": "grille hexagonale mise à l'échelle pour s'adapter",
    "hexGridScaledToFit": "grille hexagonale mise à l'échelle pour s'adapter",
    "bitbybit.point.hexGridScaledToFit_description": "Crée une grille hexagonale à sommet pointu, mettant à l'échelle les hexagones pour s'adapter exactement aux dimensions spécifiées. Renvoie à la fois les points centraux et les sommets de chaque hexagone (potentiellement mis à l'échelle). Les hexagones sont ordonnés d'abord par colonne, puis par ligne.",
    "nrHexagonsU": "nb hexagones U",
    "nrHexagonsV": "nb hexagones V",
    "extendTop": "étendre haut",
    "extendBottom": "étendre bas",
    "extendLeft": "étendre gauche",
    "extendRight": "étendre droite",
    "centerGrid": "centrer la grille",
    "bitbybit.point.sortPoints": "trier les points",
    "sortPoints": "trier les points",
    "bitbybit.point.sortPoints_description": "Trie les points lexicographiquement (X, puis Y, puis Z)",
    "bitbybit.line.lineLineIntersection": "intersection ligne-ligne",
    "lineLineIntersection": "intersection ligne-ligne",
    "bitbybit.line.lineLineIntersection_description": "Si deux lignes se croisent, renvoie le point d'intersection",
    "line1": "ligne 1",
    "line2": "ligne 2",
    "checkSegmentsOnly": "vérifier les segments uniquement",
    "bitbybit.polyline.polylineToLines": "polyligne vers lignes",
    "polylineToLines": "polyligne vers lignes",
    "bitbybit.polyline.polylineToLines_description": "Crée les lignes à partir de la polyligne",
    "bitbybit.polyline.polylineToSegments": "polyligne vers segments",
    "polylineToSegments": "polyligne vers segments",
    "bitbybit.polyline.polylineToSegments_description": "Crée les segments à partir de la polyligne",
    "bitbybit.polyline.polylineSelfIntersection": "auto-intersection de polyligne",
    "polylineSelfIntersection": "auto-intersection de polyligne",
    "bitbybit.polyline.polylineSelfIntersection_description": "Trouve les points d'auto-intersection de la polyligne",
    "bitbybit.polyline.twoPolylineIntersection": "intersection de deux polylignes",
    "twoPolylineIntersection": "intersection de deux polylignes",
    "bitbybit.polyline.twoPolylineIntersection_description": "Trouve les points d'intersection entre deux polylignes.",
    "polyline1": "polyligne 1",
    "polyline2": "polyligne 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdiviser en fils hexagonaux",
    "subdivideToHexagonWires": "subdiviser en fils hexagonaux",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivise une face en fils hexagonaux",
    "extendUUp": "étendre U haut",
    "extendUBottom": "étendre U bas",
    "extendVUp": "étendre V haut",
    "extendVBottom": "étendre V bas",
    "nrHexagonsInHeight": "nb hexagones hauteur",
    "nrHexagonsInWidth": "nb hexagones largeur",
    "bitbybit.vector.length": "longueur du vecteur",
    "bitbybit.vector.length_description": "Calcule la longueur du vecteur",
    "bitbybit.point.maxFilletRadius": "rayon de congé maximal",
    "maxFilletRadius": "rayon de congé maximal",
    "bitbybit.point.maxFilletRadius_description": "Calcule le rayon de congé maximal possible à un coin formé par deux segments de ligne partageant une extrémité (C), de sorte que l'arc de congé soit tangent aux deux segments et se situe entièrement à l'intérieur de ceux-ci.",
    "bitbybit.point.maxFilletRadiusHalfLine": "rayon de congé maximal demi-ligne",
    "maxFilletRadiusHalfLine": "rayon de congé maximal demi-ligne",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calcule le rayon de congé maximal possible à un coin C, de sorte que l'arc de congé soit tangent aux deux segments (P1-C, P2-C) et que les points tangents se situent dans la première moitié de chaque segment (mesurée à partir de C).",
    "bitbybit.point.maxFilletsHalfLine": "congés maximaux demi-ligne",
    "maxFilletsHalfLine": "congés maximaux demi-ligne",
    "bitbybit.point.maxFilletsHalfLine_description": "Calcule le rayon de congé maximal possible à chaque coin d'une polyligne formée par une série de points. Le rayon de congé est calculé pour chaque coin interne et éventuellement pour les coins de fermeture si la polyligne est fermée.",
    "checkLastWithFirst": "vérifier dernier avec premier",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "rayon de congé maximal le plus sûr (points, demi-ligne)",
    "safestPointsMaxFilletHalfLine": "rayon de congé maximal le plus sûr (points, demi-ligne)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calcule le rayon de congé maximal le plus sûr unique qui peut être appliqué uniformément à tous les coins d'une collection de points, basé sur la contrainte 'demi-ligne'. Ceci est déterminé en trouvant le minimum des rayons de congé maximaux possibles calculés pour chaque coin individuel.",
    "bitbybit.polyline.maxFilletsHalfLine": "congés maximaux demi-ligne",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calcule le rayon de congé maximal possible 'demi-ligne' pour chaque coin d'une polyligne donnée. Pour une polyligne fermée, il inclut les coins reliant le dernier segment au premier. Le calcul utilise la contrainte 'demi-ligne', ce qui signifie que les points tangents du congé doivent se situer dans la première moitié de chaque segment connecté au coin.",
    "bitbybit.polyline.safestFilletRadius": "rayon de congé le plus sûr",
    "safestFilletRadius": "rayon de congé le plus sûr",
    "bitbybit.polyline.safestFilletRadius_description": "Calcule le rayon de congé maximal le plus sûr unique qui peut être appliqué uniformément à tous les coins d'une polyligne, basé sur la contrainte 'demi-ligne'. Ceci est déterminé en trouvant le minimum des rayons de congé maximaux possibles calculés pour chaque coin individuel.",
    "flatTop": "sommet plat",
    "bitbybit.mesh.meshMeshIntersectionPoints": "points d'intersection maillage-maillage",
    "meshMeshIntersectionPoints": "points d'intersection maillage-maillage",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calcule les points d'intersection de deux maillages.",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexagones dans la grille",
    "hexagonsInGrid": "hexagones dans la grille",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Crée des fils hexagonaux OpenCascade dans une grille",
    "scalePatternWidth": "échelle largeur motif",
    "scalePatternHeight": "échelle hauteur motif",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "fils d'intersection maillage-maillage",
    "meshMeshIntersectionWires": "fils d'intersection maillage-maillage",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Effectue une opération d'intersection maillage-maillage entre deux formes - les deux formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les fils de l'intersection, qui sont des polylignes ou des polygones.",
    "mesh based": "basé sur maillage",
    "precision1": "précision 1",
    "precision2": "précision 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "points d'intersection maillage-maillage",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Effectue une opération d'intersection maillage-maillage entre deux formes - les deux formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les points de l'intersection.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "intersection maillage-maillage vers fils",
    "meshMeshIntersectionOfShapesWires": "intersection maillage-maillage vers fils",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Effectue une opération d'intersection maillage-maillage entre la forme et plusieurs autres formes - toutes les formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les fils de l'intersection, qui sont des polylignes ou des polygones.",
    "precisionShapes": "précision formes",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "intersection maillage-maillage vers points",
    "meshMeshIntersectionOfShapesPoints": "intersection maillage-maillage vers points",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Effectue une opération d'intersection maillage-maillage entre la forme et plusieurs autres formes - toutes les formes peuvent avoir leur propre précision de maillage. Cet algorithme intersecte les maillages et renvoie les points de l'intersection.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexagones dans la grille",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Crée des hexagones OpenCascade dans une grille (faces)",
    "bitbybit.jscad.toPolygonPoints": "vers points de polygone",
    "toPolygonPoints": "vers points de polygone",
    "bitbybit.jscad.toPolygonPoints_description": "Transforme la forme jscad en une collection de points de polygone représentant le maillage",
    "conversions": "conversions",
    "bitbybit.manifold.toPolygonPoints": "vers points de polygone",
    "bitbybit.manifold.toPolygonPoints_description": "Transforme la forme manifold en une collection de points de polygone représentant le maillage.",
    "flatU": "plat U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdiviser en trous hexagonaux",
    "subdivideToHexagonHoles": "subdiviser en trous hexagonaux",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivise une face en trous hexagonaux",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "convertir les lignes en courbes NURBS",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Convertit les lignes en courbes NURBS. Renvoie un tableau d'objets verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "convertir une ligne en courbe NURBS",
    "convertLineToNurbsCurve": "convertir une ligne en courbe NURBS",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Convertit une ligne en courbe NURBS. Renvoie l'objet verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "convertir une polyligne en courbe NURBS",
    "convertPolylineToNurbsCurve": "convertir une polyligne en courbe NURBS",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Convertit une polyligne en courbe NURBS. Renvoie l'objet verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "convertir les polylignes en courbes NURBS",
    "convertPolylinesToNurbsCurves": "convertir les polylignes en courbes NURBS",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Convertit les polylignes en courbes NURBS. Renvoie les objets verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segment",
    "createSegment": "segment",
    "bitbybit.line.createSegment_description": "Créer le segment",
    "bitbybit.occt.shapes.edge.fromBaseLine": "arête depuis ligne de base",
    "fromBaseLine": "depuis ligne de base",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Crée une arête linéaire à partir du format de ligne de base {start: Point3, end: Point3}",
    "from base": "depuis base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "arête depuis lignes de base",
    "fromBaseLines": "depuis lignes de base",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Crée des arêtes linéaires à partir du format de lignes de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "arête depuis segment de base",
    "fromBaseSegment": "depuis segment de base",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Crée une arête linéaire à partir du format de segment de base [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "arêtes depuis segments de base",
    "fromBaseSegments": "depuis segments de base",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Crée une arête linéaire à partir du format de segments de base [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "arêtes depuis points",
    "fromPoints": "depuis points",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Crée des arêtes linéaires à partir d'une collection de points",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "arêtes depuis polyligne de base",
    "fromBasePolyline": "depuis polyligne de base",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Crée des arêtes linéaires à partir de la définition de la polyligne",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "arêtes depuis triangle de base",
    "fromBaseTriangle": "depuis triangle de base",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Crée des arêtes linéaires à partir de la définition du triangle",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "arêtes depuis maillage de base",
    "fromBaseMesh": "depuis maillage de base",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Crée des arêtes linéaires à partir de la définition du maillage",
    "bitbybit.occt.shapes.wire.fromBaseLine": "fil depuis ligne de base",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Crée un fil linéaire à partir du format de ligne de base {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "fils depuis lignes de base",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Crée des fils linéaires à partir du format de lignes de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "fil depuis segment de base",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Crée un fil linéaire à partir du format de segment de base [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "fils depuis segments de base",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Crée des fils linéaires à partir du format de segments de base [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "fil depuis points",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Crée un fil à partir d'une collection de points",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "fil depuis polyligne de base",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Crée un fil à partir de la définition de la polyligne",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "fil depuis triangle de base",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Crée un fil à partir de la définition du triangle",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "fils depuis maillage de base",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Crée des fils à partir de la définition du maillage",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "face depuis triangle de base",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Crée une face à partir de la définition du triangle",
    "bitbybit.occt.shapes.face.fromBaseMesh": "faces depuis maillage de base",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Crée des faces à partir de la définition du maillage",
    "fromRightHanded": "depuis droitier",
      "bitbybit.advanced.text3d.createWithUrl": "texte avec url",
    "createWithUrl": "texte avec url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Crée un texte 3D avec une URL de police. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3D. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "fontUrl": "url de la police",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "texte sur face url",
    "createTextOnFaceUrl": "texte sur face url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Crée un texte 3D sur la face à l'aide d'une URL de police. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3D. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "textes sur face url",
    "createTextsOnFaceUrl": "textes sur face url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Crée des textes 3D sur la face à partir de plusieurs définitions d'URL. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3D. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "définition texte 3d sur face url",
    "definition3dTextOnFaceUrl": "définition texte 3d sur face url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Crée un texte 3D qui sera utilisé dans la définition de l'URL de la face. Ceci est utile lorsque vous souhaitez utiliser une police personnalisée qui n'est pas incluse dans la bibliothèque. La police sera chargée à partir de l'URL fournie et utilisée pour générer le texte 3D. Assurez-vous que les polices ne contiennent pas d'auto-intersection et d'autres mauvais caractères - c'est un problème courant avec les polices personnalisées. Les formats de police pris en charge sont : ttf, otf, woff. Veuillez noter que Woff2 n'est pas pris en charge par opentype.js car il s'agit d'un format compressé.",
    "bitbybit.advanced.navigation.pointOfInterest": "point d'intérêt",
    "navigation": "navigation",
    "pointOfInterest": "point d'intérêt",
    "bitbybit.advanced.navigation.pointOfInterest_description": "nœud de survol",
    "cameraTarget": "cible de la caméra",
    "cameraPosition": "position de la caméra",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "système de points d'intérêt",
    "pointsOfInterestSystem": "système de points d'intérêt",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "points d'intérêt",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "point d'intérêt",
    "style": "style",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "style de point d'intérêt",
    "pointOfInterestStyle": "style de point d'intérêt",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Créer un style de point d'intérêt - utilisé pour styliser les indicateurs de points d'intérêt dans l'espace 3D. Vous pouvez personnaliser la taille du point, la couleur, la couleur au survol, l'effet de pulsation, la couleur et la taille de l'étiquette de texte.",
    "pointSize": "taille du point",
    "pointColor": "couleur du point",
    "hoverPointColor": "couleur du point au survol",
    "pulseColor": "couleur de la pulsation",
    "hoverPulseColor": "couleur de la pulsation au survol",
    "pulseMinSize": "taille min de la pulsation",
    "pulseMaxSize": "taille max de la pulsation",
    "pulseThickness": "épaisseur de la pulsation",
    "pulseSpeed": "vitesse de la pulsation",
    "textColor": "couleur du texte",
    "hoverTextColor": "couleur du texte au survol",
    "textSize": "taille du texte",
    "hideSkybox": "masquer la skybox",
    "textureUrl": "URL de la texture",
    "hdrTexture": "texture HDR",
    "textureSize": "taille de la texture",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "activer la texture personnalisée de la skybox",
    "enableSkyboxCustomTexture": "activer la texture personnalisée de la skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Active la skybox avec une texture personnalisée",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "image de fond CSS du canvas",
    "canvasCSSBackgroundImage": "image de fond CSS du canvas",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Change l'arrière-plan de la scène en image de fond CSS pour l'espace 3D",
    "cssBackgroundImage": "image de fond CSS",
    "bitbybit.babylon.scene.twoColorLinearGradient": "dégradé linéaire à deux couleurs",
    "twoColorLinearGradient": "dégradé linéaire à deux couleurs",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Crée un arrière-plan dégradé linéaire à deux couleurs pour l'espace 3D",
    "colorFrom": "couleur de départ",
    "colorTo": "couleur d'arrivée",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "arrêt de départ",
    "stopTo": "arrêt d'arrivée",
    "bitbybit.babylon.scene.twoColorRadialGradient": "dégradé radial à deux couleurs",
    "twoColorRadialGradient": "dégradé radial à deux couleurs",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Crée un arrière-plan dégradé radial à deux couleurs pour l'espace 3D",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "dégradé linéaire multicolore",
    "multiColorLinearGradient": "dégradé linéaire multicolore",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Crée un arrière-plan dégradé linéaire multicolore pour l'espace 3D",
    "Base.Color[]": "Base.Color[]",
    "stops": "arrêts",
    "bitbybit.babylon.scene.multiColorRadialGradient": "dégradé radial multicolore",
    "multiColorRadialGradient": "dégradé radial multicolore",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Crée un arrière-plan dégradé radial multicolore pour l'espace 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "image de fond du canvas",
    "canvasBackgroundImage": "image de fond du canvas",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Définit une image de fond avec diverses options de personnalisation pour l'espace 3D",
    "imageUrl": "URL de l'image",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "attachement",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "découpage",
    "labelRotation": "rotation de l'étiquette",
    "bitbybit.advanced.dimensions.linearDimension": "dimension linéaire",
    "linearDimension": "dimension linéaire",
    "bitbybit.advanced.dimensions.linearDimension_description": "Crée une dimension linéaire - une ligne de mesure entre deux points avec des lignes d'extension et une étiquette de texte. La dimension montre la distance entre les points et peut être stylisée avec DimensionStyleDto.",
    "linear dimension": "dimension linéaire",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "dimension angulaire",
    "angularDimension": "dimension angulaire",
    "bitbybit.advanced.dimensions.angularDimension_description": "Crée une dimension angulaire - un arc de mesure entre deux vecteurs de direction avec des lignes d'extension et une étiquette de texte. La dimension montre l'angle entre les directions et peut être stylisée avec DimensionStyleDto.",
    "angular dimension": "dimension angulaire",
    "centerPoint": "point central",
    "bitbybit.advanced.dimensions.dimensionStyle": "style de dimension",
    "dimensionStyle": "style de dimension",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Créer un style de dimension - utilisé pour styliser les lignes de dimension, les flèches et le texte dans l'espace 3D. Vous pouvez personnaliser les couleurs de ligne, l'épaisseur, la taille du texte, la taille des flèches et les couleurs d'arrière-plan.",
    "dimension style": "style de dimension",
    "lineColor": "couleur de ligne",
    "lineThickness": "épaisseur de ligne",
    "extensionLineLength": "longueur de ligne d'extension",
    "textBackgroundColor": "couleur d'arrière-plan du texte",
    "textBackgroundOpacity": "opacité d'arrière-plan du texte",
    "arrowSize": "taille de flèche",
    "arrowColor": "couleur de flèche",
    "textRenderMode": "mode de rendu du texte",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "panneau de texte",
    "occlusionCheckInterval": "intervalle de vérification d'occlusion",
    "arrowTailLength": "longueur de queue de flèche",
    "showArrows": "afficher les flèches",
    "labelOverwrite": "écraser l'étiquette",
    "bitbybit.advanced.dimensions.radialDimension": "dimension radiale",
    "radialDimension": "dimension radiale",
    "bitbybit.advanced.dimensions.radialDimension_description": "Crée une dimension radiale - une ligne de mesure du centre au périmètre montrant le rayon ou le diamètre. Affiche le préfixe 'R' pour le rayon ou le préfixe '⌀' pour le diamètre avec une marque centrale optionnelle.",
    "radial dimension": "dimension radiale",
    "radiusPoint": "point de rayon",
    "showDiameter": "afficher le diamètre",
    "showCenterMark": "afficher la marque centrale",
    "bitbybit.advanced.dimensions.diametralDimension": "dimension diamétrale",
    "diametralDimension": "dimension diamétrale",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Crée une dimension diamétrale - une ligne de mesure couvrant le diamètre complet des caractéristiques circulaires. Affiche le préfixe '⌀' avec une marque centrale optionnelle et des flèches aux deux extrémités.",
    "diametral dimension": "dimension diamétrale",
    "bitbybit.advanced.dimensions.ordinateDimension": "dimension d'ordonnée",
    "ordinateDimension": "dimension d'ordonnée",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Crée une dimension d'ordonnée - affiche la coordonnée X, Y ou Z à partir d'un point de référence avec une ligne de repère. Utile pour les annotations de coordonnées et le référencement de données dans les dessins techniques.",
    "ordinate dimension": "dimension d'ordonnée",
    "measurementPoint": "point de mesure",
    "referencePoint": "point de référence",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "afficher la ligne de repère",
    "viewMode": "mode d'affichage",
    "schema": "schéma",
    "json schema": "schéma JSON",
    "metadata": "métadonnées",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "arrière-plan dégradé linéaire deux couleurs",
    "twoColorLinearGradientBackground": "arrière-plan dégradé linéaire deux couleurs",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Crée un arrière-plan dégradé linéaire deux couleurs pour l'espace 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "arrière-plan dégradé radial deux couleurs",
    "twoColorRadialGradientBackground": "arrière-plan dégradé radial deux couleurs",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Crée un arrière-plan dégradé radial deux couleurs pour l'espace 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "arrière-plan dégradé linéaire multicolore",
    "multiColorLinearGradientBackground": "arrière-plan dégradé linéaire multicolore",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Crée un arrière-plan dégradé linéaire multicolore pour l'espace 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "arrière-plan dégradé radial multicolore",
    "multiColorRadialGradientBackground": "arrière-plan dégradé radial multicolore",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Crée un arrière-plan dégradé radial multicolore pour l'espace 3D",
    "textBackgroundStroke": "contour d'arrière-plan de texte",
    "textBackgroundRadius": "rayon d'arrière-plan de texte",
    "stableSize": "taille stable",
    "alwaysOnTop": "toujours au premier plan",
    "textStableSize": "taille de texte stable",
    "bitbybit.occt.io.shapeToDxfPaths": "forme vers chemins DXF",
    "shapeToDxfPaths": "forme vers chemins DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Crée des chemins DXF à partir d'une forme OCCT. Important - les formes contenant des fils doivent se trouver sur le plan XZ (Y=0) pour une exportation DXF 2D correcte.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "chemins DXF avec calque",
    "dxfPathsWithLayer": "chemins DXF avec calque",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Ajoute des informations de calque et de couleur aux chemins DXF",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "calque",
    "bitbybit.occt.io.dxfCreate": "créer DXF",
    "dxfCreate": "créer DXF",
    "bitbybit.occt.io.dxfCreate_description": "Assemble plusieurs parties de chemin dans un fichier DXF complet",
    "pathsParts": "parties de chemins",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "graisse de police de texte",
    "textPosition": "position du texte",
    "textBackgroundStrokeThickness": "épaisseur du trait",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum"
}