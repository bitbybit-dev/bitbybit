{
    "bitbybit.draw.drawAnyAsyncNoReturn": "desenhar qualquer assíncrono sem retorno",
    "bitbybit": "bitporbit",
    "draw": "desenhar",
    "drawAnyAsyncNoReturn": "desenhar qualquer assíncrono sem retorno",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Desenha qualquer tipo de geometria e não retorna nada",
    "draw async": "desenhar assíncrono",
    "entity": "entidade",
    "Entity": "Entidade",
    "options": "opções",
    "DrawOptions": "opções de desenho",
    "babylonMesh": "malha babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "malha babylon ou malha de linhas",
    "bitbybit.draw.drawAnyAsync": "desenhar qualquer assíncrono",
    "drawAnyAsync": "desenhar qualquer assíncrono",
    "bitbybit.draw.drawAnyAsync_description": "Desenha qualquer tipo de geometria e retorna a malha babylon",
    "bitbybit.draw.drawAnyNoReturn": "desenhar qualquer sem retorno",
    "drawAnyNoReturn": "desenhar qualquer sem retorno",
    "bitbybit.draw.drawAnyNoReturn_description": "Desenha qualquer tipo de geometria que não precise de computação assíncrona, portanto, não pode ser usada com formas vindas do occt ou jscad",
    "draw sync": "desenhar síncrono",
    "bitbybit.draw.drawAny": "desenhar qualquer",
    "drawAny": "desenhar qualquer",
    "bitbybit.draw.drawAny_description": "Desenha qualquer tipo de geometria que não precise de computação assíncrona, portanto, não pode ser usada com formas vindas do occt ou jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "desenhar malha de grade sem retorno",
    "drawGridMeshNoReturn": "desenhar malha de grade sem retorno",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Desenha uma malha de grade no plano do chão no espaço 3D. Isso ajuda a se orientar no mundo.",
    "grid": "grade",
    "width": "largura",
    "number": "número",
    "height": "altura",
    "subdivisions": "subdivisões",
    "majorUnitFrequency": "frequência de unidade principal",
    "minorUnitVisibility": "visibilidade de unidade secundária",
    "gridRatio": "proporção da grade",
    "opacity": "opacidade",
    "backFaceCulling": "eliminação de faces traseiras",
    "boolean": "booleano",
    "mainColor": "cor principal",
    "Base.Color": "cor base",
    "secondaryColor": "cor secundária",
    "bitbybit.draw.drawGridMesh": "desenhar malha de grade",
    "drawGridMesh": "desenhar malha de grade",
    "bitbybit.draw.drawGridMesh_description": "Desenha uma malha de grade no plano do chão no espaço 3D. Isso ajuda a se orientar no mundo.",
    "bitbybit.draw.optionsSimple": "opções simples",
    "optionsSimple": "opções simples",
    "bitbybit.draw.optionsSimple_description": "Cria opções de desenho para tipos básicos de geometria como pontos, linhas, polilinhas, superfícies e malhas jscad",
    "colours": "cores",
    "string | string[]": "texto ou array de textos",
    "size": "tamanho",
    "updatable": "atualizável",
    "hidden": "oculto",
    "bitbybit.draw.optionsOcctShape": "opções de forma occt",
    "optionsOcctShape": "opções de forma occt",
    "bitbybit.draw.optionsOcctShape_description": "Cria opções de desenho para geometria de forma occt como arestas, fios, faces, cascas, sólidos e compostos",
    "faceOpacity": "opacidade da face",
    "edgeOpacity": "opacidade da aresta",
    "edgeColour": "cor da aresta",
    "faceColour": "cor da face",
    "vertexColour": "cor do vértice",
    "faceMaterial": "material da face",
    "Base.Material": "material base",
    "edgeWidth": "largura da aresta",
    "vertexSize": "tamanho do vértice",
    "drawEdges": "desenhar arestas",
    "drawFaces": "desenhar faces",
    "drawVertices": "desenhar vértices",
    "precision": "precisão",
    "drawEdgeIndexes": "desenhar índices de arestas",
    "edgeIndexHeight": "altura do índice de aresta",
    "edgeIndexColour": "cor do índice de aresta",
    "drawFaceIndexes": "desenhar índices de faces",
    "faceIndexHeight": "altura do índice de face",
    "faceIndexColour": "cor do índice de face",
    "bitbybit.draw.optionsOcctShapeSimple": "opções de forma occt simples",
    "optionsOcctShapeSimple": "opções de forma occt simples",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Cria opções de desenho simples para geometria de forma occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "opções de material de forma occt",
    "optionsOcctShapeMaterial": "opções de material de forma occt",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Cria opções de desenho simples com material de face personalizado para geometria de forma occt",
    "any": "qualquer",
    "bitbybit.draw.optionsManifoldShapeMaterial": "opções de material de forma manifold",
    "optionsManifoldShapeMaterial": "opções de material de forma manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Cria opções de desenho para geometria manifold",
    "crossSectionColour": "cor da seção transversal",
    "crossSectionWidth": "largura da seção transversal",
    "crossSectionOpacity": "opacidade da seção transversal",
    "computeNormals": "calcular normais",
    "bitbybit.draw.optionsBabylonNode": "opções de nó babylon",
    "optionsBabylonNode": "opções de nó babylon",
    "bitbybit.draw.optionsBabylonNode_description": "Cria opções de desenho para nós babylon js",
    "colorX": "cor x",
    "colorY": "cor y",
    "colorZ": "cor z",
    "bitbybit.babylon.mesh.dispose": "descartar malha",
    "babylon": "babylon",
    "mesh": "malha",
    "dispose": "descartar",
    "bitbybit.babylon.mesh.dispose_description": "Descarta o objeto de malha desenhado da cena",
    "memory": "memória",
    "BABYLON.Mesh": "malha babylon",
    "bitbybit.babylon.mesh.updateDrawn": "atualizar desenhado",
    "updateDrawn": "atualizar desenhado",
    "bitbybit.babylon.mesh.updateDrawn_description": "Atualiza o objeto de malha BabylonJS desenhado sem descartá-lo",
    "updates": "atualizações",
    "position": "posição",
    "Base.Point3": "ponto base 3",
    "rotation": "rotação",
    "Base.Vector3": "vetor base 3",
    "scaling": "escala",
    "bitbybit.babylon.mesh.setVisibility": "definir visibilidade",
    "setVisibility": "definir visibilidade",
    "bitbybit.babylon.mesh.setVisibility_description": "Altera a visibilidade de uma malha BabylonJS desenhada",
    "visibility": "visibilidade",
    "includeChildren": "incluir filhos",
    "bitbybit.babylon.mesh.hide": "ocultar",
    "hide": "ocultar",
    "bitbybit.babylon.mesh.hide_description": "oculta a malha",
    "bitbybit.babylon.mesh.show": "mostrar",
    "show": "mostrar",
    "bitbybit.babylon.mesh.show_description": "Mostra a malha",
    "bitbybit.babylon.mesh.setParent": "definir pai",
    "setParent": "definir pai",
    "bitbybit.babylon.mesh.setParent_description": "Altera o pai da malha desenhada",
    "set": "definir",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "malha babylon ou malha instanciada ou malha abstrata",
    "parentMesh": "malha pai",
    "bitbybit.babylon.mesh.getParent": "obter pai",
    "getParent": "obter pai",
    "bitbybit.babylon.mesh.getParent_description": "Obtém o pai da malha desenhada",
    "get": "obter",
    "bitbybit.babylon.mesh.setCheckCollisions": "definir verificação de colisões",
    "setCheckCollisions": "definir verificação de colisões",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Altera a propriedade de verificação de colisões da malha desenhada",
    "checkCollisions": "verificar colisões",
    "bitbybit.babylon.mesh.getCheckCollisions": "obter verificação de colisões",
    "getCheckCollisions": "obter verificação de colisões",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Obtém a propriedade de verificação de colisões da malha desenhada",
    "bitbybit.babylon.mesh.setPickable": "definir selecionável",
    "setPickable": "definir selecionável",
    "bitbybit.babylon.mesh.setPickable_description": "Altera a propriedade de ser selecionável da malha desenhada",
    "pickable": "selecionável",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "ativar eventos de movimento de ponteiro",
    "enablePointerMoveEvents": "ativar eventos de movimento de ponteiro",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Força a malha a ser selecionável por eventos de movimento do ponteiro, o padrão é falso pois é pesado para o desempenho",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "desativar eventos de movimento de ponteiro",
    "disablePointerMoveEvents": "desativar eventos de movimento de ponteiro",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Faz a malha ignorar eventos de movimento do ponteiro, o padrão é falso",
    "bitbybit.babylon.mesh.getPickable": "obter selecionável",
    "getPickable": "obter selecionável",
    "bitbybit.babylon.mesh.getPickable_description": "Altera a propriedade de ser selecionável da malha desenhada",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "obter malhas onde o nome contém",
    "getMeshesWhereNameContains": "obter malhas onde o nome contém",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Obtém malhas que têm nomes que contêm um texto dado",
    "name": "nome",
    "string": "texto",
    "bitbybit.babylon.mesh.getChildMeshes": "obter malhas filhas",
    "getChildMeshes": "obter malhas filhas",
    "bitbybit.babylon.mesh.getChildMeshes_description": "obtém malhas filhas",
    "directDescendantsOnly": "apenas descendentes diretos",
    "bitbybit.babylon.mesh.getMeshesOfId": "obter malhas por id",
    "getMeshesOfId": "obter malhas por id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Obtém malhas de id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "obter malha por id",
    "getMeshOfId": "obter malha por id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Obtém malha de id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "obter malha por id único",
    "getMeshOfUniqueId": "obter malha por id único",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Obtém malha de id único",
    "uniqueId": "id único",
    "bitbybit.babylon.mesh.mergeMeshes": "mesclar malhas",
    "mergeMeshes": "mesclar malhas",
    "bitbybit.babylon.mesh.mergeMeshes_description": "mescla múltiplas malhas em uma",
    "edit": "editar",
    "arrayOfMeshes": "array de malhas",
    "BABYLON.Mesh[]": "array de malhas babylon",
    "disposeSource": "descartar fonte",
    "allow32BitsIndices": "permitir índices de 32 bits",
    "meshSubclass": "subclasse de malha",
    "subdivideWithSubMeshes": "subdividir com submalhas",
    "multiMultiMaterials": "múltiplos materiais múltiplos",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "converter para malha sombreada plana",
    "convertToFlatShadedMesh": "converter para malha sombreada plana",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Converte malha para malha com sombreamento plano",
    "bitbybit.babylon.mesh.clone": "clonar",
    "clone": "clonar",
    "bitbybit.babylon.mesh.clone_description": "clona a malha",
    "bitbybit.babylon.mesh.cloneToPositions": "clonar para posições",
    "cloneToPositions": "clonar para posições",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Clona a malha para posições",
    "positions": "posições",
    "Base.Point3[]": "array de pontos base 3",
    "bitbybit.babylon.mesh.setId": "definir id",
    "setId": "definir id",
    "bitbybit.babylon.mesh.setId_description": "Altera o id da malha desenhada",
    "bitbybit.babylon.mesh.getId": "obter id",
    "getId": "obter id",
    "bitbybit.babylon.mesh.getId_description": "Obtém o id da malha desenhada",
    "bitbybit.babylon.mesh.getUniqueId": "obter id único",
    "getUniqueId": "obter id único",
    "bitbybit.babylon.mesh.getUniqueId_description": "Obtém o id único da malha desenhada",
    "bitbybit.babylon.mesh.setName": "definir nome",
    "setName": "definir nome",
    "bitbybit.babylon.mesh.setName_description": "Altera o nome da malha desenhada",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "obter vértices como pontos de polígono",
    "getVerticesAsPolygonPoints": "obter vértices como pontos de polígono",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Obtém os vértices como pontos de polígono. Estes podem ser usados com outros métodos de construção para criar malhas. A malha deve ser triangulada.",
    "bitbybit.babylon.mesh.getName": "obter nome",
    "getName": "obter nome",
    "bitbybit.babylon.mesh.getName_description": "Obtém o nome da malha babylon",
    "bitbybit.babylon.mesh.setMaterial": "definir material",
    "setMaterial": "definir material",
    "bitbybit.babylon.mesh.setMaterial_description": "Altera o material da malha desenhada",
    "material": "material",
    "BABYLON.Material": "material babylon",
    "bitbybit.babylon.mesh.getMaterial": "obter material",
    "getMaterial": "obter material",
    "bitbybit.babylon.mesh.getMaterial_description": "Obtém o material da malha babylon",
    "bitbybit.babylon.mesh.getPosition": "obter posição",
    "getPosition": "obter posição",
    "bitbybit.babylon.mesh.getPosition_description": "Obtém a posição como ponto da malha babylonjs",
    "bitbybit.babylon.mesh.getAbsolutePosition": "obter posição absoluta",
    "getAbsolutePosition": "obter posição absoluta",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Obtém a posição absoluta no mundo como ponto da malha babylonjs",
    "bitbybit.babylon.mesh.getRotation": "obter rotação",
    "getRotation": "obter rotação",
    "bitbybit.babylon.mesh.getRotation_description": "Obtém o vetor de rotação da malha babylonjs",
    "bitbybit.babylon.mesh.getScale": "obter escala",
    "getScale": "obter escala",
    "bitbybit.babylon.mesh.getScale_description": "Obtém o vetor de escala da malha babylonjs",
    "bitbybit.babylon.mesh.moveForward": "mover para frente",
    "moveForward": "mover para frente",
    "bitbybit.babylon.mesh.moveForward_description": "Move a malha babylonjs para frente no espaço local",
    "move": "mover",
    "distance": "distância",
    "bitbybit.babylon.mesh.moveBackward": "mover para trás",
    "moveBackward": "mover para trás",
    "bitbybit.babylon.mesh.moveBackward_description": "Move a malha babylonjs para trás no espaço local",
    "bitbybit.babylon.mesh.moveUp": "mover para cima",
    "moveUp": "mover para cima",
    "bitbybit.babylon.mesh.moveUp_description": "Move a malha babylonjs para cima no espaço local",
    "bitbybit.babylon.mesh.moveDown": "mover para baixo",
    "moveDown": "mover para baixo",
    "bitbybit.babylon.mesh.moveDown_description": "Move a malha babylonjs para baixo no espaço local",
    "bitbybit.babylon.mesh.moveRight": "mover para direita",
    "moveRight": "mover para direita",
    "bitbybit.babylon.mesh.moveRight_description": "Move a malha babylonjs para a direita no espaço local",
    "bitbybit.babylon.mesh.moveLeft": "mover para esquerda",
    "moveLeft": "mover para esquerda",
    "bitbybit.babylon.mesh.moveLeft_description": "Move a malha babylonjs para a esquerda no espaço local",
    "bitbybit.babylon.mesh.yaw": "guinada",
    "yaw": "guinada",
    "bitbybit.babylon.mesh.yaw_description": "Rotaciona a malha babylonjs ao redor do eixo y local",
    "rotate": "rotacionar",
    "bitbybit.babylon.mesh.pitch": "inclinação",
    "pitch": "inclinação",
    "bitbybit.babylon.mesh.pitch_description": "Rotaciona a malha babylonjs ao redor do eixo x local",
    "bitbybit.babylon.mesh.roll": "rolagem",
    "roll": "rolagem",
    "bitbybit.babylon.mesh.roll_description": "Rotaciona a malha babylonjs ao redor do eixo z local",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "rotacionar ao redor do eixo com posição",
    "rotateAroundAxisWithPosition": "rotacionar ao redor do eixo com posição",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Rotaciona a malha ao redor do eixo e posição dados por um ângulo dado",
    "axis": "eixo",
    "angle": "ângulo",
    "bitbybit.babylon.mesh.setPosition": "definir posição",
    "setPosition": "definir posição",
    "bitbybit.babylon.mesh.setPosition_description": "Atualiza a posição da malha BabylonJS ou malha instanciada",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "malha babylon ou malha instanciada",
    "bitbybit.babylon.mesh.setRotation": "definir rotação",
    "setRotation": "definir rotação",
    "bitbybit.babylon.mesh.setRotation_description": "Atualiza a rotação da malha BabylonJS ou malha instanciada",
    "bitbybit.babylon.mesh.setScale": "definir escala",
    "setScale": "definir escala",
    "bitbybit.babylon.mesh.setScale_description": "Atualiza a escala da malha BabylonJS ou malha instanciada",
    "scale": "escala",
    "bitbybit.babylon.mesh.intersectsMesh": "interseção com malha",
    "intersectsMesh": "interseção com malha",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Verifica se a malha intercepta outra malha",
    "intersects": "intersecta",
    "babylonMesh2": "malha babylon 2",
    "precise": "preciso",
    "includeDescendants": "incluir descendentes",
    "bitbybit.babylon.mesh.intersectsPoint": "interseção com ponto",
    "intersectsPoint": "interseção com ponto",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Verifica se a malha intercepta ponto",
    "point": "ponto",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instância de malha e transformar sem retorno",
    "createMeshInstanceAndTransformNoReturn": "instância de malha e transformar sem retorno",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Cria instância de malha para renderização otimizada. Este método verificará se a malha contém filhos e criará instâncias para cada filho. Estes são otimizados para desempenho máximo ao renderizar muitos objetos semelhantes na cena. Este método retorna instâncias como filhos em uma nova malha. Se a malha tiver filhos, então cada filho se torna uma instância de malha.",
    "instance": "instância",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instância de malha e transformar",
    "createMeshInstanceAndTransform": "instância de malha e transformar",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Cria instância de malha para renderização otimizada. Este método verificará se a malha contém filhos e criará instâncias para cada filho. Estes são otimizados para desempenho máximo ao renderizar muitos objetos semelhantes na cena. Este método retorna instâncias como filhos em uma nova malha. Se a malha tiver filhos, então cada filho se torna uma instância de malha.",
    "bitbybit.babylon.mesh.createMeshInstance": "instância de malha",
    "createMeshInstance": "instância de malha",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Cria instância de malha. Estes são otimizados para desempenho máximo ao renderizar muitos objetos semelhantes na cena. Se a malha tiver filhos, então cada filho recebe uma instância de malha.",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussiano",
    "gaussianSplatting": "splatting gaussiano",
    "create": "criar",
    "bitbybit.babylon.gaussianSplatting.create_description": "cria malha de splatting gaussiano",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "clonar splatting gaussiano",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clona malha de splatting gaussiano",
    "multiply": "multiplicar",
    "BABYLON.GaussianSplattingMesh": "malha de splatting gaussiano babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "obter posições de splat",
    "getSplatPositions": "obter posições de splat",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Obtém posições splat da malha gaussian splat",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "congelar matriz de projeção",
    "camera": "câmera",
    "freezeProjectionMatrix": "congelar matriz de projeção",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Congela a matriz de projeção da câmera",
    "adjust": "ajustar",
    "BABYLON.Camera": "câmera babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "descongelar matriz de projeção",
    "unfreezeProjectionMatrix": "descongelar matriz de projeção",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Descongela a matriz de projeção da câmera",
    "bitbybit.babylon.camera.setPosition": "definir posição",
    "bitbybit.babylon.camera.setPosition_description": "Altera a posição de uma câmera",
    "BABYLON.TargetCamera": "câmera alvo babylon",
    "bitbybit.babylon.camera.getPosition": "obter posição",
    "bitbybit.babylon.camera.getPosition_description": "Obtém a posição de uma câmera",
    "bitbybit.babylon.camera.setTarget": "definir alvo",
    "setTarget": "definir alvo",
    "bitbybit.babylon.camera.setTarget_description": "Altera o alvo de uma câmera",
    "target": "alvo",
    "bitbybit.babylon.camera.getTarget": "obter alvo",
    "getTarget": "obter alvo",
    "bitbybit.babylon.camera.getTarget_description": "Obtém o alvo de uma câmera",
    "bitbybit.babylon.camera.setSpeed": "definir velocidade",
    "setSpeed": "definir velocidade",
    "bitbybit.babylon.camera.setSpeed_description": "Altera a velocidade de uma câmera",
    "speed": "velocidade",
    "bitbybit.babylon.camera.getSpeed": "obter velocidade",
    "getSpeed": "obter velocidade",
    "bitbybit.babylon.camera.getSpeed_description": "Obtém a velocidade de uma câmera",
    "bitbybit.babylon.camera.setMinZ": "definir z mínimo",
    "setMinZ": "definir z mínimo",
    "bitbybit.babylon.camera.setMinZ_description": "Altera o minZ de uma câmera",
    "minZ": "z mínimo",
    "bitbybit.babylon.camera.setMaxZ": "definir z máximo",
    "setMaxZ": "definir z máximo",
    "bitbybit.babylon.camera.setMaxZ_description": "Altera o maxZ de uma câmera",
    "maxZ": "z máximo",
    "bitbybit.babylon.camera.makeCameraOrthographic": "tornar câmera ortográfica",
    "makeCameraOrthographic": "tornar câmera ortográfica",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Altera o modo da câmera para ortográfico",
    "orthoLeft": "esquerda ortográfica",
    "orthoRight": "direita ortográfica",
    "orthoBottom": "inferior ortográfico",
    "orthoTop": "superior ortográfico",
    "bitbybit.babylon.camera.makeCameraPerspective": "tornar câmera perspectiva",
    "makeCameraPerspective": "tornar câmera perspectiva",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Altera o modo de uma câmera para perspectiva",
    "bitbybit.babylon.camera.free.create": "câmera livre",
    "free": "livre",
    "bitbybit.babylon.camera.free.create_description": "Cria uma câmera livre",
    "bitbybit.babylon.camera.arcRotate.create": "câmera de rotação em arco",
    "arcRotate": "rotação em arco",
    "bitbybit.babylon.camera.arcRotate.create_description": "Cria uma câmera que gira em torno de um alvo dado enquanto viaja pelo caminho do arco. Esta câmera é adequada para navegação 3D simples e é uma câmera padrão usada pelo bitbybit.",
    "radius": "raio",
    "alpha": "alfa",
    "beta": "beta",
    "lowerRadiusLimit": "limite inferior de raio",
    "upperRadiusLimit": "limite superior de raio",
    "lowerAlphaLimit": "limite inferior de alfa",
    "upperAlphaLimit": "limite superior de alfa",
    "lowerBetaLimit": "limite inferior de beta",
    "upperBetaLimit": "limite superior de beta",
    "angularSensibilityX": "sensibilidade angular x",
    "angularSensibilityY": "sensibilidade angular y",
    "panningSensibility": "sensibilidade de panorâmica",
    "wheelPrecision": "precisão da roda",
    "bitbybit.babylon.camera.target.create": "câmera alvo",
    "bitbybit.babylon.camera.target.create_description": "Cria uma câmera de alvo",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "experiência ar imersiva",
    "webXr": "web xr",
    "simple": "simples",
    "createImmersiveARExperience": "experiência ar imersiva",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Cria experiência XR padrão no modo immersive-ar",
    "scene": "cena",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "experiência xr padrão com teletransporte",
    "createDefaultXRExperienceWithTeleportation": "experiência xr padrão com teletransporte",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Cria experiência XR padrão com teletransporte que é muito básica e funciona para cenários simples",
    "groundMeshes": "malhas do chão",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "experiência xr padrão com teletransporte retorno",
    "createDefaultXRExperienceWithTeleportationReturn": "experiência xr padrão com teletransporte retorno",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Cria experiência XR padrão com teletransporte que é muito básica e funciona para cenários simples",
    "bitbybit.babylon.node.drawNode": "desenhar nó",
    "node": "nó",
    "drawNode": "desenhar nó",
    "bitbybit.babylon.node.drawNode_description": "Desenha um nó de tamanho dado com cores dadas para cada eixo",
    "BABYLON.TransformNode": "nó de transformação babylon",
    "bitbybit.babylon.node.drawNodes": "desenhar nós",
    "drawNodes": "desenhar nós",
    "bitbybit.babylon.node.drawNodes_description": "Desenha nós de tamanho dado com cores dadas para cada eixo",
    "nodes": "nós",
    "BABYLON.TransformNode[]": "array de nós de transformação babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "nó a partir de rotação",
    "createNodeFromRotation": "nó a partir de rotação",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Cria um nó na origem com as rotações dadas no sistema de coordenadas pai",
    "parent": "pai",
    "BABYLON.TransformNode | null": "nó de transformação babylon ou nulo",
    "origin": "origem",
    "bitbybit.babylon.node.createWorldNode": "nó mundial",
    "createWorldNode": "nó mundial",
    "bitbybit.babylon.node.createWorldNode_description": "Cria um nó mundial que tem o nó raiz como seu pai",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "obter vetor frontal absoluto",
    "getAbsoluteForwardVector": "obter vetor frontal absoluto",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Obtém o vetor absoluto voltado para frente no espaço mundial",
    "bitbybit.babylon.node.getAbsoluteRightVector": "obter vetor direito absoluto",
    "getAbsoluteRightVector": "obter vetor direito absoluto",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Obtém o vetor absoluto voltado para a direita no espaço mundial",
    "bitbybit.babylon.node.getAbsoluteUpVector": "obter vetor superior absoluto",
    "getAbsoluteUpVector": "obter vetor superior absoluto",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Obtém o vetor absoluto voltado para cima no espaço mundial",
    "bitbybit.babylon.node.getAbsolutePosition": "obter posição absoluta",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Obtém a posição absoluta do nó como vetor de origem no espaço mundial",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "obter transformação de rotação absoluta",
    "getAbsoluteRotationTransformation": "obter transformação de rotação absoluta",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Obtém a rotação absoluta do nó como uma matriz de transformação codificada em array de 16 números",
    "bitbybit.babylon.node.getRotationTransformation": "obter transformação de rotação",
    "getRotationTransformation": "obter transformação de rotação",
    "bitbybit.babylon.node.getRotationTransformation_description": "Obtém a rotação do nó no espaço de coordenadas pai local como uma matriz de transformação codificada em array de 16 números",
    "bitbybit.babylon.node.getChildren": "obter filhos",
    "getChildren": "obter filhos",
    "bitbybit.babylon.node.getChildren_description": "Obtém filhos do nó",
    "bitbybit.babylon.node.getParent": "obter pai",
    "bitbybit.babylon.node.getParent_description": "Obtém pai do nó",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "obter posição no espaço local",
    "getPositionExpressedInLocalSpace": "obter posição no espaço local",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Obtém a posição do nó expressa no espaço local",
    "bitbybit.babylon.node.getRootNode": "obter nó raiz",
    "getRootNode": "obter nó raiz",
    "bitbybit.babylon.node.getRootNode_description": "Obtém o nó raiz",
    "bitbybit.babylon.node.getRotation": "obter rotação",
    "bitbybit.babylon.node.getRotation_description": "Obtém as rotações de euler",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "rotacionar ao redor do eixo com posição",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Rotaciona o nó ao redor do eixo e posição dados por um ângulo dado",
    "bitbybit.babylon.node.rotate": "rotacionar",
    "bitbybit.babylon.node.rotate_description": "Rotaciona o nó ao redor da origem e eixo dado",
    "bitbybit.babylon.node.setAbsolutePosition": "definir posição absoluta",
    "setAbsolutePosition": "definir posição absoluta",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Define a posição absoluta do nó",
    "bitbybit.babylon.node.setDirection": "definir direção",
    "setDirection": "definir direção",
    "bitbybit.babylon.node.setDirection_description": "Define a direção do nó",
    "direction": "direção",
    "number[]": "array de números",
    "bitbybit.babylon.node.setParent": "definir pai",
    "bitbybit.babylon.node.setParent_description": "Define o novo pai para o nó",
    "parentNode": "nó pai",
    "bitbybit.babylon.node.translate": "transladar",
    "translate": "transladar",
    "bitbybit.babylon.node.translate_description": "Translada o nó por um vetor de direção e uma distância dados",
    "bitbybit.babylon.scene.backgroundColour": "cor de fundo",
    "backgroundColour": "cor de fundo",
    "bitbybit.babylon.scene.backgroundColour_description": "Altera a cor de fundo da cena para o espaço 3D",
    "environment": "ambiente",
    "colour": "cor",
    "bitbybit.babylon.scene.activateCamera": "ativar câmera",
    "activateCamera": "ativar câmera",
    "bitbybit.babylon.scene.activateCamera_description": "Ativa a câmera sobrescrevendo a câmera atualmente ativa",
    "bitbybit.babylon.scene.useRightHandedSystem": "usar sistema destro",
    "useRightHandedSystem": "usar sistema destro",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Usar sistema de mão direita",
    "system": "sistema",
    "use": "usar",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "desenhar luz pontual sem retorno",
    "drawPointLightNoReturn": "desenhar luz pontual sem retorno",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Cria e desenha uma luz pontual na cena mas não emite nada",
    "lights": "luzes",
    "intensity": "intensidade",
    "diffuse": "difusa",
    "specular": "especular",
    "shadowGeneratorMapSize": "tamanho do mapa do gerador de sombras",
    "enableShadows": "ativar sombras",
    "shadowDarkness": "escuridão da sombra",
    "shadowUsePercentageCloserFiltering": "usar filtragem de porcentagem mais próxima para sombra",
    "shadowContactHardeningLightSizeUVRatio": "razão de tamanho de luz de endurecimento de contato de sombra",
    "shadowBias": "viés da sombra",
    "shadowNormalBias": "viés normal da sombra",
    "shadowMaxZ": "z máximo da sombra",
    "shadowMinZ": "z mínimo da sombra",
    "bitbybit.babylon.scene.getShadowGenerators": "obter geradores de sombras",
    "getShadowGenerators": "obter geradores de sombras",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Obtém geradores de sombra adicionados por fontes de luz através do bitbybit",
    "bitbybit.babylon.scene.drawPointLight": "desenhar luz pontual",
    "drawPointLight": "desenhar luz pontual",
    "bitbybit.babylon.scene.drawPointLight_description": "Cria e desenha uma luz pontual na cena",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "desenhar luz direcional sem retorno",
    "drawDirectionalLightNoReturn": "desenhar luz direcional sem retorno",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Cria e desenha uma luz direcional na cena",
    "bitbybit.babylon.scene.drawDirectionalLight": "desenhar luz direcional",
    "drawDirectionalLight": "desenhar luz direcional",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Cria e desenha uma luz direcional na cena",
    "bitbybit.babylon.scene.getActiveCamera": "obter câmera ativa",
    "getActiveCamera": "obter câmera ativa",
    "bitbybit.babylon.scene.getActiveCamera_description": "Obtém a câmera ativa da cena",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "ajustar câmera de rotação em arco ativa",
    "adjustActiveArcRotateCamera": "ajustar câmera de rotação em arco ativa",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Ajusta a câmera arc rotate ativa com parâmetros de configuração",
    "lookAt": "olhar para",
    "bitbybit.babylon.scene.clearAllDrawn": "limpar tudo desenhado",
    "clearAllDrawn": "limpar tudo desenhado",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Limpa todos os objetos desenhados na cena 3D",
    "bitbybit.babylon.scene.enableSkybox": "ativar skybox",
    "enableSkybox": "ativar skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "Habilita skybox",
    "skybox": "skybox",
    "Base.skyboxEnum": "enum skybox base",
    "blur": "desfoque",
    "environmentIntensity": "intensidade do ambiente",
    "bitbybit.babylon.scene.fog": "nevoeiro",
    "fog": "nevoeiro",
    "bitbybit.babylon.scene.fog_description": "Habilita modo neblina",
    "mode": "modo",
    "Base.fogModeEnum": "enum modo de nevoeiro base",
    "color": "cor",
    "density": "densidade",
    "start": "início",
    "end": "fim",
    "bitbybit.babylon.transforms.rotationCenterAxis": "eixo de centro de rotação",
    "transforms": "transformações",
    "rotationCenterAxis": "eixo de centro de rotação",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Cria transformações de rotação ao redor do centro e um eixo",
    "center": "centro",
    "bitbybit.babylon.transforms.rotationCenterX": "centro de rotação x",
    "rotationCenterX": "centro de rotação x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Cria transformações de rotação ao redor do centro e um eixo X",
    "bitbybit.babylon.transforms.rotationCenterY": "centro de rotação y",
    "rotationCenterY": "centro de rotação y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Cria transformações de rotação ao redor do centro e um eixo Y",
    "bitbybit.babylon.transforms.rotationCenterZ": "centro de rotação z",
    "rotationCenterZ": "centro de rotação z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Cria transformações de rotação ao redor do centro e um eixo Z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "centro de rotação guinada inclinação rolagem",
    "rotationCenterYawPitchRoll": "centro de rotação guinada inclinação rolagem",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Cria transformações de rotação com guinada, arfagem e rolagem",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "escala centro xyz",
    "scaleCenterXYZ": "escala centro xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Transformação de escala ao redor do centro e direções xyz",
    "scaleXyz": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "escala xyz",
    "scaleXYZ": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Cria a transformação de escala nas direções x, y e z",
    "bitbybit.babylon.transforms.uniformScale": "escala uniforme",
    "uniformScale": "escala uniforme",
    "bitbybit.babylon.transforms.uniformScale_description": "Cria transformação de escala uniforme",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "escala uniforme a partir do centro",
    "uniformScaleFromCenter": "escala uniforme a partir do centro",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Cria transformação de escala uniforme a partir do centro",
    "bitbybit.babylon.transforms.translationXYZ": "translação xyz",
    "translationXYZ": "translação xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "Cria a transformação de translação",
    "translation": "translação",
    "bitbybit.babylon.transforms.translationsXYZ": "translações xyz",
    "translationsXYZ": "translações xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Cria a transformação de translação",
    "translations": "translações",
    "Base.Vector3[]": "array de vetores base 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "carregar ativo na cena",
    "io": "entrada/saída",
    "loadAssetIntoScene": "carregar ativo na cena",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Importa malha do ativo que você carregou para o projeto. Você deve carregar seus ativos para o seu projeto via página de gerenciamento de projeto.",
    "load": "carregar",
    "assetFile": "arquivo de ativo",
    "File": "arquivo",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "carregar ativo na cena sem retorno",
    "loadAssetIntoSceneNoReturn": "carregar ativo na cena sem retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Importa malha do ativo que você carregou para o projeto. Você deve carregar seus ativos para o seu projeto via página de gerenciamento de projeto.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "carregar ativo na cena a partir de url raiz",
    "loadAssetIntoSceneFromRootUrl": "carregar ativo na cena a partir de url raiz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Importa malha da url do ativo que você carregou para um armazenamento web acessível. Tenha em mente que arquivos precisam ser publicamente acessíveis para isso funcionar, certifique-se de que o acesso CORS está habilitado para os ativos.",
    "rootUrl": "url raiz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "carregar ativo na cena a partir de url raiz sem retorno",
    "loadAssetIntoSceneFromRootUrlNoReturn": "carregar ativo na cena a partir de url raiz sem retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Importa malha da url do ativo que você carregou para um armazenamento web acessível. Tenha em mente que arquivos precisam ser publicamente acessíveis para isso funcionar, certifique-se de que o acesso CORS está habilitado para os ativos.",
    "bitbybit.babylon.io.exportBabylon": "exportar babylon",
    "exportBabylon": "exportar babylon",
    "bitbybit.babylon.io.exportBabylon_description": "Exporta toda a cena para formato de cena .babylon. Você pode então editá-la mais em editores babylonjs.",
    "export": "exportar",
    "fileName": "nome do arquivo",
    "bitbybit.babylon.io.exportGLB": "exportar glb",
    "exportGLB": "exportar glb",
    "bitbybit.babylon.io.exportGLB_description": "Exporta toda a cena para formato .glb. Este formato de arquivo tornou-se padrão da indústria para modelos web.",
    "discardSkyboxAndGrid": "descartar skybox e grade",
    "bitbybit.babylon.io.exportMeshToStl": "exportar malha para stl",
    "exportMeshToStl": "exportar malha para stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "Exporta a malha com seus filhos para stl",
    "bitbybit.babylon.io.exportMeshesToStl": "exportar malhas para stl",
    "exportMeshesToStl": "exportar malhas para stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Exporta as malhas para stl",
    "meshes": "malhas",
    "bitbybit.babylon.ray.createPickingRay": "raio de seleção",
    "ray": "raio",
    "createPickingRay": "raio de seleção",
    "bitbybit.babylon.ray.createPickingRay_description": "Cria um raio de seleção da posição atual do mouse na câmera ativa",
    "bitbybit.babylon.ray.createRay": "raio",
    "createRay": "raio",
    "bitbybit.babylon.ray.createRay_description": "Cria um raio que começa na origem, tem vetor de direção e opcionalmente comprimento",
    "length": "comprimento",
    "bitbybit.babylon.ray.createRayFromTo": "raio de para",
    "createRayFromTo": "raio de para",
    "bitbybit.babylon.ray.createRayFromTo_description": "Cria um raio de um ponto a outro",
    "from": "de",
    "to": "para",
    "bitbybit.babylon.ray.getOrigin": "obter origem",
    "getOrigin": "obter origem",
    "bitbybit.babylon.ray.getOrigin_description": "Obtém a origem do raio",
    "BABYLON.Ray": "raio babylon",
    "bitbybit.babylon.ray.getDirection": "obter direção",
    "getDirection": "obter direção",
    "bitbybit.babylon.ray.getDirection_description": "Obtém a direção do raio",
    "bitbybit.babylon.ray.getLength": "obter comprimento",
    "getLength": "obter comprimento",
    "bitbybit.babylon.ray.getLength_description": "Obtém o comprimento do raio",
    "bitbybit.babylon.pick.pickWithRay": "selecionar com raio",
    "pick": "selecionar",
    "pickWithRay": "selecionar com raio",
    "bitbybit.babylon.pick.pickWithRay_description": "Obtém um resultado de acerto de seleção com raio",
    "bitbybit.babylon.pick.pickWithPickingRay": "selecionar com raio de seleção",
    "pickWithPickingRay": "selecionar com raio de seleção",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Seleciona com raio de seleção da posição atual do mouse na câmera ativa",
    "bitbybit.babylon.pick.getDistance": "obter distância",
    "getDistance": "obter distância",
    "bitbybit.babylon.pick.getDistance_description": "Obtém a distância até o objeto se o resultado da seleção existir",
    "get from pick info": "obter de informações de seleção",
    "pickInfo": "informações de seleção",
    "BABYLON.PickingInfo": "informações de seleção babylon",
    "bitbybit.babylon.pick.getPickedMesh": "obter malha selecionada",
    "getPickedMesh": "obter malha selecionada",
    "bitbybit.babylon.pick.getPickedMesh_description": "Obtém a malha selecionada",
    "bitbybit.babylon.pick.getPickedPoint": "obter ponto selecionado",
    "getPickedPoint": "obter ponto selecionado",
    "bitbybit.babylon.pick.getPickedPoint_description": "Obtém o ponto selecionado",
    "bitbybit.babylon.pick.hit": "colisão",
    "hit": "colisão",
    "bitbybit.babylon.pick.hit_description": "Verifica se o raio de seleção atingiu algo na cena ou não",
    "bitbybit.babylon.pick.getSubMeshId": "obter id de submalha",
    "getSubMeshId": "obter id de submalha",
    "bitbybit.babylon.pick.getSubMeshId_description": "Obtém o id único da submalha se ela foi selecionada",
    "bitbybit.babylon.pick.getSubMeshFaceId": "obter id de face de submalha",
    "getSubMeshFaceId": "obter id de face de submalha",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Obtém o id único da face da submalha se ela foi selecionada",
    "bitbybit.babylon.pick.getBU": "obter bu",
    "getBU": "obter bu",
    "bitbybit.babylon.pick.getBU_description": "Obtém a coordenada baricêntrica U que é usada ao calcular as coordenadas de textura da colisão",
    "bitbybit.babylon.pick.getBV": "obter bv",
    "getBV": "obter bv",
    "bitbybit.babylon.pick.getBV_description": "Obtém a coordenada baricêntrica V que é usada ao calcular as coordenadas de textura da colisão",
    "bitbybit.babylon.pick.getPickedSprite": "obter sprite selecionado",
    "getPickedSprite": "obter sprite selecionado",
    "bitbybit.babylon.pick.getPickedSprite_description": "Obtém o sprite selecionado",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr metálico rugosidade",
    "pbrMetallicRoughness": "pbr metálico rugosidade",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Cria material PBR rugosidade metálica.",
    "baseColor": "cor base",
    "emissiveColor": "cor emissiva",
    "metallic": "metálico",
    "roughness": "rugosidade",
    "zOffset": "deslocamento z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "definir cor base",
    "setBaseColor": "definir cor base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Define a cor base do material",
    "BABYLON.PBRMetallicRoughnessMaterial": "material pbr metálico rugosidade babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "definir metálico",
    "setMetallic": "definir metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Define a propriedade metálica do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "definir rugosidade",
    "setRoughness": "definir rugosidade",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Define a rugosidade do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "definir alfa",
    "setAlpha": "definir alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Define o alfa do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "definir eliminação de faces traseiras",
    "setBackFaceCulling": "definir eliminação de faces traseiras",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Define o descarte de face traseira do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "definir textura base",
    "setBaseTexture": "definir textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Define a textura do material",
    "baseTexture": "textura base",
    "BABYLON.Texture": "textura babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "obter cor base",
    "getBaseColor": "obter cor base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Obtém a cor base do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "obter metálico",
    "getMetallic": "obter metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Obtém a propriedade metálica do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "obter rugosidade",
    "getRoughness": "obter rugosidade",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Obtém a rugosidade do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "obter alfa",
    "getAlpha": "obter alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Obtém o alfa do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "obter eliminação de faces traseiras",
    "getBackFaceCulling": "obter eliminação de faces traseiras",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Obtém o descarte de face traseira do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "obter textura base",
    "getBaseTexture": "obter textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Obtém a textura base do material",
    "bitbybit.babylon.material.skyMaterial.create": "material céu",
    "skyMaterial": "material céu",
    "bitbybit.babylon.material.skyMaterial.create_description": "Cria Material de Céu",
    "luminance": "luminância",
    "turbidity": "turbidez",
    "rayleigh": "rayleigh",
    "mieCoefficient": "coeficiente mie",
    "mieDirectionalG": "mie direcional g",
    "inclination": "inclinação",
    "azimuth": "azimute",
    "sunPosition": "posição do sol",
    "useSunPosition": "usar posição do sol",
    "cameraOffset": "deslocamento da câmera",
    "up": "cima",
    "dithering": "dithering",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "definir luminância",
    "setLuminance": "definir luminância",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Define a luminância do material de céu",
    "MATERIALS.SkyMaterial": "material céu de materiais",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "definir turbidez",
    "setTurbidity": "definir turbidez",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Define a turbidez do material de céu",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "definir rayleigh",
    "setRayleigh": "definir rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Define o rayleigh do material de céu",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "definir coeficiente mie",
    "setMieCoefficient": "definir coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Define o coeficiente mie do material de céu",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "definir mie direcional g",
    "setMieDirectionalG": "definir mie direcional g",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Define o G direcional mie do material de céu",
    "bitbybit.babylon.material.skyMaterial.setDistance": "definir distância",
    "setDistance": "definir distância",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Define a distância do material de céu",
    "bitbybit.babylon.material.skyMaterial.setInclination": "definir inclinação",
    "setInclination": "definir inclinação",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Define a inclinação do material de céu",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "definir azimute",
    "setAzimuth": "definir azimute",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Define o azimute do material de céu",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "definir posição do sol",
    "setSunPosition": "definir posição do sol",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Define a posição do sol do material de céu",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "definir uso da posição do sol",
    "setUseSunPosition": "definir uso da posição do sol",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Define o uso da posição do sol do material de céu",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "definir deslocamento da câmera",
    "setCameraOffset": "definir deslocamento da câmera",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Define o deslocamento da câmera do material de céu",
    "bitbybit.babylon.material.skyMaterial.setUp": "definir direção cima",
    "setUp": "definir direção cima",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Define o cima do material de céu",
    "bitbybit.babylon.material.skyMaterial.setDithering": "definir dithering",
    "setDithering": "definir dithering",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Define o dithering do material de céu",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "obter luminância",
    "getLuminance": "obter luminância",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Obtém a luminância do material de céu",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "obter turbidez",
    "getTurbidity": "obter turbidez",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Obtém a turbidez do material de céu",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "obter rayleigh",
    "getRayleigh": "obter rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Obtém o rayleigh do material de céu",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "obter coeficiente mie",
    "getMieCoefficient": "obter coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Obtém o coeficiente mie do material de céu",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "obter mie direcional g",
    "getMieDirectionalG": "obter mie direcional g",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Obtém o G direcional mie do material de céu",
    "bitbybit.babylon.material.skyMaterial.getDistance": "obter distância",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Obtém a distância do material de céu",
    "bitbybit.babylon.material.skyMaterial.getInclination": "obter inclinação",
    "getInclination": "obter inclinação",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Obtém a inclinação do material de céu",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "obter azimute",
    "getAzimuth": "obter azimute",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Obtém o azimute do material de céu",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "obter posição do sol",
    "getSunPosition": "obter posição do sol",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Obtém a posição do sol do material de céu",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "obter uso da posição do sol",
    "getUseSunPosition": "obter uso da posição do sol",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Obtém o uso da posição do sol do material de céu",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "obter deslocamento da câmera",
    "getCameraOffset": "obter deslocamento da câmera",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Obtém o deslocamento da câmera do material de céu",
    "bitbybit.babylon.material.skyMaterial.getUp": "obter direção cima",
    "getUp": "obter direção cima",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Obtém o cima do material de céu",
    "bitbybit.babylon.material.skyMaterial.getDithering": "obter dithering",
    "getDithering": "obter dithering",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Obtém o dithering do material de céu",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "definir direção para alvo",
    "shadowLight": "luz de sombra",
    "setDirectionToTarget": "definir direção para alvo",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Define a direção da luz de sombra",
    "BABYLON.ShadowLight": "luz de sombra babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "definir posição",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Define a posição da luz de sombra",
    "bitbybit.babylon.meshBuilder.createBox": "caixa",
    "meshBuilder": "construtor de malha",
    "createBox": "caixa",
    "bitbybit.babylon.meshBuilder.createBox_description": "Cria uma malha de caixa",
    "create simple": "criar simples",
    "depth": "profundidade",
    "sideOrientation": "orientação lateral",
    "BabylonMesh.sideOrientationEnum": "enum de orientação lateral de malha babylon",
    "bitbybit.babylon.meshBuilder.createCube": "cubo",
    "createCube": "cubo",
    "bitbybit.babylon.meshBuilder.createCube_description": "Cria uma malha de cubo",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "plano quadrado",
    "createSquarePlane": "plano quadrado",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Cria uma malha de plano quadrado",
    "bitbybit.babylon.meshBuilder.createSphere": "esfera",
    "createSphere": "esfera",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Cria uma malha de esfera",
    "diameter": "diâmetro",
    "segments": "segmentos",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "esfera icosaédrica",
    "createIcoSphere": "esfera icosaédrica",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Cria esfera ico",
    "radiusX": "raio x",
    "radiusY": "raio y",
    "radiusZ": "raio z",
    "flat": "plano",
    "bitbybit.babylon.meshBuilder.createDisc": "disco",
    "createDisc": "disco",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Cria um disco",
    "tessellation": "tesselação",
    "arc": "arco",
    "bitbybit.babylon.meshBuilder.createTorus": "toro",
    "createTorus": "toro",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Cria uma malha de toro",
    "thickness": "espessura",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "nó toro",
    "createTorusKnot": "nó toro",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Cria uma malha de nó de toro",
    "tube": "tubo",
    "radialSegments": "segmentos radiais",
    "tubularSegments": "segmentos tubulares",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polígono",
    "createPolygon": "polígono",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Cria uma malha de polígono",
    "shape": "forma",
    "holes": "furos",
    "Base.Vector3[][]": "array de arrays de vetores base 3",
    "smoothingThreshold": "limiar de suavização",
    "wrap": "envolver",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extrudar polígono",
    "extrudePolygon": "extrudar polígono",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Cria malha de polígono extrudado",
    "bitbybit.babylon.meshBuilder.createTube": "tubo",
    "createTube": "tubo",
    "bitbybit.babylon.meshBuilder.createTube_description": "Cria uma malha de tubo",
    "path": "caminho",
    "cap": "tampa",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "poliedro",
    "createPolyhedron": "poliedro",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Cria uma malha de poliedro",
    "type": "tipo",
    "sizeX": "tamanho x",
    "sizeY": "tamanho y",
    "sizeZ": "tamanho z",
    "custom": "personalizado",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodésico",
    "createGeodesic": "geodésico",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Cria malha geodésica",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Cria malha goldberg",
    "bitbybit.babylon.meshBuilder.createCapsule": "cápsula",
    "createCapsule": "cápsula",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Cria malha de cápsula",
    "orientation": "orientação",
    "capSubdivisions": "subdivisões da tampa",
    "radiusTop": "raio superior",
    "radiusBottom": "raio inferior",
    "topCapSubdivisions": "subdivisões da tampa superior",
    "bottomCapSubdivisions": "subdivisões da tampa inferior",
    "bitbybit.babylon.meshBuilder.createCylinder": "cilindro",
    "createCylinder": "cilindro",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Cria uma malha de cilindro",
    "diameterTop": "diâmetro superior",
    "diameterBottom": "diâmetro inferior",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "forma extrudada",
    "createExtrudedSahpe": "forma extrudada",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Cria forma extrudada",
    "closeShape": "fechar forma",
    "closePath": "fechar caminho",
    "bitbybit.babylon.meshBuilder.createRibbon": "fita",
    "createRibbon": "fita",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Cria uma malha de fita",
    "pathArray": "array de caminhos",
    "closeArray": "fechar array",
    "offset": "deslocamento",
    "bitbybit.babylon.meshBuilder.createLathe": "torno",
    "createLathe": "torno",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Cria malha de torno",
    "closed": "fechado",
    "bitbybit.babylon.meshBuilder.createGround": "chão",
    "createGround": "chão",
    "bitbybit.babylon.meshBuilder.createGround_description": "Cria a malha de chão",
    "subdivisionsX": "subdivisões x",
    "subdivisionsY": "subdivisões y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "plano retangular",
    "createRectanglePlane": "plano retangular",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Cria uma malha de plano retangular",
    "bitbybit.babylon.texture.createSimple": "textura simples",
    "texture": "textura",
    "createSimple": "simples",
    "bitbybit.babylon.texture.createSimple_description": "Cria textura a partir de URL com algumas opções básicas. Se você carregou o ativo via arquivo, crie object url e passe-a aqui.",
    "invertY": "inverter y",
    "invertZ": "inverter z",
    "wAng": "ângulo w",
    "uScale": "escala u",
    "vScale": "escala v",
    "uOffset": "deslocamento u",
    "vOffset": "deslocamento v",
    "samplingMode": "modo de amostragem",
    "samplingModeEnum": "enum de modo de amostragem",
    "bitbybit.babylon.tools.createScreenshot": "captura de tela",
    "tools": "ferramentas",
    "createScreenshot": "captura de tela",
    "bitbybit.babylon.tools.createScreenshot_description": "Cria uma captura de tela da cena",
    "screenshots": "capturas de tela",
    "mimeType": "tipo mime",
    "quality": "qualidade",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "captura de tela e download",
    "createScreenshotAndDownload": "captura de tela e download",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Cria uma captura de tela da cena e baixa o arquivo",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interface de tela cheia",
    "gui": "interface gráfica",
    "advancedDynamicTexture": "textura dinâmica avançada",
    "createFullScreenUI": "interface de tela cheia",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "cria interface de tela cheia",
    "spaces": "espaços",
    "foreground": "primeiro plano",
    "adaptiveScaling": "escala adaptativa",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "para malha",
    "createForMesh": "para malha",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Cria textura dinâmica avançada para uma malha",
    "BABYLON.AbstractMesh": "malha abstrata babylon",
    "supportPointerMove": "suportar movimento de ponteiro",
    "onlyAlphaTesting": "somente teste alfa",
    "sampling": "amostragem",
    "BabylonTexture.samplingModeEnum": "enum de modo de amostragem de textura babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "alterar preenchimento de controle",
    "control": "controle",
    "changeControlPadding": "alterar preenchimento de controle",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Muda o espaçamento interno para o controle",
    "positioning": "posicionamento",
    "BABYLON.GUI.Control": "controle de interface gráfica babylon",
    "paddingLeft": "preenchimento à esquerda",
    "number | string": "número ou texto",
    "paddingRight": "preenchimento à direita",
    "paddingTop": "preenchimento superior",
    "paddingBottom": "preenchimento inferior",
    "bitbybit.babylon.gui.control.changeControlAlignment": "alterar alinhamento de controle",
    "changeControlAlignment": "alterar alinhamento de controle",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Muda o alinhamento para o controle",
    "T": "t",
    "horizontalAlignment": "alinhamento horizontal",
    "horizontalAlignmentEnum": "enum de alinhamento horizontal",
    "verticalAlignment": "alinhamento vertical",
    "verticalAlignmentEnum": "enum de alinhamento vertical",
    "bitbybit.babylon.gui.control.cloneControl": "clonar controle",
    "cloneControl": "clonar controle",
    "bitbybit.babylon.gui.control.cloneControl_description": "Clona controle",
    "container": "contêiner",
    "BABYLON.GUI.Container": "contêiner de interface gráfica babylon",
    "host": "hospedeiro",
    "BABYLON.GUI.AdvancedDynamicTexture": "textura dinâmica avançada de interface gráfica babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "seletor observável de controle",
    "createControlObservableSelector": "seletor observável de controle",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Cria o seletor de um observável para um controle",
    "selector": "seletor",
    "controlObservableSelectorEnum": "enum de seletor observável de controle",
    "bitbybit.babylon.gui.control.getControlByName": "obter controle por nome",
    "getControlByName": "obter controle por nome",
    "bitbybit.babylon.gui.control.getControlByName_description": "Obtém controle por nome",
    "bitbybit.babylon.gui.control.setIsVisible": "definir visibilidade",
    "setIsVisible": "definir visibilidade",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Define se controle é visível",
    "isVisible": "é visível",
    "bitbybit.babylon.gui.control.setIsReadonly": "definir somente leitura",
    "setIsReadonly": "definir somente leitura",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Define se controle é somente leitura",
    "isReadOnly": "é somente leitura",
    "bitbybit.babylon.gui.control.setIsEnabled": "definir habilitado",
    "setIsEnabled": "definir habilitado",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Define se controle está habilitado",
    "isEnabled": "está habilitado",
    "bitbybit.babylon.gui.control.setHeight": "definir altura",
    "setHeight": "definir altura",
    "bitbybit.babylon.gui.control.setHeight_description": "Define a altura do controle",
    "bitbybit.babylon.gui.control.setWidth": "definir largura",
    "setWidth": "definir largura",
    "bitbybit.babylon.gui.control.setWidth_description": "Define a largura do controle",
    "bitbybit.babylon.gui.control.setColor": "definir cor",
    "setColor": "definir cor",
    "bitbybit.babylon.gui.control.setColor_description": "Define a cor do controle",
    "bitbybit.babylon.gui.control.setFontSize": "definir tamanho da fonte",
    "setFontSize": "definir tamanho da fonte",
    "bitbybit.babylon.gui.control.setFontSize_description": "Define tamanho da fonte",
    "fontSize": "tamanho da fonte",
    "bitbybit.babylon.gui.control.getHeight": "obter altura",
    "getHeight": "obter altura",
    "bitbybit.babylon.gui.control.getHeight_description": "Obtém a altura",
    "bitbybit.babylon.gui.control.getWidth": "obter largura",
    "getWidth": "obter largura",
    "bitbybit.babylon.gui.control.getWidth_description": "Obtém a largura",
    "bitbybit.babylon.gui.control.getColor": "obter cor",
    "getColor": "obter cor",
    "bitbybit.babylon.gui.control.getColor_description": "Obtém a cor",
    "bitbybit.babylon.gui.control.getFontSize": "obter tamanho da fonte",
    "getFontSize": "obter tamanho da fonte",
    "bitbybit.babylon.gui.control.getFontSize_description": "Obtém tamanho da fonte do controle",
    "bitbybit.babylon.gui.control.getIsVisible": "obter visibilidade",
    "getIsVisible": "obter visibilidade",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Obtém controle visível",
    "bitbybit.babylon.gui.control.getIsReadonly": "obter somente leitura",
    "getIsReadonly": "obter somente leitura",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Obtém controle somente leitura",
    "bitbybit.babylon.gui.control.getIsEnabled": "obter habilitado",
    "getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Obtém controle habilitado",
    "bitbybit.babylon.gui.container.addControls": "adicionar controles",
    "addControls": "adicionar controles",
    "bitbybit.babylon.gui.container.addControls_description": "Adiciona controles ao contêiner e mantém a ordem",
    "controls": "controles",
    "BABYLON.GUI.Control[]": "array de controles de interface gráfica babylon",
    "clearControlsFirst": "limpar controles primeiro",
    "bitbybit.babylon.gui.container.setBackground": "definir fundo",
    "setBackground": "definir fundo",
    "bitbybit.babylon.gui.container.setBackground_description": "Define o fundo do contêiner",
    "background": "fundo",
    "bitbybit.babylon.gui.container.setIsReadonly": "definir somente leitura",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Define se contêiner é somente leitura",
    "bitbybit.babylon.gui.container.getBackground": "obter fundo",
    "getBackground": "obter fundo",
    "bitbybit.babylon.gui.container.getBackground_description": "Obtém o fundo do contêiner",
    "bitbybit.babylon.gui.container.getIsReadonly": "obter somente leitura",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Obtém se contêiner é somente leitura",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "painel de pilha",
    "stackPanel": "painel de pilha",
    "createStackPanel": "painel de pilha",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "cria painel de pilha",
    "isVertical": "é vertical",
    "spacing": "espaçamento",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "definir vertical",
    "setIsVertical": "definir vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Define se painel de pilha é vertical",
    "BABYLON.GUI.StackPanel": "painel de pilha de interface gráfica babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "definir espaçamento",
    "setSpacing": "definir espaçamento",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Define espaçamento do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.setWidth": "definir largura",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Define largura do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.setHeight": "definir altura",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Define altura do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "obter vertical",
    "getIsVertical": "obter vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Obtém se painel de pilha é vertical",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "obter espaçamento",
    "getSpacing": "obter espaçamento",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Obtém espaçamento do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getWidth": "obter largura",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Obtém largura do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getHeight": "obter altura",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Obtém altura do painel de pilha",
    "bitbybit.babylon.gui.button.createSimpleButton": "botão simples",
    "button": "botão",
    "createSimpleButton": "botão simples",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "cria botão simples",
    "label": "rótulo",
    "bitbybit.babylon.gui.button.setButtonText": "definir texto do botão",
    "setButtonText": "definir texto do botão",
    "bitbybit.babylon.gui.button.setButtonText_description": "Define texto do botão",
    "BABYLON.GUI.Button": "botão de interface gráfica babylon",
    "text": "texto",
    "bitbybit.babylon.gui.button.getButtonText": "obter texto do botão",
    "getButtonText": "obter texto do botão",
    "bitbybit.babylon.gui.button.getButtonText_description": "Obtém texto do botão",
    "bitbybit.babylon.gui.slider.createSlider": "deslizador",
    "slider": "deslizador",
    "createSlider": "deslizador",
    "bitbybit.babylon.gui.slider.createSlider_description": "cria deslizador",
    "minimum": "mínimo",
    "maximum": "máximo",
    "value": "valor",
    "step": "passo",
    "displayThumb": "exibir polegar",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "alterar polegar do deslizador",
    "changeSliderThumb": "alterar polegar do deslizador",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "altera propriedades do polegar do deslizador",
    "BABYLON.GUI.Slider": "deslizador de interface gráfica babylon",
    "isThumbCircle": "polegar é círculo",
    "thumbColor": "cor do polegar",
    "thumbWidth": "largura do polegar",
    "string | number": "texto ou número",
    "isThumbClamped": "polegar está preso",
    "bitbybit.babylon.gui.slider.setBorderColor": "definir cor da borda",
    "setBorderColor": "definir cor da borda",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Altera cor da borda do controle deslizante",
    "borderColor": "cor da borda",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "definir cor de fundo",
    "setBackgroundColor": "definir cor de fundo",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Altera cor de fundo do controle deslizante",
    "backgroundColor": "cor de fundo",
    "bitbybit.babylon.gui.slider.setMaximum": "definir máximo",
    "setMaximum": "definir máximo",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Altera valor máximo do controle deslizante",
    "bitbybit.babylon.gui.slider.setMinimum": "definir mínimo",
    "setMinimum": "definir mínimo",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Altera valor mínimo do controle deslizante",
    "bitbybit.babylon.gui.slider.setStep": "definir passo",
    "setStep": "definir passo",
    "bitbybit.babylon.gui.slider.setStep_description": "Altera valor de passo do controle deslizante",
    "bitbybit.babylon.gui.slider.setValue": "definir valor",
    "setValue": "definir valor",
    "bitbybit.babylon.gui.slider.setValue_description": "Altera valor do controle deslizante",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "seletor observável do deslizador",
    "createSliderObservableSelector": "seletor observável do deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Cria o seletor de um observável para um controle deslizante",
    "sliderObservableSelectorEnum": "enum de seletor observável do deslizador",
    "bitbybit.babylon.gui.slider.getBorderColor": "obter cor da borda",
    "getBorderColor": "obter cor da borda",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Obtém a cor da borda do controle deslizante",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "obter cor de fundo",
    "getBackgroundColor": "obter cor de fundo",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Obtém a cor de fundo do controle deslizante",
    "bitbybit.babylon.gui.slider.getMaximum": "obter máximo",
    "getMaximum": "obter máximo",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Obtém o valor máximo do controle deslizante",
    "bitbybit.babylon.gui.slider.getMinimum": "obter mínimo",
    "getMinimum": "obter mínimo",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Obtém o valor mínimo do controle deslizante",
    "bitbybit.babylon.gui.slider.getStep": "obter passo",
    "getStep": "obter passo",
    "bitbybit.babylon.gui.slider.getStep_description": "Obtém o valor de passo do controle deslizante",
    "bitbybit.babylon.gui.slider.getValue": "obter valor",
    "getValue": "obter valor",
    "bitbybit.babylon.gui.slider.getValue_description": "Obtém o valor do controle deslizante",
    "bitbybit.babylon.gui.slider.getThumbColor": "obter cor do polegar",
    "getThumbColor": "obter cor do polegar",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Obtém a cor do polegar do controle deslizante",
    "bitbybit.babylon.gui.slider.getThumbWidth": "obter largura do polegar",
    "getThumbWidth": "obter largura do polegar",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Obtém a largura do polegar do controle deslizante",
    "bitbybit.babylon.gui.slider.getIsVertical": "obter vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Obtém se o controle deslizante é vertical",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "obter exibição do polegar",
    "getDisplayThumb": "obter exibição do polegar",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Obtém se mostra polegar do controle deslizante",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "obter polegar círculo",
    "getIsThumbCircle": "obter polegar círculo",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Obtém se o polegar do controle deslizante é círculo",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "obter polegar preso",
    "getIsThumbClamped": "obter polegar preso",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Obtém se o polegar do controle deslizante é fixado",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "bloco de texto",
    "textBlock": "bloco de texto",
    "createTextBlock": "bloco de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "cria bloco de texto",
    "bitbybit.babylon.gui.textBlock.alignText": "alinhar texto",
    "alignText": "alinhar texto",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Muda o alinhamento para o texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "definir contorno do texto",
    "setTextOutline": "definir contorno do texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Muda o contorno de texto para o texto",
    "BABYLON.GUI.TextBlock": "bloco de texto de interface gráfica babylon",
    "outlineWidth": "largura do contorno",
    "outlineColor": "cor do contorno",
    "bitbybit.babylon.gui.textBlock.setText": "definir texto",
    "setText": "definir texto",
    "bitbybit.babylon.gui.textBlock.setText_description": "Define o novo texto para o bloco de texto",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "definir redimensionar para ajustar",
    "setRsizeToFit": "definir redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Habilita ou desabilita redimensionar para caber",
    "resizeToFit": "redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "definir quebra de texto",
    "setTextWrapping": "definir quebra de texto",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Define a nova quebra de texto para o bloco de texto",
    "textWrapping": "quebra de texto",
    "boolean | BABYLON.GUI.TextWrapping": "booleano ou quebra de texto de interface gráfica babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "definir espaçamento de linha",
    "setLineSpacing": "definir espaçamento de linha",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Define o espaçamento de linha do texto",
    "lineSpacing": "espaçamento de linha",
    "bitbybit.babylon.gui.textBlock.getText": "obter texto",
    "getText": "obter texto",
    "bitbybit.babylon.gui.textBlock.getText_description": "Obtém o texto do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "obter quebra de texto",
    "getTextWrapping": "obter quebra de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Obtém a quebra de texto do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "obter espaçamento de linha",
    "getLineSpacing": "obter espaçamento de linha",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Obtém o espaçamento de linha do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "obter largura do contorno",
    "getOutlineWidth": "obter largura do contorno",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Obtém a largura do contorno do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "obter redimensionar para ajustar",
    "getResizeToFit": "obter redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Obtém o redimensionar para caber do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "obter alinhamento horizontal do texto",
    "getTextHorizontalAlignment": "obter alinhamento horizontal do texto",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Obtém o alinhamento horizontal de texto do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "obter alinhamento vertical do texto",
    "getTextVerticalAlignment": "obter alinhamento vertical do texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Obtém o alinhamento vertical de texto do bloco de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "seletor observável de bloco de texto",
    "createTextBlockObservableSelector": "seletor observável de bloco de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Cria o seletor de um observável para um bloco de texto",
    "textBlockObservableSelectorEnum": "enum de seletor observável de bloco de texto",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "botão de rádio",
    "radioButton": "botão de rádio",
    "createRadioButton": "botão de rádio",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "cria botão de rádio",
    "group": "grupo",
    "isChecked": "está marcado",
    "checkSizeRatio": "razão de tamanho da marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "definir razão de tamanho da marca",
    "setCheckSizeRatio": "definir razão de tamanho da marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Define a proporção de tamanho de marcação do botão de rádio",
    "BABYLON.GUI.RadioButton": "botão de rádio de interface gráfica babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "definir grupo",
    "setGroup": "definir grupo",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Define o grupo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.setBackground": "definir fundo",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Define o fundo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "obter razão de tamanho da marca",
    "getCheckSizeRatio": "obter razão de tamanho da marca",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Obtém a proporção de tamanho de marcação do botão de rádio",
    "bitbybit.babylon.gui.radioButton.getGroup": "obter grupo",
    "getGroup": "obter grupo",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Obtém o grupo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.getBackground": "obter fundo",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Obtém o fundo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "seletor observável de botão de rádio",
    "createRadioButtonObservableSelector": "seletor observável de botão de rádio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Cria o seletor de um observável para o botão de rádio",
    "radioButtonObservableSelectorEnum": "enum de seletor observável de botão de rádio",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "caixa de seleção",
    "checkbox": "caixa de seleção",
    "createCheckbox": "caixa de seleção",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "cria caixa de seleção",
    "bitbybit.babylon.gui.checkbox.setBackground": "definir fundo",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Define o fundo da caixa de seleção",
    "BABYLON.GUI.Checkbox": "caixa de seleção de interface gráfica babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "definir razão de tamanho da marca",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Define a proporção de tamanho de marcação da caixa de seleção",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "definir marcado",
    "setIsChecked": "definir marcado",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Define se a caixa de seleção está marcada",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "obter razão de tamanho da marca",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Obtém a proporção de tamanho de marcação",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "obter marcado",
    "getIsChecked": "obter marcado",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Obtém se está marcado",
    "bitbybit.babylon.gui.checkbox.getBackground": "obter fundo",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Obtém o fundo",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "seletor observável de caixa de seleção",
    "createCheckboxObservableSelector": "seletor observável de caixa de seleção",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Cria o seletor de um observável para a caixa de seleção",
    "checkboxObservableSelectorEnum": "enum de seletor observável de caixa de seleção",
    "bitbybit.babylon.gui.inputText.createInputText": "texto de entrada",
    "inputText": "texto de entrada",
    "createInputText": "texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputText_description": "cria texto de entrada",
    "placeholder": "marcador de posição",
    "bitbybit.babylon.gui.inputText.setBackground": "definir fundo",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Define o fundo do texto de entrada",
    "BABYLON.GUI.InputText": "texto de entrada de interface gráfica babylon",
    "bitbybit.babylon.gui.inputText.setText": "definir texto",
    "bitbybit.babylon.gui.inputText.setText_description": "Define o texto do texto de entrada",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "definir marcador de posição",
    "setPlaceholder": "definir marcador de posição",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Define o espaço reservado do texto de entrada",
    "bitbybit.babylon.gui.inputText.getBackground": "obter fundo",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Obtém o fundo do texto de entrada",
    "bitbybit.babylon.gui.inputText.getText": "obter texto",
    "bitbybit.babylon.gui.inputText.getText_description": "Obtém o texto do texto de entrada",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "obter marcador de posição",
    "getPlaceholder": "obter marcador de posição",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Obtém o espaço reservado do texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "seletor observável de texto de entrada",
    "createInputTextObservableSelector": "seletor observável de texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Cria o seletor de um observável para o texto de entrada",
    "inputTextObservableSelectorEnum": "enum de seletor observável de texto de entrada",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "seletor de cor",
    "colorPicker": "seletor de cor",
    "createColorPicker": "seletor de cor",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "cria seletor de cor",
    "defaultColor": "cor padrão",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "definir valor do seletor de cor",
    "setColorPickerValue": "definir valor do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Define cor de valor do seletor de cores",
    "BABYLON.GUI.ColorPicker": "seletor de cor de interface gráfica babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "definir tamanho do seletor de cor",
    "setColorPickerSize": "definir tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Define tamanho do seletor de cores (largura e altura)",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "obter valor do seletor de cor",
    "getColorPickerValue": "obter valor do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Obtém cor de valor do seletor de cores",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "obter tamanho do seletor de cor",
    "getColorPickerSize": "obter tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "obtém o tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "seletor observável de seletor de cor",
    "createColorPickerObservableSelector": "seletor observável de seletor de cor",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Cria o seletor de um observável para seletor de cores",
    "colorPickerObservableSelectorEnum": "enum de seletor observável de seletor de cor",
    "bitbybit.babylon.gui.image.createImage": "imagem",
    "image": "imagem",
    "createImage": "imagem",
    "bitbybit.babylon.gui.image.createImage_description": "cria imagem",
    "bitbybit.babylon.gui.image.setSourceUrl": "definir url de origem",
    "setSourceUrl": "definir url de origem",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "define a url de origem da imagem",
    "BABYLON.GUI.Image": "imagem de interface gráfica babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "obter url de origem",
    "getSourceUrl": "obter url de origem",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "obtém a url de origem da imagem",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gerenciador de gizmo",
    "gizmo": "gizmo",
    "manager": "gerenciador",
    "createGizmoManager": "gerenciador de gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Cria gerenciador de gizmo",
    "positionGizmoEnabled": "gizmo de posição ativado",
    "rotationGizmoEnabled": "gizmo de rotação ativado",
    "scaleGizmoEnabled": "gizmo de escala ativado",
    "boundingBoxGizmoEnabled": "gizmo de caixa delimitadora ativado",
    "usePointerToAttachGizmos": "usar ponteiro para anexar gizmos",
    "clearGizmoOnEmptyPointerEvent": "limpar gizmo em evento de ponteiro vazio",
    "scaleRatio": "razão de escala",
    "attachableMeshes": "malhas anexáveis",
    "BABYLON.AbstractMesh[]": "array de malhas abstratas babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "obter gizmo de posição",
    "getPositionGizmo": "obter gizmo de posição",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Obtém gizmo de posição",
    "gizmoManager": "gerenciador de gizmo",
    "BABYLON.GizmoManager": "gerenciador de gizmo babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "obter gizmo de rotação",
    "getRotationGizmo": "obter gizmo de rotação",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Obtém gizmo de rotação",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "obter gizmo de escala",
    "getScaleGizmo": "obter gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Obtém gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "obter gizmo de caixa delimitadora",
    "getBoundingBoxGizmo": "obter gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Obtém gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "anexar à malha",
    "attachToMesh": "anexar à malha",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Anexa gerenciador de gizmo à malha",
    "update": "atualizar",
    "bitbybit.babylon.gizmo.manager.detachMesh": "desanexar malha",
    "detachMesh": "desanexar malha",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Desanexa gerenciador de gizmo da malha",
    "bitbybit.babylon.gizmo.base.scaleRatio": "definir razão de escala",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Define proporção de escala do gizmo",
    "BABYLON.IGizmo": "interface gizmo babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "obter razão de escala",
    "getScaleRatio": "obter razão de escala",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Obtém proporção de escala",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "definir gizmo planar ativado",
    "positionGizmo": "gizmo de posição",
    "planarGizmoEnabled": "gizmo planar ativado",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Define gizmo planar habilitado",
    "BABYLON.IPositionGizmo": "interface gizmo de posição babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "definir distância de encaixe",
    "snapDistance": "distância de encaixe",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Define distância de encaixe do gizmo de posição",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "obter malha anexada",
    "getAttachedMesh": "obter malha anexada",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Obtém malha anexada",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "obter nó anexado",
    "getAttachedNode": "obter nó anexado",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Obtém nó anexado",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "obter gizmo x",
    "getXGizmo": "obter gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Obtém gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "obter gizmo y",
    "getYGizmo": "obter gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Obtém gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "obter gizmo z",
    "getZGizmo": "obter gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Obtém gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "obter gizmo de plano x",
    "getXPlaneGizmo": "obter gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Obtém gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "obter gizmo de plano y",
    "getYPlaneGizmo": "obter gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Obtém gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "obter gizmo de plano z",
    "getZPlaneGizmo": "obter gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Obtém gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "obter gizmo planar ativado",
    "getPlanarGizmoEnabled": "obter gizmo planar ativado",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Obtém se gizmo planar habilitado",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "obter distância de encaixe",
    "getSnapDistance": "obter distância de encaixe",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Obtém distância de encaixe",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "obter arrastando",
    "getIsDragging": "obter arrastando",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Obtém se está arrastando",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "seletor observável de gizmo de posição",
    "createPositionGizmoObservableSelector": "seletor observável de gizmo de posição",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Cria o seletor de um observável para um gizmo de posição",
    "positionGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de posição",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "definir distância de encaixe",
    "rotationGizmo": "gizmo de rotação",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Define distância de encaixe do gizmo de rotação",
    "BABYLON.IRotationGizmo": "interface gizmo de rotação babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "definir sensibilidade",
    "sensitivity": "sensibilidade",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Define sensibilidade do gizmo de rotação",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "obter malha anexada",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Obtém malha anexada",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "obter nó anexado",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Obtém nó anexado",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "obter gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Obtém gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "obter gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Obtém gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "obter gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Obtém gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "obter distância de encaixe",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Obtém distância de encaixe",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "obter sensibilidade",
    "getSensitivity": "obter sensibilidade",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Obtém sensibilidade",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "seletor observável de gizmo de rotação",
    "createRotationGizmoObservableSelector": "seletor observável de gizmo de rotação",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Cria o seletor de um observável para um gizmo de rotação",
    "rotationGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de rotação",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "obter gizmo x",
    "scaleGizmo": "gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Obtém gizmo x",
    "BABYLON.IScaleGizmo": "interface gizmo de escala babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "obter gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Obtém gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "obter gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Obtém gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "definir distância de encaixe",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Define distância de encaixe do gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "definir encaixe incremental",
    "setIncrementalSnap": "definir encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Define encaixe incremental do gizmo de escala",
    "incrementalSnap": "encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "definir sensibilidade",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Define sensibilidade do gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "obter encaixe incremental",
    "getIncrementalSnap": "obter encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Obtém encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "obter distância de encaixe",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Obtém distância de encaixe",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "obter sensibilidade",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Obtém sensibilidade",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "seletor observável de gizmo de escala",
    "createScaleGizmoObservableSelector": "seletor observável de gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Cria o seletor de um observável para um gizmo de escala",
    "scaleGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "definir tamanho da esfera de rotação",
    "boundingBoxGizmo": "gizmo de caixa delimitadora",
    "setRotationSphereSize": "definir tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Define tamanho da esfera de rotação do gizmo de caixa delimitadora",
    "BABYLON.BoundingBoxGizmo": "gizmo de caixa delimitadora babylon",
    "rotationSphereSize": "tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "definir tamanho fixo da malha de arrastar na tela",
    "setFixedDragMeshScreenSize": "definir tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "Se definido, as âncoras de rotação e caixas de escala aumentarão em tamanho com base na distância da câmera para ter um tamanho de tela consistente (Padrão: false) Nota: fixedDragMeshScreenSize tem precedência sobre fixedDragMeshBoundsSize se ambos forem verdadeiros",
    "fixedDragMeshScreenSize": "tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "definir tamanho fixo dos limites da malha de arrastar",
    "setFixedDragMeshBoundsSize": "definir tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Define tamanho dos limites de malha de arrasto fixo do gizmo de caixa delimitadora",
    "fixedDragMeshBoundsSize": "tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "definir fator de distância do tamanho fixo da malha de arrastar na tela",
    "setFixedDragMeshScreenSizeDistanceFactor": "definir fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "A distância do objeto na qual as malhas arrastáveis devem aparecer do tamanho do mundo quando fixedDragMeshScreenSize é definido como verdadeiro (padrão: 10)",
    "fixedDragMeshScreenSizeDistanceFactor": "fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "definir distância de encaixe de escala",
    "setScalingSnapDistance": "definir distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Define distância de encaixe de escala do gizmo de caixa delimitadora. Distância de arrasto em unidades babylon que o gizmo encaixará a escala quando arrastado.",
    "scalingSnapDistance": "distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "definir distância de encaixe de rotação",
    "setRotationSnapDistance": "definir distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Define distância de encaixe de rotação do gizmo de caixa delimitadora. Distância de arrasto em unidades babylon que o gizmo encaixará a rotação quando arrastado.",
    "rotationSnapDistance": "distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "definir tamanho da caixa de escala",
    "setScaleBoxSize": "definir tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Define tamanho da caixa de escala do gizmo de caixa delimitadora",
    "scaleBoxSize": "tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "definir encaixe incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Define encaixe incremental do gizmo de caixa delimitadora. Escala de encaixe incremental (padrão é false). Quando verdadeiro, com uma snapDistance de 0.1, a escala será 1.1, 1.2, 1.3 em vez de, quando falso: 1.1, 1.21, 1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "definir pivô de escala",
    "setScalePivot": "definir pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Define pivô de escala do gizmo de caixa delimitadora. Pivô relativo de caixa delimitadora usado ao escalar o nó anexado. Quando nulo objeto com escala do canto oposto. 0.5,0.5,0.5 para centro e 0.5,0,0.5 para baixo (Padrão: null)",
    "scalePivot": "pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "definir fator de eixo",
    "setAxisFactor": "definir fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Define fator de eixo do gizmo de caixa delimitadora. Define valor de sensibilidade personalizado para cada eixo",
    "axisFactor": "fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "definir velocidade de arrastar escala",
    "setScaleDragSpeed": "definir velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Define velocidade de arrasto de escala do gizmo de caixa delimitadora",
    "scaleDragSpeed": "velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "obter tamanho da esfera de rotação",
    "getRotationSphereSize": "obter tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Obtém tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "obter tamanho da caixa de escala",
    "getScaleBoxSize": "obter tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Obtém tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "obter tamanho fixo da malha de arrastar na tela",
    "getFixedDragMeshScreenSize": "obter tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Obtém tamanho de tela da malha de arrasto fixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "obter tamanho fixo dos limites da malha de arrastar",
    "getFixedDragMeshBoundsSize": "obter tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Obtém tamanho de limites da malha de arrasto fixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "obter fator de distância do tamanho fixo da malha de arrastar na tela",
    "getFixedDragMeshScreenSizeDistanceFactor": "obter fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Obtém fator de distância de tamanho de tela da malha de arrasto fixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "obter distância de encaixe de escala",
    "getScalingSnapDistance": "obter distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Obtém distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "obter distância de encaixe de rotação",
    "getRotationSnapDistance": "obter distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Obtém distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "obter encaixe incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Obtém encaixe incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "obter pivô de escala",
    "getScalePivot": "obter pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Obtém pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "obter fator de eixo",
    "getAxisFactor": "obter fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Obtém fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "obter velocidade de arrastar escala",
    "getScaleDragSpeed": "obter velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Obtém velocidade de arrasto de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "seletor observável de gizmo de caixa delimitadora",
    "createBoundingBoxGizmoObservableSelector": "seletor observável de gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Cria o seletor de um observável para um gizmo de caixa delimitadora",
    "boundingBoxGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "definir habilitado",
    "axisDragGizmo": "gizmo de arrastar eixo",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Define se o eixo está habilitado ou não",
    "BABYLON.IAxisDragGizmo": "interface gizmo de arrastar eixo babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Verifica se o eixo está habilitado",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "definir habilitado",
    "axisScaleGizmo": "gizmo de escala de eixo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Define se o eixo está habilitado ou não",
    "BABYLON.IAxisScaleGizmo": "interface gizmo de escala de eixo babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Verifica se o eixo está habilitado",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "definir habilitado",
    "planeDragGizmo": "gizmo de arrastar plano",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Define se o plano está habilitado ou não",
    "BABYLON.IPlaneDragGizmo": "interface gizmo de arrastar plano babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Verifica se o plano está habilitado",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "definir habilitado",
    "planeRotationGizmo": "gizmo de rotação de plano",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Define se o plano está habilitado ou não",
    "BABYLON.IPlaneRotationGizmo": "interface gizmo de rotação de plano babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Verifica se o plano está habilitado",
    "bitbybit.vector.removeAllDuplicateVectors": "remover todos os vetores duplicados",
    "vector": "vetor",
    "removeAllDuplicateVectors": "remover todos os vetores duplicados",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Remove todos os vetores duplicados do array de entrada (mantém apenas vetores únicos). Exemplo: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]] → [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "remover",
    "vectors": "vetores",
    "number[][]": "array de arrays de números",
    "tolerance": "tolerância",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "remover vetores duplicados consecutivos",
    "removeConsecutiveDuplicateVectors": "remover vetores duplicados consecutivos",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Remove vetores duplicados consecutivos do array de entrada (remove apenas duplicatas que aparecem lado a lado). Exemplo: [[1,2], [1,2], [3,4], [1,2]] → [[1,2], [3,4], [1,2]] (apenas duplicata consecutiva removida)",
    "checkFirstAndLast": "verificar primeiro e último",
    "bitbybit.vector.angleBetween": "ângulo entre",
    "angleBetween": "ângulo entre",
    "bitbybit.vector.angleBetween_description": "Mede o ângulo entre dois vetores em graus (sempre retorna ângulo positivo 0-180°). Exemplo: [1,0,0] e [0,1,0] → 90° (vetores perpendiculares)",
    "angles": "ângulos",
    "first": "primeiro",
    "second": "segundo",
    "bitbybit.vector.angleBetweenNormalized2d": "ângulo entre normalizado 2d",
    "angleBetweenNormalized2d": "ângulo entre normalizado 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Mede o ângulo 2D normalizado entre dois vetores em graus (considera direção, pode ser negativo). Exemplo: [1,0] para [0,1] → 90°, [0,1] para [1,0] → -90°",
    "bitbybit.vector.positiveAngleBetween": "ângulo positivo entre",
    "positiveAngleBetween": "ângulo positivo entre",
    "bitbybit.vector.positiveAngleBetween_description": "Mede um ângulo positivo entre dois vetores dado o vetor de referência em graus (sempre 0-360°). Exemplo: converte ângulos com sinal negativo para positivo adicionando 360° quando necessário",
    "reference": "referência",
    "bitbybit.vector.addAll": "somar todos",
    "addAll": "somar todos",
    "bitbybit.vector.addAll_description": "Adiciona todos os valores xyz do vetor elemento a elemento e cria um novo vetor. Exemplo: [[1,2,3], [4,5,6], [7,8,9]] → [12,15,18] (soma cada coluna)",
    "sum": "soma",
    "bitbybit.vector.add": "adicionar",
    "add": "adicionar",
    "bitbybit.vector.add_description": "Adiciona dois vetores juntos elemento a elemento. Exemplo: [1,2,3] + [4,5,6] → [5,7,9]",
    "bitbybit.vector.all": "todos",
    "all": "todos",
    "bitbybit.vector.all_description": "Verifica se o array booleano contém apenas valores verdadeiros, retorna falso se houver um único falso. Exemplo: [true, true, true] → verdadeiro, [true, false, true] → falso",
    "boolean[]": "array booleano",
    "bitbybit.vector.cross": "produto vetorial",
    "cross": "produto vetorial",
    "bitbybit.vector.cross_description": "Calcula o produto vetorial de dois vetores 3D (vetor perpendicular a ambas as entradas). Exemplo: [1,0,0] × [0,1,0] → [0,0,1] (regra da mão direita)",
    "bitbybit.vector.distSquared": "distância ao quadrado",
    "distSquared": "distância ao quadrado",
    "bitbybit.vector.distSquared_description": "Calcula distância quadrada entre dois vetores (mais rápido que distância, evita raiz quadrada). Exemplo: [0,0,0] a [3,4,0] → 25 (distância 5 ao quadrado)",
    "bitbybit.vector.dist": "distância",
    "dist": "distância",
    "bitbybit.vector.dist_description": "Calcula a distância Euclidiana entre dois vetores. Exemplo: [0,0,0] a [3,4,0] → 5, [1,1] a [4,5] → 5",
    "bitbybit.vector.div": "dividir",
    "div": "dividir",
    "bitbybit.vector.div_description": "Divide cada elemento do vetor por um valor escalar. Exemplo: [10,20,30] ÷ 2 → [5,10,15]",
    "scalar": "escalar",
    "bitbybit.vector.domain": "domínio",
    "domain": "domínio",
    "bitbybit.vector.domain_description": "Calcula o domínio (intervalo) entre valores mínimo e máximo do vetor. Exemplo: [1,3,5,9] → 8 (diferença entre último e primeiro: 9-1)",
    "bitbybit.vector.dot": "produto escalar",
    "dot": "produto escalar",
    "bitbybit.vector.dot_description": "Calcula o produto escalar entre dois vetores (mede similaridade/projeção). Exemplo: [1,2,3] • [4,5,6] → 32 (1×4 + 2×5 + 3×6), vetores perpendiculares → 0",
    "bitbybit.vector.finite": "finito",
    "finite": "finito",
    "bitbybit.vector.finite_description": "Verifica se cada elemento no vetor é finito e retorna um array booleano. Exemplo: [1, 2, Infinito, 3] → [true, true, false, true]",
    "validate": "validar",
    "bitbybit.vector.isZero": "é zero",
    "isZero": "é zero",
    "bitbybit.vector.isZero_description": "Verifica se o vetor tem comprimento zero (todos os elementos são zero). Exemplo: [0,0,0] → verdadeiro, [0,0,0.001] → falso",
    "bitbybit.vector.lerp": "interpolação linear",
    "lerp": "interpolação linear",
    "bitbybit.vector.lerp_description": "Encontra um vetor interpolado entre dois vetores usando uma fração (interpolação linear). Exemplo: [0,0,0] a [10,10,10] em 0.5 → [5,5,5], fração=0 → primeiro, fração=1 → segundo",
    "fraction": "fração",
    "bitbybit.vector.max": "máximo",
    "max": "máximo",
    "bitbybit.vector.max_description": "Encontra o valor máximo (maior) no vetor. Exemplo: [3, 7, 2, 9, 1] → 9",
    "extract": "extrair",
    "bitbybit.vector.min": "mínimo",
    "min": "mínimo",
    "bitbybit.vector.min_description": "Encontra o valor mínimo (menor) no vetor. Exemplo: [3, 7, 2, 9, 1] → 1",
    "bitbybit.vector.mul": "multiplicar",
    "mul": "multiplicar",
    "bitbybit.vector.mul_description": "Multiplica cada elemento do vetor por um valor escalar. Exemplo: [2,3,4] × 5 → [10,15,20]",
    "bitbybit.vector.neg": "negar",
    "neg": "negar",
    "bitbybit.vector.neg_description": "Nega o vetor (inverte o sinal de cada elemento). Exemplo: [5,-3,2] → [-5,3,-2]",
    "bitbybit.vector.normSquared": "norma ao quadrado",
    "normSquared": "norma ao quadrado",
    "bitbybit.vector.normSquared_description": "Calcula a norma quadrada (magnitude/comprimento ao quadrado) do vetor. Exemplo: [3,4,0] → 25 (comprimento 5 ao quadrado)",
    "bitbybit.vector.norm": "norma",
    "norm": "norma",
    "bitbybit.vector.norm_description": "Calcula a norma (magnitude/comprimento) do vetor. Exemplo: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.vector.normalized": "normalizado",
    "normalized": "normalizado",
    "bitbybit.vector.normalized_description": "Normaliza o vetor em um vetor unitário que tem um comprimento de 1 (mantém a direção, escala a magnitude para 1). Exemplo: [3,4,0] → [0.6,0.8,0], [10,0,0] → [1,0,0]",
    "bitbybit.vector.onRay": "no raio",
    "onRay": "no raio",
    "bitbybit.vector.onRay_description": "Encontra um ponto em um raio a uma dada distância da origem ao longo do vetor de direção. Exemplo: Ponto [0,0,0] + direção [1,0,0] a distância 5 → [5,0,0]",
    "bitbybit.vector.vectorXYZ": "vetor xyz",
    "vectorXYZ": "vetor xyz",
    "bitbybit.vector.vectorXYZ_description": "Cria um vetor 3D a partir das coordenadas x, y, z. Exemplo: x=1, y=2, z=3 → [1,2,3]",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vetor xy",
    "vectorXY": "vetor xy",
    "bitbybit.vector.vectorXY_description": "Cria um vetor 2D a partir das coordenadas x, y. Exemplo: x=3, y=4 → [3,4]",
    "bitbybit.vector.range": "intervalo",
    "range": "intervalo",
    "bitbybit.vector.range_description": "Cria um vetor de inteiros de 0 a máx (exclusivo). Exemplo: máx=5 → [0,1,2,3,4], máx=3 → [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "ângulo assinado entre",
    "signedAngleBetween": "ângulo assinado entre",
    "bitbybit.vector.signedAngleBetween_description": "Calcula ângulo com sinal entre dois vetores usando um vetor de referência (determina direção de rotação). Exemplo: Retorna ângulo positivo ou negativo dependendo da direção de rotação relativa à referência",
    "bitbybit.vector.span": "extensão",
    "span": "extensão",
    "bitbybit.vector.span_description": "Cria um vetor contendo números de min a máx em um incremento de passo dado. Exemplo: min=0, máx=10, passo=2 → [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "extensão de itens com suavização",
    "spanEaseItems": "extensão de itens com suavização",
    "bitbybit.vector.spanEaseItems_description": "Cria um vetor com números de min a máx usando uma função de suavização para distribuição não linear. Exemplo: min=0, máx=100, nrItems=5, ease='easeInQuad' → cria intervalos acelerados",
    "nrItems": "número de itens",
    "ease": "suavização",
    "Math.easeEnum": "enum de suavização matemática",
    "intervals": "intervalos",
    "bitbybit.vector.spanLinearItems": "extensão de itens lineares",
    "spanLinearItems": "extensão de itens lineares",
    "bitbybit.vector.spanLinearItems_description": "Cria um vetor com números uniformemente espaçados de min a máx com um número especificado de itens. Exemplo: min=0, máx=10, nrItems=5 → [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "subtrair",
    "sub": "subtrair",
    "bitbybit.vector.sub_description": "Subtrai o segundo vetor do primeiro elemento a elemento. Exemplo: [10,20,30] - [1,2,3] → [9,18,27]",
    "bitbybit.vector.sum": "soma",
    "bitbybit.vector.sum_description": "Soma todos os valores no vetor e retorna um único número. Exemplo: [1,2,3,4] → 10, [5,10,15] → 30",
    "bitbybit.point.transformPoint": "transformar ponto",
    "transformPoint": "transformar ponto",
    "bitbybit.point.transformPoint_description": "Aplica matriz de transformação a um único ponto (rotaciona, escala ou translada). Exemplo: ponto=[0,0,0] com translação [5,5,0] → [5,5,0]",
    "transformation": "transformação",
    "Base.TransformMatrixes": "matrizes de transformação base",
    "bitbybit.point.transformPoints": "transformar pontos",
    "transformPoints": "transformar pontos",
    "bitbybit.point.transformPoints_description": "Aplica a mesma matriz de transformação a múltiplos pontos (transformação em lote). Exemplo: 5 pontos com rotação 90° → todos os 5 pontos rotacionados juntos",
    "points": "pontos",
    "bitbybit.point.transformsForPoints": "transformações para pontos",
    "transformsForPoints": "transformações para pontos",
    "bitbybit.point.transformsForPoints_description": "Aplica diferentes matrizes de transformação a pontos correspondentes (uma transformação por ponto). Arrays devem ter comprimento igual. Exemplo: 3 pontos com 3 translações diferentes → cada ponto movido independentemente",
    "Base.TransformMatrixes[]": "array de matrizes de transformação base",
    "bitbybit.point.translatePoints": "transladar pontos",
    "translatePoints": "transladar pontos",
    "bitbybit.point.translatePoints_description": "Move múltiplos pontos por um vetor de translação (mesmo deslocamento para todos os pontos). Exemplo: pontos=[[0,0,0], [1,0,0]], translação=[5,5,0] → [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "transladar pontos com vetores",
    "translatePointsWithVectors": "transladar pontos com vetores",
    "bitbybit.point.translatePointsWithVectors_description": "Move múltiplos pontos por vetores de translação correspondentes (um vetor por ponto). Arrays devem ter comprimento igual. Exemplo: 3 pontos com 3 vetores diferentes → cada ponto movido pelo seu vetor correspondente",
    "bitbybit.point.translateXYZPoints": "transladar pontos xyz",
    "translateXYZPoints": "transladar pontos xyz",
    "bitbybit.point.translateXYZPoints_description": "Move múltiplos pontos por valores X, Y, Z separados (método conveniente para translação). Exemplo: pontos=[[0,0,0]], x=10, y=5, z=0 → [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "escalar pontos do centro xyz",
    "scalePointsCenterXYZ": "escalar pontos do centro xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "Escala múltiplos pontos ao redor de um ponto central com diferentes fatores por eixo. Exemplo: pontos=[[10,0,0]], centro=[5,0,0], scaleXyz=[2,1,1] → [[15,0,0]] (dobra distância X do centro)",
    "bitbybit.point.rotatePointsCenterAxis": "rotacionar pontos em torno do centro e eixo",
    "rotatePointsCenterAxis": "rotacionar pontos em torno do centro e eixo",
    "bitbybit.point.rotatePointsCenterAxis_description": "Rotaciona múltiplos pontos ao redor de um ponto central ao longo de um eixo personalizado. Exemplo: pontos=[[10,0,0]], centro=[0,0,0], eixo=[0,1,0], ângulo=90° → [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "distância do ponto mais próximo entre pontos",
    "closestPointFromPointsDistance": "distância do ponto mais próximo entre pontos",
    "bitbybit.point.closestPointFromPointsDistance_description": "Calcula distância até o ponto mais próximo em uma coleção. Exemplo: ponto=[0,0,0], pontos=[[5,0,0], [10,0,0], [3,0,0]] → 3 (distância para [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "índice do ponto mais próximo entre pontos",
    "closestPointFromPointsIndex": "índice do ponto mais próximo entre pontos",
    "bitbybit.point.closestPointFromPointsIndex_description": "Encontra índice do array do ponto mais próximo em uma coleção (índice base-1, não base-0). Exemplo: ponto=[0,0,0], pontos=[[5,0,0], [10,0,0], [3,0,0]] → 3 (índice de [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "ponto mais próximo entre pontos",
    "closestPointFromPoints": "ponto mais próximo entre pontos",
    "bitbybit.point.closestPointFromPoints_description": "Encontra o ponto mais próximo em uma coleção para um ponto de referência. Exemplo: ponto=[0,0,0], pontos=[[5,0,0], [10,0,0], [3,0,0]] → [3,0,0]",
    "bitbybit.point.distance": "distância",
    "bitbybit.point.distance_description": "Calcula distância Euclidiana entre dois pontos. Exemplo: início=[0,0,0], fim=[3,4,0] → 5 (usando teorema de Pitágoras: √(3²+4²))",
    "measure": "medir",
    "startPoint": "ponto inicial",
    "endPoint": "ponto final",
    "bitbybit.point.distancesToPoints": "distâncias até pontos",
    "distancesToPoints": "distâncias até pontos",
    "bitbybit.point.distancesToPoints_description": "Calcula distâncias de um ponto inicial para múltiplos pontos finais. Exemplo: início=[0,0,0], pontosFim=[[3,0,0], [0,4,0], [5,0,0]] → [3, 4, 5]",
    "endPoints": "pontos finais",
    "bitbybit.point.multiplyPoint": "multiplicar ponto",
    "multiplyPoint": "multiplicar ponto",
    "bitbybit.point.multiplyPoint_description": "Duplica um ponto N vezes (cria array com N cópias do mesmo ponto). Exemplo: ponto=[5,5,0], quantidadePontos=3 → [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "quantidade de pontos",
    "bitbybit.point.getX": "obter x",
    "getX": "obter x",
    "bitbybit.point.getX_description": "Extrai coordenada X de um ponto. Exemplo: ponto=[5,10,3] → 5",
    "bitbybit.point.getY": "obter y",
    "getY": "obter y",
    "bitbybit.point.getY_description": "Extrai coordenada Y de um ponto. Exemplo: ponto=[5,10,3] → 10",
    "bitbybit.point.getZ": "obter z",
    "getZ": "obter z",
    "bitbybit.point.getZ_description": "Extrai coordenada Z de um ponto. Exemplo: ponto=[5,10,3] → 3",
    "bitbybit.point.averagePoint": "ponto médio",
    "averagePoint": "ponto médio",
    "bitbybit.point.averagePoint_description": "Calcula centroide (posição média) de múltiplos pontos. Exemplo: pontos=[[0,0,0], [10,0,0], [10,10,0]] → [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "ponto xyz",
    "pointXYZ": "ponto xyz",
    "bitbybit.point.pointXYZ_description": "Cria um ponto 3D a partir das coordenadas X, Y, Z. Exemplo: x=10, y=5, z=3 → [10,5,3]",
    "bitbybit.point.pointXY": "ponto xy",
    "pointXY": "ponto xy",
    "bitbybit.point.pointXY_description": "Cria um ponto 2D a partir das coordenadas X, Y. Exemplo: x=10, y=5 → [10,5]",
    "bitbybit.point.spiral": "espiral",
    "spiral": "espiral",
    "bitbybit.point.spiral_description": "Cria pontos em espiral logarítmica usando ângulo áureo ou fator de alargamento personalizado. Gera padrões espirais naturais comuns na natureza (girassol, concha nautilus). Exemplo: numeroPontos=100, raio=10, phi=1.618 → 100 pontos formando espiral para fora",
    "phi": "phi",
    "numberPoints": "número de pontos",
    "widening": "alargamento",
    "factor": "fator",
    "bitbybit.point.hexGrid": "grade hexagonal",
    "hexGrid": "grade hexagonal",
    "bitbybit.point.hexGrid_description": "Cria pontos centrais de grade hexagonal no plano XY (padrão favo de mel). Tamanho da grade controlado por número de hexágonos, não largura/altura. Exemplo: raioHexagono=1, nrHexagonosX=3, nrHexagonosY=3 → 9 centros hex em padrão de grade",
    "nrHexagonsY": "número de hexágonos y",
    "nrHexagonsX": "número de hexágonos x",
    "radiusHexagon": "raio do hexágono",
    "orientOnCenter": "orientar no centro",
    "pointsOnGround": "pontos no chão",
    "bitbybit.point.removeConsecutiveDuplicates": "remover duplicatas consecutivas",
    "removeConsecutiveDuplicates": "remover duplicatas consecutivas",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Remove pontos duplicados consecutivos do array dentro da tolerância. Exemplo: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]] → [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "limpar",
    "bitbybit.line.convertToNurbsCurve": "converter para curva nurbs",
    "line": "linha",
    "convertToNurbsCurve": "converter para curva nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "converte linha em curva nurbs",
    "LinePointsDto": "dto de pontos da linha",
    "bitbybit.line.convertLinesToNurbsCurves": "converter linhas para curvas nurbs",
    "convertLinesToNurbsCurves": "converter linhas para curvas nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "converte linhas em um array de curvas nurbs",
    "lines": "linhas",
    "LinePointsDto[]": "array de dto de pontos da linha",
    "bitbybit.line.getStartPoint": "obter ponto inicial",
    "getStartPoint": "obter ponto inicial",
    "bitbybit.line.getStartPoint_description": "Extrai ponto inicial de uma linha. Exemplo: linha={start:[0,0,0], end:[10,5,0]} → [0,0,0]",
    "bitbybit.line.getEndPoint": "obter ponto final",
    "getEndPoint": "obter ponto final",
    "bitbybit.line.getEndPoint_description": "Extrai ponto final de uma linha. Exemplo: linha={start:[0,0,0], end:[10,5,0]} → [10,5,0]",
    "bitbybit.line.length": "comprimento",
    "bitbybit.line.length_description": "Calcula comprimento (distância) de um segmento de linha. Exemplo: linha={start:[0,0,0], end:[3,4,0]} → 5 (usando teorema de Pitágoras)",
    "bitbybit.line.reverse": "inverter",
    "reverse": "inverter",
    "bitbybit.line.reverse_description": "Inverte direção da linha trocando pontos inicial e final. Exemplo: linha={start:[0,0,0], end:[10,5,0]} → {start:[10,5,0], end:[0,0,0]}",
    "bitbybit.line.transformLine": "transformar linha",
    "transformLine": "transformar linha",
    "bitbybit.line.transformLine_description": "Aplica matriz de transformação à linha (rotaciona, escala ou translada ambos os pontos finais). Exemplo: linha={start:[0,0,0], end:[10,0,0]} com translação [5,5,0] → {start:[5,5,0], end:[15,5,0]}",
    "bitbybit.line.transformsForLines": "transformações para linhas",
    "transformsForLines": "transformações para linhas",
    "bitbybit.line.transformsForLines_description": "Aplica múltiplas transformações a múltiplas linhas (uma transformação por linha). Exemplo: 3 linhas com 3 matrizes de translação diferentes → cada linha movida independentemente",
    "bitbybit.line.create": "criar",
    "bitbybit.line.create_description": "Cria uma linha a partir de dois pontos (objeto linha com propriedades start e end). Exemplo: start=[0,0,0], end=[10,5,0] → {start:[0,0,0], end:[10,5,0]}",
    "bitbybit.line.createAsync": "assíncrono",
    "createAsync": "assíncrono",
    "bitbybit.line.createAsync_description": "cria linha a partir de pontos assíncronos",
    "bitbybit.line.getPointOnLine": "obter ponto na linha",
    "getPointOnLine": "obter ponto na linha",
    "bitbybit.line.getPointOnLine_description": "Calcula ponto no parâmetro t ao longo do segmento de linha (0=início, 1=fim, interpolação linear). Exemplo: linha={start:[0,0,0], end:[10,0,0]}, param=0.5 → [5,0,0] (ponto médio)",
    "param": "parâmetro",
    "bitbybit.line.linesBetweenPoints": "linhas entre pontos",
    "linesBetweenPoints": "linhas entre pontos",
    "bitbybit.line.linesBetweenPoints_description": "Cria segmentos de linha conectando pontos consecutivos em uma lista (forma um caminho de polilinha). Exemplo: pontos=[[0,0,0], [5,0,0], [5,5,0]] → 2 linhas: [0→5] e [5→5,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "linhas entre pontos iniciais e finais",
    "linesBetweenStartAndEndPoints": "linhas entre pontos iniciais e finais",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Cria linhas emparelhando pontos iniciais e finais correspondentes de dois arrays. Filtra linhas de comprimento zero. Exemplo: inícios=[[0,0,0], [5,0,0]], fins=[[0,5,0], [5,5,0]] → 2 linhas conectando pontos emparelhados",
    "startPoints": "pontos iniciais",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "linhas entre pontos iniciais e finais assíncronas",
    "linesBetweenStartAndEndPointsAsync": "linhas entre pontos iniciais e finais assíncronas",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "cria linhas entre pontos iniciais e finais com entradas assíncronas",
    "bitbybit.polyline.convertToNurbsCurve": "converter para curva nurbs",
    "polyline": "polilinha",
    "bitbybit.polyline.convertToNurbsCurve_description": "converte polilinha em curva nurbs",
    "PolylinePropertiesDto": "dto de propriedades da polilinha",
    "bitbybit.polyline.length": "comprimento",
    "bitbybit.polyline.length_description": "Calcula comprimento total da polilinha somando distâncias entre pontos consecutivos. Exemplo: pontos=[[0,0,0], [3,0,0], [3,4,0]] → 3 + 4 = 7",
    "bitbybit.polyline.countPoints": "contar pontos",
    "countPoints": "contar pontos",
    "bitbybit.polyline.countPoints_description": "Conta número de pontos na polilinha. Exemplo: polilinha com pontos=[[0,0,0], [1,0,0], [1,1,0]] → 3",
    "bitbybit.polyline.getPoints": "obter pontos",
    "getPoints": "obter pontos",
    "bitbybit.polyline.getPoints_description": "Extrai array de pontos do objeto polilinha. Exemplo: polilinha={points:[[0,0,0], [1,0,0]]} → [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "inverter",
    "bitbybit.polyline.reverse_description": "Inverte ordem dos pontos da polilinha (inverte direção). Exemplo: pontos=[[0,0,0], [1,0,0], [2,0,0]] → [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "transformar polilinha",
    "transformPolyline": "transformar polilinha",
    "bitbybit.polyline.transformPolyline_description": "Aplica matriz de transformação a todos os pontos na polilinha (rotaciona, escala ou translada). Exemplo: polilinha com 4 pontos, translação [5,0,0] → todos os pontos movidos +5 na direção X",
    "bitbybit.polyline.create": "criar",
    "bitbybit.polyline.create_description": "Cria uma polilinha a partir de array de pontos com flag isClosed opcional. Exemplo: pontos=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true → {points:..., isClosed:true}",
    "isClosed": "está fechada",
    "string | number[]": "texto ou array de números",
    "bitbybit.occt.deleteShape": "excluir forma",
    "occt": "occt",
    "deleteShape": "excluir forma",
    "bitbybit.occt.deleteShape_description": "Deleta forma do cache para manter uso de memória baixo",
    "bitbybit.occt.deleteShapes": "excluir formas",
    "deleteShapes": "excluir formas",
    "bitbybit.occt.deleteShapes_description": "Deleta formas do cache para manter uso de memória baixo",
    "shapes": "formas",
    "T[]": "array de t",
    "bitbybit.occt.cleanAllCache": "limpar todo o cache",
    "cleanAllCache": "limpar todo o cache",
    "bitbybit.occt.cleanAllCache_description": "Limpa todo cache e todas as formas da memória",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "vértice a partir de xyz",
    "vertex": "vértice",
    "vertexFromXYZ": "vértice a partir de xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Cria forma vértice a partir de coordenadas x y z",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "vértice a partir de ponto",
    "vertexFromPoint": "vértice a partir de ponto",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Cria forma vértice a partir de ponto",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "vértices a partir de pontos",
    "verticesFromPoints": "vértices a partir de pontos",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "cria vértices a partir de pontos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "composto de vértices a partir de pontos",
    "verticesCompoundFromPoints": "composto de vértices a partir de pontos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Cria forma composta contendo múltiplos vértices. Isso simplesmente acelera a renderização e permite aplicar transformações occt facilmente em grupos de vértices.",
    "bitbybit.occt.shapes.vertex.getVertices": "obter vértices",
    "getVertices": "obter vértices",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Obter todos os vértices na lista de uma forma",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "obter vértices como pontos",
    "getVerticesAsPoints": "obter vértices como pontos",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Obter todos os vértices na lista de uma forma como pontos",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "vértices para pontos",
    "verticesToPoints": "vértices para pontos",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforma vértices em pontos",
    "transform": "transformar",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "vértice para ponto",
    "vertexToPoint": "vértice para ponto",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Transformar vértice em ponto",
    "bitbybit.occt.shapes.vertex.projectPoints": "projetar pontos",
    "projectPoints": "projetar pontos",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "projeta pontos na forma",
    "place": "posicionar",
    "projectionType": "tipo de projeção",
    "pointProjectionTypeEnum": "enum de tipo de projeção de ponto",
    "bitbybit.occt.shapes.edge.line": "linha",
    "edge": "borda",
    "bitbybit.occt.shapes.edge.line_description": "cria borda linear entre dois pontos",
    "primitives": "primitivas",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arco através de três pontos",
    "arcThroughThreePoints": "arco através de três pontos",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Cria aresta em arco entre três pontos",
    "middle": "meio",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arco através de dois pontos e tangente",
    "arcThroughTwoPointsAndTangent": "arco através de dois pontos e tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Cria aresta em arco entre dois pontos dado o vetor de direção tangente no primeiro ponto.",
    "tangentVec": "vetor tangente",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arco a partir de círculo e dois pontos",
    "arcFromCircleAndTwoPoints": "arco a partir de círculo e dois pontos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Cria uma aresta em arco entre dois pontos em um círculo",
    "circle": "círculo",
    "sense": "sentido",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arco a partir de círculo e dois ângulos",
    "arcFromCircleAndTwoAngles": "arco a partir de círculo e dois ângulos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Cria uma aresta em arco entre dois ângulos alfa em um círculo",
    "alphaAngle1": "ângulo alfa 1",
    "alphaAngle2": "ângulo alfa 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arco a partir de círculo, ponto e ângulo",
    "arcFromCirclePointAndAngle": "arco a partir de círculo, ponto e ângulo",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Cria uma aresta em arco entre o ponto em um círculo e um ângulo alfa dado",
    "alphaAngle": "ângulo alfa",
    "bitbybit.occt.shapes.edge.createCircleEdge": "borda de círculo",
    "createCircleEdge": "borda de círculo",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "cria borda de círculo opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "borda de elipse",
    "createEllipseEdge": "borda de elipse",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "cria borda de elipse opencascade",
    "radiusMinor": "raio menor",
    "radiusMajor": "raio maior",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "remover bordas internas",
    "removeInternalEdges": "remover bordas internas",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Remove faces internas para a forma",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "criar borda a partir de curva geom 2d e superfície",
    "makeEdgeFromGeom2dCurveAndSurface": "criar borda a partir de curva geom 2d e superfície",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Cria uma aresta a partir de curva geom e superfície geom",
    "curve": "curva",
    "surface": "superfície",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "obter borda",
    "getEdge": "obter borda",
    "bitbybit.occt.shapes.edge.getEdge_description": "Obtém a aresta fornecendo um índice da forma",
    "index": "índice",
    "bitbybit.occt.shapes.edge.getEdges": "obter bordas",
    "getEdges": "obter bordas",
    "bitbybit.occt.shapes.edge.getEdges_description": "Obtém as arestas de uma forma em uma lista",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "obter bordas ao longo do fio",
    "getEdgesAlongWire": "obter bordas ao longo do fio",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Obtém as arestas de um fio ordenadas ao longo da direção do fio",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "obter bordas circulares ao longo do fio",
    "getCircularEdgesAlongWire": "obter bordas circulares ao longo do fio",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Obtém arestas circulares de um fio ordenadas ao longo da direção do fio",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "obter bordas lineares ao longo do fio",
    "getLinearEdgesAlongWire": "obter bordas lineares ao longo do fio",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Obtém arestas lineares de um fio ordenadas ao longo da direção do fio",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "obter pontos de canto das bordas da forma",
    "getCornerPointsOfEdgesForShape": "obter pontos de canto das bordas da forma",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Obtém pontos de canto das arestas para uma forma. Não há garantia de ordem aqui. Todas as duplicatas são removidas, então quando três arestas formam um canto, isso será representado por um único ponto na lista.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "obter comprimento da borda",
    "getEdgeLength": "obter comprimento da borda",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Obtém o comprimento da aresta",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "obter comprimentos das bordas da forma",
    "getEdgeLengthsOfShape": "obter comprimentos das bordas da forma",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Obtém os comprimentos de aresta da forma",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "obter comprimentos das bordas",
    "getEdgesLengths": "obter comprimentos das bordas",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Obtém os comprimentos das arestas",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "obter centro de massa da borda",
    "getEdgeCenterOfMass": "obter centro de massa da borda",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Obtém o centro de massa para a aresta",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "obter centros de massa das bordas",
    "getEdgesCentersOfMass": "obter centros de massa das bordas",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Obtém os centros de massa para as arestas",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "obter ponto central da borda circular",
    "getCircularEdgeCenterPoint": "obter ponto central da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Obtém o ponto central da aresta circular. Se aresta não for circular, ponto não será retornado.",
    "get circular edge": "obter borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "obter raio da borda circular",
    "getCircularEdgeRadius": "obter raio da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Obtém o raio da aresta circular. Se aresta não for circular, raio não será retornado.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "obter direção do plano da borda circular",
    "getCircularEdgePlaneDirection": "obter direção do plano da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Obtém o vetor de direção do plano da aresta circular. Se aresta não for circular, vetor de direção não será retornado.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "ponto na borda no parâmetro",
    "pointOnEdgeAtParam": "ponto na borda no parâmetro",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Obtém o ponto na aresta em param",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "pontos nas bordas no parâmetro",
    "pointsOnEdgesAtParam": "pontos nas bordas no parâmetro",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Obtém os pontos nas arestas em param",
    "bitbybit.occt.shapes.edge.edgesToPoints": "bordas para pontos",
    "edgesToPoints": "bordas para pontos",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Obtém os pontos de todas as arestas de uma forma em listas separadas para cada aresta",
    "angularDeflection": "deflexão angular",
    "curvatureDeflection": "deflexão de curvatura",
    "minimumOfPoints": "mínimo de pontos",
    "uTolerance": "tolerância u",
    "minimumLength": "comprimento mínimo",
    "bitbybit.occt.shapes.edge.reversedEdge": "borda invertida",
    "reversedEdge": "borda invertida",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Calcula aresta invertida a partir da aresta de entrada",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangente na borda no parâmetro",
    "tangentOnEdgeAtParam": "tangente na borda no parâmetro",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Obtém o vetor tangente na aresta em param",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangentes nas bordas no parâmetro",
    "tangentsOnEdgesAtParam": "tangentes nas bordas no parâmetro",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Obtém os vetores tangentes nas arestas em param",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "ponto na borda no comprimento",
    "pointOnEdgeAtLength": "ponto na borda no comprimento",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Obtém o ponto na aresta em comprimento",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "pontos nas bordas no comprimento",
    "pointsOnEdgesAtLength": "pontos nas bordas no comprimento",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Obtém os pontos nas arestas em comprimento",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangente na borda no comprimento",
    "tangentOnEdgeAtLength": "tangente na borda no comprimento",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Obtém o vetor tangente na aresta em comprimento",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangentes nas bordas no comprimento",
    "tangentsOnEdgesAtLength": "tangentes nas bordas no comprimento",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Obtém os vetores tangentes nas arestas em comprimento",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "ponto inicial na borda",
    "startPointOnEdge": "ponto inicial na borda",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Obtém o ponto inicial na aresta",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "pontos iniciais nas bordas",
    "startPointsOnEdges": "pontos iniciais nas bordas",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Obtém os pontos iniciais nas arestas",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "ponto final na borda",
    "endPointOnEdge": "ponto final na borda",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Obtém o ponto final na aresta",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "pontos finais nas bordas",
    "endPointsOnEdges": "pontos finais nas bordas",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Obtém os pontos finais nas arestas",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "dividir borda por parâmetros em pontos",
    "divideEdgeByParamsToPoints": "dividir borda por parâmetros em pontos",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divide borda por parâmetros em pontos",
    "nrOfDivisions": "número de divisões",
    "removeStartPoint": "remover ponto inicial",
    "removeEndPoint": "remover ponto final",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "dividir bordas por parâmetros em pontos",
    "divideEdgesByParamsToPoints": "dividir bordas por parâmetros em pontos",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divide bordas por parâmetros em pontos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "dividir borda por distância igual em pontos",
    "divideEdgeByEqualDistanceToPoints": "dividir borda por distância igual em pontos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divide borda por comprimento em pontos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "dividir bordas por distância igual em pontos",
    "divideEdgesByEqualDistanceToPoints": "dividir bordas por distância igual em pontos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divide bordas por comprimento em pontos",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "linhas tangentes restritas de dois pontos a círculo",
    "constraintTanLinesFromTwoPtsToCircle": "linhas tangentes restritas de dois pontos a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Cria linhas a partir de dois pontos dados até locais tangentes do círculo",
    "constraint": "restrição",
    "point1": "ponto 1",
    "point2": "ponto 2",
    "positionResult": "resultado da posição",
    "positionResultEnum": "enum de resultado da posição",
    "circleRemainder": "resto do círculo",
    "circleInclusionEnum": "enum de inclusão do círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "linhas tangentes restritas de ponto a círculo",
    "constraintTanLinesFromPtToCircle": "linhas tangentes restritas de ponto a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Cria linhas a partir de um ponto dado até locais tangentes do círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "linhas tangentes restritas em dois círculos",
    "constraintTanLinesOnTwoCircles": "linhas tangentes restritas em dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Cria linhas tangentes entre dois círculos.",
    "circle1": "círculo 1",
    "circle2": "círculo 2",
    "circleRemainders": "restos dos círculos",
    "twoCircleInclusionEnum": "enum de inclusão de dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "círculos tangentes restritos em dois círculos",
    "constraintTanCirclesOnTwoCircles": "círculos tangentes restritos em dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Cria círculos tangentes entre dois círculos.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "círculos tangentes restritos em círculo e ponto",
    "constraintTanCirclesOnCircleAndPnt": "círculos tangentes restritos em círculo e ponto",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Cria círculos tangentes entre um ponto e um círculo.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "borda é linear",
    "isEdgeLinear": "borda é linear",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Verifica se uma aresta é linear",
    "is": "é",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "borda é circular",
    "isEdgeCircular": "borda é circular",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Verifica se uma aresta é circular",
    "bitbybit.occt.shapes.wire.createPolygonWire": "fio poligonal",
    "wire": "fio",
    "createPolygonWire": "fio poligonal",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "cria fio poligonal opencascade",
    "via points": "via pontos",
    "bitbybit.occt.shapes.wire.createPolygons": "polígonos",
    "createPolygons": "polígonos",
    "bitbybit.occt.shapes.wire.createPolygons_description": "cria polígonos opencascade",
    "multiple": "múltiplo",
    "polygons": "polígonos",
    "PolygonDto[]": "array de dto de polígono",
    "returnCompound": "retornar composto",
    "bitbybit.occt.shapes.wire.createLineWire": "fio de linha",
    "createLineWire": "fio de linha",
    "bitbybit.occt.shapes.wire.createLineWire_description": "cria fio de linha opencascade",
    "bitbybit.occt.shapes.wire.createLines": "linhas",
    "createLines": "linhas",
    "bitbybit.occt.shapes.wire.createLines_description": "cria linhas opencascade",
    "LineDto[]": "array de dto de linha",
    "bitbybit.occt.shapes.wire.splitOnPoints": "dividir nos pontos",
    "splitOnPoints": "dividir nos pontos",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Divide um fio em um conjunto de pontos dados",
    "bitbybit.occt.shapes.wire.wiresToPoints": "fios para pontos",
    "wiresToPoints": "fios para pontos",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Transforma fios de forma em pontos ordenados em listas. Isso também remove pontos duplicados entre pontos de início e fim de arestas consecutivas no fio",
    "bitbybit.occt.shapes.wire.createPolylineWire": "fio de polilinha",
    "createPolylineWire": "fio de polilinha",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "cria fio de polilinha opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zigzag entre dois fios",
    "createZigZagBetweenTwoWires": "zigzag entre dois fios",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "cria zigzag entre dois fios",
    "via wires": "via fios",
    "wire1": "fio 1",
    "wire2": "fio 2",
    "nrZigZags": "número de zigzags",
    "inverse": "inverso",
    "divideByEqualDistance": "dividir por distância igual",
    "zigZagsPerEdge": "zigzags por borda",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "fio a partir de dois círculos tangentes",
    "createWireFromTwoCirclesTan": "fio a partir de dois círculos tangentes",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Cria um fio tangente envolvendo dois círculos planares",
    "keepLines": "manter linhas",
    "twoSidesStrictEnum": "enum estrito de dois lados",
    "fourSidesStrictEnum": "enum estrito de quatro lados",
    "bitbybit.occt.shapes.wire.createPolylines": "polilinhas",
    "createPolylines": "polilinhas",
    "bitbybit.occt.shapes.wire.createPolylines_description": "cria fios de polilinha opencascade",
    "polylines": "polilinhas",
    "PolylineDto[]": "array de dto de polilinha",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "cria fio bezier opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "bezier com pesos",
    "createBezierWeights": "bezier com pesos",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "cria fio bezier opencascade com pesos",
    "weights": "pesos",
    "bitbybit.occt.shapes.wire.createBezierWires": "fios bezier",
    "createBezierWires": "fios bezier",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "cria fios bezier opencascade",
    "bezierWires": "fios bezier",
    "BezierDto[]": "array de dto de bezier",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpolar pontos",
    "interpolatePoints": "interpolar pontos",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Cria fio BSpline OpenCascade a partir de pontos. Este método pode ser usado para criar loops (periódicos) bem formados.",
    "periodic": "periódico",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpolar fios",
    "interpolateWires": "interpolar fios",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Cria múltiplos fios interpolados OpenCascade",
    "interpolations": "interpolações",
    "InterpolationDto[]": "array de dto de interpolação",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "cria fio bspline opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "cria fios bspline opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "array de dto de bspline",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combinar bordas e fios em um fio",
    "combineEdgesAndWiresIntoAWire": "combinar bordas e fios em um fio",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Combina arestas e fios OpenCascade em um único fio",
    "build": "construir",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "fio a partir de borda",
    "createWireFromEdge": "fio a partir de borda",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "cria fio a partir de borda",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "adicionar bordas e fios ao fio",
    "addEdgesAndWiresToWire": "adicionar bordas e fios ao fio",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Adiciona arestas e fios OpenCascade em outro fio",
    "U[]": "array de u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "dividir fio por parâmetros em pontos",
    "divideWireByParamsToPoints": "dividir fio por parâmetros em pontos",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Divide fio OpenCascade em pontos seguindo cegamente seu espaço paramétrico",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "dividir fios por parâmetros em pontos",
    "divideWiresByParamsToPoints": "dividir fios por parâmetros em pontos",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Divide fios OpenCascade em pontos seguindo cegamente seu espaço paramétrico",
    "extract from wires": "extrair de fios",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "dividir fio por distância igual em pontos",
    "divideWireByEqualDistanceToPoints": "dividir fio por distância igual em pontos",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Divide fio OpenCascade em pontos de igual distância",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "dividir fios por distância igual em pontos",
    "divideWiresByEqualDistanceToPoints": "dividir fios por distância igual em pontos",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Divide fios OpenCascade em pontos de igual distância",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "ponto no fio no parâmetro",
    "pointOnWireAtParam": "ponto no fio no parâmetro",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Avalia ponto em um fio em valor de parâmetro entre 0 e 1, sendo pontos de início e fim",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "ponto no fio no comprimento",
    "pointOnWireAtLength": "ponto no fio no comprimento",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Avalia ponto em um fio em certo comprimento",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "pontos no fio nos comprimentos",
    "pointsOnWireAtLengths": "pontos no fio nos comprimentos",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Avalia pontos em um fio em certos comprimentos",
    "lengths": "comprimentos",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "pontos no fio em comprimento igual",
    "pointsOnWireAtEqualLength": "pontos no fio em comprimento igual",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Avalia pontos em um fio em comprimento igual",
    "tryNext": "tentar próximo",
    "includeFirst": "incluir primeiro",
    "includeLast": "incluir último",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "pontos no fio em padrão de comprimentos",
    "pointsOnWireAtPatternOfLengths": "pontos no fio em padrão de comprimentos",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Avalia pontos em um fio em padrão de comprimentos",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangente no fio no parâmetro",
    "tangentOnWireAtParam": "tangente no fio no parâmetro",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Avalia vetor tangente em um fio em valor de parâmetro entre 0 e 1, sendo pontos de início e fim",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangente no fio no comprimento",
    "tangentOnWireAtLength": "tangente no fio no comprimento",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Avalia vetor tangente em um fio em certo comprimento",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "derivadas no fio no comprimento",
    "derivativesOnWireAtLength": "derivadas no fio no comprimento",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Calcula 3 vetores derivativos de uma curva em um determinado comprimento",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "derivadas no fio no parâmetro",
    "derivativesOnWireAtParam": "derivadas no fio no parâmetro",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Calcula 3 vetores derivativos de uma curva em parâmetro entre 0 e 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "ponto inicial no fio",
    "startPointOnWire": "ponto inicial no fio",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Calcula o ponto inicial no fio em param 0",
    "bitbybit.occt.shapes.wire.endPointOnWire": "ponto final no fio",
    "endPointOnWire": "ponto final no fio",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Calcula o ponto final no fio em param 1",
    "bitbybit.occt.shapes.wire.createCircleWire": "fio de círculo",
    "createCircleWire": "fio de círculo",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "cria fio de círculo opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "fio de quadrado",
    "createSquareWire": "fio de quadrado",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "cria fio de quadrado opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "fio de estrela",
    "createStarWire": "fio de estrela",
    "bitbybit.occt.shapes.wire.createStarWire_description": "cria fio de estrela opencascade",
    "numRays": "número de raios",
    "outerRadius": "raio externo",
    "innerRadius": "raio interno",
    "offsetOuterEdges": "deslocar bordas externas",
    "half": "metade",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "fio de árvore de natal",
    "createChristmasTreeWire": "fio de árvore de natal",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "cria fio de árvore de natal",
    "innerDist": "distância interna",
    "outerDist": "distância externa",
    "nrSkirts": "número de saias",
    "trunkHeight": "altura do tronco",
    "trunkWidth": "largura do tronco",
    "bitbybit.occt.shapes.wire.createNGonWire": "fio de ngono",
    "createNGonWire": "fio de ngono",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Cria fio n-gon OpenCascade",
    "nrCorners": "número de cantos",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "fio de paralelogramo",
    "createParallelogramWire": "fio de paralelogramo",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Cria fio paralelogramo n",
    "aroundCenter": "ao redor do centro",
    "bitbybit.occt.shapes.wire.createHeartWire": "fio de coração",
    "createHeartWire": "fio de coração",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Cria um fio coração",
    "sizeApprox": "tamanho aproximado",
    "bitbybit.occt.shapes.wire.createRectangleWire": "fio de retângulo",
    "createRectangleWire": "fio de retângulo",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "cria fio de retângulo opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "fio de polígono em L",
    "createLPolygonWire": "fio de polígono em L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "cria fio de polígono em L opencascade",
    "widthFirst": "largura primeiro",
    "lengthFirst": "comprimento primeiro",
    "widthSecond": "largura segundo",
    "lengthSecond": "comprimento segundo",
    "align": "alinhar",
    "directionEnum": "enum de direção",
    "bitbybit.occt.shapes.wire.createEllipseWire": "fio de elipse",
    "createEllipseWire": "fio de elipse",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "cria fio de elipse opencascade",
    "bitbybit.occt.shapes.wire.textWires": "Contornos de texto",
    "textWires": "Contornos de texto",
    "bitbybit.occt.shapes.wire.textWires_description": "Cria contornos de texto OpenCascade baseados na fonte simplex criada pelo Dr. A. V. Hershey.",
    "xOffset": "deslocamento x",
    "yOffset": "deslocamento y",
    "letterSpacing": "espaçamento entre letras",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "deslocamento de extrusão",
    "bitbybit.occt.shapes.wire.getWire": "obter fio",
    "getWire": "obter fio",
    "bitbybit.occt.shapes.wire.getWire_description": "Obtém o fio fornecendo um índice da forma",
    "bitbybit.occt.shapes.wire.getWires": "obter fios",
    "getWires": "obter fios",
    "bitbybit.occt.shapes.wire.getWires_description": "Obtém todos os fios da forma",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "obter centro de massa do fio",
    "getWireCenterOfMass": "obter centro de massa do fio",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Obter o ponto centro de massa do fio",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "obter centros de massa dos fios",
    "getWiresCentersOfMass": "obter centros de massa dos fios",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Obter os pontos centros de massa dos fios",
    "bitbybit.occt.shapes.wire.reversedWire": "fio invertido",
    "reversedWire": "fio invertido",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Calcula fio invertido a partir do fio de entrada",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "fio invertido a partir de bordas invertidas",
    "reversedWireFromReversedEdges": "fio invertido a partir de bordas invertidas",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Calcula fio invertido invertendo todas as arestas e combinando-as em um novo fio",
    "bitbybit.occt.shapes.wire.isWireClosed": "fio está fechado",
    "isWireClosed": "fio está fechado",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Verifica se fio está fechado",
    "bitbybit.occt.shapes.wire.getWireLength": "obter comprimento do fio",
    "getWireLength": "obter comprimento do fio",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Obtém o comprimento do fio",
    "bitbybit.occt.shapes.wire.getWiresLengths": "obter comprimentos dos fios",
    "getWiresLengths": "obter comprimentos dos fios",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Obtém os comprimentos dos fios",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "posicionar fio na face",
    "placeWireOnFace": "posicionar fio na face",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Coloca um fio na face mapeando suas coordenadas 2d para espaço UV. O fio deve estar posicionado no plano XZ do chão para isso funcionar.",
    "face": "face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "posicionar fios na face",
    "placeWiresOnFace": "posicionar fios na face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Coloca múltiplos fios na face mapeando suas coordenadas 2d para espaço UV. Fios devem estar posicionados no plano XZ do chão para isso funcionar.",
    "wires": "fios",
    "bitbybit.occt.shapes.wire.closeOpenWire": "fechar fio aberto",
    "closeOpenWire": "fechar fio aberto",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Fecha o fio aberto com aresta reta adicional unindo pontos de início e fim",
    "bitbybit.occt.shapes.wire.project": "projetar",
    "project": "projetar",
    "bitbybit.occt.shapes.wire.project_description": "Projetar fio na forma",
    "bitbybit.occt.shapes.wire.projectWires": "projetar fios",
    "projectWires": "projetar fios",
    "bitbybit.occt.shapes.wire.projectWires_description": "Projetar múltiplos fios na forma",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "faces a partir de fios na face",
    "createFacesFromWiresOnFace": "faces a partir de fios na face",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Cria faces a partir de fios na face",
    "inside": "dentro",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "face a partir de fio na face",
    "createFaceFromWireOnFace": "face a partir de fio na face",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Cria uma face a partir de fio na face",
    "bitbybit.occt.shapes.face.createFaceFromWire": "face a partir de fio",
    "createFaceFromWire": "face a partir de fio",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Cria uma face a partir de fio",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "face a partir de fios",
    "createFaceFromWires": "face a partir de fios",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Cria uma face a partir de fios. Isso pode produzir faces ocas.",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "face a partir de fios na face",
    "createFaceFromWiresOnFace": "face a partir de fios na face",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Cria uma face a partir de fios na face guia. Isso pode produzir faces ocas.",
    "bitbybit.occt.shapes.face.createFacesFromWires": "faces a partir de fios",
    "createFacesFromWires": "faces a partir de fios",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "cria faces a partir de fios",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "face a partir de múltiplos fios tangentes de círculo",
    "createFaceFromMultipleCircleTanWires": "face a partir de múltiplos fios tangentes de círculo",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "cria face a partir de múltiplos fios tangentes de círculo",
    "circles": "círculos",
    "combination": "combinação",
    "combinationCirclesForFaceEnum": "enum de combinação de círculos para face",
    "unify": "unificar",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "face a partir de coleções de fios tangentes de círculo",
    "createFaceFromMultipleCircleTanWireCollections": "face a partir de coleções de fios tangentes de círculo",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "cria face a partir de múltiplas coleções de fios tangentes de círculo",
    "listsOfCircles": "listas de círculos",
    "T[][]": "array de array de t",
    "bitbybit.occt.shapes.face.faceFromSurface": "face a partir de superfície",
    "faceFromSurface": "face a partir de superfície",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Cria uma face a partir da superfície",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "face a partir de superfície e fio",
    "faceFromSurfaceAndWire": "face a partir de superfície e fio",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Cria uma face a partir da superfície e um fio",
    "bitbybit.occt.shapes.face.createPolygonFace": "face poligonal",
    "createPolygonFace": "face poligonal",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "cria face poligonal opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "face de círculo",
    "createCircleFace": "face de círculo",
    "bitbybit.occt.shapes.face.createCircleFace_description": "cria face de círculo opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "face de elipse",
    "createEllipseFace": "face de elipse",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "cria face de elipse opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "face de quadrado",
    "createSquareFace": "face de quadrado",
    "bitbybit.occt.shapes.face.createSquareFace_description": "cria face de quadrado opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "face de retângulo",
    "createRectangleFace": "face de retângulo",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "cria face de retângulo opencascade",
    "bitbybit.occt.shapes.face.getFace": "obter face",
    "getFace": "obter face",
    "bitbybit.occt.shapes.face.getFace_description": "Obtém a face fornecendo um índice da forma",
    "bitbybit.occt.shapes.face.getFaces": "obter faces",
    "getFaces": "obter faces",
    "bitbybit.occt.shapes.face.getFaces_description": "Obtém as faces da forma em uma lista",
    "bitbybit.occt.shapes.face.reversedFace": "face invertida",
    "reversedFace": "face invertida",
    "bitbybit.occt.shapes.face.reversedFace_description": "Calcula face invertida a partir da face de entrada",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdividir em pontos",
    "subdivideToPoints": "subdividir em pontos",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Subdivide uma face em grade de pontos",
    "nrDivisionsU": "número de divisões u",
    "nrDivisionsV": "número de divisões v",
    "shiftHalfStepU": "deslocar meio passo u",
    "removeStartEdgeU": "remover borda inicial u",
    "removeEndEdgeU": "remover borda final u",
    "shiftHalfStepV": "deslocar meio passo v",
    "removeStartEdgeV": "remover borda inicial v",
    "removeEndEdgeV": "remover borda final v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdividir em fios",
    "subdivideToWires": "subdividir em fios",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Subdivide uma face em fios",
    "nrDivisions": "número de divisões",
    "isU": "é u",
    "shiftHalfStep": "deslocar meio passo",
    "removeStart": "remover início",
    "removeEnd": "remover fim",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdividir em fios retangulares",
    "subdivideToRectangleWires": "subdividir em fios retangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Subdivide uma face em fios retangulares",
    "patterns": "padrões",
    "nrRectanglesU": "número de retângulos u",
    "nrRectanglesV": "número de retângulos v",
    "scalePatternU": "escala do padrão u",
    "scalePatternV": "escala do padrão v",
    "filletPattern": "padrão de arredondamento",
    "inclusionPattern": "padrão de inclusão",
    "offsetFromBorderU": "deslocamento da borda u",
    "offsetFromBorderV": "deslocamento da borda v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdividir em buracos retangulares",
    "subdivideToRectangleHoles": "subdividir em buracos retangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Subdivide uma face em fios retangulares",
    "holesToFaces": "buracos para faces",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdividir em pontos controlados",
    "subdivideToPointsControlled": "subdividir em pontos controlados",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Subdivide uma face em grade de pontos com deslocamentos e remoções em enésimas linhas ou colunas uv",
    "shiftHalfStepNthU": "deslocar meio passo nth u",
    "shiftHalfStepUOffsetN": "deslocar meio passo u offset n",
    "removeStartEdgeNthU": "remover borda inicial nth u",
    "removeStartEdgeUOffsetN": "remover borda inicial u offset n",
    "removeEndEdgeNthU": "remover borda final nth u",
    "removeEndEdgeUOffsetN": "remover borda final u offset n",
    "shiftHalfStepNthV": "deslocar meio passo nth v",
    "shiftHalfStepVOffsetN": "deslocar meio passo v offset n",
    "removeStartEdgeNthV": "remover borda inicial nth v",
    "removeStartEdgeVOffsetN": "remover borda inicial v offset n",
    "removeEndEdgeNthV": "remover borda final nth v",
    "removeEndEdgeVOffsetN": "remover borda final v offset n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdividir em normais",
    "subdivideToNormals": "subdividir em normais",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Subdivide uma face em grade de normais",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdividir em uv",
    "subdivideToUV": "subdividir em uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Subdivide uma face em grade uv",
    "bitbybit.occt.shapes.face.pointOnUV": "ponto no uv",
    "pointOnUV": "ponto no uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Obter ponto em UV onde U e V são descritos entre 0 e 1. Estes serão mapeados para limites reais.",
    "paramU": "parâmetro u",
    "paramV": "parâmetro v",
    "bitbybit.occt.shapes.face.normalOnUV": "normal no uv",
    "normalOnUV": "normal no uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Obter normal em UV onde U e V são descritos entre 0 e 1. Estes serão mapeados para limites reais.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "pontos nos uvs",
    "pointsOnUVs": "pontos nos uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Obter pontos em UVs onde U e V são descritos entre 0 e 1 em arrays bidimensionais. Estes serão mapeados para limites reais.",
    "paramsUV": "parâmetros uv",
    "[number, number][]": "array de pares de números",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normais nos uvs",
    "normalsOnUVs": "normais nos uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Obter normais em UVs onde U e V são descritos entre 0 e 1 em arrays bidimensionais. Estes serão mapeados para limites reais.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdividir em pontos no parâmetro",
    "subdivideToPointsOnParam": "subdividir em pontos no parâmetro",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Subdivide uma face em pontos ao longo de uma linha no parâmetro",
    "nrPoints": "número de pontos",
    "bitbybit.occt.shapes.face.wireAlongParam": "fio ao longo do parâmetro",
    "wireAlongParam": "fio ao longo do parâmetro",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Obtém o fio ao longo do parâmetro na face",
    "bitbybit.occt.shapes.face.wiresAlongParams": "fios ao longo dos parâmetros",
    "wiresAlongParams": "fios ao longo dos parâmetros",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Obtém os fios ao longo dos parâmetros na face",
    "params": "parâmetros",
    "bitbybit.occt.shapes.face.getUMinBound": "obter limite mínimo u",
    "getUMinBound": "obter limite mínimo u",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Obtém o limite U min da face",
    "bitbybit.occt.shapes.face.getUMaxBound": "obter limite máximo u",
    "getUMaxBound": "obter limite máximo u",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Obtém o limite U max da face",
    "bitbybit.occt.shapes.face.getVMinBound": "obter limite mínimo v",
    "getVMinBound": "obter limite mínimo v",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Obtém o limite V min da face",
    "bitbybit.occt.shapes.face.getVMaxBound": "obter limite máximo v",
    "getVMaxBound": "obter limite máximo v",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Obtém o limite V max da face",
    "bitbybit.occt.shapes.face.getFaceArea": "obter área da face",
    "getFaceArea": "obater área da face",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Obter a área da face",
    "bitbybit.occt.shapes.face.getFacesAreas": "obter áreas das faces",
    "getFacesAreas": "obter áreas das faces",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Obter as áreas das faces",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "obter centro de massa da face",
    "getFaceCenterOfMass": "obter centro de massa da face",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Obter o ponto centro de massa da face",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "obter centros de massa das faces",
    "getFacesCentersOfMass": "obter centros de massa das faces",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Obter os pontos centros de massa para faces",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtrar pontos da face",
    "filterFacePoints": "filtrar pontos da face",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtra pontos na face",
    "filter": "filtrar",
    "useBndBox": "usar caixa delimitadora",
    "gapTolerance": "tolerância de lacuna",
    "keepIn": "manter dentro",
    "keepOn": "manter sobre",
    "keepOut": "manter fora",
    "keepUnknown": "manter desconhecido",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtrar pontos das faces",
    "filterFacesPoints": "filtrar pontos das faces",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtra pontos nas faces",
    "flatPointsArray": "array plano de pontos",
    "bitbybit.occt.shapes.shell.sewFaces": "costurar faces",
    "shell": "casca",
    "sewFaces": "costurar faces",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Cria uma casca a partir de faces",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "obter área de superfície da casca",
    "getShellSurfaceArea": "obter área de superfície da casca",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Obter área de superfície da casca",
    "bitbybit.occt.shapes.solid.fromClosedShell": "a partir de casca fechada",
    "solid": "sólido",
    "fromClosedShell": "a partir de casca fechada",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Cria Sólido A partir de casca que deve ser fechada",
    "bitbybit.occt.shapes.solid.createBox": "caixa",
    "bitbybit.occt.shapes.solid.createBox_description": "cria caixa opencascade",
    "originOnCenter": "origem no centro",
    "bitbybit.occt.shapes.solid.createCube": "cubo",
    "bitbybit.occt.shapes.solid.createCube_description": "cria cubo opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "caixa a partir de canto",
    "createBoxFromCorner": "caixa a partir de canto",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "cria caixa opencascade a partir de canto",
    "corner": "canto",
    "bitbybit.occt.shapes.solid.createCylinder": "cilindro",
    "bitbybit.occt.shapes.solid.createCylinder_description": "cria cilindro opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cilindros em linhas",
    "createCylindersOnLines": "cilindros em linhas",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Cria Cilindros OpenCascade em linhas simples bit by bit representadas por dois pontos",
    "Base.Line3[]": "array de linha base 3",
    "bitbybit.occt.shapes.solid.createSphere": "esfera",
    "bitbybit.occt.shapes.solid.createSphere_description": "cria esfera opencascade",
    "bitbybit.occt.shapes.solid.createCone": "cone",
    "createCone": "cone",
    "bitbybit.occt.shapes.solid.createCone_description": "cria cone opencascade",
    "radius1": "raio 1",
    "radius2": "raio 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "obter área de superfície do sólido",
    "getSolidSurfaceArea": "obter área de superfície do sólido",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Obter área de superfície do sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume": "obter volume do sólido",
    "getSolidVolume": "obter volume do sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Obter volume do sólido",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "obter volumes dos sólidos",
    "getSolidsVolumes": "obter volumes dos sólidos",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Obter volumes dos sólidos",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "obter centro de massa do sólido",
    "getSolidCenterOfMass": "obter centro de massa do sólido",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Obter centro de massa do sólido",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "obter centros de massa dos sólidos",
    "getSolidsCentersOfMass": "obter centros de massa dos sólidos",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Obter centros de massa dos sólidos",
    "bitbybit.occt.shapes.solid.getSolids": "obter sólidos",
    "getSolids": "obter sólidos",
    "bitbybit.occt.shapes.solid.getSolids_description": "Obtém os sólidos da forma em uma lista",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtrar pontos do sólido",
    "filterSolidPoints": "filtrar pontos do sólido",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Filtra coleção de pontos baseado em relação com o sólido. Você pode escolher se deve emitir pontos dentro, em ou fora.",
    "bitbybit.occt.shapes.compound.makeCompound": "criar composto",
    "compound": "composto",
    "makeCompound": "criar composto",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Faz a forma composta, que pode incluir qualquer tipo de formas",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "obter formas do composto",
    "getShapesOfCompound": "obter formas do composto",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Obtém as formas de que o composto é feito",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "remover bordas internas",
    "purgeInternalEdges": "remover bordas internas",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Remover arestas internas que não estão conectadas a nenhuma face na forma",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unificar mesmo domínio",
    "unifySameDomain": "unificar mesmo domínio",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Unifica faces, arestas no mesmo domínio e tem possibilidade de concatenar bsplines",
    "unifyEdges": "unificar bordas",
    "unifyFaces": "unificar faces",
    "concatBSplines": "concatenar bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "está fechado",
    "bitbybit.occt.shapes.shape.isClosed_description": "Verificar se a forma está fechada",
    "analysis": "análise",
    "bitbybit.occt.shapes.shape.isConvex": "é convexo",
    "isConvex": "é convexo",
    "bitbybit.occt.shapes.shape.isConvex_description": "Verificar se a forma é convexa",
    "bitbybit.occt.shapes.shape.isChecked": "está verificado",
    "bitbybit.occt.shapes.shape.isChecked_description": "Verificar se a forma está verificada",
    "bitbybit.occt.shapes.shape.isFree": "é livre",
    "isFree": "é livre",
    "bitbybit.occt.shapes.shape.isFree_description": "Verificar se a forma é livre",
    "bitbybit.occt.shapes.shape.isInfinite": "é infinito",
    "isInfinite": "é infinito",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Verificar se a forma é infinita",
    "bitbybit.occt.shapes.shape.isModified": "está modificado",
    "isModified": "está modificado",
    "bitbybit.occt.shapes.shape.isModified_description": "Verificar se a forma está modificada",
    "bitbybit.occt.shapes.shape.isLocked": "está bloqueado",
    "isLocked": "está bloqueado",
    "bitbybit.occt.shapes.shape.isLocked_description": "Verificar se a forma está bloqueada",
    "bitbybit.occt.shapes.shape.isNull": "é nulo",
    "isNull": "é nulo",
    "bitbybit.occt.shapes.shape.isNull_description": "Verificar se a forma é nula",
    "bitbybit.occt.shapes.shape.isEqual": "é igual",
    "isEqual": "é igual",
    "bitbybit.occt.shapes.shape.isEqual_description": "Verificar se a forma é igual a outra forma",
    "otherShape": "outra forma",
    "bitbybit.occt.shapes.shape.isNotEqual": "não é igual",
    "isNotEqual": "não é igual",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Verificar se a forma não é igual a outra forma",
    "bitbybit.occt.shapes.shape.isPartner": "é parceiro",
    "isPartner": "é parceiro",
    "bitbybit.occt.shapes.shape.isPartner_description": "Verificar se a forma é parceira de outra forma",
    "bitbybit.occt.shapes.shape.isSame": "é o mesmo",
    "isSame": "é o mesmo",
    "bitbybit.occt.shapes.shape.isSame_description": "Verificar se a forma é a mesma que a outra forma",
    "bitbybit.occt.shapes.shape.getOrientation": "obter orientação",
    "getOrientation": "obter orientação",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Obter a orientação da forma",
    "bitbybit.occt.shapes.shape.getShapeType": "obter tipo de forma",
    "getShapeType": "obter tipo de forma",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Obter o tipo de forma",
    "bitbybit.occt.geom.curves.geom2dEllipse": "elipse geom 2d",
    "geom": "geom",
    "curves": "curvas",
    "geom2dEllipse": "elipse geom 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Cria uma elipse 2d. Certifique-se de usar esta geometria apenas para propósitos construtivos de modelagem, mas não para representação. Você precisa transformar estas curvas em arestas para desenhá-las.",
    "Base.Point2": "ponto base 2",
    "Base.Vector2": "vetor base 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "curva aparada geom 2d",
    "geom2dTrimmedCurve": "curva aparada geom 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Cria uma curva cortada a partir da curva base limitada entre U1 e U2. Esta curva não pode ser desenhada.",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "ajustar periódico",
    "bitbybit.occt.geom.curves.geom2dSegment": "segmento geom 2d",
    "geom2dSegment": "segmento geom 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Cria um segmento de curva 2d cortado entre dois pontos 2d. Esta curva não pode ser desenhada.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "obter ponto 2d de curva 2d no parâmetro",
    "get2dPointFrom2dCurveOnParam": "obter ponto 2d de curva 2d no parâmetro",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Obtém ponto 2d representado por [número, número] em uma curva no parâmetro.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "curva de círculo geom",
    "geomCircleCurve": "curva de círculo geom",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Cria uma curva geom de círculo",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "curva de elipse geom",
    "geomEllipseCurve": "curva de elipse geom",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Cria uma curva geom de elipse",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "superfície cilíndrica",
    "surfaces": "superfícies",
    "cylindricalSurface": "superfície cilíndrica",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Cria uma superfície cilíndrica infinita que não pode ser desenhada. Certifique-se de usar esta geometria apenas para propósitos construtivos de modelagem, mas não para representação.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "superfície a partir de face",
    "surfaceFromFace": "superfície a partir de face",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Cria uma superfície a partir da face",
    "bitbybit.occt.fillets.filletEdges": "arredondar bordas",
    "fillets": "arredondamentos",
    "filletEdges": "arredondar bordas",
    "bitbybit.occt.fillets.filletEdges_description": "arredonda formas opencascade",
    "3d fillets": "arredondamentos 3d",
    "radiusList": "lista de raios",
    "indexes": "índices",
    "bitbybit.occt.fillets.filletEdgesList": "lista de bordas arredondadas",
    "filletEdgesList": "lista de bordas arredondadas",
    "bitbybit.occt.fillets.filletEdgesList_description": "Arredonda lista de arestas com raio diferente em cada aresta.",
    "edges": "bordas",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "lista de bordas arredondadas com um raio",
    "filletEdgesListOneRadius": "lista de bordas arredondadas com um raio",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Arredonda lista de arestas com o raio único em todas as arestas.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "arredondar borda com raio variável",
    "filletEdgeVariableRadius": "arredondar borda com raio variável",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Arredonda uma única aresta com lista de raio variável em params u dados. Você precisa fornecer uma lista de params para identificar em qual param U aplicar o raio.",
    "paramsU": "parâmetros u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "arredondar bordas com mesmo raio variável",
    "filletEdgesSameVariableRadius": "arredondar bordas com mesmo raio variável",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Arredonda múltiplas arestas fornecidas com os mesmos raios variáveis em params u para cada aresta.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "arredondar bordas com raio variável",
    "filletEdgesVariableRadius": "arredondar bordas com raio variável",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Arredonda múltiplas arestas fornecidas com listas de raio variável em listas de params dadas. Você precisa fornecer uma lista de params para identificar em qual param U aplicar o raio.",
    "radiusLists": "listas de raios",
    "paramsULists": "listas de parâmetros u",
    "bitbybit.occt.fillets.fillet3DWire": "arredondar fio 3d",
    "fillet3DWire": "arredondar fio 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "Arredonda fio 3d OpenCascade, este algoritmo toma uma direção guia para os filetes serem formados. Não respeita direções tangentes em cada canto arredondado. Este algoritmo é baseado na extrusão de fio ao longo da direção dada para formar uma casca, então arredondar a casca e finalmente extrair o fio arredondado da própria casca. Certifique-se de fornecer uma direção que não seja paralela ao fio e que forme extrusão alta o suficiente para o arredondamento ter sucesso.",
    "bitbybit.occt.fillets.fillet3DWires": "arredondar fios 3d",
    "fillet3DWires": "arredondar fios 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "Arredonda fios 3d OpenCascade, este algoritmo toma uma direção guia para os filetes serem formados. Não respeita direções tangentes em cada canto arredondado. Este algoritmo é baseado na extrusão de fios ao longo da direção dada para formar uma casca, então arredondar a casca e finalmente extrair o fio arredondado da própria casca. Certifique-se de fornecer uma direção que não seja paralela ao fio e que forme extrusão alta o suficiente para o arredondamento ter sucesso.",
    "bitbybit.occt.fillets.chamferEdges": "chanfrar bordas",
    "chamferEdges": "chanfrar bordas",
    "bitbybit.occt.fillets.chamferEdges_description": "Chanfrar arestas de Forma OpenCascade",
    "3d chamfers": "chanfros 3d",
    "distanceList": "lista de distâncias",
    "bitbybit.occt.fillets.chamferEdgesList": "lista de bordas chanfradas",
    "chamferEdgesList": "lista de bordas chanfradas",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Chanfra lista de arestas com distância diferente em cada aresta.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "chanfrar borda com duas distâncias",
    "chamferEdgeTwoDistances": "chanfrar borda com duas distâncias",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Chanfra aresta por duas distâncias. Face indica a primeira distância a ser aplicada",
    "F": "f",
    "distance1": "distância 1",
    "distance2": "distância 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "chanfrar bordas com duas distâncias",
    "chamferEdgesTwoDistances": "chanfrar bordas com duas distâncias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Chanfra arestas por duas distâncias. Face indica a primeira distância a ser aplicada",
    "faces": "faces",
    "F[]": "array de f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "chanfrar bordas com listas de duas distâncias",
    "chamferEdgesTwoDistancesLists": "chanfrar bordas com listas de duas distâncias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Chanfra arestas por duas distâncias. Face indica a primeira distância a ser aplicada",
    "distances1": "distâncias 1",
    "distances2": "distâncias 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "chanfrar borda com distância e ângulo",
    "chamferEdgeDistAngle": "chanfrar borda com distância e ângulo",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Chanfra aresta por uma distância e ângulo dados a partir da face",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "chanfrar bordas com distância e ângulo",
    "chamferEdgesDistAngle": "chanfrar bordas com distância e ângulo",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Chanfra múltiplas arestas por uma distância e ângulo dados a partir das faces",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "chanfrar bordas com distâncias e ângulos",
    "chamferEdgesDistsAngles": "chanfrar bordas com distâncias e ângulos",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Chanfra arestas por distâncias e ângulos dados a partir das faces",
    "distances": "distâncias",
    "bitbybit.occt.fillets.fillet2d": "arredondar 2d",
    "fillet2d": "arredondar 2d",
    "bitbybit.occt.fillets.fillet2d_description": "arredonda fio ou face 2d",
    "2d fillets": "arredondamentos 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "arredondar formas 2d",
    "fillet2dShapes": "arredondar formas 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "arredonda fios ou faces 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "arredondar duas bordas no plano em um fio",
    "filletTwoEdgesInPlaneIntoAWire": "arredondar duas bordas no plano em um fio",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Arredonda duas arestas planares em um fio fornecendo um raio, plano, arestas e possível índice de solução se mais de um resultado existir",
    "edge1": "borda 1",
    "edge2": "borda 2",
    "planeOrigin": "origem do plano",
    "planeDirection": "direção do plano",
    "solution": "solução",
    "bitbybit.occt.transforms.transform": "transformar",
    "bitbybit.occt.transforms.transform_description": "Transforma a forma",
    "on single shape": "em uma única forma",
    "rotationAxis": "eixo de rotação",
    "rotationAngle": "ângulo de rotação",
    "scaleFactor": "fator de escala",
    "bitbybit.occt.transforms.rotate": "rotacionar",
    "bitbybit.occt.transforms.rotate_description": "Rotaciona a forma",
    "bitbybit.occt.transforms.rotateAroundCenter": "rotacionar ao redor do centro",
    "rotateAroundCenter": "rotacionar ao redor do centro",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Rotaciona a forma ao redor do centro fornecido",
    "bitbybit.occt.transforms.align": "alinhar",
    "bitbybit.occt.transforms.align_description": "Alinha a forma",
    "fromOrigin": "da origem",
    "fromDirection": "da direção",
    "toOrigin": "para a origem",
    "toDirection": "para a direção",
    "bitbybit.occt.transforms.alignAndTranslate": "alinhar e transladar",
    "alignAndTranslate": "alinhar e transladar",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Alinha e translada a forma",
    "bitbybit.occt.transforms.translate": "transladar",
    "bitbybit.occt.transforms.translate_description": "Translada a forma",
    "bitbybit.occt.transforms.scale": "escalar",
    "bitbybit.occt.transforms.scale_description": "Escala a forma",
    "bitbybit.occt.transforms.scale3d": "escalar 3d",
    "scale3d": "escalar 3d",
    "bitbybit.occt.transforms.scale3d_description": "Escala a forma em 3D",
    "bitbybit.occt.transforms.mirror": "espelhar",
    "mirror": "espelhar",
    "bitbybit.occt.transforms.mirror_description": "Espelha a forma",
    "bitbybit.occt.transforms.mirrorAlongNormal": "espelhar ao longo da normal",
    "mirrorAlongNormal": "espelhar ao longo da normal",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Espelha a forma ao longo da normal e origem",
    "normal": "normal",
    "bitbybit.occt.transforms.transformShapes": "transformar formas",
    "transformShapes": "transformar formas",
    "bitbybit.occt.transforms.transformShapes_description": "Transforma o array de formas com transformações",
    "on shapes": "em formas",
    "rotationAxes": "eixos de rotação",
    "rotationAngles": "ângulos de rotação",
    "scaleFactors": "fatores de escala",
    "bitbybit.occt.transforms.rotateShapes": "rotacionar formas",
    "rotateShapes": "rotacionar formas",
    "bitbybit.occt.transforms.rotateShapes_description": "Rotaciona as formas com rotações",
    "axes": "eixos",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "rotacionar formas ao redor do centro",
    "rotateAroundCenterShapes": "rotacionar formas ao redor do centro",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Rotaciona as formas ao redor do centro e um eixo",
    "centers": "centros",
    "bitbybit.occt.transforms.alignShapes": "alinhar formas",
    "alignShapes": "alinhar formas",
    "bitbybit.occt.transforms.alignShapes_description": "Alinha as formas com alinhamentos",
    "fromOrigins": "das origens",
    "fromDirections": "das direções",
    "toOrigins": "para as origens",
    "toDirections": "para as direções",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "alinhar e transladar formas",
    "alignAndTranslateShapes": "alinhar e transladar formas",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Alinha e translada as formas",
    "directions": "direções",
    "bitbybit.occt.transforms.translateShapes": "transladar formas",
    "translateShapes": "transladar formas",
    "bitbybit.occt.transforms.translateShapes_description": "Translada as formas com translações",
    "bitbybit.occt.transforms.scaleShapes": "escalar formas",
    "scaleShapes": "escalar formas",
    "bitbybit.occt.transforms.scaleShapes_description": "Escala as formas com fatores de escala",
    "factors": "fatores",
    "bitbybit.occt.transforms.scale3dShapes": "escalar formas 3d",
    "scale3dShapes": "escalar formas 3d",
    "bitbybit.occt.transforms.scale3dShapes_description": "Escala a forma em 3D",
    "scales": "escalas",
    "bitbybit.occt.transforms.mirrorShapes": "espelhar formas",
    "mirrorShapes": "espelhar formas",
    "bitbybit.occt.transforms.mirrorShapes_description": "Espelha as formas com múltiplos espelhos",
    "origins": "origens",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "espelhar formas ao longo da normal",
    "mirrorAlongNormalShapes": "espelhar formas ao longo da normal",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Espelha as formas ao longo da normal e origem",
    "normals": "normais",
    "bitbybit.occt.operations.loft": "loft",
    "operations": "operações",
    "loft": "loft",
    "bitbybit.occt.operations.loft_description": "Faz loft de fios em uma casca",
    "lofts": "lofts",
    "makeSolid": "criar sólido",
    "bitbybit.occt.operations.loftAdvanced": "loft avançado",
    "loftAdvanced": "loft avançado",
    "bitbybit.occt.operations.loftAdvanced_description": "Faz loft de fios em uma casca usando muitas opções avançadas",
    "straight": "reto",
    "nrPeriodicSections": "número de seções periódicas",
    "useSmoothing": "usar suavização",
    "maxUDegree": "grau máximo u",
    "parType": "tipo de parâmetro",
    "approxParametrizationTypeEnum": "enum de tipo de parametrização aproximada",
    "startVertex": "vértice inicial",
    "endVertex": "vértice final",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "pontos mais próximos entre duas formas",
    "closestPointsBetweenTwoShapes": "pontos mais próximos entre duas formas",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Calcula dois pontos mais próximos entre duas formas",
    "closest pts": "pontos mais próximos",
    "shape1": "forma 1",
    "shape2": "forma 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "pontos mais próximos na forma a partir de pontos",
    "closestPointsOnShapeFromPoints": "pontos mais próximos na forma a partir de pontos",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Calcula pontos mais próximos entre uma lista de pontos e uma forma dada",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "pontos mais próximos nas formas a partir de pontos",
    "closestPointsOnShapesFromPoints": "pontos mais próximos nas formas a partir de pontos",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Calcula pontos mais próximos entre uma lista de pontos e formas",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distâncias até a forma a partir de pontos",
    "distancesToShapeFromPoints": "distâncias até a forma a partir de pontos",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Calcula distâncias entre uma lista de pontos e pontos mais próximos correspondentes em formas.",
    "bitbybit.occt.operations.boundingBoxOfShape": "caixa delimitadora da forma",
    "boundingBoxOfShape": "caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "computa os parâmetros da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "mínimo da caixa delimitadora da forma",
    "boundingBoxMinOfShape": "mínimo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "obtém o ponto mínimo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "máximo da caixa delimitadora da forma",
    "boundingBoxMaxOfShape": "máximo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "obtém o ponto máximo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "centro da caixa delimitadora da forma",
    "boundingBoxCenterOfShape": "centro da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "obtém o ponto central da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "tamanho da caixa delimitadora da forma",
    "boundingBoxSizeOfShape": "tamanho da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "obtém o tamanho da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "forma da caixa delimitadora da forma",
    "boundingBoxShapeOfShape": "forma da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "obtém a forma da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereOfShape": "esfera delimitadora da forma",
    "boundingSphereOfShape": "esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "computa os parâmetros da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "centro da esfera delimitadora da forma",
    "boundingSphereCenterOfShape": "centro da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "obtém o ponto central da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "raio da esfera delimitadora da forma",
    "boundingSphereRadiusOfShape": "raio da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "obtém o raio da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "forma da esfera delimitadora da forma",
    "boundingSphereShapeOfShape": "forma da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "obtém a forma da esfera delimitadora da forma",
    "bitbybit.occt.operations.extrude": "extrusão",
    "extrude": "extrusão",
    "bitbybit.occt.operations.extrude_description": "Extruda a forma ao longo da direção - fio produzirá casca, face produzirá sólido",
    "extrusions": "extrusões",
    "bitbybit.occt.operations.extrudeShapes": "extrudar formas",
    "extrudeShapes": "extrudar formas",
    "bitbybit.occt.operations.extrudeShapes_description": "Extruda as formas ao longo da direção",
    "bitbybit.occt.operations.splitShapeWithShapes": "dividir forma com formas",
    "splitShapeWithShapes": "dividir forma com formas",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Divide a forma com formas",
    "divisions": "divisões",
    "localFuzzyTolerance": "tolerância fuzzy local",
    "nonDestructive": "não destrutivo",
    "bitbybit.occt.operations.revolve": "revolver",
    "revolve": "revolver",
    "bitbybit.occt.operations.revolve_description": "Revolve a forma ao redor da direção dada",
    "revolutions": "revoluções",
    "copy": "copiar",
    "bitbybit.occt.operations.rotatedExtrude": "extrusão rotacionada",
    "rotatedExtrude": "extrusão rotacionada",
    "bitbybit.occt.operations.rotatedExtrude_description": "Extrusão rotacionada que é realizada na forma",
    "bitbybit.occt.operations.pipe": "tubo",
    "pipe": "tubo",
    "bitbybit.occt.operations.pipe_description": "Tubulação de formas ao longo do fio",
    "pipeing": "tubagem",
    "bitbybit.occt.operations.pipePolylineWireNGon": "tubo de fio polilinha ngono",
    "pipePolylineWireNGon": "tubo de fio polilinha ngono",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Tubulação de fio polilinha com perfil ngon.",
    "trihedronEnum": "enum de triedro",
    "geomFillTrihedronEnum": "enum de preenchimento geométrico de triedro",
    "forceApproxC1": "forçar aproximação c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "tuba fios cilíndricos",
    "pipeWiresCylindrical": "tuba fios cilíndricos",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Tubulação de fios com forma cilíndrica",
    "bitbybit.occt.operations.pipeWireCylindrical": "tuba fio cilíndrico",
    "pipeWireCylindrical": "tuba fio cilíndrico",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Tubulação de fio com forma cilíndrica",
    "bitbybit.occt.operations.offset": "deslocamento",
    "bitbybit.occt.operations.offset_description": "Offset para várias formas",
    "offsets": "deslocamentos",
    "bitbybit.occt.operations.offsetAdv": "deslocamento avançado",
    "offsetAdv": "deslocamento avançado",
    "bitbybit.occt.operations.offsetAdv_description": "Offset avançado que dá mais opções para offset, como tipo de junção para arestas e cantos",
    "joinType": "tipo de junção",
    "joinTypeEnum": "enum de tipo de junção",
    "removeIntEdges": "remover bordas internas",
    "bitbybit.occt.operations.makeThickSolidSimple": "criar sólido espesso simples",
    "makeThickSolidSimple": "criar sólido espesso simples",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Espessa a forma em um sólido por uma distância de offset",
    "bitbybit.occt.operations.makeThickSolidByJoin": "criar sólido espesso por junção",
    "makeThickSolidByJoin": "criar sólido espesso por junção",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Espessa a forma em um sólido por junção",
    "intersection": "interseção",
    "selfIntersection": "autointerseção",
    "bitbybit.occt.operations.slice": "fatiar",
    "slice": "fatiar",
    "bitbybit.occt.operations.slice_description": "Fatia a forma",
    "bitbybit.occt.operations.sliceInStepPattern": "fatiar em padrão de passos",
    "sliceInStepPattern": "fatiar em padrão de passos",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Fatia a forma em padrão de degraus",
    "steps": "passos",
    "bitbybit.occt.operations.offset3DWire": "deslocar fio 3d",
    "offset3DWire": "deslocar fio 3d",
    "bitbybit.occt.operations.offset3DWire_description": "Offset do fio 3D. Ao usar este método considere usá-lo em fios arredondados que não contêm cantos afiados. Você pode usar arredondamento 3D nele.",
    "bitbybit.occt.booleans.union": "união",
    "booleans": "booleanos",
    "union": "união",
    "bitbybit.occt.booleans.union_description": "Une objetos separados",
    "keepEdges": "manter bordas",
    "bitbybit.occt.booleans.difference": "diferença",
    "difference": "diferença",
    "bitbybit.occt.booleans.difference_description": "Faz operação booleana de diferença entre uma forma principal e formas dadas",
    "bitbybit.occt.booleans.intersection": "interseção",
    "bitbybit.occt.booleans.intersection_description": "Faz operação booleana de interseção entre uma forma principal e formas dadas",
    "bitbybit.occt.shapeFix.basicShapeRepair": "reparo básico de forma",
    "shapeFix": "correção de forma",
    "basicShapeRepair": "reparo básico de forma",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Realiza o reparo básico de forma",
    "maxTolerance": "tolerância máxima",
    "minTolerance": "tolerância mínima",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "corrigir borda pequena no fio",
    "fixSmallEdgeOnWire": "corrigir borda pequena no fio",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Consertar aresta pequena no fio",
    "lockvtx": "bloquear vértice",
    "precsmall": "precisão pequena",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "corrigir orientações de bordas ao longo do fio",
    "fixEdgeOrientationsAlongWire": "corrigir orientações de bordas ao longo do fio",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Consertar orientações de aresta ao longo do fio",
    "bitbybit.occt.io.saveShapeSTEP": "salvar forma STEP",
    "saveShapeSTEP": "salvar forma STEP",
    "bitbybit.occt.io.saveShapeSTEP_description": "Salva o arquivo step",
    "adjustYtoZ": "ajustar Y para Z",
    "tryDownload": "tentar baixar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "salvar forma STEP e retornar",
    "saveShapeSTEPAndReturn": "salvar forma STEP e retornar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Salva o arquivo step e retorna o valor de texto",
    "bitbybit.occt.io.saveShapeStl": "salvar forma STL",
    "saveShapeStl": "salvar forma STL",
    "bitbybit.occt.io.saveShapeStl_description": "Salva o arquivo stl",
    "binary": "binário",
    "bitbybit.occt.io.saveShapeStlAndReturn": "salvar forma STL e retornar",
    "saveShapeStlAndReturn": "salvar forma STL e retornar",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Salva o arquivo stl e retorna",
    "bitbybit.occt.io.loadSTEPorIGES": "carregar STEP ou IGES",
    "loadSTEPorIGES": "carregar STEP ou IGES",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Importa o arquivo de ativo step ou iges",
    "adjustZtoY": "ajustar Z para Y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "carregar STEP ou IGES a partir de texto",
    "loadSTEPorIGESFromText": "carregar STEP ou IGES a partir de texto",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Importa o arquivo de ativo step ou iges a partir de texto",
    "fileType": "tipo de arquivo",
    "fileTypeEnum": "enum de tipo de arquivo",
    "bitbybit.advanced.text3d.create": "texto 3d",
    "advanced": "avançado",
    "text3d": "texto 3d",
    "bitbybit.advanced.text3d.create_description": "Cria um texto 3d",
    "fontType": "tipo de fonte",
    "fontsEnum": "enum de fontes",
    "fontVariant": "variante da fonte",
    "fontVariantsEnum": "enum de variantes de fonte",
    "Inputs.Base.Vector3": "vetor base 3 de entrada",
    "originAlignment": "alinhamento da origem",
    "recAlignmentEnum": "enum de alinhamento de registro",
    "bitbybit.advanced.text3d.createTextOnFace": "texto na face",
    "createTextOnFace": "texto na face",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Cria um texto 3d na face",
    "facePlanar": "face planar",
    "faceTextVar": "variável de texto da face",
    "faceTextVarEnum": "enum de variável de texto da face",
    "originParamU": "parâmetro de origem u",
    "originParamV": "parâmetro de origem v",
    "bitbybit.advanced.text3d.createTextsOnFace": "textos na face",
    "createTextsOnFace": "textos na face",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Cria textos 3d na face a partir de múltiplas definições",
    "definitions": "definições",
    "Text3DFaceDefinitionDto[]": "array de dto de definição de texto 3d na face",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "definição de texto 3d na face",
    "definition3dTextOnFace": "definição de texto 3d na face",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Cria texto 3d que será usado na definição de face",
    "bitbybit.advanced.text3d.getCompoundShape": "obter forma composta",
    "getCompoundShape": "obter forma composta",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Obtém forma composta do resultado de texto 3d",
    "model": "modelo",
    "Text3DData<T>": "dados de texto 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "obter forma do caractere",
    "getCharacterShape": "obter forma do caractere",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Obtém a forma de caractere em índice particular",
    "bitbybit.advanced.text3d.getCharacterShapes": "obter formas dos caracteres",
    "getCharacterShapes": "obter formas dos caracteres",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Obtém formas de caractere do resultado de texto 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "obter coordenadas centrais dos caracteres",
    "getCharacterCenterCoordinates": "obter coordenadas centrais dos caracteres",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Obtém as coordenadas do centro de massa de todos os caracteres",
    "bitbybit.advanced.text3d.getFaceCutout": "obter recorte da face",
    "getFaceCutout": "obter recorte da face",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Obtém o recorte de face do texto 3d que foi criado na face",
    "get from face": "obter da face",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "obter todas as faces do recorte",
    "getAllFacesOfCutout": "obter todas as faces do recorte",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Obtém todos os recortes de face do texto 3d que foi criado na face original",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "obter recortes dentro dos caracteres",
    "getCutoutsInsideCharacters": "obter recortes dentro dos caracteres",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Obtém recortes de face de caractere do texto 3d que foi criado na face original",
    "bitbybit.advanced.text3d.getAdvanceWidth": "obter largura de avanço",
    "getAdvanceWidth": "obter largura de avanço",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Obter largura de avanço",
    "dimensions": "dimensões",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pirâmide simples",
    "facePatterns": "padrões de face",
    "pyramidSimple": "pirâmide simples",
    "createPyramidSimple": "pirâmide simples",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Cria um padrão de pirâmide simples em faces",
    "uNumber": "número u",
    "vNumber": "número v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "afetadores de pirâmide simples",
    "createPyramidSimpleAffectors": "afetadores de pirâmide simples",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Cria um padrão de pirâmide simples em faces com afetadores que mudam a altura",
    "affectorPoints": "pontos afetadores",
    "Inputs.Base.Point3[]": "array de ponto base 3 de entrada",
    "affectorRadiusList": "lista de raios afetadores",
    "affectorFactors": "fatores afetadores",
    "defaultHeight": "altura padrão",
    "affectMinHeight": "altura mínima afetada",
    "affectMaxHeight": "altura máxima afetada",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "obter forma composta",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Obtém a forma composta de todas as pirâmides",
    "get shapes": "obter formas",
    "PyramidSimpleData<T>": "dados de pirâmide simples t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "obter forma composta na face",
    "getCompoundShapeOnFace": "obter forma composta na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Obtém a forma composta na face",
    "faceIndex": "índice da face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "obter célula de forma composta na face",
    "getCompoundShapeCellOnFace": "obter célula de forma composta na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Obtém a forma composta da pirâmide na face em índice particular",
    "uIndex": "índice u",
    "vIndex": "índice v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "obter todas as células de pirâmide",
    "getAllPyramidCells": "obter todas as células de pirâmide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Obtém todas as células de pirâmide. Isso é geralmente uma ação intermediária para então ler informação particular das próprias células.",
    "get cells": "obter células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "obter todas as células de pirâmide na face",
    "getAllPyramidCellsOnFace": "obter todas as células de pirâmide na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Obtém células de pirâmide na face. Isso é geralmente uma ação intermediária para então ler informação particular das próprias células.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "obter todas as células u de pirâmide na face",
    "getAllPyramidUCellsOnFace": "obter todas as células u de pirâmide na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Obtém células de pirâmide na face. Isso é geralmente uma ação intermediária para então ler informação particular das próprias células.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "obter todas as células u de pirâmide na face em u",
    "getAllPyramidUCellsOnFaceAtU": "obter todas as células u de pirâmide na face em u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Obtém células de pirâmide na face no índice u ao longo da direção v. Isso é geralmente uma ação intermediária para então ler informação particular das próprias células.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "obter todas as células u de pirâmide na face em v",
    "getAllPyramidUCellsOnFaceAtV": "obter todas as células u de pirâmide na face em v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Obtém células de pirâmide na face no índice v ao longo da direção u. Isso é geralmente uma ação intermediária para então ler informação particular das próprias células.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "obter célula no índice",
    "getCellOnIndex": "obter célula no índice",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Obtém célula de pirâmide na face no índice u e v. Isso é geralmente uma ação intermediária para então ler informação particular da própria célula.",
    "get cell": "obter célula",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obter pontos superiores das células",
    "getTopPointsOfCells": "obter pontos superiores das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Obtém os pontos superiores das células",
    "get from cells": "obter das células",
    "cells": "células",
    "PyramidSimpleCellPart<T>[]": "array de parte de célula de pirâmide simples t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "obter pontos centrais das células",
    "getCenterPointsOfCells": "obter pontos centrais das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Obtém o ponto central entre cantos da célula",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "obter pontos de canto das células",
    "getCornerPointsOfCells": "obter pontos de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Obtém os pontos de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "obter ponto de canto das células",
    "getCornerPointOfCells": "obter ponto de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Obtém os pontos de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "obter normal de canto das células",
    "getCornerNormalOfCells": "obter normal de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Obtém a normal de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "obter normais de canto das células",
    "getCornerNormalsOfCells": "obter normais de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Obtém as normais de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "obter formas compostas das células",
    "getCompoundShapesOfCells": "obter formas compostas das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Obtém as formas compostas das células de pirâmide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "obter formas de face das células",
    "getFaceShapesOfCells": "obter formas de face das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Obtém as formas de face das células de pirâmide fornecidas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "obter formas de fio das células",
    "getWireShapesOfCells": "obter formas de fio das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Obtém as formas de face das células de pirâmide fornecidas",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "obter fio polilinha inicial u",
    "getStartPolylineWireU": "obter fio polilinha inicial u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Obtém o fio polilinha ao longo da aresta inicial da direção U da face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "obter fio polilinha final u",
    "getEndPolylineWireU": "obter fio polilinha final u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Obtém o fio polilinha ao longo da aresta final da direção U da face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "obter fio polilinha inicial v",
    "getStartPolylineWireV": "obter fio polilinha inicial v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Obtém o fio polilinha ao longo da aresta inicial da direção V da face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "obter fio polilinha final v",
    "getEndPolylineWireV": "obter fio polilinha final v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Obtém o fio polilinha ao longo da aresta final da direção V da face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "obter composto de fios polilinha u",
    "getPolylineWiresUCompound": "obter composto de fios polilinha u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Obtém os fios polilinha ao longo da direção U",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "obter composto de fios polilinha v",
    "getPolylineWiresVCompound": "obter composto de fios polilinha v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Obtém os fios polilinha ao longo da direção V",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "villa ponta de asa",
    "things": "coisas",
    "kidsCorner": "cantinho das crianças",
    "birdhouses": "casas de pássaros",
    "wingtipVilla": "villa ponta de asa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Cria uma casa de pássaros wingtip villa com um telhado de 45 graus",
    "birdhouse": "casa de pássaros",
    "interiorWidth": "largura interna",
    "interiorLength": "comprimento interno",
    "interiorHeight": "altura interna",
    "holeDiameter": "diâmetro do buraco",
    "holeDistToBottom": "distância do buraco ao fundo",
    "stickLength": "comprimento do bastão",
    "stickDiameter": "diâmetro do bastão",
    "baseAttachmentHeight": "altura de fixação da base",
    "roofOverhang": "saliência do telhado",
    "chimneyHeight": "altura da chaminé",
    "Inputs.Base.Point3": "ponto base 3 de entrada",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chalé chirpy",
    "chirpyChalet": "chalé chirpy",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Cria uma casa de pássaros chirpy chalet com um telhado de 45 graus",
    "roofAngle": "ângulo do telhado",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "redemoinho da serenidade",
    "threeDPrinting": "impressão 3d",
    "vases": "vasos",
    "serenitySwirl": "redemoinho da serenidade",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Cria um serenity swirl",
    "swirl": "redemoinho",
    "addRadiusNarrow": "adicionar raio estreito",
    "addRadiusWide": "adicionar raio largo",
    "addMiddleHeight": "adicionar altura média",
    "addTopHeight": "adicionar altura superior",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arco árabe",
    "arabicArchway": "arco árabe",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Cria um vaso arabic archway",
    "profilePoints": "pontos de perfil",
    "nrOfSides": "número de lados",
    "nrOfVerticalArches": "número de arcos verticais",
    "archCenterThickness": "espessura central do arco",
    "edgesThickness": "espessura das bordas",
    "baseHeight": "altura da base",
    "patchHoles": "remendar buracos",
    "lod": "nível de detalhe",
    "Things.Enums.lodEnum": "enum de nível de detalhe de coisas",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "amor eterno",
    "medals": "medalhas",
    "eternalLove": "amor eterno",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Cria um modelo de medalha eternal love",
    "textHeading": "título do texto",
    "textName": "nome do texto",
    "fullModel": "modelo completo",
    "decorationThickness": "espessura da decoração",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "copo calmo",
    "cups": "copos",
    "calmCup": "copo calmo",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Cria um modelo de copo para seus momentos calmos",
    "radiusTopOffset": "deslocamento do raio superior",
    "fillet": "arredondamento",
    "nrOfHandles": "número de alças",
    "handleDist": "distância da alça",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "copo dragão",
    "dragonCup": "copo dragão",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Cria um modelo de copo para seu dragão interior",
    "radiusMidOffset": "deslocamento do raio médio",
    "rotationTopAngle": "ângulo de rotação superior",
    "rotationMidAngle": "ângulo de rotação médio",
    "nrSkinCellsVertical": "número de células de pele verticais",
    "nrSkinCellsHorizontal": "número de células de pele horizontais",
    "nrSkinCellDivisionsTop": "número de divisões de células de pele superiores",
    "nrSkinCellDivisionsBottom": "número de divisões de células de pele inferiores",
    "skinCellOuterHeight": "altura externa da célula de pele",
    "skinCellInnerHeight": "altura interna da célula de pele",
    "skinCellBottomHeight": "altura inferior da célula de pele",
    "skinCellTopHeight": "altura superior da célula de pele",
    "bottomThickness": "espessura do fundo",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "obter forma composta",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Obtém a forma composta do copo dragão",
    "DragonCupData<T>": "dados do copo dragão t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "ninho de telefone",
    "desktop": "área de trabalho",
    "phoneNest": "ninho de telefone",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Cria um modelo phone nest",
    "heightBottom": "altura inferior",
    "heightTop": "altura superior",
    "widthBack": "largura traseira",
    "widthFront": "largura frontal",
    "backOffset": "deslocamento traseiro",
    "applyOrnaments": "aplicar ornamentos",
    "filletRadius": "raio de arredondamento",
    "phoneHeight": "altura do telefone",
    "phoneWidth": "largura do telefone",
    "phoneThickness": "espessura do telefone",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "obter forma composta",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Obtém a forma composta do phone nest",
    "PhoneNestData<T>": "dados do ninho de telefone t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "opções de desenho",
    "drawOptions": "opções de desenho",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "cria opções de desenho para o modelo",
    "mainMaterial": "material principal",
    "phoneMaterial": "material do telefone",
    "Inputs.Base.Color": "cor base de entrada",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "suporte de telefone gotículas",
    "laserCutting": "corte a laser",
    "gadgets": "apetrechos",
    "dropletsPhoneHolder": "suporte de telefone gotículas",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "cria suporte de telefone gotículas",
    "title": "título",
    "subtitle": "subtítulo",
    "includeLogo": "incluir logotipo",
    "kerf": "kerf",
    "backLength": "comprimento traseiro",
    "offsetAroundPhone": "deslocamento ao redor do telefone",
    "penShelf": "prateleira para caneta",
    "phoneLockHeight": "altura de trava do telefone",
    "includePattern": "incluir padrão",
    "densityPattern": "padrão de densidade",
    "holesForWire": "buracos para fio",
    "wireInputThickness": "espessura de entrada do fio",
    "includeModel": "incluir modelo",
    "includeDrawings": "incluir desenhos",
    "spacingDrawings": "espaçamento dos desenhos",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "obter forma composta",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Obtém a forma composta do droplets phone holder",
    "DropletsPhoneHolderData<T>": "dados do suporte de telefone gotículas t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "obter composto de fios de corte",
    "getCutWiresCompound": "obter composto de fios de corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Obtém o composto de fios de corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "obter composto de fios de gravação",
    "getEngravingWiresCompound": "obter composto de fios de gravação",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Obtém o composto de fios de gravação",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "baixar desenhos DXF",
    "downloadDXFDrawings": "baixar desenhos DXF",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "baixa desenho DXF",
    "download": "baixar",
    "cutWiresColor": "cor dos fios de corte",
    "engravingWiresColor": "cor dos fios de gravação",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "baixar desenhos STEP",
    "downloadSTEPDrawings": "baixar desenhos STEP",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "baixa desenho STEP",
    "adjustYZ": "ajustar YZ",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "baixar modelo 3D STEP",
    "download3dSTEPModel": "baixar modelo 3D STEP",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "baixa modelo 3D em formato STEP",
    "bitbybit.things.architecture.houses.zenHideout.create": "refúgio zen",
    "architecture": "arquitetura",
    "houses": "casas",
    "zenHideout": "refúgio zen",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Cria um zen hideout",
    "widthFirstWing": "largura da primeira ala",
    "lengthFirstWing": "comprimento da primeira ala",
    "terraceWidth": "largura do terraço",
    "widthSecondWing": "largura da segunda ala",
    "lengthSecondWing": "comprimento da segunda ala",
    "heightWalls": "altura das paredes",
    "roofAngleFirstWing": "ângulo do telhado da primeira ala",
    "roofAngleSecondWing": "ângulo do telhado da segunda ala",
    "roofOffset": "deslocamento do telhado",
    "roofInsideOverhang": "saliência interna do telhado",
    "roofMaxDistAttachmentBeams": "distância máxima das vigas de fixação do telhado",
    "roofAttachmentBeamWidth": "largura da viga de fixação do telhado",
    "roofAttachmentBeamHeight": "altura da viga de fixação do telhado",
    "roofOutsideOverhang": "saliência externa do telhado",
    "columnSize": "tamanho da coluna",
    "ceilingBeamHeight": "altura da viga de teto",
    "ceilingBeamWidth": "largura da viga de teto",
    "nrCeilingBeamsBetweenColumns": "número de vigas de teto entre colunas",
    "distBetweenColumns": "distância entre colunas",
    "floorHeight": "altura do piso",
    "groundLevel": "nível do solo",
    "facadePanelThickness": "espessura do painel de fachada",
    "windowWidthOffset": "deslocamento da largura da janela",
    "windowHeightOffset": "deslocamento da altura da janela",
    "windowFrameThickness": "espessura da moldura da janela",
    "windowGlassFrameThickness": "espessura da moldura de vidro da janela",
    "skinOpacity": "opacidade da pele",
    "bitbybit.things.furniture.chairs.snakeChair.create": "cadeira serpente",
    "furniture": "móveis",
    "chairs": "cadeiras",
    "snakeChair": "cadeira serpente",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Cria um modelo snake chair",
    "sittingHeight": "altura do assento",
    "backRestOffset": "deslocamento do encosto",
    "backRestHeight": "altura do encosto",
    "nrOrnamentPlanks": "número de tábuas ornamentais",
    "ornamentDepth": "profundidade do ornamento",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Obtém a forma composta da cadeira",
    "SnakeChairData<T>": "dados da cadeira serpente t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "obter forma de fio do assento",
    "getSittingWireShape": "obter forma de fio do assento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Obtém a forma de fio da área de assento da cadeira",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "obter ponto central da área de assento",
    "getSittingAreaCenterPoint": "obter ponto central da área de assento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Obtém o ponto central da área de assento da cadeira",
    "get points": "obter pontos",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "cria opções de desenho para a cadeira serpente",
    "bitbybit.things.furniture.tables.elegantTable.create": "mesa elegante",
    "tables": "mesas",
    "elegantTable": "mesa elegante",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Cria um modelo de mesa elegante",
    "topThickness": "espessura do tampo",
    "topOffset": "deslocamento do tampo",
    "minFillet": "arredondamento mínimo",
    "radiusLegTop": "raio da perna no topo",
    "radiusLegBottom": "raio da perna na base",
    "nrLegPairs": "número de pares de pernas",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Obtém a forma composta da mesa",
    "ElegantTableData<T>": "dados da mesa elegante t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "obter formas das pernas",
    "getLegShapes": "obter formas das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Obtém as formas de perna como uma lista",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "obter forma da perna por índice",
    "getLegShapeByIndex": "obter forma da perna por índice",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Obtém a forma de perna por índice",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "obter forma do painel superior",
    "getTopPanelShape": "obter forma do painel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Obtém a forma do painel superior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "obter forma de fio do painel superior",
    "getTopPanelWireShape": "obter forma de fio do painel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Obtém a forma de fio do painel superior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "obter forma de fio do painel inferior",
    "getBottomPanelWireShape": "obter forma de fio do painel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Obtém a forma de fio do painel inferior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "obter forma do painel inferior",
    "getBottomPanelShape": "obter forma do painel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Obtém a forma do painel inferior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "obter forma composta das pernas",
    "getLegsCompoundShape": "obter forma composta das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Obtém as formas de perna como uma forma composta",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "obter ponto central do tampo da mesa",
    "getTableTopCenterPoint": "obter ponto central do tampo da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Obtém o ponto central superior",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "obter ponto central da base da mesa",
    "getTableBottomCenterPoint": "obter ponto central da base da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Obtém o ponto central inferior",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "obter pontos inferiores das pernas",
    "getLegBottomPoints": "obter pontos inferiores das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Obtém os pontos inferiores da perna",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obter pontos superiores das pernas",
    "getLegTopPoints": "obter pontos superiores das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Obtém os pontos superiores da perna",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "cria opções de desenho para a mesa elegante",
    "topMaterial": "material do tampo",
    "topBaseMaterial": "material da base do tampo",
    "legsMaterial": "material das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "mesa de café boa",
    "goodCoffeeTable": "mesa de café boa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Cria um modelo de mesa de café boa",
    "chamfer": "chanfro",
    "topGlassOffset": "deslocamento do vidro superior",
    "glassThickness": "espessura do vidro",
    "glassHolderLength": "comprimento do suporte de vidro",
    "shelfTopOffset": "deslocamento superior da prateleira",
    "shelfThickness": "espessura da prateleira",
    "legWidth": "largura da perna",
    "legDepth": "profundidade da perna",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Obtém a forma composta da mesa",
    "GoodCoffeeTableData<T>": "dados da mesa de café boa t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "obter formas das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Obtém as formas de perna como uma lista",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "obter forma da perna por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Obtém a forma de perna por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "obter forma do painel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Obtém a forma do painel superior da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "obter forma de fio do painel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Obtém a forma de fio do painel superior da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "obter forma do painel de vidro",
    "getGlassPanelShape": "obter forma do painel de vidro",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Obtém a forma do painel de vidro da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "obter forma de fio do painel de vidro",
    "getGlassPanelWireShape": "obter forma de fio do painel de vidro",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Obtém a forma de fio do painel de vidro da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "obter forma da prateleira",
    "getShelfShape": "obter forma da prateleira",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Obtém a forma da prateleira da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "obter forma de fio superior da prateleira",
    "getShelfTopWireShape": "obter forma de fio superior da prateleira",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Obtém a forma de fio superior da prateleira da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "obter forma composta das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Obtém as formas de perna como uma forma composta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "obter ponto central do tampo da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Obtém o ponto central superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "obter ponto central superior da prateleira da mesa",
    "getTableShelfTopCenterPoint": "obter ponto central superior da prateleira da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Obtém o ponto central superior da prateleira",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "obter pontos inferiores das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Obtém os pontos inferiores da perna",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obter pontos superiores das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Obtém os pontos superiores da perna",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "cria opções de desenho para a mesa de café boa",
    "topGlassMaterial": "material do vidro superior",
    "shelfMaterial": "material da prateleira",
    "bitbybit.things.furniture.tables.snakeTable.create": "mesa serpente",
    "snakeTable": "mesa serpente",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Cria um modelo de mesa cobra",
    "supportLength": "comprimento do suporte",
    "shelfHeight": "altura da prateleira",
    "glassOffset": "deslocamento do vidro",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Obtém a forma composta da mesa",
    "SnakeTableData<T>": "dados da mesa serpente t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "obter forma do vidro",
    "getGlassShape": "obter forma do vidro",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Obtém a forma de vidro da mesa",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "obter forma principal",
    "getMainShape": "obter forma principal",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Obtém a forma sólida principal da mesa",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "obter ponto central do tampo",
    "getTopCenterPoint": "obter ponto central do tampo",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Obtém o ponto central do topo da mesa",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "cria opções de desenho para a mesa serpente",
    "glassMaterial": "material do vidro",
    "bitbybit.things.enums.lodEnum": "enum de nível de detalhe",
    "enums": "enums",
    "lodEnum": "enum de nível de detalhe",
    "bitbybit.things.enums.lodEnum_description": "Cria um valor de enumeração de nível de detalhe",
    "bitbybit.jscad.transformSolids": "transformar sólidos",
    "jscad": "jscad",
    "transformSolids": "transformar sólidos",
    "bitbybit.jscad.transformSolids_description": "Transforma as malhas sólidas Jscad com uma lista dada de transformações.",
    "JSCADEntity[]": "array de entidade jscad",
    "bitbybit.jscad.transformSolid": "transformar sólido",
    "transformSolid": "transformar sólido",
    "bitbybit.jscad.transformSolid_description": "Transforma a malha sólida Jscad com uma lista dada de transformações.",
    "JSCADEntity": "entidade jscad",
    "bitbybit.jscad.downloadSolidSTL": "baixar sólido STL",
    "downloadSolidSTL": "baixar sólido STL",
    "bitbybit.jscad.downloadSolidSTL_description": "Baixa o arquivo STL binário de um sólido 3D",
    "bitbybit.jscad.downloadSolidsSTL": "baixar sólidos STL",
    "downloadSolidsSTL": "baixar sólidos STL",
    "bitbybit.jscad.downloadSolidsSTL_description": "Baixa o arquivo STL binário de sólidos 3D",
    "bitbybit.jscad.downloadGeometryDxf": "baixar geometria DXF",
    "downloadGeometryDxf": "baixar geometria DXF",
    "bitbybit.jscad.downloadGeometryDxf_description": "Baixa o arquivo dxf da geometria jscad. Suporta caminhos e malhas em array.",
    "geometry": "geometria",
    "JSCADEntity | JSCADEntity[]": "entidade jscad ou array",
    "bitbybit.jscad.downloadGeometry3MF": "baixar geometria 3MF",
    "downloadGeometry3MF": "baixar geometria 3MF",
    "bitbybit.jscad.downloadGeometry3MF_description": "Baixa o arquivo 3MF da geometria jscad.",
    "bitbybit.jscad.booleans.intersect": "interseccionar",
    "intersect": "interseccionar",
    "bitbybit.jscad.booleans.intersect_description": "Intersecciona múltiplos objetos de malha sólida",
    "bitbybit.jscad.booleans.subtract": "subtrair",
    "subtract": "subtrair",
    "bitbybit.jscad.booleans.subtract_description": "Subtrai múltiplos objetos de malha sólida",
    "bitbybit.jscad.booleans.union": "união",
    "bitbybit.jscad.booleans.union_description": "Une múltiplos objetos de malha sólida",
    "bitbybit.jscad.booleans.intersectTwo": "interseccionar dois",
    "intersectTwo": "interseccionar dois",
    "bitbybit.jscad.booleans.intersectTwo_description": "Intersecciona dois objetos de malha sólida",
    "bitbybit.jscad.booleans.subtractTwo": "subtrair dois",
    "subtractTwo": "subtrair dois",
    "bitbybit.jscad.booleans.subtractTwo_description": "Subtrai dois objetos de malha sólida",
    "bitbybit.jscad.booleans.unionTwo": "união de dois",
    "unionTwo": "união de dois",
    "bitbybit.jscad.booleans.unionTwo_description": "Une dois objetos de malha sólida",
    "bitbybit.jscad.booleans.subtractFrom": "subtrair de",
    "subtractFrom": "subtrair de",
    "bitbybit.jscad.booleans.subtractFrom_description": "Subtrai múltiplas malhas de um objeto de malha",
    "bitbybit.jscad.expansions.expand": "expandir",
    "expansions": "expansões",
    "expand": "expandir",
    "bitbybit.jscad.expansions.expand_description": "Expande geometrias de categoria sólida",
    "expansion": "expansão",
    "delta": "delta",
    "corners": "cantos",
    "solidCornerTypeEnum": "enum de tipo de canto sólido",
    "bitbybit.jscad.expansions.offset": "deslocamento",
    "bitbybit.jscad.expansions.offset_description": "Desloca geometrias 2d de categoria sólida",
    "bitbybit.jscad.extrusions.extrudeLinear": "extrusão linear",
    "extrudeLinear": "extrusão linear",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Extrusão linear de geometrias 2D de categoria sólida",
    "twistAngle": "ângulo de torção",
    "twistSteps": "passos de torção",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extrusão retangular",
    "extrudeRectangular": "extrusão retangular",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Extrusão retangular de geometrias 2D de categoria sólida. Cria uma extrusão tipo parede de certa altura e tamanho.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extrusão retangular de pontos",
    "extrudeRectangularPoints": "extrusão retangular de pontos",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Extrusão retangular de uma lista de pontos 2D. Cria uma extrusão tipo parede de certa altura e tamanho.",
    "bitbybit.jscad.extrusions.extrudeRotate": "extrusão rotacionada",
    "extrudeRotate": "extrusão rotacionada",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Extrusão retangular de uma lista de pontos 2D. Cria uma extrusão tipo parede de certa altura e tamanho.",
    "polygon": "polígono",
    "startAngle": "ângulo inicial",
    "bitbybit.jscad.hulls.hullChain": "cadeia de casco",
    "hulls": "cascos",
    "hullChain": "cadeia de casco",
    "bitbybit.jscad.hulls.hullChain_description": "Cadeia de casco conecta sólidos ou geometrias 2d preenchendo um espaço vazio entre objetos em ordem. Geometrias precisam ser do mesmo tipo.",
    "bitbybit.jscad.hulls.hull": "casco",
    "hull": "casco",
    "bitbybit.jscad.hulls.hull_description": "Casco convexo conecta sólidos ou geometrias 2d preenchendo um espaço vazio entre eles sem seguir ordem. Geometrias precisam ser do mesmo tipo.",
    "bitbybit.jscad.path.createFromPoints": "a partir de pontos",
    "createFromPoints": "a partir de pontos",
    "bitbybit.jscad.path.createFromPoints_description": "Cria um caminho 2D a partir de uma lista de pontos",
    "Base.Point2[]": "array de ponto base 2",
    "bitbybit.jscad.path.createPathsFromPoints": "caminhos a partir de pontos",
    "createPathsFromPoints": "caminhos a partir de pontos",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Cria caminhos 2D a partir de listas de pontos",
    "pointsLists": "listas de pontos",
    "Base.Point3[][] | Base.Point2[][]": "array de ponto base 3 ou 2",
    "bitbybit.jscad.path.createFromPolyline": "a partir de polilinha",
    "createFromPolyline": "a partir de polilinha",
    "bitbybit.jscad.path.createFromPolyline_description": "Cria um caminho 2D a partir de uma polilinha",
    "bitbybit.jscad.path.createEmpty": "vazio",
    "createEmpty": "vazio",
    "bitbybit.jscad.path.createEmpty_description": "Cria caminho 2D vazio",
    "bitbybit.jscad.path.close": "fechar",
    "close": "fechar",
    "bitbybit.jscad.path.close_description": "Fecha um caminho 2D aberto",
    "bitbybit.jscad.path.appendPoints": "adicionar pontos",
    "appendPoints": "adicionar pontos",
    "bitbybit.jscad.path.appendPoints_description": "Anexa o caminho com pontos 2D",
    "append": "adicionar",
    "bitbybit.jscad.path.appendPolyline": "adicionar polilinha",
    "appendPolyline": "adicionar polilinha",
    "bitbybit.jscad.path.appendPolyline_description": "Anexa o caminho com polilinha",
    "bitbybit.jscad.path.appendArc": "adicionar arco",
    "appendArc": "adicionar arco",
    "bitbybit.jscad.path.appendArc_description": "Anexa o arco ao caminho",
    "xAxisRotation": "rotação no eixo x",
    "clockwise": "sentido horário",
    "large": "grande",
    "bitbybit.jscad.polygon.createFromPoints": "a partir de pontos",
    "bitbybit.jscad.polygon.createFromPoints_description": "Cria um polígono 2D a partir de uma lista de pontos",
    "bitbybit.jscad.polygon.createFromPolyline": "a partir de polilinha",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Cria um polígono 2D a partir de uma polilinha",
    "bitbybit.jscad.polygon.createFromCurve": "a partir de curva",
    "createFromCurve": "a partir de curva",
    "bitbybit.jscad.polygon.createFromCurve_description": "Cria um polígono 2D a partir de uma curva",
    "bitbybit.jscad.polygon.createFromPath": "a partir de caminho",
    "createFromPath": "a partir de caminho",
    "bitbybit.jscad.polygon.createFromPath_description": "Cria um polígono 2D a partir de um caminho",
    "bitbybit.jscad.polygon.circle": "círculo",
    "bitbybit.jscad.polygon.circle_description": "Cria um círculo polígono 2D",
    "bitbybit.jscad.polygon.ellipse": "elipse",
    "ellipse": "elipse",
    "bitbybit.jscad.polygon.ellipse_description": "Cria uma elipse polígono 2D",
    "bitbybit.jscad.polygon.rectangle": "retângulo",
    "rectangle": "retângulo",
    "bitbybit.jscad.polygon.rectangle_description": "Cria um retângulo polígono 2D",
    "bitbybit.jscad.polygon.roundedRectangle": "retângulo arredondado",
    "roundedRectangle": "retângulo arredondado",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Cria um retângulo arredondado 2D",
    "roundRadius": "raio de arredondamento",
    "bitbybit.jscad.polygon.square": "quadrado",
    "square": "quadrado",
    "bitbybit.jscad.polygon.square_description": "Cria um quadrado polígono 2D",
    "bitbybit.jscad.polygon.star": "estrela",
    "star": "estrela",
    "bitbybit.jscad.polygon.star_description": "Cria uma estrela polígono 2D",
    "vertices": "vértices",
    "bitbybit.jscad.shapes.cube": "cubo",
    "cube": "cubo",
    "bitbybit.jscad.shapes.cube_description": "Cria uma forma de cubo 3D",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubos em pontos centrais",
    "cubesOnCenterPoints": "cubos em pontos centrais",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Cria cubos 3D em múltiplos pontos centrais",
    "primitives on centers": "primitivas em centros",
    "bitbybit.jscad.shapes.cuboid": "cuboide",
    "cuboid": "cuboide",
    "bitbybit.jscad.shapes.cuboid_description": "Cria uma forma de cuboide 3D",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "cuboides em pontos centrais",
    "cuboidsOnCenterPoints": "cuboides em pontos centrais",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Cria cuboides 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.cylinderElliptic": "cilindro elíptico",
    "cylinderElliptic": "cilindro elíptico",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Cria um sólido cilindro elíptico 3D",
    "startRadius": "raio inicial",
    "endRadius": "raio final",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cilindros elípticos em pontos centrais",
    "cylinderEllipticOnCenterPoints": "cilindros elípticos em pontos centrais",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Cria cilindros elípticos 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.cylinder": "cilindro",
    "cylinder": "cilindro",
    "bitbybit.jscad.shapes.cylinder_description": "Cria um sólido cilindro 3D",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cilindros em pontos centrais",
    "cylindersOnCenterPoints": "cilindros em pontos centrais",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Cria cilindros 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.ellipsoid": "elipsoide",
    "ellipsoid": "elipsoide",
    "bitbybit.jscad.shapes.ellipsoid_description": "Cria um sólido elipsoide 3D",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "elipsoides em pontos centrais",
    "ellipsoidsOnCenterPoints": "elipsoides em pontos centrais",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Cria elipsoides 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.geodesicSphere": "esfera geodésica",
    "geodesicSphere": "esfera geodésica",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Cria um sólido esfera geodésica 3D",
    "frequency": "frequência",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "esferas geodésicas em pontos centrais",
    "geodesicSpheresOnCenterPoints": "esferas geodésicas em pontos centrais",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Cria esferas geodésicas 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.roundedCuboid": "cuboide arredondado",
    "roundedCuboid": "cuboide arredondado",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Cria um sólido cuboide arredondado 3D",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "cuboides arredondados em pontos centrais",
    "roundedCuboidsOnCenterPoints": "cuboides arredondados em pontos centrais",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Cria cuboides arredondados 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.roundedCylinder": "cilindro arredondado",
    "roundedCylinder": "cilindro arredondado",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Cria um sólido cilindro arredondado 3D",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "cilindros arredondados em pontos centrais",
    "roundedCylindersOnCenterPoints": "cilindros arredondados em pontos centrais",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Cria cilindros arredondados 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.sphere": "esfera",
    "sphere": "esfera",
    "bitbybit.jscad.shapes.sphere_description": "Cria um sólido esfera 3D",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "esferas em pontos centrais",
    "spheresOnCenterPoints": "esferas em pontos centrais",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Cria uma esfera 3D em múltiplos pontos centrais",
    "bitbybit.jscad.shapes.torus": "toro",
    "torus": "toro",
    "bitbybit.jscad.shapes.torus_description": "Cria um sólido toro 3D",
    "innerSegments": "segmentos internos",
    "outerSegments": "segmentos externos",
    "innerRotation": "rotação interna",
    "outerRotation": "rotação externa",
    "bitbybit.jscad.shapes.fromPolygonPoints": "a partir de pontos de polígono",
    "fromPolygonPoints": "a partir de pontos de polígono",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Cria uma forma 3D a partir de pontos de polígono que devem ser arrays aninhados de pontos",
    "polygonPoints": "pontos de polígono",
    "Base.Point3[][]": "array de ponto base 3",
    "bitbybit.jscad.text.cylindricalText": "texto cilíndrico",
    "cylindricalText": "texto cilíndrico",
    "bitbybit.jscad.text.cylindricalText_description": "Cria um texto que é baseado em cilindros de cadeia de casco",
    "extrusionHeight": "altura de extrusão",
    "extrusionSize": "tamanho de extrusão",
    "jscadTextAlignEnum": "enum de alinhamento de texto jscad",
    "bitbybit.jscad.text.sphericalText": "texto esférico",
    "sphericalText": "texto esférico",
    "bitbybit.jscad.text.sphericalText_description": "Cria um texto que é baseado em esferas de cadeia de casco",
    "bitbybit.jscad.text.createVectorText": "texto vetorial",
    "createVectorText": "texto vetorial",
    "bitbybit.jscad.text.createVectorText_description": "Cria um texto vetorial",
    "bitbybit.jscad.colors.colorize": "colorir",
    "colors": "cores",
    "colorize": "colorir",
    "bitbybit.jscad.colors.colorize_description": "Colore a geometria do jscad. Se a geometria estiver no array, colorirá todos os itens e os retornará. Se a geometria for um único item, retornará um único item. Tenha em mente que a geometria colorida no jscad sempre será desenhada nessa cor, mesmo se você tentar alterá-la via opções de desenho.",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold para ponteiro de malha",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold para ponteiro de malha",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Transforma forma manifold em um ponteiro de malha que vive na memória do worker. Este ponteiro pode ser usado com funções bitbybit.manifold.mesh",
    "meshing": "malhagem",
    "normalIdx": "índice de normal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "decompor manifold ou seção transversal",
    "decomposeManifoldOrCrossSection": "decompor manifold ou seção transversal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Decompõe forma manifold ou seção transversal em uma malha ou polígonos simples",
    "decompose": "decompor",
    "manifoldOrCrossSection": "manifold ou seção transversal",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "decompor manifolds ou seções transversais",
    "decomposeManifoldsOrCrossSections": "decompor manifolds ou seções transversais",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Decompõe forma manifold ou seção transversal em uma malha ou polígonos simples",
    "manifoldsOrCrossSections": "manifolds ou seções transversais",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "excluir manifold ou seção transversal",
    "deleteManifoldOrCrossSection": "excluir manifold ou seção transversal",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Deleta manifold ou seção transversal da memória",
    "cleanup": "limpeza",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "excluir manifolds ou seções transversais",
    "deleteManifoldsOrCrossSections": "excluir manifolds ou seções transversais",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Deleta manifolds ou seções transversais da memória",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold para malha",
    "manifoldToMesh": "manifold para malha",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Transforma forma manifold em uma malha",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds para malhas",
    "manifoldsToMeshes": "manifolds para malhas",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "transforma formas manifold em malhas",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold a partir de malha",
    "manifoldFromMesh": "manifold a partir de malha",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Converte uma Malha em um Manifold, retendo suas propriedades e mesclando apenas as posições de acordo com os vetores de mesclagem. Lançará um erro se o resultado não for um 2-manifold orientado. Irá colapsar triângulos degenerados e vértices desnecessários. Todos os campos são lidos, tornando esta estrutura adequada para uma ida e volta sem perdas de dados de manifoldToMesh(). Para entrada multi-material, use reserveIDs() para definir um originalID único para cada material, e classifique os materiais em execuções de triângulo.",
    "DecomposedManifoldMeshDto": "dto de malha manifold decomposta",
    "bitbybit.manifold.manifold.shapes.cube": "cubo",
    "bitbybit.manifold.manifold.shapes.cube_description": "Cria uma forma de cubo 3D",
    "bitbybit.manifold.manifold.shapes.sphere": "esfera",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Cria uma forma de esfera 3D",
    "circularSegments": "segmentos circulares",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tetraedro",
    "tetrahedron": "tetraedro",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Cria uma forma de tetraedro 3D",
    "bitbybit.manifold.manifold.shapes.cylinder": "cilindro",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Cria uma forma de cilindro 3D",
    "radiusLow": "raio baixo",
    "radiusHigh": "raio alto",
    "bitbybit.manifold.manifold.booleans.subtract": "subtrair",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Subtrai duas formas manifold",
    "a to b": "a para b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "adicionar",
    "bitbybit.manifold.manifold.booleans.add_description": "Adiciona duas formas manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "interseccionar",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Intercepta duas formas manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "diferença de dois",
    "differenceTwo": "diferença de dois",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "diferença de duas formas manifold",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "união de dois",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "união de duas formas manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "interseção de dois",
    "intersectionTwo": "interseção de dois",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "interseção de duas formas manifold",
    "bitbybit.manifold.manifold.booleans.difference": "diferença",
    "bitbybit.manifold.manifold.booleans.difference_description": "diferença de múltiplas formas manifold",
    "bitbybit.manifold.manifold.booleans.union": "união",
    "bitbybit.manifold.manifold.booleans.union_description": "união de múltiplas formas manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "interseção",
    "bitbybit.manifold.manifold.booleans.intersection_description": "interseção de múltiplas formas manifold",
    "bitbybit.manifold.manifold.booleans.split": "dividir",
    "split": "dividir",
    "bitbybit.manifold.manifold.booleans.split_description": "Divide manifold por outro manifold",
    "manifoldToSplit": "manifold a dividir",
    "manifoldCutter": "manifold cortador",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "dividir por plano",
    "splitByPlane": "dividir por plano",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Divide manifold por plano",
    "originOffset": "deslocamento da origem",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "dividir por plano em deslocamentos",
    "splitByPlaneOnOffsets": "dividir por plano em deslocamentos",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Divide manifold por plano em vários offsets",
    "originOffsets": "deslocamentos da origem",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "aparar por plano",
    "trimByPlane": "aparar por plano",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Apara manifold por plano",
    "trim": "aparar",
    "bitbybit.manifold.manifold.operations.hull": "casco",
    "bitbybit.manifold.manifold.operations.hull_description": "Computa casco convexo da forma manifold fornecida",
    "bitbybit.manifold.manifold.operations.hullPoints": "casco de pontos",
    "hullPoints": "casco de pontos",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Casco de pontos ou manifolds",
    "bitbybit.manifold.manifold.operations.slice": "fatiar",
    "bitbybit.manifold.manifold.operations.slice_description": "Retorna a seção transversal deste objeto paralelo ao plano X-Y na altura especificada. Usar uma altura igual ao fundo da caixa delimitadora retornará as faces inferiores, enquanto usar uma altura igual ao topo da caixa delimitadora retornará vazio.",
    "cross sections": "seções transversais",
    "bitbybit.manifold.manifold.operations.project": "projetar",
    "bitbybit.manifold.manifold.operations.project_description": "Cria uma projeção no plano xy a partir do contorno da forma",
    "bitbybit.manifold.manifold.operations.setTolerance": "definir tolerância",
    "setTolerance": "definir tolerância",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Retorna uma cópia do manifold com o valor de tolerância definido. Isso realiza simplificação de malha quando o valor de tolerância é aumentado.",
    "basic": "básico",
    "bitbybit.manifold.manifold.operations.reserveIds": "reservar ids",
    "reserveIds": "reservar ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Retorna o primeiro de n novos IDs de malha únicos sequenciais para marcar conjuntos de triângulos que podem ser consultados após operações posteriores. Atribuir ao vetor Mesh.runOriginalID.",
    "count": "contagem",
    "bitbybit.manifold.manifold.operations.asOriginal": "como original",
    "asOriginal": "como original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "Se você copiar um manifold, mas quiser que esta nova cópia tenha novas propriedades (por exemplo, um mapeamento UV diferente), você pode redefinir seus IDs para um novo original, significando que agora será referenciado por seus descendentes em vez das malhas de onde foi construído, permitindo diferenciar as cópias ao aplicar suas propriedades ao resultado final. Esta função também condensa todas as faces coplanares na relação, e colapsa essas arestas. Se você quiser ter propriedades inconsistentes através dessas faces, o que significa que você quer preservar algumas dessas arestas, você deve chamar GetMesh(), calcular suas propriedades e usá-las para construir um novo manifold.",
    "bitbybit.manifold.manifold.operations.compose": "compor",
    "compose": "compor",
    "bitbybit.manifold.manifold.operations.compose_description": "Constrói um novo manifold a partir de uma lista de outros manifolds. Esta é uma operação puramente topológica, então cuidado deve ser tomado para evitar criar resultados sobrepostos. É a operação inversa de Decompose().",
    "composition": "composição",
    "bitbybit.manifold.manifold.operations.decompose": "decompor",
    "bitbybit.manifold.manifold.operations.decompose_description": "Esta operação retorna um vetor de Manifolds que são topologicamente desconectados. Se tudo estiver conectado, o vetor tem comprimento um, contendo uma cópia do original. É a operação inversa de Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calcular normais",
    "calculateNormals": "calcular normais",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Preenche propriedades de vértice para vetores normais, calculados a partir da geometria da malha. Faces planas compostas de três ou mais triângulos permanecerão planas.",
    "adjustments": "ajustes",
    "minSharpAngle": "ângulo agudo mínimo",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calcular curvatura",
    "calculateCurvature": "calcular curvatura",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "Curvatura é o inverso do raio de curvatura, e assinada tal que positivo é convexo e negativo é côncavo. Existem duas curvaturas principais ortogonais em qualquer ponto em um manifold, com uma máxima e a outra mínima. Curvatura Gaussiana é o produto delas, enquanto curvatura média é a soma delas. Isso as aproxima para cada vértice e as atribui como propriedades de vértice nos canais dados.",
    "gaussianIdx": "índice gaussiano",
    "meanIdx": "índice médio",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "refinar para tolerância",
    "refineToTolerance": "refinar para tolerância",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Aumenta a densidade da malha dividindo cada aresta em pedaços de tal forma que qualquer ponto nos triângulos resultantes esteja aproximadamente dentro da tolerância da superfície suavemente curvada definida pelos vetores tangentes. Isso significa que regiões de curvatura apertada serão divididas mais finamente do que regiões mais suaves. Se halfedgeTangents não estiverem presentes, o resultado será simplesmente uma cópia do original. Quads ignorarão sua bissetriz de triângulo interior.",
    "bitbybit.manifold.manifold.operations.refineToLength": "refinar para comprimento",
    "refineToLength": "refinar para comprimento",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Aumenta a densidade da malha dividindo cada aresta em pedaços de aproximadamente o comprimento de entrada. Vértices interiores são adicionados para manter o resto das arestas de triangulação também de aproximadamente o mesmo comprimento. Se halfedgeTangents estiverem presentes (por exemplo, do construtor Smooth()), os novos vértices serão movidos para a superfície interpolada de acordo com suas coordenadas baricêntricas.",
    "bitbybit.manifold.manifold.operations.refine": "refinar",
    "refine": "refinar",
    "bitbybit.manifold.manifold.operations.refine_description": "Aumenta a densidade da malha dividindo cada aresta em n pedaços. Por exemplo, com n = 2, cada triângulo será dividido em 4 triângulos. Estes serão todos coplanares (e não serão imediatamente colapsados) a menos que o MeshManifold tenha halfedgeTangents especificados (por exemplo, do construtor Smooth()), caso em que os novos vértices serão movidos para a superfície interpolada de acordo com suas coordenadas baricêntricas.",
    "bitbybit.manifold.manifold.operations.smoothOut": "suavizar",
    "smoothOut": "suavizar",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Suaviza o Manifold preenchendo os vetores halfedgeTangent. A geometria permanecerá inalterada até que Refine ou RefineToLength seja chamado para interpolar a superfície. Esta versão usa a geometria dos triângulos e pseudo-normais para definir os vetores tangentes.",
    "minSmoothness": "suavidade mínima",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "suavizar por normais",
    "smoothByNormals": "suavizar por normais",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Suaviza o Manifold preenchendo os vetores halfedgeTangent. A geometria permanecerá inalterada até que Refine ou RefineToLength seja chamado para interpolar a superfície. Esta versão usa as propriedades normais de vértice fornecidas para definir os vetores tangentes.",
    "bitbybit.manifold.manifold.transforms.scale3D": "escalar 3D",
    "scale3D": "escalar 3D",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Escala uma forma manifold com vetor 3D",
    "bitbybit.manifold.manifold.transforms.scale": "escalar",
    "bitbybit.manifold.manifold.transforms.scale_description": "Escala uma forma manifold com fator único",
    "bitbybit.manifold.manifold.transforms.mirror": "espelhar",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Espelha uma forma manifold sobre um plano definido por um vetor normal",
    "bitbybit.manifold.manifold.transforms.translate": "transladar",
    "bitbybit.manifold.manifold.transforms.translate_description": "Translada uma forma manifold ao longo do vetor",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "transladar por vetores",
    "translateByVectors": "transladar por vetores",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Translada uma forma manifold ao longo por múltiplos vetores",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "transladar xyz",
    "translateXYZ": "transladar xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Translada uma forma manifold ao longo de x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "rotacionar",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Rotaciona uma forma manifold ao longo do vetor contendo ângulos euler",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "rotacionar xyz",
    "rotateXYZ": "rotacionar xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Rotaciona uma forma manifold ao longo dos ângulos euler x y z",
    "bitbybit.manifold.manifold.transforms.transform": "transformar",
    "bitbybit.manifold.manifold.transforms.transform_description": "Transforma uma forma manifold usando a matriz de transformação 4x4",
    "matrix": "matriz",
    "Base.TransformMatrix": "matriz de transformação base",
    "bitbybit.manifold.manifold.transforms.transforms": "transformações",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Transforma uma forma manifold usando as matrizes de transformação 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "área de superfície",
    "evaluate": "avaliar",
    "surfaceArea": "área de superfície",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Obter área de superfície do manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volume",
    "volume": "volume",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Obter volume do manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "está vazio",
    "isEmpty": "está vazio",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Verificar se manifold contém triângulos",
    "bitbybit.manifold.manifold.evaluate.numVert": "número de vértices",
    "numVert": "número de vértices",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Obter número de vértices no manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "número de triângulos",
    "numTri": "número de triângulos",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Obter número de triângulos no manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "número de bordas",
    "numEdge": "número de bordas",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Obter número de arestas no manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "número de propriedades",
    "numProp": "número de propriedades",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Obter número de propriedades no manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "número de propriedades de vértices",
    "numPropVert": "número de propriedades de vértices",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "O número de vértices de propriedade no Manifold. Isso sempre será >= numVert, pois alguns vértices físicos podem ser duplicados para contabilizar diferentes propriedades em diferentes triângulos vizinhos.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "caixa delimitadora",
    "boundingBox": "caixa delimitadora",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Retorna a caixa delimitadora alinhada ao eixo de todos os vértices do Manifold.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolerância",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Retorna a tolerância dos vértices deste Manifold, que rastreia o erro de arredondamento aproximado sobre todas as transformações e operações que levaram a este estado. Quaisquer triângulos que sejam colineares dentro desta tolerância são considerados degenerados e removidos.",
    "bitbybit.manifold.manifold.evaluate.genus": "gênero",
    "genus": "gênero",
    "bitbybit.manifold.manifold.evaluate.genus_description": "O gênero é uma propriedade topológica do manifold, representando o número de alças. Uma esfera é 0, toro 1, etc. É significativo apenas para uma única malha, então é melhor chamar Decompose() primeiro.",
    "bitbybit.manifold.manifold.evaluate.minGap": "lacuna mínima",
    "minGap": "lacuna mínima",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Retorna o intervalo mínimo entre dois manifolds. Retorna um float entre 0 e searchLength.",
    "searchLength": "comprimento de busca",
    "bitbybit.manifold.manifold.evaluate.originalID": "id original",
    "originalID": "id original",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "Se esta malha for um original, isso retorna seu ID que pode ser referenciado por manifolds de produto. Se este manifold for um produto, isso retorna -1.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "seção transversal para polígonos",
    "crossSection": "seção transversal",
    "crossSectionToPolygons": "seção transversal para polígonos",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "transforma seção transversal em polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "seções transversais para polígonos",
    "crossSectionsToPolygons": "seções transversais para polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "transforma seções transversais em polígonos",
    "crossSections": "seções transversais",
    "bitbybit.manifold.crossSection.shapes.create": "criar",
    "bitbybit.manifold.crossSection.shapes.create_description": "Cria uma seção transversal 2d a partir de um conjunto de contornos (polígonos complexos). Uma operação de união booleana (com regra de preenchimento Positiva por padrão) é realizada para combinar polígonos sobrepostos e garantir que a Seção Transversal resultante esteja livre de interseções.",
    "Base.Vector2[][]": "array de vetor base 2",
    "fillRule": "regra de preenchimento",
    "fillRuleEnum": "enum de regra de preenchimento",
    "bitbybit.manifold.crossSection.shapes.square": "quadrado",
    "bitbybit.manifold.crossSection.shapes.square_description": "Cria uma seção transversal quadrada 2D",
    "bitbybit.manifold.crossSection.shapes.circle": "círculo",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Cria uma seção transversal circular 2D",
    "bitbybit.manifold.crossSection.shapes.rectangle": "retângulo",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Cria uma seção transversal retangular 2D",
    "bitbybit.manifold.crossSection.operations.hull": "casco",
    "bitbybit.manifold.crossSection.operations.hull_description": "Computa casco convexo para a seção transversal",
    "bitbybit.manifold.crossSection.operations.extrude": "extrudar",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Extruda a seção transversal para criar uma forma 3D",
    "nDivisions": "número de divisões",
    "twistDegrees": "graus de torção",
    "scaleTopX": "escala superior x",
    "scaleTopY": "escala superior y",
    "bitbybit.manifold.crossSection.operations.revolve": "revolver",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Revolve a seção transversal para criar uma forma 3D",
    "revolveDegrees": "graus de revolução",
    "matchProfile": "corresponder perfil",
    "bitbybit.manifold.crossSection.operations.offset": "deslocamento",
    "bitbybit.manifold.crossSection.operations.offset_description": "Desloca a seção transversal para criar uma nova seção transversal com um delta dado (usa algoritmo Clipper2 por trás).",
    "manifoldJoinTypeEnum": "enum de tipo de junção manifold",
    "miterLimit": "limite de esquadria",
    "bitbybit.manifold.crossSection.operations.simplify": "simplificar",
    "simplify": "simplificar",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Remove vértices dos contornos nesta Seção Transversal que estão a menos da distância epsilon especificada de uma linha imaginária que passa por seus dois vértices adjacentes. Vértices quase duplicados e pontos colineares serão removidos em epsilons mais baixos, com eliminação de segmentos de linha tornando-se cada vez mais agressiva com epsilons maiores. É recomendado aplicar esta função após Offset, para limpar quaisquer minúsculos segmentos de linha espúrios introduzidos que não melhoram as operações de offset a serem realizadas, o que agravaria o problema.",
    "epsilon": "épsilon",
    "bitbybit.manifold.crossSection.operations.compose": "compor",
    "bitbybit.manifold.crossSection.operations.compose_description": "Compõe múltiplas seções transversais ou polígonos em uma única seção transversal",
    "bitbybit.manifold.crossSection.operations.decompose": "decompor",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Decompõe seções transversais que estão topologicamente desconectadas, cada uma contendo um contorno externo com zero ou mais buracos.",
    "bitbybit.manifold.crossSection.booleans.subtract": "subtrair",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Subtrai duas seções transversais",
    "crossSection1": "seção transversal 1",
    "crossSection2": "seção transversal 2",
    "bitbybit.manifold.crossSection.booleans.add": "adicionar",
    "bitbybit.manifold.crossSection.booleans.add_description": "Adiciona duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.intersect": "interseccionar",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Intercepta duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "diferença de dois",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "diferença de duas seções transversais",
    "2 cross sections": "2 seções transversais",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "união de dois",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "união de duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "interseção de dois",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "interseção de duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.difference": "diferença",
    "bitbybit.manifold.crossSection.booleans.difference_description": "diferença de múltiplas seções transversais",
    "bitbybit.manifold.crossSection.booleans.union": "união",
    "bitbybit.manifold.crossSection.booleans.union_description": "união de múltiplas seções transversais",
    "bitbybit.manifold.crossSection.booleans.intersection": "interseção",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "interseção de múltiplas seções transversais",
    "bitbybit.manifold.crossSection.transforms.scale2D": "escalar 2D",
    "scale2D": "escalar 2D",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Escala uma forma de seção transversal com vetor 2D",
    "bitbybit.manifold.crossSection.transforms.scale": "escalar",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Escala uma forma de seção transversal com fator único",
    "bitbybit.manifold.crossSection.transforms.mirror": "espelhar",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Espelha uma forma de seção transversal sobre um plano definido por um vetor normal",
    "bitbybit.manifold.crossSection.transforms.translate": "transladar",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Translada uma forma de seção transversal ao longo do vetor",
    "bitbybit.manifold.crossSection.transforms.translateXY": "transladar xy",
    "translateXY": "transladar xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Translada uma forma de seção transversal ao longo de x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "rotacionar",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Rotaciona uma forma de seção transversal ao longo dos graus contidos",
    "degrees": "graus",
    "bitbybit.manifold.crossSection.transforms.transform": "transformar",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Transforma uma forma de seção transversal usando a matriz de transformação 3x3",
    "Base.TransformMatrix3x3": "matriz de transformação base 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "área",
    "area": "área",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Obter área da seção transversal",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "está vazio",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Verificar se seção transversal está vazia",
    "bitbybit.manifold.crossSection.evaluate.numVert": "número de vértices",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Obter número de vértices na seção transversal",
    "bitbybit.manifold.crossSection.evaluate.numContour": "número de contornos",
    "numContour": "número de contornos",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Obter número de contornos na seção transversal",
    "bitbybit.manifold.crossSection.evaluate.bounds": "limites",
    "bounds": "limites",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Obter os limites do contorno como um retângulo. A saída é dada em dois pontos vec2 no array. O primeiro array é o ponto min e o segundo array é o ponto max.",
    "bitbybit.manifold.mesh.operations.merge": "mesclar",
    "merge": "mesclar",
    "bitbybit.manifold.mesh.operations.merge_description": "Atualiza os vetores mergeFromVert e mergeToVert a fim de criar um sólido manifold. Se o MeshGL já for manifold, nenhuma mudança ocorrerá e a função retornará falso. Caso contrário, isso mesclará verts ao longo de arestas abertas dentro da tolerância (o máximo da tolerância MeshGL e a tolerância da caixa delimitadora base), mantendo qualquer um dos vetores de mesclagem existentes. Não há garantia de que o resultado seja manifold - esta é uma função auxiliar de melhor esforço projetada principalmente para ajudar no caso onde um MeshGL multi-material manifold foi produzido, mas seus vetores de mesclagem foram perdidos devido a uma ida e volta através de um formato de arquivo. Construir um Manifold a partir do resultado relatará um Status se não for manifold.",
    "bitbybit.manifold.mesh.evaluate.position": "posição",
    "bitbybit.manifold.mesh.evaluate.position_description": "Obter posição no índice de vértice da malha",
    "vertexIndex": "índice de vértice",
    "bitbybit.manifold.mesh.evaluate.verts": "vértices",
    "verts": "vértices",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Obtém os três índices de vértice deste triângulo em ordem CCW.",
    "triangleIndex": "índice de triângulo",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangente",
    "tangent": "tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Obtém o vetor tangente começando em verts(tri)[j] apontando para o próximo ponto Bezier ao longo da aresta CCW. O quarto valor é seu peso.",
    "halfEdgeIndex": "índice de meia-borda",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Obtém quaisquer outras propriedades associadas a este vértice.",
    "bitbybit.manifold.mesh.evaluate.transform": "transformar",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Obtém a transformação de matriz 4x4 coluna-principal da malha original para estes triângulos relacionados.",
    "bitbybit.manifold.mesh.evaluate.numProp": "número de propriedades",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Número de propriedades por vértice, sempre >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "número de vértices",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Número de vértices de propriedade",
    "bitbybit.manifold.mesh.evaluate.numTri": "número de triângulos",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Obter número de triângulos na malha",
    "bitbybit.manifold.mesh.evaluate.numRun": "número de execuções",
    "numRun": "número de execuções",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Número de execuções de triângulo. Cada execução de triângulo é um conjunto de triângulos consecutivos que todos vêm da mesma instância da mesma malha de entrada.",
    "bitbybit.logic.boolean": "booleano",
    "logic": "lógica",
    "bitbybit.logic.boolean_description": "Cria e retorna um valor booleano (passagem para entrada booleana). Exemplo: true → true, false → false",
    "bitbybit.logic.randomBooleans": "booleanos aleatórios",
    "randomBooleans": "booleanos aleatórios",
    "bitbybit.logic.randomBooleans_description": "Gera uma lista booleana aleatória onde cada valor tem uma chance limite de ser verdadeiro. Exemplo: comprimento=5, limite=0.7 → pode produzir [true, true, false, true, true]",
    "trueThreshold": "limiar de verdadeiro",
    "bitbybit.logic.twoThresholdRandomGradient": "gradiente aleatório com dois limiares",
    "twoThresholdRandomGradient": "gradiente aleatório com dois limiares",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Converte números para booleanos usando dois limites com randomização de gradiente entre eles. Valores abaixo de limiteVerdadeiro → sempre true, acima de limiteFalso → sempre false. Entre limites → gradiente de probabilidade (mais perto do limite falso = maior chance de falso). Exemplo: [0.1, 0.4, 0.6, 0.9] com limites [0.3, 0.7] → [true, gradiente, gradiente, false]",
    "numbers": "números",
    "thresholdTotalTrue": "limiar total de verdadeiro",
    "thresholdTotalFalse": "limiar total de falso",
    "nrLevels": "número de níveis",
    "bitbybit.logic.thresholdBooleanList": "lista booleana com limiar",
    "thresholdBooleanList": "lista booleana com limiar",
    "bitbybit.logic.thresholdBooleanList_description": "Converte números para booleanos baseado em um limite (abaixo do limite → true, acima → false). Pode ser invertido para virar a lógica. Exemplo: [0.3, 0.7, 0.5] com limite=0.6 → [true, false, true]",
    "threshold": "limiar",
    "bitbybit.logic.thresholdGapsBooleanList": "lista booleana com lacunas de limiar",
    "thresholdGapsBooleanList": "lista booleana com lacunas de limiar",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Converte números para booleanos usando múltiplos limites de intervalo (lacunas definem intervalos verdadeiros). Valores dentro de qualquer intervalo de lacuna → true, fora de todas as lacunas → false. Pode ser invertido. Exemplo: [0.2, 0.5, 0.8] com lacunas [[0.3, 0.6], [0.7, 0.9]] → [false, true, true]",
    "gapThresholds": "limiares de lacunas",
    "Base.Vector2[]": "array de vetor base 2",
    "bitbybit.logic.not": "não",
    "not": "não",
    "bitbybit.logic.not_description": "Aplica operador NOT para inverter um valor booleano. Exemplo: true → false, false → true",
    "bitbybit.logic.notList": "lista não",
    "notList": "lista não",
    "bitbybit.logic.notList_description": "Aplica operador NOT para inverter todos os valores booleanos em uma lista. Exemplo: [true, false, true] → [false, true, false]",
    "bitbybit.logic.compare": "comparar",
    "compare": "comparar",
    "bitbybit.logic.compare_description": "Compara dois valores usando vários operadores (==, !=, ===, !==, <, <=, >, >=). Exemplo: 5 > 3 → true, 'ola' === 'mundo' → false",
    "operator": "operador",
    "BooleanOperatorsEnum": "enum de operadores booleanos",
    "bitbybit.logic.valueGate": "portão de valor",
    "valueGate": "portão de valor",
    "bitbybit.logic.valueGate_description": "Passa condicionalmente um valor se booleano for verdadeiro, caso contrário retorna indefinido. Exemplo: valor=42, booleano=true → 42, valor=42, booleano=false → indefinido",
    "bitbybit.logic.firstDefinedValueGate": "primeiro portão de valor definido",
    "firstDefinedValueGate": "primeiro portão de valor definido",
    "bitbybit.logic.firstDefinedValueGate_description": "Retorna o primeiro valor definido (não-indefinido) de duas opções (padrão fallback). Exemplo: valor1=42, valor2=10 → 42, valor1=indefinido, valor2=10 → 10",
    "value1": "valor 1",
    "value2": "valor 2",
    "bitbybit.math.number": "número",
    "math": "matemática",
    "bitbybit.math.number_description": "Cria e retorna um valor numérico (passagem para entrada numérica). Exemplo: Entrada 42 → 42, Entrada 3.14 → 3.14",
    "bitbybit.math.twoNrOperation": "operação com dois números",
    "twoNrOperation": "operação com dois números",
    "bitbybit.math.twoNrOperation_description": "Realiza operações aritméticas básicas em dois números (adicionar, subtrair, multiplicar, dividir, potência, módulo). Exemplo: 5 + 3 → 8, 10 % 3 → 1, 2 ^ 3 → 8",
    "operation": "operação",
    "mathTwoNrOperatorEnum": "enum de operador matemático com dois números",
    "bitbybit.math.modulus": "módulo",
    "modulus": "módulo",
    "bitbybit.math.modulus_description": "Calcula o resto após divisão (operação módulo). Exemplo: 10 % 3 → 1, 17 % 5 → 2",
    "bitbybit.math.roundToDecimals": "arredondar para decimais",
    "roundToDecimals": "arredondar para decimais",
    "bitbybit.math.roundToDecimals_description": "Arredonda um número para casas decimais especificadas. Exemplo: 1.32156 com 3 decimais retorna 1.322",
    "decimalPlaces": "casas decimais",
    "bitbybit.math.oneNrOperation": "operação com um número",
    "oneNrOperation": "operação com um número",
    "bitbybit.math.oneNrOperation_description": "Realiza operações matemáticas em um único número (absoluto, negar, raiz quadrada, funções trigonométricas, logaritmos, etc.). Exemplo: sqrt(5) → 2.236, abs(-3) → 3, sin(π2) → 1",
    "mathOneNrOperatorEnum": "enum de operador matemático com um número",
    "bitbybit.math.remap": "remapear",
    "remap": "remapear",
    "bitbybit.math.remap_description": "Mapeia um número de um intervalo para outro intervalo proporcionalmente. Exemplo: 5 de [0,10] para [0,100] → 50, 0.5 de [0,1] para [-10,10] → 0",
    "fromLow": "de baixo",
    "fromHigh": "de alto",
    "toLow": "para baixo",
    "toHigh": "para alto",
    "bitbybit.math.random": "aleatório",
    "random": "aleatório",
    "bitbybit.math.random_description": "Gera um número decimal aleatório entre 0 (inclusivo) e 1 (exclusivo). Exemplo: Saídas como 0.342, 0.891, ou qualquer valor em [0, 1)",
    "generate": "gerar",
    "bitbybit.math.randomNumber": "número aleatório",
    "randomNumber": "número aleatório",
    "bitbybit.math.randomNumber_description": "Gera um número aleatório dentro de um intervalo especificado (baixo a alto). Exemplo: Intervalo [0, 10] → saídas como 3.7, 8.2, ou qualquer valor entre 0 e 10",
    "low": "baixo",
    "high": "alto",
    "bitbybit.math.randomNumbers": "números aleatórios",
    "randomNumbers": "números aleatórios",
    "bitbybit.math.randomNumbers_description": "Gera múltiplos números aleatórios dentro de um intervalo especificado. Exemplo: Intervalo [0, 10] com 3 itens → [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "Retorna a constante matemática π (pi) ≈ 3.14159. Exemplo: Saídas 3.141592653589793",
    "bitbybit.math.toFixed": "para fixo",
    "toFixed": "para fixo",
    "bitbybit.math.toFixed_description": "Formata um número como uma string com um número fixo de casas decimais (sempre mostra zeros finais). Exemplo: 3.14159 com 2 decimais → '3.14', 5 com 3 decimais → '5.000'",
    "bitbybit.math.add": "somar",
    "bitbybit.math.add_description": "Adiciona dois números juntos. Exemplo: 5 + 3 → 8, -2 + 7 → 5",
    "basics": "básicos",
    "bitbybit.math.subtract": "subtrair",
    "bitbybit.math.subtract_description": "Subtrai o segundo número do primeiro. Exemplo: 10 - 3 → 7, 5 - 8 → -3",
    "bitbybit.math.multiply": "multiplicar",
    "bitbybit.math.multiply_description": "Multiplica dois números juntos. Exemplo: 5 × 3 → 15, -2 × 4 → -8",
    "bitbybit.math.divide": "dividir",
    "divide": "dividir",
    "bitbybit.math.divide_description": "Divide o primeiro número pelo segundo. Exemplo: 10 ÷ 2 → 5, 7 ÷ 2 → 3.5",
    "bitbybit.math.power": "potência",
    "power": "potência",
    "bitbybit.math.power_description": "Eleva o primeiro número à potência do segundo (exponenciação). Exemplo: 2³ → 8, 5² → 25, 10⁻¹ → 0.1",
    "bitbybit.math.sqrt": "raiz quadrada",
    "sqrt": "raiz quadrada",
    "bitbybit.math.sqrt_description": "Calcula a raiz quadrada de um número. Exemplo: √9 → 3, √2 → 1.414, √16 → 4",
    "bitbybit.math.abs": "absoluto",
    "abs": "absoluto",
    "bitbybit.math.abs_description": "Retorna o valor absoluto (remove sinal negativo, sempre positivo ou zero). Exemplo: |-5| → 5, |3| → 3, |0| → 0",
    "bitbybit.math.round": "arredondar",
    "round": "arredondar",
    "bitbybit.math.round_description": "Arredonda um número para o inteiro mais próximo. Exemplo: 3.7 → 4, 2.3 → 2, 5.5 → 6",
    "bitbybit.math.floor": "piso",
    "floor": "piso",
    "bitbybit.math.floor_description": "Arredonda um número para baixo para o inteiro mais próximo (em direção ao infinito negativo). Exemplo: 3.7 → 3, -2.3 → -3, 5 → 5",
    "bitbybit.math.ceil": "teto",
    "ceil": "teto",
    "bitbybit.math.ceil_description": "Arredonda um número para cima para o inteiro mais próximo (em direção ao infinito positivo). Exemplo: 3.2 → 4, -2.8 → -2, 5 → 5",
    "bitbybit.math.negate": "negar",
    "negate": "negar",
    "bitbybit.math.negate_description": "Nega um número (inverte seu sinal: positivo torna-se negativo, negativo torna-se positivo). Exemplo: 5 → -5, -3 → 3, 0 → 0",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "Calcula o logaritmo natural (base e) de um número. Exemplo: ln(2.718) → ~1, ln(7.389) → ~2, ln(1) → 0",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "Calcula o logaritmo base 10 de um número. Exemplo: log₁₀(100) → 2, log₁₀(1000) → 3, log₁₀(10) → 1",
    "bitbybit.math.tenPow": "potência de dez",
    "tenPow": "potência de dez",
    "bitbybit.math.tenPow_description": "Eleva 10 à potência do número de entrada. Exemplo: 10² → 100, 10³ → 1000, 10⁻¹ → 0.1",
    "bitbybit.math.sin": "seno",
    "sin": "seno",
    "bitbybit.math.sin_description": "Calcula o seno de um ângulo em radianos. Exemplo: sin(0) → 0, sin(π2) → 1, sin(π) → ~0",
    "bitbybit.math.cos": "cosseno",
    "cos": "cosseno",
    "bitbybit.math.cos_description": "Calcula o cosseno de um ângulo em radianos. Exemplo: cos(0) → 1, cos(π2) → ~0, cos(π) → -1",
    "bitbybit.math.tan": "tangente",
    "tan": "tangente",
    "bitbybit.math.tan_description": "Calcula a tangente de um ângulo em radianos. Exemplo: tan(0) → 0, tan(π4) → ~1, tan(π2) → infinito",
    "bitbybit.math.asin": "arcoseno",
    "asin": "arcoseno",
    "bitbybit.math.asin_description": "Calcula o arco seno (seno inverso) em radianos, retorna ângulo cujo seno é a entrada. Exemplo: asin(0) → 0, asin(1) → π2 (~1.57), asin(0.5) → π6 (~0.524)",
    "bitbybit.math.acos": "arcocosseno",
    "acos": "arcocosseno",
    "bitbybit.math.acos_description": "Calcula o arco cosseno (cosseno inverso) em radianos, retorna ângulo cujo cosseno é a entrada. Exemplo: acos(1) → 0, acos(0) → π2 (~1.57), acos(-1) → π (~3.14)",
    "bitbybit.math.atan": "arcotangente",
    "atan": "arcotangente",
    "bitbybit.math.atan_description": "Calcula o arco tangente (tangente inversa) em radianos, retorna ângulo cuja tangente é a entrada. Exemplo: atan(0) → 0, atan(1) → π4 (~0.785), atan(-1) → -π4",
    "bitbybit.math.exp": "exponencial",
    "exp": "exponencial",
    "bitbybit.math.exp_description": "Calcula e elevado à potência da entrada (função exponencial). Exemplo: e⁰ → 1, e¹ → ~2.718, e² → ~7.389",
    "bitbybit.math.degToRad": "graus para radianos",
    "degToRad": "graus para radianos",
    "bitbybit.math.degToRad_description": "Converte um ângulo de graus para radianos. Exemplo: 180° → π (~3.14159), 90° → π2 (~1.5708), 360° → 2π",
    "bitbybit.math.radToDeg": "radianos para graus",
    "radToDeg": "radianos para graus",
    "bitbybit.math.radToDeg_description": "Converte um ângulo de radianos para graus. Exemplo: π → 180°, π2 → 90°, 2π → 360°",
    "bitbybit.math.ease": "suavizar",
    "bitbybit.math.ease_description": "Aplica uma função de suavização para interpolar suavemente entre valores mín e máx. Exemplo: x=0.5 de [0,100] com easeInQuad → aplica curva de aceleração quadrática Útil para animações suaves com várias curvas de aceleração/desaceleração.",
    "easeEnum": "enum de suavização",
    "bitbybit.lists.getItem": "obter item",
    "lists": "listas",
    "getItem": "obter item",
    "bitbybit.lists.getItem_description": "Obtém um item da lista em uma posição específica usando indexação baseada em zero. Exemplo: De [10, 20, 30, 40], obter índice 2 retorna 30",
    "list": "lista",
    "bitbybit.lists.randomGetThreshold": "obter aleatoriamente com limiar",
    "randomGetThreshold": "obter aleatoriamente com limiar",
    "bitbybit.lists.randomGetThreshold_description": "Mantém aleatoriamente itens da lista com base em um limite de probabilidade (0 a 1). Exemplo: De [1, 2, 3, 4, 5] com limite 0.5, pode retornar [1, 3, 5] (50% de chance para cada item)",
    "bitbybit.lists.getSubList": "obter sublista",
    "getSubList": "obter sublista",
    "bitbybit.lists.getSubList_description": "Extrai uma porção da lista entre posições de início e fim (fim é exclusivo). Exemplo: De [10, 20, 30, 40, 50] com início=1 e fim=4, retorna [20, 30, 40]",
    "indexStart": "índice inicial",
    "indexEnd": "índice final",
    "bitbybit.lists.getNthItem": "obter enésimo item",
    "getNthItem": "obter enésimo item",
    "bitbybit.lists.getNthItem_description": "Obtém cada enésimo item da lista, começando de uma posição de deslocamento opcional. Exemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] com enésimo=3 e deslocamento=0, retorna [0, 3, 6] Exemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] com enésimo=2 e deslocamento=1, retorna [1, 3, 5, 7]",
    "nth": "enésimo",
    "bitbybit.lists.getByPattern": "obter por padrão",
    "getByPattern": "obter por padrão",
    "bitbybit.lists.getByPattern_description": "Filtra itens da lista usando um padrão verdadeirofalso repetitivo. Exemplo: De [0, 1, 2, 3, 4, 5] com padrão [true, true, false], retorna [0, 1, 3, 4] (mantém itens onde padrão é verdadeiro)",
    "pattern": "padrão",
    "bitbybit.lists.mergeElementsOfLists": "mesclar elementos de listas",
    "mergeElementsOfLists": "mesclar elementos de listas",
    "bitbybit.lists.mergeElementsOfLists_description": "Mescla elementos de múltiplas listas em um nível de aninhamento específico, agrupando elementos por posição. Exemplo: De [[0, 1, 2], [3, 4, 5]] no nível 0, retorna [[0, 3], [1, 4], [2, 5]]",
    "level": "nível",
    "bitbybit.lists.getLongestListLength": "obter comprimento da lista mais longa",
    "getLongestListLength": "obter comprimento da lista mais longa",
    "bitbybit.lists.getLongestListLength_description": "Encontra o comprimento da lista mais longa entre múltiplas listas. Exemplo: De [[1, 2], [3, 4, 5, 6], [7]], retorna 4 (comprimento de [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "inverter",
    "bitbybit.lists.reverse_description": "Inverte a ordem dos itens na lista. Exemplo: De [1, 2, 3, 4, 5], retorna [5, 4, 3, 2, 1]",
    "bitbybit.lists.flipLists": "inverter listas",
    "flipLists": "inverter listas",
    "bitbybit.lists.flipLists_description": "Transpõe uma lista 2D trocando linhas e colunas (todas as sublistas devem ter comprimento igual). Exemplo: De [[0, 1, 2], [3, 4, 5]], retorna [[0, 3], [1, 4], [2, 5]]",
    "bitbybit.lists.groupNth": "agrupar enésimo",
    "groupNth": "agrupar enésimo",
    "bitbybit.lists.groupNth_description": "Divide a lista em listas menores de n elementos cada. Exemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] com n=3, retorna [[0, 1, 2], [3, 4, 5], [6, 7, 8]] Exemplo: De [0, 1, 2, 3, 4] com n=2 e keepRemainder=true, retorna [[0, 1], [2, 3], [4]]",
    "nrElements": "número de elementos",
    "keepRemainder": "manter resto",
    "bitbybit.lists.getListDepth": "obter profundidade da lista",
    "getListDepth": "obter profundidade da lista",
    "bitbybit.lists.getListDepth_description": "Determina o nível máximo de aninhamento (profundidade) de uma estrutura de lista. Exemplo: [1, 2, 3] tem profundidade 1, [[1, 2], [3, 4]] tem profundidade 2, [[[1]]] tem profundidade 3",
    "bitbybit.lists.listLength": "comprimento da lista",
    "listLength": "comprimento da lista",
    "bitbybit.lists.listLength_description": "Retorna o número de itens na lista. Exemplo: [10, 20, 30, 40, 50] retorna 5, [] retorna 0",
    "bitbybit.lists.addItemAtIndex": "adicionar item no índice",
    "addItemAtIndex": "adicionar item no índice",
    "bitbybit.lists.addItemAtIndex_description": "Insere um item em uma posição específica na lista. Exemplo: Em [10, 20, 30, 40], adicionar 99 no índice 2 resulta em [10, 20, 99, 30, 40]",
    "item": "item",
    "bitbybit.lists.addItemAtIndexes": "adicionar item nos índices",
    "addItemAtIndexes": "adicionar item nos índices",
    "bitbybit.lists.addItemAtIndexes_description": "Insere o mesmo item em múltiplas posições especificadas na lista. Exemplo: Em [10, 20, 30], adicionar 99 nos índices [0, 2] resulta em [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "adicionar itens nos índices",
    "addItemsAtIndexes": "adicionar itens nos índices",
    "bitbybit.lists.addItemsAtIndexes_description": "Insere múltiplos itens em posições correspondentes (primeiro item no primeiro índice, segundo item no segundo índice, etc.). Exemplo: Em [10, 20, 30], adicionar itens [88, 99] nos índices [1, 2] resulta em [10, 88, 20, 99, 30]",
    "items": "itens",
    "bitbybit.lists.removeItemAtIndex": "remover item no índice",
    "removeItemAtIndex": "remover item no índice",
    "bitbybit.lists.removeItemAtIndex_description": "Remove o item em uma posição específica na lista. Exemplo: De [10, 20, 30, 40, 50], remover índice 2 resulta em [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "remover itens nos índices",
    "removeItemsAtIndexes": "remover itens nos índices",
    "bitbybit.lists.removeItemsAtIndexes_description": "Remove itens em múltiplas posições especificadas da lista. Exemplo: De [10, 20, 30, 40, 50], remover índices [1, 3] resulta em [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "remover todos os itens",
    "removeAllItems": "remover todos os itens",
    "bitbybit.lists.removeAllItems_description": "Limpa todos os itens da lista, resultando em uma lista vazia. Exemplo: De [10, 20, 30, 40], retorna []",
    "bitbybit.lists.removeNthItem": "remover enésimo item",
    "removeNthItem": "remover enésimo item",
    "bitbybit.lists.removeNthItem_description": "Remove cada enésimo item da lista, começando de uma posição de deslocamento opcional. Exemplo: De [0, 1, 2, 3, 4, 5, 6, 7, 8] com enésimo=3 e deslocamento=0, retorna [1, 2, 4, 5, 7, 8] (remove 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "remover aleatoriamente com limiar",
    "randomRemoveThreshold": "remover aleatoriamente com limiar",
    "bitbybit.lists.randomRemoveThreshold_description": "Aleatoriamente remove itens da lista baseado em um limite de probabilidade (0 a 1). Exemplo: De [1, 2, 3, 4, 5] com limite 0.5, pode retornar [2, 4] (50% de chance de remover cada item)",
    "bitbybit.lists.removeDuplicateNumbers": "remover números duplicados",
    "removeDuplicateNumbers": "remover números duplicados",
    "bitbybit.lists.removeDuplicateNumbers_description": "Remove números duplicados da lista, mantendo apenas a primeira ocorrência de cada valor. Exemplo: De [1, 2, 3, 2, 4, 3, 5], retorna [1, 2, 3, 4, 5]",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "remover números duplicados com tolerância",
    "removeDuplicateNumbersTolerance": "remover números duplicados com tolerância",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Remove números duplicados que estão dentro de um intervalo de tolerância especificado um do outro. Exemplo: De [1.0, 1.001, 2.0, 2.002, 3.0] com tolerância 0.01, retorna [1.0, 2.0, 3.0]",
    "bitbybit.lists.addItem": "adicionar item",
    "addItem": "adicionar item",
    "bitbybit.lists.addItem_description": "Anexa um item ao final da lista. Exemplo: A [10, 20, 30], adicionar 40 resulta em [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "inserir item no início",
    "prependItem": "inserir item no início",
    "bitbybit.lists.prependItem_description": "Adiciona um item ao início da lista. Exemplo: A [10, 20, 30], prefixar 5 resulta em [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "adicionar item no início ou fim",
    "addItemFirstLast": "adicionar item no início ou fim",
    "bitbybit.lists.addItemFirstLast_description": "Adiciona um item ou no início ou no fim da lista baseado no parâmetro de posição. Exemplo: A [10, 20, 30], adicionar 5 em 'first' resulta em [5, 10, 20, 30], em 'last' resulta em [10, 20, 30, 5]",
    "firstLastEnum": "enum de primeiro ou último",
    "bitbybit.lists.createEmptyList": "lista vazia",
    "createEmptyList": "lista vazia",
    "bitbybit.lists.createEmptyList_description": "Cria uma nova lista vazia sem itens. Exemplo: Retorna []",
    "bitbybit.lists.repeat": "repetir",
    "repeat": "repetir",
    "bitbybit.lists.repeat_description": "Cria uma nova lista repetindo um item um número especificado de vezes. Exemplo: Repetir 5 três vezes retorna [5, 5, 5]",
    "times": "vezes",
    "bitbybit.lists.repeatInPattern": "repetir em padrão",
    "repeatInPattern": "repetir em padrão",
    "bitbybit.lists.repeatInPattern_description": "Repete um padrão de itens ciclicamente até atingir um comprimento de lista alvo. Exemplo: Padrão [1, 2, 3] com comprimento 7 retorna [1, 2, 3, 1, 2, 3, 1]",
    "lengthLimit": "limite de comprimento",
    "bitbybit.lists.sortNumber": "ordenar número",
    "sortNumber": "ordenar número",
    "bitbybit.lists.sortNumber_description": "Ordena números em ordem ascendente (menor para maior) ou descendente (maior para menor). Exemplo: [5, 2, 8, 1, 9] ascendente retorna [1, 2, 5, 8, 9], descendente retorna [9, 8, 5, 2, 1]",
    "sorting": "ordenação",
    "orderAsc": "ordem ascendente",
    "bitbybit.lists.sortTexts": "ordenar textos",
    "sortTexts": "ordenar textos",
    "bitbybit.lists.sortTexts_description": "Ordena strings de texto alfabeticamente em ordem ascendente (A a Z) ou descendente (Z a A). Exemplo: ['cao', 'maca', 'gato', 'banana'] ascendente retorna ['banana', 'cao', 'gato', 'maca']",
    "bitbybit.lists.sortByPropValue": "ordenar por valor de propriedade",
    "sortByPropValue": "ordenar por valor de propriedade",
    "bitbybit.lists.sortByPropValue_description": "Ordena objetos comparando valores numéricos de uma propriedade especificada. Exemplo: [{age: 30}, {age: 20}, {age: 25}] ordenado por 'age' ascendente retorna [{age: 20}, {age: 25}, {age: 30}]",
    "property": "propriedade",
    "bitbybit.color.hexColor": "cor hexadecimal",
    "hexColor": "cor hexadecimal",
    "bitbybit.color.hexColor_description": "Cria e retorna uma string de cor hex (pass-through para entrada de cor). Exemplo: '#FF5733' → '#FF5733'",
    "bitbybit.color.hexToRgb": "hexadecimal para RGB",
    "hexToRgb": "hexadecimal para RGB",
    "bitbybit.color.hexToRgb_description": "Converte cor hex para objeto RGB com valores r, g, b (intervalo 0-255). Exemplo: '#FF5733' → {r: 255, g: 87, b: 51}",
    "convert": "converter",
    "bitbybit.color.rgbToHex": "RGB para hexadecimal",
    "rgbToHex": "RGB para hexadecimal",
    "bitbybit.color.rgbToHex_description": "Converte valores RGB para string de cor hex (suporta intervalos min/max personalizados, auto-remapeia para 0-255). Exemplo: r=255, g=87, b=51 com intervalo [0,255] → '#ff5733' Exemplo: r=1, g=0.5, b=0.2 com intervalo [0,1] → '#ff7f33'",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "objeto RGB para hexadecimal",
    "rgbObjToHex": "objeto RGB para hexadecimal",
    "bitbybit.color.rgbObjToHex_description": "Converte objeto RGB para string de cor hex (suporta intervalos min/max personalizados). Exemplo: {r: 1, g: 0.5, b: 0.2} com intervalo [0,1] → '#ff7f33'",
    "rgb": "RGB",
    "Base.ColorRGB": "cor base RGB",
    "bitbybit.color.hexToRgbMapped": "hexadecimal para RGB mapeado",
    "hexToRgbMapped": "hexadecimal para RGB mapeado",
    "bitbybit.color.hexToRgbMapped_description": "Converte cor hex para RGB e remapeia valores para um intervalo personalizado. Exemplo: '#FF5733' mapeado para [0,1] → {r: 1, g: 0.341, b: 0.2} Exemplo: '#FF5733' mapeado para [0,100] → {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "obter parâmetro vermelho",
    "getRedParam": "obter parâmetro vermelho",
    "bitbybit.color.getRedParam_description": "Extrai o valor do canal vermelho da cor hex (pode ser mapeado para intervalo personalizado). Exemplo: '#FF5733' com intervalo [0,1] → 1",
    "hex to": "hexadecimal para",
    "bitbybit.color.getGreenParam": "obter parâmetro verde",
    "getGreenParam": "obter parâmetro verde",
    "bitbybit.color.getGreenParam_description": "Extrai o valor do canal verde da cor hex (pode ser mapeado para intervalo personalizado). Exemplo: '#FF5733' com intervalo [0,1] → 0.341",
    "bitbybit.color.getBlueParam": "obter parâmetro azul",
    "getBlueParam": "obter parâmetro azul",
    "bitbybit.color.getBlueParam_description": "Extrai o valor do canal azul da cor hex (pode ser mapeado para intervalo personalizado). Exemplo: '#FF5733' com intervalo [0,1] → 0.2",
    "bitbybit.color.rgbToRed": "RGB para vermelho",
    "rgbToRed": "RGB para vermelho",
    "bitbybit.color.rgbToRed_description": "Extrai o valor do canal vermelho do objeto RGB. Exemplo: {r: 255, g: 87, b: 51} → 255",
    "rgb to": "RGB para",
    "bitbybit.color.rgbToGreen": "RGB para verde",
    "rgbToGreen": "RGB para verde",
    "bitbybit.color.rgbToGreen_description": "Extrai o valor do canal verde do objeto RGB. Exemplo: {r: 255, g: 87, b: 51} → 87",
    "bitbybit.color.rgbToBlue": "RGB para azul",
    "rgbToBlue": "RGB para azul",
    "bitbybit.color.rgbToBlue_description": "Extrai o valor do canal azul do objeto RGB. Exemplo: {r: 255, g: 87, b: 51} → 51",
    "bitbybit.color.invert": "inverter",
    "invert": "inverter",
    "bitbybit.color.invert_description": "Inverte uma cor hex (vira canais RGB: 255-r, 255-g, 255-b). Com blackAndWhite=true → retorna '#000000' ou '#ffffff' baseado no brilho. Exemplo: '#FF5733' → '#00a8cc', '#FF5733' com blackAndWhite=true → '#ffffff'",
    "blackAndWhite": "preto e branco",
    "bitbybit.text.create": "criar",
    "bitbybit.text.create_description": "Cria e retorna uma string de texto (pass-through para entrada de texto). Exemplo: texto='Olá Mundo' → 'Olá Mundo'",
    "bitbybit.text.split": "dividir",
    "bitbybit.text.split_description": "Divide texto em múltiplos pedaços usando uma string separadora. Exemplo: texto='maca,banana,cereja', separador=',' → ['maca', 'banana', 'cereja']",
    "separator": "separador",
    "bitbybit.text.replaceAll": "substituir tudo",
    "replaceAll": "substituir tudo",
    "bitbybit.text.replaceAll_description": "Substitui todas as ocorrências de uma string de busca por uma string de substituição. Exemplo: texto='ola ola', busca='ola', substituirPor='oi' → 'oi oi'",
    "search": "buscar",
    "replaceWith": "substituir por",
    "bitbybit.text.join": "unir",
    "join": "unir",
    "bitbybit.text.join_description": "Une múltiplos itens em uma única string de texto usando um separador. Exemplo: lista=['maca', 'banana', 'cereja'], separador=', ' → 'maca, banana, cereja'",
    "string[]": "array de strings",
    "bitbybit.text.toString": "para string",
    "toString": "para string",
    "bitbybit.text.toString_description": "Transformar qualquer item em texto",
    "bitbybit.text.toStringEach": "para string cada",
    "toStringEach": "para string cada",
    "bitbybit.text.toStringEach_description": "Transformar cada item na lista em texto",
    "bitbybit.text.format": "formatar",
    "format": "formatar",
    "bitbybit.text.format_description": "Formata texto com valores de espaço reservado usando sintaxe {0}, {1}, etc. Exemplo: texto='Ponto: ({0}, {1})', values=[10, 5] → 'Ponto: (10, 5)'",
    "values": "valores",
    "bitbybit.text.vectorChar": "caractere vetorial",
    "vectorChar": "caractere vetorial",
    "bitbybit.text.vectorChar_description": "Converte um caractere em caminhos vetoriais (polilinhas) com dados de largura e altura para renderização. Usa fonte de traço simplex para gerar segmentos de linha 2D representando a forma do caractere. Exemplo: char='A', altura=10 → {width:8, height:10, paths:[[pontos formando forma A]]}",
    "char": "caractere",
    "bitbybit.text.vectorText": "texto vetorial",
    "vectorText": "texto vetorial",
    "bitbybit.text.vectorText_description": "Converte texto multi-linha em caminhos vetoriais (polilinhas) com controles de alinhamento e espaçamento. Suporta quebras de linha, espaçamento entre letras, espaçamento entre linhas, alinhamento horizontal e centralização de origem. Exemplo: texto='Olá Mundo', altura=10, alinhar=centro → [{chars linha1}, {chars linha2}]",
    "bitbybit.dates.toDateString": "para string de data",
    "dates": "datas",
    "toDateString": "para string de data",
    "bitbybit.dates.toDateString_description": "Converte data para string de data legível (exclui hora). Exemplo: Date(2024,0,15,14,30) → 'Seg Jan 15 2024'",
    "date": "data",
    "Date": "data",
    "bitbybit.dates.toISOString": "para string ISO",
    "toISOString": "para string ISO",
    "bitbybit.dates.toISOString_description": "Converte data para string no formato ISO 8601 (formato padrão para APIs e troca de dados). Exemplo: Date(2024,0,15,14,30,45) → '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "para JSON",
    "toJSON": "para JSON",
    "bitbybit.dates.toJSON_description": "Converte data para string compatível com JSON (igual ao formato ISO, usado em JSON.stringify). Exemplo: Date(2024,0,15,14,30) → '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "para string",
    "bitbybit.dates.toString_description": "Converte data para string completa específica do local (inclui data, hora e fuso horário). Exemplo: Date(2024,0,15,14,30) → 'Seg Jan 15 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "para string de tempo",
    "toTimeString": "para string de tempo",
    "bitbybit.dates.toTimeString_description": "Converte data para string de hora (exclui data, inclui fuso horário). Exemplo: Date(2024,0,15,14,30,45) → '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "para string UTC",
    "toUTCString": "para string UTC",
    "bitbybit.dates.toUTCString_description": "Converte data para formato de string UTC (Tempo Universal Coordenado, sem deslocamento de fuso horário). Exemplo: Date(2024,0,15,14,30) → 'Seg, 15 Jan 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "agora",
    "now": "agora",
    "bitbybit.dates.now_description": "Retorna a data e hora atuais no momento da execução. Exemplo: chamar now() → Objeto Date representando momento atual (e.g., '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "criar data",
    "createDate": "criar data",
    "bitbybit.dates.createDate_description": "Cria uma nova data a partir de componentes individuais usando hora local. Mês é indexado em 0: 0=Janeiro, 11=Dezembro. Exemplo: ano=2024, mês=0, dia=15, horas=14, minutos=30 → Date(Jan 15, 2024 14:30)",
    "year": "ano",
    "month": "mês",
    "day": "dia",
    "hours": "horas",
    "minutes": "minutos",
    "seconds": "segundos",
    "milliseconds": "milissegundos",
    "bitbybit.dates.createDateUTC": "criar data UTC",
    "createDateUTC": "criar data UTC",
    "bitbybit.dates.createDateUTC_description": "Cria uma nova data a partir de componentes individuais usando UTC (ignora fuso horário). Retorna milissegundos desde a época Unix (1 Jan 1970 00:00:00 UTC). Exemplo: ano=2024, mês=0, dia=15 → Date representando Jan 15, 2024 00:00 UTC",
    "bitbybit.dates.createFromUnixTimeStamp": "criar a partir de carimbo de tempo Unix",
    "createFromUnixTimeStamp": "criar a partir de carimbo de tempo Unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Cria uma data a partir de timestamp Unix (milissegundos desde 1 Jan 1970 UTC). Exemplo: unixTimeStamp=1705329000000 → Date(Jan 15, 2024 14:30:00)",
    "unixTimeStamp": "carimbo de tempo Unix",
    "bitbybit.dates.parseDate": "analisar data",
    "parseDate": "analisar data",
    "bitbybit.dates.parseDate_description": "Analisa uma string de data e retorna timestamp Unix (milissegundos desde 1 Jan 1970 UTC). Exemplo: dateString='2024-01-15' → 1705276800000",
    "parse": "analisar",
    "dateString": "string de data",
    "bitbybit.dates.getDayOfMonth": "obter dia do mês",
    "getDayOfMonth": "obter dia do mês",
    "bitbybit.dates.getDayOfMonth_description": "Extrai dia do mês da data (1-31) usando hora local. Exemplo: Date(2024,0,15) → 15",
    "bitbybit.dates.getWeekday": "obter dia da semana",
    "getWeekday": "obter dia da semana",
    "bitbybit.dates.getWeekday_description": "Extrai dia da semana da data (0=Domingo, 6=Sábado) usando hora local. Exemplo: Date(2024,0,15) → 1 (Segunda-feira)",
    "bitbybit.dates.getYear": "obter ano",
    "getYear": "obter ano",
    "bitbybit.dates.getYear_description": "Extrai ano completo da data usando hora local. Exemplo: Date(2024,0,15) → 2024",
    "bitbybit.dates.getMonth": "obter mês",
    "getMonth": "obter mês",
    "bitbybit.dates.getMonth_description": "Extrai mês da data (0=Janeiro, 11=Dezembro) usando hora local. Exemplo: Date(2024,0,15) → 0 (Janeiro)",
    "bitbybit.dates.getHours": "obter horas",
    "getHours": "obter horas",
    "bitbybit.dates.getHours_description": "Extrai horas da data (0-23) usando hora local. Exemplo: Date(2024,0,15,14,30) → 14",
    "bitbybit.dates.getMinutes": "obter minutos",
    "getMinutes": "obter minutos",
    "bitbybit.dates.getMinutes_description": "Extrai minutos da data (0-59) usando hora local. Exemplo: Date(2024,0,15,14,30) → 30",
    "bitbybit.dates.getSeconds": "obter segundos",
    "getSeconds": "obter segundos",
    "bitbybit.dates.getSeconds_description": "Extrai segundos da data (0-59) usando hora local. Exemplo: Date(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getMilliseconds": "obter milissegundos",
    "getMilliseconds": "obter milissegundos",
    "bitbybit.dates.getMilliseconds_description": "Extrai milissegundos da data (0-999) usando hora local. Exemplo: Date(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.getTime": "obter tempo",
    "getTime": "obter tempo",
    "bitbybit.dates.getTime_description": "Converte data para timestamp Unix (milissegundos desde 1 Jan 1970 UTC). Exemplo: Date(2024,0,15,14,30) → 1705329000000",
    "bitbybit.dates.getUTCYear": "obter ano UTC",
    "getUTCYear": "obter ano UTC",
    "bitbybit.dates.getUTCYear_description": "Extrai ano completo da data usando UTC (ignora fuso horário). Exemplo: Date(2024,0,15) → 2024",
    "bitbybit.dates.getUTCMonth": "obter mês UTC",
    "getUTCMonth": "obter mês UTC",
    "bitbybit.dates.getUTCMonth_description": "Extrai mês da data (0=Janeiro, 11=Dezembro) usando UTC. Exemplo: Date.UTC(2024,0,15) → 0 (Janeiro)",
    "bitbybit.dates.getUTCDay": "obter dia UTC",
    "getUTCDay": "obter dia UTC",
    "bitbybit.dates.getUTCDay_description": "Extrai dia do mês da data (1-31) usando UTC. Exemplo: Date.UTC(2024,0,15) → 15",
    "bitbybit.dates.getUTCHours": "obter horas UTC",
    "getUTCHours": "obter horas UTC",
    "bitbybit.dates.getUTCHours_description": "Extrai horas da data (0-23) usando UTC. Exemplo: Date.UTC(2024,0,15,14) → 14",
    "bitbybit.dates.getUTCMinutes": "obter minutos UTC",
    "getUTCMinutes": "obter minutos UTC",
    "bitbybit.dates.getUTCMinutes_description": "Extrai minutos da data (0-59) usando UTC. Exemplo: Date.UTC(2024,0,15,14,30) → 30",
    "bitbybit.dates.getUTCSeconds": "obter segundos UTC",
    "getUTCSeconds": "obter segundos UTC",
    "bitbybit.dates.getUTCSeconds_description": "Extrai segundos da data (0-59) usando UTC. Exemplo: Date.UTC(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getUTCMilliseconds": "obter milissegundos UTC",
    "getUTCMilliseconds": "obter milissegundos UTC",
    "bitbybit.dates.getUTCMilliseconds_description": "Extrai milissegundos da data (0-999) usando UTC. Exemplo: Date.UTC(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.setYear": "definir ano",
    "setYear": "definir ano",
    "bitbybit.dates.setYear_description": "Cria nova data com ano modificado (retorna nova data, original inalterada). Exemplo: Date(2024,0,15) com ano=2025 → Date(2025,0,15)",
    "bitbybit.dates.setMonth": "definir mês",
    "setMonth": "definir mês",
    "bitbybit.dates.setMonth_description": "Cria nova data com mês modificado (0=Janeiro, 11=Dezembro, retorna nova data). Exemplo: Date(2024,0,15) com mês=5 → Date(2024,5,15) (15 Junho)",
    "bitbybit.dates.setDayOfMonth": "definir dia do mês",
    "setDayOfMonth": "definir dia do mês",
    "bitbybit.dates.setDayOfMonth_description": "Cria nova data com dia do mês modificado (1-31, retorna nova data). Exemplo: Date(2024,0,15) com dia=20 → Date(2024,0,20)",
    "bitbybit.dates.setHours": "definir horas",
    "setHours": "definir horas",
    "bitbybit.dates.setHours_description": "define o valor das horas no objeto de data usando o horário local",
    "bitbybit.dates.setMinutes": "definir minutos",
    "setMinutes": "definir minutos",
    "bitbybit.dates.setMinutes_description": "define o valor dos minutos no objeto de data usando o horário local",
    "bitbybit.dates.setSeconds": "definir segundos",
    "setSeconds": "definir segundos",
    "bitbybit.dates.setSeconds_description": "define o valor dos segundos no objeto de data usando o horário local",
    "bitbybit.dates.setMilliseconds": "definir milissegundos",
    "setMilliseconds": "definir milissegundos",
    "bitbybit.dates.setMilliseconds_description": "define o valor dos milissegundos no objeto de data usando o horário local",
    "bitbybit.dates.setTime": "definir tempo",
    "setTime": "definir tempo",
    "bitbybit.dates.setTime_description": "define o valor de data e hora no objeto de data",
    "time": "tempo",
    "bitbybit.dates.setUTCYear": "definir ano UTC",
    "setUTCYear": "definir ano UTC",
    "bitbybit.dates.setUTCYear_description": "define o valor do ano no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCMonth": "definir mês UTC",
    "setUTCMonth": "definir mês UTC",
    "bitbybit.dates.setUTCMonth_description": "define o valor do mês no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCDay": "definir dia UTC",
    "setUTCDay": "definir dia UTC",
    "bitbybit.dates.setUTCDay_description": "define o dia numérico do mês no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCHours": "definir horas UTC",
    "setUTCHours": "definir horas UTC",
    "bitbybit.dates.setUTCHours_description": "define o valor das horas no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCMinutes": "definir minutos UTC",
    "setUTCMinutes": "definir minutos UTC",
    "bitbybit.dates.setUTCMinutes_description": "define o valor dos minutos no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCSeconds": "definir segundos UTC",
    "setUTCSeconds": "definir segundos UTC",
    "bitbybit.dates.setUTCSeconds_description": "define o valor dos segundos no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCMilliseconds": "definir milissegundos UTC",
    "setUTCMilliseconds": "definir milissegundos UTC",
    "bitbybit.dates.setUTCMilliseconds_description": "define o valor dos milissegundos no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.json.stringify": "stringificar",
    "json": "JSON",
    "stringify": "stringificar",
    "bitbybit.json.stringify_description": "Stringifica o valor de entrada",
    "bitbybit.json.parse": "analisar",
    "bitbybit.json.parse_description": "Analisa o valor de entrada",
    "bitbybit.json.query": "consultar",
    "query": "consultar",
    "bitbybit.json.query_description": "Consulta o valor de entrada",
    "jsonpath": "caminho JSON",
    "bitbybit.json.setValueOnProp": "definir valor na propriedade",
    "setValueOnProp": "definir valor na propriedade",
    "bitbybit.json.setValueOnProp_description": "Define valor na propriedade dada do json dado",
    "props": "propriedades",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "obter JSON do array pela primeira correspondência de propriedade",
    "getJsonFromArrayByFirstPropMatch": "obter JSON do array pela primeira correspondência de propriedade",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Obtém json do array pela primeira correspondência de propriedade. Esta é uma busca muito simplista e retorna apenas a primeira correspondência. Se você precisa de busca mais complexa, você pode usar consulta jsonpath com filtros.",
    "jsonArray": "array JSON",
    "any[]": "array qualquer",
    "match": "correspondência",
    "bitbybit.json.getValueOnProp": "obter valor da propriedade",
    "getValueOnProp": "obter valor da propriedade",
    "bitbybit.json.getValueOnProp_description": "Obtém valor da propriedade no json dado",
    "bitbybit.json.setValue": "definir valor",
    "bitbybit.json.setValue_description": "Define valor no json fornecendo um caminho",
    "prop": "propriedade",
    "bitbybit.json.setValuesOnPaths": "definir valores nos caminhos",
    "setValuesOnPaths": "definir valores nos caminhos",
    "bitbybit.json.setValuesOnPaths_description": "Define múltiplos valores no json fornecendo caminhos",
    "paths": "caminhos",
    "bitbybit.json.paths": "caminhos",
    "bitbybit.json.paths_description": "Encontra caminhos para elementos no objeto correspondendo à expressão de caminho",
    "bitbybit.json.createEmpty": "vazio",
    "bitbybit.json.createEmpty_description": "Cria um objeto JavaScript vazio",
    "bitbybit.json.previewAndSaveJson": "visualizar e salvar JSON",
    "previewAndSaveJson": "visualizar e salvar JSON",
    "bitbybit.json.previewAndSaveJson_description": "Pré-visualiza json e dá opção de salvá-lo",
    "preview": "visualizar",
    "bitbybit.json.previewJson": "visualizar JSON",
    "previewJson": "visualizar JSON",
    "bitbybit.json.previewJson_description": "visualiza JSON",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "curva por nós, pontos de controle e pesos",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "curva por nós, pontos de controle e pesos",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Cria uma curva Nurbs fornecendo nós, pontos de controle e pesos",
    "degree": "grau",
    "knots": "nós",
    "bitbybit.verb.curve.createCurveByPoints": "curva por pontos",
    "createCurveByPoints": "curva por pontos",
    "bitbybit.verb.curve.createCurveByPoints_description": "Cria uma curva Nurbs fornecendo pontos de controle",
    "bitbybit.verb.curve.createBezierCurve": "curva de Bézier",
    "createBezierCurve": "curva de Bézier",
    "bitbybit.verb.curve.createBezierCurve_description": "Cria uma curva Bezier Nurbs fornecendo pontos de controle e pesos",
    "bitbybit.verb.curve.clone": "clonar",
    "bitbybit.verb.curve.clone_description": "Clona a curva Nurbs",
    "bitbybit.verb.curve.closestParam": "parâmetro mais próximo",
    "closestParam": "parâmetro mais próximo",
    "bitbybit.verb.curve.closestParam_description": "Encontra o parâmetro mais próximo na curva Nurbs a partir do ponto",
    "bitbybit.verb.curve.closestParams": "parâmetros mais próximos",
    "closestParams": "parâmetros mais próximos",
    "bitbybit.verb.curve.closestParams_description": "Encontra os parâmetros mais próximos na curva Nurbs a partir dos pontos",
    "bitbybit.verb.curve.closestPoint": "ponto mais próximo",
    "closestPoint": "ponto mais próximo",
    "bitbybit.verb.curve.closestPoint_description": "Encontra o ponto mais próximo na curva Nurbs a partir do ponto",
    "bitbybit.verb.curve.closestPoints": "pontos mais próximos",
    "closestPoints": "pontos mais próximos",
    "bitbybit.verb.curve.closestPoints_description": "Encontra os pontos mais próximos na curva Nurbs a partir da lista de pontos",
    "bitbybit.verb.curve.controlPoints": "pontos de controle",
    "controlPoints": "pontos de controle",
    "bitbybit.verb.curve.controlPoints_description": "Encontra os pontos de controle da curva Nurbs",
    "bitbybit.verb.curve.degree": "grau",
    "bitbybit.verb.curve.degree_description": "Encontra o grau da curva Nurbs",
    "bitbybit.verb.curve.derivatives": "derivadas",
    "derivatives": "derivadas",
    "bitbybit.verb.curve.derivatives_description": "Encontra as derivadas da curva Nurbs no parâmetro",
    "numDerivatives": "número de derivadas",
    "parameter": "parâmetro",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "dividir por comprimento de arco igual para parâmetros",
    "divideByEqualArcLengthToParams": "dividir por comprimento de arco igual para parâmetros",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Divide a curva por igual comprimento de arco em parâmetros",
    "subdivision": "subdivisão",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "dividir por comprimento de arco igual para pontos",
    "divideByEqualArcLengthToPoints": "dividir por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Divide a curva por igual comprimento de arco em pontos",
    "bitbybit.verb.curve.divideByArcLengthToParams": "dividir por comprimento de arco para parâmetros",
    "divideByArcLengthToParams": "dividir por comprimento de arco para parâmetros",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Divide a curva por comprimento de arco em parâmetros",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "dividir por comprimento de arco para pontos",
    "divideByArcLengthToPoints": "dividir por comprimento de arco para pontos",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Divide a curva por comprimento de arco em pontos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "dividir curvas por comprimento de arco igual para pontos",
    "divideCurvesByEqualArcLengthToPoints": "dividir curvas por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divide múltiplas curvas por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "dividir curvas por comprimento de arco para pontos",
    "divideCurvesByArcLengthToPoints": "dividir curvas por comprimento de arco para pontos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divide múltiplas curvas por comprimento de arco para pontos",
    "bitbybit.verb.curve.domain": "domínio",
    "bitbybit.verb.curve.domain_description": "Encontra o intervalo de domínio dos parâmetros da curva",
    "bitbybit.verb.curve.startPoint": "ponto inicial",
    "bitbybit.verb.curve.startPoint_description": "Ponto inicial da curva",
    "bitbybit.verb.curve.endPoint": "ponto final",
    "bitbybit.verb.curve.endPoint_description": "Ponto final da curva",
    "bitbybit.verb.curve.startPoints": "pontos iniciais",
    "bitbybit.verb.curve.startPoints_description": "Pontos iniciais das curvas",
    "bitbybit.verb.curve.endPoints": "pontos finais",
    "bitbybit.verb.curve.endPoints_description": "Pontos finais das curvas",
    "bitbybit.verb.curve.knots": "nós",
    "bitbybit.verb.curve.knots_description": "Encontra os nós da curva Nurbs",
    "bitbybit.verb.curve.lengthAtParam": "comprimento no parâmetro",
    "lengthAtParam": "comprimento no parâmetro",
    "bitbybit.verb.curve.lengthAtParam_description": "Obtém o comprimento da curva Nurbs no parâmetro específico",
    "bitbybit.verb.curve.length": "comprimento",
    "bitbybit.verb.curve.length_description": "Obtém o comprimento da curva Nurbs",
    "bitbybit.verb.curve.paramAtLength": "parâmetro no comprimento",
    "paramAtLength": "parâmetro no comprimento",
    "bitbybit.verb.curve.paramAtLength_description": "Obtém o param no comprimento especificado na curva Nurbs",
    "bitbybit.verb.curve.pointAtParam": "ponto no parâmetro",
    "pointAtParam": "ponto no parâmetro",
    "bitbybit.verb.curve.pointAtParam_description": "Obtém o ponto no parâmetro especificado na curva Nurbs",
    "bitbybit.verb.curve.pointsAtParam": "pontos no parâmetro",
    "pointsAtParam": "pontos no parâmetro",
    "bitbybit.verb.curve.pointsAtParam_description": "Obtém os pontos no parâmetro especificado nas curvas Nurbs",
    "bitbybit.verb.curve.reverse": "inverter",
    "bitbybit.verb.curve.reverse_description": "Inverte a curva Nurbs",
    "bitbybit.verb.curve.split": "dividir",
    "bitbybit.verb.curve.split_description": "Divide a curva Nurbs em duas em um parâmetro dado",
    "bitbybit.verb.curve.tangent": "tangente",
    "bitbybit.verb.curve.tangent_description": "Tangente da curva Nurbs em um parâmetro dado",
    "bitbybit.verb.curve.tessellate": "tesselar",
    "tessellate": "tesselar",
    "bitbybit.verb.curve.tessellate_description": "Tessela a curva Nurbs em uma lista de pontos",
    "bitbybit.verb.curve.transform": "transformar",
    "bitbybit.verb.curve.transform_description": "Transforma a curva Nurbs",
    "bitbybit.verb.curve.transformCurves": "transformar curvas",
    "transformCurves": "transformar curvas",
    "bitbybit.verb.curve.transformCurves_description": "Transforma as curvas Nurbs",
    "bitbybit.verb.curve.weights": "pesos",
    "bitbybit.verb.curve.weights_description": "Pesos da curva Nurbs",
    "bitbybit.verb.curve.circle.createCircle": "círculo",
    "createCircle": "círculo",
    "bitbybit.verb.curve.circle.createCircle_description": "Cria a curva Nurbs de círculo",
    "xAxis": "eixo x",
    "yAxis": "eixo y",
    "bitbybit.verb.curve.circle.createArc": "arco",
    "createArc": "arco",
    "bitbybit.verb.curve.circle.createArc_description": "Cria a curva Nurbs de arco",
    "minAngle": "ângulo mínimo",
    "maxAngle": "ângulo máximo",
    "bitbybit.verb.curve.circle.center": "centro",
    "bitbybit.verb.curve.circle.center_description": "Obtém o ponto central do círculo ou de um arco",
    "bitbybit.verb.curve.circle.radius": "raio",
    "bitbybit.verb.curve.circle.radius_description": "Obtém o raio do círculo ou de um arco",
    "bitbybit.verb.curve.circle.maxAngle": "ângulo máximo",
    "bitbybit.verb.curve.circle.maxAngle_description": "Obtém o ângulo máximo do arco em graus",
    "bitbybit.verb.curve.circle.minAngle": "ângulo mínimo",
    "bitbybit.verb.curve.circle.minAngle_description": "Obtém o ângulo mínimo do arco em graus",
    "bitbybit.verb.curve.circle.xAxis": "eixo x",
    "bitbybit.verb.curve.circle.xAxis_description": "Obtém o ângulo x do arco",
    "bitbybit.verb.curve.circle.yAxis": "eixo y",
    "bitbybit.verb.curve.circle.yAxis_description": "Obtém o ângulo y do arco",
    "bitbybit.verb.curve.ellipse.createEllipse": "elipse",
    "createEllipse": "elipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Cria a curva Nurbs de elipse",
    "bitbybit.verb.curve.ellipse.createArc": "arco",
    "bitbybit.verb.curve.ellipse.createArc_description": "Cria a curva Nurbs de arco de elipse",
    "bitbybit.verb.curve.ellipse.center": "centro",
    "bitbybit.verb.curve.ellipse.center_description": "Obtém o ponto central da elipse ou de um arco",
    "bitbybit.verb.curve.ellipse.maxAngle": "ângulo máximo",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Obtém o ângulo máximo do arco em graus",
    "bitbybit.verb.curve.ellipse.minAngle": "ângulo mínimo",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Obtém o ângulo mínimo do arco em graus",
    "bitbybit.verb.curve.ellipse.xAxis": "eixo x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Obtém o ângulo x do arco ou de uma elipse",
    "bitbybit.verb.curve.ellipse.yAxis": "eixo y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Obtém o ângulo y do arco ou de uma elipse",
    "bitbybit.verb.surface.boundaries": "fronteiras",
    "boundaries": "fronteiras",
    "bitbybit.verb.surface.boundaries_description": "Obtém as curvas Nurbs de borda limite da superfície em uma lista",
    "bitbybit.verb.surface.createSurfaceByCorners": "superfície por cantos",
    "createSurfaceByCorners": "superfície por cantos",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Cria a superfície fornecendo 4 pontos como cantos",
    "point3": "ponto 3",
    "point4": "ponto 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "superfície por nós, pontos de controle e pesos",
    "createSurfaceByKnotsControlPointsWeights": "superfície por nós, pontos de controle e pesos",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Cria a superfície Nurbs fornecendo nós uv, graus uv, pontos e pesos",
    "degreeU": "grau U",
    "degreeV": "grau V",
    "knotsU": "nós U",
    "knotsV": "nós V",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "superfície por elevação de curvas",
    "createSurfaceByLoftingCurves": "superfície por elevação de curvas",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Cria a superfície Nurbs por solevamento de curvas",
    "bitbybit.verb.surface.clone": "clonar",
    "bitbybit.verb.surface.clone_description": "Clona a superfície Nurbs",
    "bitbybit.verb.surface.closestParam": "parâmetro mais próximo",
    "bitbybit.verb.surface.closestParam_description": "Encontra o parâmetro mais próximo na superfície a partir do ponto",
    "bitbybit.verb.surface.closestPoint": "ponto mais próximo",
    "bitbybit.verb.surface.closestPoint_description": "Encontra o ponto mais próximo na superfície a partir do ponto",
    "bitbybit.verb.surface.controlPoints": "pontos de controle",
    "bitbybit.verb.surface.controlPoints_description": "Obtém os pontos de controle na superfície",
    "bitbybit.verb.surface.degreeU": "grau U",
    "bitbybit.verb.surface.degreeU_description": "Obtém o grau U da superfície",
    "bitbybit.verb.surface.degreeV": "grau V",
    "bitbybit.verb.surface.degreeV_description": "Obtém o grau V da superfície",
    "bitbybit.verb.surface.derivatives": "derivadas",
    "bitbybit.verb.surface.derivatives_description": "Obtém as derivadas da superfície na coordenada uv especificada",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "domínio U",
    "domainU": "domínio U",
    "bitbybit.verb.surface.domainU_description": "Obtém o domínio U da superfície",
    "bitbybit.verb.surface.domainV": "domínio V",
    "domainV": "domínio V",
    "bitbybit.verb.surface.domainV_description": "Obtém o domínio V da superfície",
    "bitbybit.verb.surface.isocurve": "isocurva",
    "isocurve": "isocurva",
    "bitbybit.verb.surface.isocurve_description": "Obtém a isocurva Nurbs na superfície",
    "useV": "usar V",
    "bitbybit.verb.surface.isocurvesSubdivision": "subdivisão de isocurvas",
    "isocurvesSubdivision": "subdivisão de isocurvas",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Subdivide superfície em número preferido de isocurvas",
    "isocurveSegments": "segmentos de isocurva",
    "bitbybit.verb.surface.isocurvesAtParams": "isocurvas nos parâmetros",
    "isocurvesAtParams": "isocurvas nos parâmetros",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Subdivide superfície em isocurvas em array especificado de parâmetros",
    "parameters": "parâmetros",
    "bitbybit.verb.surface.knotsU": "nós U",
    "bitbybit.verb.surface.knotsU_description": "Obtém os nós U da superfície",
    "bitbybit.verb.surface.knotsV": "nós V",
    "bitbybit.verb.surface.knotsV_description": "Obtém os nós V da superfície",
    "bitbybit.verb.surface.normal": "normal",
    "bitbybit.verb.surface.normal_description": "Obtém a normal na superfície na coordenada uv",
    "bitbybit.verb.surface.point": "ponto",
    "bitbybit.verb.surface.point_description": "Obtém o ponto na superfície na coordenada uv",
    "bitbybit.verb.surface.reverse": "inverter",
    "bitbybit.verb.surface.reverse_description": "Inverte a superfície Nurbs. Isso inverterá a origem UV e direções de isocurva",
    "bitbybit.verb.surface.split": "dividir",
    "bitbybit.verb.surface.split_description": "Divide a superfície Nurbs em duas metades.",
    "bitbybit.verb.surface.transformSurface": "transformar superfície",
    "transformSurface": "transformar superfície",
    "bitbybit.verb.surface.transformSurface_description": "Transforma a superfície Nurbs com uma lista dada de transformações.",
    "bitbybit.verb.surface.weights": "pesos",
    "bitbybit.verb.surface.weights_description": "Obtém os pesos da superfície",
    "bitbybit.verb.surface.cone.create": "criar",
    "cone": "cone",
    "bitbybit.verb.surface.cone.create_description": "Cria a superfície Nurbs cônica",
    "bitbybit.verb.surface.cone.axis": "eixo",
    "bitbybit.verb.surface.cone.axis_description": "Obter eixo do cone",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "Obter base do cone",
    "bitbybit.verb.surface.cone.height": "altura",
    "bitbybit.verb.surface.cone.height_description": "Obter altura do cone",
    "bitbybit.verb.surface.cone.radius": "raio",
    "bitbybit.verb.surface.cone.radius_description": "Obter raio do cone",
    "bitbybit.verb.surface.cone.xAxis": "eixo x",
    "bitbybit.verb.surface.cone.xAxis_description": "Obter eixo x do cone",
    "bitbybit.verb.surface.cylinder.create": "criar",
    "bitbybit.verb.surface.cylinder.create_description": "Cria a superfície Nurbs cilíndrica",
    "bitbybit.verb.surface.cylinder.axis": "eixo",
    "bitbybit.verb.surface.cylinder.axis_description": "Obter eixo do cilindro",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "Obter base do cilindro",
    "bitbybit.verb.surface.cylinder.height": "altura",
    "bitbybit.verb.surface.cylinder.height_description": "Obter altura do cilindro",
    "bitbybit.verb.surface.cylinder.radius": "raio",
    "bitbybit.verb.surface.cylinder.radius_description": "Obter raio do cilindro",
    "bitbybit.verb.surface.cylinder.xAxis": "eixo x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Obter eixo x do cilindro",
    "bitbybit.verb.surface.extrusion.create": "criar",
    "extrusion": "extrusão",
    "bitbybit.verb.surface.extrusion.create_description": "Cria a extrusão de superfície Nurbs a partir da curva",
    "profile": "perfil",
    "bitbybit.verb.surface.extrusion.direction": "direção",
    "bitbybit.verb.surface.extrusion.direction_description": "Obtém o vetor de direção da extrusão",
    "bitbybit.verb.surface.extrusion.profile": "perfil",
    "bitbybit.verb.surface.extrusion.profile_description": "Obtém a curva Nurbs de perfil da extrusão",
    "bitbybit.verb.surface.sphere.create": "criar",
    "bitbybit.verb.surface.sphere.create_description": "Cria a superfície Nurbs esférica",
    "bitbybit.verb.surface.sphere.radius": "raio",
    "bitbybit.verb.surface.sphere.radius_description": "Obter o raio da superfície Nurbs esférica",
    "bitbybit.verb.surface.sphere.center": "centro",
    "bitbybit.verb.surface.sphere.center_description": "Obter o centro da superfície Nurbs esférica",
    "bitbybit.verb.surface.revolved.create": "criar",
    "revolved": "revolvido",
    "bitbybit.verb.surface.revolved.create_description": "Cria a superfície Nurbs revolucionada",
    "bitbybit.verb.surface.revolved.profile": "perfil",
    "bitbybit.verb.surface.revolved.profile_description": "Obter a curva Nurbs de perfil da superfície Nurbs revolucionada",
    "revolution": "revolução",
    "bitbybit.verb.surface.revolved.center": "centro",
    "bitbybit.verb.surface.revolved.center_description": "Obter a curva Nurbs central da superfície Nurbs revolucionada",
    "bitbybit.verb.surface.revolved.axis": "eixo",
    "bitbybit.verb.surface.revolved.axis_description": "Obter o eixo de rotação da superfície Nurbs revolucionada",
    "bitbybit.verb.surface.revolved.angle": "ângulo",
    "bitbybit.verb.surface.revolved.angle_description": "Obter o ângulo de rotação da superfície Nurbs revolucionada",
    "bitbybit.verb.surface.sweep.create": "criar",
    "sweep": "varredura",
    "bitbybit.verb.surface.sweep.create_description": "Cria a superfície Nurbs de varredura",
    "rail": "trilho",
    "bitbybit.verb.surface.sweep.profile": "perfil",
    "bitbybit.verb.surface.sweep.profile_description": "Obter a curva Nurbs de perfil da superfície Nurbs varrida",
    "bitbybit.verb.surface.sweep.rail": "trilho",
    "bitbybit.verb.surface.sweep.rail_description": "Obter a curva Nurbs de trilho da superfície Nurbs varrida",
    "bitbybit.verb.intersect.curves": "curvas",
    "bitbybit.verb.intersect.curves_description": "Intercepta duas curvas Nurbs verb juntas e retorna resultados de interseção",
    "firstCurve": "primeira curva",
    "secondCurve": "segunda curva",
    "bitbybit.verb.intersect.curveAndSurface": "curva e superfície",
    "curveAndSurface": "curva e superfície",
    "bitbybit.verb.intersect.curveAndSurface_description": "intersecciona curva e superfície",
    "bitbybit.verb.intersect.surfaces": "superfícies",
    "bitbybit.verb.intersect.surfaces_description": "intersecciona duas superfícies",
    "firstSurface": "primeira superfície",
    "secondSurface": "segunda superfície",
    "bitbybit.verb.intersect.curveCurveFirstParams": "parâmetros da primeira curva",
    "curveCurveFirstParams": "parâmetros da primeira curva",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Obtém parâmetros de interseção na primeira curva da interseção curva-curva",
    "intersections": "interseções",
    "BaseTypes.CurveCurveIntersection[]": "array de interseção de curva com curva do tipo base",
    "bitbybit.verb.intersect.curveCurveSecondParams": "parâmetros da segunda curva",
    "curveCurveSecondParams": "parâmetros da segunda curva",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Obtém parâmetros de interseção na segunda curva da interseção curva-curva",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "pontos da primeira curva",
    "curveCurveFirstPoints": "pontos da primeira curva",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Obtém pontos de interseção na primeira curva da interseção curva-curva",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "pontos da segunda curva",
    "curveCurveSecondPoints": "pontos da segunda curva",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Obtém pontos de interseção na segunda curva da interseção curva-curva",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "parâmetros da curva na interseção com superfície",
    "curveSurfaceCurveParams": "parâmetros da curva na interseção com superfície",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Obtém parâmetros de interseção na curva da interseção curva-superfície",
    "BaseTypes.CurveSurfaceIntersection[]": "array de interseção de curva com superfície do tipo base",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "parâmetros da superfície na interseção com curva",
    "curveSurfaceSurfaceParams": "parâmetros da superfície na interseção com curva",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Obtém parâmetros de interseção na superfície da interseção curva-superfície",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "pontos da curva na interseção com superfície",
    "curveSurfaceCurvePoints": "pontos da curva na interseção com superfície",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Obtém pontos de interseção na curva da interseção curva-superfície",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "pontos da superfície na interseção com curva",
    "curveSurfaceSurfacePoints": "pontos da superfície na interseção com curva",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Obtém pontos de interseção na superfície da interseção curva-superfície",
    "bitbybit.tag.create": "criar",
    "tag": "etiqueta",
    "bitbybit.tag.create_description": "Cria um dto de tag",
    "adaptDepth": "adaptar profundidade",
    "needsUpdate": "precisa de atualização",
    "bitbybit.time.registerRenderFunction": "registrar função de renderização",
    "registerRenderFunction": "registrar função de renderização",
    "bitbybit.time.registerRenderFunction_description": "Registra uma função para loop de renderização",
    "bitbybit.asset.getFile": "obter arquivo",
    "asset": "ativo",
    "getFile": "obter arquivo",
    "bitbybit.asset.getFile_description": "Obtém o arquivo de ativo",
    "bitbybit.asset.getLocalFile": "obter arquivo local",
    "getLocalFile": "obter arquivo local",
    "bitbybit.asset.getLocalFile_description": "Obtém o arquivo de ativo local armazenado no seu navegador.",
    "bitbybit.asset.fetchBlob": "buscar blob",
    "fetchBlob": "buscar blob",
    "bitbybit.asset.fetchBlob_description": "Busca o blob da url dada, deve ser um endpoint acessível habilitado para CORS",
    "fetch": "buscar",
    "bitbybit.asset.fetchFile": "buscar arquivo",
    "fetchFile": "buscar arquivo",
    "bitbybit.asset.fetchFile_description": "Busca o arquivo da url dada, deve ser um endpoint acessível habilitado para CORS",
    "bitbybit.asset.fetchJSON": "buscar JSON",
    "fetchJSON": "buscar JSON",
    "bitbybit.asset.fetchJSON_description": "Busca o json da url dada, deve ser um endpoint acessível habilitado para CORS",
    "bitbybit.asset.fetchText": "buscar texto",
    "fetchText": "buscar texto",
    "bitbybit.asset.fetchText_description": "Busca o texto da url dada, deve ser um endpoint acessível habilitado para CORS",
    "bitbybit.asset.createObjectURL": "URL de objeto",
    "createObjectURL": "URL de objeto",
    "bitbybit.asset.createObjectURL_description": "Obtém e cria o caminho de string url para seu arquivo armazenado em sua memória.",
    "file": "arquivo",
    "File | Blob": "arquivo ou blob",
    "bitbybit.asset.createObjectURLs": "URLs de objetos",
    "createObjectURLs": "URLs de objetos",
    "bitbybit.asset.createObjectURLs_description": "Obtém e cria os caminhos de string url para seus arquivos armazenados em sua memória.",
    "files": "arquivos",
    "(File | Blob)[]": "array de arquivo ou blob",
    "exec": "executar",
    "Visible": "Visível",
    "Hidden": "Oculto",
    "flatten": "achatar",
    "force exec": "forçar execução",
    "console log": "log no console",
    "preview data": "visualizar dados",
    "flow": "fluxo",
    "code": "código",
    "runner": "executor",
    "counters": "contadores",
    "actions": "ações",
    "loops": "loops",
    "interval": "intervalo",
    "delay": "atraso",
    "expire": "expirar",
    "timeout": "tempo limite",
    "counter min max": "contador mínimo e máximo",
    "counter steps": "passos do contador",
    "reset": "redefinir",
    "trigger": "gatilho",
    "mouse": "mouse",
    "mouse click": "clique do mouse",
    "key": "tecla",
    "pointer": "ponteiro",
    "pick info": "informações de seleção",
    "down": "baixo",
    "wheel": "roda",
    "tap": "toque",
    "double tap": "toque duplo",
    "render": "renderizar",
    "passed ms": "ms passados",
    "babylon observable listener": "ouvinte observável Babylon",
    "object": "objeto",
    "observable selector": "seletor observável",
    "get event data": "obter dados do evento",
    "exec click": "executar clique",
    "exec down": "executar pressionado",
    "toggle": "alternar",
    "flip flop": "flip flop",
    "boolean gate": "portão booleano",
    "boolean gate silent": "portão booleano silencioso",
    "is undefined": "é indefinido",
    "for loop": "loop for",
    "last": "último",
    "for each loop": "loop para cada",
    "element": "elemento",
    "body": "corpo",
    "complete": "completo",
    "editors": "editores",
    "inputs": "entradas",
    "outputs": "saídas",
    "recent": "recente",
    "Clear": "Limpar",
    "Run": "Executar",
    "Swap Canvas": "Trocar Tela",
    "Local Assets": "Ativos Locais",
    "Import": "Importar",
    "Copy to Clipboard": "Copiar para a Área de Transferência",
    "Paste from Clipboard": "Colar da Área de Transferência",
    "Export": "Exportar",
    "Export to runner": "Exportar para executor",
    "Clean Cache": "Limpar Cache",
    "Community": "Comunidade",
    "Sponsors and Partners": "Patrocinadores e Parceiros",
    "API Documentation": "Documentação da API",
    "About": "Sobre",
    "Toolbox": "Caixa de Ferramentas",
    "More": "Mais",
    "bitbybit.code.typeScriptEditor": "editor TypeScript",
    "bitbybit.code.typeScriptEditor_description": "Permite escrever código TypeScript com suporte completo ao intellisense do Bitbybit em uma função. O que a função start retornar será visto como saída do componente.",
    "bitbybit.code.javaScriptEditor": "editor JavaScript",
    "bitbybit.code.javaScriptEditor_description": "Permite escrever código JavaScript em uma função. O que a função start retornar será visto como saída do componente.",
    "bitbybit.code.jsonEditor": "editor JSON",
    "bitbybit.code.jsonEditor_description": "Permite escrever código JSON. O que a função start retornar será visto como saída do componente.",
    "bitbybit.flow.actions.keyboard": "teclado",
    "bitbybit.flow.actions.keyboard_description": "Executará em eventos de teclado ao clicar nos botões.",
    "bitbybit.flow.actions.mouseClick": "clique do mouse",
    "bitbybit.flow.actions.mouseClick_description": "Executará em eventos de mouse ao clicar nos botões.",
    "bitbybit.flow.actions.start": "iniciar",
    "bitbybit.flow.actions.start_description": "Inicia o fluxo de controle e dispara execuções.",
    "bitbybit.flow.actions.trigger": "gatilho",
    "bitbybit.flow.actions.trigger_description": "Dispara a execução ao clicar no botão.",
    "bitbybit.flow.babylon.gui.button": "botão",
    "bitbybit.flow.babylon.gui.button_description": "Executará em vários eventos de ponteiro ao clicar com o botão esquerdo do mouse na tela do BabylonJS.",
    "bitbybit.flow.babylon.scene.pointerEvents": "ponteiro",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Executará em vários eventos de ponteiro ao clicar com o botão esquerdo do mouse na tela do BabylonJS.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "obter dados do evento",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Obtém dados do evento a partir do resultado observado do ouvinte observável.",
    "bitbybit.flow.babylon.observableListener": "ouvinte observável Babylon",
    "bitbybit.flow.babylon.observableListener_description": "Inscreve-se e escuta qualquer um dos observáveis do BabylonJS.",
    "bitbybit.flow.babylon.render": "renderizar",
    "bitbybit.flow.babylon.render_description": "Executa em cada quadro de renderização do BabylonJS.",
    "bitbybit.flow.counters.counterMinMax": "contador mínimo e máximo",
    "bitbybit.flow.counters.counterMinMax_description": "Conta o número de execuções do fluxo entre valores mínimo e máximo. Quando o máximo é alcançado, reinicia.",
    "bitbybit.flow.counters.counterSteps": "passos do contador",
    "bitbybit.flow.counters.counterSteps_description": "Conta o número de execuções do fluxo começando em um valor dado e aumentando a cada execução por um passo da lista, até que os passos terminem. Quando o fim é alcançado, reinicia.",
    "bitbybit.flow.counters.counter": "contador",
    "bitbybit.flow.counters.counter_description": "Conta o número de execuções do fluxo.",
    "bitbybit.flow.logic.booleanGateSilent": "portão booleano silencioso",
    "bitbybit.flow.logic.booleanGateSilent_description": "Dispara diferentes eventos de execução com base no valor booleano fornecido, mas executa apenas quando o booleano muda de valor, evitando múltiplos eventos constantes sem alterações.",
    "bitbybit.flow.logic.booleanGate": "portão booleano",
    "bitbybit.flow.logic.booleanGate_description": "Dispara diferentes eventos de execução com base no valor booleano fornecido.",
    "bitbybit.flow.logic.flipFlop": "flip flop",
    "bitbybit.flow.logic.flipFlop_description": "Cada vez que um evento é executado, um evento diferente será disparado, criando essencialmente uma funcionalidade de alternância.",
    "bitbybit.flow.logic.isUndefined": "é indefinido",
    "bitbybit.flow.logic.isUndefined_description": "Verifica se o valor fornecido é indefinido e dispara um evento verdadeiro ou falso.",
    "bitbybit.flow.loops.forEach": "loop para cada",
    "bitbybit.flow.loops.forEach_description": "Loop para cada que percorre todos os elementos da lista.",
    "bitbybit.flow.loops.for": "loop for",
    "bitbybit.flow.loops.for_description": "Loop for que executa o corpo entre dois valores.",
    "bitbybit.flow.time.delay": "atraso",
    "bitbybit.flow.time.delay_description": "Atrasa a execução pelo tempo limite dado em milissegundos.",
    "bitbybit.flow.time.interval": "intervalo",
    "bitbybit.flow.time.interval_description": "Executa o fluxo a cada intervalo dado em milissegundos.",
    "bitbybit.lists.createList": "criar lista",
    "bitbybit.lists.createList_description": "Cria uma lista a partir dos elementos fornecidos.",
    "bitbybit.lists.flatten": "achatar",
    "bitbybit.lists.flatten_description": "Achata a lista de listas em uma única lista.",
    "bitbybit.lists.passThrough": "passagem direta",
    "bitbybit.lists.passThrough_description": "Converte o valor para o tipo 'any' e passa a entrada para a saída sem alterações.",
    "bitbybit.math.numberSlider": "deslizador de número",
    "bitbybit.math.numberSlider_description": "Cria um número com um deslizador. Você pode definir valores mínimo, máximo e de passo.",
    "bitbybit.consoleLog": "log no console",
    "bitbybit.consoleLog_description": "Registra a entrada no console do navegador.",
    "bitbybit.previewData": "visualizar dados",
    "bitbybit.previewData_description": "Mostra os dados de entrada em uma área de visualização geral. Pode ser texto, números, objetos JSON, arrays, etc. Objetos JavaScript circulares não são permitidos.",
    "bitbybit.runner.getRunnerInputValue": "obter valor de entrada do executor",
    "bitbybit.runner.getRunnerInputValue_description": "Obtém o valor de entrada do executor a partir do JSON de entradas. Este componente sempre retornará um valor indefinido no contexto do editor.",
    "bitbybit.runner.getRunnerInputs": "obter entradas do executor",
    "bitbybit.runner.getRunnerInputs_description": "Obtém as entradas do executor em JSON. Este componente sempre retornará um objeto vazio no contexto do editor.",
    "bitbybit.runner.run": "executar",
    "bitbybit.runner.run_description": "Executa código JavaScript do executor.",
    "bitbybit.runner.setRunnerResult": "definir resultado do executor",
    "bitbybit.runner.setRunnerResult_description": "Define o resultado JSON completo para o executor. Tenha em mente que é mais seguro definir valores, pois este método substituirá todo o objeto de resultado pelo valor fornecido.",
    "bitbybit.runner.setRunnerResultArrayValue": "definir valor de array do resultado do executor",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Define o valor do resultado do executor na propriedade do objeto JSON. Cada valor será adicionado a um array, que é o valor da propriedade.",
    "bitbybit.runner.setRunnerResultValue": "definir valor do resultado do executor",
    "bitbybit.runner.setRunnerResultValue_description": "Define o valor do resultado do executor na propriedade do objeto JSON.",
    "bitbybit.text.areaCreate": "área de texto",
    "bitbybit.text.areaCreate_description": "Cria uma área de texto no editor. Você pode definir o texto, largura e altura da área.",
    "update on drag": "atualizar ao arrastar",
    "paste": "colar",
    "duplicate": "duplicar",
    "delete": "excluir",
    "keyboard": "teclado",
    "data": "dados",
    "observables": "observáveis",
    "buttons": "botões",
    "variables": "variáveis",
    "functions": "funções",
    "loop": "loop",
    "apply": "aplicar",
    "async context": "contexto assíncrono",
    "async context description": "Cria um contexto assíncrono que pode usar componentes await, simplificando a execução e leitura de código assíncrono.",
    "then": "então",
    "await": "aguardar",
    "await description": "Aguarda a resolução da promessa e retorna o valor.",
    "when the": "quando o",
    "error": "erro",
    "happens in the promise": "ocorre na promessa",
    "catch": "capturar",
    "catch description": "Captura o erro que pode ocorrer durante a execução de código assíncrono. O usuário pode optar por tratar os erros adequadamente.",
    "cancel the interval execution": "cancelar a execução do intervalo",
    "cancel the interval description": "Cancela a execução do intervalo fornecendo o manipulador.",
    "cancel the timeout execution": "cancelar a execução do tempo limite",
    "cancel the timeout description": "Cancela a execução do tempo limite fornecendo o manipulador.",
    "key down": "tecla pressionada",
    "key down descritpion": "Dispara código quando o evento de tecla pressionada ocorre.",
    "key up": "tecla solta",
    "key up description": "Dispara código quando o evento de tecla solta ocorre.",
    "key press": "tecla pressionada",
    "key press description": "Dispara código quando o evento de tecla pressionada ocorre.",
    "is key pressed": "tecla está pressionada",
    "block_validation_required": "deve ser fornecido",
    "block_validation_of_length": "deve conter uma contagem de itens de",
    "block_validation_higher_or_equal": "deve ser maior ou igual a",
    "block_validation_lower_or_equal": "deve ser menor ou igual a",
    "block_validation_range": "deve estar no intervalo",
    "block_validation_smaller_than": "deve ser menor que",
    "block_validation_smaller_or_equal_than": "deve ser menor ou igual a",
    "block_validation_larger_than": "deve ser maior que",
    "block_validation_larger_or_equal_than": "deve ser maior ou igual a",
    "save text to file": "salvar texto em arquivo",
    "save text to file description": "Salva texto em um arquivo e permite escolher o nome e a extensão. Este componente não visualiza o texto e pode ser usado em situações onde o texto é muito grande para editar em um campo de área de texto.",
    "print text on screen": "imprimir texto na tela",
    "print text on screen description": "Imprime texto na tela. Este componente é útil para fins de depuração.",
    "preview text and save to file": "visualizar texto e salvar em arquivo",
    "preview text and save to file description": "Imprime texto na tela e permite salvá-lo em um arquivo. Este componente é útil para fins de depuração.",
    "register render loop listener": "registrar ouvinte de loop de renderização",
    "and update": "e atualizar",
    "register render loop listener description": "Executa a instrução no loop de renderização e indica quanto tempo passou desde o último quadro na variável timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "tempoDecorridoDesdeOFrameAnterior",
    "computing": "computação",
    "result": "resultado",
    "of promise is returned": "da promessa é retornado",
    "on pointer up": "ao soltar o ponteiro",
    "on pointer move": "ao mover o ponteiro",
    "on pointer down": "ao pressionar o ponteiro",
    "of babylonjs observable object": "do objeto observável BabylonJS",
    "observable name": "nome do observável",
    "is key pressed description": "Verifica se a tecla está pressionada e retorna verdadeiro ou falso.",
    "execute code after": "executar código após",
    "execute code after description": "Executa o código após o tempo limite dado em segundos.",
    "execute code every": "executar código a cada",
    "second(s)": "segundo(s)",
    "execute code every description": "Executa o código a cada intervalo dado em segundos.",
    "handler": "manipulador",
    "workers initialising": "inicializando trabalhadores",
    "Assets": "Ativos",
    "Local assets stored in browser cache:": "Ativos locais armazenados no cache do navegador:",
    "Asset Name": "Nome do Ativo",
    "Name is required": "O nome é obrigatório",
    "Asset with this name already exists, choose a different one": "Ativo com este nome já existe, escolha um diferente",
    "Allowed file formats:": "Formatos de arquivo permitidos:",
    "You must select an asset file": "Você deve selecionar um arquivo de ativo",
    "Upload Local Asset": "Carregar Ativo Local",
    "File Name": "Nome do Arquivo",
    "File Size": "Tamanho do Arquivo",
    "Your browser does not support indexDB and you can't upload local asset files.": "Seu navegador não suporta indexDB e você não pode carregar arquivos de ativos locais.",
    "Upload": "Carregar",
    "elements": "elementos",
    "bitbybit.vector.vectorsTheSame": "vetores iguais",
    "vectorsTheSame": "vetores iguais",
    "bitbybit.vector.vectorsTheSame_description": "Verifica se dois vetores são iguais dentro de uma tolerância dada (considera precisão de ponto flutuante). Exemplo: [1,2,3] vs [1.0001,2.0001,3.0001] com tolerância 0.001 → verdadeiro",
    "vec1": "vetor 1",
    "vec2": "vetor 2",
    "bitbybit.point.boundingBoxOfPoints": "caixa delimitadora de pontos",
    "boundingBoxOfPoints": "caixa delimitadora de pontos",
    "bitbybit.point.boundingBoxOfPoints_description": "Calcula caixa delimitadora alinhada ao eixo contendo todos os pontos (min, máx, centro, largura, altura, comprimento). Exemplo: pontos=[[0,0,0], [10,5,3]] → {min:[0,0,0], máx:[10,5,3], centro:[5,2.5,1.5], largura:10, altura:5, comprimento:3}",
    "bitbybit.point.normalFromThreePoints": "normal a partir de três pontos",
    "normalFromThreePoints": "normal a partir de três pontos",
    "bitbybit.point.normalFromThreePoints_description": "Calcula vetor normal a partir de três pontos usando produto vetorial (perpendicular ao plano). Exemplo: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0] → [0,0,1] (apontando para cima do plano XY)",
    "reverseNormal": "normal invertida",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "polilinha com extensões",
    "createLineWireWithExtensions": "polilinha com extensões",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Cria uma polilinha OpenCascade com extensões",
    "extensionStart": "início ext.",
    "extensionEnd": "fim ext.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "ponto médio na polilinha",
    "midPointOnWire": "ponto médio na polilinha",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Calcula o ponto médio na polilinha no parâmetro 0.5",
    "centerOnOrigin": "centrar na origem",
    "bitbybit.occt.shapes.wire.textWiresWithData": "polilinhas de texto com dados",
    "textWiresWithData": "polilinhas de texto com dados",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Cria um composto OpenCascade a partir de polilinhas de texto e retorna informações adicionais com base na fonte simplex criada pelo Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "alinhar normal e eixo",
    "alignNormAndAxis": "alinhar normal e eixo",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Alinha a forma com a normal e o eixo",
    "fromNorm": "da normal",
    "fromAx": "do eixo",
    "toNorm": "para normal",
    "toAx": "para eixo",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "cota de comprimento linear simples",
    "simpleLinearLengthDimension": "cota de comprimento linear simples",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Cria dimensão de comprimento linear simples entre dois pontos - unidades de medição. Você decide que tipo de unidades está usando fornecendo um sufixo.",
    "offsetFromPoints": "deslocamento dos pontos",
    "crossingSize": "tamanho do cruzamento",
    "labelSuffix": "sufixo do rótulo",
    "labelSize": "tamanho do rótulo",
    "labelOffset": "deslocamento do rótulo",
    "bitbybit.occt.dimensions.simpleAngularDimension": "dimensão angular simples",
    "simpleAngularDimension": "dimensão angular simples",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Cria uma dimensão angular simples. Por padrão, exibimos graus, mas você pode optar por usar radianos.",
    "direction1": "direção 1",
    "direction2": "direção 2",
    "offsetFromCenter": "deslocamento do centro",
    "extraSize": "tamanho extra",
    "radians": "radianos",
    "bitbybit.occt.dimensions.pinWithLabel": "pino com rótulo",
    "pinWithLabel": "pino com rótulo",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Cria um pino com rótulo. Pode ser usado para explicar coisas sobre os modelos ou marcar itens importantes na cena 3D.",
    "offsetFromStart": "deslocamento do início",
    "bitbybit.vector.lengthSq": "comprimento ao quadrado",
    "lengthSq": "comprimento ao quadrado",
    "bitbybit.vector.lengthSq_description": "Calcula o comprimento ao quadrado (magnitude ao quadrado) de um vetor 3D. Exemplo: [3,4,0] → 25 (comprimento 5 ao quadrado)",
    "bitbybit.point.twoPointsAlmostEqual": "dois pontos iguais",
    "twoPointsAlmostEqual": "dois pontos iguais",
    "bitbybit.point.twoPointsAlmostEqual_description": "Verifica se dois pontos são aproximadamente iguais dentro da tolerância (comparação baseada em distância). Exemplo: ponto1=[1.0000001, 2.0, 3.0], ponto2=[1.0, 2.0, 3.0], tolerância=1e-6 → verdadeiro",
    "bitbybit.line.lineToSegment": "linha para segmento",
    "lineToSegment": "linha para segmento",
    "bitbybit.line.lineToSegment_description": "Converte objeto linha para formato array de segmento. Exemplo: {start:[0,0,0], end:[10,5,0]} → [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "linhas para segmentos",
    "linesToSegments": "linhas para segmentos",
    "bitbybit.line.linesToSegments_description": "Converte múltiplos objetos linha para formato array de segmento (conversão em lote). Exemplo: 3 objetos linha → 3 arrays de segmento [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "segmento para linha",
    "segmentToLine": "segmento para linha",
    "bitbybit.line.segmentToLine_description": "Converte array de segmento para formato objeto linha. Exemplo: [[0,0,0], [10,5,0]] → {start:[0,0,0], end:[10,5,0]}",
    "segment": "segmento",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segmentos para linhas",
    "segmentsToLines": "segmentos para linhas",
    "bitbybit.line.segmentsToLines_description": "Converte múltiplos arrays de segmento para formato objeto linha (conversão em lote). Exemplo: 3 arrays de segmento → 3 objetos linha com propriedades start/end",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "ordenar segmentos em polilinhas",
    "sortSegmentsIntoPolylines": "ordenar segmentos em polilinhas",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Ordena segmentos embaralhados em polilinhas conectadas combinando pontos finais. Usa hash espacial para busca eficiente de conexão. Exemplo: 10 segmentos aleatórios que formam 2 caminhos conectados → 2 polilinhas",
    "sort": "ordenar",
    "bitbybit.mesh.signedDistanceToPlane": "distância com sinal ao plano",
    "signedDistanceToPlane": "distância com sinal ao plano",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calcula distância com sinal de um ponto a um plano (positivo=acima do plano, negativo=abaixo). Exemplo: ponto=[0,5,0], plano={normal:[0,1,0], d:0} → 5 (ponto está 5 unidades acima do plano XZ)",
    "plane": "plano",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calcular plano do triângulo",
    "calculateTrianglePlane": "calcular plano do triângulo",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calcula equação do plano a partir de vértices do triângulo (vetor normal e distância da origem). Retorna indefinido se triângulo é degenerado (área zero, pontos colineares). Exemplo: triângulo=[[0,0,0], [1,0,0], [0,1,0]] → {normal:[0,0,1], d:0} (plano XY)",
    "triangle": "triângulo",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "interseção triângulo-triângulo",
    "triangleTriangleIntersection": "interseção triângulo-triângulo",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calcula segmento de interseção de dois triângulos (segmento de linha onde se cruzam). Retorna indefinido se triângulos não intersectam, são paralelos ou coplanares. Exemplo: triângulo1=[[0,0,0], [2,0,0], [1,2,0]], triângulo2=[[1,-1,1], [1,1,1], [1,1,-1]] → [[1,0,0], [1,1,0]]",
    "triangle1": "triângulo 1",
    "triangle2": "triângulo 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segmentos de interseção malha-malha",
    "meshMeshIntersectionSegments": "segmentos de interseção malha-malha",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calcula todos os segmentos de interseção entre duas malhas de triângulos (testes de triângulos em pares). Retorna array de segmentos de linha onde superfícies de malha interceptam. Exemplo: malha cubo interceptando com malha esfera → múltiplos segmentos formando curva de interseção",
    "mesh1": "malha 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "malha 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polilinhas de interseção malha-malha",
    "meshMeshIntersectionPolylines": "polilinhas de interseção malha-malha",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calcula polilinhas de interseção entre duas malhas ordenando segmentos em caminhos conectados. Segmentos são unidos ponta-a-ponta para formar curvas contínuas ou fechadas. Exemplo: interseção cubo-esfera → loops de polilinha fechados onde superfícies se encontram",
    "bitbybit.occt.shapeFacesToPolygonPoints": "faces da forma para pontos do polígono",
    "shapeFacesToPolygonPoints": "faces da forma para pontos do polígono",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Cria pontos do polígono a partir das faces da forma",
    "reversedPoints": "pontos invertidos",
    "bitbybit.occt.shapeToMesh": "forma para malha",
    "shapeToMesh": "forma para malha",
    "bitbybit.occt.shapeToMesh_description": "Cria malha a partir da forma",
    "bitbybit.occt.shapesToMeshes": "formas para malhas",
    "shapesToMeshes": "formas para malhas",
    "bitbybit.occt.shapesToMeshes_description": "Cria malha a partir da forma",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "a partir de pontos do polígono",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Cria um Manifold a partir de um conjunto de pontos do polígono que descrevem triângulos.",
    "traingle": "triângulo",
    "bitbybit.point.stretchPointsDirFromCenter": "esticar pontos na direção a partir do centro",
    "stretchPointsDirFromCenter": "esticar pontos na direção a partir do centro",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Estica múltiplos pontos ao longo de uma direção a partir de um ponto central (escala direcional). Exemplo: pontos=[[10,0,0]], centro=[0,0,0], direção=[1,0,0], escala=2 → [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "grade hexagonal escalada para ajustar",
    "hexGridScaledToFit": "grade hexagonal escalada para ajustar",
    "bitbybit.point.hexGridScaledToFit_description": "Cria grade hexagonal escalada para caber dentro dos limites de largura/altura especificados (calcula tamanho do hex automaticamente). Retorna pontos centrais e vértices hex. Suporta orientação ponta-cima ou plano-cima. Exemplo: largura=10, altura=10, nrHexagonosNaAltura=3 → grade hex preenchendo área 10×10 com 3 linhas",
    "nrHexagonsU": "nº hexágonos U",
    "nrHexagonsV": "nº hexágonos V",
    "extendTop": "estender topo",
    "extendBottom": "estender base",
    "extendLeft": "estender esquerda",
    "extendRight": "estender direita",
    "centerGrid": "centralizar grade",
    "bitbybit.point.sortPoints": "ordenar pontos",
    "sortPoints": "ordenar pontos",
    "bitbybit.point.sortPoints_description": "Ordena pontos lexicograficamente (por coordenadas X, depois Y, depois Z). Exemplo: [[5,0,0], [1,0,0], [3,0,0]] → [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "interseção linha-linha",
    "lineLineIntersection": "interseção linha-linha",
    "bitbybit.line.lineLineIntersection_description": "Calcula ponto de interseção de duas linhas (ou segmentos se checkSegmentsOnly=true). Retorna indefinido se linhas são paralelas, enviesadas ou segmentos não se sobrepõem. Exemplo: linha1={start:[0,0,0], end:[10,0,0]}, linha2={start:[5,-5,0], end:[5,5,0]} → [5,0,0]",
    "line1": "linha 1",
    "line2": "linha 2",
    "checkSegmentsOnly": "verificar apenas segmentos",
    "bitbybit.polyline.polylineToLines": "polilinha para linhas",
    "polylineToLines": "polilinha para linhas",
    "bitbybit.polyline.polylineToLines_description": "Converte polilinha em segmentos de linha (cada segmento como objeto linha com start/end). Polilinhas fechadas incluem segmento de fechamento. Exemplo: 3 pontos → 2 ou 3 linhas (dependendo de isClosed)",
    "bitbybit.polyline.polylineToSegments": "polilinha para segmentos",
    "polylineToSegments": "polilinha para segmentos",
    "bitbybit.polyline.polylineToSegments_description": "Converte polilinha em arrays de segmento (cada segmento como [point1, point2]). Polilinhas fechadas incluem segmento de fechamento se pontos finais diferem. Exemplo: 4 pontos, fechado → 4 segmentos conectando todos os pontos em um loop",
    "bitbybit.polyline.polylineSelfIntersection": "autointerseção de polilinha",
    "polylineSelfIntersection": "autointerseção de polilinha",
    "bitbybit.polyline.polylineSelfIntersection_description": "Encontra pontos onde a polilinha cruza a si mesma (pontos de auto-interseção). Pula segmentos adjacentes e deduplica pontos próximos. Exemplo: polilinha em forma de 8 → retorna ponto de cruzamento central",
    "bitbybit.polyline.twoPolylineIntersection": "interseção de duas polilinhas",
    "twoPolylineIntersection": "interseção de duas polilinhas",
    "bitbybit.polyline.twoPolylineIntersection_description": "Encontra pontos de interseção entre duas polilinhas (todos os cruzamentos segmento-segmento). Testa todos os pares de segmentos e deduplica pontos próximos. Exemplo: polilinhas cruzadas formando um X → retorna ponto de interseção central",
    "polyline1": "polilinha 1",
    "polyline2": "polilinha 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdividir em arames hexagonais",
    "subdivideToHexagonWires": "subdividir em arames hexagonais",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivide uma face em arames hexagonais",
    "extendUUp": "estender U acima",
    "extendUBottom": "estender U abaixo",
    "extendVUp": "estender V acima",
    "extendVBottom": "estender V abaixo",
    "nrHexagonsInHeight": "nº hexágonos altura",
    "nrHexagonsInWidth": "nº hexágonos largura",
    "bitbybit.vector.length": "comprimento do vetor",
    "bitbybit.vector.length_description": "Calcula o comprimento (magnitude) de um vetor 3D. Exemplo: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.point.maxFilletRadius": "raio máximo de fillet",
    "maxFilletRadius": "raio máximo de fillet",
    "bitbybit.point.maxFilletRadius_description": "Calcula o raio máximo de concordância (fillet) possível num canto formado por dois segmentos de linha que partilham um ponto extremo (C), de tal forma que o arco de concordância seja tangente a ambos os segmentos e esteja inteiramente contido neles.",
    "bitbybit.point.maxFilletRadiusHalfLine": "raio máximo de fillet meia-linha",
    "maxFilletRadiusHalfLine": "raio máximo de fillet meia-linha",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calcula o raio máximo de concordância (fillet) possível num canto C, de tal forma que o arco de concordância seja tangente a ambos os segmentos (P1-C, P2-C) e os pontos tangentes estejam dentro da primeira metade de cada segmento (medido a partir de C).",
    "bitbybit.point.maxFilletsHalfLine": "fillets máximos meia-linha",
    "maxFilletsHalfLine": "fillets máximos meia-linha",
    "bitbybit.point.maxFilletsHalfLine_description": "Calcula o raio máximo de concordância (fillet) possível em cada canto de uma polilinha formada por uma série de pontos. O raio de concordância é calculado para cada canto interno e opcionalmente para os cantos de fecho se a polilinha for fechada.",
    "checkLastWithFirst": "verificar último com primeiro",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "raio máximo de fillet mais seguro (pontos, meia-linha)",
    "safestPointsMaxFilletHalfLine": "raio máximo de fillet mais seguro (pontos, meia-linha)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calcula o único raio máximo de concordância (fillet) mais seguro que pode ser aplicado uniformemente a todos os cantos de uma coleção de pontos, com base na restrição de 'meia-linha'. Isso é determinado encontrando o mínimo dos raios máximos de concordância possíveis calculados para cada canto individual.",
    "bitbybit.polyline.maxFilletsHalfLine": "fillets máximos meia-linha",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calcula o raio máximo de concordância (fillet) de 'meia-linha' possível para cada canto de uma dada polilinha. Para uma polilinha fechada, inclui os cantos que conectam o último segmento de volta ao primeiro. O cálculo usa a restrição de 'meia-linha', significando que os pontos tangentes do fillet devem estar dentro da primeira metade de cada segmento conectado ao canto.",
    "bitbybit.polyline.safestFilletRadius": "raio de fillet mais seguro",
    "safestFilletRadius": "raio de fillet mais seguro",
    "bitbybit.polyline.safestFilletRadius_description": "Calcula o único raio máximo de concordância (fillet) mais seguro que pode ser aplicado uniformemente a todos os cantos de uma polilinha, com base na restrição de 'meia-linha'. Isso é determinado encontrando o mínimo dos raios máximos de concordância possíveis calculados para cada canto individual.",
    "flatTop": "topo plano",
    "bitbybit.mesh.meshMeshIntersectionPoints": "pontos de interseção malha-malha",
    "meshMeshIntersectionPoints": "pontos de interseção malha-malha",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calcula pontos de interseção entre duas malhas como arrays de pontos (um array por polilinha). Polilinhas fechadas têm primeiro ponto duplicado no final. Exemplo: interseção cubo-esfera → arrays de pontos definindo curvas de interseção",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexágonos na grade",
    "hexagonsInGrid": "hexágonos na grade",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Cria arames hexagonais OpenCascade na grade",
    "scalePatternWidth": "escalar largura do padrão",
    "scalePatternHeight": "escalar altura do padrão",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "arames de interseção malha-malha",
    "meshMeshIntersectionWires": "arames de interseção malha-malha",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Realiza a operação de interseção malha-malha entre duas formas - ambas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os arames da interseção, que são polilinhas ou polígonos.",
    "mesh based": "baseado em malha",
    "precision1": "precisão 1",
    "precision2": "precisão 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "pontos de interseção malha-malha",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Realiza a operação de interseção malha-malha entre duas formas - ambas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os pontos da interseção.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "interseção malha-malha para arames",
    "meshMeshIntersectionOfShapesWires": "interseção malha-malha para arames",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Realiza a operação de interseção malha-malha entre a forma e múltiplas outras formas - todas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os arames da interseção, que são polilinhas ou polígonos.",
    "precisionShapes": "precisão formas",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "interseção malha-malha para pontos",
    "meshMeshIntersectionOfShapesPoints": "interseção malha-malha para pontos",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Realiza a operação de interseção malha-malha entre a forma e múltiplas outras formas - todas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os pontos da interseção.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexágonos na grade",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Cria hexágonos OpenCascade na grade (faces)",
    "bitbybit.jscad.toPolygonPoints": "para pontos de polígono",
    "toPolygonPoints": "para pontos de polígono",
    "bitbybit.jscad.toPolygonPoints_description": "Converte a malha Jscad para pontos de polígono representando triângulos da malha.",
    "conversions": "conversões",
    "bitbybit.manifold.toPolygonPoints": "para pontos de polígono",
    "bitbybit.manifold.toPolygonPoints_description": "Transforma a forma manifold numa coleção de pontos de polígono representando a malha.",
    "flatU": "plano U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdividir em furos hexagonais",
    "subdivideToHexagonHoles": "subdividir em furos hexagonais",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivide uma face em furos hexagonais",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "converter linhas para curvas NURBS",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Converte linhas em curvas NURBS. Retorna um array de objetos verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "converter linha para curva NURBS",
    "convertLineToNurbsCurve": "converter linha para curva NURBS",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Converte linha em curva NURBS. Retorna o objeto verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "converter polilinha para curva NURBS",
    "convertPolylineToNurbsCurve": "converter polilinha para curva NURBS",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Converte uma polilinha em uma curva NURBS. Retorna o objeto verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "converter polilinhas para curvas NURBS",
    "convertPolylinesToNurbsCurves": "converter polilinhas para curvas NURBS",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Converte polilinhas em curvas NURBS. Retorna os objetos verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segmento",
    "createSegment": "segmento",
    "bitbybit.line.createSegment_description": "Cria um segmento a partir de dois pontos (formato array: [start, end]). Exemplo: start=[0,0,0], end=[10,5,0] → [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "aresta da linha de base",
    "fromBaseLine": "da linha de base",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Cria aresta linear a partir do formato de linha de base {start: Point3, end: Point3}",
    "from base": "da base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "aresta das linhas de base",
    "fromBaseLines": "das linhas de base",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Cria arestas lineares a partir do formato de linhas de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "aresta do segmento de base",
    "fromBaseSegment": "do segmento de base",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Cria aresta linear a partir do formato de segmento de base [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "arestas dos segmentos de base",
    "fromBaseSegments": "dos segmentos de base",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Cria aresta linear a partir do formato de segmentos de base [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "arestas de pontos",
    "fromPoints": "de pontos",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Cria arestas lineares a partir da coleção de pontos",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "arestas da polilinha de base",
    "fromBasePolyline": "da polilinha de base",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Cria arestas lineares a partir da definição de polilinha",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "arestas do triângulo de base",
    "fromBaseTriangle": "do triângulo de base",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Cria arestas lineares a partir da definição de triângulo",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "arestas da malha de base",
    "fromBaseMesh": "da malha de base",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Cria arestas lineares a partir da definição de malha",
    "bitbybit.occt.shapes.wire.fromBaseLine": "arame da linha de base",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Cria arame linear a partir do formato de linha de base {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "arames das linhas de base",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Cria arames lineares a partir do formato de linhas de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "arame do segmento de base",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Cria arame linear a partir do formato de segmento de base [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "arames dos segmentos de base",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Cria arames lineares a partir do formato de segmentos de base [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "arame de pontos",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Cria arame a partir da coleção de pontos",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "arame da polilinha de base",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Cria arame a partir da definição de polilinha",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "arame do triângulo de base",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Cria arame a partir da definição de triângulo",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "arames da malha de base",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Cria arames a partir da definição de malha",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "face do triângulo de base",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Cria face a partir da definição de triângulo",
    "bitbybit.occt.shapes.face.fromBaseMesh": "faces da malha de base",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Cria faces a partir da definição de malha",
    "fromRightHanded": "de destro",
    "bitbybit.advanced.text3d.createWithUrl": "texto com url",
    "createWithUrl": "texto com url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Cria um texto 3d com uma URL de fonte Isso é útil quando você quer usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada da URL fornecida e usada para gerar o texto 3d. Certifique-se de que fontes não contêm auto-interseção e outros caracteres ruins - isso é um problema comum com fontes personalizadas. Formatos de fonte suportados são: ttf, otf, woff. Por favor note que Woff2 não é suportado pelo opentype.js pois é um formato comprimido.",
    "fontUrl": "url da fonte",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "texto na face url",
    "createTextOnFaceUrl": "texto na face url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Cria um texto 3D na face usando um URL de fonte. Isso é útil quando você deseja usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada a partir do URL fornecido e usada para gerar o texto 3D. Certifique-se de que as fontes não contenham autointerseção e outros caracteres ruins - esse é um problema comum com fontes personalizadas. Os formatos de fonte suportados são: ttf, otf, woff. Observe que o Woff2 não é suportado pelo opentype.js, pois é um formato compactado.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "textos na face url",
    "createTextsOnFaceUrl": "textos na face url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Cria textos 3d na face a partir de múltiplas definições de url Isso é útil quando você quer usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada da URL fornecida e usada para gerar o texto 3d. Certifique-se de que fontes não contêm auto-interseção e outros caracteres ruins - isso é um problema comum com fontes personalizadas. Formatos de fonte suportados são: ttf, otf, woff. Por favor note que Woff2 não é suportado pelo opentype.js pois é um formato comprimido.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "definição de texto 3d na face url",
    "definition3dTextOnFaceUrl": "definição de texto 3d na face url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Cria texto 3d que será usado na definição de url de face Isso é útil quando você quer usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada da URL fornecida e usada para gerar o texto 3d. Certifique-se de que fontes não contêm auto-interseção e outros caracteres ruins - isso é um problema comum com fontes personalizadas. Formatos de fonte suportados são: ttf, otf, woff. Por favor note que Woff2 não é suportado pelo opentype.js pois é um formato comprimido.",
    "bitbybit.advanced.navigation.pointOfInterest": "ponto de interesse",
    "navigation": "navegação",
    "pointOfInterest": "ponto de interesse",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Cria ponto de interesse - indicador clicável no espaço 3D que pode ser usado para voar a câmera para um local específico com posição de câmera e alvo predefinidos. Ponto de interesse pode ser estilizado com PointOfInterestStyleDto e animado com efeito de pulso. Ponto de interesse também pode ter um rótulo de texto.",
    "cameraTarget": "alvo da câmera",
    "cameraPosition": "posição da câmera",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "sistema de pontos de interesse",
    "pointsOfInterestSystem": "sistema de pontos de interesse",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "pontos de interesse",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "ponto de interesse",
    "style": "estilo",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "estilo de ponto de interesse",
    "pointOfInterestStyle": "estilo de ponto de interesse",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Criar estilo de ponto de interesse - usado para estilizar indicadores de pontos de interesse no espaço 3D. Você pode personalizar o tamanho do ponto, cor, cor ao passar o mouse, efeito de pulsação, cor e tamanho do rótulo de texto.",
    "pointSize": "tamanho do ponto",
    "pointColor": "cor do ponto",
    "hoverPointColor": "cor do ponto ao passar o mouse",
    "pulseColor": "cor da pulsação",
    "hoverPulseColor": "cor da pulsação ao passar o mouse",
    "pulseMinSize": "tamanho mín. da pulsação",
    "pulseMaxSize": "tamanho máx. da pulsação",
    "pulseThickness": "espessura da pulsação",
    "pulseSpeed": "velocidade da pulsação",
    "textColor": "cor do texto",
    "hoverTextColor": "cor do texto ao passar o mouse",
    "textSize": "tamanho do texto",
    "hideSkybox": "ocultar skybox",
    "textureUrl": "URL da textura",
    "hdrTexture": "textura HDR",
    "textureSize": "tamanho da textura",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "habilitar textura personalizada do skybox",
    "enableSkyboxCustomTexture": "habilitar textura personalizada do skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Habilita o skybox com uma textura personalizada",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "imagem de fundo CSS do canvas",
    "canvasCSSBackgroundImage": "imagem de fundo CSS do canvas",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Altera o fundo da cena para uma imagem de fundo CSS para o espaço 3D",
    "cssBackgroundImage": "imagem de fundo CSS",
    "bitbybit.babylon.scene.twoColorLinearGradient": "gradiente linear de duas cores",
    "twoColorLinearGradient": "gradiente linear de duas cores",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Cria um fundo de gradiente linear de duas cores para o espaço 3D",
    "colorFrom": "cor de",
    "colorTo": "cor para",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "parada de",
    "stopTo": "parada para",
    "bitbybit.babylon.scene.twoColorRadialGradient": "gradiente radial de duas cores",
    "twoColorRadialGradient": "gradiente radial de duas cores",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Cria um fundo de gradiente radial de duas cores para o espaço 3D",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "gradiente linear multicolorido",
    "multiColorLinearGradient": "gradiente linear multicolorido",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Cria um fundo de gradiente linear multicolorido para o espaço 3D",
    "Base.Color[]": "Base.Color[]",
    "stops": "paradas",
    "bitbybit.babylon.scene.multiColorRadialGradient": "gradiente radial multicolorido",
    "multiColorRadialGradient": "gradiente radial multicolorido",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Cria um fundo de gradiente radial multicolorido para o espaço 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "imagem de fundo do canvas",
    "canvasBackgroundImage": "imagem de fundo do canvas",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Define uma imagem de fundo com várias opções de personalização para o espaço 3D",
    "imageUrl": "URL da imagem",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "anexo",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "recorte",
    "labelRotation": "rotação da etiqueta",
    "bitbybit.advanced.dimensions.linearDimension": "dimensão linear",
    "linearDimension": "dimensão linear",
    "bitbybit.advanced.dimensions.linearDimension_description": "Cria dimensão linear - uma linha de medição entre dois pontos com linhas de extensão e etiqueta de texto. A dimensão mostra a distância entre os pontos e pode ser estilizada com DimensionStyleDto.",
    "linear dimension": "dimensão linear",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "dimensão angular",
    "angularDimension": "dimensão angular",
    "bitbybit.advanced.dimensions.angularDimension_description": "Cria dimensão angular - um arco de medição entre dois vetores de direção com linhas de extensão e etiqueta de texto. A dimensão mostra o ângulo entre as direções e pode ser estilizada com DimensionStyleDto.",
    "angular dimension": "dimensão angular",
    "centerPoint": "ponto central",
    "bitbybit.advanced.dimensions.dimensionStyle": "estilo de dimensão",
    "dimensionStyle": "estilo de dimensão",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Criar estilo de dimensão - usado para estilizar linhas de dimensão, setas e texto no espaço 3D. Você pode personalizar cores de linha, espessura, tamanho do texto, tamanho da seta e cores de fundo.",
    "dimension style": "estilo de dimensão",
    "lineColor": "cor da linha",
    "lineThickness": "espessura da linha",
    "extensionLineLength": "comprimento da linha de extensão",
    "textBackgroundColor": "cor de fundo do texto",
    "textBackgroundOpacity": "opacidade do fundo do texto",
    "arrowSize": "tamanho da seta",
    "arrowColor": "cor da seta",
    "textRenderMode": "modo de renderização do texto",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "billboard de texto",
    "occlusionCheckInterval": "intervalo de verificação de oclusão",
    "arrowTailLength": "comprimento da cauda da seta",
    "showArrows": "mostrar setas",
    "labelOverwrite": "sobrescrever etiqueta",
    "bitbybit.advanced.dimensions.radialDimension": "dimensão radial",
    "radialDimension": "dimensão radial",
    "bitbybit.advanced.dimensions.radialDimension_description": "Cria dimensão radial - uma linha de medição do centro ao perímetro mostrando raio ou diâmetro. Mostra prefixo 'R' para raio ou prefixo '⌀' para diâmetro com marca central opcional.",
    "radial dimension": "dimensão radial",
    "radiusPoint": "ponto do raio",
    "showDiameter": "mostrar diâmetro",
    "showCenterMark": "mostrar marca central",
    "bitbybit.advanced.dimensions.diametralDimension": "dimensão diametral",
    "diametralDimension": "dimensão diametral",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Cria dimensão diametral - uma linha de medição que abrange o diâmetro completo de características circulares. Mostra prefixo '⌀' com marca central opcional e setas em ambas as extremidades.",
    "diametral dimension": "dimensão diametral",
    "bitbybit.advanced.dimensions.ordinateDimension": "dimensão de ordenada",
    "ordinateDimension": "dimensão de ordenada",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Cria dimensão de ordenada - mostra coordenada X, Y ou Z de um ponto de referência com linha de chamada. Útil para anotações de coordenadas e referenciamento de dados em desenhos técnicos.",
    "ordinate dimension": "dimensão de ordenada",
    "measurementPoint": "ponto de medição",
    "referencePoint": "ponto de referência",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "mostrar linha de chamada",
    "viewMode": "modo de visualização",
    "schema": "esquema",
    "json schema": "esquema JSON",
    "metadata": "metadados",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "fundo de gradiente linear de duas cores",
    "twoColorLinearGradientBackground": "fundo de gradiente linear de duas cores",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Cria um fundo de gradiente linear de duas cores para espaço 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "fundo de gradiente radial de duas cores",
    "twoColorRadialGradientBackground": "fundo de gradiente radial de duas cores",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Cria um fundo de gradiente radial de duas cores para espaço 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "fundo de gradiente linear multicolorido",
    "multiColorLinearGradientBackground": "fundo de gradiente linear multicolorido",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Cria um fundo de gradiente linear multicolorido para espaço 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "fundo de gradiente radial multicolorido",
    "multiColorRadialGradientBackground": "fundo de gradiente radial multicolorido",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Cria um fundo de gradiente radial multicolorido para espaço 3D",
    "textBackgroundStroke": "contorno do fundo do texto",
    "textBackgroundRadius": "raio do fundo do texto",
    "stableSize": "tamanho estável",
    "alwaysOnTop": "sempre no topo",
    "textStableSize": "tamanho de texto estável",
    "bitbybit.occt.io.shapeToDxfPaths": "forma para caminhos DXF",
    "shapeToDxfPaths": "forma para caminhos DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Cria caminhos DXF de uma forma OCCT Importante - formas contendo fios devem estar no plano XZ (Y=0) para exportação DXF 2D correta.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "caminhos DXF com camada",
    "dxfPathsWithLayer": "caminhos DXF com camada",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Adiciona informação de camada e cor aos caminhos DXF Importante - formas contendo fios devem estar no plano XZ (Y=0) para exportação DXF 2D correta.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "camada",
    "bitbybit.occt.io.dxfCreate": "criar DXF",
    "dxfCreate": "criar DXF",
    "bitbybit.occt.io.dxfCreate_description": "Monta várias partes de caminho em um arquivo DXF completo",
    "pathsParts": "partes de caminhos",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "peso da fonte do texto",
    "textPosition": "posição do texto",
    "textBackgroundStrokeThickness": "espessura do traço",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Limpar",
    "recompute": "Recalcular",
    "clear tooltip": "Limpar todos os caches e componentes",
    "recompute tooltip": "Limpa o cache e recalcula",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "fio de perfil de viga I",
    "createIBeamProfileWire": "fio de perfil de viga I",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Cria fio de perfil de viga I do OpenCascade",
    "beam profiles": "perfis de vigas",
    "webThickness": "espessura da alma",
    "flangeThickness": "espessura do flange",
    "alignment": "alinhamento",
    "Base.basicAlignmentEnum": "Base.basicAlignmentEnum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "fio de perfil de viga H",
    "createHBeamProfileWire": "fio de perfil de viga H",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Cria fio de perfil de viga H do OpenCascade",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "fio de perfil de viga T",
    "createTBeamProfileWire": "fio de perfil de viga T",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Cria fio de perfil de viga T do OpenCascade",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "fio de perfil de viga U",
    "createUBeamProfileWire": "fio de perfil de viga U",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Cria fio de perfil de viga U do OpenCascade",
    "flangeWidth": "largura do flange",
    "bitbybit.occt.shapes.face.createLPolygonFace": "face de polígono L",
    "createLPolygonFace": "face de polígono L",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Cria face de polígono L do OpenCascade",
    "bitbybit.occt.shapes.face.createStarFace": "face de estrela",
    "createStarFace": "face de estrela",
    "bitbybit.occt.shapes.face.createStarFace_description": "Cria face de estrela do OpenCascade",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "face de árvore de natal",
    "createChristmasTreeFace": "face de árvore de natal",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Cria face de árvore de natal do OpenCascade",
    "bitbybit.occt.shapes.face.createParallelogramFace": "face de paralelogramo",
    "createParallelogramFace": "face de paralelogramo",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Cria face de paralelogramo do OpenCascade",
    "bitbybit.occt.shapes.face.createHeartFace": "face de coração",
    "createHeartFace": "face de coração",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Cria face de coração do OpenCascade",
    "bitbybit.occt.shapes.face.createNGonFace": "face de n-gono",
    "createNGonFace": "face de n-gono",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Cria face de n-gono do OpenCascade",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "face de perfil de viga I",
    "createIBeamProfileFace": "face de perfil de viga I",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Cria face de perfil de viga I do OpenCascade",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "face de perfil de viga H",
    "createHBeamProfileFace": "face de perfil de viga H",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Cria face de perfil de viga H do OpenCascade",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "face de perfil de viga T",
    "createTBeamProfileFace": "face de perfil de viga T",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Cria face de perfil de viga T do OpenCascade",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "face de perfil de viga U",
    "createUBeamProfileFace": "face de perfil de viga U",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Cria face de perfil de viga U do OpenCascade",
    "bitbybit.occt.shapes.solid.createStarSolid": "sólido de estrela",
    "createStarSolid": "sólido de estrela",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Cria sólido de estrela do OpenCascade",
    "extrusionLengthFront": "comprimento de extrusão frontal",
    "extrusionLengthBack": "comprimento de extrusão traseira",
    "bitbybit.occt.shapes.solid.createNGonSolid": "sólido de n-gono",
    "createNGonSolid": "sólido de n-gono",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Cria sólido de n-gono do OpenCascade",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "sólido de paralelogramo",
    "createParallelogramSolid": "sólido de paralelogramo",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Cria sólido de paralelogramo do OpenCascade",
    "bitbybit.occt.shapes.solid.createHeartSolid": "sólido de coração",
    "createHeartSolid": "sólido de coração",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Cria sólido de coração do OpenCascade",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "sólido de árvore de natal",
    "createChristmasTreeSolid": "sólido de árvore de natal",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Cria sólido de árvore de natal do OpenCascade",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "sólido de polígono L",
    "createLPolygonSolid": "sólido de polígono L",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Cria sólido de polígono L do OpenCascade",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "sólido de perfil de viga I",
    "createIBeamProfileSolid": "sólido de perfil de viga I",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Cria sólido de perfil de viga I do OpenCascade",
    "beam": "viga",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "sólido de perfil de viga H",
    "createHBeamProfileSolid": "sólido de perfil de viga H",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Cria sólido de perfil de viga H do OpenCascade",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "sólido de perfil de viga T",
    "createTBeamProfileSolid": "sólido de perfil de viga T",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Cria sólido de perfil de viga T do OpenCascade",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "sólido de perfil de viga U",
    "createUBeamProfileSolid": "sólido de perfil de viga U",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Cria sólido de perfil de viga U do OpenCascade",
    "endType": "tipo de extremidade",
    "dimensionEndTypeEnum": "dimensionEndTypeEnum",
    "arrowAngle": "ângulo da seta",
    "arrowsFlipped": "setas invertidas",
    "colorFormat": "formato de cor",
    "dxfColorFormatEnum": "dxfColorFormatEnum",
    "acadVersion": "versão acad",
    "dxfAcadVersionEnum": "dxfAcadVersionEnum",
    "bitbybit.advanced.navigation.zoomOn": "ampliar em",
    "zoomOn": "ampliar em",
    "bitbybit.advanced.navigation.zoomOn_description": "Amplia a câmera para ajustar as malhas especificadas na cena com animação suave. Funciona apenas com ArcRotateCamera. A animação pode ser interrompida se chamada várias vezes.",
    "animationSpeed": "velocidade de animação",
    "doNotUpdateMaxZ": "não atualizar max z",
    "bitbybit.advanced.navigation.focusFromAngle": "focar a partir do ângulo",
    "focusFromAngle": "focar a partir do ângulo",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Foca a câmera nas malhas especificadas a partir de um ângulo específico com animação suave. Calcula o centro da caixa delimitadora de todas as malhas e posiciona a câmera no vetor de orientação especificado para olhar para o centro. Funciona apenas com ArcRotateCamera. A animação pode ser interrompida se chamada várias vezes.",
    "padding": "preenchimento",
    "shadowRefreshRate": "Taxa de atualização de sombra",
    "labelFlipHorizontal": "Inverter rótulo horizontalmente",
    "labelFlipVertical": "Inverter rótulo verticalmente",
    "bitbybit.advanced.navigation.zoomOnAspect": "Zoom no aspecto",
    "zoomOnAspect": "Zoom no aspecto",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Amplia a câmera para ajustar as malhas especificadas na cena com animação suave, considerando a proporção exata da tela. Ao contrário do zoomOn, este método calcula com precisão a distância da câmera com base nas dimensões da janela de visualização e na caixa delimitadora da malha para garantir melhor ajuste em padding=0. Funciona apenas com ArcRotateCamera. A animação pode ser interrompida se chamada várias vezes.",
    "bitbybit.vector.parseNumbers": "analisar números",
    "parseNumbers": "analisar números",
    "bitbybit.vector.parseNumbers_description": "Converte um array de números em formato de string para números reais. Exemplo: ['1', '2.5', '3'] → [1, 2.5, 3], ['10', '-5', '0.1'] → [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "simplificar",
    "bitbybit.manifold.manifold.operations.simplify_description": "Retorna uma cópia do manifold simplificada para a tolerância dada, mas com o seu valor de tolerância real inalterado. O resultado conterá um subconjunto dos vértices originais e todas as superfícies terão se movido menos que a tolerância.",
    "bitbybit.manifold.manifold.operations.setProperties": "definir propriedades",
    "setProperties": "definir propriedades",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Cria uma nova cópia deste manifold com propriedades de vértice atualizadas fornecendo uma função que recebe a posição existente e as propriedades como entrada. Você pode especificar qualquer número de propriedades de saída, permitindo a criação e remoção de canais. Nota: comportamento indefinido resultará se você ler além do número de propriedades de entrada ou escrever além do número de propriedades de saída.",
    "propFunc": "função de prop",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "deformar (warp)",
    "warp": "deformar (warp)",
    "bitbybit.manifold.manifold.transforms.warp_description": "Move os vértices deste Manifold (criando um novo) de acordo com qualquer função de entrada arbitrária. É fácil criar uma função que deforma um objeto geometricamente válido em um que se sobrepõe, mas isso não é verificado aqui, então cabe ao usuário escolher sua função com discrição.",
    "warpFunc": "função de deformação",
    "(vert: Base.Vector3) => void": "(vert: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "status",
    "status": "status",
    "bitbybit.manifold.manifold.evaluate.status_description": "Retorna a razão pela qual uma Malha de entrada produz um Manifold vazio. Este Status será mantido através de operações como propagação de NaN, garantindo que uma malha com erro não seja misteriosamente perdida. Malhas vazias ainda podem mostrar NoError, por exemplo, a interseção de malhas que não se sobrepõem.",
    "bitbybit.manifold.crossSection.transforms.warp": "deformar (warp)",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Move os vértices desta Seção Transversal (criando uma nova) de acordo com qualquer função de entrada arbitrária, seguida por uma operação de união (com uma regra de preenchimento Positiva) que garante que quaisquer interseções introduzidas não sejam incluídas no resultado.",
    "(vert: Base.Vector2) => void": "(vert: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "arredondar e remover zeros finais",
    "roundAndRemoveTrailingZeros": "arredondar e remover zeros finais",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Arredonda um número para as casas decimais especificadas e remove zeros finais. Exemplo: 1.32156 com 3 decimais retorna 1.322, mas 1.320000001 retorna 1.32, e 1.000 retorna 1",
    "bitbybit.math.clamp": "restringir (clamp)",
    "clamp": "restringir (clamp)",
    "bitbybit.math.clamp_description": "Restringe um valor entre um valor mínimo e máximo. Exemplo: clamp(5, 0, 3) retorna 3, clamp(-1, 0, 3) retorna 0, clamp(1.5, 0, 3) retorna 1.5",
    "bitbybit.math.lerp": "lerp",
    "bitbybit.math.lerp_description": "Interpolação linear entre dois valores usando o parâmetro t (0 a 1). Exemplo: De 0 a 100 em t=0.5 → 50, De 10 a 20 em t=0.25 → 12.5. Quando t=0 retorna início, quando t=1 retorna fim. Útil para transições suaves.",
    "t": "t",
    "bitbybit.math.inverseLerp": "lerp inverso",
    "inverseLerp": "lerp inverso",
    "bitbybit.math.inverseLerp_description": "Calcula o parâmetro de interpolação t para um valor entre início e fim (inverso de lerp). Exemplo: Valor 5 no intervalo [0,10] → t=0.5, Valor 2.5 no intervalo [0,10] → t=0.25. Retorna qual valor t produziria o valor dado em um lerp. Útil para encontrar a posição relativa.",
    "bitbybit.math.smoothstep": "passo suave (smoothstep)",
    "smoothstep": "passo suave (smoothstep)",
    "bitbybit.math.smoothstep_description": "Interpolação Hermite com aceleração e desaceleração suaves (mais suave que lerp linear). Exemplo: x=0 → 0, x=0.5 → 0.5, x=1 → 1 (mas com curva S suave entre eles). A entrada é automaticamente restrita a [0,1]. A saída entra e sai suavemente. Ótimo para animações.",
    "bitbybit.math.sign": "sinal",
    "sign": "sinal",
    "bitbybit.math.sign_description": "Retorna o sinal de um número: -1 para negativo, 0 para zero, 1 para positivo. Exemplo: -5 → -1, 0 → 0, 3.14 → 1. Útil para determinar direção ou polaridade.",
    "bitbybit.math.fract": "parte fracionária",
    "fract": "parte fracionária",
    "bitbybit.math.fract_description": "Retorna a parte fracionária de um número (remove a parte inteira, mantém os decimais). Exemplo: 3.14 → 0.14, 5.9 → 0.9, -2.3 → 0.7. Útil para envolver valores e criar padrões repetitivos.",
    "bitbybit.math.wrap": "envolver (wrap)",
    "bitbybit.math.wrap_description": "Envolve um número dentro de um intervalo especificado (cria ciclo repetitivo). Exemplo: 1.5 no intervalo [0,1) → 0.5, -0.3 no intervalo [0,1) → 0.7, 370° no intervalo [0,360) → 10°. Útil para ângulos, UVs ou qualquer domínio repetitivo. Como módulo, mas lida com negativos corretamente.",
    "bitbybit.math.pingPong": "pingue-pongue",
    "pingPong": "pingue-pongue",
    "bitbybit.math.pingPong_description": "Cria um efeito de pingue-pongue (ida e volta) que faz um valor quicar entre 0 e comprimento. O valor vai de 0→comprimento, depois volta comprimento→0, repetindo este ciclo. Exemplo: Com comprimento=1: t=0→0, t=0.5→0.5, t=1→1 (pico), t=1.5→0.5, t=2→0, t=2.5→0.5 (repete). Útil para criar animações de rebote como uma bola ou movimento oscilante.",
    "bitbybit.math.moveTowards": "mover em direção a",
    "moveTowards": "mover em direção a",
    "bitbybit.math.moveTowards_description": "Move um valor em direção a um alvo por uma quantidade delta máxima (nunca ultrapassando). Exemplo: De 0 em direção a 10 por máx 3 → 3, De 8 em direção a 10 por máx 3 → 10 (alcançado). Útil para movimento suave com limites de velocidade máxima.",
    "current": "atual",
    "maxDelta": "delta máx",
    "bitbybit.lists.getFirstItem": "obter primeiro item",
    "getFirstItem": "obter primeiro item",
    "bitbybit.lists.getFirstItem_description": "Obtém o primeiro item da lista. Exemplo: De [10, 20, 30, 40], retorna 10",
    "bitbybit.lists.getLastItem": "obter último item",
    "getLastItem": "obter último item",
    "bitbybit.lists.getLastItem_description": "Obtém o último item da lista. Exemplo: De [10, 20, 30, 40], retorna 40",
    "bitbybit.lists.shuffle": "embaralhar",
    "shuffle": "embaralhar",
    "bitbybit.lists.shuffle_description": "Reorganiza aleatoriamente todos os itens na lista (usando algoritmo Fisher-Yates). Exemplo: De [1, 2, 3, 4, 5], pode retornar [3, 1, 5, 2, 4] (a ordem varia a cada vez)",
    "bitbybit.lists.includes": "inclui",
    "includes": "inclui",
    "bitbybit.lists.includes_description": "Verifica se a lista contém um item específico. Exemplo: Lista [10, 20, 30, 40] com item 30 retorna verdadeiro, com item 50 retorna falso",
    "bitbybit.lists.findIndex": "encontrar índice",
    "findIndex": "encontrar índice",
    "bitbybit.lists.findIndex_description": "Encontra a posição (índice) da primeira ocorrência de um item na lista. Exemplo: Em [10, 20, 30, 20, 40], encontrar 20 retorna 1 (primeira ocorrência), encontrar 50 retorna -1 (não encontrado)",
    "bitbybit.lists.removeFirstItem": "remover primeiro item",
    "removeFirstItem": "remover primeiro item",
    "bitbybit.lists.removeFirstItem_description": "Remove o primeiro item da lista. Exemplo: De [10, 20, 30, 40], retorna [20, 30, 40]",
    "bitbybit.lists.removeLastItem": "remover último item",
    "removeLastItem": "remover último item",
    "bitbybit.lists.removeLastItem_description": "Remove o último item da lista. Exemplo: De [10, 20, 30, 40], retorna [10, 20, 30]",
    "bitbybit.lists.removeItemAtIndexFromEnd": "remover item no índice do fim",
    "removeItemAtIndexFromEnd": "remover item no índice do fim",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Remove um item contando a partir do final da lista (índice 0 = último item, 1 = penúltimo, etc.). Exemplo: De [10, 20, 30, 40, 50], remover índice 1 do fim resulta em [10, 20, 30, 50] (remove 40)",
    "bitbybit.lists.removeDuplicates": "remover duplicatas",
    "removeDuplicates": "remover duplicatas",
    "bitbybit.lists.removeDuplicates_description": "Remove itens duplicados da lista usando comparação de igualdade estrita (funciona com qualquer tipo). Exemplo: De ['a', 'b', 'c', 'a', 'd', 'b'], retorna ['a', 'b', 'c', 'd']",
    "bitbybit.lists.concatenate": "concatenar",
    "concatenate": "concatenar",
    "bitbybit.lists.concatenate_description": "Combina várias listas em uma única lista juntando-as de ponta a ponta. Exemplo: De [[1, 2], [3, 4], [5, 6]], retorna [1, 2, 3, 4, 5, 6]",
    "bitbybit.lists.interleave": "intercalar",
    "interleave": "intercalar",
    "bitbybit.lists.interleave_description": "Combina várias listas alternando elementos de cada lista (primeiro da lista1, primeiro da lista2, segundo da lista1, etc.). Exemplo: De [[0, 1, 2], [3, 4, 5]], retorna [0, 3, 1, 4, 2, 5]",
    "bitbybit.text.includes": "inclui",
    "bitbybit.text.includes_description": "Verifica se o texto contém uma string de pesquisa. Exemplo: texto='olá mundo', busca='mundo' → verdadeiro",
    "bitbybit.text.startsWith": "começa com",
    "startsWith": "começa com",
    "bitbybit.text.startsWith_description": "Verifica se o texto começa com uma string de pesquisa. Exemplo: texto='olá mundo', busca='olá' → verdadeiro",
    "bitbybit.text.endsWith": "termina com",
    "endsWith": "termina com",
    "bitbybit.text.endsWith_description": "Verifica se o texto termina com uma string de pesquisa. Exemplo: texto='olá mundo', busca='mundo' → verdadeiro",
    "bitbybit.text.indexOf": "índice de",
    "indexOf": "índice de",
    "bitbybit.text.indexOf_description": "Retorna o índice da primeira ocorrência de uma string de pesquisa. Exemplo: texto='olá mundo', busca='mundo' → 4",
    "bitbybit.text.lastIndexOf": "último índice de",
    "lastIndexOf": "último índice de",
    "bitbybit.text.lastIndexOf_description": "Retorna o índice da última ocorrência de uma string de pesquisa. Exemplo: texto='olá mundo olá', busca='olá' → 10",
    "bitbybit.text.substring": "substring",
    "substring": "substring",
    "bitbybit.text.substring_description": "Extrai uma seção de texto entre dois índices. Exemplo: texto='olá mundo', início=0, fim=3 → 'olá'",
    "bitbybit.text.slice": "fatiar (slice)",
    "bitbybit.text.slice_description": "Extrai uma seção de texto e retorna uma nova string. Exemplo: texto='olá mundo', início=0, fim=3 → 'olá'",
    "bitbybit.text.charAt": "caractere em",
    "charAt": "caractere em",
    "bitbybit.text.charAt_description": "Retorna o caractere no índice especificado. Exemplo: texto='olá', índice=1 → 'l'",
    "bitbybit.text.trim": "aparar (trim)",
    "bitbybit.text.trim_description": "Remove espaços em branco de ambas as extremidades do texto. Exemplo: texto='  olá  ' → 'olá'",
    "bitbybit.text.trimStart": "aparar início",
    "trimStart": "aparar início",
    "bitbybit.text.trimStart_description": "Remove espaços em branco do início do texto. Exemplo: texto='  olá  ' → 'olá  '",
    "bitbybit.text.trimEnd": "aparar fim",
    "trimEnd": "aparar fim",
    "bitbybit.text.trimEnd_description": "Remove espaços em branco do final do texto. Exemplo: texto='  olá  ' → '  olá'",
    "bitbybit.text.padStart": "preencher início",
    "padStart": "preencher início",
    "bitbybit.text.padStart_description": "Preenche o texto desde o início para atingir o comprimento alvo. Exemplo: texto='x', comprimento=3, stringPreenchimento='a' → 'aax'",
    "padString": "string de preenchimento",
    "bitbybit.text.padEnd": "preencher fim",
    "padEnd": "preencher fim",
    "bitbybit.text.padEnd_description": "Preenche o texto a partir do final para atingir o comprimento alvo. Exemplo: texto='x', comprimento=3, stringPreenchimento='a' → 'xaa'",
    "bitbybit.text.toUpperCase": "para maiúsculas",
    "toUpperCase": "para maiúsculas",
    "bitbybit.text.toUpperCase_description": "Converte o texto para maiúsculas. Exemplo: texto='olá' → 'OLÁ'",
    "bitbybit.text.toLowerCase": "para minúsculas",
    "toLowerCase": "para minúsculas",
    "bitbybit.text.toLowerCase_description": "Converte o texto para minúsculas. Exemplo: texto='OLÁ' → 'olá'",
    "bitbybit.text.toUpperCaseFirst": "primeira maiúscula",
    "toUpperCaseFirst": "primeira maiúscula",
    "bitbybit.text.toUpperCaseFirst_description": "Capitaliza o primeiro caractere do texto. Exemplo: texto='olá mundo' → 'Olá mundo'",
    "bitbybit.text.toLowerCaseFirst": "primeira minúscula",
    "toLowerCaseFirst": "primeira minúscula",
    "bitbybit.text.toLowerCaseFirst_description": "Coloca em minúscula o primeiro caractere do texto. Exemplo: texto='Olá Mundo' → 'olá Mundo'",
    "bitbybit.text.repeat": "repetir",
    "bitbybit.text.repeat_description": "Repete o texto um número especificado de vezes. Exemplo: texto='ha', contagem=3 → 'hahaha'",
    "bitbybit.text.reverse": "inverter",
    "bitbybit.text.reverse_description": "Inverte os caracteres no texto. Exemplo: texto='olá' → 'álo'",
    "bitbybit.text.length": "comprimento",
    "bitbybit.text.length_description": "Retorna o comprimento do texto. Exemplo: texto='olá' → 3",
    "bitbybit.text.isEmpty": "está vazio",
    "bitbybit.text.isEmpty_description": "Verifica se o texto está vazio ou apenas com espaços em branco. Exemplo: texto='   ' → verdadeiro",
    "bitbybit.text.concat": "concatenar",
    "concat": "concatenar",
    "bitbybit.text.concat_description": "Concatena várias strings de texto. Exemplo: textos=['olá', ' ', 'mundo'] → 'olá mundo'",
    "texts": "textos",
    "bitbybit.text.regexTest": "teste regex",
    "regexTest": "teste regex",
    "bitbybit.text.regexTest_description": "Testa se o texto corresponde a um padrão de expressão regular. Exemplo: texto='ola123', padrão='[0-9]+' → verdadeiro",
    "regex": "regex",
    "flags": "flags",
    "bitbybit.text.regexMatch": "correspondência regex",
    "regexMatch": "correspondência regex",
    "bitbybit.text.regexMatch_description": "Combina texto com uma expressão regular e retorna correspondências. Exemplo: texto='ola123mundo456', padrão='[0-9]+', flags='g' → ['123', '456']",
    "bitbybit.text.regexReplace": "substituição regex",
    "regexReplace": "substituição regex",
    "bitbybit.text.regexReplace_description": "Substitui texto correspondente a um padrão de expressão regular. Exemplo: texto='ola123mundo456', padrão='[0-9]+', flags='g', substituirPor='X' → 'olaXmundoX'",
    "bitbybit.text.regexSearch": "busca regex",
    "regexSearch": "busca regex",
    "bitbybit.text.regexSearch_description": "Pesquisa texto por um padrão de expressão regular e retorna o índice. Exemplo: texto='ola123', padrão='[0-9]+' → 3",
    "bitbybit.text.regexSplit": "divisão regex",
    "regexSplit": "divisão regex",
    "bitbybit.text.regexSplit_description": "Divide o texto usando um padrão de expressão regular. Exemplo: texto='a1b2c3', padrão='[0-9]+' → ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "analisar para array",
    "csv": "csv",
    "parseToArray": "analisar para array",
    "bitbybit.csv.parseToArray_description": "Analisa texto CSV para um array 2D de strings (linhas e colunas). Exemplo: csv='a,b,c 1,2,3' → [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "separador de linha",
    "columnSeparator": "separador de coluna",
    "bitbybit.csv.parseToJson": "analisar para json",
    "parseToJson": "analisar para json",
    "bitbybit.csv.parseToJson_description": "Analisa texto CSV para um array de objetos JSON usando cabeçalhos. Exemplo: csv='nome,idade Joao,30 Maria,25', linhaCabecalho=0, linhaInicioDados=1 → [{'nome':'Joao','idade':'30'}, {'nome':'Maria','idade':'25'}]",
    "headerRow": "linha de cabeçalho",
    "dataStartRow": "linha de início de dados",
    "numberColumns": "colunas numéricas",
    "bitbybit.csv.parseToJsonWithHeaders": "analisar para json com cabeçalhos",
    "parseToJsonWithHeaders": "analisar para json com cabeçalhos",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Analisa texto CSV para JSON usando cabeçalhos personalizados (ignora cabeçalhos CSV se presentes). Exemplo: csv='Joao,30 Maria,25', cabecalhos=['nome','idade'] → [{'nome':'Joao','idade':'30'}, {'nome':'Maria','idade':'25'}]",
    "headers": "cabeçalhos",
    "bitbybit.csv.queryColumn": "consultar coluna",
    "queryColumn": "consultar coluna",
    "bitbybit.csv.queryColumn_description": "Consulta dados CSV por nome de cabeçalho de coluna e retorna todos os valores nessa coluna. Exemplo: csv='nome,idade Joao,30 Maria,25', coluna='nome' → ['Joao', 'Maria']",
    "column": "coluna",
    "asNumber": "como número",
    "bitbybit.csv.queryRowsByValue": "consultar linhas por valor",
    "queryRowsByValue": "consultar linhas por valor",
    "bitbybit.csv.queryRowsByValue_description": "Consulta dados CSV e filtra linhas onde uma coluna corresponde a um valor. Exemplo: csv='nome,idade Joao,30 Maria,25', coluna='idade', valor='30' → [{'nome':'Joao','idade':'30'}]",
    "bitbybit.csv.arrayToCsv": "array para csv",
    "arrayToCsv": "array para csv",
    "bitbybit.csv.arrayToCsv_description": "Converte um array 2D para texto CSV. Exemplo: array=[['nome','idade'], ['Joao','30']] → 'nome,idade Joao,30'",
    "array": "array",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "json para csv",
    "jsonToCsv": "json para csv",
    "bitbybit.csv.jsonToCsv_description": "Converte um array de objetos JSON para texto CSV. Exemplo: json=[{'nome':'Joao','idade':'30'}], cabecalhos=['nome','idade'] → 'nome,idade Joao,30'",
    "includeHeaders": "incluir cabeçalhos",
    "bitbybit.csv.jsonToCsvAuto": "json para csv auto",
    "jsonToCsvAuto": "json para csv auto",
    "bitbybit.csv.jsonToCsvAuto_description": "Converte um array de objetos JSON para texto CSV usando chaves de objeto como cabeçalhos. Exemplo: json=[{'nome':'Joao','idade':'30'}] → 'nome,idade Joao,30'",
    "bitbybit.csv.getHeaders": "obter cabeçalhos",
    "getHeaders": "obter cabeçalhos",
    "bitbybit.csv.getHeaders_description": "Obtém os cabeçalhos de um arquivo CSV. Exemplo: csv='nome,idade Joao,30', linhaCabecalho=0 → ['nome', 'idade']",
    "bitbybit.csv.getRowCount": "obter contagem de linhas",
    "getRowCount": "obter contagem de linhas",
    "bitbybit.csv.getRowCount_description": "Obtém o número de linhas em um arquivo CSV (excluindo cabeçalhos se especificado). Exemplo: csv='nome,idade Joao,30 Maria,25', linhaCabecalho=0 → 2",
    "hasHeaders": "tem cabeçalhos",
    "bitbybit.csv.getColumnCount": "obter contagem de colunas",
    "getColumnCount": "obter contagem de colunas",
    "bitbybit.csv.getColumnCount_description": "Obtém o número de colunas em um arquivo CSV. Exemplo: csv='nome,idade,cidade Joao,30,Rio' → 3",
    "removeTrailingZeros": "remover zeros finais",
    "bitbybit.asset.getTextFile": "obter arquivo de texto",
    "getTextFile": "obter arquivo de texto",
    "bitbybit.asset.getTextFile_description": "Obtém o texto do arquivo de recurso armazenado em sua conta na nuvem.",
    "bitbybit.asset.getLocalTextFile": "obter arquivo de texto local",
    "getLocalTextFile": "obter arquivo de texto local",
    "bitbybit.asset.getLocalTextFile_description": "Obtém o texto do arquivo de recurso armazenado em seu navegador.",
    "bitbybit.asset.download": "download",
    "bitbybit.asset.download_description": "Faz o download de um arquivo com o conteúdo, extensão e tipo de conteúdo fornecidos.",
    "content": "conteúdo",
    "string | Blob": "string | Blob",
    "extension": "extensão",
    "contentType": "tipo de conteúdo",
    "preview csv": "pré-visualizar csv",
    "startRow": "linha inicial",
    "maxRows": "máximo de linhas"
}