{
    "bitbybit.draw.drawAnyAsyncNoReturn": "desenhar qualquer assíncrono sem retorno",
    "bitbybit": "bitporbit",
    "draw": "desenhar",
    "drawAnyAsyncNoReturn": "desenhar qualquer assíncrono sem retorno",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "desenha qualquer geometria sem retornar nada",
    "draw async": "desenhar assíncrono",
    "entity": "entidade",
    "Entity": "Entidade",
    "options": "opções",
    "DrawOptions": "opções de desenho",
    "babylonMesh": "malha babylon",
    "BABYLON.Mesh | BABYLON.LinesMesh": "malha babylon ou malha de linhas",
    "bitbybit.draw.drawAnyAsync": "desenhar qualquer assíncrono",
    "drawAnyAsync": "desenhar qualquer assíncrono",
    "bitbybit.draw.drawAnyAsync_description": "desenha qualquer geometria e retorna malha babylon",
    "bitbybit.draw.drawAnyNoReturn": "desenhar qualquer sem retorno",
    "drawAnyNoReturn": "desenhar qualquer sem retorno",
    "bitbybit.draw.drawAnyNoReturn_description": "desenha geometria síncrona, não para formas occt ou jscad",
    "draw sync": "desenhar síncrono",
    "bitbybit.draw.drawAny": "desenhar qualquer",
    "drawAny": "desenhar qualquer",
    "bitbybit.draw.drawAny_description": "desenha geometria síncrona, não para formas occt ou jscad",
    "bitbybit.draw.drawGridMeshNoReturn": "desenhar malha de grade sem retorno",
    "drawGridMeshNoReturn": "desenhar malha de grade sem retorno",
    "bitbybit.draw.drawGridMeshNoReturn_description": "desenha malha de grade no chão para auxiliar na orientação",
    "grid": "grade",
    "width": "largura",
    "number": "número",
    "height": "altura",
    "subdivisions": "subdivisões",
    "majorUnitFrequency": "frequência de unidade principal",
    "minorUnitVisibility": "visibilidade de unidade secundária",
    "gridRatio": "proporção da grade",
    "opacity": "opacidade",
    "backFaceCulling": "eliminação de faces traseiras",
    "boolean": "booleano",
    "mainColor": "cor principal",
    "Base.Color": "cor base",
    "secondaryColor": "cor secundária",
    "bitbybit.draw.drawGridMesh": "desenhar malha de grade",
    "drawGridMesh": "desenhar malha de grade",
    "bitbybit.draw.drawGridMesh_description": "desenha malha de grade no chão para auxiliar na orientação",
    "bitbybit.draw.optionsSimple": "opções simples",
    "optionsSimple": "opções simples",
    "bitbybit.draw.optionsSimple_description": "define opções de desenho para geometrias básicas como pontos e linhas",
    "colours": "cores",
    "string | string[]": "texto ou array de textos",
    "size": "tamanho",
    "updatable": "atualizável",
    "hidden": "oculto",
    "bitbybit.draw.optionsOcctShape": "opções de forma occt",
    "optionsOcctShape": "opções de forma occt",
    "bitbybit.draw.optionsOcctShape_description": "define opções de desenho para formas occt como arestas e sólidos",
    "faceOpacity": "opacidade da face",
    "edgeOpacity": "opacidade da aresta",
    "edgeColour": "cor da aresta",
    "faceColour": "cor da face",
    "vertexColour": "cor do vértice",
    "faceMaterial": "material da face",
    "Base.Material": "material base",
    "edgeWidth": "largura da aresta",
    "vertexSize": "tamanho do vértice",
    "drawEdges": "desenhar arestas",
    "drawFaces": "desenhar faces",
    "drawVertices": "desenhar vértices",
    "precision": "precisão",
    "drawEdgeIndexes": "desenhar índices de arestas",
    "edgeIndexHeight": "altura do índice de aresta",
    "edgeIndexColour": "cor do índice de aresta",
    "drawFaceIndexes": "desenhar índices de faces",
    "faceIndexHeight": "altura do índice de face",
    "faceIndexColour": "cor do índice de face",
    "bitbybit.draw.optionsOcctShapeSimple": "opções de forma occt simples",
    "optionsOcctShapeSimple": "opções de forma occt simples",
    "bitbybit.draw.optionsOcctShapeSimple_description": "define opções de desenho simples para formas occt",
    "bitbybit.draw.optionsOcctShapeMaterial": "opções de material de forma occt",
    "optionsOcctShapeMaterial": "opções de material de forma occt",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "define opções de desenho com material de face personalizado para formas occt",
    "any": "qualquer",
    "bitbybit.draw.optionsManifoldShapeMaterial": "opções de material de forma manifold",
    "optionsManifoldShapeMaterial": "opções de material de forma manifold",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "define opções de desenho para geometria manifold",
    "crossSectionColour": "cor da seção transversal",
    "crossSectionWidth": "largura da seção transversal",
    "crossSectionOpacity": "opacidade da seção transversal",
    "computeNormals": "calcular normais",
    "bitbybit.draw.optionsBabylonNode": "opções de nó babylon",
    "optionsBabylonNode": "opções de nó babylon",
    "bitbybit.draw.optionsBabylonNode_description": "define opções de desenho para nós babylon js",
    "colorX": "cor x",
    "colorY": "cor y",
    "colorZ": "cor z",
    "bitbybit.babylon.mesh.dispose": "descartar malha",
    "babylon": "babylon",
    "mesh": "malha",
    "dispose": "descartar",
    "bitbybit.babylon.mesh.dispose_description": "remove malha desenhada da cena",
    "memory": "memória",
    "BABYLON.Mesh": "malha babylon",
    "bitbybit.babylon.mesh.updateDrawn": "atualizar desenhado",
    "updateDrawn": "atualizar desenhado",
    "bitbybit.babylon.mesh.updateDrawn_description": "atualiza malha babylon js sem descartar",
    "updates": "atualizações",
    "position": "posição",
    "Base.Point3": "ponto base 3",
    "rotation": "rotação",
    "Base.Vector3": "vetor base 3",
    "scaling": "escala",
    "bitbybit.babylon.mesh.setVisibility": "definir visibilidade",
    "setVisibility": "definir visibilidade",
    "bitbybit.babylon.mesh.setVisibility_description": "altera visibilidade da malha babylon js",
    "visibility": "visibilidade",
    "includeChildren": "incluir filhos",
    "bitbybit.babylon.mesh.hide": "ocultar",
    "hide": "ocultar",
    "bitbybit.babylon.mesh.hide_description": "oculta a malha",
    "bitbybit.babylon.mesh.show": "mostrar",
    "show": "mostrar",
    "bitbybit.babylon.mesh.show_description": "mostra a malha",
    "bitbybit.babylon.mesh.setParent": "definir pai",
    "setParent": "definir pai",
    "bitbybit.babylon.mesh.setParent_description": "altera o pai da malha desenhada",
    "set": "definir",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "malha babylon ou malha instanciada ou malha abstrata",
    "parentMesh": "malha pai",
    "bitbybit.babylon.mesh.getParent": "obter pai",
    "getParent": "obter pai",
    "bitbybit.babylon.mesh.getParent_description": "obtém o pai da malha desenhada",
    "get": "obter",
    "bitbybit.babylon.mesh.setCheckCollisions": "definir verificação de colisões",
    "setCheckCollisions": "definir verificação de colisões",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "altera propriedade de verificação de colisão da malha desenhada",
    "checkCollisions": "verificar colisões",
    "bitbybit.babylon.mesh.getCheckCollisions": "obter verificação de colisões",
    "getCheckCollisions": "obter verificação de colisões",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "obtém propriedade de verificação de colisão da malha desenhada",
    "bitbybit.babylon.mesh.setPickable": "definir selecionável",
    "setPickable": "definir selecionável",
    "bitbybit.babylon.mesh.setPickable_description": "altera propriedade de selecionável da malha desenhada",
    "pickable": "selecionável",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "ativar eventos de movimento de ponteiro",
    "enablePointerMoveEvents": "ativar eventos de movimento de ponteiro",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "torna a malha selecionável por eventos de movimento de ponteiro, pesado para desempenho",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "desativar eventos de movimento de ponteiro",
    "disablePointerMoveEvents": "desativar eventos de movimento de ponteiro",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "faz a malha ignorar eventos de movimento de ponteiro",
    "bitbybit.babylon.mesh.getPickable": "obter selecionável",
    "getPickable": "obter selecionável",
    "bitbybit.babylon.mesh.getPickable_description": "obtém propriedade de selecionável da malha desenhada",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "obter malhas onde o nome contém",
    "getMeshesWhereNameContains": "obter malhas onde o nome contém",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "obtém malhas com nomes que contêm o texto dado",
    "name": "nome",
    "string": "texto",
    "bitbybit.babylon.mesh.getChildMeshes": "obter malhas filhas",
    "getChildMeshes": "obter malhas filhas",
    "bitbybit.babylon.mesh.getChildMeshes_description": "obtém malhas filhas",
    "directDescendantsOnly": "apenas descendentes diretos",
    "bitbybit.babylon.mesh.getMeshesOfId": "obter malhas por id",
    "getMeshesOfId": "obter malhas por id",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "obtém malhas por id",
    "id": "id",
    "bitbybit.babylon.mesh.getMeshOfId": "obter malha por id",
    "getMeshOfId": "obter malha por id",
    "bitbybit.babylon.mesh.getMeshOfId_description": "obtém malha por id",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "obter malha por id único",
    "getMeshOfUniqueId": "obter malha por id único",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "obtém malha por id único",
    "uniqueId": "id único",
    "bitbybit.babylon.mesh.mergeMeshes": "mesclar malhas",
    "mergeMeshes": "mesclar malhas",
    "bitbybit.babylon.mesh.mergeMeshes_description": "mescla múltiplas malhas em uma",
    "edit": "editar",
    "arrayOfMeshes": "array de malhas",
    "BABYLON.Mesh[]": "array de malhas babylon",
    "disposeSource": "descartar fonte",
    "allow32BitsIndices": "permitir índices de 32 bits",
    "meshSubclass": "subclasse de malha",
    "subdivideWithSubMeshes": "subdividir com submalhas",
    "multiMultiMaterials": "múltiplos materiais múltiplos",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "converter para malha sombreada plana",
    "convertToFlatShadedMesh": "converter para malha sombreada plana",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "converte malha para malha sombreada plana",
    "bitbybit.babylon.mesh.clone": "clonar",
    "clone": "clonar",
    "bitbybit.babylon.mesh.clone_description": "clona a malha",
    "bitbybit.babylon.mesh.cloneToPositions": "clonar para posições",
    "cloneToPositions": "clonar para posições",
    "bitbybit.babylon.mesh.cloneToPositions_description": "clona malha para múltiplas posições",
    "positions": "posições",
    "Base.Point3[]": "array de pontos base 3",
    "bitbybit.babylon.mesh.setId": "definir id",
    "setId": "definir id",
    "bitbybit.babylon.mesh.setId_description": "altera id da malha desenhada",
    "bitbybit.babylon.mesh.getId": "obter id",
    "getId": "obter id",
    "bitbybit.babylon.mesh.getId_description": "obtém id da malha desenhada",
    "bitbybit.babylon.mesh.getUniqueId": "obter id único",
    "getUniqueId": "obter id único",
    "bitbybit.babylon.mesh.getUniqueId_description": "obtém id único da malha desenhada",
    "bitbybit.babylon.mesh.setName": "definir nome",
    "setName": "definir nome",
    "bitbybit.babylon.mesh.setName_description": "altera nome da malha desenhada",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "obter vértices como pontos de polígono",
    "getVerticesAsPolygonPoints": "obter vértices como pontos de polígono",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "obtém vértices como pontos de polígono para construção de malha, requer triangulação",
    "bitbybit.babylon.mesh.getName": "obter nome",
    "getName": "obter nome",
    "bitbybit.babylon.mesh.getName_description": "obtém nome da malha babylon",
    "bitbybit.babylon.mesh.setMaterial": "definir material",
    "setMaterial": "definir material",
    "bitbybit.babylon.mesh.setMaterial_description": "altera material da malha desenhada",
    "material": "material",
    "BABYLON.Material": "material babylon",
    "bitbybit.babylon.mesh.getMaterial": "obter material",
    "getMaterial": "obter material",
    "bitbybit.babylon.mesh.getMaterial_description": "obtém material da malha babylon",
    "bitbybit.babylon.mesh.getPosition": "obter posição",
    "getPosition": "obter posição",
    "bitbybit.babylon.mesh.getPosition_description": "obtém posição como ponto da malha babylon js",
    "bitbybit.babylon.mesh.getAbsolutePosition": "obter posição absoluta",
    "getAbsolutePosition": "obter posição absoluta",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "obtém posição absoluta no mundo como ponto da malha babylon js",
    "bitbybit.babylon.mesh.getRotation": "obter rotação",
    "getRotation": "obter rotação",
    "bitbybit.babylon.mesh.getRotation_description": "obtém vetor de rotação da malha babylon js",
    "bitbybit.babylon.mesh.getScale": "obter escala",
    "getScale": "obter escala",
    "bitbybit.babylon.mesh.getScale_description": "obtém vetor de escala da malha babylon js",
    "bitbybit.babylon.mesh.moveForward": "mover para frente",
    "moveForward": "mover para frente",
    "bitbybit.babylon.mesh.moveForward_description": "move malha babylon js para frente no espaço local",
    "move": "mover",
    "distance": "distância",
    "bitbybit.babylon.mesh.moveBackward": "mover para trás",
    "moveBackward": "mover para trás",
    "bitbybit.babylon.mesh.moveBackward_description": "move malha babylon js para trás no espaço local",
    "bitbybit.babylon.mesh.moveUp": "mover para cima",
    "moveUp": "mover para cima",
    "bitbybit.babylon.mesh.moveUp_description": "move malha babylon js para cima no espaço local",
    "bitbybit.babylon.mesh.moveDown": "mover para baixo",
    "moveDown": "mover para baixo",
    "bitbybit.babylon.mesh.moveDown_description": "move malha babylon js para baixo no espaço local",
    "bitbybit.babylon.mesh.moveRight": "mover para direita",
    "moveRight": "mover para direita",
    "bitbybit.babylon.mesh.moveRight_description": "move malha babylon js para direita no espaço local",
    "bitbybit.babylon.mesh.moveLeft": "mover para esquerda",
    "moveLeft": "mover para esquerda",
    "bitbybit.babylon.mesh.moveLeft_description": "move malha babylon js para esquerda no espaço local",
    "bitbybit.babylon.mesh.yaw": "guinada",
    "yaw": "guinada",
    "bitbybit.babylon.mesh.yaw_description": "rotaciona malha babylon js ao redor do eixo y local",
    "rotate": "rotacionar",
    "bitbybit.babylon.mesh.pitch": "inclinação",
    "pitch": "inclinação",
    "bitbybit.babylon.mesh.pitch_description": "rotaciona malha babylon js ao redor do eixo x local",
    "bitbybit.babylon.mesh.roll": "rolagem",
    "roll": "rolagem",
    "bitbybit.babylon.mesh.roll_description": "rotaciona malha babylon js ao redor do eixo z local",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "rotacionar ao redor do eixo com posição",
    "rotateAroundAxisWithPosition": "rotacionar ao redor do eixo com posição",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "rotaciona malha ao redor do eixo e posição por ângulo",
    "axis": "eixo",
    "angle": "ângulo",
    "bitbybit.babylon.mesh.setPosition": "definir posição",
    "setPosition": "definir posição",
    "bitbybit.babylon.mesh.setPosition_description": "atualiza posição da malha babylon js ou malha instanciada",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "malha babylon ou malha instanciada",
    "bitbybit.babylon.mesh.setRotation": "definir rotação",
    "setRotation": "definir rotação",
    "bitbybit.babylon.mesh.setRotation_description": "atualiza rotação da malha babylon js ou malha instanciada",
    "bitbybit.babylon.mesh.setScale": "definir escala",
    "setScale": "definir escala",
    "bitbybit.babylon.mesh.setScale_description": "atualiza escala da malha babylon js ou malha instanciada",
    "scale": "escala",
    "bitbybit.babylon.mesh.intersectsMesh": "interseção com malha",
    "intersectsMesh": "interseção com malha",
    "bitbybit.babylon.mesh.intersectsMesh_description": "verifica se a malha intersecta outra malha",
    "intersects": "intersecta",
    "babylonMesh2": "malha babylon 2",
    "precise": "preciso",
    "includeDescendants": "incluir descendentes",
    "bitbybit.babylon.mesh.intersectsPoint": "interseção com ponto",
    "intersectsPoint": "interseção com ponto",
    "bitbybit.babylon.mesh.intersectsPoint_description": "verifica se a malha intersecta um ponto",
    "point": "ponto",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "instância de malha e transformar sem retorno",
    "createMeshInstanceAndTransformNoReturn": "instância de malha e transformar sem retorno",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "cria instância de malha com filhos para renderização otimizada, sem retorno",
    "instance": "instância",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "instância de malha e transformar",
    "createMeshInstanceAndTransform": "instância de malha e transformar",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "cria instância de malha com filhos para renderização otimizada, retorna malha",
    "bitbybit.babylon.mesh.createMeshInstance": "instância de malha",
    "createMeshInstance": "instância de malha",
    "bitbybit.babylon.mesh.createMeshInstance_description": "cria instância de malha para renderização otimizada com filhos",
    "bitbybit.babylon.gaussianSplatting.create": "splatting gaussiano",
    "gaussianSplatting": "splatting gaussiano",
    "create": "criar",
    "bitbybit.babylon.gaussianSplatting.create_description": "cria malha de splatting gaussiano",
    "url": "url",
    "bitbybit.babylon.gaussianSplatting.clone": "clonar splatting gaussiano",
    "bitbybit.babylon.gaussianSplatting.clone_description": "clona malha de splatting gaussiano",
    "multiply": "multiplicar",
    "BABYLON.GaussianSplattingMesh": "malha de splatting gaussiano babylon",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "obter posições de splat",
    "getSplatPositions": "obter posições de splat",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "obtém posições de splat da malha de splatting gaussiano",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "congelar matriz de projeção",
    "camera": "câmera",
    "freezeProjectionMatrix": "congelar matriz de projeção",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "congela matriz de projeção da câmera",
    "adjust": "ajustar",
    "BABYLON.Camera": "câmera babylon",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "descongelar matriz de projeção",
    "unfreezeProjectionMatrix": "descongelar matriz de projeção",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "descongela matriz de projeção da câmera",
    "bitbybit.babylon.camera.setPosition": "definir posição",
    "bitbybit.babylon.camera.setPosition_description": "altera posição da câmera",
    "BABYLON.TargetCamera": "câmera alvo babylon",
    "bitbybit.babylon.camera.getPosition": "obter posição",
    "bitbybit.babylon.camera.getPosition_description": "obtém posição da câmera",
    "bitbybit.babylon.camera.setTarget": "definir alvo",
    "setTarget": "definir alvo",
    "bitbybit.babylon.camera.setTarget_description": "altera alvo da câmera",
    "target": "alvo",
    "bitbybit.babylon.camera.getTarget": "obter alvo",
    "getTarget": "obter alvo",
    "bitbybit.babylon.camera.getTarget_description": "obtém alvo da câmera",
    "bitbybit.babylon.camera.setSpeed": "definir velocidade",
    "setSpeed": "definir velocidade",
    "bitbybit.babylon.camera.setSpeed_description": "altera velocidade da câmera",
    "speed": "velocidade",
    "bitbybit.babylon.camera.getSpeed": "obter velocidade",
    "getSpeed": "obter velocidade",
    "bitbybit.babylon.camera.getSpeed_description": "obtém velocidade da câmera",
    "bitbybit.babylon.camera.setMinZ": "definir z mínimo",
    "setMinZ": "definir z mínimo",
    "bitbybit.babylon.camera.setMinZ_description": "altera z mínimo da câmera",
    "minZ": "z mínimo",
    "bitbybit.babylon.camera.setMaxZ": "definir z máximo",
    "setMaxZ": "definir z máximo",
    "bitbybit.babylon.camera.setMaxZ_description": "altera z máximo da câmera",
    "maxZ": "z máximo",
    "bitbybit.babylon.camera.makeCameraOrthographic": "tornar câmera ortográfica",
    "makeCameraOrthographic": "tornar câmera ortográfica",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "define câmera para modo ortográfico",
    "orthoLeft": "esquerda ortográfica",
    "orthoRight": "direita ortográfica",
    "orthoBottom": "inferior ortográfico",
    "orthoTop": "superior ortográfico",
    "bitbybit.babylon.camera.makeCameraPerspective": "tornar câmera perspectiva",
    "makeCameraPerspective": "tornar câmera perspectiva",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "define câmera para modo perspectiva",
    "bitbybit.babylon.camera.free.create": "câmera livre",
    "free": "livre",
    "bitbybit.babylon.camera.free.create_description": "cria câmera livre",
    "bitbybit.babylon.camera.arcRotate.create": "câmera de rotação em arco",
    "arcRotate": "rotação em arco",
    "bitbybit.babylon.camera.arcRotate.create_description": "cria câmera que rotaciona ao redor do alvo em trajetória de arco, padrão para bitporbit",
    "radius": "raio",
    "alpha": "alfa",
    "beta": "beta",
    "lowerRadiusLimit": "limite inferior de raio",
    "upperRadiusLimit": "limite superior de raio",
    "lowerAlphaLimit": "limite inferior de alfa",
    "upperAlphaLimit": "limite superior de alfa",
    "lowerBetaLimit": "limite inferior de beta",
    "upperBetaLimit": "limite superior de beta",
    "angularSensibilityX": "sensibilidade angular x",
    "angularSensibilityY": "sensibilidade angular y",
    "panningSensibility": "sensibilidade de panorâmica",
    "wheelPrecision": "precisão da roda",
    "bitbybit.babylon.camera.target.create": "câmera alvo",
    "bitbybit.babylon.camera.target.create_description": "cria câmera alvo",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "experiência ar imersiva",
    "webXr": "web xr",
    "simple": "simples",
    "createImmersiveARExperience": "experiência ar imersiva",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "cria experiência xr padrão em modo ar imersivo",
    "scene": "cena",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "experiência xr padrão com teletransporte",
    "createDefaultXRExperienceWithTeleportation": "experiência xr padrão com teletransporte",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "cria experiência xr básica com teletransporte",
    "groundMeshes": "malhas do chão",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "experiência xr padrão com teletransporte retorno",
    "createDefaultXRExperienceWithTeleportationReturn": "experiência xr padrão com teletransporte retorno",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "cria experiência xr básica com teletransporte, retorna resultado",
    "bitbybit.babylon.node.drawNode": "desenhar nó",
    "node": "nó",
    "drawNode": "desenhar nó",
    "bitbybit.babylon.node.drawNode_description": "desenha nó com tamanho e cores de eixos",
    "BABYLON.TransformNode": "nó de transformação babylon",
    "bitbybit.babylon.node.drawNodes": "desenhar nós",
    "drawNodes": "desenhar nós",
    "bitbybit.babylon.node.drawNodes_description": "desenha múltiplos nós com tamanho e cores de eixos",
    "nodes": "nós",
    "BABYLON.TransformNode[]": "array de nós de transformação babylon",
    "bitbybit.babylon.node.createNodeFromRotation": "nó a partir de rotação",
    "createNodeFromRotation": "nó a partir de rotação",
    "bitbybit.babylon.node.createNodeFromRotation_description": "cria nó na origem com rotações no espaço do pai",
    "parent": "pai",
    "BABYLON.TransformNode | null": "nó de transformação babylon ou nulo",
    "origin": "origem",
    "bitbybit.babylon.node.createWorldNode": "nó mundial",
    "createWorldNode": "nó mundial",
    "bitbybit.babylon.node.createWorldNode_description": "cria nó com a raiz como pai",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "obter vetor frontal absoluto",
    "getAbsoluteForwardVector": "obter vetor frontal absoluto",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "obtém vetor frontal absoluto no espaço mundial",
    "bitbybit.babylon.node.getAbsoluteRightVector": "obter vetor direito absoluto",
    "getAbsoluteRightVector": "obter vetor direito absoluto",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "obtém vetor direito absoluto no espaço mundial",
    "bitbybit.babylon.node.getAbsoluteUpVector": "obter vetor superior absoluto",
    "getAbsoluteUpVector": "obter vetor superior absoluto",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "obtém vetor superior absoluto no espaço mundial",
    "bitbybit.babylon.node.getAbsolutePosition": "obter posição absoluta",
    "bitbybit.babylon.node.getAbsolutePosition_description": "obtém posição absoluta do nó no espaço mundial",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "obter transformação de rotação absoluta",
    "getAbsoluteRotationTransformation": "obter transformação de rotação absoluta",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "obtém rotação absoluta como matriz de transformação (16 números)",
    "bitbybit.babylon.node.getRotationTransformation": "obter transformação de rotação",
    "getRotationTransformation": "obter transformação de rotação",
    "bitbybit.babylon.node.getRotationTransformation_description": "obtém rotação local como matriz de transformação (16 números)",
    "bitbybit.babylon.node.getChildren": "obter filhos",
    "getChildren": "obter filhos",
    "bitbybit.babylon.node.getChildren_description": "obtém filhos do nó",
    "bitbybit.babylon.node.getParent": "obter pai",
    "bitbybit.babylon.node.getParent_description": "obtém pai do nó",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "obter posição no espaço local",
    "getPositionExpressedInLocalSpace": "obter posição no espaço local",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "obtém posição do nó no espaço local",
    "bitbybit.babylon.node.getRootNode": "obter nó raiz",
    "getRootNode": "obter nó raiz",
    "bitbybit.babylon.node.getRootNode_description": "obtém nó raiz",
    "bitbybit.babylon.node.getRotation": "obter rotação",
    "bitbybit.babylon.node.getRotation_description": "obtém rotações euler do nó",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "rotacionar ao redor do eixo com posição",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "rotaciona nó ao redor do eixo e posição por ângulo",
    "bitbybit.babylon.node.rotate": "rotacionar",
    "bitbybit.babylon.node.rotate_description": "rotaciona nó ao redor da origem e eixo",
    "bitbybit.babylon.node.setAbsolutePosition": "definir posição absoluta",
    "setAbsolutePosition": "definir posição absoluta",
    "bitbybit.babylon.node.setAbsolutePosition_description": "define posição absoluta do nó",
    "bitbybit.babylon.node.setDirection": "definir direção",
    "setDirection": "definir direção",
    "bitbybit.babylon.node.setDirection_description": "define direção do nó",
    "direction": "direção",
    "number[]": "array de números",
    "bitbybit.babylon.node.setParent": "definir pai",
    "bitbybit.babylon.node.setParent_description": "define novo pai para o nó",
    "parentNode": "nó pai",
    "bitbybit.babylon.node.translate": "transladar",
    "translate": "transladar",
    "bitbybit.babylon.node.translate_description": "move nó pelo vetor de direção e distância",
    "bitbybit.babylon.scene.backgroundColour": "cor de fundo",
    "backgroundColour": "cor de fundo",
    "bitbybit.babylon.scene.backgroundColour_description": "altera cor de fundo da cena no espaço 3D",
    "environment": "ambiente",
    "colour": "cor",
    "bitbybit.babylon.scene.activateCamera": "ativar câmera",
    "activateCamera": "ativar câmera",
    "bitbybit.babylon.scene.activateCamera_description": "define câmera como ativa, substituindo a atual",
    "bitbybit.babylon.scene.useRightHandedSystem": "usar sistema destro",
    "useRightHandedSystem": "usar sistema destro",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "muda para sistema de coordenadas destro",
    "system": "sistema",
    "use": "usar",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "desenhar luz pontual sem retorno",
    "drawPointLightNoReturn": "desenhar luz pontual sem retorno",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "adiciona luz pontual à cena, sem saída",
    "lights": "luzes",
    "intensity": "intensidade",
    "diffuse": "difusa",
    "specular": "especular",
    "shadowGeneratorMapSize": "tamanho do mapa do gerador de sombras",
    "enableShadows": "ativar sombras",
    "shadowDarkness": "escuridão da sombra",
    "shadowUsePercentageCloserFiltering": "usar filtragem de porcentagem mais próxima para sombra",
    "shadowContactHardeningLightSizeUVRatio": "razão de tamanho de luz de endurecimento de contato de sombra",
    "shadowBias": "viés da sombra",
    "shadowNormalBias": "viés normal da sombra",
    "shadowMaxZ": "z máximo da sombra",
    "shadowMinZ": "z mínimo da sombra",
    "bitbybit.babylon.scene.getShadowGenerators": "obter geradores de sombras",
    "getShadowGenerators": "obter geradores de sombras",
    "bitbybit.babylon.scene.getShadowGenerators_description": "obtém geradores de sombras das luzes bitporbit",
    "bitbybit.babylon.scene.drawPointLight": "desenhar luz pontual",
    "drawPointLight": "desenhar luz pontual",
    "bitbybit.babylon.scene.drawPointLight_description": "adiciona luz pontual à cena",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "desenhar luz direcional sem retorno",
    "drawDirectionalLightNoReturn": "desenhar luz direcional sem retorno",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "adiciona luz direcional à cena, sem saída",
    "bitbybit.babylon.scene.drawDirectionalLight": "desenhar luz direcional",
    "drawDirectionalLight": "desenhar luz direcional",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "adiciona luz direcional à cena",
    "bitbybit.babylon.scene.getActiveCamera": "obter câmera ativa",
    "getActiveCamera": "obter câmera ativa",
    "bitbybit.babylon.scene.getActiveCamera_description": "obtém câmera ativa atual na cena",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "ajustar câmera de rotação em arco ativa",
    "adjustActiveArcRotateCamera": "ajustar câmera de rotação em arco ativa",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "ajusta configurações da câmera de rotação em arco ativa",
    "lookAt": "olhar para",
    "bitbybit.babylon.scene.clearAllDrawn": "limpar tudo desenhado",
    "clearAllDrawn": "limpar tudo desenhado",
    "bitbybit.babylon.scene.clearAllDrawn_description": "remove todos os objetos desenhados da cena 3D",
    "bitbybit.babylon.scene.enableSkybox": "ativar skybox",
    "enableSkybox": "ativar skybox",
    "bitbybit.babylon.scene.enableSkybox_description": "ativa skybox na cena",
    "skybox": "skybox",
    "Base.skyboxEnum": "enum skybox base",
    "blur": "desfoque",
    "environmentIntensity": "intensidade do ambiente",
    "bitbybit.babylon.scene.fog": "nevoeiro",
    "fog": "nevoeiro",
    "bitbybit.babylon.scene.fog_description": "ativa modo de nevoeiro na cena",
    "mode": "modo",
    "Base.fogModeEnum": "enum modo de nevoeiro base",
    "color": "cor",
    "density": "densidade",
    "start": "início",
    "end": "fim",
    "bitbybit.babylon.transforms.rotationCenterAxis": "eixo de centro de rotação",
    "transforms": "transformações",
    "rotationCenterAxis": "eixo de centro de rotação",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "cria transformação de rotação ao redor do centro e eixo",
    "center": "centro",
    "bitbybit.babylon.transforms.rotationCenterX": "centro de rotação x",
    "rotationCenterX": "centro de rotação x",
    "bitbybit.babylon.transforms.rotationCenterX_description": "cria transformação de rotação ao redor do centro e eixo x",
    "bitbybit.babylon.transforms.rotationCenterY": "centro de rotação y",
    "rotationCenterY": "centro de rotação y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "cria transformação de rotação ao redor do centro e eixo y",
    "bitbybit.babylon.transforms.rotationCenterZ": "centro de rotação z",
    "rotationCenterZ": "centro de rotação z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "cria transformação de rotação ao redor do centro e eixo z",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "centro de rotação guinada inclinação rolagem",
    "rotationCenterYawPitchRoll": "centro de rotação guinada inclinação rolagem",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "cria transformação de rotação com guinada, inclinação e rolagem",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "escala centro xyz",
    "scaleCenterXYZ": "escala centro xyz",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "cria transformação de escala ao redor do centro em xyz",
    "scaleXyz": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ": "escala xyz",
    "scaleXYZ": "escala xyz",
    "bitbybit.babylon.transforms.scaleXYZ_description": "cria transformação de escala nas direções x, y, z",
    "bitbybit.babylon.transforms.uniformScale": "escala uniforme",
    "uniformScale": "escala uniforme",
    "bitbybit.babylon.transforms.uniformScale_description": "cria transformação de escala uniforme",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "escala uniforme a partir do centro",
    "uniformScaleFromCenter": "escala uniforme a partir do centro",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "cria transformação de escala uniforme a partir do centro",
    "bitbybit.babylon.transforms.translationXYZ": "translação xyz",
    "translationXYZ": "translação xyz",
    "bitbybit.babylon.transforms.translationXYZ_description": "cria transformação de translação",
    "translation": "translação",
    "bitbybit.babylon.transforms.translationsXYZ": "translações xyz",
    "translationsXYZ": "translações xyz",
    "bitbybit.babylon.transforms.translationsXYZ_description": "cria múltiplas transformações de translação",
    "translations": "translações",
    "Base.Vector3[]": "array de vetores base 3",
    "bitbybit.babylon.io.loadAssetIntoScene": "carregar ativo na cena",
    "io": "entrada/saída",
    "loadAssetIntoScene": "carregar ativo na cena",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "importa malha de ativo de projeto carregado",
    "load": "carregar",
    "assetFile": "arquivo de ativo",
    "File": "arquivo",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "carregar ativo na cena sem retorno",
    "loadAssetIntoSceneNoReturn": "carregar ativo na cena sem retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "importa malha de ativo de projeto carregado, sem saída",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "carregar ativo na cena a partir de url raiz",
    "loadAssetIntoSceneFromRootUrl": "carregar ativo na cena a partir de url raiz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "importa malha de url web pública, requer cors",
    "rootUrl": "url raiz",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "carregar ativo na cena a partir de url raiz sem retorno",
    "loadAssetIntoSceneFromRootUrlNoReturn": "carregar ativo na cena a partir de url raiz sem retorno",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "importa malha de url web pública, sem saída, requer cors",
    "bitbybit.babylon.io.exportBabylon": "exportar babylon",
    "exportBabylon": "exportar babylon",
    "bitbybit.babylon.io.exportBabylon_description": "exporta cena para formato .babylon para edição",
    "export": "exportar",
    "fileName": "nome do arquivo",
    "bitbybit.babylon.io.exportGLB": "exportar glb",
    "exportGLB": "exportar glb",
    "bitbybit.babylon.io.exportGLB_description": "exporta cena para formato .glb, padrão web",
    "discardSkyboxAndGrid": "descartar skybox e grade",
    "bitbybit.babylon.io.exportMeshToStl": "exportar malha para stl",
    "exportMeshToStl": "exportar malha para stl",
    "bitbybit.babylon.io.exportMeshToStl_description": "exporta malha e filhos para stl",
    "bitbybit.babylon.io.exportMeshesToStl": "exportar malhas para stl",
    "exportMeshesToStl": "exportar malhas para stl",
    "bitbybit.babylon.io.exportMeshesToStl_description": "exporta múltiplas malhas para stl",
    "meshes": "malhas",
    "bitbybit.babylon.ray.createPickingRay": "raio de seleção",
    "ray": "raio",
    "createPickingRay": "raio de seleção",
    "bitbybit.babylon.ray.createPickingRay_description": "cria raio de seleção a partir da posição do mouse na câmera ativa",
    "bitbybit.babylon.ray.createRay": "raio",
    "createRay": "raio",
    "bitbybit.babylon.ray.createRay_description": "cria raio a partir da origem com direção e comprimento opcional",
    "length": "comprimento",
    "bitbybit.babylon.ray.createRayFromTo": "raio de para",
    "createRayFromTo": "raio de para",
    "bitbybit.babylon.ray.createRayFromTo_description": "cria raio entre dois pontos",
    "from": "de",
    "to": "para",
    "bitbybit.babylon.ray.getOrigin": "obter origem",
    "getOrigin": "obter origem",
    "bitbybit.babylon.ray.getOrigin_description": "obtém origem do raio",
    "BABYLON.Ray": "raio babylon",
    "bitbybit.babylon.ray.getDirection": "obter direção",
    "getDirection": "obter direção",
    "bitbybit.babylon.ray.getDirection_description": "obtém direção do raio",
    "bitbybit.babylon.ray.getLength": "obter comprimento",
    "getLength": "obter comprimento",
    "bitbybit.babylon.ray.getLength_description": "obtém comprimento do raio",
    "bitbybit.babylon.pick.pickWithRay": "selecionar com raio",
    "pick": "selecionar",
    "pickWithRay": "selecionar com raio",
    "bitbybit.babylon.pick.pickWithRay_description": "obtém resultado de colisão a partir da seleção por raio",
    "bitbybit.babylon.pick.pickWithPickingRay": "selecionar com raio de seleção",
    "pickWithPickingRay": "selecionar com raio de seleção",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "seleciona com raio a partir da posição do mouse na câmera ativa",
    "bitbybit.babylon.pick.getDistance": "obter distância",
    "getDistance": "obter distância",
    "bitbybit.babylon.pick.getDistance_description": "obtém distância até o objeto se selecionado",
    "get from pick info": "obter de informações de seleção",
    "pickInfo": "informações de seleção",
    "BABYLON.PickingInfo": "informações de seleção babylon",
    "bitbybit.babylon.pick.getPickedMesh": "obter malha selecionada",
    "getPickedMesh": "obter malha selecionada",
    "bitbybit.babylon.pick.getPickedMesh_description": "obtém malha que foi selecionada",
    "bitbybit.babylon.pick.getPickedPoint": "obter ponto selecionado",
    "getPickedPoint": "obter ponto selecionado",
    "bitbybit.babylon.pick.getPickedPoint_description": "obtém ponto que foi selecionado",
    "bitbybit.babylon.pick.hit": "colisão",
    "hit": "colisão",
    "bitbybit.babylon.pick.hit_description": "verifica se o raio colidiu com algo na cena",
    "bitbybit.babylon.pick.getSubMeshId": "obter id de submalha",
    "getSubMeshId": "obter id de submalha",
    "bitbybit.babylon.pick.getSubMeshId_description": "obtém id único de submalha se selecionado",
    "bitbybit.babylon.pick.getSubMeshFaceId": "obter id de face de submalha",
    "getSubMeshFaceId": "obter id de face de submalha",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "obtém id único de face de submalha se selecionado",
    "bitbybit.babylon.pick.getBU": "obter bu",
    "getBU": "obter bu",
    "bitbybit.babylon.pick.getBU_description": "obtém u baricêntrico para colisão de textura",
    "bitbybit.babylon.pick.getBV": "obter bv",
    "getBV": "obter bv",
    "bitbybit.babylon.pick.getBV_description": "obtém v baricêntrico para colisão de textura",
    "bitbybit.babylon.pick.getPickedSprite": "obter sprite selecionado",
    "getPickedSprite": "obter sprite selecionado",
    "bitbybit.babylon.pick.getPickedSprite_description": "obtém sprite selecionado",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "pbr metálico rugosidade",
    "pbrMetallicRoughness": "pbr metálico rugosidade",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "cria material pbr metálico rugosidade",
    "baseColor": "cor base",
    "emissiveColor": "cor emissiva",
    "metallic": "metálico",
    "roughness": "rugosidade",
    "zOffset": "deslocamento z",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "definir cor base",
    "setBaseColor": "definir cor base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "define cor base do material",
    "BABYLON.PBRMetallicRoughnessMaterial": "material pbr metálico rugosidade babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "definir metálico",
    "setMetallic": "definir metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "define propriedade metálica do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "definir rugosidade",
    "setRoughness": "definir rugosidade",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "define rugosidade do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "definir alfa",
    "setAlpha": "definir alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "define alfa do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "definir eliminação de faces traseiras",
    "setBackFaceCulling": "definir eliminação de faces traseiras",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "define eliminação de faces traseiras do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "definir textura base",
    "setBaseTexture": "definir textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "define textura do material",
    "baseTexture": "textura base",
    "BABYLON.Texture": "textura babylon",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "obter cor base",
    "getBaseColor": "obter cor base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "obtém cor base do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "obter metálico",
    "getMetallic": "obter metálico",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "obtém propriedade metálica do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "obter rugosidade",
    "getRoughness": "obter rugosidade",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "obtém rugosidade do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "obter alfa",
    "getAlpha": "obter alfa",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "obtém alfa do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "obter eliminação de faces traseiras",
    "getBackFaceCulling": "obter eliminação de faces traseiras",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "obtém eliminação de faces traseiras do material",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "obter textura base",
    "getBaseTexture": "obter textura base",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "obtém textura base do material",
    "bitbybit.babylon.material.skyMaterial.create": "material céu",
    "skyMaterial": "material céu",
    "bitbybit.babylon.material.skyMaterial.create_description": "cria material céu",
    "luminance": "luminância",
    "turbidity": "turbidez",
    "rayleigh": "rayleigh",
    "mieCoefficient": "coeficiente mie",
    "mieDirectionalG": "mie direcional g",
    "inclination": "inclinação",
    "azimuth": "azimute",
    "sunPosition": "posição do sol",
    "useSunPosition": "usar posição do sol",
    "cameraOffset": "deslocamento da câmera",
    "up": "cima",
    "dithering": "dithering",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "definir luminância",
    "setLuminance": "definir luminância",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "define luminância do material céu",
    "MATERIALS.SkyMaterial": "material céu de materiais",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "definir turbidez",
    "setTurbidity": "definir turbidez",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "define turbidez do material céu",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "definir rayleigh",
    "setRayleigh": "definir rayleigh",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "define rayleigh do material céu",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "definir coeficiente mie",
    "setMieCoefficient": "definir coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "define coeficiente mie do material céu",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "definir mie direcional g",
    "setMieDirectionalG": "definir mie direcional g",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "define mie direcional g do material céu",
    "bitbybit.babylon.material.skyMaterial.setDistance": "definir distância",
    "setDistance": "definir distância",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "define distância do material céu",
    "bitbybit.babylon.material.skyMaterial.setInclination": "definir inclinação",
    "setInclination": "definir inclinação",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "define inclinação do material céu",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "definir azimute",
    "setAzimuth": "definir azimute",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "define azimute do material céu",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "definir posição do sol",
    "setSunPosition": "definir posição do sol",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "define posição do sol do material céu",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "definir uso da posição do sol",
    "setUseSunPosition": "definir uso da posição do sol",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "define uso da posição do sol do material céu",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "definir deslocamento da câmera",
    "setCameraOffset": "definir deslocamento da câmera",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "define deslocamento da câmera do material céu",
    "bitbybit.babylon.material.skyMaterial.setUp": "definir direção cima",
    "setUp": "definir direção cima",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "define direção cima do material céu",
    "bitbybit.babylon.material.skyMaterial.setDithering": "definir dithering",
    "setDithering": "definir dithering",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "define dithering do material céu",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "obter luminância",
    "getLuminance": "obter luminância",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "obtém luminância do material céu",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "obter turbidez",
    "getTurbidity": "obter turbidez",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "obtém turbidez do material céu",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "obter rayleigh",
    "getRayleigh": "obter rayleigh",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "obtém rayleigh do material céu",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "obter coeficiente mie",
    "getMieCoefficient": "obter coeficiente mie",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "obtém coeficiente mie do material céu",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "obter mie direcional g",
    "getMieDirectionalG": "obter mie direcional g",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "obtém mie direcional g do material céu",
    "bitbybit.babylon.material.skyMaterial.getDistance": "obter distância",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "obtém distância do material céu",
    "bitbybit.babylon.material.skyMaterial.getInclination": "obter inclinação",
    "getInclination": "obter inclinação",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "obtém inclinação do material céu",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "obter azimute",
    "getAzimuth": "obter azimute",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "obtém azimute do material céu",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "obter posição do sol",
    "getSunPosition": "obter posição do sol",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "obtém posição do sol do material céu",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "obter uso da posição do sol",
    "getUseSunPosition": "obter uso da posição do sol",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "obtém uso da posição do sol do material céu",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "obter deslocamento da câmera",
    "getCameraOffset": "obter deslocamento da câmera",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "obtém deslocamento da câmera do material céu",
    "bitbybit.babylon.material.skyMaterial.getUp": "obter direção cima",
    "getUp": "obter direção cima",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "obtém direção cima do material céu",
    "bitbybit.babylon.material.skyMaterial.getDithering": "obter dithering",
    "getDithering": "obter dithering",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "obtém dithering do material céu",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "definir direção para alvo",
    "shadowLight": "luz de sombra",
    "setDirectionToTarget": "definir direção para alvo",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "define direção da luz de sombra",
    "BABYLON.ShadowLight": "luz de sombra babylon",
    "bitbybit.babylon.lights.shadowLight.setPosition": "definir posição",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "define posição da luz de sombra",
    "bitbybit.babylon.meshBuilder.createBox": "caixa",
    "meshBuilder": "construtor de malha",
    "createBox": "caixa",
    "bitbybit.babylon.meshBuilder.createBox_description": "cria malha de caixa",
    "create simple": "criar simples",
    "depth": "profundidade",
    "sideOrientation": "orientação lateral",
    "BabylonMesh.sideOrientationEnum": "enum de orientação lateral de malha babylon",
    "bitbybit.babylon.meshBuilder.createCube": "cubo",
    "createCube": "cubo",
    "bitbybit.babylon.meshBuilder.createCube_description": "cria malha de cubo",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "plano quadrado",
    "createSquarePlane": "plano quadrado",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "cria malha de plano quadrado",
    "bitbybit.babylon.meshBuilder.createSphere": "esfera",
    "createSphere": "esfera",
    "bitbybit.babylon.meshBuilder.createSphere_description": "cria malha de esfera",
    "diameter": "diâmetro",
    "segments": "segmentos",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "esfera icosaédrica",
    "createIcoSphere": "esfera icosaédrica",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "cria malha de esfera icosaédrica",
    "radiusX": "raio x",
    "radiusY": "raio y",
    "radiusZ": "raio z",
    "flat": "plano",
    "bitbybit.babylon.meshBuilder.createDisc": "disco",
    "createDisc": "disco",
    "bitbybit.babylon.meshBuilder.createDisc_description": "cria malha de disco",
    "tessellation": "tesselação",
    "arc": "arco",
    "bitbybit.babylon.meshBuilder.createTorus": "toro",
    "createTorus": "toro",
    "bitbybit.babylon.meshBuilder.createTorus_description": "cria malha de toro",
    "thickness": "espessura",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "nó toro",
    "createTorusKnot": "nó toro",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "cria malha de nó toro",
    "tube": "tubo",
    "radialSegments": "segmentos radiais",
    "tubularSegments": "segmentos tubulares",
    "p": "p",
    "q": "q",
    "bitbybit.babylon.meshBuilder.createPolygon": "polígono",
    "createPolygon": "polígono",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "cria malha de polígono",
    "shape": "forma",
    "holes": "furos",
    "Base.Vector3[][]": "array de arrays de vetores base 3",
    "smoothingThreshold": "limiar de suavização",
    "wrap": "envolver",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "extrudar polígono",
    "extrudePolygon": "extrudar polígono",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "cria malha de polígono extrudado",
    "bitbybit.babylon.meshBuilder.createTube": "tubo",
    "createTube": "tubo",
    "bitbybit.babylon.meshBuilder.createTube_description": "cria malha de tubo",
    "path": "caminho",
    "cap": "tampa",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "poliedro",
    "createPolyhedron": "poliedro",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "cria malha de poliedro",
    "type": "tipo",
    "sizeX": "tamanho x",
    "sizeY": "tamanho y",
    "sizeZ": "tamanho z",
    "custom": "personalizado",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodésico",
    "createGeodesic": "geodésico",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "cria malha geodésica",
    "m": "m",
    "n": "n",
    "bitbybit.babylon.meshBuilder.createGoldberg": "goldberg",
    "createGoldberg": "goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "cria malha goldberg",
    "bitbybit.babylon.meshBuilder.createCapsule": "cápsula",
    "createCapsule": "cápsula",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "cria malha de cápsula",
    "orientation": "orientação",
    "capSubdivisions": "subdivisões da tampa",
    "radiusTop": "raio superior",
    "radiusBottom": "raio inferior",
    "topCapSubdivisions": "subdivisões da tampa superior",
    "bottomCapSubdivisions": "subdivisões da tampa inferior",
    "bitbybit.babylon.meshBuilder.createCylinder": "cilindro",
    "createCylinder": "cilindro",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "cria malha de cilindro",
    "diameterTop": "diâmetro superior",
    "diameterBottom": "diâmetro inferior",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "forma extrudada",
    "createExtrudedSahpe": "forma extrudada",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "cria malha de forma extrudada",
    "closeShape": "fechar forma",
    "closePath": "fechar caminho",
    "bitbybit.babylon.meshBuilder.createRibbon": "fita",
    "createRibbon": "fita",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "cria malha de fita",
    "pathArray": "array de caminhos",
    "closeArray": "fechar array",
    "offset": "deslocamento",
    "bitbybit.babylon.meshBuilder.createLathe": "torno",
    "createLathe": "torno",
    "bitbybit.babylon.meshBuilder.createLathe_description": "cria malha de torno",
    "closed": "fechado",
    "bitbybit.babylon.meshBuilder.createGround": "chão",
    "createGround": "chão",
    "bitbybit.babylon.meshBuilder.createGround_description": "cria malha de chão",
    "subdivisionsX": "subdivisões x",
    "subdivisionsY": "subdivisões y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "plano retangular",
    "createRectanglePlane": "plano retangular",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "cria malha de plano retangular",
    "bitbybit.babylon.texture.createSimple": "textura simples",
    "texture": "textura",
    "createSimple": "simples",
    "bitbybit.babylon.texture.createSimple_description": "cria textura a partir de url com opções básicas",
    "invertY": "inverter y",
    "invertZ": "inverter z",
    "wAng": "ângulo w",
    "uScale": "escala u",
    "vScale": "escala v",
    "uOffset": "deslocamento u",
    "vOffset": "deslocamento v",
    "samplingMode": "modo de amostragem",
    "samplingModeEnum": "enum de modo de amostragem",
    "bitbybit.babylon.tools.createScreenshot": "captura de tela",
    "tools": "ferramentas",
    "createScreenshot": "captura de tela",
    "bitbybit.babylon.tools.createScreenshot_description": "captura captura de tela da cena",
    "screenshots": "capturas de tela",
    "mimeType": "tipo mime",
    "quality": "qualidade",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "captura de tela e download",
    "createScreenshotAndDownload": "captura de tela e download",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "captura e faz download da captura de tela da cena",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "interface de tela cheia",
    "gui": "interface gráfica",
    "advancedDynamicTexture": "textura dinâmica avançada",
    "createFullScreenUI": "interface de tela cheia",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "cria interface de tela cheia",
    "spaces": "espaços",
    "foreground": "primeiro plano",
    "adaptiveScaling": "escala adaptativa",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "para malha",
    "createForMesh": "para malha",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "cria textura para malha",
    "BABYLON.AbstractMesh": "malha abstrata babylon",
    "supportPointerMove": "suportar movimento de ponteiro",
    "onlyAlphaTesting": "somente teste alfa",
    "sampling": "amostragem",
    "BabylonTexture.samplingModeEnum": "enum de modo de amostragem de textura babylon",
    "bitbybit.babylon.gui.control.changeControlPadding": "alterar preenchimento de controle",
    "control": "controle",
    "changeControlPadding": "alterar preenchimento de controle",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "define o preenchimento do controle",
    "positioning": "posicionamento",
    "BABYLON.GUI.Control": "controle de interface gráfica babylon",
    "paddingLeft": "preenchimento à esquerda",
    "number | string": "número ou texto",
    "paddingRight": "preenchimento à direita",
    "paddingTop": "preenchimento superior",
    "paddingBottom": "preenchimento inferior",
    "bitbybit.babylon.gui.control.changeControlAlignment": "alterar alinhamento de controle",
    "changeControlAlignment": "alterar alinhamento de controle",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "define o alinhamento do controle",
    "T": "t",
    "horizontalAlignment": "alinhamento horizontal",
    "horizontalAlignmentEnum": "enum de alinhamento horizontal",
    "verticalAlignment": "alinhamento vertical",
    "verticalAlignmentEnum": "enum de alinhamento vertical",
    "bitbybit.babylon.gui.control.cloneControl": "clonar controle",
    "cloneControl": "clonar controle",
    "bitbybit.babylon.gui.control.cloneControl_description": "clona o controle",
    "container": "contêiner",
    "BABYLON.GUI.Container": "contêiner de interface gráfica babylon",
    "host": "hospedeiro",
    "BABYLON.GUI.AdvancedDynamicTexture": "textura dinâmica avançada de interface gráfica babylon",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "seletor observável de controle",
    "createControlObservableSelector": "seletor observável de controle",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "cria seletor observável para o controle",
    "selector": "seletor",
    "controlObservableSelectorEnum": "enum de seletor observável de controle",
    "bitbybit.babylon.gui.control.getControlByName": "obter controle por nome",
    "getControlByName": "obter controle por nome",
    "bitbybit.babylon.gui.control.getControlByName_description": "obtém controle por nome",
    "bitbybit.babylon.gui.control.setIsVisible": "definir visibilidade",
    "setIsVisible": "definir visibilidade",
    "bitbybit.babylon.gui.control.setIsVisible_description": "define a visibilidade do controle",
    "isVisible": "é visível",
    "bitbybit.babylon.gui.control.setIsReadonly": "definir somente leitura",
    "setIsReadonly": "definir somente leitura",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "define o controle como somente leitura",
    "isReadOnly": "é somente leitura",
    "bitbybit.babylon.gui.control.setIsEnabled": "definir habilitado",
    "setIsEnabled": "definir habilitado",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "define o controle como habilitado",
    "isEnabled": "está habilitado",
    "bitbybit.babylon.gui.control.setHeight": "definir altura",
    "setHeight": "definir altura",
    "bitbybit.babylon.gui.control.setHeight_description": "define a altura do controle",
    "bitbybit.babylon.gui.control.setWidth": "definir largura",
    "setWidth": "definir largura",
    "bitbybit.babylon.gui.control.setWidth_description": "define a largura do controle",
    "bitbybit.babylon.gui.control.setColor": "definir cor",
    "setColor": "definir cor",
    "bitbybit.babylon.gui.control.setColor_description": "define a cor do controle",
    "bitbybit.babylon.gui.control.setFontSize": "definir tamanho da fonte",
    "setFontSize": "definir tamanho da fonte",
    "bitbybit.babylon.gui.control.setFontSize_description": "define o tamanho da fonte do controle",
    "fontSize": "tamanho da fonte",
    "bitbybit.babylon.gui.control.getHeight": "obter altura",
    "getHeight": "obter altura",
    "bitbybit.babylon.gui.control.getHeight_description": "obtém a altura do controle",
    "bitbybit.babylon.gui.control.getWidth": "obter largura",
    "getWidth": "obter largura",
    "bitbybit.babylon.gui.control.getWidth_description": "obtém a largura do controle",
    "bitbybit.babylon.gui.control.getColor": "obter cor",
    "getColor": "obter cor",
    "bitbybit.babylon.gui.control.getColor_description": "obtém a cor do controle",
    "bitbybit.babylon.gui.control.getFontSize": "obter tamanho da fonte",
    "getFontSize": "obter tamanho da fonte",
    "bitbybit.babylon.gui.control.getFontSize_description": "obtém o tamanho da fonte do controle",
    "bitbybit.babylon.gui.control.getIsVisible": "obter visibilidade",
    "getIsVisible": "obter visibilidade",
    "bitbybit.babylon.gui.control.getIsVisible_description": "obtém a visibilidade do controle",
    "bitbybit.babylon.gui.control.getIsReadonly": "obter somente leitura",
    "getIsReadonly": "obter somente leitura",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "obtém o estado somente leitura do controle",
    "bitbybit.babylon.gui.control.getIsEnabled": "obter habilitado",
    "getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "obtém o estado habilitado do controle",
    "bitbybit.babylon.gui.container.addControls": "adicionar controles",
    "addControls": "adicionar controles",
    "bitbybit.babylon.gui.container.addControls_description": "adiciona controles ao contêiner em ordem",
    "controls": "controles",
    "BABYLON.GUI.Control[]": "array de controles de interface gráfica babylon",
    "clearControlsFirst": "limpar controles primeiro",
    "bitbybit.babylon.gui.container.setBackground": "definir fundo",
    "setBackground": "definir fundo",
    "bitbybit.babylon.gui.container.setBackground_description": "define o fundo do contêiner",
    "background": "fundo",
    "bitbybit.babylon.gui.container.setIsReadonly": "definir somente leitura",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "define o contêiner como somente leitura",
    "bitbybit.babylon.gui.container.getBackground": "obter fundo",
    "getBackground": "obter fundo",
    "bitbybit.babylon.gui.container.getBackground_description": "obtém o fundo do contêiner",
    "bitbybit.babylon.gui.container.getIsReadonly": "obter somente leitura",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "obtém o estado somente leitura do contêiner",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "painel de pilha",
    "stackPanel": "painel de pilha",
    "createStackPanel": "painel de pilha",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "cria painel de pilha",
    "isVertical": "é vertical",
    "spacing": "espaçamento",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "definir vertical",
    "setIsVertical": "definir vertical",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "define o painel de pilha como vertical",
    "BABYLON.GUI.StackPanel": "painel de pilha de interface gráfica babylon",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "definir espaçamento",
    "setSpacing": "definir espaçamento",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "define o espaçamento do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.setWidth": "definir largura",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "define a largura do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.setHeight": "definir altura",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "define a altura do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "obter vertical",
    "getIsVertical": "obter vertical",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "obtém o estado vertical do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "obter espaçamento",
    "getSpacing": "obter espaçamento",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "obtém o espaçamento do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getWidth": "obter largura",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "obtém a largura do painel de pilha",
    "bitbybit.babylon.gui.stackPanel.getHeight": "obter altura",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "obtém a altura do painel de pilha",
    "bitbybit.babylon.gui.button.createSimpleButton": "botão simples",
    "button": "botão",
    "createSimpleButton": "botão simples",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "cria botão simples",
    "label": "rótulo",
    "bitbybit.babylon.gui.button.setButtonText": "definir texto do botão",
    "setButtonText": "definir texto do botão",
    "bitbybit.babylon.gui.button.setButtonText_description": "define o texto do botão",
    "BABYLON.GUI.Button": "botão de interface gráfica babylon",
    "text": "texto",
    "bitbybit.babylon.gui.button.getButtonText": "obter texto do botão",
    "getButtonText": "obter texto do botão",
    "bitbybit.babylon.gui.button.getButtonText_description": "obtém o texto do botão",
    "bitbybit.babylon.gui.slider.createSlider": "deslizador",
    "slider": "deslizador",
    "createSlider": "deslizador",
    "bitbybit.babylon.gui.slider.createSlider_description": "cria deslizador",
    "minimum": "mínimo",
    "maximum": "máximo",
    "value": "valor",
    "step": "passo",
    "displayThumb": "exibir polegar",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "alterar polegar do deslizador",
    "changeSliderThumb": "alterar polegar do deslizador",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "altera propriedades do polegar do deslizador",
    "BABYLON.GUI.Slider": "deslizador de interface gráfica babylon",
    "isThumbCircle": "polegar é círculo",
    "thumbColor": "cor do polegar",
    "thumbWidth": "largura do polegar",
    "string | number": "texto ou número",
    "isThumbClamped": "polegar está preso",
    "bitbybit.babylon.gui.slider.setBorderColor": "definir cor da borda",
    "setBorderColor": "definir cor da borda",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "define a cor da borda do deslizador",
    "borderColor": "cor da borda",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "definir cor de fundo",
    "setBackgroundColor": "definir cor de fundo",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "define a cor de fundo do deslizador",
    "backgroundColor": "cor de fundo",
    "bitbybit.babylon.gui.slider.setMaximum": "definir máximo",
    "setMaximum": "definir máximo",
    "bitbybit.babylon.gui.slider.setMaximum_description": "define o valor máximo do deslizador",
    "bitbybit.babylon.gui.slider.setMinimum": "definir mínimo",
    "setMinimum": "definir mínimo",
    "bitbybit.babylon.gui.slider.setMinimum_description": "define o valor mínimo do deslizador",
    "bitbybit.babylon.gui.slider.setStep": "definir passo",
    "setStep": "definir passo",
    "bitbybit.babylon.gui.slider.setStep_description": "define o valor do passo do deslizador",
    "bitbybit.babylon.gui.slider.setValue": "definir valor",
    "setValue": "definir valor",
    "bitbybit.babylon.gui.slider.setValue_description": "define o valor do deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "seletor observável do deslizador",
    "createSliderObservableSelector": "seletor observável do deslizador",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "cria seletor observável para o deslizador",
    "sliderObservableSelectorEnum": "enum de seletor observável do deslizador",
    "bitbybit.babylon.gui.slider.getBorderColor": "obter cor da borda",
    "getBorderColor": "obter cor da borda",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "obtém a cor da borda do deslizador",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "obter cor de fundo",
    "getBackgroundColor": "obter cor de fundo",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "obtém a cor de fundo do deslizador",
    "bitbybit.babylon.gui.slider.getMaximum": "obter máximo",
    "getMaximum": "obter máximo",
    "bitbybit.babylon.gui.slider.getMaximum_description": "obtém o valor máximo do deslizador",
    "bitbybit.babylon.gui.slider.getMinimum": "obter mínimo",
    "getMinimum": "obter mínimo",
    "bitbybit.babylon.gui.slider.getMinimum_description": "obtém o valor mínimo do deslizador",
    "bitbybit.babylon.gui.slider.getStep": "obter passo",
    "getStep": "obter passo",
    "bitbybit.babylon.gui.slider.getStep_description": "obtém o valor do passo do deslizador",
    "bitbybit.babylon.gui.slider.getValue": "obter valor",
    "getValue": "obter valor",
    "bitbybit.babylon.gui.slider.getValue_description": "obtém o valor do deslizador",
    "bitbybit.babylon.gui.slider.getThumbColor": "obter cor do polegar",
    "getThumbColor": "obter cor do polegar",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "obtém a cor do polegar do deslizador",
    "bitbybit.babylon.gui.slider.getThumbWidth": "obter largura do polegar",
    "getThumbWidth": "obter largura do polegar",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "obtém a largura do polegar do deslizador",
    "bitbybit.babylon.gui.slider.getIsVertical": "obter vertical",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "obtém o estado vertical do deslizador",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "obter exibição do polegar",
    "getDisplayThumb": "obter exibição do polegar",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "obtém a exibição do polegar do deslizador",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "obter polegar círculo",
    "getIsThumbCircle": "obter polegar círculo",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "obtém se o polegar do deslizador é círculo",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "obter polegar preso",
    "getIsThumbClamped": "obter polegar preso",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "obtém se o polegar do deslizador está preso",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "bloco de texto",
    "textBlock": "bloco de texto",
    "createTextBlock": "bloco de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "cria bloco de texto",
    "bitbybit.babylon.gui.textBlock.alignText": "alinhar texto",
    "alignText": "alinhar texto",
    "bitbybit.babylon.gui.textBlock.alignText_description": "define o alinhamento do texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "definir contorno do texto",
    "setTextOutline": "definir contorno do texto",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "define o contorno do texto",
    "BABYLON.GUI.TextBlock": "bloco de texto de interface gráfica babylon",
    "outlineWidth": "largura do contorno",
    "outlineColor": "cor do contorno",
    "bitbybit.babylon.gui.textBlock.setText": "definir texto",
    "setText": "definir texto",
    "bitbybit.babylon.gui.textBlock.setText_description": "define o texto do bloco de texto",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "definir redimensionar para ajustar",
    "setRsizeToFit": "definir redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "define redimensionar para ajustar",
    "resizeToFit": "redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "definir quebra de texto",
    "setTextWrapping": "definir quebra de texto",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "define a quebra de texto",
    "textWrapping": "quebra de texto",
    "boolean | BABYLON.GUI.TextWrapping": "booleano ou quebra de texto de interface gráfica babylon",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "definir espaçamento de linha",
    "setLineSpacing": "definir espaçamento de linha",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "define o espaçamento de linha do texto",
    "lineSpacing": "espaçamento de linha",
    "bitbybit.babylon.gui.textBlock.getText": "obter texto",
    "getText": "obter texto",
    "bitbybit.babylon.gui.textBlock.getText_description": "obtém o texto do bloco de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "obter quebra de texto",
    "getTextWrapping": "obter quebra de texto",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "obtém a quebra de texto",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "obter espaçamento de linha",
    "getLineSpacing": "obter espaçamento de linha",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "obtém o espaçamento de linha do texto",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "obter largura do contorno",
    "getOutlineWidth": "obter largura do contorno",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "obtém a largura do contorno do texto",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "obter redimensionar para ajustar",
    "getResizeToFit": "obter redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "obtém redimensionar para ajustar",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "obter alinhamento horizontal do texto",
    "getTextHorizontalAlignment": "obter alinhamento horizontal do texto",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "obtém o alinhamento horizontal do texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "obter alinhamento vertical do texto",
    "getTextVerticalAlignment": "obter alinhamento vertical do texto",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "obtém o alinhamento vertical do texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "seletor observável de bloco de texto",
    "createTextBlockObservableSelector": "seletor observável de bloco de texto",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "cria seletor observável para bloco de texto",
    "textBlockObservableSelectorEnum": "enum de seletor observável de bloco de texto",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "botão de rádio",
    "radioButton": "botão de rádio",
    "createRadioButton": "botão de rádio",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "cria botão de rádio",
    "group": "grupo",
    "isChecked": "está marcado",
    "checkSizeRatio": "razão de tamanho da marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "definir razão de tamanho da marca",
    "setCheckSizeRatio": "definir razão de tamanho da marca",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "define a razão de tamanho da marca do botão de rádio",
    "BABYLON.GUI.RadioButton": "botão de rádio de interface gráfica babylon",
    "bitbybit.babylon.gui.radioButton.setGroup": "definir grupo",
    "setGroup": "definir grupo",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "define o grupo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.setBackground": "definir fundo",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "define o fundo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "obter razão de tamanho da marca",
    "getCheckSizeRatio": "obter razão de tamanho da marca",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "obtém a razão de tamanho da marca do botão de rádio",
    "bitbybit.babylon.gui.radioButton.getGroup": "obter grupo",
    "getGroup": "obter grupo",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "obtém o grupo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.getBackground": "obter fundo",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "obtém o fundo do botão de rádio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "seletor observável de botão de rádio",
    "createRadioButtonObservableSelector": "seletor observável de botão de rádio",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "cria seletor observável para botão de rádio",
    "radioButtonObservableSelectorEnum": "enum de seletor observável de botão de rádio",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "caixa de seleção",
    "checkbox": "caixa de seleção",
    "createCheckbox": "caixa de seleção",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "cria caixa de seleção",
    "bitbybit.babylon.gui.checkbox.setBackground": "definir fundo",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "define o fundo da caixa de seleção",
    "BABYLON.GUI.Checkbox": "caixa de seleção de interface gráfica babylon",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "definir razão de tamanho da marca",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "define a razão de tamanho da marca da caixa de seleção",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "definir marcado",
    "setIsChecked": "definir marcado",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "define a caixa de seleção como marcada",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "obter razão de tamanho da marca",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "obtém a razão de tamanho da marca da caixa de seleção",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "obter marcado",
    "getIsChecked": "obter marcado",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "obtém o estado marcado da caixa de seleção",
    "bitbybit.babylon.gui.checkbox.getBackground": "obter fundo",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "obtém o fundo da caixa de seleção",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "seletor observável de caixa de seleção",
    "createCheckboxObservableSelector": "seletor observável de caixa de seleção",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "cria seletor observável para caixa de seleção",
    "checkboxObservableSelectorEnum": "enum de seletor observável de caixa de seleção",
    "bitbybit.babylon.gui.inputText.createInputText": "texto de entrada",
    "inputText": "texto de entrada",
    "createInputText": "texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputText_description": "cria texto de entrada",
    "placeholder": "marcador de posição",
    "bitbybit.babylon.gui.inputText.setBackground": "definir fundo",
    "bitbybit.babylon.gui.inputText.setBackground_description": "define o fundo do texto de entrada",
    "BABYLON.GUI.InputText": "texto de entrada de interface gráfica babylon",
    "bitbybit.babylon.gui.inputText.setText": "definir texto",
    "bitbybit.babylon.gui.inputText.setText_description": "define o texto de entrada",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "definir marcador de posição",
    "setPlaceholder": "definir marcador de posição",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "define o marcador de posição do texto de entrada",
    "bitbybit.babylon.gui.inputText.getBackground": "obter fundo",
    "bitbybit.babylon.gui.inputText.getBackground_description": "obtém o fundo do texto de entrada",
    "bitbybit.babylon.gui.inputText.getText": "obter texto",
    "bitbybit.babylon.gui.inputText.getText_description": "obtém o texto de entrada",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "obter marcador de posição",
    "getPlaceholder": "obter marcador de posição",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "obtém o marcador de posição do texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "seletor observável de texto de entrada",
    "createInputTextObservableSelector": "seletor observável de texto de entrada",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "cria seletor observável para texto de entrada",
    "inputTextObservableSelectorEnum": "enum de seletor observável de texto de entrada",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "seletor de cor",
    "colorPicker": "seletor de cor",
    "createColorPicker": "seletor de cor",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "cria seletor de cor",
    "defaultColor": "cor padrão",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "definir valor do seletor de cor",
    "setColorPickerValue": "definir valor do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "define o valor do seletor de cor",
    "BABYLON.GUI.ColorPicker": "seletor de cor de interface gráfica babylon",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "definir tamanho do seletor de cor",
    "setColorPickerSize": "definir tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "define o tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "obter valor do seletor de cor",
    "getColorPickerValue": "obter valor do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "obtém o valor do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "obter tamanho do seletor de cor",
    "getColorPickerSize": "obter tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "obtém o tamanho do seletor de cor",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "seletor observável de seletor de cor",
    "createColorPickerObservableSelector": "seletor observável de seletor de cor",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "cria seletor observável para seletor de cor",
    "colorPickerObservableSelectorEnum": "enum de seletor observável de seletor de cor",
    "bitbybit.babylon.gui.image.createImage": "imagem",
    "image": "imagem",
    "createImage": "imagem",
    "bitbybit.babylon.gui.image.createImage_description": "cria imagem",
    "bitbybit.babylon.gui.image.setSourceUrl": "definir url de origem",
    "setSourceUrl": "definir url de origem",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "define a url de origem da imagem",
    "BABYLON.GUI.Image": "imagem de interface gráfica babylon",
    "bitbybit.babylon.gui.image.getSourceUrl": "obter url de origem",
    "getSourceUrl": "obter url de origem",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "obtém a url de origem da imagem",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "gerenciador de gizmo",
    "gizmo": "gizmo",
    "manager": "gerenciador",
    "createGizmoManager": "gerenciador de gizmo",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "cria gerenciador de gizmo",
    "positionGizmoEnabled": "gizmo de posição ativado",
    "rotationGizmoEnabled": "gizmo de rotação ativado",
    "scaleGizmoEnabled": "gizmo de escala ativado",
    "boundingBoxGizmoEnabled": "gizmo de caixa delimitadora ativado",
    "usePointerToAttachGizmos": "usar ponteiro para anexar gizmos",
    "clearGizmoOnEmptyPointerEvent": "limpar gizmo em evento de ponteiro vazio",
    "scaleRatio": "razão de escala",
    "attachableMeshes": "malhas anexáveis",
    "BABYLON.AbstractMesh[]": "array de malhas abstratas babylon",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "obter gizmo de posição",
    "getPositionGizmo": "obter gizmo de posição",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "obtém o gizmo de posição",
    "gizmoManager": "gerenciador de gizmo",
    "BABYLON.GizmoManager": "gerenciador de gizmo babylon",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "obter gizmo de rotação",
    "getRotationGizmo": "obter gizmo de rotação",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "obtém o gizmo de rotação",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "obter gizmo de escala",
    "getScaleGizmo": "obter gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "obtém o gizmo de escala",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "obter gizmo de caixa delimitadora",
    "getBoundingBoxGizmo": "obter gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "obtém o gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "anexar à malha",
    "attachToMesh": "anexar à malha",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "anexa o gerenciador de gizmo à malha",
    "update": "atualizar",
    "bitbybit.babylon.gizmo.manager.detachMesh": "desanexar malha",
    "detachMesh": "desanexar malha",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "desanexa o gerenciador de gizmo da malha",
    "bitbybit.babylon.gizmo.base.scaleRatio": "definir razão de escala",
    "base": "base",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "define a razão de escala do gizmo",
    "BABYLON.IGizmo": "interface gizmo babylon",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "obter razão de escala",
    "getScaleRatio": "obter razão de escala",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "obtém a razão de escala do gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "definir gizmo planar ativado",
    "positionGizmo": "gizmo de posição",
    "planarGizmoEnabled": "gizmo planar ativado",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "define o gizmo planar como ativado",
    "BABYLON.IPositionGizmo": "interface gizmo de posição babylon",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "definir distância de encaixe",
    "snapDistance": "distância de encaixe",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "define a distância de encaixe do gizmo de posição",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "obter malha anexada",
    "getAttachedMesh": "obter malha anexada",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "obtém a malha anexada",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "obter nó anexado",
    "getAttachedNode": "obter nó anexado",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "obtém o nó anexado",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "obter gizmo x",
    "getXGizmo": "obter gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "obtém o gizmo x",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "obter gizmo y",
    "getYGizmo": "obter gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "obtém o gizmo y",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "obter gizmo z",
    "getZGizmo": "obter gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "obtém o gizmo z",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "obter gizmo de plano x",
    "getXPlaneGizmo": "obter gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "obtém o gizmo de plano x",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "obter gizmo de plano y",
    "getYPlaneGizmo": "obter gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "obtém o gizmo de plano y",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "obter gizmo de plano z",
    "getZPlaneGizmo": "obter gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "obtém o gizmo de plano z",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "obter gizmo planar ativado",
    "getPlanarGizmoEnabled": "obter gizmo planar ativado",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "obtém o estado ativado do gizmo planar",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "obter distância de encaixe",
    "getSnapDistance": "obter distância de encaixe",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "obtém a distância de encaixe",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "obter arrastando",
    "getIsDragging": "obter arrastando",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "obtém o estado de arrastar",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "seletor observável de gizmo de posição",
    "createPositionGizmoObservableSelector": "seletor observável de gizmo de posição",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "cria seletor observável para gizmo de posição",
    "positionGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de posição",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "definir distância de encaixe",
    "rotationGizmo": "gizmo de rotação",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "define a distância de encaixe do gizmo de rotação",
    "BABYLON.IRotationGizmo": "interface gizmo de rotação babylon",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "definir sensibilidade",
    "sensitivity": "sensibilidade",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "define a sensibilidade do gizmo de rotação",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "obter malha anexada",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "obtém a malha anexada",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "obter nó anexado",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "obtém o nó anexado",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "obter gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "obtém o gizmo x",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "obter gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "obtém o gizmo y",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "obter gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "obtém o gizmo z",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "obter distância de encaixe",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "obtém a distância de encaixe",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "obter sensibilidade",
    "getSensitivity": "obter sensibilidade",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "obtém a sensibilidade",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "seletor observável de gizmo de rotação",
    "createRotationGizmoObservableSelector": "seletor observável de gizmo de rotação",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "cria seletor observável para gizmo de rotação",
    "rotationGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de rotação",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "obter gizmo x",
    "scaleGizmo": "gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "obtém o gizmo x",
    "BABYLON.IScaleGizmo": "interface gizmo de escala babylon",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "obter gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "obtém o gizmo y",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "obter gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "obtém o gizmo z",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "definir distância de encaixe",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "define a distância de encaixe do gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "definir encaixe incremental",
    "setIncrementalSnap": "definir encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "define o encaixe incremental do gizmo de escala",
    "incrementalSnap": "encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "definir sensibilidade",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "define a sensibilidade do gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "obter encaixe incremental",
    "getIncrementalSnap": "obter encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "obtém o encaixe incremental",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "obter distância de encaixe",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "obtém a distância de encaixe",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "obter sensibilidade",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "obtém a sensibilidade",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "seletor observável de gizmo de escala",
    "createScaleGizmoObservableSelector": "seletor observável de gizmo de escala",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "cria seletor observável para gizmo de escala",
    "scaleGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "definir tamanho da esfera de rotação",
    "boundingBoxGizmo": "gizmo de caixa delimitadora",
    "setRotationSphereSize": "definir tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "define o tamanho da esfera de rotação do gizmo de caixa delimitadora",
    "BABYLON.BoundingBoxGizmo": "gizmo de caixa delimitadora babylon",
    "rotationSphereSize": "tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "definir tamanho fixo da malha de arrastar na tela",
    "setFixedDragMeshScreenSize": "definir tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "define o tamanho fixo da malha de arrastar na tela para escala consistente",
    "fixedDragMeshScreenSize": "tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "definir tamanho fixo dos limites da malha de arrastar",
    "setFixedDragMeshBoundsSize": "definir tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "define o tamanho fixo dos limites da malha de arrastar",
    "fixedDragMeshBoundsSize": "tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "definir fator de distância do tamanho fixo da malha de arrastar na tela",
    "setFixedDragMeshScreenSizeDistanceFactor": "definir fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "define o fator de distância para o tamanho fixo da malha de arrastar na tela",
    "fixedDragMeshScreenSizeDistanceFactor": "fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "definir distância de encaixe de escala",
    "setScalingSnapDistance": "definir distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "define a distância de encaixe de escala do gizmo de caixa delimitadora",
    "scalingSnapDistance": "distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "definir distância de encaixe de rotação",
    "setRotationSnapDistance": "definir distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "define a distância de encaixe de rotação do gizmo de caixa delimitadora",
    "rotationSnapDistance": "distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "definir tamanho da caixa de escala",
    "setScaleBoxSize": "definir tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "define o tamanho da caixa de escala do gizmo de caixa delimitadora",
    "scaleBoxSize": "tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "definir encaixe incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "define o encaixe incremental do gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "definir pivô de escala",
    "setScalePivot": "definir pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "define o pivô de escala do gizmo de caixa delimitadora",
    "scalePivot": "pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "definir fator de eixo",
    "setAxisFactor": "definir fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "define o fator de eixo do gizmo de caixa delimitadora",
    "axisFactor": "fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "definir velocidade de arrastar escala",
    "setScaleDragSpeed": "definir velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "define a velocidade de arrastar escala do gizmo de caixa delimitadora",
    "scaleDragSpeed": "velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "obter tamanho da esfera de rotação",
    "getRotationSphereSize": "obter tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "obtém o tamanho da esfera de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "obter tamanho da caixa de escala",
    "getScaleBoxSize": "obter tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "obtém o tamanho da caixa de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "obter tamanho fixo da malha de arrastar na tela",
    "getFixedDragMeshScreenSize": "obter tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "obtém o tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "obter tamanho fixo dos limites da malha de arrastar",
    "getFixedDragMeshBoundsSize": "obter tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "obtém o tamanho fixo dos limites da malha de arrastar",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "obter fator de distância do tamanho fixo da malha de arrastar na tela",
    "getFixedDragMeshScreenSizeDistanceFactor": "obter fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "obtém o fator de distância do tamanho fixo da malha de arrastar na tela",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "obter distância de encaixe de escala",
    "getScalingSnapDistance": "obter distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "obtém a distância de encaixe de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "obter distância de encaixe de rotação",
    "getRotationSnapDistance": "obter distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "obtém a distância de encaixe de rotação",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "obter encaixe incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "obtém o encaixe incremental",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "obter pivô de escala",
    "getScalePivot": "obter pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "obtém o pivô de escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "obter fator de eixo",
    "getAxisFactor": "obter fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "obtém o fator de eixo",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "obter velocidade de arrastar escala",
    "getScaleDragSpeed": "obter velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "obtém a velocidade de arrastar escala",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "seletor observável de gizmo de caixa delimitadora",
    "createBoundingBoxGizmoObservableSelector": "seletor observável de gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "cria seletor observável para gizmo de caixa delimitadora",
    "boundingBoxGizmoObservableSelectorEnum": "enum de seletor observável de gizmo de caixa delimitadora",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "definir habilitado",
    "axisDragGizmo": "gizmo de arrastar eixo",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "define o eixo como habilitado",
    "BABYLON.IAxisDragGizmo": "interface gizmo de arrastar eixo babylon",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "obtém o estado habilitado do eixo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "definir habilitado",
    "axisScaleGizmo": "gizmo de escala de eixo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "define o eixo como habilitado",
    "BABYLON.IAxisScaleGizmo": "interface gizmo de escala de eixo babylon",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "obtém o estado habilitado do eixo",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "definir habilitado",
    "planeDragGizmo": "gizmo de arrastar plano",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "define o plano como habilitado",
    "BABYLON.IPlaneDragGizmo": "interface gizmo de arrastar plano babylon",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "obtém o estado habilitado do plano",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "definir habilitado",
    "planeRotationGizmo": "gizmo de rotação de plano",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "define o plano como habilitado",
    "BABYLON.IPlaneRotationGizmo": "interface gizmo de rotação de plano babylon",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "obter habilitado",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "obtém o estado habilitado do plano",
    "bitbybit.vector.removeAllDuplicateVectors": "remover todos os vetores duplicados",
    "vector": "vetor",
    "removeAllDuplicateVectors": "remover todos os vetores duplicados",
    "bitbybit.vector.removeAllDuplicateVectors_description": "remove todos os vetores duplicados do array",
    "remove": "remover",
    "vectors": "vetores",
    "number[][]": "array de arrays de números",
    "tolerance": "tolerância",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "remover vetores duplicados consecutivos",
    "removeConsecutiveDuplicateVectors": "remover vetores duplicados consecutivos",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "remove vetores duplicados consecutivos do array",
    "checkFirstAndLast": "verificar primeiro e último",
    "bitbybit.vector.angleBetween": "ângulo entre",
    "angleBetween": "ângulo entre",
    "bitbybit.vector.angleBetween_description": "mede o ângulo entre dois vetores em graus",
    "angles": "ângulos",
    "first": "primeiro",
    "second": "segundo",
    "bitbybit.vector.angleBetweenNormalized2d": "ângulo entre normalizado 2d",
    "angleBetweenNormalized2d": "ângulo entre normalizado 2d",
    "bitbybit.vector.angleBetweenNormalized2d_description": "mede o ângulo 2d normalizado entre dois vetores em graus",
    "bitbybit.vector.positiveAngleBetween": "ângulo positivo entre",
    "positiveAngleBetween": "ângulo positivo entre",
    "bitbybit.vector.positiveAngleBetween_description": "mede o ângulo positivo entre dois vetores com referência em graus",
    "reference": "referência",
    "bitbybit.vector.addAll": "somar todos",
    "addAll": "somar todos",
    "bitbybit.vector.addAll_description": "soma todos os valores xyz do vetor em um novo vetor",
    "sum": "soma",
    "bitbybit.vector.add": "adicionar",
    "add": "adicionar",
    "bitbybit.vector.add_description": "adiciona dois vetores",
    "bitbybit.vector.all": "todos",
    "all": "todos",
    "bitbybit.vector.all_description": "verifica se array booleano é todo verdadeiro",
    "boolean[]": "array booleano",
    "bitbybit.vector.cross": "produto vetorial",
    "cross": "produto vetorial",
    "bitbybit.vector.cross_description": "realiza o produto vetorial de dois vetores",
    "bitbybit.vector.distSquared": "distância ao quadrado",
    "distSquared": "distância ao quadrado",
    "bitbybit.vector.distSquared_description": "distância ao quadrado entre dois vetores",
    "bitbybit.vector.dist": "distância",
    "dist": "distância",
    "bitbybit.vector.dist_description": "distância entre dois vetores",
    "bitbybit.vector.div": "dividir",
    "div": "dividir",
    "bitbybit.vector.div_description": "divide vetor por escalar",
    "scalar": "escalar",
    "bitbybit.vector.domain": "domínio",
    "domain": "domínio",
    "bitbybit.vector.domain_description": "computa o domínio entre o mínimo e o máximo do vetor",
    "bitbybit.vector.dot": "produto escalar",
    "dot": "produto escalar",
    "bitbybit.vector.dot_description": "produto escalar de dois vetores",
    "bitbybit.vector.finite": "finito",
    "finite": "finito",
    "bitbybit.vector.finite_description": "verifica se os números do vetor são finitos",
    "validate": "validar",
    "bitbybit.vector.isZero": "é zero",
    "isZero": "é zero",
    "bitbybit.vector.isZero_description": "verifica se o comprimento do vetor é zero",
    "bitbybit.vector.lerp": "interpolação linear",
    "lerp": "interpolação linear",
    "bitbybit.vector.lerp_description": "encontra o vetor entre dois vetores por fração",
    "fraction": "fração",
    "bitbybit.vector.max": "máximo",
    "max": "máximo",
    "bitbybit.vector.max_description": "encontra o valor máximo no vetor",
    "extract": "extrair",
    "bitbybit.vector.min": "mínimo",
    "min": "mínimo",
    "bitbybit.vector.min_description": "encontra o valor mínimo no vetor",
    "bitbybit.vector.mul": "multiplicar",
    "mul": "multiplicar",
    "bitbybit.vector.mul_description": "multiplica vetor por escalar",
    "bitbybit.vector.neg": "negar",
    "neg": "negar",
    "bitbybit.vector.neg_description": "nega o vetor",
    "bitbybit.vector.normSquared": "norma ao quadrado",
    "normSquared": "norma ao quadrado",
    "bitbybit.vector.normSquared_description": "computa a norma ao quadrado",
    "bitbybit.vector.norm": "norma",
    "norm": "norma",
    "bitbybit.vector.norm_description": "computa a norma do vetor",
    "bitbybit.vector.normalized": "normalizado",
    "normalized": "normalizado",
    "bitbybit.vector.normalized_description": "normaliza o vetor para comprimento unitário",
    "bitbybit.vector.onRay": "no raio",
    "onRay": "no raio",
    "bitbybit.vector.onRay_description": "encontra ponto no raio a uma dada distância",
    "bitbybit.vector.vectorXYZ": "vetor xyz",
    "vectorXYZ": "vetor xyz",
    "bitbybit.vector.vectorXYZ_description": "cria vetor xyz",
    "x": "x",
    "y": "y",
    "z": "z",
    "bitbybit.vector.vectorXY": "vetor xy",
    "vectorXY": "vetor xy",
    "bitbybit.vector.vectorXY_description": "cria vetor 2d xy",
    "bitbybit.vector.range": "intervalo",
    "range": "intervalo",
    "bitbybit.vector.range_description": "cria vetor inteiro de 0 até o máximo",
    "bitbybit.vector.signedAngleBetween": "ângulo assinado entre",
    "signedAngleBetween": "ângulo assinado entre",
    "bitbybit.vector.signedAngleBetween_description": "computa o ângulo assinado entre dois vetores com referência",
    "bitbybit.vector.span": "extensão",
    "span": "extensão",
    "bitbybit.vector.span_description": "cria vetor que se estende de mínimo a máximo com passo",
    "bitbybit.vector.spanEaseItems": "extensão de itens com suavização",
    "spanEaseItems": "extensão de itens com suavização",
    "bitbybit.vector.spanEaseItems_description": "cria vetor que se estende de mínimo a máximo com função de suavização",
    "nrItems": "número de itens",
    "ease": "suavização",
    "Math.easeEnum": "enum de suavização matemática",
    "intervals": "intervalos",
    "bitbybit.vector.spanLinearItems": "extensão de itens lineares",
    "spanLinearItems": "extensão de itens lineares",
    "bitbybit.vector.spanLinearItems_description": "cria vetor que se estende de mínimo a máximo com contagem de itens",
    "bitbybit.vector.sub": "subtrair",
    "sub": "subtrair",
    "bitbybit.vector.sub_description": "subtrai dois vetores",
    "bitbybit.vector.sum": "soma",
    "bitbybit.vector.sum_description": "soma os valores do vetor",
    "bitbybit.point.transformPoint": "transformar ponto",
    "transformPoint": "transformar ponto",
    "bitbybit.point.transformPoint_description": "transforma um único ponto",
    "transformation": "transformação",
    "Base.TransformMatrixes": "matrizes de transformação base",
    "bitbybit.point.transformPoints": "transformar pontos",
    "transformPoints": "transformar pontos",
    "bitbybit.point.transformPoints_description": "transforma múltiplos pontos",
    "points": "pontos",
    "bitbybit.point.transformsForPoints": "transformações para pontos",
    "transformsForPoints": "transformações para pontos",
    "bitbybit.point.transformsForPoints_description": "transforma múltiplos pontos com múltiplas transformações",
    "Base.TransformMatrixes[]": "array de matrizes de transformação base",
    "bitbybit.point.translatePoints": "transladar pontos",
    "translatePoints": "transladar pontos",
    "bitbybit.point.translatePoints_description": "translada múltiplos pontos",
    "bitbybit.point.translatePointsWithVectors": "transladar pontos com vetores",
    "translatePointsWithVectors": "transladar pontos com vetores",
    "bitbybit.point.translatePointsWithVectors_description": "translada múltiplos pontos com vetores",
    "bitbybit.point.translateXYZPoints": "transladar pontos xyz",
    "translateXYZPoints": "transladar pontos xyz",
    "bitbybit.point.translateXYZPoints_description": "translada múltiplos pontos por valores xyz",
    "bitbybit.point.scalePointsCenterXYZ": "escalar pontos do centro xyz",
    "scalePointsCenterXYZ": "escalar pontos do centro xyz",
    "bitbybit.point.scalePointsCenterXYZ_description": "escala múltiplos pontos a partir do centro com fatores xyz",
    "bitbybit.point.rotatePointsCenterAxis": "rotacionar pontos em torno do centro e eixo",
    "rotatePointsCenterAxis": "rotacionar pontos em torno do centro e eixo",
    "bitbybit.point.rotatePointsCenterAxis_description": "rotaciona múltiplos pontos ao redor do centro e eixo",
    "bitbybit.point.closestPointFromPointsDistance": "distância do ponto mais próximo entre pontos",
    "closestPointFromPointsDistance": "distância do ponto mais próximo entre pontos",
    "bitbybit.point.closestPointFromPointsDistance_description": "mede a distância mais próxima até pontos",
    "bitbybit.point.closestPointFromPointsIndex": "índice do ponto mais próximo entre pontos",
    "closestPointFromPointsIndex": "índice do ponto mais próximo entre pontos",
    "bitbybit.point.closestPointFromPointsIndex_description": "encontra o índice do ponto mais próximo começando em 1",
    "bitbybit.point.closestPointFromPoints": "ponto mais próximo entre pontos",
    "closestPointFromPoints": "ponto mais próximo entre pontos",
    "bitbybit.point.closestPointFromPoints_description": "encontra o ponto mais próximo na coleção",
    "bitbybit.point.distance": "distância",
    "bitbybit.point.distance_description": "mede a distância entre dois pontos",
    "measure": "medir",
    "startPoint": "ponto inicial",
    "endPoint": "ponto final",
    "bitbybit.point.distancesToPoints": "distâncias até pontos",
    "distancesToPoints": "distâncias até pontos",
    "bitbybit.point.distancesToPoints_description": "mede distâncias do ponto inicial até múltiplos pontos finais",
    "endPoints": "pontos finais",
    "bitbybit.point.multiplyPoint": "multiplicar ponto",
    "multiplyPoint": "multiplicar ponto",
    "bitbybit.point.multiplyPoint_description": "multiplica ponto por quantidade",
    "amountOfPoints": "quantidade de pontos",
    "bitbybit.point.getX": "obter x",
    "getX": "obter x",
    "bitbybit.point.getX_description": "obtém a coordenada x do ponto",
    "bitbybit.point.getY": "obter y",
    "getY": "obter y",
    "bitbybit.point.getY_description": "obtém a coordenada y do ponto",
    "bitbybit.point.getZ": "obter z",
    "getZ": "obter z",
    "bitbybit.point.getZ_description": "obtém a coordenada z do ponto",
    "bitbybit.point.averagePoint": "ponto médio",
    "averagePoint": "ponto médio",
    "bitbybit.point.averagePoint_description": "obtém o ponto médio de pontos",
    "bitbybit.point.pointXYZ": "ponto xyz",
    "pointXYZ": "ponto xyz",
    "bitbybit.point.pointXYZ_description": "cria ponto xyz",
    "bitbybit.point.pointXY": "ponto xy",
    "pointXY": "ponto xy",
    "bitbybit.point.pointXY_description": "cria ponto xy",
    "bitbybit.point.spiral": "espiral",
    "spiral": "espiral",
    "bitbybit.point.spiral_description": "cria espiral a partir de múltiplos pontos",
    "phi": "phi",
    "numberPoints": "número de pontos",
    "widening": "alargamento",
    "factor": "fator",
    "bitbybit.point.hexGrid": "grade hexagonal",
    "hexGrid": "grade hexagonal",
    "bitbybit.point.hexGrid_description": "cria grade hexagonal plana no plano xy",
    "nrHexagonsY": "número de hexágonos y",
    "nrHexagonsX": "número de hexágonos x",
    "radiusHexagon": "raio do hexágono",
    "orientOnCenter": "orientar no centro",
    "pointsOnGround": "pontos no chão",
    "bitbybit.point.removeConsecutiveDuplicates": "remover duplicatas consecutivas",
    "removeConsecutiveDuplicates": "remover duplicatas consecutivas",
    "bitbybit.point.removeConsecutiveDuplicates_description": "remove duplicatas consecutivas do array de pontos",
    "clean": "limpar",
    "bitbybit.line.convertToNurbsCurve": "converter para curva nurbs",
    "line": "linha",
    "convertToNurbsCurve": "converter para curva nurbs",
    "bitbybit.line.convertToNurbsCurve_description": "converte linha em curva nurbs",
    "LinePointsDto": "dto de pontos da linha",
    "bitbybit.line.convertLinesToNurbsCurves": "converter linhas para curvas nurbs",
    "convertLinesToNurbsCurves": "converter linhas para curvas nurbs",
    "bitbybit.line.convertLinesToNurbsCurves_description": "converte linhas em um array de curvas nurbs",
    "lines": "linhas",
    "LinePointsDto[]": "array de dto de pontos da linha",
    "bitbybit.line.getStartPoint": "obter ponto inicial",
    "getStartPoint": "obter ponto inicial",
    "bitbybit.line.getStartPoint_description": "obtém o ponto inicial da linha",
    "bitbybit.line.getEndPoint": "obter ponto final",
    "getEndPoint": "obter ponto final",
    "bitbybit.line.getEndPoint_description": "obtém o ponto final da linha",
    "bitbybit.line.length": "comprimento",
    "bitbybit.line.length_description": "obtém o comprimento da linha",
    "bitbybit.line.reverse": "inverter",
    "reverse": "inverter",
    "bitbybit.line.reverse_description": "inverte os pontos finais da linha",
    "bitbybit.line.transformLine": "transformar linha",
    "transformLine": "transformar linha",
    "bitbybit.line.transformLine_description": "transforma a linha",
    "bitbybit.line.transformsForLines": "transformações para linhas",
    "transformsForLines": "transformações para linhas",
    "bitbybit.line.transformsForLines_description": "transforma múltiplas linhas",
    "bitbybit.line.create": "criar",
    "bitbybit.line.create_description": "cria linha",
    "bitbybit.line.createAsync": "assíncrono",
    "createAsync": "assíncrono",
    "bitbybit.line.createAsync_description": "cria linha a partir de pontos assíncronos",
    "bitbybit.line.getPointOnLine": "obter ponto na linha",
    "getPointOnLine": "obter ponto na linha",
    "bitbybit.line.getPointOnLine_description": "obtém ponto na linha no parâmetro",
    "param": "parâmetro",
    "bitbybit.line.linesBetweenPoints": "linhas entre pontos",
    "linesBetweenPoints": "linhas entre pontos",
    "bitbybit.line.linesBetweenPoints_description": "cria segmentos de linha entre pontos",
    "bitbybit.line.linesBetweenStartAndEndPoints": "linhas entre pontos iniciais e finais",
    "linesBetweenStartAndEndPoints": "linhas entre pontos iniciais e finais",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "cria linhas entre listas de pontos iniciais e finais",
    "startPoints": "pontos iniciais",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "linhas entre pontos iniciais e finais assíncronas",
    "linesBetweenStartAndEndPointsAsync": "linhas entre pontos iniciais e finais assíncronas",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "cria linhas entre pontos iniciais e finais com entradas assíncronas",
    "bitbybit.polyline.convertToNurbsCurve": "converter para curva nurbs",
    "polyline": "polilinha",
    "bitbybit.polyline.convertToNurbsCurve_description": "converte polilinha em curva nurbs",
    "PolylinePropertiesDto": "dto de propriedades da polilinha",
    "bitbybit.polyline.length": "comprimento",
    "bitbybit.polyline.length_description": "obtém o comprimento da polilinha",
    "bitbybit.polyline.countPoints": "contar pontos",
    "countPoints": "contar pontos",
    "bitbybit.polyline.countPoints_description": "obtém a contagem de pontos da polilinha",
    "bitbybit.polyline.getPoints": "obter pontos",
    "getPoints": "obter pontos",
    "bitbybit.polyline.getPoints_description": "obtém os pontos da polilinha",
    "bitbybit.polyline.reverse": "inverter",
    "bitbybit.polyline.reverse_description": "inverte os pontos da polilinha",
    "bitbybit.polyline.transformPolyline": "transformar polilinha",
    "transformPolyline": "transformar polilinha",
    "bitbybit.polyline.transformPolyline_description": "transforma a polilinha",
    "bitbybit.polyline.create": "criar",
    "bitbybit.polyline.create_description": "cria polilinha",
    "isClosed": "está fechada",
    "string | number[]": "texto ou array de números",
    "bitbybit.occt.deleteShape": "excluir forma",
    "occt": "occt",
    "deleteShape": "excluir forma",
    "bitbybit.occt.deleteShape_description": "exclui forma do cache",
    "bitbybit.occt.deleteShapes": "excluir formas",
    "deleteShapes": "excluir formas",
    "bitbybit.occt.deleteShapes_description": "exclui formas do cache",
    "shapes": "formas",
    "T[]": "array de t",
    "bitbybit.occt.cleanAllCache": "limpar todo o cache",
    "cleanAllCache": "limpar todo o cache",
    "bitbybit.occt.cleanAllCache_description": "limpa todo o cache e formas da memória",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "vértice a partir de xyz",
    "vertex": "vértice",
    "vertexFromXYZ": "vértice a partir de xyz",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "cria vértice a partir de coordenadas xyz",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "vértice a partir de ponto",
    "vertexFromPoint": "vértice a partir de ponto",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "cria vértice a partir de ponto",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "vértices a partir de pontos",
    "verticesFromPoints": "vértices a partir de pontos",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "cria vértices a partir de pontos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "composto de vértices a partir de pontos",
    "verticesCompoundFromPoints": "composto de vértices a partir de pontos",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "cria forma composta de vértices",
    "bitbybit.occt.shapes.vertex.getVertices": "obter vértices",
    "getVertices": "obter vértices",
    "bitbybit.occt.shapes.vertex.getVertices_description": "obtém todos os vértices da forma",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "obter vértices como pontos",
    "getVerticesAsPoints": "obter vértices como pontos",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "obtém todos os vértices como pontos",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "vértices para pontos",
    "verticesToPoints": "vértices para pontos",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transforma vértices em pontos",
    "transform": "transformar",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "vértice para ponto",
    "vertexToPoint": "vértice para ponto",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "transforma vértice em ponto",
    "bitbybit.occt.shapes.vertex.projectPoints": "projetar pontos",
    "projectPoints": "projetar pontos",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "projeta pontos na forma",
    "place": "posicionar",
    "projectionType": "tipo de projeção",
    "pointProjectionTypeEnum": "enum de tipo de projeção de ponto",
    "bitbybit.occt.shapes.edge.line": "linha",
    "edge": "borda",
    "bitbybit.occt.shapes.edge.line_description": "cria borda linear entre dois pontos",
    "primitives": "primitivas",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "arco através de três pontos",
    "arcThroughThreePoints": "arco através de três pontos",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "cria borda de arco através de três pontos",
    "middle": "meio",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "arco através de dois pontos e tangente",
    "arcThroughTwoPointsAndTangent": "arco através de dois pontos e tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "cria borda de arco com tangente no primeiro ponto",
    "tangentVec": "vetor tangente",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "arco a partir de círculo e dois pontos",
    "arcFromCircleAndTwoPoints": "arco a partir de círculo e dois pontos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "cria borda de arco em círculo entre dois pontos",
    "circle": "círculo",
    "sense": "sentido",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "arco a partir de círculo e dois ângulos",
    "arcFromCircleAndTwoAngles": "arco a partir de círculo e dois ângulos",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "cria borda de arco em círculo entre dois ângulos",
    "alphaAngle1": "ângulo alfa 1",
    "alphaAngle2": "ângulo alfa 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "arco a partir de círculo, ponto e ângulo",
    "arcFromCirclePointAndAngle": "arco a partir de círculo, ponto e ângulo",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "cria borda de arco em círculo de ponto até ângulo",
    "alphaAngle": "ângulo alfa",
    "bitbybit.occt.shapes.edge.createCircleEdge": "borda de círculo",
    "createCircleEdge": "borda de círculo",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "cria borda de círculo opencascade",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "borda de elipse",
    "createEllipseEdge": "borda de elipse",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "cria borda de elipse opencascade",
    "radiusMinor": "raio menor",
    "radiusMajor": "raio maior",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "remover bordas internas",
    "removeInternalEdges": "remover bordas internas",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "remove bordas internas da forma",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "criar borda a partir de curva geom 2d e superfície",
    "makeEdgeFromGeom2dCurveAndSurface": "criar borda a partir de curva geom 2d e superfície",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "cria borda a partir de curva geométrica e superfície",
    "curve": "curva",
    "surface": "superfície",
    "U": "u",
    "bitbybit.occt.shapes.edge.getEdge": "obter borda",
    "getEdge": "obter borda",
    "bitbybit.occt.shapes.edge.getEdge_description": "obtém borda por índice da forma",
    "index": "índice",
    "bitbybit.occt.shapes.edge.getEdges": "obter bordas",
    "getEdges": "obter bordas",
    "bitbybit.occt.shapes.edge.getEdges_description": "obtém bordas da forma",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "obter bordas ao longo do fio",
    "getEdgesAlongWire": "obter bordas ao longo do fio",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "obtém bordas ao longo da direção do fio",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "obter bordas circulares ao longo do fio",
    "getCircularEdgesAlongWire": "obter bordas circulares ao longo do fio",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "obtém bordas circulares ao longo da direção do fio",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "obter bordas lineares ao longo do fio",
    "getLinearEdgesAlongWire": "obter bordas lineares ao longo do fio",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "obtém bordas lineares ao longo da direção do fio",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "obter pontos de canto das bordas da forma",
    "getCornerPointsOfEdgesForShape": "obter pontos de canto das bordas da forma",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "obtém pontos de canto únicos das bordas",
    "bitbybit.occt.shapes.edge.getEdgeLength": "obter comprimento da borda",
    "getEdgeLength": "obter comprimento da borda",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "obtém o comprimento da borda",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "obter comprimentos das bordas da forma",
    "getEdgeLengthsOfShape": "obter comprimentos das bordas da forma",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "obtém os comprimentos das bordas da forma",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "obter comprimentos das bordas",
    "getEdgesLengths": "obter comprimentos das bordas",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "obtém os comprimentos das bordas",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "obter centro de massa da borda",
    "getEdgeCenterOfMass": "obter centro de massa da borda",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "obtém o centro de massa da borda",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "obter centros de massa das bordas",
    "getEdgesCentersOfMass": "obter centros de massa das bordas",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "obtém os centros de massa das bordas",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "obter ponto central da borda circular",
    "getCircularEdgeCenterPoint": "obter ponto central da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "obtém o ponto central da borda circular",
    "get circular edge": "obter borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "obter raio da borda circular",
    "getCircularEdgeRadius": "obter raio da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "obtém o raio da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "obter direção do plano da borda circular",
    "getCircularEdgePlaneDirection": "obter direção do plano da borda circular",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "obtém a direção do plano da borda circular",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "ponto na borda no parâmetro",
    "pointOnEdgeAtParam": "ponto na borda no parâmetro",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "obtém ponto na borda no parâmetro",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "pontos nas bordas no parâmetro",
    "pointsOnEdgesAtParam": "pontos nas bordas no parâmetro",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "obtém pontos nas bordas no parâmetro",
    "bitbybit.occt.shapes.edge.edgesToPoints": "bordas para pontos",
    "edgesToPoints": "bordas para pontos",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "obtém pontos das bordas em listas separadas",
    "angularDeflection": "deflexão angular",
    "curvatureDeflection": "deflexão de curvatura",
    "minimumOfPoints": "mínimo de pontos",
    "uTolerance": "tolerância u",
    "minimumLength": "comprimento mínimo",
    "bitbybit.occt.shapes.edge.reversedEdge": "borda invertida",
    "reversedEdge": "borda invertida",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "computa borda invertida",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "tangente na borda no parâmetro",
    "tangentOnEdgeAtParam": "tangente na borda no parâmetro",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "obtém vetor tangente na borda no parâmetro",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "tangentes nas bordas no parâmetro",
    "tangentsOnEdgesAtParam": "tangentes nas bordas no parâmetro",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "obtém vetores tangentes nas bordas no parâmetro",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "ponto na borda no comprimento",
    "pointOnEdgeAtLength": "ponto na borda no comprimento",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "obtém ponto na borda no comprimento",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "pontos nas bordas no comprimento",
    "pointsOnEdgesAtLength": "pontos nas bordas no comprimento",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "obtém pontos nas bordas no comprimento",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "tangente na borda no comprimento",
    "tangentOnEdgeAtLength": "tangente na borda no comprimento",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "obtém vetor tangente na borda no comprimento",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "tangentes nas bordas no comprimento",
    "tangentsOnEdgesAtLength": "tangentes nas bordas no comprimento",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "obtém vetores tangentes nas bordas no comprimento",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "ponto inicial na borda",
    "startPointOnEdge": "ponto inicial na borda",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "obtém ponto inicial na borda",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "pontos iniciais nas bordas",
    "startPointsOnEdges": "pontos iniciais nas bordas",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "obtém pontos iniciais nas bordas",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "ponto final na borda",
    "endPointOnEdge": "ponto final na borda",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "obtém ponto final na borda",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "pontos finais nas bordas",
    "endPointsOnEdges": "pontos finais nas bordas",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "obtém pontos finais nas bordas",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "dividir borda por parâmetros em pontos",
    "divideEdgeByParamsToPoints": "dividir borda por parâmetros em pontos",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "divide borda por parâmetros em pontos",
    "nrOfDivisions": "número de divisões",
    "removeStartPoint": "remover ponto inicial",
    "removeEndPoint": "remover ponto final",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "dividir bordas por parâmetros em pontos",
    "divideEdgesByParamsToPoints": "dividir bordas por parâmetros em pontos",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "divide bordas por parâmetros em pontos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "dividir borda por distância igual em pontos",
    "divideEdgeByEqualDistanceToPoints": "dividir borda por distância igual em pontos",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "divide borda por comprimento em pontos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "dividir bordas por distância igual em pontos",
    "divideEdgesByEqualDistanceToPoints": "dividir bordas por distância igual em pontos",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "divide bordas por comprimento em pontos",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "linhas tangentes restritas de dois pontos a círculo",
    "constraintTanLinesFromTwoPtsToCircle": "linhas tangentes restritas de dois pontos a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "cria linhas de dois pontos até tangentes do círculo",
    "constraint": "restrição",
    "point1": "ponto 1",
    "point2": "ponto 2",
    "positionResult": "resultado da posição",
    "positionResultEnum": "enum de resultado da posição",
    "circleRemainder": "resto do círculo",
    "circleInclusionEnum": "enum de inclusão do círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "linhas tangentes restritas de ponto a círculo",
    "constraintTanLinesFromPtToCircle": "linhas tangentes restritas de ponto a círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "cria linhas de ponto até tangentes do círculo",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "linhas tangentes restritas em dois círculos",
    "constraintTanLinesOnTwoCircles": "linhas tangentes restritas em dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "cria linhas tangentes entre dois círculos",
    "circle1": "círculo 1",
    "circle2": "círculo 2",
    "circleRemainders": "restos dos círculos",
    "twoCircleInclusionEnum": "enum de inclusão de dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "círculos tangentes restritos em dois círculos",
    "constraintTanCirclesOnTwoCircles": "círculos tangentes restritos em dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "cria círculos tangentes entre dois círculos",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "círculos tangentes restritos em círculo e ponto",
    "constraintTanCirclesOnCircleAndPnt": "círculos tangentes restritos em círculo e ponto",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "cria círculos tangentes entre ponto e círculo",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "borda é linear",
    "isEdgeLinear": "borda é linear",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "verifica se a borda é linear",
    "is": "é",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "borda é circular",
    "isEdgeCircular": "borda é circular",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "verifica se a borda é circular",
    "bitbybit.occt.shapes.wire.createPolygonWire": "fio poligonal",
    "wire": "fio",
    "createPolygonWire": "fio poligonal",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "cria fio poligonal opencascade",
    "via points": "via pontos",
    "bitbybit.occt.shapes.wire.createPolygons": "polígonos",
    "createPolygons": "polígonos",
    "bitbybit.occt.shapes.wire.createPolygons_description": "cria polígonos opencascade",
    "multiple": "múltiplo",
    "polygons": "polígonos",
    "PolygonDto[]": "array de dto de polígono",
    "returnCompound": "retornar composto",
    "bitbybit.occt.shapes.wire.createLineWire": "fio de linha",
    "createLineWire": "fio de linha",
    "bitbybit.occt.shapes.wire.createLineWire_description": "cria fio de linha opencascade",
    "bitbybit.occt.shapes.wire.createLines": "linhas",
    "createLines": "linhas",
    "bitbybit.occt.shapes.wire.createLines_description": "cria linhas opencascade",
    "LineDto[]": "array de dto de linha",
    "bitbybit.occt.shapes.wire.splitOnPoints": "dividir nos pontos",
    "splitOnPoints": "dividir nos pontos",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "divide fio nos pontos dados",
    "bitbybit.occt.shapes.wire.wiresToPoints": "fios para pontos",
    "wiresToPoints": "fios para pontos",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "transforma fios em pontos em listas ordenadas",
    "bitbybit.occt.shapes.wire.createPolylineWire": "fio de polilinha",
    "createPolylineWire": "fio de polilinha",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "cria fio de polilinha opencascade",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "zigzag entre dois fios",
    "createZigZagBetweenTwoWires": "zigzag entre dois fios",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "cria zigzag entre dois fios",
    "via wires": "via fios",
    "wire1": "fio 1",
    "wire2": "fio 2",
    "nrZigZags": "número de zigzags",
    "inverse": "inverso",
    "divideByEqualDistance": "dividir por distância igual",
    "zigZagsPerEdge": "zigzags por borda",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "fio a partir de dois círculos tangentes",
    "createWireFromTwoCirclesTan": "fio a partir de dois círculos tangentes",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "cria fio tangente envolvendo dois círculos planares",
    "keepLines": "manter linhas",
    "twoSidesStrictEnum": "enum estrito de dois lados",
    "fourSidesStrictEnum": "enum estrito de quatro lados",
    "bitbybit.occt.shapes.wire.createPolylines": "polilinhas",
    "createPolylines": "polilinhas",
    "bitbybit.occt.shapes.wire.createPolylines_description": "cria fios de polilinha opencascade",
    "polylines": "polilinhas",
    "PolylineDto[]": "array de dto de polilinha",
    "bitbybit.occt.shapes.wire.createBezier": "bezier",
    "createBezier": "bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "cria fio bezier opencascade",
    "bitbybit.occt.shapes.wire.createBezierWeights": "bezier com pesos",
    "createBezierWeights": "bezier com pesos",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "cria fio bezier opencascade com pesos",
    "weights": "pesos",
    "bitbybit.occt.shapes.wire.createBezierWires": "fios bezier",
    "createBezierWires": "fios bezier",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "cria fios bezier opencascade",
    "bezierWires": "fios bezier",
    "BezierDto[]": "array de dto de bezier",
    "bitbybit.occt.shapes.wire.interpolatePoints": "interpolar pontos",
    "interpolatePoints": "interpolar pontos",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "cria fio bspline opencascade a partir de pontos",
    "periodic": "periódico",
    "bitbybit.occt.shapes.wire.interpolateWires": "interpolar fios",
    "interpolateWires": "interpolar fios",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "cria múltiplos fios interpolados opencascade",
    "interpolations": "interpolações",
    "InterpolationDto[]": "array de dto de interpolação",
    "bitbybit.occt.shapes.wire.createBSpline": "bspline",
    "createBSpline": "bspline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "cria fio bspline opencascade",
    "bitbybit.occt.shapes.wire.createBSplines": "bsplines",
    "createBSplines": "bsplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "cria fios bspline opencascade",
    "bSplines": "bsplines",
    "BSplineDto[]": "array de dto de bspline",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "combinar bordas e fios em um fio",
    "combineEdgesAndWiresIntoAWire": "combinar bordas e fios em um fio",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "combina bordas e fios em um único fio",
    "build": "construir",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "fio a partir de borda",
    "createWireFromEdge": "fio a partir de borda",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "cria fio a partir de borda",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "adicionar bordas e fios ao fio",
    "addEdgesAndWiresToWire": "adicionar bordas e fios ao fio",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "adiciona bordas e fios ao fio",
    "U[]": "array de u",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "dividir fio por parâmetros em pontos",
    "divideWireByParamsToPoints": "dividir fio por parâmetros em pontos",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "divide fio em pontos por parâmetros",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "dividir fios por parâmetros em pontos",
    "divideWiresByParamsToPoints": "dividir fios por parâmetros em pontos",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "divide fios em pontos por parâmetros",
    "extract from wires": "extrair de fios",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "dividir fio por distância igual em pontos",
    "divideWireByEqualDistanceToPoints": "dividir fio por distância igual em pontos",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "divide fio em pontos de distância igual",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "dividir fios por distância igual em pontos",
    "divideWiresByEqualDistanceToPoints": "dividir fios por distância igual em pontos",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "divide fios em pontos de distância igual",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "ponto no fio no parâmetro",
    "pointOnWireAtParam": "ponto no fio no parâmetro",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "obtém ponto no fio no parâmetro",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "ponto no fio no comprimento",
    "pointOnWireAtLength": "ponto no fio no comprimento",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "obtém ponto no fio no comprimento",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "pontos no fio nos comprimentos",
    "pointsOnWireAtLengths": "pontos no fio nos comprimentos",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "obtém pontos no fio nos comprimentos",
    "lengths": "comprimentos",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "pontos no fio em comprimento igual",
    "pointsOnWireAtEqualLength": "pontos no fio em comprimento igual",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "obtém pontos no fio em comprimento igual",
    "tryNext": "tentar próximo",
    "includeFirst": "incluir primeiro",
    "includeLast": "incluir último",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "pontos no fio em padrão de comprimentos",
    "pointsOnWireAtPatternOfLengths": "pontos no fio em padrão de comprimentos",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "obtém pontos no fio em padrão de comprimentos",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "tangente no fio no parâmetro",
    "tangentOnWireAtParam": "tangente no fio no parâmetro",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "obtém vetor tangente no fio no parâmetro",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "tangente no fio no comprimento",
    "tangentOnWireAtLength": "tangente no fio no comprimento",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "obtém vetor tangente no fio no comprimento",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "derivadas no fio no comprimento",
    "derivativesOnWireAtLength": "derivadas no fio no comprimento",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "computa 3 derivadas no fio no comprimento",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "derivadas no fio no parâmetro",
    "derivativesOnWireAtParam": "derivadas no fio no parâmetro",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "computa 3 derivadas no fio no parâmetro",
    "bitbybit.occt.shapes.wire.startPointOnWire": "ponto inicial no fio",
    "startPointOnWire": "ponto inicial no fio",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "obtém ponto inicial no fio",
    "bitbybit.occt.shapes.wire.endPointOnWire": "ponto final no fio",
    "endPointOnWire": "ponto final no fio",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "obtém ponto final no fio",
    "bitbybit.occt.shapes.wire.createCircleWire": "fio de círculo",
    "createCircleWire": "fio de círculo",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "cria fio de círculo opencascade",
    "bitbybit.occt.shapes.wire.createSquareWire": "fio de quadrado",
    "createSquareWire": "fio de quadrado",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "cria fio de quadrado opencascade",
    "bitbybit.occt.shapes.wire.createStarWire": "fio de estrela",
    "createStarWire": "fio de estrela",
    "bitbybit.occt.shapes.wire.createStarWire_description": "cria fio de estrela opencascade",
    "numRays": "número de raios",
    "outerRadius": "raio externo",
    "innerRadius": "raio interno",
    "offsetOuterEdges": "deslocar bordas externas",
    "half": "metade",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "fio de árvore de natal",
    "createChristmasTreeWire": "fio de árvore de natal",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "cria fio de árvore de natal",
    "innerDist": "distância interna",
    "outerDist": "distância externa",
    "nrSkirts": "número de saias",
    "trunkHeight": "altura do tronco",
    "trunkWidth": "largura do tronco",
    "bitbybit.occt.shapes.wire.createNGonWire": "fio de ngono",
    "createNGonWire": "fio de ngono",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "cria fio de ngono opencascade",
    "nrCorners": "número de cantos",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "fio de paralelogramo",
    "createParallelogramWire": "fio de paralelogramo",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "cria fio de paralelogramo",
    "aroundCenter": "ao redor do centro",
    "bitbybit.occt.shapes.wire.createHeartWire": "fio de coração",
    "createHeartWire": "fio de coração",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "cria fio de coração",
    "sizeApprox": "tamanho aproximado",
    "bitbybit.occt.shapes.wire.createRectangleWire": "fio de retângulo",
    "createRectangleWire": "fio de retângulo",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "cria fio de retângulo opencascade",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "fio de polígono em L",
    "createLPolygonWire": "fio de polígono em L",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "cria fio de polígono em L opencascade",
    "widthFirst": "largura primeiro",
    "lengthFirst": "comprimento primeiro",
    "widthSecond": "largura segundo",
    "lengthSecond": "comprimento segundo",
    "align": "alinhar",
    "directionEnum": "enum de direção",
    "bitbybit.occt.shapes.wire.createEllipseWire": "fio de elipse",
    "createEllipseWire": "fio de elipse",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "cria fio de elipse opencascade",
    "bitbybit.occt.shapes.wire.textWires": "Contornos de texto",
    "textWires": "Contornos de texto",
    "bitbybit.occt.shapes.wire.textWires_description": "Cria contornos de texto OpenCascade baseados na fonte simplex criada pelo Dr. A. V. Hershey.",
    "xOffset": "deslocamento x",
    "yOffset": "deslocamento y",
    "letterSpacing": "espaçamento entre letras",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "deslocamento de extrusão",
    "bitbybit.occt.shapes.wire.getWire": "obter fio",
    "getWire": "obter fio",
    "bitbybit.occt.shapes.wire.getWire_description": "obtém fio por índice da forma",
    "bitbybit.occt.shapes.wire.getWires": "obter fios",
    "getWires": "obter fios",
    "bitbybit.occt.shapes.wire.getWires_description": "obtém todos os fios da forma",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "obter centro de massa do fio",
    "getWireCenterOfMass": "obter centro de massa do fio",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "obtém o ponto do centro de massa do fio",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "obter centros de massa dos fios",
    "getWiresCentersOfMass": "obter centros de massa dos fios",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "obtém os pontos dos centros de massa dos fios",
    "bitbybit.occt.shapes.wire.reversedWire": "fio invertido",
    "reversedWire": "fio invertido",
    "bitbybit.occt.shapes.wire.reversedWire_description": "computa fio invertido",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "fio invertido a partir de bordas invertidas",
    "reversedWireFromReversedEdges": "fio invertido a partir de bordas invertidas",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "computa fio invertido a partir de bordas invertidas",
    "bitbybit.occt.shapes.wire.isWireClosed": "fio está fechado",
    "isWireClosed": "fio está fechado",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "verifica se o fio está fechado",
    "bitbybit.occt.shapes.wire.getWireLength": "obter comprimento do fio",
    "getWireLength": "obter comprimento do fio",
    "bitbybit.occt.shapes.wire.getWireLength_description": "obtém o comprimento do fio",
    "bitbybit.occt.shapes.wire.getWiresLengths": "obter comprimentos dos fios",
    "getWiresLengths": "obter comprimentos dos fios",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "obtém os comprimentos dos fios",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "posicionar fio na face",
    "placeWireOnFace": "posicionar fio na face",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "posiciona fio na face usando espaço uv",
    "face": "face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "posicionar fios na face",
    "placeWiresOnFace": "posicionar fios na face",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "posiciona múltiplos fios na face usando espaço uv",
    "wires": "fios",
    "bitbybit.occt.shapes.wire.closeOpenWire": "fechar fio aberto",
    "closeOpenWire": "fechar fio aberto",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "fecha fio aberto com borda reta",
    "bitbybit.occt.shapes.wire.project": "projetar",
    "project": "projetar",
    "bitbybit.occt.shapes.wire.project_description": "projeta fio na forma",
    "bitbybit.occt.shapes.wire.projectWires": "projetar fios",
    "projectWires": "projetar fios",
    "bitbybit.occt.shapes.wire.projectWires_description": "projeta múltiplos fios na forma",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "faces a partir de fios na face",
    "createFacesFromWiresOnFace": "faces a partir de fios na face",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "cria faces a partir de fios na face",
    "inside": "dentro",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "face a partir de fio na face",
    "createFaceFromWireOnFace": "face a partir de fio na face",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "cria face a partir de fio na face",
    "bitbybit.occt.shapes.face.createFaceFromWire": "face a partir de fio",
    "createFaceFromWire": "face a partir de fio",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "cria face a partir de fio",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "face a partir de fios",
    "createFaceFromWires": "face a partir de fios",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "cria face a partir de fios",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "face a partir de fios na face",
    "createFaceFromWiresOnFace": "face a partir de fios na face",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "cria face a partir de fios na face guia",
    "bitbybit.occt.shapes.face.createFacesFromWires": "faces a partir de fios",
    "createFacesFromWires": "faces a partir de fios",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "cria faces a partir de fios",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "face a partir de múltiplos fios tangentes de círculo",
    "createFaceFromMultipleCircleTanWires": "face a partir de múltiplos fios tangentes de círculo",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "cria face a partir de múltiplos fios tangentes de círculo",
    "circles": "círculos",
    "combination": "combinação",
    "combinationCirclesForFaceEnum": "enum de combinação de círculos para face",
    "unify": "unificar",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "face a partir de coleções de fios tangentes de círculo",
    "createFaceFromMultipleCircleTanWireCollections": "face a partir de coleções de fios tangentes de círculo",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "cria face a partir de múltiplas coleções de fios tangentes de círculo",
    "listsOfCircles": "listas de círculos",
    "T[][]": "array de array de t",
    "bitbybit.occt.shapes.face.faceFromSurface": "face a partir de superfície",
    "faceFromSurface": "face a partir de superfície",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "cria face a partir de superfície",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "face a partir de superfície e fio",
    "faceFromSurfaceAndWire": "face a partir de superfície e fio",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "cria face a partir de superfície e fio",
    "bitbybit.occt.shapes.face.createPolygonFace": "face poligonal",
    "createPolygonFace": "face poligonal",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "cria face poligonal opencascade",
    "bitbybit.occt.shapes.face.createCircleFace": "face de círculo",
    "createCircleFace": "face de círculo",
    "bitbybit.occt.shapes.face.createCircleFace_description": "cria face de círculo opencascade",
    "bitbybit.occt.shapes.face.createEllipseFace": "face de elipse",
    "createEllipseFace": "face de elipse",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "cria face de elipse opencascade",
    "bitbybit.occt.shapes.face.createSquareFace": "face de quadrado",
    "createSquareFace": "face de quadrado",
    "bitbybit.occt.shapes.face.createSquareFace_description": "cria face de quadrado opencascade",
    "bitbybit.occt.shapes.face.createRectangleFace": "face de retângulo",
    "createRectangleFace": "face de retângulo",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "cria face de retângulo opencascade",
    "bitbybit.occt.shapes.face.getFace": "obter face",
    "getFace": "obter face",
    "bitbybit.occt.shapes.face.getFace_description": "obtém face por índice da forma",
    "bitbybit.occt.shapes.face.getFaces": "obter faces",
    "getFaces": "obter faces",
    "bitbybit.occt.shapes.face.getFaces_description": "obtém faces da forma",
    "bitbybit.occt.shapes.face.reversedFace": "face invertida",
    "reversedFace": "face invertida",
    "bitbybit.occt.shapes.face.reversedFace_description": "computa face invertida",
    "bitbybit.occt.shapes.face.subdivideToPoints": "subdividir em pontos",
    "subdivideToPoints": "subdividir em pontos",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "subdivide face em grade de pontos",
    "nrDivisionsU": "número de divisões u",
    "nrDivisionsV": "número de divisões v",
    "shiftHalfStepU": "deslocar meio passo u",
    "removeStartEdgeU": "remover borda inicial u",
    "removeEndEdgeU": "remover borda final u",
    "shiftHalfStepV": "deslocar meio passo v",
    "removeStartEdgeV": "remover borda inicial v",
    "removeEndEdgeV": "remover borda final v",
    "bitbybit.occt.shapes.face.subdivideToWires": "subdividir em fios",
    "subdivideToWires": "subdividir em fios",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "subdivide face em fios",
    "nrDivisions": "número de divisões",
    "isU": "é u",
    "shiftHalfStep": "deslocar meio passo",
    "removeStart": "remover início",
    "removeEnd": "remover fim",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "subdividir em fios retangulares",
    "subdivideToRectangleWires": "subdividir em fios retangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "subdivide face em fios retangulares",
    "patterns": "padrões",
    "nrRectanglesU": "número de retângulos u",
    "nrRectanglesV": "número de retângulos v",
    "scalePatternU": "escala do padrão u",
    "scalePatternV": "escala do padrão v",
    "filletPattern": "padrão de arredondamento",
    "inclusionPattern": "padrão de inclusão",
    "offsetFromBorderU": "deslocamento da borda u",
    "offsetFromBorderV": "deslocamento da borda v",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "subdividir em buracos retangulares",
    "subdivideToRectangleHoles": "subdividir em buracos retangulares",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "subdivide face em fios retangulares",
    "holesToFaces": "buracos para faces",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "subdividir em pontos controlados",
    "subdivideToPointsControlled": "subdividir em pontos controlados",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "subdivide face em grade de pontos com deslocamentos controlados",
    "shiftHalfStepNthU": "deslocar meio passo nth u",
    "shiftHalfStepUOffsetN": "deslocar meio passo u offset n",
    "removeStartEdgeNthU": "remover borda inicial nth u",
    "removeStartEdgeUOffsetN": "remover borda inicial u offset n",
    "removeEndEdgeNthU": "remover borda final nth u",
    "removeEndEdgeUOffsetN": "remover borda final u offset n",
    "shiftHalfStepNthV": "deslocar meio passo nth v",
    "shiftHalfStepVOffsetN": "deslocar meio passo v offset n",
    "removeStartEdgeNthV": "remover borda inicial nth v",
    "removeStartEdgeVOffsetN": "remover borda inicial v offset n",
    "removeEndEdgeNthV": "remover borda final nth v",
    "removeEndEdgeVOffsetN": "remover borda final v offset n",
    "bitbybit.occt.shapes.face.subdivideToNormals": "subdividir em normais",
    "subdivideToNormals": "subdividir em normais",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "subdivide face em grade de normais",
    "bitbybit.occt.shapes.face.subdivideToUV": "subdividir em uv",
    "subdivideToUV": "subdividir em uv",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "subdivide face em grade uv",
    "bitbybit.occt.shapes.face.pointOnUV": "ponto no uv",
    "pointOnUV": "ponto no uv",
    "bitbybit.occt.shapes.face.pointOnUV_description": "obtém ponto no uv mapeado para os limites",
    "paramU": "parâmetro u",
    "paramV": "parâmetro v",
    "bitbybit.occt.shapes.face.normalOnUV": "normal no uv",
    "normalOnUV": "normal no uv",
    "bitbybit.occt.shapes.face.normalOnUV_description": "obtém normal no uv mapeado para os limites",
    "bitbybit.occt.shapes.face.pointsOnUVs": "pontos nos uvs",
    "pointsOnUVs": "pontos nos uvs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "obtém pontos nos uvs mapeados para os limites",
    "paramsUV": "parâmetros uv",
    "[number, number][]": "array de pares de números",
    "bitbybit.occt.shapes.face.normalsOnUVs": "normais nos uvs",
    "normalsOnUVs": "normais nos uvs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "obtém normais nos uvs mapeados para os limites",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "subdividir em pontos no parâmetro",
    "subdivideToPointsOnParam": "subdividir em pontos no parâmetro",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "subdivide face em pontos no parâmetro",
    "nrPoints": "número de pontos",
    "bitbybit.occt.shapes.face.wireAlongParam": "fio ao longo do parâmetro",
    "wireAlongParam": "fio ao longo do parâmetro",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "obtém fio ao longo do parâmetro na face",
    "bitbybit.occt.shapes.face.wiresAlongParams": "fios ao longo dos parâmetros",
    "wiresAlongParams": "fios ao longo dos parâmetros",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "obtém fios ao longo dos parâmetros na face",
    "params": "parâmetros",
    "bitbybit.occt.shapes.face.getUMinBound": "obter limite mínimo u",
    "getUMinBound": "obter limite mínimo u",
    "bitbybit.occt.shapes.face.getUMinBound_description": "obtém o limite mínimo u da face",
    "bitbybit.occt.shapes.face.getUMaxBound": "obter limite máximo u",
    "getUMaxBound": "obter limite máximo u",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "obtém o limite máximo u da face",
    "bitbybit.occt.shapes.face.getVMinBound": "obter limite mínimo v",
    "getVMinBound": "obter limite mínimo v",
    "bitbybit.occt.shapes.face.getVMinBound_description": "obtém o limite mínimo v da face",
    "bitbybit.occt.shapes.face.getVMaxBound": "obter limite máximo v",
    "getVMaxBound": "obter limite máximo v",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "obtém o limite máximo v da face",
    "bitbybit.occt.shapes.face.getFaceArea": "obter área da face",
    "getFaceArea": "obater área da face",
    "bitbybit.occt.shapes.face.getFaceArea_description": "obtém a área da face",
    "bitbybit.occt.shapes.face.getFacesAreas": "obter áreas das faces",
    "getFacesAreas": "obter áreas das faces",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "obtém as áreas das faces",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "obter centro de massa da face",
    "getFaceCenterOfMass": "obter centro de massa da face",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "obtém o ponto do centro de massa da face",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "obter centros de massa das faces",
    "getFacesCentersOfMass": "obter centros de massa das faces",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "obtém os centros de massa das faces",
    "bitbybit.occt.shapes.face.filterFacePoints": "filtrar pontos da face",
    "filterFacePoints": "filtrar pontos da face",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtra pontos na face",
    "filter": "filtrar",
    "useBndBox": "usar caixa delimitadora",
    "gapTolerance": "tolerância de lacuna",
    "keepIn": "manter dentro",
    "keepOn": "manter sobre",
    "keepOut": "manter fora",
    "keepUnknown": "manter desconhecido",
    "bitbybit.occt.shapes.face.filterFacesPoints": "filtrar pontos das faces",
    "filterFacesPoints": "filtrar pontos das faces",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtra pontos nas faces",
    "flatPointsArray": "array plano de pontos",
    "bitbybit.occt.shapes.shell.sewFaces": "costurar faces",
    "shell": "casca",
    "sewFaces": "costurar faces",
    "bitbybit.occt.shapes.shell.sewFaces_description": "cria casca a partir de faces",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "obter área de superfície da casca",
    "getShellSurfaceArea": "obter área de superfície da casca",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "obtém a área de superfície da casca",
    "bitbybit.occt.shapes.solid.fromClosedShell": "a partir de casca fechada",
    "solid": "sólido",
    "fromClosedShell": "a partir de casca fechada",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "cria sólido a partir de casca fechada",
    "bitbybit.occt.shapes.solid.createBox": "caixa",
    "bitbybit.occt.shapes.solid.createBox_description": "cria caixa opencascade",
    "originOnCenter": "origem no centro",
    "bitbybit.occt.shapes.solid.createCube": "cubo",
    "bitbybit.occt.shapes.solid.createCube_description": "cria cubo opencascade",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "caixa a partir de canto",
    "createBoxFromCorner": "caixa a partir de canto",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "cria caixa opencascade a partir de canto",
    "corner": "canto",
    "bitbybit.occt.shapes.solid.createCylinder": "cilindro",
    "bitbybit.occt.shapes.solid.createCylinder_description": "cria cilindro opencascade",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "cilindros em linhas",
    "createCylindersOnLines": "cilindros em linhas",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "cria cilindros opencascade em linhas",
    "Base.Line3[]": "array de linha base 3",
    "bitbybit.occt.shapes.solid.createSphere": "esfera",
    "bitbybit.occt.shapes.solid.createSphere_description": "cria esfera opencascade",
    "bitbybit.occt.shapes.solid.createCone": "cone",
    "createCone": "cone",
    "bitbybit.occt.shapes.solid.createCone_description": "cria cone opencascade",
    "radius1": "raio 1",
    "radius2": "raio 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "obter área de superfície do sólido",
    "getSolidSurfaceArea": "obter área de superfície do sólido",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "obtém a área de superfície do sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume": "obter volume do sólido",
    "getSolidVolume": "obter volume do sólido",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "obtém o volume do sólido",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "obter volumes dos sólidos",
    "getSolidsVolumes": "obter volumes dos sólidos",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "obtém os volumes dos sólidos",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "obter centro de massa do sólido",
    "getSolidCenterOfMass": "obter centro de massa do sólido",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "obtém o centro de massa do sólido",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "obter centros de massa dos sólidos",
    "getSolidsCentersOfMass": "obter centros de massa dos sólidos",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "obtém os centros de massa dos sólidos",
    "bitbybit.occt.shapes.solid.getSolids": "obter sólidos",
    "getSolids": "obter sólidos",
    "bitbybit.occt.shapes.solid.getSolids_description": "obtém sólidos da forma",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "filtrar pontos do sólido",
    "filterSolidPoints": "filtrar pontos do sólido",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "filtra pontos com base na relação com o sólido",
    "bitbybit.occt.shapes.compound.makeCompound": "criar composto",
    "compound": "composto",
    "makeCompound": "criar composto",
    "bitbybit.occt.shapes.compound.makeCompound_description": "cria forma composta a partir de formas",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "obter formas do composto",
    "getShapesOfCompound": "obter formas do composto",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "obtém formas do composto",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "remover bordas internas",
    "purgeInternalEdges": "remover bordas internas",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "remove bordas internas da forma",
    "bitbybit.occt.shapes.shape.unifySameDomain": "unificar mesmo domínio",
    "unifySameDomain": "unificar mesmo domínio",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "unifica faces e bordas no mesmo domínio",
    "unifyEdges": "unificar bordas",
    "unifyFaces": "unificar faces",
    "concatBSplines": "concatenar bsplines",
    "bitbybit.occt.shapes.shape.isClosed": "está fechado",
    "bitbybit.occt.shapes.shape.isClosed_description": "verifica se a forma está fechada",
    "analysis": "análise",
    "bitbybit.occt.shapes.shape.isConvex": "é convexo",
    "isConvex": "é convexo",
    "bitbybit.occt.shapes.shape.isConvex_description": "verifica se a forma é convexa",
    "bitbybit.occt.shapes.shape.isChecked": "está verificado",
    "bitbybit.occt.shapes.shape.isChecked_description": "verifica se a forma está verificada",
    "bitbybit.occt.shapes.shape.isFree": "é livre",
    "isFree": "é livre",
    "bitbybit.occt.shapes.shape.isFree_description": "verifica se a forma é livre",
    "bitbybit.occt.shapes.shape.isInfinite": "é infinito",
    "isInfinite": "é infinito",
    "bitbybit.occt.shapes.shape.isInfinite_description": "verifica se a forma é infinita",
    "bitbybit.occt.shapes.shape.isModified": "está modificado",
    "isModified": "está modificado",
    "bitbybit.occt.shapes.shape.isModified_description": "verifica se a forma está modificada",
    "bitbybit.occt.shapes.shape.isLocked": "está bloqueado",
    "isLocked": "está bloqueado",
    "bitbybit.occt.shapes.shape.isLocked_description": "verifica se a forma está bloqueada",
    "bitbybit.occt.shapes.shape.isNull": "é nulo",
    "isNull": "é nulo",
    "bitbybit.occt.shapes.shape.isNull_description": "verifica se a forma é nula",
    "bitbybit.occt.shapes.shape.isEqual": "é igual",
    "isEqual": "é igual",
    "bitbybit.occt.shapes.shape.isEqual_description": "verifica se a forma é igual a outra forma",
    "otherShape": "outra forma",
    "bitbybit.occt.shapes.shape.isNotEqual": "não é igual",
    "isNotEqual": "não é igual",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "verifica se a forma difere de outra forma",
    "bitbybit.occt.shapes.shape.isPartner": "é parceiro",
    "isPartner": "é parceiro",
    "bitbybit.occt.shapes.shape.isPartner_description": "verifica se a forma é parceira de outra forma",
    "bitbybit.occt.shapes.shape.isSame": "é o mesmo",
    "isSame": "é o mesmo",
    "bitbybit.occt.shapes.shape.isSame_description": "verifica se a forma é a mesma que outra forma",
    "bitbybit.occt.shapes.shape.getOrientation": "obter orientação",
    "getOrientation": "obter orientação",
    "bitbybit.occt.shapes.shape.getOrientation_description": "obtém a orientação da forma",
    "bitbybit.occt.shapes.shape.getShapeType": "obter tipo de forma",
    "getShapeType": "obter tipo de forma",
    "bitbybit.occt.shapes.shape.getShapeType_description": "obtém o tipo da forma",
    "bitbybit.occt.geom.curves.geom2dEllipse": "elipse geom 2d",
    "geom": "geom",
    "curves": "curvas",
    "geom2dEllipse": "elipse geom 2d",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "cria elipse 2d para modelagem",
    "Base.Point2": "ponto base 2",
    "Base.Vector2": "vetor base 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "curva aparada geom 2d",
    "geom2dTrimmedCurve": "curva aparada geom 2d",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "cria curva aparada entre u1 e u2",
    "u1": "u1",
    "u2": "u2",
    "adjustPeriodic": "ajustar periódico",
    "bitbybit.occt.geom.curves.geom2dSegment": "segmento geom 2d",
    "geom2dSegment": "segmento geom 2d",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "cria segmento de curva 2d entre dois pontos",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "obter ponto 2d de curva 2d no parâmetro",
    "get2dPointFrom2dCurveOnParam": "obter ponto 2d de curva 2d no parâmetro",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "obtém ponto 2d na curva no parâmetro",
    "bitbybit.occt.geom.curves.geomCircleCurve": "curva de círculo geom",
    "geomCircleCurve": "curva de círculo geom",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "cria curva geométrica de círculo",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "curva de elipse geom",
    "geomEllipseCurve": "curva de elipse geom",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "cria curva geométrica de elipse",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "superfície cilíndrica",
    "surfaces": "superfícies",
    "cylindricalSurface": "superfície cilíndrica",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "cria superfície cilíndrica infinita para modelagem",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "superfície a partir de face",
    "surfaceFromFace": "superfície a partir de face",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "cria superfície a partir de face",
    "bitbybit.occt.fillets.filletEdges": "arredondar bordas",
    "fillets": "arredondamentos",
    "filletEdges": "arredondar bordas",
    "bitbybit.occt.fillets.filletEdges_description": "arredonda formas opencascade",
    "3d fillets": "arredondamentos 3d",
    "radiusList": "lista de raios",
    "indexes": "índices",
    "bitbybit.occt.fillets.filletEdgesList": "lista de bordas arredondadas",
    "filletEdgesList": "lista de bordas arredondadas",
    "bitbybit.occt.fillets.filletEdgesList_description": "arredonda bordas com diferentes raios",
    "edges": "bordas",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "lista de bordas arredondadas com um raio",
    "filletEdgesListOneRadius": "lista de bordas arredondadas com um raio",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "arredonda bordas com um único raio",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "arredondar borda com raio variável",
    "filletEdgeVariableRadius": "arredondar borda com raio variável",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "arredonda borda com raio variável nos parâmetros u",
    "paramsU": "parâmetros u",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "arredondar bordas com mesmo raio variável",
    "filletEdgesSameVariableRadius": "arredondar bordas com mesmo raio variável",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "arredonda bordas com os mesmos raios variáveis",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "arredondar bordas com raio variável",
    "filletEdgesVariableRadius": "arredondar bordas com raio variável",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "arredonda bordas com raios variáveis nos parâmetros",
    "radiusLists": "listas de raios",
    "paramsULists": "listas de parâmetros u",
    "bitbybit.occt.fillets.fillet3DWire": "arredondar fio 3d",
    "fillet3DWire": "arredondar fio 3d",
    "bitbybit.occt.fillets.fillet3DWire_description": "arredonda fio 3d com direção guia",
    "bitbybit.occt.fillets.fillet3DWires": "arredondar fios 3d",
    "fillet3DWires": "arredondar fios 3d",
    "bitbybit.occt.fillets.fillet3DWires_description": "arredonda fios 3d com direção guia",
    "bitbybit.occt.fillets.chamferEdges": "chanfrar bordas",
    "chamferEdges": "chanfrar bordas",
    "bitbybit.occt.fillets.chamferEdges_description": "chanfra bordas de forma opencascade",
    "3d chamfers": "chanfros 3d",
    "distanceList": "lista de distâncias",
    "bitbybit.occt.fillets.chamferEdgesList": "lista de bordas chanfradas",
    "chamferEdgesList": "lista de bordas chanfradas",
    "bitbybit.occt.fillets.chamferEdgesList_description": "chanfra bordas com diferentes distâncias",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "chanfrar borda com duas distâncias",
    "chamferEdgeTwoDistances": "chanfrar borda com duas distâncias",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "chanfra borda com duas distâncias",
    "F": "f",
    "distance1": "distância 1",
    "distance2": "distância 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "chanfrar bordas com duas distâncias",
    "chamferEdgesTwoDistances": "chanfrar bordas com duas distâncias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "chanfra bordas com duas distâncias",
    "faces": "faces",
    "F[]": "array de f",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "chanfrar bordas com listas de duas distâncias",
    "chamferEdgesTwoDistancesLists": "chanfrar bordas com listas de duas distâncias",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "chanfra bordas com listas de duas distâncias",
    "distances1": "distâncias 1",
    "distances2": "distâncias 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "chanfrar borda com distância e ângulo",
    "chamferEdgeDistAngle": "chanfrar borda com distância e ângulo",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "chanfra borda com distância e ângulo",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "chanfrar bordas com distância e ângulo",
    "chamferEdgesDistAngle": "chanfrar bordas com distância e ângulo",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "chanfra bordas com distância e ângulo",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "chanfrar bordas com distâncias e ângulos",
    "chamferEdgesDistsAngles": "chanfrar bordas com distâncias e ângulos",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "chanfra bordas com distâncias e ângulos",
    "distances": "distâncias",
    "bitbybit.occt.fillets.fillet2d": "arredondar 2d",
    "fillet2d": "arredondar 2d",
    "bitbybit.occt.fillets.fillet2d_description": "arredonda fio ou face 2d",
    "2d fillets": "arredondamentos 2d",
    "bitbybit.occt.fillets.fillet2dShapes": "arredondar formas 2d",
    "fillet2dShapes": "arredondar formas 2d",
    "bitbybit.occt.fillets.fillet2dShapes_description": "arredonda fios ou faces 2d",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "arredondar duas bordas no plano em um fio",
    "filletTwoEdgesInPlaneIntoAWire": "arredondar duas bordas no plano em um fio",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "arredonda duas bordas planares em um fio",
    "edge1": "borda 1",
    "edge2": "borda 2",
    "planeOrigin": "origem do plano",
    "planeDirection": "direção do plano",
    "solution": "solução",
    "bitbybit.occt.transforms.transform": "transformar",
    "bitbybit.occt.transforms.transform_description": "transforma a forma",
    "on single shape": "em uma única forma",
    "rotationAxis": "eixo de rotação",
    "rotationAngle": "ângulo de rotação",
    "scaleFactor": "fator de escala",
    "bitbybit.occt.transforms.rotate": "rotacionar",
    "bitbybit.occt.transforms.rotate_description": "rotaciona a forma",
    "bitbybit.occt.transforms.rotateAroundCenter": "rotacionar ao redor do centro",
    "rotateAroundCenter": "rotacionar ao redor do centro",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "rotaciona a forma ao redor do centro",
    "bitbybit.occt.transforms.align": "alinhar",
    "bitbybit.occt.transforms.align_description": "alinha a forma",
    "fromOrigin": "da origem",
    "fromDirection": "da direção",
    "toOrigin": "para a origem",
    "toDirection": "para a direção",
    "bitbybit.occt.transforms.alignAndTranslate": "alinhar e transladar",
    "alignAndTranslate": "alinhar e transladar",
    "bitbybit.occt.transforms.alignAndTranslate_description": "alinha e translada a forma",
    "bitbybit.occt.transforms.translate": "transladar",
    "bitbybit.occt.transforms.translate_description": "translada a forma",
    "bitbybit.occt.transforms.scale": "escalar",
    "bitbybit.occt.transforms.scale_description": "escala a forma",
    "bitbybit.occt.transforms.scale3d": "escalar 3d",
    "scale3d": "escalar 3d",
    "bitbybit.occt.transforms.scale3d_description": "escala a forma em 3d",
    "bitbybit.occt.transforms.mirror": "espelhar",
    "mirror": "espelhar",
    "bitbybit.occt.transforms.mirror_description": "espelha a forma",
    "bitbybit.occt.transforms.mirrorAlongNormal": "espelhar ao longo da normal",
    "mirrorAlongNormal": "espelhar ao longo da normal",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "espelha a forma ao longo da normal e origem",
    "normal": "normal",
    "bitbybit.occt.transforms.transformShapes": "transformar formas",
    "transformShapes": "transformar formas",
    "bitbybit.occt.transforms.transformShapes_description": "transforma array de formas",
    "on shapes": "em formas",
    "rotationAxes": "eixos de rotação",
    "rotationAngles": "ângulos de rotação",
    "scaleFactors": "fatores de escala",
    "bitbybit.occt.transforms.rotateShapes": "rotacionar formas",
    "rotateShapes": "rotacionar formas",
    "bitbybit.occt.transforms.rotateShapes_description": "rotaciona formas",
    "axes": "eixos",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "rotacionar formas ao redor do centro",
    "rotateAroundCenterShapes": "rotacionar formas ao redor do centro",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "rotaciona formas ao redor do centro e eixo",
    "centers": "centros",
    "bitbybit.occt.transforms.alignShapes": "alinhar formas",
    "alignShapes": "alinhar formas",
    "bitbybit.occt.transforms.alignShapes_description": "alinha formas",
    "fromOrigins": "das origens",
    "fromDirections": "das direções",
    "toOrigins": "para as origens",
    "toDirections": "para as direções",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "alinhar e transladar formas",
    "alignAndTranslateShapes": "alinhar e transladar formas",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "alinha e translada formas",
    "directions": "direções",
    "bitbybit.occt.transforms.translateShapes": "transladar formas",
    "translateShapes": "transladar formas",
    "bitbybit.occt.transforms.translateShapes_description": "translada formas",
    "bitbybit.occt.transforms.scaleShapes": "escalar formas",
    "scaleShapes": "escalar formas",
    "bitbybit.occt.transforms.scaleShapes_description": "escala formas",
    "factors": "fatores",
    "bitbybit.occt.transforms.scale3dShapes": "escalar formas 3d",
    "scale3dShapes": "escalar formas 3d",
    "bitbybit.occt.transforms.scale3dShapes_description": "escala formas em 3d",
    "scales": "escalas",
    "bitbybit.occt.transforms.mirrorShapes": "espelhar formas",
    "mirrorShapes": "espelhar formas",
    "bitbybit.occt.transforms.mirrorShapes_description": "espelha formas",
    "origins": "origens",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "espelhar formas ao longo da normal",
    "mirrorAlongNormalShapes": "espelhar formas ao longo da normal",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "espelha formas ao longo da normal e origem",
    "normals": "normais",
    "bitbybit.occt.operations.loft": "loft",
    "operations": "operações",
    "loft": "loft",
    "bitbybit.occt.operations.loft_description": "eleva fios em uma casca",
    "lofts": "lofts",
    "makeSolid": "criar sólido",
    "bitbybit.occt.operations.loftAdvanced": "loft avançado",
    "loftAdvanced": "loft avançado",
    "bitbybit.occt.operations.loftAdvanced_description": "eleva fios em uma casca com opções",
    "straight": "reto",
    "nrPeriodicSections": "número de seções periódicas",
    "useSmoothing": "usar suavização",
    "maxUDegree": "grau máximo u",
    "parType": "tipo de parâmetro",
    "approxParametrizationTypeEnum": "enum de tipo de parametrização aproximada",
    "startVertex": "vértice inicial",
    "endVertex": "vértice final",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "pontos mais próximos entre duas formas",
    "closestPointsBetweenTwoShapes": "pontos mais próximos entre duas formas",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "computa os pontos mais próximos entre duas formas",
    "closest pts": "pontos mais próximos",
    "shape1": "forma 1",
    "shape2": "forma 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "pontos mais próximos na forma a partir de pontos",
    "closestPointsOnShapeFromPoints": "pontos mais próximos na forma a partir de pontos",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "computa os pontos mais próximos de pontos para a forma",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "pontos mais próximos nas formas a partir de pontos",
    "closestPointsOnShapesFromPoints": "pontos mais próximos nas formas a partir de pontos",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "computa os pontos mais próximos de pontos para as formas",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "distâncias até a forma a partir de pontos",
    "distancesToShapeFromPoints": "distâncias até a forma a partir de pontos",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "computa as distâncias de pontos até a forma",
    "bitbybit.occt.operations.boundingBoxOfShape": "caixa delimitadora da forma",
    "boundingBoxOfShape": "caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "computa os parâmetros da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "mínimo da caixa delimitadora da forma",
    "boundingBoxMinOfShape": "mínimo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "obtém o ponto mínimo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "máximo da caixa delimitadora da forma",
    "boundingBoxMaxOfShape": "máximo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "obtém o ponto máximo da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "centro da caixa delimitadora da forma",
    "boundingBoxCenterOfShape": "centro da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "obtém o ponto central da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "tamanho da caixa delimitadora da forma",
    "boundingBoxSizeOfShape": "tamanho da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "obtém o tamanho da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "forma da caixa delimitadora da forma",
    "boundingBoxShapeOfShape": "forma da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "obtém a forma da caixa delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereOfShape": "esfera delimitadora da forma",
    "boundingSphereOfShape": "esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "computa os parâmetros da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "centro da esfera delimitadora da forma",
    "boundingSphereCenterOfShape": "centro da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "obtém o ponto central da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "raio da esfera delimitadora da forma",
    "boundingSphereRadiusOfShape": "raio da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "obtém o raio da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "forma da esfera delimitadora da forma",
    "boundingSphereShapeOfShape": "forma da esfera delimitadora da forma",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "obtém a forma da esfera delimitadora da forma",
    "bitbybit.occt.operations.extrude": "extrusão",
    "extrude": "extrusão",
    "bitbybit.occt.operations.extrude_description": "extruda a forma ao longo da direção",
    "extrusions": "extrusões",
    "bitbybit.occt.operations.extrudeShapes": "extrudar formas",
    "extrudeShapes": "extrudar formas",
    "bitbybit.occt.operations.extrudeShapes_description": "extruda formas ao longo da direção",
    "bitbybit.occt.operations.splitShapeWithShapes": "dividir forma com formas",
    "splitShapeWithShapes": "dividir forma com formas",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "divide a forma com formas",
    "divisions": "divisões",
    "localFuzzyTolerance": "tolerância fuzzy local",
    "nonDestructive": "não destrutivo",
    "bitbybit.occt.operations.revolve": "revolver",
    "revolve": "revolver",
    "bitbybit.occt.operations.revolve_description": "revolve a forma ao redor da direção",
    "revolutions": "revoluções",
    "copy": "copiar",
    "bitbybit.occt.operations.rotatedExtrude": "extrusão rotacionada",
    "rotatedExtrude": "extrusão rotacionada",
    "bitbybit.occt.operations.rotatedExtrude_description": "realiza extrusão rotacionada na forma",
    "bitbybit.occt.operations.pipe": "tubo",
    "pipe": "tubo",
    "bitbybit.occt.operations.pipe_description": "tuba formas ao longo de um fio",
    "pipeing": "tubagem",
    "bitbybit.occt.operations.pipePolylineWireNGon": "tubo de fio polilinha ngono",
    "pipePolylineWireNGon": "tubo de fio polilinha ngono",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "tuba fio polilinha com perfil ngono",
    "trihedronEnum": "enum de triedro",
    "geomFillTrihedronEnum": "enum de preenchimento geométrico de triedro",
    "forceApproxC1": "forçar aproximação c1",
    "bitbybit.occt.operations.pipeWiresCylindrical": "tuba fios cilíndricos",
    "pipeWiresCylindrical": "tuba fios cilíndricos",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "tuba fios com forma cilíndrica",
    "bitbybit.occt.operations.pipeWireCylindrical": "tuba fio cilíndrico",
    "pipeWireCylindrical": "tuba fio cilíndrico",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "tuba fio com forma cilíndrica",
    "bitbybit.occt.operations.offset": "deslocamento",
    "bitbybit.occt.operations.offset_description": "desloca formas",
    "offsets": "deslocamentos",
    "bitbybit.occt.operations.offsetAdv": "deslocamento avançado",
    "offsetAdv": "deslocamento avançado",
    "bitbybit.occt.operations.offsetAdv_description": "desloca com opções avançadas",
    "joinType": "tipo de junção",
    "joinTypeEnum": "enum de tipo de junção",
    "removeIntEdges": "remover bordas internas",
    "bitbybit.occt.operations.makeThickSolidSimple": "criar sólido espesso simples",
    "makeThickSolidSimple": "criar sólido espesso simples",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "engrossa a forma em um sólido",
    "bitbybit.occt.operations.makeThickSolidByJoin": "criar sólido espesso por junção",
    "makeThickSolidByJoin": "criar sólido espesso por junção",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "engrossa a forma em um sólido por junção",
    "intersection": "interseção",
    "selfIntersection": "autointerseção",
    "bitbybit.occt.operations.slice": "fatiar",
    "slice": "fatiar",
    "bitbybit.occt.operations.slice_description": "fatia a forma",
    "bitbybit.occt.operations.sliceInStepPattern": "fatiar em padrão de passos",
    "sliceInStepPattern": "fatiar em padrão de passos",
    "bitbybit.occt.operations.sliceInStepPattern_description": "fatia a forma em padrão de passos",
    "steps": "passos",
    "bitbybit.occt.operations.offset3DWire": "deslocar fio 3d",
    "offset3DWire": "deslocar fio 3d",
    "bitbybit.occt.operations.offset3DWire_description": "desloca fio 3d",
    "bitbybit.occt.booleans.union": "união",
    "booleans": "booleanos",
    "union": "união",
    "bitbybit.occt.booleans.union_description": "junta objetos",
    "keepEdges": "manter bordas",
    "bitbybit.occt.booleans.difference": "diferença",
    "difference": "diferença",
    "bitbybit.occt.booleans.difference_description": "realiza diferença booleana",
    "bitbybit.occt.booleans.intersection": "interseção",
    "bitbybit.occt.booleans.intersection_description": "realiza interseção booleana",
    "bitbybit.occt.shapeFix.basicShapeRepair": "reparo básico de forma",
    "shapeFix": "correção de forma",
    "basicShapeRepair": "reparo básico de forma",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "repara a forma",
    "maxTolerance": "tolerância máxima",
    "minTolerance": "tolerância mínima",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "corrigir borda pequena no fio",
    "fixSmallEdgeOnWire": "corrigir borda pequena no fio",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "corrige borda pequena no fio",
    "lockvtx": "bloquear vértice",
    "precsmall": "precisão pequena",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "corrigir orientações de bordas ao longo do fio",
    "fixEdgeOrientationsAlongWire": "corrigir orientações de bordas ao longo do fio",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "corrige orientações de bordas ao longo do fio",
    "bitbybit.occt.io.saveShapeSTEP": "salvar forma STEP",
    "saveShapeSTEP": "salvar forma STEP",
    "bitbybit.occt.io.saveShapeSTEP_description": "salva arquivo STEP",
    "adjustYtoZ": "ajustar Y para Z",
    "tryDownload": "tentar baixar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "salvar forma STEP e retornar",
    "saveShapeSTEPAndReturn": "salvar forma STEP e retornar",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "salva arquivo STEP e retorna texto",
    "bitbybit.occt.io.saveShapeStl": "salvar forma STL",
    "saveShapeStl": "salvar forma STL",
    "bitbybit.occt.io.saveShapeStl_description": "salva arquivo STL",
    "binary": "binário",
    "bitbybit.occt.io.saveShapeStlAndReturn": "salvar forma STL e retornar",
    "saveShapeStlAndReturn": "salvar forma STL e retornar",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "salva arquivo STL e retorna",
    "bitbybit.occt.io.loadSTEPorIGES": "carregar STEP ou IGES",
    "loadSTEPorIGES": "carregar STEP ou IGES",
    "bitbybit.occt.io.loadSTEPorIGES_description": "importa arquivo STEP ou IGES",
    "adjustZtoY": "ajustar Z para Y",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "carregar STEP ou IGES a partir de texto",
    "loadSTEPorIGESFromText": "carregar STEP ou IGES a partir de texto",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "importa STEP ou IGES a partir de texto",
    "fileType": "tipo de arquivo",
    "fileTypeEnum": "enum de tipo de arquivo",
    "bitbybit.advanced.text3d.create": "texto 3d",
    "advanced": "avançado",
    "text3d": "texto 3d",
    "bitbybit.advanced.text3d.create_description": "cria texto 3d",
    "fontType": "tipo de fonte",
    "fontsEnum": "enum de fontes",
    "fontVariant": "variante da fonte",
    "fontVariantsEnum": "enum de variantes de fonte",
    "Inputs.Base.Vector3": "vetor base 3 de entrada",
    "originAlignment": "alinhamento da origem",
    "recAlignmentEnum": "enum de alinhamento de registro",
    "bitbybit.advanced.text3d.createTextOnFace": "texto na face",
    "createTextOnFace": "texto na face",
    "bitbybit.advanced.text3d.createTextOnFace_description": "cria texto 3d na face",
    "facePlanar": "face planar",
    "faceTextVar": "variável de texto da face",
    "faceTextVarEnum": "enum de variável de texto da face",
    "originParamU": "parâmetro de origem u",
    "originParamV": "parâmetro de origem v",
    "bitbybit.advanced.text3d.createTextsOnFace": "textos na face",
    "createTextsOnFace": "textos na face",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "cria textos 3d na face",
    "definitions": "definições",
    "Text3DFaceDefinitionDto[]": "array de dto de definição de texto 3d na face",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "definição de texto 3d na face",
    "definition3dTextOnFace": "definição de texto 3d na face",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "cria texto 3d para definição de face",
    "bitbybit.advanced.text3d.getCompoundShape": "obter forma composta",
    "getCompoundShape": "obter forma composta",
    "bitbybit.advanced.text3d.getCompoundShape_description": "obtém a forma composta do texto 3d",
    "model": "modelo",
    "Text3DData<T>": "dados de texto 3d t",
    "bitbybit.advanced.text3d.getCharacterShape": "obter forma do caractere",
    "getCharacterShape": "obter forma do caractere",
    "bitbybit.advanced.text3d.getCharacterShape_description": "obtém a forma do caractere no índice",
    "bitbybit.advanced.text3d.getCharacterShapes": "obter formas dos caracteres",
    "getCharacterShapes": "obter formas dos caracteres",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "obtém as formas dos caracteres do texto 3d",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "obter coordenadas centrais dos caracteres",
    "getCharacterCenterCoordinates": "obter coordenadas centrais dos caracteres",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "obtém as coordenadas centrais dos caracteres",
    "bitbybit.advanced.text3d.getFaceCutout": "obter recorte da face",
    "getFaceCutout": "obter recorte da face",
    "bitbybit.advanced.text3d.getFaceCutout_description": "obtém o recorte da face do texto 3d na face",
    "get from face": "obter da face",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "obter todas as faces do recorte",
    "getAllFacesOfCutout": "obter todas as faces do recorte",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "obtém todos os recortes de face do texto 3d",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "obter recortes dentro dos caracteres",
    "getCutoutsInsideCharacters": "obter recortes dentro dos caracteres",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "obtém recortes de face dos caracteres do texto 3d",
    "bitbybit.advanced.text3d.getAdvanceWidth": "obter largura de avanço",
    "getAdvanceWidth": "obter largura de avanço",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "obtém a largura de avanço",
    "dimensions": "dimensões",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "pirâmide simples",
    "facePatterns": "padrões de face",
    "pyramidSimple": "pirâmide simples",
    "createPyramidSimple": "pirâmide simples",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "cria padrão de pirâmide simples nas faces",
    "uNumber": "número u",
    "vNumber": "número v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "afetadores de pirâmide simples",
    "createPyramidSimpleAffectors": "afetadores de pirâmide simples",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "cria padrão de pirâmide com afetadores",
    "affectorPoints": "pontos afetadores",
    "Inputs.Base.Point3[]": "array de ponto base 3 de entrada",
    "affectorRadiusList": "lista de raios afetadores",
    "affectorFactors": "fatores afetadores",
    "defaultHeight": "altura padrão",
    "affectMinHeight": "altura mínima afetada",
    "affectMaxHeight": "altura máxima afetada",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "obter forma composta",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "obtém a forma composta das pirâmides",
    "get shapes": "obter formas",
    "PyramidSimpleData<T>": "dados de pirâmide simples t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "obter forma composta na face",
    "getCompoundShapeOnFace": "obter forma composta na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "obtém a forma composta na face",
    "faceIndex": "índice da face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "obter célula de forma composta na face",
    "getCompoundShapeCellOnFace": "obter célula de forma composta na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "obtém a forma de pirâmide na face no índice",
    "uIndex": "índice u",
    "vIndex": "índice v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "obter todas as células de pirâmide",
    "getAllPyramidCells": "obter todas as células de pirâmide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "obtém todas as células de pirâmide",
    "get cells": "obter células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "obter todas as células de pirâmide na face",
    "getAllPyramidCellsOnFace": "obter todas as células de pirâmide na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "obtém as células de pirâmide na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "obter todas as células u de pirâmide na face",
    "getAllPyramidUCellsOnFace": "obter todas as células u de pirâmide na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "obtém as células u de pirâmide na face",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "obter todas as células u de pirâmide na face em u",
    "getAllPyramidUCellsOnFaceAtU": "obter todas as células u de pirâmide na face em u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "obtém as células de pirâmide na face em u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "obter todas as células u de pirâmide na face em v",
    "getAllPyramidUCellsOnFaceAtV": "obter todas as células u de pirâmide na face em v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "obtém as células de pirâmide na face em v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "obter célula no índice",
    "getCellOnIndex": "obter célula no índice",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "obtém a célula de pirâmide na face em u e v",
    "get cell": "obter célula",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obter pontos superiores das células",
    "getTopPointsOfCells": "obter pontos superiores das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "obtém os pontos superiores das células",
    "get from cells": "obter das células",
    "cells": "células",
    "PyramidSimpleCellPart<T>[]": "array de parte de célula de pirâmide simples t",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "obter pontos centrais das células",
    "getCenterPointsOfCells": "obter pontos centrais das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "obtém os pontos centrais das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "obter pontos de canto das células",
    "getCornerPointsOfCells": "obter pontos de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "obtém os pontos de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "obter ponto de canto das células",
    "getCornerPointOfCells": "obter ponto de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "obtém o ponto de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "obter normal de canto das células",
    "getCornerNormalOfCells": "obter normal de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "obtém a normal de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "obter normais de canto das células",
    "getCornerNormalsOfCells": "obter normais de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "obtém as normais de canto das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "obter formas compostas das células",
    "getCompoundShapesOfCells": "obter formas compostas das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "obtém as formas compostas das células de pirâmide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "obter formas de face das células",
    "getFaceShapesOfCells": "obter formas de face das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "obtém as formas de face das células de pirâmide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "obter formas de fio das células",
    "getWireShapesOfCells": "obter formas de fio das células",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "obtém as formas de fio das células de pirâmide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "obter fio polilinha inicial u",
    "getStartPolylineWireU": "obter fio polilinha inicial u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "obtém o fio polilinha ao longo da borda inicial u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "obter fio polilinha final u",
    "getEndPolylineWireU": "obter fio polilinha final u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "obtém o fio polilinha ao longo da borda final u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "obter fio polilinha inicial v",
    "getStartPolylineWireV": "obter fio polilinha inicial v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "obtém o fio polilinha ao longo da borda inicial v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "obter fio polilinha final v",
    "getEndPolylineWireV": "obter fio polilinha final v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "obtém o fio polilinha ao longo da borda final v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "obter composto de fios polilinha u",
    "getPolylineWiresUCompound": "obter composto de fios polilinha u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "obtém os fios polilinha ao longo de u",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "obter composto de fios polilinha v",
    "getPolylineWiresVCompound": "obter composto de fios polilinha v",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "obtém os fios polilinha ao longo de v",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "villa ponta de asa",
    "things": "coisas",
    "kidsCorner": "cantinho das crianças",
    "birdhouses": "casas de pássaros",
    "wingtipVilla": "villa ponta de asa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "cria casa de pássaros villa ponta de asa",
    "birdhouse": "casa de pássaros",
    "interiorWidth": "largura interna",
    "interiorLength": "comprimento interno",
    "interiorHeight": "altura interna",
    "holeDiameter": "diâmetro do buraco",
    "holeDistToBottom": "distância do buraco ao fundo",
    "stickLength": "comprimento do bastão",
    "stickDiameter": "diâmetro do bastão",
    "baseAttachmentHeight": "altura de fixação da base",
    "roofOverhang": "saliência do telhado",
    "chimneyHeight": "altura da chaminé",
    "Inputs.Base.Point3": "ponto base 3 de entrada",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "chalé chirpy",
    "chirpyChalet": "chalé chirpy",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "cria casa de pássaros chalé chirpy",
    "roofAngle": "ângulo do telhado",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "redemoinho da serenidade",
    "threeDPrinting": "impressão 3d",
    "vases": "vasos",
    "serenitySwirl": "redemoinho da serenidade",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "cria vaso redemoinho da serenidade",
    "swirl": "redemoinho",
    "addRadiusNarrow": "adicionar raio estreito",
    "addRadiusWide": "adicionar raio largo",
    "addMiddleHeight": "adicionar altura média",
    "addTopHeight": "adicionar altura superior",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "arco árabe",
    "arabicArchway": "arco árabe",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "cria vaso arco árabe",
    "profilePoints": "pontos de perfil",
    "nrOfSides": "número de lados",
    "nrOfVerticalArches": "número de arcos verticais",
    "archCenterThickness": "espessura central do arco",
    "edgesThickness": "espessura das bordas",
    "baseHeight": "altura da base",
    "patchHoles": "remendar buracos",
    "lod": "nível de detalhe",
    "Things.Enums.lodEnum": "enum de nível de detalhe de coisas",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "amor eterno",
    "medals": "medalhas",
    "eternalLove": "amor eterno",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "cria medalha amor eterno",
    "textHeading": "título do texto",
    "textName": "nome do texto",
    "fullModel": "modelo completo",
    "decorationThickness": "espessura da decoração",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "copo calmo",
    "cups": "copos",
    "calmCup": "copo calmo",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "cria modelo de copo calmo",
    "radiusTopOffset": "deslocamento do raio superior",
    "fillet": "arredondamento",
    "nrOfHandles": "número de alças",
    "handleDist": "distância da alça",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "copo dragão",
    "dragonCup": "copo dragão",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "cria modelo de copo dragão",
    "radiusMidOffset": "deslocamento do raio médio",
    "rotationTopAngle": "ângulo de rotação superior",
    "rotationMidAngle": "ângulo de rotação médio",
    "nrSkinCellsVertical": "número de células de pele verticais",
    "nrSkinCellsHorizontal": "número de células de pele horizontais",
    "nrSkinCellDivisionsTop": "número de divisões de células de pele superiores",
    "nrSkinCellDivisionsBottom": "número de divisões de células de pele inferiores",
    "skinCellOuterHeight": "altura externa da célula de pele",
    "skinCellInnerHeight": "altura interna da célula de pele",
    "skinCellBottomHeight": "altura inferior da célula de pele",
    "skinCellTopHeight": "altura superior da célula de pele",
    "bottomThickness": "espessura do fundo",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "obter forma composta",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "obtém a forma composta do copo dragão",
    "DragonCupData<T>": "dados do copo dragão t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "ninho de telefone",
    "desktop": "área de trabalho",
    "phoneNest": "ninho de telefone",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "cria modelo de ninho de telefone",
    "heightBottom": "altura inferior",
    "heightTop": "altura superior",
    "widthBack": "largura traseira",
    "widthFront": "largura frontal",
    "backOffset": "deslocamento traseiro",
    "applyOrnaments": "aplicar ornamentos",
    "filletRadius": "raio de arredondamento",
    "phoneHeight": "altura do telefone",
    "phoneWidth": "largura do telefone",
    "phoneThickness": "espessura do telefone",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "obter forma composta",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "obtém a forma composta do ninho de telefone",
    "PhoneNestData<T>": "dados do ninho de telefone t",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "opções de desenho",
    "drawOptions": "opções de desenho",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "cria opções de desenho para o modelo",
    "mainMaterial": "material principal",
    "phoneMaterial": "material do telefone",
    "Inputs.Base.Color": "cor base de entrada",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "suporte de telefone gotículas",
    "laserCutting": "corte a laser",
    "gadgets": "apetrechos",
    "dropletsPhoneHolder": "suporte de telefone gotículas",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "cria suporte de telefone gotículas",
    "title": "título",
    "subtitle": "subtítulo",
    "includeLogo": "incluir logotipo",
    "kerf": "kerf",
    "backLength": "comprimento traseiro",
    "offsetAroundPhone": "deslocamento ao redor do telefone",
    "penShelf": "prateleira para caneta",
    "phoneLockHeight": "altura de trava do telefone",
    "includePattern": "incluir padrão",
    "densityPattern": "padrão de densidade",
    "holesForWire": "buracos para fio",
    "wireInputThickness": "espessura de entrada do fio",
    "includeModel": "incluir modelo",
    "includeDrawings": "incluir desenhos",
    "spacingDrawings": "espaçamento dos desenhos",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "obter forma composta",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "obtém a forma composta do suporte de telefone gotículas",
    "DropletsPhoneHolderData<T>": "dados do suporte de telefone gotículas t",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "obter composto de fios de corte",
    "getCutWiresCompound": "obter composto de fios de corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "obtém o composto de fios de corte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "obter composto de fios de gravação",
    "getEngravingWiresCompound": "obter composto de fios de gravação",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "obtém o composto de fios de gravação",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "baixar desenhos DXF",
    "downloadDXFDrawings": "baixar desenhos DXF",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "baixa desenho DXF",
    "download": "baixar",
    "cutWiresColor": "cor dos fios de corte",
    "engravingWiresColor": "cor dos fios de gravação",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "baixar desenhos STEP",
    "downloadSTEPDrawings": "baixar desenhos STEP",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "baixa desenho STEP",
    "adjustYZ": "ajustar YZ",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "baixar modelo 3D STEP",
    "download3dSTEPModel": "baixar modelo 3D STEP",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "baixa modelo 3D em formato STEP",
    "bitbybit.things.architecture.houses.zenHideout.create": "refúgio zen",
    "architecture": "arquitetura",
    "houses": "casas",
    "zenHideout": "refúgio zen",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "cria refúgio zen",
    "widthFirstWing": "largura da primeira ala",
    "lengthFirstWing": "comprimento da primeira ala",
    "terraceWidth": "largura do terraço",
    "widthSecondWing": "largura da segunda ala",
    "lengthSecondWing": "comprimento da segunda ala",
    "heightWalls": "altura das paredes",
    "roofAngleFirstWing": "ângulo do telhado da primeira ala",
    "roofAngleSecondWing": "ângulo do telhado da segunda ala",
    "roofOffset": "deslocamento do telhado",
    "roofInsideOverhang": "saliência interna do telhado",
    "roofMaxDistAttachmentBeams": "distância máxima das vigas de fixação do telhado",
    "roofAttachmentBeamWidth": "largura da viga de fixação do telhado",
    "roofAttachmentBeamHeight": "altura da viga de fixação do telhado",
    "roofOutsideOverhang": "saliência externa do telhado",
    "columnSize": "tamanho da coluna",
    "ceilingBeamHeight": "altura da viga de teto",
    "ceilingBeamWidth": "largura da viga de teto",
    "nrCeilingBeamsBetweenColumns": "número de vigas de teto entre colunas",
    "distBetweenColumns": "distância entre colunas",
    "floorHeight": "altura do piso",
    "groundLevel": "nível do solo",
    "facadePanelThickness": "espessura do painel de fachada",
    "windowWidthOffset": "deslocamento da largura da janela",
    "windowHeightOffset": "deslocamento da altura da janela",
    "windowFrameThickness": "espessura da moldura da janela",
    "windowGlassFrameThickness": "espessura da moldura de vidro da janela",
    "skinOpacity": "opacidade da pele",
    "bitbybit.things.furniture.chairs.snakeChair.create": "cadeira serpente",
    "furniture": "móveis",
    "chairs": "cadeiras",
    "snakeChair": "cadeira serpente",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "cria modelo de cadeira serpente",
    "sittingHeight": "altura do assento",
    "backRestOffset": "deslocamento do encosto",
    "backRestHeight": "altura do encosto",
    "nrOrnamentPlanks": "número de tábuas ornamentais",
    "ornamentDepth": "profundidade do ornamento",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "obtém a forma composta da cadeira",
    "SnakeChairData<T>": "dados da cadeira serpente t",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "obter forma de fio do assento",
    "getSittingWireShape": "obter forma de fio do assento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "obtém a forma de fio da área de assento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "obter ponto central da área de assento",
    "getSittingAreaCenterPoint": "obter ponto central da área de assento",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "obtém o ponto central da área de assento",
    "get points": "obter pontos",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "cria opções de desenho para a cadeira serpente",
    "bitbybit.things.furniture.tables.elegantTable.create": "mesa elegante",
    "tables": "mesas",
    "elegantTable": "mesa elegante",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "cria modelo de mesa elegante",
    "topThickness": "espessura do tampo",
    "topOffset": "deslocamento do tampo",
    "minFillet": "arredondamento mínimo",
    "radiusLegTop": "raio da perna no topo",
    "radiusLegBottom": "raio da perna na base",
    "nrLegPairs": "número de pares de pernas",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "obtém a forma composta da mesa",
    "ElegantTableData<T>": "dados da mesa elegante t",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "obter formas das pernas",
    "getLegShapes": "obter formas das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "obtém as formas das pernas como lista",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "obter forma da perna por índice",
    "getLegShapeByIndex": "obter forma da perna por índice",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "obtém a forma da perna por índice",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "obter forma do painel superior",
    "getTopPanelShape": "obter forma do painel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "obtém a forma do painel superior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "obter forma de fio do painel superior",
    "getTopPanelWireShape": "obter forma de fio do painel superior",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "obtém a forma de fio do painel superior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "obter forma de fio do painel inferior",
    "getBottomPanelWireShape": "obter forma de fio do painel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "obtém a forma de fio do painel inferior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "obter forma do painel inferior",
    "getBottomPanelShape": "obter forma do painel inferior",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "obtém a forma do painel inferior da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "obter forma composta das pernas",
    "getLegsCompoundShape": "obter forma composta das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "obtém as formas das pernas como forma composta",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "obter ponto central do tampo da mesa",
    "getTableTopCenterPoint": "obter ponto central do tampo da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "obtém o ponto central do tampo",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "obter ponto central da base da mesa",
    "getTableBottomCenterPoint": "obter ponto central da base da mesa",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "obtém o ponto central da base",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "obter pontos inferiores das pernas",
    "getLegBottomPoints": "obter pontos inferiores das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "obtém os pontos inferiores das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obter pontos superiores das pernas",
    "getLegTopPoints": "obter pontos superiores das pernas",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "obtém os pontos superiores das pernas",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "cria opções de desenho para a mesa elegante",
    "topMaterial": "material do tampo",
    "topBaseMaterial": "material da base do tampo",
    "legsMaterial": "material das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "mesa de café boa",
    "goodCoffeeTable": "mesa de café boa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "cria modelo de mesa de café boa",
    "chamfer": "chanfro",
    "topGlassOffset": "deslocamento do vidro superior",
    "glassThickness": "espessura do vidro",
    "glassHolderLength": "comprimento do suporte de vidro",
    "shelfTopOffset": "deslocamento superior da prateleira",
    "shelfThickness": "espessura da prateleira",
    "legWidth": "largura da perna",
    "legDepth": "profundidade da perna",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "obtém a forma composta da mesa",
    "GoodCoffeeTableData<T>": "dados da mesa de café boa t",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "obter formas das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "obtém as formas das pernas como lista",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "obter forma da perna por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "obtém a forma da perna por índice",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "obter forma do painel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "obtém a forma do painel superior da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "obter forma de fio do painel superior",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "obtém a forma de fio do painel superior da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "obter forma do painel de vidro",
    "getGlassPanelShape": "obter forma do painel de vidro",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "obtém a forma do painel de vidro da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "obter forma de fio do painel de vidro",
    "getGlassPanelWireShape": "obter forma de fio do painel de vidro",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "obtém a forma de fio do painel de vidro da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "obter forma da prateleira",
    "getShelfShape": "obter forma da prateleira",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "obtém a forma da prateleira da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "obter forma de fio superior da prateleira",
    "getShelfTopWireShape": "obter forma de fio superior da prateleira",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "obtém a forma de fio superior da prateleira da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "obter forma composta das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "obtém as formas das pernas como forma composta",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "obter ponto central do tampo da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "obtém o ponto central do tampo",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "obter ponto central superior da prateleira da mesa",
    "getTableShelfTopCenterPoint": "obter ponto central superior da prateleira da mesa",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "obtém o ponto central superior da prateleira",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "obter pontos inferiores das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "obtém os pontos inferiores das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obter pontos superiores das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "obtém os pontos superiores das pernas",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "cria opções de desenho para a mesa de café boa",
    "topGlassMaterial": "material do vidro superior",
    "shelfMaterial": "material da prateleira",
    "bitbybit.things.furniture.tables.snakeTable.create": "mesa serpente",
    "snakeTable": "mesa serpente",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "cria modelo de mesa serpente",
    "supportLength": "comprimento do suporte",
    "shelfHeight": "altura da prateleira",
    "glassOffset": "deslocamento do vidro",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "obter forma composta",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "obtém a forma composta da mesa",
    "SnakeTableData<T>": "dados da mesa serpente t",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "obter forma do vidro",
    "getGlassShape": "obter forma do vidro",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "obtém a forma do vidro da mesa",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "obter forma principal",
    "getMainShape": "obter forma principal",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "obtém a forma sólida principal da mesa",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "obter ponto central do tampo",
    "getTopCenterPoint": "obter ponto central do tampo",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "obtém o ponto central do tampo da mesa",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "opções de desenho",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "cria opções de desenho para a mesa serpente",
    "glassMaterial": "material do vidro",
    "bitbybit.things.enums.lodEnum": "enum de nível de detalhe",
    "enums": "enums",
    "lodEnum": "enum de nível de detalhe",
    "bitbybit.things.enums.lodEnum_description": "cria valor de enum de nível de detalhe",
    "bitbybit.jscad.transformSolids": "transformar sólidos",
    "jscad": "jscad",
    "transformSolids": "transformar sólidos",
    "bitbybit.jscad.transformSolids_description": "transforma malhas sólidas jscad com transformações",
    "JSCADEntity[]": "array de entidade jscad",
    "bitbybit.jscad.transformSolid": "transformar sólido",
    "transformSolid": "transformar sólido",
    "bitbybit.jscad.transformSolid_description": "transforma malha sólida jscad com transformações",
    "JSCADEntity": "entidade jscad",
    "bitbybit.jscad.downloadSolidSTL": "baixar sólido STL",
    "downloadSolidSTL": "baixar sólido STL",
    "bitbybit.jscad.downloadSolidSTL_description": "baixa arquivo STL binário a partir de sólido 3D",
    "bitbybit.jscad.downloadSolidsSTL": "baixar sólidos STL",
    "downloadSolidsSTL": "baixar sólidos STL",
    "bitbybit.jscad.downloadSolidsSTL_description": "baixa arquivo STL binário a partir de sólidos 3D",
    "bitbybit.jscad.downloadGeometryDxf": "baixar geometria DXF",
    "downloadGeometryDxf": "baixar geometria DXF",
    "bitbybit.jscad.downloadGeometryDxf_description": "baixa arquivo DXF a partir de geometria jscad",
    "geometry": "geometria",
    "JSCADEntity | JSCADEntity[]": "entidade jscad ou array",
    "bitbybit.jscad.downloadGeometry3MF": "baixar geometria 3MF",
    "downloadGeometry3MF": "baixar geometria 3MF",
    "bitbybit.jscad.downloadGeometry3MF_description": "baixa arquivo 3MF a partir de geometria jscad",
    "bitbybit.jscad.booleans.intersect": "interseccionar",
    "intersect": "interseccionar",
    "bitbybit.jscad.booleans.intersect_description": "intersecciona múltiplos objetos de malha sólida",
    "bitbybit.jscad.booleans.subtract": "subtrair",
    "subtract": "subtrair",
    "bitbybit.jscad.booleans.subtract_description": "subtrai múltiplos objetos de malha sólida",
    "bitbybit.jscad.booleans.union": "união",
    "bitbybit.jscad.booleans.union_description": "une múltiplos objetos de malha sólida",
    "bitbybit.jscad.booleans.intersectTwo": "interseccionar dois",
    "intersectTwo": "interseccionar dois",
    "bitbybit.jscad.booleans.intersectTwo_description": "intersecciona dois objetos de malha sólida",
    "bitbybit.jscad.booleans.subtractTwo": "subtrair dois",
    "subtractTwo": "subtrair dois",
    "bitbybit.jscad.booleans.subtractTwo_description": "subtrai dois objetos de malha sólida",
    "bitbybit.jscad.booleans.unionTwo": "união de dois",
    "unionTwo": "união de dois",
    "bitbybit.jscad.booleans.unionTwo_description": "une dois objetos de malha sólida",
    "bitbybit.jscad.booleans.subtractFrom": "subtrair de",
    "subtractFrom": "subtrair de",
    "bitbybit.jscad.booleans.subtractFrom_description": "subtrai múltiplas malhas de uma malha",
    "bitbybit.jscad.expansions.expand": "expandir",
    "expansions": "expansões",
    "expand": "expandir",
    "bitbybit.jscad.expansions.expand_description": "expande geometrias sólidas",
    "expansion": "expansão",
    "delta": "delta",
    "corners": "cantos",
    "solidCornerTypeEnum": "enum de tipo de canto sólido",
    "bitbybit.jscad.expansions.offset": "deslocamento",
    "bitbybit.jscad.expansions.offset_description": "desloca geometrias 2D",
    "bitbybit.jscad.extrusions.extrudeLinear": "extrusão linear",
    "extrudeLinear": "extrusão linear",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "extruda linearmente geometrias 2D",
    "twistAngle": "ângulo de torção",
    "twistSteps": "passos de torção",
    "bitbybit.jscad.extrusions.extrudeRectangular": "extrusão retangular",
    "extrudeRectangular": "extrusão retangular",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "extruda retangularmente geometrias 2D",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "extrusão retangular de pontos",
    "extrudeRectangularPoints": "extrusão retangular de pontos",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "extruda retangularmente pontos 2D",
    "bitbybit.jscad.extrusions.extrudeRotate": "extrusão rotacionada",
    "extrudeRotate": "extrusão rotacionada",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "rotaciona e extruda pontos 2D",
    "polygon": "polígono",
    "startAngle": "ângulo inicial",
    "bitbybit.jscad.hulls.hullChain": "cadeia de casco",
    "hulls": "cascos",
    "hullChain": "cadeia de casco",
    "bitbybit.jscad.hulls.hullChain_description": "conecta sólidos ou geometrias 2D em ordem",
    "bitbybit.jscad.hulls.hull": "casco",
    "hull": "casco",
    "bitbybit.jscad.hulls.hull_description": "casco convexo conecta sólidos ou geometrias 2D",
    "bitbybit.jscad.path.createFromPoints": "a partir de pontos",
    "createFromPoints": "a partir de pontos",
    "bitbybit.jscad.path.createFromPoints_description": "cria caminho 2D a partir de pontos",
    "Base.Point2[]": "array de ponto base 2",
    "bitbybit.jscad.path.createPathsFromPoints": "caminhos a partir de pontos",
    "createPathsFromPoints": "caminhos a partir de pontos",
    "bitbybit.jscad.path.createPathsFromPoints_description": "cria caminhos 2D a partir de listas de pontos",
    "pointsLists": "listas de pontos",
    "Base.Point3[][] | Base.Point2[][]": "array de ponto base 3 ou 2",
    "bitbybit.jscad.path.createFromPolyline": "a partir de polilinha",
    "createFromPolyline": "a partir de polilinha",
    "bitbybit.jscad.path.createFromPolyline_description": "cria caminho 2D a partir de polilinha",
    "bitbybit.jscad.path.createEmpty": "vazio",
    "createEmpty": "vazio",
    "bitbybit.jscad.path.createEmpty_description": "cria caminho 2D vazio",
    "bitbybit.jscad.path.close": "fechar",
    "close": "fechar",
    "bitbybit.jscad.path.close_description": "fecha caminho 2D aberto",
    "bitbybit.jscad.path.appendPoints": "adicionar pontos",
    "appendPoints": "adicionar pontos",
    "bitbybit.jscad.path.appendPoints_description": "adiciona pontos 2D ao caminho",
    "append": "adicionar",
    "bitbybit.jscad.path.appendPolyline": "adicionar polilinha",
    "appendPolyline": "adicionar polilinha",
    "bitbybit.jscad.path.appendPolyline_description": "adiciona polilinha ao caminho",
    "bitbybit.jscad.path.appendArc": "adicionar arco",
    "appendArc": "adicionar arco",
    "bitbybit.jscad.path.appendArc_description": "adiciona arco ao caminho",
    "xAxisRotation": "rotação no eixo x",
    "clockwise": "sentido horário",
    "large": "grande",
    "bitbybit.jscad.polygon.createFromPoints": "a partir de pontos",
    "bitbybit.jscad.polygon.createFromPoints_description": "cria polígono 2D a partir de pontos",
    "bitbybit.jscad.polygon.createFromPolyline": "a partir de polilinha",
    "bitbybit.jscad.polygon.createFromPolyline_description": "cria polígono 2D a partir de polilinha",
    "bitbybit.jscad.polygon.createFromCurve": "a partir de curva",
    "createFromCurve": "a partir de curva",
    "bitbybit.jscad.polygon.createFromCurve_description": "cria polígono 2D a partir de curva",
    "bitbybit.jscad.polygon.createFromPath": "a partir de caminho",
    "createFromPath": "a partir de caminho",
    "bitbybit.jscad.polygon.createFromPath_description": "cria polígono 2D a partir de caminho",
    "bitbybit.jscad.polygon.circle": "círculo",
    "bitbybit.jscad.polygon.circle_description": "cria círculo polígono 2D",
    "bitbybit.jscad.polygon.ellipse": "elipse",
    "ellipse": "elipse",
    "bitbybit.jscad.polygon.ellipse_description": "cria elipse polígono 2D",
    "bitbybit.jscad.polygon.rectangle": "retângulo",
    "rectangle": "retângulo",
    "bitbybit.jscad.polygon.rectangle_description": "cria retângulo polígono 2D",
    "bitbybit.jscad.polygon.roundedRectangle": "retângulo arredondado",
    "roundedRectangle": "retângulo arredondado",
    "bitbybit.jscad.polygon.roundedRectangle_description": "cria retângulo arredondado 2D",
    "roundRadius": "raio de arredondamento",
    "bitbybit.jscad.polygon.square": "quadrado",
    "square": "quadrado",
    "bitbybit.jscad.polygon.square_description": "cria quadrado polígono 2D",
    "bitbybit.jscad.polygon.star": "estrela",
    "star": "estrela",
    "bitbybit.jscad.polygon.star_description": "cria estrela polígono 2D",
    "vertices": "vértices",
    "bitbybit.jscad.shapes.cube": "cubo",
    "cube": "cubo",
    "bitbybit.jscad.shapes.cube_description": "cria forma de cubo 3D",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "cubos em pontos centrais",
    "cubesOnCenterPoints": "cubos em pontos centrais",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "cria cubos 3D em pontos centrais",
    "primitives on centers": "primitivas em centros",
    "bitbybit.jscad.shapes.cuboid": "cuboide",
    "cuboid": "cuboide",
    "bitbybit.jscad.shapes.cuboid_description": "cria forma de cuboide 3D",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "cuboides em pontos centrais",
    "cuboidsOnCenterPoints": "cuboides em pontos centrais",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "cria cuboides 3D em pontos centrais",
    "bitbybit.jscad.shapes.cylinderElliptic": "cilindro elíptico",
    "cylinderElliptic": "cilindro elíptico",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "cria sólido de cilindro elíptico 3D",
    "startRadius": "raio inicial",
    "endRadius": "raio final",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "cilindros elípticos em pontos centrais",
    "cylinderEllipticOnCenterPoints": "cilindros elípticos em pontos centrais",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "cria cilindros elípticos 3D em pontos centrais",
    "bitbybit.jscad.shapes.cylinder": "cilindro",
    "cylinder": "cilindro",
    "bitbybit.jscad.shapes.cylinder_description": "cria sólido de cilindro 3D",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "cilindros em pontos centrais",
    "cylindersOnCenterPoints": "cilindros em pontos centrais",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "cria cilindros 3D em pontos centrais",
    "bitbybit.jscad.shapes.ellipsoid": "elipsoide",
    "ellipsoid": "elipsoide",
    "bitbybit.jscad.shapes.ellipsoid_description": "cria sólido de elipsoide 3D",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "elipsoides em pontos centrais",
    "ellipsoidsOnCenterPoints": "elipsoides em pontos centrais",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "cria elipsoides 3D em pontos centrais",
    "bitbybit.jscad.shapes.geodesicSphere": "esfera geodésica",
    "geodesicSphere": "esfera geodésica",
    "bitbybit.jscad.shapes.geodesicSphere_description": "cria sólido de esfera geodésica 3D",
    "frequency": "frequência",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "esferas geodésicas em pontos centrais",
    "geodesicSpheresOnCenterPoints": "esferas geodésicas em pontos centrais",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "cria esferas geodésicas 3D em pontos centrais",
    "bitbybit.jscad.shapes.roundedCuboid": "cuboide arredondado",
    "roundedCuboid": "cuboide arredondado",
    "bitbybit.jscad.shapes.roundedCuboid_description": "cria sólido de cuboide arredondado 3D",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "cuboides arredondados em pontos centrais",
    "roundedCuboidsOnCenterPoints": "cuboides arredondados em pontos centrais",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "cria cuboides arredondados 3D em pontos centrais",
    "bitbybit.jscad.shapes.roundedCylinder": "cilindro arredondado",
    "roundedCylinder": "cilindro arredondado",
    "bitbybit.jscad.shapes.roundedCylinder_description": "cria sólido de cilindro arredondado 3D",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "cilindros arredondados em pontos centrais",
    "roundedCylindersOnCenterPoints": "cilindros arredondados em pontos centrais",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "cria cilindros arredondados 3D em pontos centrais",
    "bitbybit.jscad.shapes.sphere": "esfera",
    "sphere": "esfera",
    "bitbybit.jscad.shapes.sphere_description": "cria sólido de esfera 3D",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "esferas em pontos centrais",
    "spheresOnCenterPoints": "esferas em pontos centrais",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "cria esferas 3D em pontos centrais",
    "bitbybit.jscad.shapes.torus": "toro",
    "torus": "toro",
    "bitbybit.jscad.shapes.torus_description": "cria sólido de toro 3D",
    "innerSegments": "segmentos internos",
    "outerSegments": "segmentos externos",
    "innerRotation": "rotação interna",
    "outerRotation": "rotação externa",
    "bitbybit.jscad.shapes.fromPolygonPoints": "a partir de pontos de polígono",
    "fromPolygonPoints": "a partir de pontos de polígono",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "cria forma 3D a partir de pontos de polígono aninhados",
    "polygonPoints": "pontos de polígono",
    "Base.Point3[][]": "array de ponto base 3",
    "bitbybit.jscad.text.cylindricalText": "texto cilíndrico",
    "cylindricalText": "texto cilíndrico",
    "bitbybit.jscad.text.cylindricalText_description": "cria texto com cilindros encadeados por casco",
    "extrusionHeight": "altura de extrusão",
    "extrusionSize": "tamanho de extrusão",
    "jscadTextAlignEnum": "enum de alinhamento de texto jscad",
    "bitbybit.jscad.text.sphericalText": "texto esférico",
    "sphericalText": "texto esférico",
    "bitbybit.jscad.text.sphericalText_description": "cria texto com esferas encadeadas por casco",
    "bitbybit.jscad.text.createVectorText": "texto vetorial",
    "createVectorText": "texto vetorial",
    "bitbybit.jscad.text.createVectorText_description": "cria texto vetorial",
    "bitbybit.jscad.colors.colorize": "colorir",
    "colors": "cores",
    "colorize": "colorir",
    "bitbybit.jscad.colors.colorize_description": "colore geometria jscad",
    "bitbybit.manifold.manifoldToMeshPointer": "manifold para ponteiro de malha",
    "manifold": "manifold",
    "manifoldToMeshPointer": "manifold para ponteiro de malha",
    "bitbybit.manifold.manifoldToMeshPointer_description": "transforma forma manifold em ponteiro de malha",
    "meshing": "malhagem",
    "normalIdx": "índice de normal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "decompor manifold ou seção transversal",
    "decomposeManifoldOrCrossSection": "decompor manifold ou seção transversal",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "decompõe manifold ou seção transversal em malha ou polígonos",
    "decompose": "decompor",
    "manifoldOrCrossSection": "manifold ou seção transversal",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "decompor manifolds ou seções transversais",
    "decomposeManifoldsOrCrossSections": "decompor manifolds ou seções transversais",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "decompõe manifolds ou seções transversais em malhas ou polígonos",
    "manifoldsOrCrossSections": "manifolds ou seções transversais",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "excluir manifold ou seção transversal",
    "deleteManifoldOrCrossSection": "excluir manifold ou seção transversal",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "exclui manifold ou seção transversal da memória",
    "cleanup": "limpeza",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "excluir manifolds ou seções transversais",
    "deleteManifoldsOrCrossSections": "excluir manifolds ou seções transversais",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "exclui manifolds ou seções transversais da memória",
    "bitbybit.manifold.manifold.manifoldToMesh": "manifold para malha",
    "manifoldToMesh": "manifold para malha",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "transforma forma manifold em malha",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "manifolds para malhas",
    "manifoldsToMeshes": "manifolds para malhas",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "transforma formas manifold em malhas",
    "manifolds": "manifolds",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "manifold a partir de malha",
    "manifoldFromMesh": "manifold a partir de malha",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "converte malha em manifold",
    "DecomposedManifoldMeshDto": "dto de malha manifold decomposta",
    "bitbybit.manifold.manifold.shapes.cube": "cubo",
    "bitbybit.manifold.manifold.shapes.cube_description": "cria forma de cubo 3D",
    "bitbybit.manifold.manifold.shapes.sphere": "esfera",
    "bitbybit.manifold.manifold.shapes.sphere_description": "cria forma de esfera 3D",
    "circularSegments": "segmentos circulares",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "tetraedro",
    "tetrahedron": "tetraedro",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "cria forma de tetraedro 3D",
    "bitbybit.manifold.manifold.shapes.cylinder": "cilindro",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "cria forma de cilindro 3D",
    "radiusLow": "raio baixo",
    "radiusHigh": "raio alto",
    "bitbybit.manifold.manifold.booleans.subtract": "subtrair",
    "bitbybit.manifold.manifold.booleans.subtract_description": "subtrai duas formas manifold",
    "a to b": "a para b",
    "manifold1": "manifold 1",
    "manifold2": "manifold 2",
    "bitbybit.manifold.manifold.booleans.add": "adicionar",
    "bitbybit.manifold.manifold.booleans.add_description": "adiciona duas formas manifold",
    "bitbybit.manifold.manifold.booleans.intersect": "interseccionar",
    "bitbybit.manifold.manifold.booleans.intersect_description": "intersecciona duas formas manifold",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "diferença de dois",
    "differenceTwo": "diferença de dois",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "diferença de duas formas manifold",
    "2 manifolds": "2 manifolds",
    "bitbybit.manifold.manifold.booleans.unionTwo": "união de dois",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "união de duas formas manifold",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "interseção de dois",
    "intersectionTwo": "interseção de dois",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "interseção de duas formas manifold",
    "bitbybit.manifold.manifold.booleans.difference": "diferença",
    "bitbybit.manifold.manifold.booleans.difference_description": "diferença de múltiplas formas manifold",
    "bitbybit.manifold.manifold.booleans.union": "união",
    "bitbybit.manifold.manifold.booleans.union_description": "união de múltiplas formas manifold",
    "bitbybit.manifold.manifold.booleans.intersection": "interseção",
    "bitbybit.manifold.manifold.booleans.intersection_description": "interseção de múltiplas formas manifold",
    "bitbybit.manifold.manifold.booleans.split": "dividir",
    "split": "dividir",
    "bitbybit.manifold.manifold.booleans.split_description": "divide manifold por outro manifold",
    "manifoldToSplit": "manifold a dividir",
    "manifoldCutter": "manifold cortador",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "dividir por plano",
    "splitByPlane": "dividir por plano",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "divide manifold por plano",
    "originOffset": "deslocamento da origem",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "dividir por plano em deslocamentos",
    "splitByPlaneOnOffsets": "dividir por plano em deslocamentos",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "divide manifold por plano em deslocamentos",
    "originOffsets": "deslocamentos da origem",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "aparar por plano",
    "trimByPlane": "aparar por plano",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "apara manifold por plano",
    "trim": "aparar",
    "bitbybit.manifold.manifold.operations.hull": "casco",
    "bitbybit.manifold.manifold.operations.hull_description": "computa casco convexo da forma manifold",
    "bitbybit.manifold.manifold.operations.hullPoints": "casco de pontos",
    "hullPoints": "casco de pontos",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "computa casco de pontos ou manifolds",
    "bitbybit.manifold.manifold.operations.slice": "fatiar",
    "bitbybit.manifold.manifold.operations.slice_description": "retorna seção transversal do objeto na altura",
    "cross sections": "seções transversais",
    "bitbybit.manifold.manifold.operations.project": "projetar",
    "bitbybit.manifold.manifold.operations.project_description": "cria projeção no plano xy a partir do contorno da forma",
    "bitbybit.manifold.manifold.operations.setTolerance": "definir tolerância",
    "setTolerance": "definir tolerância",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "define valor de tolerância para manifold",
    "basic": "básico",
    "bitbybit.manifold.manifold.operations.reserveIds": "reservar ids",
    "reserveIds": "reservar ids",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "reserva ids sequenciais de malha",
    "count": "contagem",
    "bitbybit.manifold.manifold.operations.asOriginal": "como original",
    "asOriginal": "como original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "redefine ids do manifold como original",
    "bitbybit.manifold.manifold.operations.compose": "compor",
    "compose": "compor",
    "bitbybit.manifold.manifold.operations.compose_description": "constrói manifold a partir de lista de manifolds",
    "composition": "composição",
    "bitbybit.manifold.manifold.operations.decompose": "decompor",
    "bitbybit.manifold.manifold.operations.decompose_description": "decompõe manifold em partes desconectadas",
    "bitbybit.manifold.manifold.operations.calculateNormals": "calcular normais",
    "calculateNormals": "calcular normais",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "calcula normais dos vértices",
    "adjustments": "ajustes",
    "minSharpAngle": "ângulo agudo mínimo",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "calcular curvatura",
    "calculateCurvature": "calcular curvatura",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "calcula curvatura para vértices",
    "gaussianIdx": "índice gaussiano",
    "meanIdx": "índice médio",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "refinar para tolerância",
    "refineToTolerance": "refinar para tolerância",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "refina malha para tolerância",
    "bitbybit.manifold.manifold.operations.refineToLength": "refinar para comprimento",
    "refineToLength": "refinar para comprimento",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "refina malha para comprimento",
    "bitbybit.manifold.manifold.operations.refine": "refinar",
    "refine": "refinar",
    "bitbybit.manifold.manifold.operations.refine_description": "refina malha dividindo bordas",
    "bitbybit.manifold.manifold.operations.smoothOut": "suavizar",
    "smoothOut": "suavizar",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "suaviza manifold com vetores tangentes",
    "minSmoothness": "suavidade mínima",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "suavizar por normais",
    "smoothByNormals": "suavizar por normais",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "suaviza manifold usando normais dos vértices",
    "bitbybit.manifold.manifold.transforms.scale3D": "escalar 3D",
    "scale3D": "escalar 3D",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "escala manifold com vetor 3D",
    "bitbybit.manifold.manifold.transforms.scale": "escalar",
    "bitbybit.manifold.manifold.transforms.scale_description": "escala manifold com fator único",
    "bitbybit.manifold.manifold.transforms.mirror": "espelhar",
    "bitbybit.manifold.manifold.transforms.mirror_description": "espelha manifold sobre plano",
    "bitbybit.manifold.manifold.transforms.translate": "transladar",
    "bitbybit.manifold.manifold.transforms.translate_description": "translada manifold ao longo de vetor",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "transladar por vetores",
    "translateByVectors": "transladar por vetores",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "translada manifold por múltiplos vetores",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "transladar xyz",
    "translateXYZ": "transladar xyz",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "translada manifold ao longo de x, y, z",
    "bitbybit.manifold.manifold.transforms.rotate": "rotacionar",
    "bitbybit.manifold.manifold.transforms.rotate_description": "rotaciona manifold com ângulos de Euler",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "rotacionar xyz",
    "rotateXYZ": "rotacionar xyz",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "rotaciona manifold ao longo de ângulos de Euler x, y, z",
    "bitbybit.manifold.manifold.transforms.transform": "transformar",
    "bitbybit.manifold.manifold.transforms.transform_description": "transforma manifold com matriz 4x4",
    "matrix": "matriz",
    "Base.TransformMatrix": "matriz de transformação base",
    "bitbybit.manifold.manifold.transforms.transforms": "transformações",
    "bitbybit.manifold.manifold.transforms.transforms_description": "transforma manifold com múltiplas matrizes 4x4",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "área de superfície",
    "evaluate": "avaliar",
    "surfaceArea": "área de superfície",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "obtém a área de superfície do manifold",
    "bitbybit.manifold.manifold.evaluate.volume": "volume",
    "volume": "volume",
    "bitbybit.manifold.manifold.evaluate.volume_description": "obtém o volume do manifold",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "está vazio",
    "isEmpty": "está vazio",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "verifica se o manifold tem triângulos",
    "bitbybit.manifold.manifold.evaluate.numVert": "número de vértices",
    "numVert": "número de vértices",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "obtém o número de vértices no manifold",
    "bitbybit.manifold.manifold.evaluate.numTri": "número de triângulos",
    "numTri": "número de triângulos",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "obtém o número de triângulos no manifold",
    "bitbybit.manifold.manifold.evaluate.numEdge": "número de bordas",
    "numEdge": "número de bordas",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "obtém o número de bordas no manifold",
    "bitbybit.manifold.manifold.evaluate.numProp": "número de propriedades",
    "numProp": "número de propriedades",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "obtém o número de propriedades no manifold",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "número de propriedades de vértices",
    "numPropVert": "número de propriedades de vértices",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "obtém o número de vértices de propriedades no manifold",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "caixa delimitadora",
    "boundingBox": "caixa delimitadora",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "obtém a caixa delimitadora alinhada aos eixos do manifold",
    "bitbybit.manifold.manifold.evaluate.tolerance": "tolerância",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "obtém a tolerância dos vértices do manifold",
    "bitbybit.manifold.manifold.evaluate.genus": "gênero",
    "genus": "gênero",
    "bitbybit.manifold.manifold.evaluate.genus_description": "obtém o gênero do manifold",
    "bitbybit.manifold.manifold.evaluate.minGap": "lacuna mínima",
    "minGap": "lacuna mínima",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "obtém a lacuna mínima entre dois manifolds",
    "searchLength": "comprimento de busca",
    "bitbybit.manifold.manifold.evaluate.originalID": "id original",
    "originalID": "id original",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "obtém o id original do manifold",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "seção transversal para polígonos",
    "crossSection": "seção transversal",
    "crossSectionToPolygons": "seção transversal para polígonos",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "transforma seção transversal em polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "seções transversais para polígonos",
    "crossSectionsToPolygons": "seções transversais para polígonos",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "transforma seções transversais em polígonos",
    "crossSections": "seções transversais",
    "bitbybit.manifold.crossSection.shapes.create": "criar",
    "bitbybit.manifold.crossSection.shapes.create_description": "cria seção transversal 2D a partir de contornos",
    "Base.Vector2[][]": "array de vetor base 2",
    "fillRule": "regra de preenchimento",
    "fillRuleEnum": "enum de regra de preenchimento",
    "bitbybit.manifold.crossSection.shapes.square": "quadrado",
    "bitbybit.manifold.crossSection.shapes.square_description": "cria seção transversal quadrada 2D",
    "bitbybit.manifold.crossSection.shapes.circle": "círculo",
    "bitbybit.manifold.crossSection.shapes.circle_description": "cria seção transversal circular 2D",
    "bitbybit.manifold.crossSection.shapes.rectangle": "retângulo",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "cria seção transversal retangular 2D",
    "bitbybit.manifold.crossSection.operations.hull": "casco",
    "bitbybit.manifold.crossSection.operations.hull_description": "computa casco convexo para seção transversal",
    "bitbybit.manifold.crossSection.operations.extrude": "extrudar",
    "bitbybit.manifold.crossSection.operations.extrude_description": "extruda seção transversal para forma 3D",
    "nDivisions": "número de divisões",
    "twistDegrees": "graus de torção",
    "scaleTopX": "escala superior x",
    "scaleTopY": "escala superior y",
    "bitbybit.manifold.crossSection.operations.revolve": "revolver",
    "bitbybit.manifold.crossSection.operations.revolve_description": "revolve seção transversal para forma 3D",
    "revolveDegrees": "graus de revolução",
    "matchProfile": "corresponder perfil",
    "bitbybit.manifold.crossSection.operations.offset": "deslocamento",
    "bitbybit.manifold.crossSection.operations.offset_description": "desloca seção transversal com delta",
    "manifoldJoinTypeEnum": "enum de tipo de junção manifold",
    "miterLimit": "limite de esquadria",
    "bitbybit.manifold.crossSection.operations.simplify": "simplificar",
    "simplify": "simplificar",
    "bitbybit.manifold.crossSection.operations.simplify_description": "simplifica contornos da seção transversal",
    "epsilon": "épsilon",
    "bitbybit.manifold.crossSection.operations.compose": "compor",
    "bitbybit.manifold.crossSection.operations.compose_description": "compoõe múltiplas seções transversais em uma",
    "bitbybit.manifold.crossSection.operations.decompose": "decompor",
    "bitbybit.manifold.crossSection.operations.decompose_description": "decompõe seções transversais em partes",
    "bitbybit.manifold.crossSection.booleans.subtract": "subtrair",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "subtrai duas seções transversais",
    "crossSection1": "seção transversal 1",
    "crossSection2": "seção transversal 2",
    "bitbybit.manifold.crossSection.booleans.add": "adicionar",
    "bitbybit.manifold.crossSection.booleans.add_description": "adiciona duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.intersect": "interseccionar",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "intersecciona duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "diferença de dois",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "diferença de duas seções transversais",
    "2 cross sections": "2 seções transversais",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "união de dois",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "união de duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "interseção de dois",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "interseção de duas seções transversais",
    "bitbybit.manifold.crossSection.booleans.difference": "diferença",
    "bitbybit.manifold.crossSection.booleans.difference_description": "diferença de múltiplas seções transversais",
    "bitbybit.manifold.crossSection.booleans.union": "união",
    "bitbybit.manifold.crossSection.booleans.union_description": "união de múltiplas seções transversais",
    "bitbybit.manifold.crossSection.booleans.intersection": "interseção",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "interseção de múltiplas seções transversais",
    "bitbybit.manifold.crossSection.transforms.scale2D": "escalar 2D",
    "scale2D": "escalar 2D",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "escala seção transversal com vetor 2D",
    "bitbybit.manifold.crossSection.transforms.scale": "escalar",
    "bitbybit.manifold.crossSection.transforms.scale_description": "escala seção transversal com fator único",
    "bitbybit.manifold.crossSection.transforms.mirror": "espelhar",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "espelha seção transversal sobre plano",
    "bitbybit.manifold.crossSection.transforms.translate": "transladar",
    "bitbybit.manifold.crossSection.transforms.translate_description": "translada seção transversal ao longo de vetor",
    "bitbybit.manifold.crossSection.transforms.translateXY": "transladar xy",
    "translateXY": "transladar xy",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "translada seção transversal ao longo de x, y",
    "bitbybit.manifold.crossSection.transforms.rotate": "rotacionar",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "rotaciona seção transversal com graus",
    "degrees": "graus",
    "bitbybit.manifold.crossSection.transforms.transform": "transformar",
    "bitbybit.manifold.crossSection.transforms.transform_description": "transforma seção transversal com matriz 3x3",
    "Base.TransformMatrix3x3": "matriz de transformação base 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "área",
    "area": "área",
    "bitbybit.manifold.crossSection.evaluate.area_description": "obtém a área da seção transversal",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "está vazio",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "verifica se a seção transversal está vazia",
    "bitbybit.manifold.crossSection.evaluate.numVert": "número de vértices",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "obtém o número de vértices na seção transversal",
    "bitbybit.manifold.crossSection.evaluate.numContour": "número de contornos",
    "numContour": "número de contornos",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "obtém o número de contornos na seção transversal",
    "bitbybit.manifold.crossSection.evaluate.bounds": "limites",
    "bounds": "limites",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "obtém os limites do contorno como retângulo",
    "bitbybit.manifold.mesh.operations.merge": "mesclar",
    "merge": "mesclar",
    "bitbybit.manifold.mesh.operations.merge_description": "mescla vértices para sólido manifold",
    "bitbybit.manifold.mesh.evaluate.position": "posição",
    "bitbybit.manifold.mesh.evaluate.position_description": "obtém a posição no índice de vértice da malha",
    "vertexIndex": "índice de vértice",
    "bitbybit.manifold.mesh.evaluate.verts": "vértices",
    "verts": "vértices",
    "bitbybit.manifold.mesh.evaluate.verts_description": "obtém os três índices de vértices de um triângulo",
    "triangleIndex": "índice de triângulo",
    "bitbybit.manifold.mesh.evaluate.tangent": "tangente",
    "tangent": "tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "obtém o vetor tangente da meia-borda",
    "halfEdgeIndex": "índice de meia-borda",
    "bitbybit.manifold.mesh.evaluate.extras": "extras",
    "extras": "extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "obtém propriedades extras do vértice",
    "bitbybit.manifold.mesh.evaluate.transform": "transformar",
    "bitbybit.manifold.mesh.evaluate.transform_description": "obtém a matriz de transformação 4x4 da malha",
    "bitbybit.manifold.mesh.evaluate.numProp": "número de propriedades",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "obtém o número de propriedades por vértice",
    "bitbybit.manifold.mesh.evaluate.numVert": "número de vértices",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "obtém o número de vértices de propriedades",
    "bitbybit.manifold.mesh.evaluate.numTri": "número de triângulos",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "obtém o número de triângulos na malha",
    "bitbybit.manifold.mesh.evaluate.numRun": "número de execuções",
    "numRun": "número de execuções",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "obtém o número de execuções de triângulos",
    "bitbybit.logic.boolean": "booleano",
    "logic": "lógica",
    "bitbybit.logic.boolean_description": "cria um valor booleano",
    "bitbybit.logic.randomBooleans": "booleanos aleatórios",
    "randomBooleans": "booleanos aleatórios",
    "bitbybit.logic.randomBooleans_description": "cria uma lista de booleanos aleatórios",
    "trueThreshold": "limiar de verdadeiro",
    "bitbybit.logic.twoThresholdRandomGradient": "gradiente aleatório com dois limiares",
    "twoThresholdRandomGradient": "gradiente aleatório com dois limiares",
    "bitbybit.logic.twoThresholdRandomGradient_description": "cria uma lista de booleanos aleatórios com limiares",
    "numbers": "números",
    "thresholdTotalTrue": "limiar total de verdadeiro",
    "thresholdTotalFalse": "limiar total de falso",
    "nrLevels": "número de níveis",
    "bitbybit.logic.thresholdBooleanList": "lista booleana com limiar",
    "thresholdBooleanList": "lista booleana com limiar",
    "bitbybit.logic.thresholdBooleanList_description": "cria uma lista booleana com limiar",
    "threshold": "limiar",
    "bitbybit.logic.thresholdGapsBooleanList": "lista booleana com lacunas de limiar",
    "thresholdGapsBooleanList": "lista booleana com lacunas de limiar",
    "bitbybit.logic.thresholdGapsBooleanList_description": "cria uma lista booleana com limiares de lacunas",
    "gapThresholds": "limiares de lacunas",
    "Base.Vector2[]": "array de vetor base 2",
    "bitbybit.logic.not": "não",
    "not": "não",
    "bitbybit.logic.not_description": "aplica o operador não em um booleano",
    "bitbybit.logic.notList": "lista não",
    "notList": "lista não",
    "bitbybit.logic.notList_description": "aplica o operador não em uma lista booleana",
    "bitbybit.logic.compare": "comparar",
    "compare": "comparar",
    "bitbybit.logic.compare_description": "compara dois valores",
    "operator": "operador",
    "BooleanOperatorsEnum": "enum de operadores booleanos",
    "bitbybit.logic.valueGate": "portão de valor",
    "valueGate": "portão de valor",
    "bitbybit.logic.valueGate_description": "transmite valor se o booleano for verdadeiro",
    "bitbybit.logic.firstDefinedValueGate": "primeiro portão de valor definido",
    "firstDefinedValueGate": "primeiro portão de valor definido",
    "bitbybit.logic.firstDefinedValueGate_description": "retorna o primeiro valor definido",
    "value1": "valor 1",
    "value2": "valor 2",
    "bitbybit.math.number": "número",
    "math": "matemática",
    "bitbybit.math.number_description": "cria um número",
    "bitbybit.math.twoNrOperation": "operação com dois números",
    "twoNrOperation": "operação com dois números",
    "bitbybit.math.twoNrOperation_description": "realiza operações matemáticas básicas",
    "operation": "operação",
    "mathTwoNrOperatorEnum": "enum de operador matemático com dois números",
    "bitbybit.math.modulus": "módulo",
    "modulus": "módulo",
    "bitbybit.math.modulus_description": "realiza operação de módulo",
    "bitbybit.math.roundToDecimals": "arredondar para decimais",
    "roundToDecimals": "arredondar para decimais",
    "bitbybit.math.roundToDecimals_description": "arredonda para decimais",
    "decimalPlaces": "casas decimais",
    "bitbybit.math.oneNrOperation": "operação com um número",
    "oneNrOperation": "operação com um número",
    "bitbybit.math.oneNrOperation_description": "realiza matemática em um número",
    "mathOneNrOperatorEnum": "enum de operador matemático com um número",
    "bitbybit.math.remap": "remapear",
    "remap": "remapear",
    "bitbybit.math.remap_description": "remapeia um número entre intervalos",
    "fromLow": "de baixo",
    "fromHigh": "de alto",
    "toLow": "para baixo",
    "toHigh": "para alto",
    "bitbybit.math.random": "aleatório",
    "random": "aleatório",
    "bitbybit.math.random_description": "cria um número aleatório de 0 a 1",
    "generate": "gerar",
    "bitbybit.math.randomNumber": "número aleatório",
    "randomNumber": "número aleatório",
    "bitbybit.math.randomNumber_description": "cria um número aleatório em um intervalo",
    "low": "baixo",
    "high": "alto",
    "bitbybit.math.randomNumbers": "números aleatórios",
    "randomNumbers": "números aleatórios",
    "bitbybit.math.randomNumbers_description": "cria números aleatórios em um intervalo",
    "bitbybit.math.pi": "pi",
    "pi": "pi",
    "bitbybit.math.pi_description": "cria o número pi",
    "bitbybit.math.toFixed": "para fixo",
    "toFixed": "para fixo",
    "bitbybit.math.toFixed_description": "arredonda número para decimais",
    "bitbybit.math.add": "somar",
    "bitbybit.math.add_description": "soma dois números",
    "basics": "básicos",
    "bitbybit.math.subtract": "subtrair",
    "bitbybit.math.subtract_description": "subtrai dois números",
    "bitbybit.math.multiply": "multiplicar",
    "bitbybit.math.multiply_description": "multiplica dois números",
    "bitbybit.math.divide": "dividir",
    "divide": "dividir",
    "bitbybit.math.divide_description": "divide dois números",
    "bitbybit.math.power": "potência",
    "power": "potência",
    "bitbybit.math.power_description": "eleva um número à potência",
    "bitbybit.math.sqrt": "raiz quadrada",
    "sqrt": "raiz quadrada",
    "bitbybit.math.sqrt_description": "obtém a raiz quadrada",
    "bitbybit.math.abs": "absoluto",
    "abs": "absoluto",
    "bitbybit.math.abs_description": "obtém o valor absoluto",
    "bitbybit.math.round": "arredondar",
    "round": "arredondar",
    "bitbybit.math.round_description": "arredonda um número",
    "bitbybit.math.floor": "piso",
    "floor": "piso",
    "bitbybit.math.floor_description": "arredonda um número para baixo",
    "bitbybit.math.ceil": "teto",
    "ceil": "teto",
    "bitbybit.math.ceil_description": "arredonda um número para cima",
    "bitbybit.math.negate": "negar",
    "negate": "negar",
    "bitbybit.math.negate_description": "nega um número",
    "bitbybit.math.ln": "ln",
    "ln": "ln",
    "bitbybit.math.ln_description": "obtém o logaritmo natural",
    "bitbybit.math.log10": "log10",
    "log10": "log10",
    "bitbybit.math.log10_description": "obtém o logaritmo base 10",
    "bitbybit.math.tenPow": "potência de dez",
    "tenPow": "potência de dez",
    "bitbybit.math.tenPow_description": "eleva 10 à potência",
    "bitbybit.math.sin": "seno",
    "sin": "seno",
    "bitbybit.math.sin_description": "obtém o seno",
    "bitbybit.math.cos": "cosseno",
    "cos": "cosseno",
    "bitbybit.math.cos_description": "obtém o cosseno",
    "bitbybit.math.tan": "tangente",
    "tan": "tangente",
    "bitbybit.math.tan_description": "obtém a tangente",
    "bitbybit.math.asin": "arcoseno",
    "asin": "arcoseno",
    "bitbybit.math.asin_description": "obtém o arcoseno",
    "bitbybit.math.acos": "arcocosseno",
    "acos": "arcocosseno",
    "bitbybit.math.acos_description": "obtém o arcocosseno",
    "bitbybit.math.atan": "arcotangente",
    "atan": "arcotangente",
    "bitbybit.math.atan_description": "obtém a arcotangente",
    "bitbybit.math.exp": "exponencial",
    "exp": "exponencial",
    "bitbybit.math.exp_description": "obtém o exponencial natural",
    "bitbybit.math.degToRad": "graus para radianos",
    "degToRad": "graus para radianos",
    "bitbybit.math.degToRad_description": "converte graus para radianos",
    "bitbybit.math.radToDeg": "radianos para graus",
    "radToDeg": "radianos para graus",
    "bitbybit.math.radToDeg_description": "converte radianos para graus",
    "bitbybit.math.ease": "suavizar",
    "bitbybit.math.ease_description": "suaviza número com intervalo",
    "easeEnum": "enum de suavização",
    "bitbybit.lists.getItem": "obter item",
    "lists": "listas",
    "getItem": "obter item",
    "bitbybit.lists.getItem_description": "obtém item da lista por índice",
    "list": "lista",
    "bitbybit.lists.randomGetThreshold": "obter aleatoriamente com limiar",
    "randomGetThreshold": "obter aleatoriamente com limiar",
    "bitbybit.lists.randomGetThreshold_description": "obtém itens aleatoriamente com limiar",
    "bitbybit.lists.getSubList": "obter sublista",
    "getSubList": "obter sublista",
    "bitbybit.lists.getSubList_description": "obtém sublista entre índices",
    "indexStart": "índice inicial",
    "indexEnd": "índice final",
    "bitbybit.lists.getNthItem": "obter enésimo item",
    "getNthItem": "obter enésimo item",
    "bitbybit.lists.getNthItem_description": "obtém o enésimo item da lista",
    "nth": "enésimo",
    "bitbybit.lists.getByPattern": "obter por padrão",
    "getByPattern": "obter por padrão",
    "bitbybit.lists.getByPattern_description": "obtém elementos por padrão",
    "pattern": "padrão",
    "bitbybit.lists.mergeElementsOfLists": "mesclar elementos de listas",
    "mergeElementsOfLists": "mesclar elementos de listas",
    "bitbybit.lists.mergeElementsOfLists_description": "mescla elementos de listas em um nível",
    "level": "nível",
    "bitbybit.lists.getLongestListLength": "obter comprimento da lista mais longa",
    "getLongestListLength": "obter comprimento da lista mais longa",
    "bitbybit.lists.getLongestListLength_description": "obtém o comprimento da lista mais longa",
    "bitbybit.lists.reverse": "inverter",
    "bitbybit.lists.reverse_description": "inverte a lista",
    "bitbybit.lists.flipLists": "inverter listas",
    "flipLists": "inverter listas",
    "bitbybit.lists.flipLists_description": "inverte listas 2D",
    "bitbybit.lists.groupNth": "agrupar enésimo",
    "groupNth": "agrupar enésimo",
    "bitbybit.lists.groupNth_description": "agrupa a lista em n elementos",
    "nrElements": "número de elementos",
    "keepRemainder": "manter resto",
    "bitbybit.lists.getListDepth": "obter profundidade da lista",
    "getListDepth": "obter profundidade da lista",
    "bitbybit.lists.getListDepth_description": "obtém a profundidade da lista",
    "bitbybit.lists.listLength": "comprimento da lista",
    "listLength": "comprimento da lista",
    "bitbybit.lists.listLength_description": "obtém o comprimento da lista",
    "bitbybit.lists.addItemAtIndex": "adicionar item no índice",
    "addItemAtIndex": "adicionar item no índice",
    "bitbybit.lists.addItemAtIndex_description": "adiciona item à lista no índice",
    "item": "item",
    "bitbybit.lists.addItemAtIndexes": "adicionar item nos índices",
    "addItemAtIndexes": "adicionar item nos índices",
    "bitbybit.lists.addItemAtIndexes_description": "adiciona item à lista nos índices",
    "bitbybit.lists.addItemsAtIndexes": "adicionar itens nos índices",
    "addItemsAtIndexes": "adicionar itens nos índices",
    "bitbybit.lists.addItemsAtIndexes_description": "adiciona itens à lista nos índices",
    "items": "itens",
    "bitbybit.lists.removeItemAtIndex": "remover item no índice",
    "removeItemAtIndex": "remover item no índice",
    "bitbybit.lists.removeItemAtIndex_description": "remove item da lista no índice",
    "bitbybit.lists.removeItemsAtIndexes": "remover itens nos índices",
    "removeItemsAtIndexes": "remover itens nos índices",
    "bitbybit.lists.removeItemsAtIndexes_description": "remove itens da lista nos índices",
    "bitbybit.lists.removeAllItems": "remover todos os itens",
    "removeAllItems": "remover todos os itens",
    "bitbybit.lists.removeAllItems_description": "remove todos os itens da lista",
    "bitbybit.lists.removeNthItem": "remover enésimo item",
    "removeNthItem": "remover enésimo item",
    "bitbybit.lists.removeNthItem_description": "remove o enésimo item da lista",
    "bitbybit.lists.randomRemoveThreshold": "remover aleatoriamente com limiar",
    "randomRemoveThreshold": "remover aleatoriamente com limiar",
    "bitbybit.lists.randomRemoveThreshold_description": "remove itens aleatoriamente com limiar",
    "bitbybit.lists.removeDuplicateNumbers": "remover números duplicados",
    "removeDuplicateNumbers": "remover números duplicados",
    "bitbybit.lists.removeDuplicateNumbers_description": "remove números duplicados da lista",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "remover números duplicados com tolerância",
    "removeDuplicateNumbersTolerance": "remover números duplicados com tolerância",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "remove números duplicados com tolerância",
    "bitbybit.lists.addItem": "adicionar item",
    "addItem": "adicionar item",
    "bitbybit.lists.addItem_description": "adiciona item ao final da lista",
    "bitbybit.lists.prependItem": "inserir item no início",
    "prependItem": "inserir item no início",
    "bitbybit.lists.prependItem_description": "adiciona item ao início da lista",
    "bitbybit.lists.addItemFirstLast": "adicionar item no início ou fim",
    "addItemFirstLast": "adicionar item no início ou fim",
    "bitbybit.lists.addItemFirstLast_description": "adiciona item ao início ou fim da lista",
    "firstLastEnum": "enum de primeiro ou último",
    "bitbybit.lists.createEmptyList": "lista vazia",
    "createEmptyList": "lista vazia",
    "bitbybit.lists.createEmptyList_description": "cria uma lista vazia",
    "bitbybit.lists.repeat": "repetir",
    "repeat": "repetir",
    "bitbybit.lists.repeat_description": "repete item em uma nova lista",
    "times": "vezes",
    "bitbybit.lists.repeatInPattern": "repetir em padrão",
    "repeatInPattern": "repetir em padrão",
    "bitbybit.lists.repeatInPattern_description": "repete itens da lista até o limite de comprimento",
    "lengthLimit": "limite de comprimento",
    "bitbybit.lists.sortNumber": "ordenar número",
    "sortNumber": "ordenar número",
    "bitbybit.lists.sortNumber_description": "ordena lista de números",
    "sorting": "ordenação",
    "orderAsc": "ordem ascendente",
    "bitbybit.lists.sortTexts": "ordenar textos",
    "sortTexts": "ordenar textos",
    "bitbybit.lists.sortTexts_description": "ordena lista de textos alfabeticamente",
    "bitbybit.lists.sortByPropValue": "ordenar por valor de propriedade",
    "sortByPropValue": "ordenar por valor de propriedade",
    "bitbybit.lists.sortByPropValue_description": "ordena por propriedade numérica JSON",
    "property": "propriedade",
    "bitbybit.color.hexColor": "cor hexadecimal",
    "hexColor": "cor hexadecimal",
    "bitbybit.color.hexColor_description": "cria uma cor hexadecimal",
    "bitbybit.color.hexToRgb": "hexadecimal para RGB",
    "hexToRgb": "hexadecimal para RGB",
    "bitbybit.color.hexToRgb_description": "cria RGB a partir de hexadecimal",
    "convert": "converter",
    "bitbybit.color.rgbToHex": "RGB para hexadecimal",
    "rgbToHex": "RGB para hexadecimal",
    "bitbybit.color.rgbToHex_description": "cria hexadecimal a partir de RGB",
    "r": "r",
    "g": "g",
    "b": "b",
    "bitbybit.color.rgbObjToHex": "objeto RGB para hexadecimal",
    "rgbObjToHex": "objeto RGB para hexadecimal",
    "bitbybit.color.rgbObjToHex_description": "cria hexadecimal a partir de objeto RGB",
    "rgb": "RGB",
    "Base.ColorRGB": "cor base RGB",
    "bitbybit.color.hexToRgbMapped": "hexadecimal para RGB mapeado",
    "hexToRgbMapped": "hexadecimal para RGB mapeado",
    "bitbybit.color.hexToRgbMapped_description": "cria RGB a partir de hexadecimal com mapeamento de intervalo",
    "bitbybit.color.getRedParam": "obter parâmetro vermelho",
    "getRedParam": "obter parâmetro vermelho",
    "bitbybit.color.getRedParam_description": "obtém o parâmetro vermelho",
    "hex to": "hexadecimal para",
    "bitbybit.color.getGreenParam": "obter parâmetro verde",
    "getGreenParam": "obter parâmetro verde",
    "bitbybit.color.getGreenParam_description": "obtém o parâmetro verde",
    "bitbybit.color.getBlueParam": "obter parâmetro azul",
    "getBlueParam": "obter parâmetro azul",
    "bitbybit.color.getBlueParam_description": "obtém o parâmetro azul",
    "bitbybit.color.rgbToRed": "RGB para vermelho",
    "rgbToRed": "RGB para vermelho",
    "bitbybit.color.rgbToRed_description": "obtém vermelho do RGB",
    "rgb to": "RGB para",
    "bitbybit.color.rgbToGreen": "RGB para verde",
    "rgbToGreen": "RGB para verde",
    "bitbybit.color.rgbToGreen_description": "obtém verde do RGB",
    "bitbybit.color.rgbToBlue": "RGB para azul",
    "rgbToBlue": "RGB para azul",
    "bitbybit.color.rgbToBlue_description": "obtém azul do RGB",
    "bitbybit.color.invert": "inverter",
    "invert": "inverter",
    "bitbybit.color.invert_description": "inverte a cor",
    "blackAndWhite": "preto e branco",
    "bitbybit.text.create": "criar",
    "bitbybit.text.create_description": "cria texto",
    "bitbybit.text.split": "dividir",
    "bitbybit.text.split_description": "divide texto por separador",
    "separator": "separador",
    "bitbybit.text.replaceAll": "substituir tudo",
    "replaceAll": "substituir tudo",
    "bitbybit.text.replaceAll_description": "substitui todas as ocorrências no texto",
    "search": "buscar",
    "replaceWith": "substituir por",
    "bitbybit.text.join": "unir",
    "join": "unir",
    "bitbybit.text.join_description": "une itens em texto com separador",
    "string[]": "array de strings",
    "bitbybit.text.toString": "para string",
    "toString": "para string",
    "bitbybit.text.toString_description": "converte item para texto",
    "bitbybit.text.toStringEach": "para string cada",
    "toStringEach": "para string cada",
    "bitbybit.text.toStringEach_description": "converte cada item da lista para texto",
    "bitbybit.text.format": "formatar",
    "format": "formatar",
    "bitbybit.text.format_description": "formata texto com valores",
    "values": "valores",
    "bitbybit.text.vectorChar": "caractere vetorial",
    "vectorChar": "caractere vetorial",
    "bitbybit.text.vectorChar_description": "Cria segmentos vetoriais para um caractere e inclui informações de largura e altura.",
    "char": "caractere",
    "bitbybit.text.vectorText": "texto vetorial",
    "vectorText": "texto vetorial",
    "bitbybit.text.vectorText_description": "Cria linhas de texto vetoriais para um determinado texto e inclui informações de largura e altura.",
    "bitbybit.dates.toDateString": "para string de data",
    "dates": "datas",
    "toDateString": "para string de data",
    "bitbybit.dates.toDateString_description": "retorna uma data como valor de string",
    "date": "data",
    "Date": "data",
    "bitbybit.dates.toISOString": "para string ISO",
    "toISOString": "para string ISO",
    "bitbybit.dates.toISOString_description": "retorna uma data como valor de string no formato ISO",
    "bitbybit.dates.toJSON": "para JSON",
    "toJSON": "para JSON",
    "bitbybit.dates.toJSON_description": "retorna uma data como valor de string no formato JSON",
    "bitbybit.dates.toString": "para string",
    "bitbybit.dates.toString_description": "retorna uma representação em string de uma data; o formato depende do local",
    "bitbybit.dates.toTimeString": "para string de tempo",
    "toTimeString": "para string de tempo",
    "bitbybit.dates.toTimeString_description": "retorna um tempo como valor de string",
    "bitbybit.dates.toUTCString": "para string UTC",
    "toUTCString": "para string UTC",
    "bitbybit.dates.toUTCString_description": "retorna uma data convertida para string usando Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.now": "agora",
    "now": "agora",
    "bitbybit.dates.now_description": "retorna a data e hora atuais",
    "bitbybit.dates.createDate": "criar data",
    "createDate": "criar data",
    "bitbybit.dates.createDate_description": "cria um novo objeto de data usando os parâmetros fornecidos",
    "year": "ano",
    "month": "mês",
    "day": "dia",
    "hours": "horas",
    "minutes": "minutos",
    "seconds": "segundos",
    "milliseconds": "milissegundos",
    "bitbybit.dates.createDateUTC": "criar data UTC",
    "createDateUTC": "criar data UTC",
    "bitbybit.dates.createDateUTC_description": "retorna o número de milissegundos entre meia-noite de 1º de janeiro de 1970, Tempo Universal Coordenado (UTC) (ou GMT), e a data especificada",
    "bitbybit.dates.createFromUnixTimeStamp": "criar a partir de carimbo de tempo Unix",
    "createFromUnixTimeStamp": "criar a partir de carimbo de tempo Unix",
    "bitbybit.dates.createFromUnixTimeStamp_description": "cria um novo objeto de data usando o carimbo de tempo Unix fornecido",
    "unixTimeStamp": "carimbo de tempo Unix",
    "bitbybit.dates.parseDate": "analisar data",
    "parseDate": "analisar data",
    "bitbybit.dates.parseDate_description": "analisa uma string contendo uma data e retorna o número de milissegundos entre essa data e meia-noite de 1º de janeiro de 1970",
    "parse": "analisar",
    "dateString": "string de data",
    "bitbybit.dates.getDayOfMonth": "obter dia do mês",
    "getDayOfMonth": "obter dia do mês",
    "bitbybit.dates.getDayOfMonth_description": "obtém o dia do mês, usando o horário local",
    "bitbybit.dates.getWeekday": "obter dia da semana",
    "getWeekday": "obter dia da semana",
    "bitbybit.dates.getWeekday_description": "obtém o dia da semana, usando o horário local",
    "bitbybit.dates.getYear": "obter ano",
    "getYear": "obter ano",
    "bitbybit.dates.getYear_description": "obtém o ano, usando o horário local",
    "bitbybit.dates.getMonth": "obter mês",
    "getMonth": "obter mês",
    "bitbybit.dates.getMonth_description": "obtém o mês, usando o horário local",
    "bitbybit.dates.getHours": "obter horas",
    "getHours": "obter horas",
    "bitbybit.dates.getHours_description": "obtém as horas em uma data, usando o horário local",
    "bitbybit.dates.getMinutes": "obter minutos",
    "getMinutes": "obter minutos",
    "bitbybit.dates.getMinutes_description": "obtém os minutos de um objeto de data, usando o horário local",
    "bitbybit.dates.getSeconds": "obter segundos",
    "getSeconds": "obter segundos",
    "bitbybit.dates.getSeconds_description": "obtém os segundos de um objeto de data, usando o horário local",
    "bitbybit.dates.getMilliseconds": "obter milissegundos",
    "getMilliseconds": "obter milissegundos",
    "bitbybit.dates.getMilliseconds_description": "obtém os milissegundos de uma data, usando o horário local",
    "bitbybit.dates.getTime": "obter tempo",
    "getTime": "obter tempo",
    "bitbybit.dates.getTime_description": "retorna o valor de tempo armazenado em milissegundos desde meia-noite de 1º de janeiro de 1970 UTC",
    "bitbybit.dates.getUTCYear": "obter ano UTC",
    "getUTCYear": "obter ano UTC",
    "bitbybit.dates.getUTCYear_description": "obtém o ano usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.getUTCMonth": "obter mês UTC",
    "getUTCMonth": "obter mês UTC",
    "bitbybit.dates.getUTCMonth_description": "obtém o mês de um objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.getUTCDay": "obter dia UTC",
    "getUTCDay": "obter dia UTC",
    "bitbybit.dates.getUTCDay_description": "obtém o dia do mês, usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.getUTCHours": "obter horas UTC",
    "getUTCHours": "obter horas UTC",
    "bitbybit.dates.getUTCHours_description": "obtém o valor das horas em um objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.getUTCMinutes": "obter minutos UTC",
    "getUTCMinutes": "obter minutos UTC",
    "bitbybit.dates.getUTCMinutes_description": "obtém os minutos de um objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.getUTCSeconds": "obter segundos UTC",
    "getUTCSeconds": "obter segundos UTC",
    "bitbybit.dates.getUTCSeconds_description": "obtém os segundos de um objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.getUTCMilliseconds": "obter milissegundos UTC",
    "getUTCMilliseconds": "obter milissegundos UTC",
    "bitbybit.dates.getUTCMilliseconds_description": "obtém os milissegundos de um objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setYear": "definir ano",
    "setYear": "definir ano",
    "bitbybit.dates.setYear_description": "define o ano do objeto de data usando o horário local",
    "bitbybit.dates.setMonth": "definir mês",
    "setMonth": "definir mês",
    "bitbybit.dates.setMonth_description": "define o valor do mês no objeto de data usando o horário local",
    "bitbybit.dates.setDayOfMonth": "definir dia do mês",
    "setDayOfMonth": "definir dia do mês",
    "bitbybit.dates.setDayOfMonth_description": "define o valor numérico do dia do mês do objeto de data usando o horário local",
    "bitbybit.dates.setHours": "definir horas",
    "setHours": "definir horas",
    "bitbybit.dates.setHours_description": "define o valor das horas no objeto de data usando o horário local",
    "bitbybit.dates.setMinutes": "definir minutos",
    "setMinutes": "definir minutos",
    "bitbybit.dates.setMinutes_description": "define o valor dos minutos no objeto de data usando o horário local",
    "bitbybit.dates.setSeconds": "definir segundos",
    "setSeconds": "definir segundos",
    "bitbybit.dates.setSeconds_description": "define o valor dos segundos no objeto de data usando o horário local",
    "bitbybit.dates.setMilliseconds": "definir milissegundos",
    "setMilliseconds": "definir milissegundos",
    "bitbybit.dates.setMilliseconds_description": "define o valor dos milissegundos no objeto de data usando o horário local",
    "bitbybit.dates.setTime": "definir tempo",
    "setTime": "definir tempo",
    "bitbybit.dates.setTime_description": "define o valor de data e hora no objeto de data",
    "time": "tempo",
    "bitbybit.dates.setUTCYear": "definir ano UTC",
    "setUTCYear": "definir ano UTC",
    "bitbybit.dates.setUTCYear_description": "define o valor do ano no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCMonth": "definir mês UTC",
    "setUTCMonth": "definir mês UTC",
    "bitbybit.dates.setUTCMonth_description": "define o valor do mês no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCDay": "definir dia UTC",
    "setUTCDay": "definir dia UTC",
    "bitbybit.dates.setUTCDay_description": "define o dia numérico do mês no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCHours": "definir horas UTC",
    "setUTCHours": "definir horas UTC",
    "bitbybit.dates.setUTCHours_description": "define o valor das horas no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCMinutes": "definir minutos UTC",
    "setUTCMinutes": "definir minutos UTC",
    "bitbybit.dates.setUTCMinutes_description": "define o valor dos minutos no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCSeconds": "definir segundos UTC",
    "setUTCSeconds": "definir segundos UTC",
    "bitbybit.dates.setUTCSeconds_description": "define o valor dos segundos no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.dates.setUTCMilliseconds": "definir milissegundos UTC",
    "setUTCMilliseconds": "definir milissegundos UTC",
    "bitbybit.dates.setUTCMilliseconds_description": "define o valor dos milissegundos no objeto de data usando o Tempo Universal Coordenado (UTC)",
    "bitbybit.json.stringify": "stringificar",
    "json": "JSON",
    "stringify": "stringificar",
    "bitbybit.json.stringify_description": "stringifica o valor de entrada",
    "bitbybit.json.parse": "analisar",
    "bitbybit.json.parse_description": "analisa o valor de entrada",
    "bitbybit.json.query": "consultar",
    "query": "consultar",
    "bitbybit.json.query_description": "consulta o valor de entrada",
    "jsonpath": "caminho JSON",
    "bitbybit.json.setValueOnProp": "definir valor na propriedade",
    "setValueOnProp": "definir valor na propriedade",
    "bitbybit.json.setValueOnProp_description": "define valor na propriedade JSON",
    "props": "propriedades",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "obter JSON do array pela primeira correspondência de propriedade",
    "getJsonFromArrayByFirstPropMatch": "obter JSON do array pela primeira correspondência de propriedade",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "obtém JSON do array pela primeira correspondência de propriedade",
    "jsonArray": "array JSON",
    "any[]": "array qualquer",
    "match": "correspondência",
    "bitbybit.json.getValueOnProp": "obter valor da propriedade",
    "getValueOnProp": "obter valor da propriedade",
    "bitbybit.json.getValueOnProp_description": "obtém o valor da propriedade no JSON",
    "bitbybit.json.setValue": "definir valor",
    "bitbybit.json.setValue_description": "define valor no JSON por caminho",
    "prop": "propriedade",
    "bitbybit.json.setValuesOnPaths": "definir valores nos caminhos",
    "setValuesOnPaths": "definir valores nos caminhos",
    "bitbybit.json.setValuesOnPaths_description": "define múltiplos valores no JSON por caminhos",
    "paths": "caminhos",
    "bitbybit.json.paths": "caminhos",
    "bitbybit.json.paths_description": "encontra caminhos para elementos no objeto",
    "bitbybit.json.createEmpty": "vazio",
    "bitbybit.json.createEmpty_description": "cria um objeto JavaScript vazio",
    "bitbybit.json.previewAndSaveJson": "visualizar e salvar JSON",
    "previewAndSaveJson": "visualizar e salvar JSON",
    "bitbybit.json.previewAndSaveJson_description": "visualiza JSON e oferece opção de salvar",
    "preview": "visualizar",
    "bitbybit.json.previewJson": "visualizar JSON",
    "previewJson": "visualizar JSON",
    "bitbybit.json.previewJson_description": "visualiza JSON",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "curva por nós, pontos de controle e pesos",
    "verb": "verb",
    "createCurveByKnotsControlPointsWeights": "curva por nós, pontos de controle e pesos",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "cria uma curva NURBS com nós, pontos de controle e pesos",
    "degree": "grau",
    "knots": "nós",
    "bitbybit.verb.curve.createCurveByPoints": "curva por pontos",
    "createCurveByPoints": "curva por pontos",
    "bitbybit.verb.curve.createCurveByPoints_description": "cria uma curva NURBS com pontos de controle",
    "bitbybit.verb.curve.createBezierCurve": "curva de Bézier",
    "createBezierCurve": "curva de Bézier",
    "bitbybit.verb.curve.createBezierCurve_description": "cria uma curva NURBS de Bézier com pontos de controle e pesos",
    "bitbybit.verb.curve.clone": "clonar",
    "bitbybit.verb.curve.clone_description": "clona uma curva NURBS",
    "bitbybit.verb.curve.closestParam": "parâmetro mais próximo",
    "closestParam": "parâmetro mais próximo",
    "bitbybit.verb.curve.closestParam_description": "encontra o parâmetro mais próximo em uma curva NURBS a partir de um ponto",
    "bitbybit.verb.curve.closestParams": "parâmetros mais próximos",
    "closestParams": "parâmetros mais próximos",
    "bitbybit.verb.curve.closestParams_description": "encontra os parâmetros mais próximos em uma curva NURBS a partir de pontos",
    "bitbybit.verb.curve.closestPoint": "ponto mais próximo",
    "closestPoint": "ponto mais próximo",
    "bitbybit.verb.curve.closestPoint_description": "encontra o ponto mais próximo em uma curva NURBS a partir de um ponto",
    "bitbybit.verb.curve.closestPoints": "pontos mais próximos",
    "closestPoints": "pontos mais próximos",
    "bitbybit.verb.curve.closestPoints_description": "encontra os pontos mais próximos em uma curva NURBS a partir de pontos",
    "bitbybit.verb.curve.controlPoints": "pontos de controle",
    "controlPoints": "pontos de controle",
    "bitbybit.verb.curve.controlPoints_description": "encontra os pontos de controle de uma curva NURBS",
    "bitbybit.verb.curve.degree": "grau",
    "bitbybit.verb.curve.degree_description": "encontra o grau de uma curva NURBS",
    "bitbybit.verb.curve.derivatives": "derivadas",
    "derivatives": "derivadas",
    "bitbybit.verb.curve.derivatives_description": "encontra as derivadas de uma curva NURBS em um parâmetro",
    "numDerivatives": "número de derivadas",
    "parameter": "parâmetro",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "dividir por comprimento de arco igual para parâmetros",
    "divideByEqualArcLengthToParams": "dividir por comprimento de arco igual para parâmetros",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "divide a curva por comprimento de arco igual para parâmetros",
    "subdivision": "subdivisão",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "dividir por comprimento de arco igual para pontos",
    "divideByEqualArcLengthToPoints": "dividir por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "divide a curva por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideByArcLengthToParams": "dividir por comprimento de arco para parâmetros",
    "divideByArcLengthToParams": "dividir por comprimento de arco para parâmetros",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "divide a curva por comprimento de arco para parâmetros",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "dividir por comprimento de arco para pontos",
    "divideByArcLengthToPoints": "dividir por comprimento de arco para pontos",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "divide a curva por comprimento de arco para pontos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "dividir curvas por comprimento de arco igual para pontos",
    "divideCurvesByEqualArcLengthToPoints": "dividir curvas por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "divide múltiplas curvas por comprimento de arco igual para pontos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "dividir curvas por comprimento de arco para pontos",
    "divideCurvesByArcLengthToPoints": "dividir curvas por comprimento de arco para pontos",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "divide múltiplas curvas por comprimento de arco para pontos",
    "bitbybit.verb.curve.domain": "domínio",
    "bitbybit.verb.curve.domain_description": "encontra o intervalo de domínio dos parâmetros da curva",
    "bitbybit.verb.curve.startPoint": "ponto inicial",
    "bitbybit.verb.curve.startPoint_description": "ponto inicial da curva",
    "bitbybit.verb.curve.endPoint": "ponto final",
    "bitbybit.verb.curve.endPoint_description": "ponto final da curva",
    "bitbybit.verb.curve.startPoints": "pontos iniciais",
    "bitbybit.verb.curve.startPoints_description": "pontos iniciais das curvas",
    "bitbybit.verb.curve.endPoints": "pontos finais",
    "bitbybit.verb.curve.endPoints_description": "pontos finais das curvas",
    "bitbybit.verb.curve.knots": "nós",
    "bitbybit.verb.curve.knots_description": "encontra os nós de uma curva NURBS",
    "bitbybit.verb.curve.lengthAtParam": "comprimento no parâmetro",
    "lengthAtParam": "comprimento no parâmetro",
    "bitbybit.verb.curve.lengthAtParam_description": "obtém o comprimento de uma curva NURBS no parâmetro",
    "bitbybit.verb.curve.length": "comprimento",
    "bitbybit.verb.curve.length_description": "obtém o comprimento de uma curva NURBS",
    "bitbybit.verb.curve.paramAtLength": "parâmetro no comprimento",
    "paramAtLength": "parâmetro no comprimento",
    "bitbybit.verb.curve.paramAtLength_description": "obtém o parâmetro no comprimento em uma curva NURBS",
    "bitbybit.verb.curve.pointAtParam": "ponto no parâmetro",
    "pointAtParam": "ponto no parâmetro",
    "bitbybit.verb.curve.pointAtParam_description": "obtém o ponto no parâmetro em uma curva NURBS",
    "bitbybit.verb.curve.pointsAtParam": "pontos no parâmetro",
    "pointsAtParam": "pontos no parâmetro",
    "bitbybit.verb.curve.pointsAtParam_description": "obtém os pontos no parâmetro em curvas NURBS",
    "bitbybit.verb.curve.reverse": "inverter",
    "bitbybit.verb.curve.reverse_description": "inverte uma curva NURBS",
    "bitbybit.verb.curve.split": "dividir",
    "bitbybit.verb.curve.split_description": "divide uma curva NURBS no parâmetro",
    "bitbybit.verb.curve.tangent": "tangente",
    "bitbybit.verb.curve.tangent_description": "tangente de uma curva NURBS no parâmetro",
    "bitbybit.verb.curve.tessellate": "tesselar",
    "tessellate": "tesselar",
    "bitbybit.verb.curve.tessellate_description": "tessela uma curva NURBS em pontos",
    "bitbybit.verb.curve.transform": "transformar",
    "bitbybit.verb.curve.transform_description": "transforma uma curva NURBS",
    "bitbybit.verb.curve.transformCurves": "transformar curvas",
    "transformCurves": "transformar curvas",
    "bitbybit.verb.curve.transformCurves_description": "transforma curvas NURBS",
    "bitbybit.verb.curve.weights": "pesos",
    "bitbybit.verb.curve.weights_description": "pesos de uma curva NURBS",
    "bitbybit.verb.curve.circle.createCircle": "círculo",
    "createCircle": "círculo",
    "bitbybit.verb.curve.circle.createCircle_description": "cria uma curva NURBS circular",
    "xAxis": "eixo x",
    "yAxis": "eixo y",
    "bitbybit.verb.curve.circle.createArc": "arco",
    "createArc": "arco",
    "bitbybit.verb.curve.circle.createArc_description": "cria uma curva NURBS de arco",
    "minAngle": "ângulo mínimo",
    "maxAngle": "ângulo máximo",
    "bitbybit.verb.curve.circle.center": "centro",
    "bitbybit.verb.curve.circle.center_description": "obtém o centro do círculo ou arco",
    "bitbybit.verb.curve.circle.radius": "raio",
    "bitbybit.verb.curve.circle.radius_description": "obtém o raio do círculo ou arco",
    "bitbybit.verb.curve.circle.maxAngle": "ângulo máximo",
    "bitbybit.verb.curve.circle.maxAngle_description": "obtém o ângulo máximo do arco em graus",
    "bitbybit.verb.curve.circle.minAngle": "ângulo mínimo",
    "bitbybit.verb.curve.circle.minAngle_description": "obtém o ângulo mínimo do arco em graus",
    "bitbybit.verb.curve.circle.xAxis": "eixo x",
    "bitbybit.verb.curve.circle.xAxis_description": "obtém o ângulo x do arco",
    "bitbybit.verb.curve.circle.yAxis": "eixo y",
    "bitbybit.verb.curve.circle.yAxis_description": "obtém o ângulo y do arco",
    "bitbybit.verb.curve.ellipse.createEllipse": "elipse",
    "createEllipse": "elipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "cria uma curva NURBS elíptica",
    "bitbybit.verb.curve.ellipse.createArc": "arco",
    "bitbybit.verb.curve.ellipse.createArc_description": "cria uma curva NURBS de arco elíptico",
    "bitbybit.verb.curve.ellipse.center": "centro",
    "bitbybit.verb.curve.ellipse.center_description": "obtém o centro da elipse ou arco",
    "bitbybit.verb.curve.ellipse.maxAngle": "ângulo máximo",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "obtém o ângulo máximo do arco em graus",
    "bitbybit.verb.curve.ellipse.minAngle": "ângulo mínimo",
    "bitbybit.verb.curve.ellipse.minAngle_description": "obtém o ângulo mínimo do arco em graus",
    "bitbybit.verb.curve.ellipse.xAxis": "eixo x",
    "bitbybit.verb.curve.ellipse.xAxis_description": "obtém o ângulo x do arco ou elipse",
    "bitbybit.verb.curve.ellipse.yAxis": "eixo y",
    "bitbybit.verb.curve.ellipse.yAxis_description": "obtém o ângulo y do arco ou elipse",
    "bitbybit.verb.surface.boundaries": "fronteiras",
    "boundaries": "fronteiras",
    "bitbybit.verb.surface.boundaries_description": "obtém as curvas NURBS de borda da superfície",
    "bitbybit.verb.surface.createSurfaceByCorners": "superfície por cantos",
    "createSurfaceByCorners": "superfície por cantos",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "cria uma superfície com 4 pontos de canto",
    "point3": "ponto 3",
    "point4": "ponto 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "superfície por nós, pontos de controle e pesos",
    "createSurfaceByKnotsControlPointsWeights": "superfície por nós, pontos de controle e pesos",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "cria uma superfície NURBS com nós UV, graus, pontos e pesos",
    "degreeU": "grau U",
    "degreeV": "grau V",
    "knotsU": "nós U",
    "knotsV": "nós V",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "superfície por elevação de curvas",
    "createSurfaceByLoftingCurves": "superfície por elevação de curvas",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "cria uma superfície NURBS por elevação de curvas",
    "bitbybit.verb.surface.clone": "clonar",
    "bitbybit.verb.surface.clone_description": "clona uma superfície NURBS",
    "bitbybit.verb.surface.closestParam": "parâmetro mais próximo",
    "bitbybit.verb.surface.closestParam_description": "encontra o parâmetro mais próximo na superfície a partir de um ponto",
    "bitbybit.verb.surface.closestPoint": "ponto mais próximo",
    "bitbybit.verb.surface.closestPoint_description": "encontra o ponto mais próximo na superfície a partir de um ponto",
    "bitbybit.verb.surface.controlPoints": "pontos de controle",
    "bitbybit.verb.surface.controlPoints_description": "obtém os pontos de controle na superfície",
    "bitbybit.verb.surface.degreeU": "grau U",
    "bitbybit.verb.surface.degreeU_description": "obtém o grau U da superfície",
    "bitbybit.verb.surface.degreeV": "grau V",
    "bitbybit.verb.surface.degreeV_description": "obtém o grau V da superfície",
    "bitbybit.verb.surface.derivatives": "derivadas",
    "bitbybit.verb.surface.derivatives_description": "obtém as derivadas da superfície em UV",
    "u": "u",
    "v": "v",
    "bitbybit.verb.surface.domainU": "domínio U",
    "domainU": "domínio U",
    "bitbybit.verb.surface.domainU_description": "obtém o domínio U da superfície",
    "bitbybit.verb.surface.domainV": "domínio V",
    "domainV": "domínio V",
    "bitbybit.verb.surface.domainV_description": "obtém o domínio V da superfície",
    "bitbybit.verb.surface.isocurve": "isocurva",
    "isocurve": "isocurva",
    "bitbybit.verb.surface.isocurve_description": "obtém uma isocurva NURBS na superfície",
    "useV": "usar V",
    "bitbybit.verb.surface.isocurvesSubdivision": "subdivisão de isocurvas",
    "isocurvesSubdivision": "subdivisão de isocurvas",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "subdivide a superfície em isocurvas",
    "isocurveSegments": "segmentos de isocurva",
    "bitbybit.verb.surface.isocurvesAtParams": "isocurvas nos parâmetros",
    "isocurvesAtParams": "isocurvas nos parâmetros",
    "bitbybit.verb.surface.isocurvesAtParams_description": "subdivide a superfície em isocurvas nos parâmetros",
    "parameters": "parâmetros",
    "bitbybit.verb.surface.knotsU": "nós U",
    "bitbybit.verb.surface.knotsU_description": "obtém os nós U da superfície",
    "bitbybit.verb.surface.knotsV": "nós V",
    "bitbybit.verb.surface.knotsV_description": "obtém os nós V da superfície",
    "bitbybit.verb.surface.normal": "normal",
    "bitbybit.verb.surface.normal_description": "obtém a normal na superfície em UV",
    "bitbybit.verb.surface.point": "ponto",
    "bitbybit.verb.surface.point_description": "obtém o ponto na superfície em UV",
    "bitbybit.verb.surface.reverse": "inverter",
    "bitbybit.verb.surface.reverse_description": "inverte os UV e isocurvas da superfície NURBS",
    "bitbybit.verb.surface.split": "dividir",
    "bitbybit.verb.surface.split_description": "divide uma superfície NURBS em duas",
    "bitbybit.verb.surface.transformSurface": "transformar superfície",
    "transformSurface": "transformar superfície",
    "bitbybit.verb.surface.transformSurface_description": "transforma uma superfície NURBS com transformações",
    "bitbybit.verb.surface.weights": "pesos",
    "bitbybit.verb.surface.weights_description": "obtém os pesos da superfície",
    "bitbybit.verb.surface.cone.create": "criar",
    "cone": "cone",
    "bitbybit.verb.surface.cone.create_description": "cria uma superfície NURBS cônica",
    "bitbybit.verb.surface.cone.axis": "eixo",
    "bitbybit.verb.surface.cone.axis_description": "obtém o eixo do cone",
    "bitbybit.verb.surface.cone.base": "base",
    "bitbybit.verb.surface.cone.base_description": "obtém a base do cone",
    "bitbybit.verb.surface.cone.height": "altura",
    "bitbybit.verb.surface.cone.height_description": "obtém a altura do cone",
    "bitbybit.verb.surface.cone.radius": "raio",
    "bitbybit.verb.surface.cone.radius_description": "obtém o raio do cone",
    "bitbybit.verb.surface.cone.xAxis": "eixo x",
    "bitbybit.verb.surface.cone.xAxis_description": "obtém o eixo x do cone",
    "bitbybit.verb.surface.cylinder.create": "criar",
    "bitbybit.verb.surface.cylinder.create_description": "cria uma superfície NURBS cilíndrica",
    "bitbybit.verb.surface.cylinder.axis": "eixo",
    "bitbybit.verb.surface.cylinder.axis_description": "obtém o eixo do cilindro",
    "bitbybit.verb.surface.cylinder.base": "base",
    "bitbybit.verb.surface.cylinder.base_description": "obtém a base do cilindro",
    "bitbybit.verb.surface.cylinder.height": "altura",
    "bitbybit.verb.surface.cylinder.height_description": "obtém a altura do cilindro",
    "bitbybit.verb.surface.cylinder.radius": "raio",
    "bitbybit.verb.surface.cylinder.radius_description": "obtém o raio do cilindro",
    "bitbybit.verb.surface.cylinder.xAxis": "eixo x",
    "bitbybit.verb.surface.cylinder.xAxis_description": "obtém o eixo x do cilindro",
    "bitbybit.verb.surface.extrusion.create": "criar",
    "extrusion": "extrusão",
    "bitbybit.verb.surface.extrusion.create_description": "cria uma extrusão de superfície NURBS a partir de uma curva",
    "profile": "perfil",
    "bitbybit.verb.surface.extrusion.direction": "direção",
    "bitbybit.verb.surface.extrusion.direction_description": "obtém o vetor de direção da extrusão",
    "bitbybit.verb.surface.extrusion.profile": "perfil",
    "bitbybit.verb.surface.extrusion.profile_description": "obtém a curva NURBS de perfil da extrusão",
    "bitbybit.verb.surface.sphere.create": "criar",
    "bitbybit.verb.surface.sphere.create_description": "cria uma superfície NURBS esférica",
    "bitbybit.verb.surface.sphere.radius": "raio",
    "bitbybit.verb.surface.sphere.radius_description": "obtém o raio da superfície NURBS esférica",
    "bitbybit.verb.surface.sphere.center": "centro",
    "bitbybit.verb.surface.sphere.center_description": "obtém o centro da superfície NURBS esférica",
    "bitbybit.verb.surface.revolved.create": "criar",
    "revolved": "revolvido",
    "bitbybit.verb.surface.revolved.create_description": "cria uma superfície NURBS revolvida",
    "bitbybit.verb.surface.revolved.profile": "perfil",
    "bitbybit.verb.surface.revolved.profile_description": "obtém a curva NURBS de perfil da superfície revolvida",
    "revolution": "revolução",
    "bitbybit.verb.surface.revolved.center": "centro",
    "bitbybit.verb.surface.revolved.center_description": "obtém a curva NURBS de centro da superfície revolvida",
    "bitbybit.verb.surface.revolved.axis": "eixo",
    "bitbybit.verb.surface.revolved.axis_description": "obtém o eixo de rotação da superfície revolvida",
    "bitbybit.verb.surface.revolved.angle": "ângulo",
    "bitbybit.verb.surface.revolved.angle_description": "obtém o ângulo de rotação da superfície revolvida",
    "bitbybit.verb.surface.sweep.create": "criar",
    "sweep": "varredura",
    "bitbybit.verb.surface.sweep.create_description": "cria uma superfície NURBS de varredura",
    "rail": "trilho",
    "bitbybit.verb.surface.sweep.profile": "perfil",
    "bitbybit.verb.surface.sweep.profile_description": "obtém a curva NURBS de perfil da superfície varrida",
    "bitbybit.verb.surface.sweep.rail": "trilho",
    "bitbybit.verb.surface.sweep.rail_description": "obtém a curva NURBS de trilho da superfície varrida",
    "bitbybit.verb.intersect.curves": "curvas",
    "bitbybit.verb.intersect.curves_description": "intersecciona duas curvas NURBS do Verb",
    "firstCurve": "primeira curva",
    "secondCurve": "segunda curva",
    "bitbybit.verb.intersect.curveAndSurface": "curva e superfície",
    "curveAndSurface": "curva e superfície",
    "bitbybit.verb.intersect.curveAndSurface_description": "intersecciona curva e superfície",
    "bitbybit.verb.intersect.surfaces": "superfícies",
    "bitbybit.verb.intersect.surfaces_description": "intersecciona duas superfícies",
    "firstSurface": "primeira superfície",
    "secondSurface": "segunda superfície",
    "bitbybit.verb.intersect.curveCurveFirstParams": "parâmetros da primeira curva",
    "curveCurveFirstParams": "parâmetros da primeira curva",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "obtém os parâmetros de interseção na primeira curva",
    "intersections": "interseções",
    "BaseTypes.CurveCurveIntersection[]": "array de interseção de curva com curva do tipo base",
    "bitbybit.verb.intersect.curveCurveSecondParams": "parâmetros da segunda curva",
    "curveCurveSecondParams": "parâmetros da segunda curva",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "obtém os parâmetros de interseção na segunda curva",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "pontos da primeira curva",
    "curveCurveFirstPoints": "pontos da primeira curva",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "obtém os pontos de interseção na primeira curva",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "pontos da segunda curva",
    "curveCurveSecondPoints": "pontos da segunda curva",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "obtém os pontos de interseção na segunda curva",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "parâmetros da curva na interseção com superfície",
    "curveSurfaceCurveParams": "parâmetros da curva na interseção com superfície",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "obtém os parâmetros de interseção na curva",
    "BaseTypes.CurveSurfaceIntersection[]": "array de interseção de curva com superfície do tipo base",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "parâmetros da superfície na interseção com curva",
    "curveSurfaceSurfaceParams": "parâmetros da superfície na interseção com curva",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "obtém os parâmetros de interseção na superfície",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "pontos da curva na interseção com superfície",
    "curveSurfaceCurvePoints": "pontos da curva na interseção com superfície",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "obtém os pontos de interseção na curva",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "pontos da superfície na interseção com curva",
    "curveSurfaceSurfacePoints": "pontos da superfície na interseção com curva",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "obtém os pontos de interseção na superfície",
    "bitbybit.tag.create": "criar",
    "tag": "etiqueta",
    "bitbybit.tag.create_description": "cria um DTO de etiqueta",
    "adaptDepth": "adaptar profundidade",
    "needsUpdate": "precisa de atualização",
    "bitbybit.time.registerRenderFunction": "registrar função de renderização",
    "registerRenderFunction": "registrar função de renderização",
    "bitbybit.time.registerRenderFunction_description": "registra uma função no loop de renderização",
    "bitbybit.asset.getFile": "obter arquivo",
    "asset": "ativo",
    "getFile": "obter arquivo",
    "bitbybit.asset.getFile_description": "obtém um arquivo de ativo",
    "bitbybit.asset.getLocalFile": "obter arquivo local",
    "getLocalFile": "obter arquivo local",
    "bitbybit.asset.getLocalFile_description": "obtém um arquivo de ativo local do navegador",
    "bitbybit.asset.fetchBlob": "buscar blob",
    "fetchBlob": "buscar blob",
    "bitbybit.asset.fetchBlob_description": "busca um blob a partir de uma URL CORS",
    "fetch": "buscar",
    "bitbybit.asset.fetchFile": "buscar arquivo",
    "fetchFile": "buscar arquivo",
    "bitbybit.asset.fetchFile_description": "busca um arquivo a partir de uma URL CORS",
    "bitbybit.asset.fetchJSON": "buscar JSON",
    "fetchJSON": "buscar JSON",
    "bitbybit.asset.fetchJSON_description": "busca JSON a partir de uma URL CORS",
    "bitbybit.asset.fetchText": "buscar texto",
    "fetchText": "buscar texto",
    "bitbybit.asset.fetchText_description": "busca texto a partir de uma URL CORS",
    "bitbybit.asset.createObjectURL": "URL de objeto",
    "createObjectURL": "URL de objeto",
    "bitbybit.asset.createObjectURL_description": "cria uma URL para um arquivo na memória",
    "file": "arquivo",
    "File | Blob": "arquivo ou blob",
    "bitbybit.asset.createObjectURLs": "URLs de objetos",
    "createObjectURLs": "URLs de objetos",
    "bitbybit.asset.createObjectURLs_description": "cria URLs para arquivos na memória",
    "files": "arquivos",
    "(File | Blob)[]": "array de arquivo ou blob",
    "exec": "executar",
    "Visible": "Visível",
    "Hidden": "Oculto",
    "flatten": "achatar",
    "force exec": "forçar execução",
    "console log": "log no console",
    "preview data": "visualizar dados",
    "flow": "fluxo",
    "code": "código",
    "runner": "executor",
    "counters": "contadores",
    "actions": "ações",
    "loops": "loops",
    "interval": "intervalo",
    "delay": "atraso",
    "expire": "expirar",
    "timeout": "tempo limite",
    "counter min max": "contador mínimo e máximo",
    "counter steps": "passos do contador",
    "reset": "redefinir",
    "trigger": "gatilho",
    "mouse": "mouse",
    "mouse click": "clique do mouse",
    "key": "tecla",
    "pointer": "ponteiro",
    "pick info": "informações de seleção",
    "down": "baixo",
    "wheel": "roda",
    "tap": "toque",
    "double tap": "toque duplo",
    "render": "renderizar",
    "passed ms": "ms passados",
    "babylon observable listener": "ouvinte observável Babylon",
    "object": "objeto",
    "observable selector": "seletor observável",
    "get event data": "obter dados do evento",
    "exec click": "executar clique",
    "exec down": "executar pressionado",
    "toggle": "alternar",
    "flip flop": "flip flop",
    "boolean gate": "portão booleano",
    "boolean gate silent": "portão booleano silencioso",
    "is undefined": "é indefinido",
    "for loop": "loop for",
    "last": "último",
    "for each loop": "loop para cada",
    "element": "elemento",
    "body": "corpo",
    "complete": "completo",
    "editors": "editores",
    "inputs": "entradas",
    "outputs": "saídas",
    "recent": "recente",
    "Clear": "Limpar",
    "Run": "Executar",
    "Swap Canvas": "Trocar Tela",
    "Local Assets": "Ativos Locais",
    "Import": "Importar",
    "Copy to Clipboard": "Copiar para a Área de Transferência",
    "Paste from Clipboard": "Colar da Área de Transferência",
    "Export": "Exportar",
    "Export to runner": "Exportar para executor",
    "Clean Cache": "Limpar Cache",
    "Community": "Comunidade",
    "Sponsors and Partners": "Patrocinadores e Parceiros",
    "API Documentation": "Documentação da API",
    "About": "Sobre",
    "Toolbox": "Caixa de Ferramentas",
    "More": "Mais",
    "bitbybit.code.typeScriptEditor": "editor TypeScript",
    "bitbybit.code.typeScriptEditor_description": "Permite escrever código TypeScript com suporte completo ao intellisense do Bitbybit em uma função. O que a função start retornar será visto como saída do componente.",
    "bitbybit.code.javaScriptEditor": "editor JavaScript",
    "bitbybit.code.javaScriptEditor_description": "Permite escrever código JavaScript em uma função. O que a função start retornar será visto como saída do componente.",
    "bitbybit.code.jsonEditor": "editor JSON",
    "bitbybit.code.jsonEditor_description": "Permite escrever código JSON. O que a função start retornar será visto como saída do componente.",
    "bitbybit.flow.actions.keyboard": "teclado",
    "bitbybit.flow.actions.keyboard_description": "Executará em eventos de teclado ao clicar nos botões.",
    "bitbybit.flow.actions.mouseClick": "clique do mouse",
    "bitbybit.flow.actions.mouseClick_description": "Executará em eventos de mouse ao clicar nos botões.",
    "bitbybit.flow.actions.start": "iniciar",
    "bitbybit.flow.actions.start_description": "Inicia o fluxo de controle e dispara execuções.",
    "bitbybit.flow.actions.trigger": "gatilho",
    "bitbybit.flow.actions.trigger_description": "Dispara a execução ao clicar no botão.",
    "bitbybit.flow.babylon.gui.button": "botão",
    "bitbybit.flow.babylon.gui.button_description": "Executará em vários eventos de ponteiro ao clicar com o botão esquerdo do mouse na tela do BabylonJS.",
    "bitbybit.flow.babylon.scene.pointerEvents": "ponteiro",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Executará em vários eventos de ponteiro ao clicar com o botão esquerdo do mouse na tela do BabylonJS.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "obter dados do evento",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Obtém dados do evento a partir do resultado observado do ouvinte observável.",
    "bitbybit.flow.babylon.observableListener": "ouvinte observável Babylon",
    "bitbybit.flow.babylon.observableListener_description": "Inscreve-se e escuta qualquer um dos observáveis do BabylonJS.",
    "bitbybit.flow.babylon.render": "renderizar",
    "bitbybit.flow.babylon.render_description": "Executa em cada quadro de renderização do BabylonJS.",
    "bitbybit.flow.counters.counterMinMax": "contador mínimo e máximo",
    "bitbybit.flow.counters.counterMinMax_description": "Conta o número de execuções do fluxo entre valores mínimo e máximo. Quando o máximo é alcançado, reinicia.",
    "bitbybit.flow.counters.counterSteps": "passos do contador",
    "bitbybit.flow.counters.counterSteps_description": "Conta o número de execuções do fluxo começando em um valor dado e aumentando a cada execução por um passo da lista, até que os passos terminem. Quando o fim é alcançado, reinicia.",
    "bitbybit.flow.counters.counter": "contador",
    "bitbybit.flow.counters.counter_description": "Conta o número de execuções do fluxo.",
    "bitbybit.flow.logic.booleanGateSilent": "portão booleano silencioso",
    "bitbybit.flow.logic.booleanGateSilent_description": "Dispara diferentes eventos de execução com base no valor booleano fornecido, mas executa apenas quando o booleano muda de valor, evitando múltiplos eventos constantes sem alterações.",
    "bitbybit.flow.logic.booleanGate": "portão booleano",
    "bitbybit.flow.logic.booleanGate_description": "Dispara diferentes eventos de execução com base no valor booleano fornecido.",
    "bitbybit.flow.logic.flipFlop": "flip flop",
    "bitbybit.flow.logic.flipFlop_description": "Cada vez que um evento é executado, um evento diferente será disparado, criando essencialmente uma funcionalidade de alternância.",
    "bitbybit.flow.logic.isUndefined": "é indefinido",
    "bitbybit.flow.logic.isUndefined_description": "Verifica se o valor fornecido é indefinido e dispara um evento verdadeiro ou falso.",
    "bitbybit.flow.loops.forEach": "loop para cada",
    "bitbybit.flow.loops.forEach_description": "Loop para cada que percorre todos os elementos da lista.",
    "bitbybit.flow.loops.for": "loop for",
    "bitbybit.flow.loops.for_description": "Loop for que executa o corpo entre dois valores.",
    "bitbybit.flow.time.delay": "atraso",
    "bitbybit.flow.time.delay_description": "Atrasa a execução pelo tempo limite dado em milissegundos.",
    "bitbybit.flow.time.interval": "intervalo",
    "bitbybit.flow.time.interval_description": "Executa o fluxo a cada intervalo dado em milissegundos.",
    "bitbybit.lists.createList": "criar lista",
    "bitbybit.lists.createList_description": "Cria uma lista a partir dos elementos fornecidos.",
    "bitbybit.lists.flatten": "achatar",
    "bitbybit.lists.flatten_description": "Achata a lista de listas em uma única lista.",
    "bitbybit.lists.passThrough": "passagem direta",
    "bitbybit.lists.passThrough_description": "Converte o valor para o tipo 'any' e passa a entrada para a saída sem alterações.",
    "bitbybit.math.numberSlider": "deslizador de número",
    "bitbybit.math.numberSlider_description": "Cria um número com um deslizador. Você pode definir valores mínimo, máximo e de passo.",
    "bitbybit.consoleLog": "log no console",
    "bitbybit.consoleLog_description": "Registra a entrada no console do navegador.",
    "bitbybit.previewData": "visualizar dados",
    "bitbybit.previewData_description": "Mostra os dados de entrada em uma área de visualização geral. Pode ser texto, números, objetos JSON, arrays, etc. Objetos JavaScript circulares não são permitidos.",
    "bitbybit.runner.getRunnerInputValue": "obter valor de entrada do executor",
    "bitbybit.runner.getRunnerInputValue_description": "Obtém o valor de entrada do executor a partir do JSON de entradas. Este componente sempre retornará um valor indefinido no contexto do editor.",
    "bitbybit.runner.getRunnerInputs": "obter entradas do executor",
    "bitbybit.runner.getRunnerInputs_description": "Obtém as entradas do executor em JSON. Este componente sempre retornará um objeto vazio no contexto do editor.",
    "bitbybit.runner.run": "executar",
    "bitbybit.runner.run_description": "Executa código JavaScript do executor.",
    "bitbybit.runner.setRunnerResult": "definir resultado do executor",
    "bitbybit.runner.setRunnerResult_description": "Define o resultado JSON completo para o executor. Tenha em mente que é mais seguro definir valores, pois este método substituirá todo o objeto de resultado pelo valor fornecido.",
    "bitbybit.runner.setRunnerResultArrayValue": "definir valor de array do resultado do executor",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Define o valor do resultado do executor na propriedade do objeto JSON. Cada valor será adicionado a um array, que é o valor da propriedade.",
    "bitbybit.runner.setRunnerResultValue": "definir valor do resultado do executor",
    "bitbybit.runner.setRunnerResultValue_description": "Define o valor do resultado do executor na propriedade do objeto JSON.",
    "bitbybit.text.areaCreate": "área de texto",
    "bitbybit.text.areaCreate_description": "Cria uma área de texto no editor. Você pode definir o texto, largura e altura da área.",
    "update on drag": "atualizar ao arrastar",
    "paste": "colar",
    "duplicate": "duplicar",
    "delete": "excluir",
    "keyboard": "teclado",
    "data": "dados",
    "observables": "observáveis",
    "buttons": "botões",
    "variables": "variáveis",
    "functions": "funções",
    "loop": "loop",
    "apply": "aplicar",
    "async context": "contexto assíncrono",
    "async context description": "Cria um contexto assíncrono que pode usar componentes await, simplificando a execução e leitura de código assíncrono.",
    "then": "então",
    "await": "aguardar",
    "await description": "Aguarda a resolução da promessa e retorna o valor.",
    "when the": "quando o",
    "error": "erro",
    "happens in the promise": "ocorre na promessa",
    "catch": "capturar",
    "catch description": "Captura o erro que pode ocorrer durante a execução de código assíncrono. O usuário pode optar por tratar os erros adequadamente.",
    "cancel the interval execution": "cancelar a execução do intervalo",
    "cancel the interval description": "Cancela a execução do intervalo fornecendo o manipulador.",
    "cancel the timeout execution": "cancelar a execução do tempo limite",
    "cancel the timeout description": "Cancela a execução do tempo limite fornecendo o manipulador.",
    "key down": "tecla pressionada",
    "key down descritpion": "Dispara código quando o evento de tecla pressionada ocorre.",
    "key up": "tecla solta",
    "key up description": "Dispara código quando o evento de tecla solta ocorre.",
    "key press": "tecla pressionada",
    "key press description": "Dispara código quando o evento de tecla pressionada ocorre.",
    "is key pressed": "tecla está pressionada",
    "block_validation_required": "deve ser fornecido",
    "block_validation_of_length": "deve conter uma contagem de itens de",
    "block_validation_higher_or_equal": "deve ser maior ou igual a",
    "block_validation_lower_or_equal": "deve ser menor ou igual a",
    "block_validation_range": "deve estar no intervalo",
    "block_validation_smaller_than": "deve ser menor que",
    "block_validation_smaller_or_equal_than": "deve ser menor ou igual a",
    "block_validation_larger_than": "deve ser maior que",
    "block_validation_larger_or_equal_than": "deve ser maior ou igual a",
    "save text to file": "salvar texto em arquivo",
    "save text to file description": "Salva texto em um arquivo e permite escolher o nome e a extensão. Este componente não visualiza o texto e pode ser usado em situações onde o texto é muito grande para editar em um campo de área de texto.",
    "print text on screen": "imprimir texto na tela",
    "print text on screen description": "Imprime texto na tela. Este componente é útil para fins de depuração.",
    "preview text and save to file": "visualizar texto e salvar em arquivo",
    "preview text and save to file description": "Imprime texto na tela e permite salvá-lo em um arquivo. Este componente é útil para fins de depuração.",
    "register render loop listener": "registrar ouvinte de loop de renderização",
    "and update": "e atualizar",
    "register render loop listener description": "Executa a instrução no loop de renderização e indica quanto tempo passou desde o último quadro na variável timeElapsedFromPreviousFrame.",
    "timeElapsedFromPreviousFrame_var": "tempoDecorridoDesdeOFrameAnterior",
    "computing": "computação",
    "result": "resultado",
    "of promise is returned": "da promessa é retornado",
    "on pointer up": "ao soltar o ponteiro",
    "on pointer move": "ao mover o ponteiro",
    "on pointer down": "ao pressionar o ponteiro",
    "of babylonjs observable object": "do objeto observável BabylonJS",
    "observable name": "nome do observável",
    "is key pressed description": "Verifica se a tecla está pressionada e retorna verdadeiro ou falso.",
    "execute code after": "executar código após",
    "execute code after description": "Executa o código após o tempo limite dado em segundos.",
    "execute code every": "executar código a cada",
    "second(s)": "segundo(s)",
    "execute code every description": "Executa o código a cada intervalo dado em segundos.",
    "handler": "manipulador",
    "workers initialising": "inicializando trabalhadores",
    "Assets": "Ativos",
    "Local assets stored in browser cache:": "Ativos locais armazenados no cache do navegador:",
    "Asset Name": "Nome do Ativo",
    "Name is required": "O nome é obrigatório",
    "Asset with this name already exists, choose a different one": "Ativo com este nome já existe, escolha um diferente",
    "Allowed file formats:": "Formatos de arquivo permitidos:",
    "You must select an asset file": "Você deve selecionar um arquivo de ativo",
    "Upload Local Asset": "Carregar Ativo Local",
    "File Name": "Nome do Arquivo",
    "File Size": "Tamanho do Arquivo",
    "Your browser does not support indexDB and you can't upload local asset files.": "Seu navegador não suporta indexDB e você não pode carregar arquivos de ativos locais.",
    "Upload": "Carregar",
    "elements": "elementos",
    "bitbybit.vector.vectorsTheSame": "vetores iguais",
    "vectorsTheSame": "vetores iguais",
    "bitbybit.vector.vectorsTheSame_description": "Verifica se dois vetores são iguais dentro de uma determinada tolerância",
    "vec1": "vetor 1",
    "vec2": "vetor 2",
    "bitbybit.point.boundingBoxOfPoints": "caixa delimitadora de pontos",
    "boundingBoxOfPoints": "caixa delimitadora de pontos",
    "bitbybit.point.boundingBoxOfPoints_description": "Obtém uma caixa delimitadora dos pontos",
    "bitbybit.point.normalFromThreePoints": "normal a partir de três pontos",
    "normalFromThreePoints": "normal a partir de três pontos",
    "bitbybit.point.normalFromThreePoints_description": "Cria um vetor normal a partir de 3 pontos",
    "reverseNormal": "normal invertida",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "polilinha com extensões",
    "createLineWireWithExtensions": "polilinha com extensões",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Cria uma polilinha OpenCascade com extensões",
    "extensionStart": "início ext.",
    "extensionEnd": "fim ext.",
    "bitbybit.occt.shapes.wire.midPointOnWire": "ponto médio na polilinha",
    "midPointOnWire": "ponto médio na polilinha",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Calcula o ponto médio na polilinha no parâmetro 0.5",
    "centerOnOrigin": "centrar na origem",
    "bitbybit.occt.shapes.wire.textWiresWithData": "polilinhas de texto com dados",
    "textWiresWithData": "polilinhas de texto com dados",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Cria um composto OpenCascade a partir de polilinhas de texto e retorna informações adicionais com base na fonte simplex criada pelo Dr. A. V. Hershey",
    "bitbybit.occt.transforms.alignNormAndAxis": "alinhar normal e eixo",
    "alignNormAndAxis": "alinhar normal e eixo",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Alinha a forma com a normal e o eixo",
    "fromNorm": "da normal",
    "fromAx": "do eixo",
    "toNorm": "para normal",
    "toAx": "para eixo",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "cota de comprimento linear simples",
    "simpleLinearLengthDimension": "cota de comprimento linear simples",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Cria uma cota de comprimento linear simples entre dois pontos - unidades de medida",
    "offsetFromPoints": "deslocamento dos pontos",
    "crossingSize": "tamanho do cruzamento",
    "labelSuffix": "sufixo do rótulo",
    "labelSize": "tamanho do rótulo",
    "labelOffset": "deslocamento do rótulo",
    "bitbybit.occt.dimensions.simpleAngularDimension": "dimensão angular simples",
    "simpleAngularDimension": "dimensão angular simples",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Cria uma dimensão angular simples. Por padrão, exibimos graus, mas você pode optar por usar radianos.",
    "direction1": "direção 1",
    "direction2": "direção 2",
    "offsetFromCenter": "deslocamento do centro",
    "extraSize": "tamanho extra",
    "radians": "radianos",
    "bitbybit.occt.dimensions.pinWithLabel": "pino com rótulo",
    "pinWithLabel": "pino com rótulo",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Cria um pino com rótulo. Pode ser usado para explicar coisas sobre os modelos ou marcar itens importantes na cena 3D.",
    "offsetFromStart": "deslocamento do início",
    "bitbybit.vector.lengthSq": "comprimento ao quadrado",
    "lengthSq": "comprimento ao quadrado",
    "bitbybit.vector.lengthSq_description": "Calcula o comprimento ao quadrado do vetor",
    "bitbybit.point.twoPointsAlmostEqual": "dois pontos iguais",
    "twoPointsAlmostEqual": "dois pontos iguais",
    "bitbybit.point.twoPointsAlmostEqual_description": "Verifica se dois pontos são quase iguais",
    "bitbybit.line.lineToSegment": "linha para segmento",
    "lineToSegment": "linha para segmento",
    "bitbybit.line.lineToSegment_description": "Converte a linha para segmento",
    "bitbybit.line.linesToSegments": "linhas para segmentos",
    "linesToSegments": "linhas para segmentos",
    "bitbybit.line.linesToSegments_description": "Converte as linhas para segmentos",
    "bitbybit.line.segmentToLine": "segmento para linha",
    "segmentToLine": "segmento para linha",
    "bitbybit.line.segmentToLine_description": "Converte o segmento para linha",
    "segment": "segmento",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "segmentos para linhas",
    "segmentsToLines": "segmentos para linhas",
    "bitbybit.line.segmentsToLines_description": "Converte os segmentos para linhas",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "ordenar segmentos em polilinhas",
    "sortSegmentsIntoPolylines": "ordenar segmentos em polilinhas",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Cria as polilinhas a partir de segmentos que estão potencialmente conectados, mas misturados aleatoriamente",
    "sort": "ordenar",
    "bitbybit.mesh.signedDistanceToPlane": "distância com sinal ao plano",
    "signedDistanceToPlane": "distância com sinal ao plano",
    "bitbybit.mesh.signedDistanceToPlane_description": "Calcula a distância com sinal de um ponto a um plano.",
    "plane": "plano",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "calcular plano do triângulo",
    "calculateTrianglePlane": "calcular plano do triângulo",
    "bitbybit.mesh.calculateTrianglePlane_description": "Calcula o plano do triângulo a partir do triângulo.",
    "triangle": "triângulo",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "interseção triângulo-triângulo",
    "triangleTriangleIntersection": "interseção triângulo-triângulo",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Calcula a interseção de dois triângulos.",
    "triangle1": "triângulo 1",
    "triangle2": "triângulo 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "segmentos de interseção malha-malha",
    "meshMeshIntersectionSegments": "segmentos de interseção malha-malha",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Calcula os segmentos de interseção de duas malhas.",
    "mesh1": "malha 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "malha 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "polilinhas de interseção malha-malha",
    "meshMeshIntersectionPolylines": "polilinhas de interseção malha-malha",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Calcula as polilinhas de interseção de duas malhas.",
    "bitbybit.occt.shapeFacesToPolygonPoints": "faces da forma para pontos do polígono",
    "shapeFacesToPolygonPoints": "faces da forma para pontos do polígono",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Cria pontos do polígono a partir das faces da forma",
    "reversedPoints": "pontos invertidos",
    "bitbybit.occt.shapeToMesh": "forma para malha",
    "shapeToMesh": "forma para malha",
    "bitbybit.occt.shapeToMesh_description": "Cria malha a partir da forma",
    "bitbybit.occt.shapesToMeshes": "formas para malhas",
    "shapesToMeshes": "formas para malhas",
    "bitbybit.occt.shapesToMeshes_description": "Cria malha a partir da forma",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "a partir de pontos do polígono",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Cria um Manifold a partir de um conjunto de pontos do polígono que descrevem triângulos.",
    "traingle": "triângulo",
    "bitbybit.point.stretchPointsDirFromCenter": "esticar pontos na direção a partir do centro",
    "stretchPointsDirFromCenter": "esticar pontos na direção a partir do centro",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Estica múltiplos pontos fornecendo ponto central, direção e fator de escala uniforme",
    "bitbybit.point.hexGridScaledToFit": "grade hexagonal escalada para ajustar",
    "hexGridScaledToFit": "grade hexagonal escalada para ajustar",
    "bitbybit.point.hexGridScaledToFit_description": "Cria uma grade hexagonal de topo pontiagudo, escalando os hexágonos para ajustar exatamente às dimensões especificadas. Retorna os pontos centrais e os vértices de cada hexágono (potencialmente escalado). Os hexágonos são ordenados primeiro por coluna, depois por linha.",
    "nrHexagonsU": "nº hexágonos U",
    "nrHexagonsV": "nº hexágonos V",
    "extendTop": "estender topo",
    "extendBottom": "estender base",
    "extendLeft": "estender esquerda",
    "extendRight": "estender direita",
    "centerGrid": "centralizar grade",
    "bitbybit.point.sortPoints": "ordenar pontos",
    "sortPoints": "ordenar pontos",
    "bitbybit.point.sortPoints_description": "Ordena pontos lexicograficamente (X, depois Y, depois Z)",
    "bitbybit.line.lineLineIntersection": "interseção linha-linha",
    "lineLineIntersection": "interseção linha-linha",
    "bitbybit.line.lineLineIntersection_description": "Se duas linhas se cruzarem, retorna o ponto de interseção",
    "line1": "linha 1",
    "line2": "linha 2",
    "checkSegmentsOnly": "verificar apenas segmentos",
    "bitbybit.polyline.polylineToLines": "polilinha para linhas",
    "polylineToLines": "polilinha para linhas",
    "bitbybit.polyline.polylineToLines_description": "Cria as linhas a partir da polilinha",
    "bitbybit.polyline.polylineToSegments": "polilinha para segmentos",
    "polylineToSegments": "polilinha para segmentos",
    "bitbybit.polyline.polylineToSegments_description": "Cria os segmentos a partir da polilinha",
    "bitbybit.polyline.polylineSelfIntersection": "autointerseção de polilinha",
    "polylineSelfIntersection": "autointerseção de polilinha",
    "bitbybit.polyline.polylineSelfIntersection_description": "Encontra os pontos de autointerseção da polilinha",
    "bitbybit.polyline.twoPolylineIntersection": "interseção de duas polilinhas",
    "twoPolylineIntersection": "interseção de duas polilinhas",
    "bitbybit.polyline.twoPolylineIntersection_description": "Encontra os pontos de interseção entre duas polilinhas.",
    "polyline1": "polilinha 1",
    "polyline2": "polilinha 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "subdividir em arames hexagonais",
    "subdivideToHexagonWires": "subdividir em arames hexagonais",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Subdivide uma face em arames hexagonais",
    "extendUUp": "estender U acima",
    "extendUBottom": "estender U abaixo",
    "extendVUp": "estender V acima",
    "extendVBottom": "estender V abaixo",
    "nrHexagonsInHeight": "nº hexágonos altura",
    "nrHexagonsInWidth": "nº hexágonos largura",
    "bitbybit.vector.length": "comprimento do vetor",
    "bitbybit.vector.length_description": "Calcula o comprimento do vetor",
    "bitbybit.point.maxFilletRadius": "raio máximo de fillet",
    "maxFilletRadius": "raio máximo de fillet",
    "bitbybit.point.maxFilletRadius_description": "Calcula o raio máximo de concordância (fillet) possível num canto formado por dois segmentos de linha que partilham um ponto extremo (C), de tal forma que o arco de concordância seja tangente a ambos os segmentos e esteja inteiramente contido neles.",
    "bitbybit.point.maxFilletRadiusHalfLine": "raio máximo de fillet meia-linha",
    "maxFilletRadiusHalfLine": "raio máximo de fillet meia-linha",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Calcula o raio máximo de concordância (fillet) possível num canto C, de tal forma que o arco de concordância seja tangente a ambos os segmentos (P1-C, P2-C) e os pontos tangentes estejam dentro da primeira metade de cada segmento (medido a partir de C).",
    "bitbybit.point.maxFilletsHalfLine": "fillets máximos meia-linha",
    "maxFilletsHalfLine": "fillets máximos meia-linha",
    "bitbybit.point.maxFilletsHalfLine_description": "Calcula o raio máximo de concordância (fillet) possível em cada canto de uma polilinha formada por uma série de pontos. O raio de concordância é calculado para cada canto interno e opcionalmente para os cantos de fecho se a polilinha for fechada.",
    "checkLastWithFirst": "verificar último com primeiro",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "raio máximo de fillet mais seguro (pontos, meia-linha)",
    "safestPointsMaxFilletHalfLine": "raio máximo de fillet mais seguro (pontos, meia-linha)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Calcula o único raio máximo de concordância (fillet) mais seguro que pode ser aplicado uniformemente a todos os cantos de uma coleção de pontos, com base na restrição de 'meia-linha'. Isso é determinado encontrando o mínimo dos raios máximos de concordância possíveis calculados para cada canto individual.",
    "bitbybit.polyline.maxFilletsHalfLine": "fillets máximos meia-linha",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Calcula o raio máximo de concordância (fillet) de 'meia-linha' possível para cada canto de uma dada polilinha. Para uma polilinha fechada, inclui os cantos que conectam o último segmento de volta ao primeiro. O cálculo usa a restrição de 'meia-linha', significando que os pontos tangentes do fillet devem estar dentro da primeira metade de cada segmento conectado ao canto.",
    "bitbybit.polyline.safestFilletRadius": "raio de fillet mais seguro",
    "safestFilletRadius": "raio de fillet mais seguro",
    "bitbybit.polyline.safestFilletRadius_description": "Calcula o único raio máximo de concordância (fillet) mais seguro que pode ser aplicado uniformemente a todos os cantos de uma polilinha, com base na restrição de 'meia-linha'. Isso é determinado encontrando o mínimo dos raios máximos de concordância possíveis calculados para cada canto individual.",
    "flatTop": "topo plano",
    "bitbybit.mesh.meshMeshIntersectionPoints": "pontos de interseção malha-malha",
    "meshMeshIntersectionPoints": "pontos de interseção malha-malha",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Calcula os pontos de interseção de duas malhas.",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "hexágonos na grade",
    "hexagonsInGrid": "hexágonos na grade",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Cria arames hexagonais OpenCascade na grade",
    "scalePatternWidth": "escalar largura do padrão",
    "scalePatternHeight": "escalar altura do padrão",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "arames de interseção malha-malha",
    "meshMeshIntersectionWires": "arames de interseção malha-malha",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Realiza a operação de interseção malha-malha entre duas formas - ambas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os arames da interseção, que são polilinhas ou polígonos.",
    "mesh based": "baseado em malha",
    "precision1": "precisão 1",
    "precision2": "precisão 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "pontos de interseção malha-malha",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Realiza a operação de interseção malha-malha entre duas formas - ambas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os pontos da interseção.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "interseção malha-malha para arames",
    "meshMeshIntersectionOfShapesWires": "interseção malha-malha para arames",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Realiza a operação de interseção malha-malha entre a forma e múltiplas outras formas - todas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os arames da interseção, que são polilinhas ou polígonos.",
    "precisionShapes": "precisão formas",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "interseção malha-malha para pontos",
    "meshMeshIntersectionOfShapesPoints": "interseção malha-malha para pontos",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Realiza a operação de interseção malha-malha entre a forma e múltiplas outras formas - todas as formas podem ter sua própria precisão de malhagem. Este algoritmo cruza as malhas e retorna os pontos da interseção.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "hexágonos na grade",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Cria hexágonos OpenCascade na grade (faces)",
    "bitbybit.jscad.toPolygonPoints": "para pontos de polígono",
    "toPolygonPoints": "para pontos de polígono",
    "bitbybit.jscad.toPolygonPoints_description": "Transforma a forma jscad numa coleção de pontos de polígono representando a malha",
    "conversions": "conversões",
    "bitbybit.manifold.toPolygonPoints": "para pontos de polígono",
    "bitbybit.manifold.toPolygonPoints_description": "Transforma a forma manifold numa coleção de pontos de polígono representando a malha.",
    "flatU": "plano U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "subdividir em furos hexagonais",
    "subdivideToHexagonHoles": "subdividir em furos hexagonais",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Subdivide uma face em furos hexagonais",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "converter linhas para curvas NURBS",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Converte linhas em curvas NURBS. Retorna um array de objetos verbnurbs Line.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "converter linha para curva NURBS",
    "convertLineToNurbsCurve": "converter linha para curva NURBS",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Converte linha em curva NURBS. Retorna o objeto verbnurbs Line.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "converter polilinha para curva NURBS",
    "convertPolylineToNurbsCurve": "converter polilinha para curva NURBS",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Converte uma polilinha em uma curva NURBS. Retorna o objeto verbnurbs NurbsCurve.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "converter polilinhas para curvas NURBS",
    "convertPolylinesToNurbsCurves": "converter polilinhas para curvas NURBS",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Converte polilinhas em curvas NURBS. Retorna os objetos verbnurbs NurbsCurve.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "segmento",
    "createSegment": "segmento",
    "bitbybit.line.createSegment_description": "Criar o segmento",
    "bitbybit.occt.shapes.edge.fromBaseLine": "aresta da linha de base",
    "fromBaseLine": "da linha de base",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Cria aresta linear a partir do formato de linha de base {start: Point3, end: Point3}",
    "from base": "da base",
    "bitbybit.occt.shapes.edge.fromBaseLines": "aresta das linhas de base",
    "fromBaseLines": "das linhas de base",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Cria arestas lineares a partir do formato de linhas de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "aresta do segmento de base",
    "fromBaseSegment": "do segmento de base",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Cria aresta linear a partir do formato de segmento de base [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "arestas dos segmentos de base",
    "fromBaseSegments": "dos segmentos de base",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Cria aresta linear a partir do formato de segmentos de base [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "arestas de pontos",
    "fromPoints": "de pontos",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Cria arestas lineares a partir da coleção de pontos",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "arestas da polilinha de base",
    "fromBasePolyline": "da polilinha de base",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Cria arestas lineares a partir da definição de polilinha",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "arestas do triângulo de base",
    "fromBaseTriangle": "do triângulo de base",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Cria arestas lineares a partir da definição de triângulo",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "arestas da malha de base",
    "fromBaseMesh": "da malha de base",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Cria arestas lineares a partir da definição de malha",
    "bitbybit.occt.shapes.wire.fromBaseLine": "arame da linha de base",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Cria arame linear a partir do formato de linha de base {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "arames das linhas de base",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Cria arames lineares a partir do formato de linhas de base {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "arame do segmento de base",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Cria arame linear a partir do formato de segmento de base [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "arames dos segmentos de base",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Cria arames lineares a partir do formato de segmentos de base [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "arame de pontos",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Cria arame a partir da coleção de pontos",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "arame da polilinha de base",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Cria arame a partir da definição de polilinha",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "arame do triângulo de base",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Cria arame a partir da definição de triângulo",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "arames da malha de base",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Cria arames a partir da definição de malha",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "face do triângulo de base",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Cria face a partir da definição de triângulo",
    "bitbybit.occt.shapes.face.fromBaseMesh": "faces da malha de base",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Cria faces a partir da definição de malha",
    "fromRightHanded": "de destro",
      "bitbybit.advanced.text3d.createWithUrl": "texto com url",
    "createWithUrl": "texto com url",
    "bitbybit.advanced.text3d.createWithUrl_description": "Cria um texto 3D com um URL de fonte. Isso é útil quando você deseja usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada a partir do URL fornecido e usada para gerar o texto 3D. Certifique-se de que as fontes não contenham autointerseção e outros caracteres ruins - esse é um problema comum com fontes personalizadas. Os formatos de fonte suportados são: ttf, otf, woff. Observe que o Woff2 não é suportado pelo opentype.js, pois é um formato compactado.",
    "fontUrl": "url da fonte",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "texto na face url",
    "createTextOnFaceUrl": "texto na face url",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Cria um texto 3D na face usando um URL de fonte. Isso é útil quando você deseja usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada a partir do URL fornecido e usada para gerar o texto 3D. Certifique-se de que as fontes não contenham autointerseção e outros caracteres ruins - esse é um problema comum com fontes personalizadas. Os formatos de fonte suportados são: ttf, otf, woff. Observe que o Woff2 não é suportado pelo opentype.js, pois é um formato compactado.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "textos na face url",
    "createTextsOnFaceUrl": "textos na face url",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Cria textos 3D na face a partir de várias definições de URL. Isso é útil quando você deseja usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada a partir do URL fornecido e usada para gerar o texto 3D. Certifique-se de que as fontes não contenham autointerseção e outros caracteres ruins - esse é um problema comum com fontes personalizadas. Os formatos de fonte suportados são: ttf, otf, woff. Observe que o Woff2 não é suportado pelo opentype.js, pois é um formato compactado.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "definição de texto 3d na face url",
    "definition3dTextOnFaceUrl": "definição de texto 3d na face url",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Cria um texto 3D que será usado na definição de URL da face. Isso é útil quando você deseja usar uma fonte personalizada que não está incluída na biblioteca. A fonte será carregada a partir do URL fornecido e usada para gerar o texto 3D. Certifique-se de que as fontes não contenham autointerseção e outros caracteres ruins - esse é um problema comum com fontes personalizadas. Os formatos de fonte suportados são: ttf, otf, woff. Observe que o Woff2 não é suportado pelo opentype.js, pois é um formato compactado.",
      "bitbybit.advanced.navigation.pointOfInterest": "ponto de interesse",
    "navigation": "navegação",
    "pointOfInterest": "ponto de interesse",
    "bitbybit.advanced.navigation.pointOfInterest_description": "nó de sobrevoo",
    "cameraTarget": "alvo da câmera",
    "cameraPosition": "posição da câmera",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "sistema de pontos de interesse",
    "pointsOfInterestSystem": "sistema de pontos de interesse",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "pontos de interesse",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "ponto de interesse",
    "style": "estilo",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "estilo de ponto de interesse",
    "pointOfInterestStyle": "estilo de ponto de interesse",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Criar estilo de ponto de interesse - usado para estilizar indicadores de pontos de interesse no espaço 3D. Você pode personalizar o tamanho do ponto, cor, cor ao passar o mouse, efeito de pulsação, cor e tamanho do rótulo de texto.",
    "pointSize": "tamanho do ponto",
    "pointColor": "cor do ponto",
    "hoverPointColor": "cor do ponto ao passar o mouse",
    "pulseColor": "cor da pulsação",
    "hoverPulseColor": "cor da pulsação ao passar o mouse",
    "pulseMinSize": "tamanho mín. da pulsação",
    "pulseMaxSize": "tamanho máx. da pulsação",
    "pulseThickness": "espessura da pulsação",
    "pulseSpeed": "velocidade da pulsação",
    "textColor": "cor do texto",
    "hoverTextColor": "cor do texto ao passar o mouse",
    "textSize": "tamanho do texto",
    "hideSkybox": "ocultar skybox",
    "textureUrl": "URL da textura",
    "hdrTexture": "textura HDR",
    "textureSize": "tamanho da textura",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "habilitar textura personalizada do skybox",
    "enableSkyboxCustomTexture": "habilitar textura personalizada do skybox",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Habilita o skybox com uma textura personalizada",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "imagem de fundo CSS do canvas",
    "canvasCSSBackgroundImage": "imagem de fundo CSS do canvas",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Altera o fundo da cena para uma imagem de fundo CSS para o espaço 3D",
    "cssBackgroundImage": "imagem de fundo CSS",
    "bitbybit.babylon.scene.twoColorLinearGradient": "gradiente linear de duas cores",
    "twoColorLinearGradient": "gradiente linear de duas cores",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Cria um fundo de gradiente linear de duas cores para o espaço 3D",
    "colorFrom": "cor de",
    "colorTo": "cor para",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "parada de",
    "stopTo": "parada para",
    "bitbybit.babylon.scene.twoColorRadialGradient": "gradiente radial de duas cores",
    "twoColorRadialGradient": "gradiente radial de duas cores",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Cria um fundo de gradiente radial de duas cores para o espaço 3D",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "gradiente linear multicolorido",
    "multiColorLinearGradient": "gradiente linear multicolorido",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Cria um fundo de gradiente linear multicolorido para o espaço 3D",
    "Base.Color[]": "Base.Color[]",
    "stops": "paradas",
    "bitbybit.babylon.scene.multiColorRadialGradient": "gradiente radial multicolorido",
    "multiColorRadialGradient": "gradiente radial multicolorido",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Cria um fundo de gradiente radial multicolorido para o espaço 3D",
    "bitbybit.babylon.scene.canvasBackgroundImage": "imagem de fundo do canvas",
    "canvasBackgroundImage": "imagem de fundo do canvas",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Define uma imagem de fundo com várias opções de personalização para o espaço 3D",
    "imageUrl": "URL da imagem",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "anexo",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "recorte",
    "labelRotation": "rotação da etiqueta",
    "bitbybit.advanced.dimensions.linearDimension": "dimensão linear",
    "linearDimension": "dimensão linear",
    "bitbybit.advanced.dimensions.linearDimension_description": "Cria dimensão linear - uma linha de medição entre dois pontos com linhas de extensão e etiqueta de texto. A dimensão mostra a distância entre os pontos e pode ser estilizada com DimensionStyleDto.",
    "linear dimension": "dimensão linear",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "dimensão angular",
    "angularDimension": "dimensão angular",
    "bitbybit.advanced.dimensions.angularDimension_description": "Cria dimensão angular - um arco de medição entre dois vetores de direção com linhas de extensão e etiqueta de texto. A dimensão mostra o ângulo entre as direções e pode ser estilizada com DimensionStyleDto.",
    "angular dimension": "dimensão angular",
    "centerPoint": "ponto central",
    "bitbybit.advanced.dimensions.dimensionStyle": "estilo de dimensão",
    "dimensionStyle": "estilo de dimensão",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Criar estilo de dimensão - usado para estilizar linhas de dimensão, setas e texto no espaço 3D. Você pode personalizar cores de linha, espessura, tamanho do texto, tamanho da seta e cores de fundo.",
    "dimension style": "estilo de dimensão",
    "lineColor": "cor da linha",
    "lineThickness": "espessura da linha",
    "extensionLineLength": "comprimento da linha de extensão",
    "textBackgroundColor": "cor de fundo do texto",
    "textBackgroundOpacity": "opacidade do fundo do texto",
    "arrowSize": "tamanho da seta",
    "arrowColor": "cor da seta",
    "textRenderMode": "modo de renderização do texto",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "billboard de texto",
    "occlusionCheckInterval": "intervalo de verificação de oclusão",
    "arrowTailLength": "comprimento da cauda da seta",
    "showArrows": "mostrar setas",
    "labelOverwrite": "sobrescrever etiqueta",
    "bitbybit.advanced.dimensions.radialDimension": "dimensão radial",
    "radialDimension": "dimensão radial",
    "bitbybit.advanced.dimensions.radialDimension_description": "Cria dimensão radial - uma linha de medição do centro ao perímetro mostrando raio ou diâmetro. Mostra prefixo 'R' para raio ou prefixo '⌀' para diâmetro com marca central opcional.",
    "radial dimension": "dimensão radial",
    "radiusPoint": "ponto do raio",
    "showDiameter": "mostrar diâmetro",
    "showCenterMark": "mostrar marca central",
    "bitbybit.advanced.dimensions.diametralDimension": "dimensão diametral",
    "diametralDimension": "dimensão diametral",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Cria dimensão diametral - uma linha de medição que abrange o diâmetro completo de características circulares. Mostra prefixo '⌀' com marca central opcional e setas em ambas as extremidades.",
    "diametral dimension": "dimensão diametral",
    "bitbybit.advanced.dimensions.ordinateDimension": "dimensão de ordenada",
    "ordinateDimension": "dimensão de ordenada",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Cria dimensão de ordenada - mostra coordenada X, Y ou Z de um ponto de referência com linha de chamada. Útil para anotações de coordenadas e referenciamento de dados em desenhos técnicos.",
    "ordinate dimension": "dimensão de ordenada",
    "measurementPoint": "ponto de medição",
    "referencePoint": "ponto de referência",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "mostrar linha de chamada",
    "viewMode": "modo de visualização",
    "schema": "esquema",
    "json schema": "esquema JSON",
    "metadata": "metadados",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "fundo de gradiente linear de duas cores",
    "twoColorLinearGradientBackground": "fundo de gradiente linear de duas cores",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Cria um fundo de gradiente linear de duas cores para espaço 3D",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "fundo de gradiente radial de duas cores",
    "twoColorRadialGradientBackground": "fundo de gradiente radial de duas cores",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Cria um fundo de gradiente radial de duas cores para espaço 3D",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "fundo de gradiente linear multicolorido",
    "multiColorLinearGradientBackground": "fundo de gradiente linear multicolorido",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Cria um fundo de gradiente linear multicolorido para espaço 3D",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "fundo de gradiente radial multicolorido",
    "multiColorRadialGradientBackground": "fundo de gradiente radial multicolorido",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Cria um fundo de gradiente radial multicolorido para espaço 3D",
    "textBackgroundStroke": "contorno do fundo do texto",
    "textBackgroundRadius": "raio do fundo do texto",
    "stableSize": "tamanho estável",
    "alwaysOnTop": "sempre no topo",
    "textStableSize": "tamanho de texto estável",
    "bitbybit.occt.io.shapeToDxfPaths": "forma para caminhos DXF",
    "shapeToDxfPaths": "forma para caminhos DXF",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Cria caminhos DXF a partir de uma forma OCCT. Importante - formas contendo arames devem estar no plano XZ (Y=0) para exportação DXF 2D correta.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "caminhos DXF com camada",
    "dxfPathsWithLayer": "caminhos DXF com camada",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Adiciona informações de camada e cor aos caminhos DXF",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "camada",
    "bitbybit.occt.io.dxfCreate": "criar DXF",
    "dxfCreate": "criar DXF",
    "bitbybit.occt.io.dxfCreate_description": "Monta várias partes de caminho em um arquivo DXF completo",
    "pathsParts": "partes de caminhos",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "peso da fonte do texto",
    "textPosition": "posição do texto",
    "textBackgroundStrokeThickness": "espessura do traço",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum"
}