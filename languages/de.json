{
    "bitbybit.draw.drawAnyAsyncNoReturn": "beliebig asynchron ohne Rückgabe zeichnen",
    "bitbybit": "bitbybit",
    "draw": "zeichnen",
    "drawAnyAsyncNoReturn": "beliebig asynchron ohne Rückgabe zeichnen",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "zeichnet beliebige Geometrie ohne Rückgabe",
    "draw async": "asynchron zeichnen",
    "entity": "Entität",
    "Entity": "Entität",
    "options": "Optionen",
    "DrawOptions": "Zeichenoptionen",
    "babylonMesh": "Babylon-Mesh",
    "BABYLON.Mesh | BABYLON.LinesMesh": "Babylon-Mesh oder Linien-Mesh",
    "bitbybit.draw.drawAnyAsync": "beliebig asynchron zeichnen",
    "drawAnyAsync": "beliebig asynchron zeichnen",
    "bitbybit.draw.drawAnyAsync_description": "zeichnet beliebige Geometrie und gibt Babylon-Mesh zurück",
    "bitbybit.draw.drawAnyNoReturn": "beliebig ohne Rückgabe zeichnen",
    "drawAnyNoReturn": "beliebig ohne Rückgabe zeichnen",
    "bitbybit.draw.drawAnyNoReturn_description": "zeichnet synchrone Geometrie, nicht für OCCT- oder JSCAD-Formen",
    "draw sync": "synchron zeichnen",
    "bitbybit.draw.drawAny": "beliebig zeichnen",
    "drawAny": "beliebig zeichnen",
    "bitbybit.draw.drawAny_description": "zeichnet synchrone Geometrie, nicht für OCCT- oder JSCAD-Formen",
    "bitbybit.draw.drawGridMeshNoReturn": "Gitter-Mesh ohne Rückgabe zeichnen",
    "drawGridMeshNoReturn": "Gitter-Mesh ohne Rückgabe zeichnen",
    "bitbybit.draw.drawGridMeshNoReturn_description": "zeichnet Gitter-Mesh auf dem Boden zur Orientierungshilfe",
    "grid": "Gitter",
    "width": "Breite",
    "number": "Nummer",
    "height": "Höhe",
    "subdivisions": "Unterteilungen",
    "majorUnitFrequency": "Haupteinheitsfrequenz",
    "minorUnitVisibility": "Sichtbarkeit kleiner Einheiten",
    "gridRatio": "Gitterverhältnis",
    "opacity": "Deckkraft",
    "backFaceCulling": "Rückseitenentfernung",
    "boolean": "Boolesch",
    "mainColor": "Hauptfarbe",
    "Base.Color": "Basisfarbe",
    "secondaryColor": "Sekundärfarbe",
    "bitbybit.draw.drawGridMesh": "Gitter-Mesh zeichnen",
    "drawGridMesh": "Gitter-Mesh zeichnen",
    "bitbybit.draw.drawGridMesh_description": "zeichnet Gitter-Mesh auf dem Boden zur Orientierungshilfe",
    "bitbybit.draw.optionsSimple": "einfache Optionen",
    "optionsSimple": "einfache Optionen",
    "bitbybit.draw.optionsSimple_description": "legt Zeichenoptionen für einfache Geometrien wie Punkte und Linien fest",
    "colours": "Farben",
    "string | string[]": "Zeichenkette oder Zeichenketten-Array",
    "size": "Größe",
    "updatable": "aktualisierbar",
    "hidden": "versteckt",
    "bitbybit.draw.optionsOcctShape": "OCCT-Form-Optionen",
    "optionsOcctShape": "OCCT-Form-Optionen",
    "bitbybit.draw.optionsOcctShape_description": "legt Zeichenoptionen für OCCT-Formen wie Kanten und Festkörper fest",
    "faceOpacity": "Flächen-Deckkraft",
    "edgeOpacity": "Kanten-Deckkraft",
    "edgeColour": "Kantenfarbe",
    "faceColour": "Flächenfarbe",
    "vertexColour": "Eckpunktfarbe",
    "faceMaterial": "Flächenmaterial",
    "Base.Material": "Basismaterial",
    "edgeWidth": "Kantenbreite",
    "vertexSize": "Eckpunktgröße",
    "drawEdges": "Kanten zeichnen",
    "drawFaces": "Flächen zeichnen",
    "drawVertices": "Eckpunkte zeichnen",
    "precision": "Präzision",
    "drawEdgeIndexes": "Kantenindizes zeichnen",
    "edgeIndexHeight": "Kantenindexhöhe",
    "edgeIndexColour": "Kantenindexfarbe",
    "drawFaceIndexes": "Flächenindizes zeichnen",
    "faceIndexHeight": "Flächenindexhöhe",
    "faceIndexColour": "Flächenindexfarbe",
    "bitbybit.draw.optionsOcctShapeSimple": "einfache OCCT-Form-Optionen",
    "optionsOcctShapeSimple": "einfache OCCT-Form-Optionen",
    "bitbybit.draw.optionsOcctShapeSimple_description": "legt einfache Zeichenoptionen für OCCT-Formen fest",
    "bitbybit.draw.optionsOcctShapeMaterial": "OCCT-Form-Material-Optionen",
    "optionsOcctShapeMaterial": "OCCT-Form-Material-Optionen",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "legt Zeichenoptionen mit benutzerdefiniertem Flächenmaterial für OCCT-Formen fest",
    "any": "beliebig",
    "bitbybit.draw.optionsManifoldShapeMaterial": "Mannigfaltigkeits-Form-Material-Optionen",
    "optionsManifoldShapeMaterial": "Mannigfaltigkeits-Form-Material-Optionen",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "legt Zeichenoptionen für Mannigfaltigkeitsgeometrie fest",
    "crossSectionColour": "Querschnittsfarbe",
    "crossSectionWidth": "Querschnittsbreite",
    "crossSectionOpacity": "Querschnittsdeckkraft",
    "computeNormals": "Normalen berechnen",
    "bitbybit.draw.optionsBabylonNode": "Babylon-Knoten-Optionen",
    "optionsBabylonNode": "Babylon-Knoten-Optionen",
    "bitbybit.draw.optionsBabylonNode_description": "legt Zeichenoptionen für Babylon.js-Knoten fest",
    "colorX": "Farbe X",
    "colorY": "Farbe Y",
    "colorZ": "Farbe Z",
    "bitbybit.babylon.mesh.dispose": "Mesh entsorgen",
    "babylon": "Babylon",
    "mesh": "Mesh",
    "dispose": "entsorgen",
    "bitbybit.babylon.mesh.dispose_description": "entfernt gezeichnetes Mesh aus der Szene",
    "memory": "Speicher",
    "BABYLON.Mesh": "Babylon-Mesh",
    "bitbybit.babylon.mesh.updateDrawn": "gezeichnetes aktualisieren",
    "updateDrawn": "gezeichnetes aktualisieren",
    "bitbybit.babylon.mesh.updateDrawn_description": "aktualisiert Babylon.js-Mesh ohne Entsorgung",
    "updates": "Aktualisierungen",
    "position": "Position",
    "Base.Point3": "Basispunkt 3",
    "rotation": "Rotation",
    "Base.Vector3": "Basisvektor 3",
    "scaling": "Skalierung",
    "bitbybit.babylon.mesh.setVisibility": "Sichtbarkeit festlegen",
    "setVisibility": "Sichtbarkeit festlegen",
    "bitbybit.babylon.mesh.setVisibility_description": "ändert die Sichtbarkeit von Babylon.js-Mesh",
    "visibility": "Sichtbarkeit",
    "includeChildren": "Kinder einbeziehen",
    "bitbybit.babylon.mesh.hide": "verstecken",
    "hide": "verstecken",
    "bitbybit.babylon.mesh.hide_description": "versteckt das Mesh",
    "bitbybit.babylon.mesh.show": "anzeigen",
    "show": "anzeigen",
    "bitbybit.babylon.mesh.show_description": "zeigt das Mesh",
    "bitbybit.babylon.mesh.setParent": "Elternteil festlegen",
    "setParent": "Elternteil festlegen",
    "bitbybit.babylon.mesh.setParent_description": "ändert den Elternteil des gezeichneten Mesh",
    "set": "festlegen",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "Babylon-Mesh oder instanziertes Mesh oder abstraktes Mesh",
    "parentMesh": "Eltern-Mesh",
    "bitbybit.babylon.mesh.getParent": "Elternteil abrufen",
    "getParent": "Elternteil abrufen",
    "bitbybit.babylon.mesh.getParent_description": "ruft den Elternteil des gezeichneten Mesh ab",
    "get": "abrufen",
    "bitbybit.babylon.mesh.setCheckCollisions": "Kollisionsprüfung festlegen",
    "setCheckCollisions": "Kollisionsprüfung festlegen",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "ändert die Kollisionsprüfungseigenschaft des gezeichneten Mesh",
    "checkCollisions": "Kollisionen prüfen",
    "bitbybit.babylon.mesh.getCheckCollisions": "Kollisionsprüfung abrufen",
    "getCheckCollisions": "Kollisionsprüfung abrufen",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "ruft die Kollisionsprüfungseigenschaft des gezeichneten Mesh ab",
    "bitbybit.babylon.mesh.setPickable": "Auswählbar festlegen",
    "setPickable": "Auswählbar festlegen",
    "bitbybit.babylon.mesh.setPickable_description": "ändert die Auswählbarkeitseigenschaft des gezeichneten Mesh",
    "pickable": "auswählbar",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "Zeigerbewegungsereignisse aktivieren",
    "enablePointerMoveEvents": "Zeigerbewegungsereignisse aktivieren",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "macht das Mesh durch Zeigerbewegungsereignisse auswählbar, leistungsschwer",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "Zeigerbewegungsereignisse deaktivieren",
    "disablePointerMoveEvents": "Zeigerbewegungsereignisse deaktivieren",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "lässt das Mesh Zeigerbewegungsereignisse ignorieren",
    "bitbybit.babylon.mesh.getPickable": "Auswählbar abrufen",
    "getPickable": "Auswählbar abrufen",
    "bitbybit.babylon.mesh.getPickable_description": "ruft die Auswählbarkeitseigenschaft des gezeichneten Mesh ab",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "Meshes abrufen, deren Name enthält",
    "getMeshesWhereNameContains": "Meshes abrufen, deren Name enthält",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "ruft Meshes mit Namen ab, die den gegebenen Text enthalten",
    "name": "Name",
    "string": "Zeichenkette",
    "bitbybit.babylon.mesh.getChildMeshes": "Kind-Meshes abrufen",
    "getChildMeshes": "Kind-Meshes abrufen",
    "bitbybit.babylon.mesh.getChildMeshes_description": "ruft Kind-Meshes ab",
    "directDescendantsOnly": "nur direkte Nachkommen",
    "bitbybit.babylon.mesh.getMeshesOfId": "Meshes nach ID abrufen",
    "getMeshesOfId": "Meshes nach ID abrufen",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "ruft Meshes nach ID ab",
    "id": "ID",
    "bitbybit.babylon.mesh.getMeshOfId": "Mesh nach ID abrufen",
    "getMeshOfId": "Mesh nach ID abrufen",
    "bitbybit.babylon.mesh.getMeshOfId_description": "ruft Mesh nach ID ab",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "Mesh nach eindeutiger ID abrufen",
    "getMeshOfUniqueId": "Mesh nach eindeutiger ID abrufen",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "ruft Mesh nach eindeutiger ID ab",
    "uniqueId": "eindeutige ID",
    "bitbybit.babylon.mesh.mergeMeshes": "Meshes zusammenführen",
    "mergeMeshes": "Meshes zusammenführen",
    "bitbybit.babylon.mesh.mergeMeshes_description": "führt mehrere Meshes zu einem zusammen",
    "edit": "bearbeiten",
    "arrayOfMeshes": "Array von Meshes",
    "BABYLON.Mesh[]": "Babylon-Mesh-Array",
    "disposeSource": "Quelle entsorgen",
    "allow32BitsIndices": "32-Bit-Indizes erlauben",
    "meshSubclass": "Mesh-Unterklasse",
    "subdivideWithSubMeshes": "mit Sub-Meshes unterteilen",
    "multiMultiMaterials": "Multi-Multi-Materialien",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "in flach beschattetes Mesh konvertieren",
    "convertToFlatShadedMesh": "in flach beschattetes Mesh konvertieren",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "konvertiert Mesh in flach beschattetes Mesh",
    "bitbybit.babylon.mesh.clone": "klonen",
    "clone": "klonen",
    "bitbybit.babylon.mesh.clone_description": "klont das Mesh",
    "bitbybit.babylon.mesh.cloneToPositions": "zu Positionen klonen",
    "cloneToPositions": "zu Positionen klonen",
    "bitbybit.babylon.mesh.cloneToPositions_description": "klont Mesh zu mehreren Positionen",
    "positions": "Positionen",
    "Base.Point3[]": "Basispunkt-3-Array",
    "bitbybit.babylon.mesh.setId": "ID festlegen",
    "setId": "ID festlegen",
    "bitbybit.babylon.mesh.setId_description": "ändert die ID des gezeichneten Mesh",
    "bitbybit.babylon.mesh.getId": "ID abrufen",
    "getId": "ID abrufen",
    "bitbybit.babylon.mesh.getId_description": "ruft die ID des gezeichneten Mesh ab",
    "bitbybit.babylon.mesh.getUniqueId": "eindeutige ID abrufen",
    "getUniqueId": "eindeutige ID abrufen",
    "bitbybit.babylon.mesh.getUniqueId_description": "ruft die eindeutige ID des gezeichneten Mesh ab",
    "bitbybit.babylon.mesh.setName": "Name festlegen",
    "setName": "Name festlegen",
    "bitbybit.babylon.mesh.setName_description": "ändert den Namen des gezeichneten Mesh",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "Eckpunkte als Polygonpunkte abrufen",
    "getVerticesAsPolygonPoints": "Eckpunkte als Polygonpunkte abrufen",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "ruft Eckpunkte als Polygonpunkte für den Mesh-Aufbau ab, erfordert Triangulierung",
    "bitbybit.babylon.mesh.getName": "Namen abrufen",
    "getName": "Namen abrufen",
    "bitbybit.babylon.mesh.getName_description": "ruft den Namen des Babylon-Mesh ab",
    "bitbybit.babylon.mesh.setMaterial": "Material festlegen",
    "setMaterial": "Material festlegen",
    "bitbybit.babylon.mesh.setMaterial_description": "ändert das Material des gezeichneten Mesh",
    "material": "Material",
    "BABYLON.Material": "Babylon-Material",
    "bitbybit.babylon.mesh.getMaterial": "Material abrufen",
    "getMaterial": "Material abrufen",
    "bitbybit.babylon.mesh.getMaterial_description": "ruft das Material des Babylon-Mesh ab",
    "bitbybit.babylon.mesh.getPosition": "Position abrufen",
    "getPosition": "Position abrufen",
    "bitbybit.babylon.mesh.getPosition_description": "ruft die Position als Punkt des Babylon.js-Mesh ab",
    "bitbybit.babylon.mesh.getAbsolutePosition": "absolute Position abrufen",
    "getAbsolutePosition": "absolute Position abrufen",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "ruft die absolute Position in der Welt als Punkt des Babylon.js-Mesh ab",
    "bitbybit.babylon.mesh.getRotation": "Rotation abrufen",
    "getRotation": "Rotation abrufen",
    "bitbybit.babylon.mesh.getRotation_description": "ruft den Rotationsvektor des Babylon.js-Mesh ab",
    "bitbybit.babylon.mesh.getScale": "Skalierung abrufen",
    "getScale": "Skalierung abrufen",
    "bitbybit.babylon.mesh.getScale_description": "ruft den Skalierungsvektor des Babylon.js-Mesh ab",
    "bitbybit.babylon.mesh.moveForward": "vorwärts bewegen",
    "moveForward": "vorwärts bewegen",
    "bitbybit.babylon.mesh.moveForward_description": "bewegt das Babylon.js-Mesh im lokalen Raum vorwärts",
    "move": "bewegen",
    "distance": "Entfernung",
    "bitbybit.babylon.mesh.moveBackward": "rückwärts bewegen",
    "moveBackward": "rückwärts bewegen",
    "bitbybit.babylon.mesh.moveBackward_description": "bewegt das Babylon.js-Mesh im lokalen Raum rückwärts",
    "bitbybit.babylon.mesh.moveUp": "nach oben bewegen",
    "moveUp": "nach oben bewegen",
    "bitbybit.babylon.mesh.moveUp_description": "bewegt das Babylon.js-Mesh im lokalen Raum nach oben",
    "bitbybit.babylon.mesh.moveDown": "nach unten bewegen",
    "moveDown": "nach unten bewegen",
    "bitbybit.babylon.mesh.moveDown_description": "bewegt das Babylon.js-Mesh im lokalen Raum nach unten",
    "bitbybit.babylon.mesh.moveRight": "nach rechts bewegen",
    "moveRight": "nach rechts bewegen",
    "bitbybit.babylon.mesh.moveRight_description": "bewegt das Babylon.js-Mesh im lokalen Raum nach rechts",
    "bitbybit.babylon.mesh.moveLeft": "nach links bewegen",
    "moveLeft": "nach links bewegen",
    "bitbybit.babylon.mesh.moveLeft_description": "bewegt das Babylon.js-Mesh im lokalen Raum nach links",
    "bitbybit.babylon.mesh.yaw": "Gieren",
    "yaw": "Gieren",
    "bitbybit.babylon.mesh.yaw_description": "rotiert das Babylon.js-Mesh um die lokale Y-Achse",
    "rotate": "rotieren",
    "bitbybit.babylon.mesh.pitch": "Nicken",
    "pitch": "Nicken",
    "bitbybit.babylon.mesh.pitch_description": "rotiert das Babylon.js-Mesh um die lokale X-Achse",
    "bitbybit.babylon.mesh.roll": "Rollen",
    "roll": "Rollen",
    "bitbybit.babylon.mesh.roll_description": "rotiert das Babylon.js-Mesh um die lokale Z-Achse",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "um Achse mit Position rotieren",
    "rotateAroundAxisWithPosition": "um Achse mit Position rotieren",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "rotiert das Mesh um Achse und Position um einen Winkel",
    "axis": "Achse",
    "angle": "Winkel",
    "bitbybit.babylon.mesh.setPosition": "Position festlegen",
    "setPosition": "Position festlegen",
    "bitbybit.babylon.mesh.setPosition_description": "aktualisiert die Position des Babylon.js-Mesh oder instanzierten Mesh",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "Babylon-Mesh oder instanziertes Mesh",
    "bitbybit.babylon.mesh.setRotation": "Rotation festlegen",
    "setRotation": "Rotation festlegen",
    "bitbybit.babylon.mesh.setRotation_description": "aktualisiert die Rotation des Babylon.js-Mesh oder instanzierten Mesh",
    "bitbybit.babylon.mesh.setScale": "Skalierung festlegen",
    "setScale": "Skalierung festlegen",
    "bitbybit.babylon.mesh.setScale_description": "aktualisiert die Skalierung des Babylon.js-Mesh oder instanzierten Mesh",
    "scale": "Skalierung",
    "bitbybit.babylon.mesh.intersectsMesh": "Mesh schneidet",
    "intersectsMesh": "Mesh schneidet",
    "bitbybit.babylon.mesh.intersectsMesh_description": "prüft, ob das Mesh ein anderes Mesh schneidet",
    "intersects": "schneidet",
    "babylonMesh2": "Babylon-Mesh 2",
    "precise": "präzise",
    "includeDescendants": "Nachkommen einbeziehen",
    "bitbybit.babylon.mesh.intersectsPoint": "Punkt schneidet",
    "intersectsPoint": "Punkt schneidet",
    "bitbybit.babylon.mesh.intersectsPoint_description": "prüft, ob das Mesh einen Punkt schneidet",
    "point": "Punkt",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "Mesh-Instanz und Transformation ohne Rückgabe erstellen",
    "createMeshInstanceAndTransformNoReturn": "Mesh-Instanz und Transformation ohne Rückgabe erstellen",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "erstellt Mesh-Instanz mit Kindern für optimiertes Rendering, keine Rückgabe",
    "instance": "Instanz",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "Mesh-Instanz und Transformation erstellen",
    "createMeshInstanceAndTransform": "Mesh-Instanz und Transformation erstellen",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "erstellt Mesh-Instanz mit Kindern für optimiertes Rendering, gibt Mesh zurück",
    "bitbybit.babylon.mesh.createMeshInstance": "Mesh-Instanz erstellen",
    "createMeshInstance": "Mesh-Instanz erstellen",
    "bitbybit.babylon.mesh.createMeshInstance_description": "erstellt Mesh-Instanz für optimiertes Rendering mit Kindern",
    "bitbybit.babylon.gaussianSplatting.create": "Gaussian Splatting",
    "gaussianSplatting": "Gaussian Splatting",
    "create": "erstellen",
    "bitbybit.babylon.gaussianSplatting.create_description": "erstellt Gaussian Splatting Mesh",
    "url": "URL",
    "bitbybit.babylon.gaussianSplatting.clone": "Gaussian Splatting klonen",
    "bitbybit.babylon.gaussianSplatting.clone_description": "klont Gaussian Splatting Mesh",
    "multiply": "multiplizieren",
    "BABYLON.GaussianSplattingMesh": "Babylon Gaussian Splatting Mesh",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "Splat-Positionen abrufen",
    "getSplatPositions": "Splat-Positionen abrufen",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "ruft Splat-Positionen des Gaussian Splatting Mesh ab",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "Projektionsmatrix einfrieren",
    "camera": "Kamera",
    "freezeProjectionMatrix": "Projektionsmatrix einfrieren",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "friert die Projektionsmatrix der Kamera ein",
    "adjust": "anpassen",
    "BABYLON.Camera": "Babylon-Kamera",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "Projektionsmatrix freigeben",
    "unfreezeProjectionMatrix": "Projektionsmatrix freigeben",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "gibt die Projektionsmatrix der Kamera frei",
    "bitbybit.babylon.camera.setPosition": "Position festlegen",
    "bitbybit.babylon.camera.setPosition_description": "ändert die Kameraposition",
    "BABYLON.TargetCamera": "Babylon-Zielkamera",
    "bitbybit.babylon.camera.getPosition": "Position abrufen",
    "bitbybit.babylon.camera.getPosition_description": "ruft die Kameraposition ab",
    "bitbybit.babylon.camera.setTarget": "Ziel festlegen",
    "setTarget": "Ziel festlegen",
    "bitbybit.babylon.camera.setTarget_description": "ändert das Kameraziel",
    "target": "Ziel",
    "bitbybit.babylon.camera.getTarget": "Ziel abrufen",
    "getTarget": "Ziel abrufen",
    "bitbybit.babylon.camera.getTarget_description": "ruft das Kameraziel ab",
    "bitbybit.babylon.camera.setSpeed": "Geschwindigkeit festlegen",
    "setSpeed": "Geschwindigkeit festlegen",
    "bitbybit.babylon.camera.setSpeed_description": "ändert die Kamerageschwindigkeit",
    "speed": "Geschwindigkeit",
    "bitbybit.babylon.camera.getSpeed": "Geschwindigkeit abrufen",
    "getSpeed": "Geschwindigkeit abrufen",
    "bitbybit.babylon.camera.getSpeed_description": "ruft die Kamerageschwindigkeit ab",
    "bitbybit.babylon.camera.setMinZ": "Min Z festlegen",
    "setMinZ": "Min Z festlegen",
    "bitbybit.babylon.camera.setMinZ_description": "ändert das minimale Z der Kamera",
    "minZ": "Min Z",
    "bitbybit.babylon.camera.setMaxZ": "Max Z festlegen",
    "setMaxZ": "Max Z festlegen",
    "bitbybit.babylon.camera.setMaxZ_description": "ändert das maximale Z der Kamera",
    "maxZ": "Max Z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "Kamera orthografisch machen",
    "makeCameraOrthographic": "Kamera orthografisch machen",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "setzt die Kamera in den orthografischen Modus",
    "orthoLeft": "Ortho links",
    "orthoRight": "Ortho rechts",
    "orthoBottom": "Ortho unten",
    "orthoTop": "Ortho oben",
    "bitbybit.babylon.camera.makeCameraPerspective": "Kamera perspektivisch machen",
    "makeCameraPerspective": "Kamera perspektivisch machen",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "setzt die Kamera in den perspektivischen Modus",
    "bitbybit.babylon.camera.free.create": "freie Kamera",
    "free": "frei",
    "bitbybit.babylon.camera.free.create_description": "erstellt eine freie Kamera",
    "bitbybit.babylon.camera.arcRotate.create": "Bogenrotationskamera",
    "arcRotate": "Bogenrotation",
    "bitbybit.babylon.camera.arcRotate.create_description": "erstellt eine Kamera, die sich auf einem Bogenpfad um das Ziel dreht, Standard für bitbybit",
    "radius": "Radius",
    "alpha": "Alpha",
    "beta": "Beta",
    "lowerRadiusLimit": "unterer Radiusgrenzwert",
    "upperRadiusLimit": "oberer Radiusgrenzwert",
    "lowerAlphaLimit": "unterer Alphagrenzwert",
    "upperAlphaLimit": "oberer Alphagrenzwert",
    "lowerBetaLimit": "unterer Betagrenzwert",
    "upperBetaLimit": "oberer Betagrenzwert",
    "angularSensibilityX": "Winkelempfindlichkeit X",
    "angularSensibilityY": "Winkelempfindlichkeit Y",
    "panningSensibility": "Schwenkempfindlichkeit",
    "wheelPrecision": "Radpräzision",
    "bitbybit.babylon.camera.target.create": "Zielkamera",
    "bitbybit.babylon.camera.target.create_description": "erstellt eine Zielkamera",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "immersives AR-Erlebnis",
    "webXr": "Web XR",
    "simple": "einfach",
    "createImmersiveARExperience": "immersives AR-Erlebnis",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "erstellt ein standardmäßiges XR-Erlebnis im immersiven AR-Modus",
    "scene": "Szene",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "Standard-XR-Erlebnis mit Teleportation",
    "createDefaultXRExperienceWithTeleportation": "Standard-XR-Erlebnis mit Teleportation",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "erstellt ein einfaches XR-Erlebnis mit Teleportation",
    "groundMeshes": "Boden-Meshes",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "Standard-XR-Erlebnis mit Teleportation Rück traced",
    "createDefaultXRExperienceWithTeleportationReturn": "Standard-XR-Erlebnis mit Teleportation Rückgabe",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "erstellt ein einfaches XR-Erlebnis mit Teleportation, gibt Ergebnis zurück",
    "bitbybit.babylon.node.drawNode": "Knoten zeichnen",
    "node": "Knoten",
    "drawNode": "Knoten zeichnen",
    "bitbybit.babylon.node.drawNode_description": "zeichnet Knoten mit Größe und Achsenfarben",
    "BABYLON.TransformNode": "Babylon-Transformationsknoten",
    "bitbybit.babylon.node.drawNodes": "Knoten zeichnen",
    "drawNodes": "Knoten zeichnen",
    "bitbybit.babylon.node.drawNodes_description": "zeichnet mehrere Knoten mit Größe und Achsenfarben",
    "nodes": "Knoten",
    "BABYLON.TransformNode[]": "Babylon-Transformationsknoten-Array",
    "bitbybit.babylon.node.createNodeFromRotation": "Knoten aus Rotation erstellen",
    "createNodeFromRotation": "Knoten aus Rotation erstellen",
    "bitbybit.babylon.node.createNodeFromRotation_description": "erstellt Knoten am Ursprung mit Rotationen im Elternraum",
    "parent": "Elternteil",
    "BABYLON.TransformNode | null": "Babylon-Transformationsknoten oder null",
    "origin": "Ursprung",
    "bitbybit.babylon.node.createWorldNode": "Welknoten",
    "createWorldNode": "Welknoten",
    "bitbybit.babylon.node.createWorldNode_description": "erstellt Knoten mit Wurzel als Elternteil",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "absoluten Vorwärtsvektor abrufen",
    "getAbsoluteForwardVector": "absoluten Vorwärtsvektor abrufen",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "ruft absoluten Vorwärtsvektor im Weltraum ab",
    "bitbybit.babylon.node.getAbsoluteRightVector": "absoluten Rechtsvektor abrufen",
    "getAbsoluteRightVector": "absoluten Rechtsvektor abrufen",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "ruft absoluten Rechtsvektor im Weltraum ab",
    "bitbybit.babylon.node.getAbsoluteUpVector": "absoluten Aufwärtsvektor abrufen",
    "getAbsoluteUpVector": "absoluten Aufwärtsvektor abrufen",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "ruft absoluten Aufwärtsvektor im Weltraum ab",
    "bitbybit.babylon.node.getAbsolutePosition": "absolute Position abrufen",
    "bitbybit.babylon.node.getAbsolutePosition_description": "ruft absolute Position des Knotens im Weltraum ab",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "absolute Rotationstransformation abrufen",
    "getAbsoluteRotationTransformation": "absolute Rotationstransformation abrufen",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "ruft absolute Rotation als Transformationsmatrix ab (16 Zahlen)",
    "bitbybit.babylon.node.getRotationTransformation": "Rotationstransformation abrufen",
    "getRotationTransformation": "Rotationstransformation abrufen",
    "bitbybit.babylon.node.getRotationTransformation_description": "ruft lokale Rotation als Transformationsmatrix ab (16 Zahlen)",
    "bitbybit.babylon.node.getChildren": "Kinder abrufen",
    "getChildren": "Kinder abrufen",
    "bitbybit.babylon.node.getChildren_description": "ruft Kinder des Knotens ab",
    "bitbybit.babylon.node.getParent": "Elternteil abrufen",
    "bitbybit.babylon.node.getParent_description": "ruft Elternteil des Knotens ab",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "Position im lokalen Raum abrufen",
    "getPositionExpressedInLocalSpace": "Position im lokalen Raum abrufen",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "ruft die Knotenposition im lokalen Raum ab",
    "bitbybit.babylon.node.getRootNode": "Wurzelknoten abrufen",
    "getRootNode": "Wurzelknoten abrufen",
    "bitbybit.babylon.node.getRootNode_description": "ruft Wurzelknoten ab",
    "bitbybit.babylon.node.getRotation": "Rotation abrufen",
    "bitbybit.babylon.node.getRotation_description": "ruft Euler-Rotationen des Knotens ab",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "um Achse mit Position rotieren",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "rotiert Knoten um Achse und Position um einen Winkel",
    "bitbybit.babylon.node.rotate": "rotieren",
    "bitbybit.babylon.node.rotate_description": "rotiert Knoten um Ursprung und Achse",
    "bitbybit.babylon.node.setAbsolutePosition": "absolute Position festlegen",
    "setAbsolutePosition": "absolute Position festlegen",
    "bitbybit.babylon.node.setAbsolutePosition_description": "setzt absolute Position des Knotens",
    "bitbybit.babylon.node.setDirection": "Richtung festlegen",
    "setDirection": "Richtung festlegen",
    "bitbybit.babylon.node.setDirection_description": "setzt Richtung des Knotens",
    "direction": "Richtung",
    "number[]": "Zahlen-Array",
    "bitbybit.babylon.node.setParent": "Elternteil festlegen",
    "bitbybit.babylon.node.setParent_description": "setzt neuen Elternteil für Knoten",
    "parentNode": "Elternknoten",
    "bitbybit.babylon.node.translate": "verschieben",
    "translate": "verschieben",
    "bitbybit.babylon.node.translate_description": "verschiebt Knoten um Richtungsvektor und Entfernung",
    "bitbybit.babylon.scene.backgroundColour": "Hintergrundfarbe",
    "backgroundColour": "Hintergrundfarbe",
    "bitbybit.babylon.scene.backgroundColour_description": "ändert die Hintergrundfarbe der Szene im 3D-Raum",
    "environment": "Umgebung",
    "colour": "Farbe",
    "bitbybit.babylon.scene.activateCamera": "Kamera aktivieren",
    "activateCamera": "Kamera aktivieren",
    "bitbybit.babylon.scene.activateCamera_description": "setzt die Kamera als aktiv, ersetzt die aktuelle",
    "bitbybit.babylon.scene.useRightHandedSystem": "rechtshändiges System verwenden",
    "useRightHandedSystem": "rechtshändiges System verwenden",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "wechselt zum rechtshändigen Koordinatensystem",
    "system": "System",
    "use": "verwenden",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "Punktlicht ohne Rückgabe zeichnen",
    "drawPointLightNoReturn": "Punktlicht ohne Rückgabe zeichnen",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "fügt der Szene ein Punktlicht hinzu, keine Ausgabe",
    "lights": "Lichter",
    "intensity": "Intensität",
    "diffuse": "Diffus",
    "specular": "Spekular",
    "shadowGeneratorMapSize": "Schattengeneratorkartengröße",
    "enableShadows": "Schatten aktivieren",
    "shadowDarkness": "Schattendunkelheit",
    "shadowUsePercentageCloserFiltering": "Schattenprozentsatz näher filtern",
    "shadowContactHardeningLightSizeUVRatio": "Schattenkontakthärtung Lichtgröße UV-Verhältnis",
    "shadowBias": "Schattenbias",
    "shadowNormalBias": "Schattennormalbias",
    "shadowMaxZ": "Schatten Max Z",
    "shadowMinZ": "Schatten Min Z",
    "bitbybit.babylon.scene.getShadowGenerators": "Schattengeneratoren abrufen",
    "getShadowGenerators": "Schattengeneratoren abrufen",
    "bitbybit.babylon.scene.getShadowGenerators_description": "ruft Schattengeneratoren von bitbybit-Lichtern ab",
    "bitbybit.babylon.scene.drawPointLight": "Punktlicht zeichnen",
    "drawPointLight": "Punktlicht zeichnen",
    "bitbybit.babylon.scene.drawPointLight_description": "fügt der Szene ein Punktlicht hinzu",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "Richtungslicht ohne Rückgabe zeichnen",
    "drawDirectionalLightNoReturn": "Richtungslicht ohne Rückgabe zeichnen",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "fügt der Szene ein Richtungslicht hinzu, keine Ausgabe",
    "bitbybit.babylon.scene.drawDirectionalLight": "Richtungslicht zeichnen",
    "drawDirectionalLight": "Richtungslicht zeichnen",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "fügt der Szene ein Richtungslicht hinzu",
    "bitbybit.babylon.scene.getActiveCamera": "aktive Kamera abrufen",
    "getActiveCamera": "aktive Kamera abrufen",
    "bitbybit.babylon.scene.getActiveCamera_description": "ruft die aktuelle aktive Kamera in der Szene ab",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "aktive Bogenrotationskamera anpassen",
    "adjustActiveArcRotateCamera": "aktive Bogenrotationskamera anpassen",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "stimmt die Einstellungen der aktiven Bogenrotationskamera ab",
    "lookAt": "anschauen",
    "bitbybit.babylon.scene.clearAllDrawn": "alles Gezeichnete löschen",
    "clearAllDrawn": "alles Gezeich Conductor löschen",
    "bitbybit.babylon.scene.clearAllDrawn_description": "entfernt alle gezeichneten Objekte aus der 3D-Szene",
    "bitbybit.babylon.scene.enableSkybox": "Himmelbox aktivieren",
    "enableSkybox": "Himmelbox aktivieren",
    "bitbybit.babylon.scene.enableSkybox_description": "schaltet die Himmelbox in der Szene ein",
    "skybox": "Himmelbox",
    "Base.skyboxEnum": "Basis-Himmelbox-Enum",
    "blur": "Unschärfe",
    "environmentIntensity": "Umgebungsintensität",
    "bitbybit.babylon.scene.fog": "Nebel",
    "fog": "Nebel",
    "bitbybit.babylon.scene.fog_description": "schaltet den Nebelmodus in der Szene ein",
    "mode": "Modus",
    "Base.fogModeEnum": "Basis-Nebelmodus-Enum",
    "color": "Farbe",
    "density": "Dichte",
    "start": "Start",
    "end": "Ende",
    "bitbybit.babylon.transforms.rotationCenterAxis": "Rotationszentrum-Achse",
    "transforms": "Transformationen",
    "rotationCenterAxis": "Rotationszentrum-Achse",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "erstellt Rotationstransformation um Zentrum und Achse",
    "center": "Zentrum",
    "bitbybit.babylon.transforms.rotationCenterX": "Rotationszentrum X",
    "rotationCenterX": "Rotationszentrum X",
    "bitbybit.babylon.transforms.rotationCenterX_description": "erstellt Rotationstransformation um Zentrum und X-Achse",
    "bitbybit.babylon.transforms.rotationCenterY": "Rotationszentrum Y",
    "rotationCenterY": "Rotationszentrum Y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "erstellt Rotationstransformation um Zentrum und Y-Achse",
    "bitbybit.babylon.transforms.rotationCenterZ": "Rotationszentrum Z",
    "rotationCenterZ": "Rotationszentrum Z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "erstellt Rotationstransformation um Zentrum und Z-Achse",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "Rotationszentrum Gieren Nicken Rollen",
    "rotationCenterYawPitchRoll": "Rotationszentrum Gieren Nicken Rollen",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "erstellt Rotationstransformation mit Gieren, Nicken, Rollen",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "Skalierungszentrum XYZ",
    "scaleCenterXYZ": "Skalierungszentrum XYZ",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "erstellt Skalierungstransformation um Zentrum in XYZ",
    "scaleXyz": "Skalierung XYZ",
    "bitbybit.babylon.transforms.scaleXYZ": "Skalierung XYZ",
    "scaleXYZ": "Skalierung XYZ",
    "bitbybit.babylon.transforms.scaleXYZ_description": "erstellt Skalierungstransformation in X-, Y-, Z-Richtungen",
    "bitbybit.babylon.transforms.uniformScale": "einheitliche Skalierung",
    "uniformScale": "einheitliche Skalierung",
    "bitbybit.babylon.transforms.uniformScale_description": "erstellt einheitliche Skalierungstransformation",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "einheitliche Skalierung vom Zentrum",
    "uniformScaleFromCenter": "einheitliche Skalierung vom Zentrum",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "erstellt einheitliche Skalierungstransformation vom Zentrum",
    "bitbybit.babylon.transforms.translationXYZ": "Verschiebung XYZ",
    "translationXYZ": "Verschiebung XYZ",
    "bitbybit.babylon.transforms.translationXYZ_description": "erstellt Verschiebungstransformation",
    "translation": "Verschiebung",
    "bitbybit.babylon.transforms.translationsXYZ": "Verschiebungen XYZ",
    "translationsXYZ": "Verschiebungen XYZ",
    "bitbybit.babylon.transforms.translationsXYZ_description": "erstellt mehrere Verschiebungstransformationen",
    "translations": "Verschiebungen",
    "Base.Vector3[]": "Basisvektor-3-Array",
    "bitbybit.babylon.io.loadAssetIntoScene": "Asset in Szene laden",
    "io": "IO",
    "loadAssetIntoScene": "Asset in Szene laden",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "importiert Mesh aus hochgeladenem Projektasset",
    "load": "laden",
    "assetFile": "Asset-Datei",
    "File": "Datei",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "Asset in Szene ohne Rückgabe laden",
    "loadAssetIntoSceneNoReturn": "Asset in Szene ohne Rückgabe laden",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "importiert Mesh aus hochgeladenem Projektasset, keine Ausgabe",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "Asset aus Root-URL in Szene laden",
    "loadAssetIntoSceneFromRootUrl": "Asset aus Root-URL in Szene laden",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "importiert Mesh aus öffentlicher Web-URL, erfordert CORS",
    "rootUrl": "Root-URL",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "Asset aus Root-URL in Szene ohne Rückgabe laden",
    "loadAssetIntoSceneFromRootUrlNoReturn": "Asset aus Root-URL in Szene ohne Rückgabe laden",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "importiert Mesh aus öffentlicher Web-URL, keine Ausgabe, erfordert CORS",
    "bitbybit.babylon.io.exportBabylon": "Babylon exportieren",
    "exportBabylon": "Babylon exportieren",
    "bitbybit.babylon.io.exportBabylon_description": "exportiert Szene ins .babylon-Format für die Bearbeitung",
    "export": "exportieren",
    "fileName": "Dateiname",
    "bitbybit.babylon.io.exportGLB": "GLB exportieren",
    "exportGLB": "GLB exportieren",
    "bitbybit.babylon.io.exportGLB_description": "exportiert Szene ins .glb-Format, Web-Standard",
    "discardSkyboxAndGrid": "Himmelbox und Gitter verwerfen",
    "bitbybit.babylon.io.exportMeshToStl": "Mesh nach STL exportieren",
    "exportMeshToStl": "Mesh nach STL exportieren",
    "bitbybit.babylon.io.exportMeshToStl_description": "exportiert Mesh und Kinder nach STL",
    "bitbybit.babylon.io.exportMeshesToStl": "Meshes nach STL exportieren",
    "exportMeshesToStl": "Meshes nach STL exportieren",
    "bitbybit.babylon.io.exportMeshesToStl_description": "exportiert mehrere Meshes nach STL",
    "meshes": "Meshes",
    "bitbybit.babylon.ray.createPickingRay": "Auswahlstrahl",
    "ray": "Strahl",
    "createPickingRay": "Auswahlstrahl",
    "bitbybit.babylon.ray.createPickingRay_description": "erstellt Auswahlstrahl von der Mausposition in der aktiven Kamera",
    "bitbybit.babylon.ray.createRay": "Strahl",
    "createRay": "Strahl",
    "bitbybit.babylon.ray.createRay_description": "erstellt Strahl vom Ursprung mit Richtung und optionaler Länge",
    "length": "Länge",
    "bitbybit.babylon.ray.createRayFromTo": "Strahl von bis",
    "createRayFromTo": "Strahl von bis",
    "bitbybit.babylon.ray.createRayFromTo_description": "erstellt Strahl zwischen zwei Punkten",
    "from": "von",
    "to": "bis",
    "bitbybit.babylon.ray.getOrigin": "Ursprung abrufen",
    "getOrigin": "Ursprung abrufen",
    "bitbybit.babylon.ray.getOrigin_description": "ruft den Ursprung des Strahls ab",
    "BABYLON.Ray": "Babylon-Strahl",
    "bitbybit.babylon.ray.getDirection": "Richtung abrufen",
    "getDirection": "Richtung abrufen",
    "bitbybit.babylon.ray.getDirection_description": "ruft die Richtung des Strahls ab",
    "bitbybit.babylon.ray.getLength": "Länge abrufen",
    "getLength": "Länge abrufen",
    "bitbybit.babylon.ray.getLength_description": "ruft die Länge des Strahls ab",
    "bitbybit.babylon.pick.pickWithRay": "mit Strahl auswählen",
    "pick": "auswählen",
    "pickWithRay": "mit Strahl auswählen",
    "bitbybit.babylon.pick.pickWithRay_description": "ruft Trefferergebnis vom Strahlauswählen ab",
    "bitbybit.babylon.pick.pickWithPickingRay": "mit Auswahlstrahl auswählen",
    "pickWithPickingRay": "mit Auswahlstrahl auswählen",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "wählt mit Strahl von der Mausposition in der aktiven Kamera",
    "bitbybit.babylon.pick.getDistance": "Entfernung abrufen",
    "getDistance": "Entfernung abrufen",
    "bitbybit.babylon.pick.getDistance_description": "ruft die Entfernung zum Objekt ab, wenn ausgewählt",
    "get from pick info": "aus Auswahlinfo abrufen",
    "pickInfo": "Auswahlinfo",
    "BABYLON.PickingInfo": "Babylon-Auswahlinfo",
    "bitbybit.babylon.pick.getPickedMesh": "ausgewähltes Mesh abrufen",
    "getPickedMesh": "ausgewähltes Mesh abrufen",
    "bitbybit.babylon.pick.getPickedMesh_description": "ruft das ausgewählte Mesh ab",
    "bitbybit.babylon.pick.getPickedPoint": "ausgewählten Punkt abrufen",
    "getPickedPoint": "ausgewählten Punkt abrufen",
    "bitbybit.babylon.pick.getPickedPoint_description": "ruft den ausgewählten Punkt ab",
    "bitbybit.babylon.pick.hit": "Treffer",
    "hit": "Treffer",
    "bitbybit.babylon.pick.hit_description": "prüft, ob der Strahl etwas in der Szene trifft",
    "bitbybit.babylon.pick.getSubMeshId": "Sub-Mesh-ID abrufen",
    "getSubMeshId": "Sub-Mesh-ID abrufen",
    "bitbybit.babylon.pick.getSubMeshId_description": "ruft die eindeutige Sub-Mesh-ID ab, wenn ausgewählt",
    "bitbybit.babylon.pick.getSubMeshFaceId": "Sub-Mesh-Flächen-ID abrufen",
    "getSubMeshFaceId": "Sub-Mesh-Flächen-ID abrufen",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "ruft die eindeutige Sub-Mesh-Flächen-ID ab, wenn ausgewählt",
    "bitbybit.babylon.pick.getBU": "BU abrufen",
    "getBU": "BU abrufen",
    "bitbybit.babylon.pick.getBU_description": "ruft baryzentrisches U für Texturkollision ab",
    "bitbybit.babylon.pick.getBV": "BV abrufen",
    "getBV": "BV abrufen",
    "bitbybit.babylon.pick.getBV_description": "ruft baryzentrisches V für Texturkollision ab",
    "bitbybit.babylon.pick.getPickedSprite": "ausgewähltes Sprite abrufen",
    "getPickedSprite": "ausgewähltes Sprite abrufen",
    "bitbybit.babylon.pick.getPickedSprite_description": "ruft das ausgewählte Sprite ab",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "PBR metallische Rauheit",
    "pbrMetallicRoughness": "PBR metallische Rauheit",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "erstellt PBR metallisches Rauheitsmaterial",
    "baseColor": "Basisfarbe",
    "emissiveColor": "Emissionsfarbe",
    "metallic": "metallisch",
    "roughness": "Rauheit",
    "zOffset": "Z-Versatz",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "Basisfarbe festlegen",
    "setBaseColor": "Basisfarbe festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "setzt die Basisfarbe des Materials",
    "BABYLON.PBRMetallicRoughnessMaterial": "Babylon PBR metallisches Rauheitsmaterial",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "Metallisch festlegen",
    "setMetallic": "Metallisch festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "setzt die metallische Eigenschaft des Materials",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "Rauheit festlegen",
    "setRoughness": "Rauheit festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "legt die Materialrauhigkeit fest",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "Alpha festlegen",
    "setAlpha": "Alpha festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "legt den Material-Alpha-Wert fest",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "Rückseitenentfernung festlegen",
    "setBackFaceCulling": "Rückseitenentfernung festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "legt die Rückseitenentfernung des Materials fest",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "Basistextur festlegen",
    "setBaseTexture": "Basistextur festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "legt die Materialtextur fest",
    "baseTexture": "Basistextur",
    "BABYLON.Texture": "Babylon-Textur",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "Basisfarbe abrufen",
    "getBaseColor": "Basisfarbe abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "ruft die Basisfarbe des Materials ab",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "Metallisch abrufen",
    "getMetallic": "Metallisch abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "ruft die metallische Eigenschaft des Materials ab",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "Rauheit abrufen",
    "getRoughness": "Rauheit abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "ruft die Rauheit des Materials ab",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "Alpha abrufen",
    "getAlpha": "Alpha abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "ruft den Alpha-Wert des Materials ab",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "Rückseitenentfernung abrufen",
    "getBackFaceCulling": "Rückseitenentfernung abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "ruft die Rückseitenentfernung des Materials ab",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "Basistextur abrufen",
    "getBaseTexture": "Basistextur abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "ruft die Basistextur des Materials ab",
    "bitbybit.babylon.material.skyMaterial.create": "Himmelmaterial",
    "skyMaterial": "Himmelmaterial",
    "bitbybit.babylon.material.skyMaterial.create_description": "erstellt Himmelmaterial",
    "luminance": "Luminanz",
    "turbidity": "Trübung",
    "rayleigh": "Rayleigh",
    "mieCoefficient": "Mie-Koeffizient",
    "mieDirectionalG": "Mie-Richtung G",
    "inclination": "Neigung",
    "azimuth": "Azimut",
    "sunPosition": "Sonnenposition",
    "useSunPosition": "Sonnenposition verwenden",
    "cameraOffset": "Kameraoffset",
    "up": "nach oben",
    "dithering": "Dithering",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "Luminanz festlegen",
    "setLuminance": "Luminanz festlegen",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "legt die Luminanz des Himmelmaterials fest",
    "MATERIALS.SkyMaterial": "Materialien Himmelmaterial",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "Trübung festlegen",
    "setTurbidity": "Trübung festlegen",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "legt die Trübung des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "Rayleigh festlegen",
    "setRayleigh": "Rayleigh festlegen",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "legt den Rayleigh-Wert des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "Mie-Koeffizient festlegen",
    "setMieCoefficient": "Mie-Koeffizient festlegen",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "legt den Mie-Koeffizienten des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "Mie-Richtung G festlegen",
    "setMieDirectionalG": "Mie-Richtung G festlegen",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "legt die Mie-Richtung G des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setDistance": "Entfernung festlegen",
    "setDistance": "Entfernung festlegen",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "legt die Entfernung des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setInclination": "Neigung festlegen",
    "setInclination": "Neigung festlegen",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "legt die Neigung des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "Azimut festlegen",
    "setAzimuth": "Azimut festlegen",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "legt den Azimut des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "Sonnenposition festlegen",
    "setSunPosition": "Sonnenposition festlegen",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "legt die Sonnenposition des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "Sonnenposition verwenden festlegen",
    "setUseSunPosition": "Sonnenposition verwenden festlegen",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "legt die Verwendung der Sonnenposition des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "Kameraoffset festlegen",
    "setCameraOffset": "Kameraoffset festlegen",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "legt den Kameraoffset des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setUp": "Aufwärts festlegen",
    "setUp": "Aufwärts festlegen",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "legt die Aufwärtsrichtung des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.setDithering": "Dithering festlegen",
    "setDithering": "Dithering festlegen",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "legt das Dithering des Himmelmaterials fest",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "Luminanz abrufen",
    "getLuminance": "Luminanz abrufen",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "ruft die Luminanz des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "Trübung abrufen",
    "getTurbidity": "Trübung abrufen",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "ruft die Trübung des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "Rayleigh abrufen",
    "getRayleigh": "Rayleigh abrufen",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "ruft den Rayleigh-Wert des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "Mie-Koeffizient abrufen",
    "getMieCoefficient": "Mie-Koeffizient abrufen",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "ruft den Mie-Koeffizienten des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "Mie-Richtung G abrufen",
    "getMieDirectionalG": "Mie-Richtung G abrufen",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "ruft die Mie-Richtung G des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getDistance": "Entfernung abrufen",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "ruft die Entfernung des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getInclination": "Neigung abrufen",
    "getInclination": "Neigung abrufen",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "ruft die Neigung des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "Azimut abrufen",
    "getAzimuth": "Azimut abrufen",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "ruft den Azimut des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "Sonnenposition abrufen",
    "getSunPosition": "Sonnenposition abrufen",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "ruft die Sonnenposition des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "Sonnenposition verwenden abrufen",
    "getUseSunPosition": "Sonnenposition verwenden abrufen",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "ruft die Verwendung der Sonnenposition des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "Kameraoffset abrufen",
    "getCameraOffset": "Kameraoffset abrufen",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "ruft den Kameraoffset des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getUp": "Aufwärts abrufen",
    "getUp": "Aufwärts abrufen",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "ruft die Aufwärtsrichtung des Himmelmaterials ab",
    "bitbybit.babylon.material.skyMaterial.getDithering": "Dithering abrufen",
    "getDithering": "Dithering abrufen",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "ruft das Dithering des Himmelmaterials ab",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "Richtung zum Ziel festlegen",
    "shadowLight": "Schattenlicht",
    "setDirectionToTarget": "Richtung zum Ziel festlegen",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "legt die Richtung des Schattenlichts fest",
    "BABYLON.ShadowLight": "Babylon-Schattenlicht",
    "bitbybit.babylon.lights.shadowLight.setPosition": "Position festlegen",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "legt die Position des Schattenlichts fest",
    "bitbybit.babylon.meshBuilder.createBox": "Box",
    "meshBuilder": "Mesh-Builder",
    "createBox": "Box",
    "bitbybit.babylon.meshBuilder.createBox_description": "erstellt Box-Mesh",
    "create simple": "einfach erstellen",
    "depth": "Tiefe",
    "sideOrientation": "Seitenorientierung",
    "BabylonMesh.sideOrientationEnum": "Babylon-Mesh-Seitenorientierungs-Enum",
    "bitbybit.babylon.meshBuilder.createCube": "Würfel",
    "createCube": "Würfel",
    "bitbybit.babylon.meshBuilder.createCube_description": "erstellt Würfel-Mesh",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "quadratische Ebene",
    "createSquarePlane": "quadratische Ebene",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "erstellt quadratische Ebenen-Mesh",
    "bitbybit.babylon.meshBuilder.createSphere": "Kugel",
    "createSphere": "Kugel",
    "bitbybit.babylon.meshBuilder.createSphere_description": "erstellt Kugel-Mesh",
    "diameter": "Durchmesser",
    "segments": "Segmente",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "Ikosaeder-Kugel",
    "createIcoSphere": "Ikosaeder-Kugel",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "erstellt Ikosaeder-Kugel-Mesh",
    "radiusX": "Radius X",
    "radiusY": "Radius Y",
    "radiusZ": "Radius Z",
    "flat": "flach",
    "bitbybit.babylon.meshBuilder.createDisc": "Scheibe",
    "createDisc": "Scheibe",
    "bitbybit.babylon.meshBuilder.createDisc_description": "erstellt Scheiben-Mesh",
    "tessellation": "Tesselierung",
    "arc": "Bogen",
    "bitbybit.babylon.meshBuilder.createTorus": "Torus",
    "createTorus": "Torus",
    "bitbybit.babylon.meshBuilder.createTorus_description": "erstellt Torus-Mesh",
    "thickness": "Dicke",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "Torusknoten",
    "createTorusKnot": "Torusknoten",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "erstellt Torusknoten-Mesh",
    "tube": "Rohr",
    "radialSegments": "radiale Segmente",
    "tubularSegments": "tubulare Segmente",
    "p": "P",
    "q": "Q",
    "bitbybit.babylon.meshBuilder.createPolygon": "Polygon",
    "createPolygon": "Polygon",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "erstellt Polygon-Mesh",
    "shape": "Form",
    "holes": "Löcher",
    "Base.Vector3[][]": "Basisvektor-3-Array-Array",
    "smoothingThreshold": "Glättungsschwelle",
    "wrap": "umwickeln",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "Polygon extrudieren",
    "extrudePolygon": "Polygon extrudieren",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "erstellt extrudiertes Polygon-Mesh",
    "bitbybit.babylon.meshBuilder.createTube": "Rohr",
    "createTube": "Rohr",
    "bitbybit.babylon.meshBuilder.createTube_description": "erstellt Rohr-Mesh",
    "path": "Pfad",
    "cap": "Kappe",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "Polyeder",
    "createPolyhedron": "Polyeder",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "erstellt Polyeder-Mesh",
    "type": "Typ",
    "sizeX": "Größe X",
    "sizeY": "Größe Y",
    "sizeZ": "Größe Z",
    "custom": "benutzerdefiniert",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodätisch",
    "createGeodesic": "geodätisch",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "erstellt geodätisches Mesh",
    "m": "M",
    "n": "N",
    "bitbybit.babylon.meshBuilder.createGoldberg": "Goldberg",
    "createGoldberg": "Goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "erstellt Goldberg-Mesh",
    "bitbybit.babylon.meshBuilder.createCapsule": "Kapsel",
    "createCapsule": "Kapsel",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "erstellt Kapsel-Mesh",
    "orientation": "Orientierung",
    "capSubdivisions": "Kappenunterteilungen",
    "radiusTop": "Radius oben",
    "radiusBottom": "Radius unten",
    "topCapSubdivisions": "obere Kappenunterteilungen",
    "bottomCapSubdivisions": "untere Kappenunterteilungen",
    "bitbybit.babylon.meshBuilder.createCylinder": "Zylinder",
    "createCylinder": "Zylinder",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "erstellt Zylinder-Mesh",
    "diameterTop": "Durchmesser oben",
    "diameterBottom": "Durchmesser unten",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "extrudierte Form",
    "createExtrudedSahpe": "extrudierte Form",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "erstellt extrudiertes Form-Mesh",
    "closeShape": "Form schließen",
    "closePath": "Pfad schließen",
    "bitbybit.babylon.meshBuilder.createRibbon": "Band",
    "createRibbon": "Band",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "erstellt Band-Mesh",
    "pathArray": "Pfad-Array",
    "closeArray": "Array schließen",
    "offset": "Versatz",
    "bitbybit.babylon.meshBuilder.createLathe": "Drehmaschine",
    "createLathe": "Drehmaschine",
    "bitbybit.babylon.meshBuilder.createLathe_description": "erstellt Drehmaschinen-Mesh",
    "closed": "geschlossen",
    "bitbybit.babylon.meshBuilder.createGround": "Boden",
    "createGround": "Boden",
    "bitbybit.babylon.meshBuilder.createGround_description": "erstellt Boden-Mesh",
    "subdivisionsX": "Unterteilungen X",
    "subdivisionsY": "Unterteilungen Y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "rechteckige Ebene",
    "createRectanglePlane": "rechteckige Ebene",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "erstellt rechteckige Ebenen-Mesh",
    "bitbybit.babylon.texture.createSimple": "einfache Textur",
    "texture": "Textur",
    "createSimple": "einfach",
    "bitbybit.babylon.texture.createSimple_description": "erstellt Textur aus URL mit grundlegenden Optionen",
    "invertY": "Y umkehren",
    "invertZ": "Z umkehren",
    "wAng": "Winkel",
    "uScale": "U-Skalierung",
    "vScale": "V-Skalierung",
    "uOffset": "U-Versatz",
    "vOffset": "V-Versatz",
    "samplingMode": "Abtastmodus",
    "samplingModeEnum": "Abtastmodus-Enum",
    "bitbybit.babylon.tools.createScreenshot": "Screenshot",
    "tools": "Werkzeuge",
    "createScreenshot": "Screenshot",
    "bitbybit.babylon.tools.createScreenshot_description": "nimmt einen Screenshot der Szene auf",
    "screenshots": "Screenshots",
    "mimeType": "MIME-Typ",
    "quality": "Qualität",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "Screenshot und Download",
    "createScreenshotAndDownload": "Screenshot und Download",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "nimmt einen Screenshot der Szene auf und lädt ihn herunter",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "Vollbild-UI",
    "gui": "GUI",
    "advancedDynamicTexture": "erweiterte dynamische Textur",
    "createFullScreenUI": "Vollbild-UI",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "erstellt Vollbild-UI",
    "spaces": "Räume",
    "foreground": "Vordergrund",
    "adaptiveScaling": "adaptive Skalierung",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "für Mesh",
    "createForMesh": "für Mesh",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "erstellt Textur für Mesh",
    "BABYLON.AbstractMesh": "Babylon abstraktes Mesh",
    "supportPointerMove": "Zeigerbewegung unterstützen",
    "onlyAlphaTesting": "nur Alpha-Tests",
    "sampling": "Abtastung",
    "BabylonTexture.samplingModeEnum": "Babylon-Textur-Abtastmodus-Enum",
    "bitbybit.babylon.gui.control.changeControlPadding": "Steuerabstand ändern",
    "control": "Steuerung",
    "changeControlPadding": "Steuerabstand ändern",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "legt den Abstand der Steuerung fest",
    "positioning": "Positionierung",
    "BABYLON.GUI.Control": "Babylon GUI-Steuerung",
    "paddingLeft": "Abstand links",
    "number | string": "Zahl oder Zeichenkette",
    "paddingRight": "Abstand rechts",
    "paddingTop": "Abstand oben",
    "paddingBottom": "Abstand unten",
    "bitbybit.babylon.gui.control.changeControlAlignment": "Steuerausrichtung ändern",
    "changeControlAlignment": "Steuerausrichtung ändern",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "legt die Ausrichtung der Steuerung fest",
    "T": "T",
    "horizontalAlignment": "horizontale Ausrichtung",
    "horizontalAlignmentEnum": "horizontale Ausrichtungs-Enum",
    "verticalAlignment": "vertikale Ausrichtung",
    "verticalAlignmentEnum": "vertikale Ausrichtungs-Enum",
    "bitbybit.babylon.gui.control.cloneControl": "Steuerung klonen",
    "cloneControl": "Steuerung klonen",
    "bitbybit.babylon.gui.control.cloneControl_description": "klont die Steuerung",
    "container": "Container",
    "BABYLON.GUI.Container": "Babylon GUI-Container",
    "host": "Host",
    "BABYLON.GUI.AdvancedDynamicTexture": "Babylon GUI erweiterte dynamische Textur",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "Steuerung beobachtbarer Selektor",
    "createControlObservableSelector": "Steuerung beobachtbarer Selektor",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "erstellt beobachtbaren Selektor für Steuerung",
    "selector": "Selektor",
    "controlObservableSelectorEnum": "Steuerung beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.control.getControlByName": "Steuerung nach Namen abrufen",
    "getControlByName": "Steuerung nach Namen abrufen",
    "bitbybit.babylon.gui.control.getControlByName_description": "ruft die Steuerung nach Namen ab",
    "bitbybit.babylon.gui.control.setIsVisible": "Sichtbarkeit festlegen",
    "setIsVisible": "Sichtbarkeit festlegen",
    "bitbybit.babylon.gui.control.setIsVisible_description": "legt die Sichtbarkeit der Steuerung fest",
    "isVisible": "ist sichtbar",
    "bitbybit.babylon.gui.control.setIsReadonly": "Nur-Lesen festlegen",
    "setIsReadonly": "Nur-Lesen festlegen",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "legt die Nur-Lesen-Eigenschaft der Steuerung fest",
    "isReadOnly": "ist nur-lesen",
    "bitbybit.babylon.gui.control.setIsEnabled": "Aktiviert festlegen",
    "setIsEnabled": "Aktiviert festlegen",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "legt die Aktivierung der Steuerung fest",
    "isEnabled": "ist aktiviert",
    "bitbybit.babylon.gui.control.setHeight": "Höhe festlegen",
    "setHeight": "Höhe festlegen",
    "bitbybit.babylon.gui.control.setHeight_description": "legt die Höhe der Steuerung fest",
    "bitbybit.babylon.gui.control.setWidth": "Breite festlegen",
    "setWidth": "Breite festlegen",
    "bitbybit.babylon.gui.control.setWidth_description": "legt die Breite der Steuerung fest",
    "bitbybit.babylon.gui.control.setColor": "Farbe festlegen",
    "setColor": "Farbe festlegen",
    "bitbybit.babylon.gui.control.setColor_description": "legt die Farbe der Steuerung fest",
    "bitbybit.babylon.gui.control.setFontSize": "Schriftgröße festlegen",
    "setFontSize": "Schriftgröße festlegen",
    "bitbybit.babylon.gui.control.setFontSize_description": "legt die Schriftgröße der Steuerung fest",
    "fontSize": "Schriftgröße",
    "bitbybit.babylon.gui.control.getHeight": "Höhe abrufen",
    "getHeight": "Höhe abrufen",
    "bitbybit.babylon.gui.control.getHeight_description": "ruft die Höhe der Steuerung ab",
    "bitbybit.babylon.gui.control.getWidth": "Breite abrufen",
    "getWidth": "Breite abrufen",
    "bitbybit.babylon.gui.control.getWidth_description": "ruft die Breite der Steuerung ab",
    "bitbybit.babylon.gui.control.getColor": "Farbe abrufen",
    "getColor": "Farbe abrufen",
    "bitbybit.babylon.gui.control.getColor_description": "ruft die Farbe der Steuerung ab",
    "bitbybit.babylon.gui.control.getFontSize": "Schriftgröße abrufen",
    "getFontSize": "Schriftgröße abrufen",
    "bitbybit.babylon.gui.control.getFontSize_description": "ruft die Schriftgröße der Steuerung ab",
    "bitbybit.babylon.gui.control.getIsVisible": "Sichtbarkeit abrufen",
    "getIsVisible": "Sichtbarkeit abrufen",
    "bitbybit.babylon.gui.control.getIsVisible_description": "ruft die Sichtbarkeit der Steuerung ab",
    "bitbybit.babylon.gui.control.getIsReadonly": "Nur-Lesen abrufen",
    "getIsReadonly": "Nur-Lesen abrufen",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "ruft die Nur-Lesen-Eigenschaft der Steuerung ab",
    "bitbybit.babylon.gui.control.getIsEnabled": "Aktiviert abrufen",
    "getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "ruft die Aktivierung der Steuerung ab",
    "bitbybit.babylon.gui.container.addControls": "Steuerungen hinzufügen",
    "addControls": "Steuerungen hinzufügen",
    "bitbybit.babylon.gui.container.addControls_description": "fügt Steuerungen in der Reihenfolge zum Container hinzu",
    "controls": "Steuerungen",
    "BABYLON.GUI.Control[]": "Babylon GUI-Steuerungs-Array",
    "clearControlsFirst": "zuerst Steuerungen löschen",
    "bitbybit.babylon.gui.container.setBackground": "Hintergrund festlegen",
    "setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.container.setBackground_description": "legt den Hintergrund des Containers fest",
    "background": "Hintergrund",
    "bitbybit.babylon.gui.container.setIsReadonly": "Nur-Lesen festlegen",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "legt die Nur-Lesen-Eigenschaft des Containers fest",
    "bitbybit.babylon.gui.container.getBackground": "Hintergrund abrufen",
    "getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.container.getBackground_description": "ruft den Hintergrund des Containers ab",
    "bitbybit.babylon.gui.container.getIsReadonly": "Nur-Lesen abrufen",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "ruft die Nur-Lesen-Eigenschaft des Containers ab",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "Stapelbereich",
    "stackPanel": "Stapelbereich",
    "createStackPanel": "Stapelbereich",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "erstellt Stapelbereich",
    "isVertical": "ist vertikal",
    "spacing": "Abstand",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "Vertikal festlegen",
    "setIsVertical": "Vertikal festlegen",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "legt den Stapelbereich vertikal fest",
    "BABYLON.GUI.StackPanel": "Babylon GUI-Stapelbereich",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "Abstand festlegen",
    "setSpacing": "Abstand festlegen",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "legt den Abstand des Stapelbereichs fest",
    "bitbybit.babylon.gui.stackPanel.setWidth": "Breite festlegen",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "legt die Breite des Stapelbereichs fest",
    "bitbybit.babylon.gui.stackPanel.setHeight": "Höhe festlegen",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "legt die Höhe des Stapelbereichs fest",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "Vertikal abrufen",
    "getIsVertical": "Vertikal abrufen",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "ruft die vertikale Ausrichtung des Stapelbereichs ab",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "Abstand abrufen",
    "getSpacing": "Abstand abrufen",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "ruft den Abstand des Stapelbereichs ab",
    "bitbybit.babylon.gui.stackPanel.getWidth": "Breite abrufen",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "ruft die Breite des Stapelbereichs ab",
    "bitbybit.babylon.gui.stackPanel.getHeight": "Höhe abrufen",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "ruft die Höhe des Stapelbereichs ab",
    "bitbybit.babylon.gui.button.createSimpleButton": "einfacher Button",
    "button": "Button",
    "createSimpleButton": "einfacher Button",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "erstellt einfachen Button",
    "label": "Beschriftung",
    "bitbybit.babylon.gui.button.setButtonText": "Button-Text festlegen",
    "setButtonText": "Button-Text festlegen",
    "bitbybit.babylon.gui.button.setButtonText_description": "legt den Text des Buttons fest",
    "BABYLON.GUI.Button": "Babylon GUI-Button",
    "text": "Text",
    "bitbybit.babylon.gui.button.getButtonText": "Button-Text abrufen",
    "getButtonText": "Button-Text abrufen",
    "bitbybit.babylon.gui.button.getButtonText_description": "ruft den Text des Buttons ab",
    "bitbybit.babylon.gui.slider.createSlider": "Schieberegler",
    "slider": "Schieberegler",
    "createSlider": "Schieberegler",
    "bitbybit.babylon.gui.slider.createSlider_description": "erstellt Schieberegler",
    "minimum": "Minimum",
    "maximum": "Maximum",
    "value": "Wert",
    "step": "Schritt",
    "displayThumb": "Daumen anzeigen",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "Schieberegler-Daumen ändern",
    "changeSliderThumb": "Schieberegler-Daumen ändern",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "ändert die Eigenschaften des Schieberegler-Daumens",
    "BABYLON.GUI.Slider": "Babylon GUI-Schieberegler",
    "isThumbCircle": "ist Daumen kreisförmig",
    "thumbColor": "Daumenfarbe",
    "thumbWidth": "Daumenbreite",
    "string | number": "Zeichenkette oder Zahl",
    "isThumbClamped": "ist Daumen eingeklemmt",
    "bitbybit.babylon.gui.slider.setBorderColor": "Randfarbe festlegen",
    "setBorderColor": "Randfarbe festlegen",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "legt die Randfarbe des Schiebereglers fest",
    "borderColor": "Randfarbe",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "Hintergrundfarbe festlegen",
    "setBackgroundColor": "Hintergrundfarbe festlegen",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "legt die Hintergrundfarbe des Schiebereglers fest",
    "backgroundColor": "Hintergrundfarbe",
    "bitbybit.babylon.gui.slider.setMaximum": "Maximum festlegen",
    "setMaximum": "Maximum festlegen",
    "bitbybit.babylon.gui.slider.setMaximum_description": "legt den maximalen Wert des Schiebereglers fest",
    "bitbybit.babylon.gui.slider.setMinimum": "Minimum festlegen",
    "setMinimum": "Minimum festlegen",
    "bitbybit.babylon.gui.slider.setMinimum_description": "legt den minimalen Wert des Schiebereglers fest",
    "bitbybit.babylon.gui.slider.setStep": "Schritt festlegen",
    "setStep": "Schritt festlegen",
    "bitbybit.babylon.gui.slider.setStep_description": "legt den Schritt-Wert des Schiebereglers fest",
    "bitbybit.babylon.gui.slider.setValue": "Wert festlegen",
    "setValue": "Wert festlegen",
    "bitbybit.babylon.gui.slider.setValue_description": "legt den Wert des Schiebereglers fest",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "Schieberegler beobachtbarer Selektor",
    "createSliderObservableSelector": "Schieberegler beobachtbarer Selektor",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "erstellt beobachtbaren Selektor für Schieberegler",
    "sliderObservableSelectorEnum": "Schieberegler beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.slider.getBorderColor": "Randfarbe abrufen",
    "getBorderColor": "Randfarbe abrufen",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "ruft die Randfarbe des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "Hintergrundfarbe abrufen",
    "getBackgroundColor": "Hintergrundfarbe abrufen",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "ruft die Hintergrundfarbe des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getMaximum": "Maximum abrufen",
    "getMaximum": "Maximum abrufen",
    "bitbybit.babylon.gui.slider.getMaximum_description": "ruft den maximalen Wert des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getMinimum": "Minimum abrufen",
    "getMinimum": "Minimum abrufen",
    "bitbybit.babylon.gui.slider.getMinimum_description": "ruft den minimalen Wert des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getStep": "Schritt abrufen",
    "getStep": "Schritt abrufen",
    "bitbybit.babylon.gui.slider.getStep_description": "ruft den Schritt-Wert des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getValue": "Wert abrufen",
    "getValue": "Wert abrufen",
    "bitbybit.babylon.gui.slider.getValue_description": "ruft den Wert des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getThumbColor": "Daumenfarbe abrufen",
    "getThumbColor": "Daumenfarbe abrufen",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "ruft die Daumenfarbe des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getThumbWidth": "Daumenbreite abrufen",
    "getThumbWidth": "Daumenbreite abrufen",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "ruft die Daumenbreite des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getIsVertical": "Vertikal abrufen",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "ruft die vertikale Ausrichtung des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "Daumen anzeigen abrufen",
    "getDisplayThumb": "Daumen anzeigen abrufen",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "ruft die Daumen-Anzeige des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "Daumen kreisförmig abrufen",
    "getIsThumbCircle": "Daumen kreisförmig abrufen",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "ruft die kreisförmige Daumen-Eigenschaft des Schiebereglers ab",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "Daumen eingeklemmt abrufen",
    "getIsThumbClamped": "Daumen eingeklemmt abrufen",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "ruft die eingeklemmte Daumen-Eigenschaft des Schiebereglers ab",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "Textblock",
    "textBlock": "Textblock",
    "createTextBlock": "Textblock",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "erstellt Textblock",
    "bitbybit.babylon.gui.textBlock.alignText": "Text ausrichten",
    "alignText": "Text ausrichten",
    "bitbybit.babylon.gui.textBlock.alignText_description": "legt die Textausrichtung fest",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "Textumriss festlegen",
    "setTextOutline": "Textumriss festlegen",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "legt den Textumriss fest",
    "BABYLON.GUI.TextBlock": "Babylon GUI-Textblock",
    "outlineWidth": "Umrissbreite",
    "outlineColor": "Umrissfarbe",
    "bitbybit.babylon.gui.textBlock.setText": "Text festlegen",
    "setText": "Text festlegen",
    "bitbybit.babylon.gui.textBlock.setText_description": "legt den Text des Textblocks fest",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "Größe anpassen festlegen",
    "setRsizeToFit": "Größe anpassen festlegen",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "legt die Größenanpassung fest",
    "resizeToFit": "Größe anpassen",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "Textumbruch festlegen",
    "setTextWrapping": "Textumbruch festlegen",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "legt den Textumbruch fest",
    "textWrapping": "Textumbruch",
    "boolean | BABYLON.GUI.TextWrapping": "boolesch oder Babylon GUI-Textumbruch",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "Zeilenabstand festlegen",
    "setLineSpacing": "Zeilenabstand festlegen",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "legt den Zeilenabstand des Textes fest",
    "lineSpacing": "Zeilenabstand",
    "bitbybit.babylon.gui.textBlock.getText": "Text abrufen",
    "getText": "Text abrufen",
    "bitbybit.babylon.gui.textBlock.getText_description": "ruft den Text des Textblocks ab",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "Textumbruch abrufen",
    "getTextWrapping": "Textumbruch abrufen",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "ruft den Textumbruch ab",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "Zeilenabstand abrufen",
    "getLineSpacing": "Zeilenabstand abrufen",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "ruft den Zeilenabstand des Textes ab",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "Umrissbreite abrufen",
    "getOutlineWidth": "Umrissbreite abrufen",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "ruft die Umrissbreite des Textes ab",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "Größe anpassen abrufen",
    "getResizeToFit": "Größe anpassen abrufen",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "ruft die Größenanpassung ab",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "horizontale Textausrichtung abrufen",
    "getTextHorizontalAlignment": "horizontale Textausrichtung abrufen",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "ruft die horizontale Textausrichtung ab",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "vertikale Textausrichtung abrufen",
    "getTextVerticalAlignment": "vertikale Textausrichtung abrufen",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "ruft die vertikale Textausrichtung ab",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "Textblock beobachtbarer Selektor",
    "createTextBlockObservableSelector": "Textblock beobachtbarer Selektor",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "erstellt beobachtbaren Selektor für Textblock",
    "textBlockObservableSelectorEnum": "Textblock beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "Optionsfeld",
    "radioButton": "Optionsfeld",
    "createRadioButton": "Optionsfeld",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "erstellt Optionsfeld",
    "group": "Gruppe",
    "isChecked": "ist aktiviert",
    "checkSizeRatio": "Kontrollgrößenverhältnis",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "Kontrollgrößenverhältnis festlegen",
    "setCheckSizeRatio": "Kontrollgrößenverhältnis festlegen",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "legt das Kontrollgrößenverhältnis des Optionsfelds fest",
    "BABYLON.GUI.RadioButton": "Babylon GUI-Optionsfeld",
    "bitbybit.babylon.gui.radioButton.setGroup": "Gruppe festlegen",
    "setGroup": "Gruppe festlegen",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "legt die Gruppe des Optionsfelds fest",
    "bitbybit.babylon.gui.radioButton.setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "legt den Hintergrund des Optionsfelds fest",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "Kontrollgrößenverhältnis abrufen",
    "getCheckSizeRatio": "Kontrollgrößenverhältnis abrufen",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "ruft das Kontrollgrößenverhältnis des Optionsfelds ab",
    "bitbybit.babylon.gui.radioButton.getGroup": "Gruppe abrufen",
    "getGroup": "Gruppe abrufen",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "ruft die Gruppe des Optionsfelds ab",
    "bitbybit.babylon.gui.radioButton.getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "ruft den Hintergrund des Optionsfelds ab",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "Optionsfeld beobachtbarer Selektor",
    "createRadioButtonObservableSelector": "Optionsfeld beobachtbarer Selektor",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "erstellt beobachtbaren Selektor für Optionsfeld",
    "radioButtonObservableSelectorEnum": "Optionsfeld beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "Kontrollkästchen",
    "checkbox": "Kontrollkästchen",
    "createCheckbox": "Kontrollkästchen",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "erstellt Kontrollkästchen",
    "bitbybit.babylon.gui.checkbox.setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "legt den Hintergrund des Kontrollkästchens fest",
    "BABYLON.GUI.Checkbox": "Babylon GUI-Kontrollkästchen",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "Kontrollgrößenverhältnis festlegen",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "legt das Kontrollgrößenverhältnis des Kontrollkästchens fest",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "Aktiviert festlegen",
    "setIsChecked": "Aktiviert festlegen",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "legt die Aktivierung des Kontrollkästchens fest",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "Kontrollgrößenverhältnis abrufen",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "ruft das Kontrollgrößenverhältnis des Kontrollkästchens ab",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "Aktiviert abrufen",
    "getIsChecked": "Aktiviert abrufen",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "ruft die Aktivierung des Kontrollkästchens ab",
    "bitbybit.babylon.gui.checkbox.getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "ruft den Hintergrund des Kontrollkästchens ab",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "Kontrollkästchen beobachtbarer Selektor",
    "createCheckboxObservableSelector": "Kontrollkästchen beobachtbarer Selektor",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "erstellt beobachtbaren Selektor für Kontrollkästchen",
    "checkboxObservableSelectorEnum": "Kontrollkästchen beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.inputText.createInputText": "Eingabetext",
    "inputText": "Eingabetext",
    "createInputText": "Eingabetext",
    "bitbybit.babylon.gui.inputText.createInputText_description": "erstellt Eingabetext",
    "placeholder": "Platzhalter",
    "bitbybit.babylon.gui.inputText.setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.inputText.setBackground_description": "legt den Hintergrund des Eingabetextes fest",
    "BABYLON.GUI.InputText": "Babylon GUI-Eingabetext",
    "bitbybit.babylon.gui.inputText.setText": "Text festlegen",
    "bitbybit.babylon.gui.inputText.setText_description": "legt den Eingabetext fest",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "Platzhalter festlegen",
    "setPlaceholder": "Platzhalter festlegen",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "legt den Platzhalter des Eingabetextes fest",
    "bitbybit.babylon.gui.inputText.getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.inputText.getBackground_description": "ruft den Hintergrund des Eingabetextes ab",
    "bitbybit.babylon.gui.inputText.getText": "Text abrufen",
    "bitbybit.babylon.gui.inputText.getText_description": "ruft den Eingabetext ab",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "Platzhallter abrufen",
    "getPlaceholder": "Platzhalter abrufen",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "ruft den Platzhalter des Eingabetextes ab",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "Eingabetext beobachtbarer Selektor",
    "createInputTextObservableSelector": "Eingabetext beobachtbarer Selektor",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "erstellt beobachtbaren Selektor für Eingabetext",
    "inputTextObservableSelectorEnum": "Eingabetext beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "Farbwähler",
    "colorPicker": "Farbwähler",
    "createColorPicker": "Farbwähler",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "erstellt Farbwähler",
    "defaultColor": "Standardfarbe",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "Farbwähler-Wert festlegen",
    "setColorPickerValue": "Farbwähler-Wert festlegen",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "legt den Wert des Farbwählers fest",
    "BABYLON.GUI.ColorPicker": "Babylon GUI-Farbwähler",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "Farbwähler-Größe festlegen",
    "setColorPickerSize": "Farbwähler-Größe festlegen",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "legt die Größe des Farbwählers fest",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "Farbwähler-Wert abrufen",
    "getColorPickerValue": "Farbwähler-Wert abrufen",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "ruft den Wert des Farbwählers ab",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "Farbwähler-Größe abrufen",
    "getColorPickerSize": "Farbwähler-Größe abrufen",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "ruft die Größe des Farbwählers ab",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "Farbwähler beobachtbarer Selektor",
    "createColorPickerObservableSelector": "Farbwähler beobachtbarer Selektor",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "erstellt beobachtbaren Selektor für Farbwähler",
    "colorPickerObservableSelectorEnum": "Farbwähler beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.image.createImage": "Bild",
    "image": "Bild",
    "createImage": "Bild",
    "bitbybit.babylon.gui.image.createImage_description": "erstellt Bild",
    "bitbybit.babylon.gui.image.setSourceUrl": "Quell-URL festlegen",
    "setSourceUrl": "Quell-URL festlegen",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "legt die Quell-URL des Bildes fest",
    "BABYLON.GUI.Image": "Babylon GUI-Bild",
    "bitbybit.babylon.gui.image.getSourceUrl": "Quell-URL abrufen",
    "getSourceUrl": "Quell-URL abrufen",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "ruft die Quell-URL des Bildes ab",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "Gizmo-Manager",
    "gizmo": "Gizmo",
    "manager": "Manager",
    "createGizmoManager": "Gizmo-Manager",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "erstellt Gizmo-Manager",
    "positionGizmoEnabled": "Positions-Gizmo aktiviert",
    "rotationGizmoEnabled": "Rotations-Gizmo aktiviert",
    "scaleGizmoEnabled": "Skalierungs-Gizmo aktiviert",
    "boundingBoxGizmoEnabled": "Begrenzungsrahmen-Gizmo aktiviert",
    "usePointerToAttachGizmos": "Zeiger zum Anhängen von Gizmos verwenden",
    "clearGizmoOnEmptyPointerEvent": "Gizmo bei leerem Zeigerereignis löschen",
    "scaleRatio": "Skalierungsverhältnis",
    "attachableMeshes": "anbringbare Meshes",
    "BABYLON.AbstractMesh[]": "Babylon abstraktes Mesh-Array",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "Positions-Gizmo abrufen",
    "getPositionGizmo": "Positions-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "ruft das Positions-Gizmo ab",
    "gizmoManager": "Gizmo-Manager",
    "BABYLON.GizmoManager": "Babylon Gizmo-Manager",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "Rotations-Gizmo abrufen",
    "getRotationGizmo": "Rotations-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "ruft das Rotations-Gizmo ab",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "Skalierungs-Gizmo abrufen",
    "getScaleGizmo": "Skalierungs-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "ruft das Skalierungs-Gizmo ab",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "Begrenzungsrahmen-Gizmo abrufen",
    "getBoundingBoxGizmo": "Begrenzungsrahmen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "ruft das Begrenzungsrahmen-Gizmo ab",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "an Mesh anbringen",
    "attachToMesh": "an Mesh anbringen",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "hängt den Gizmo-Manager an ein Mesh an",
    "update": "parte",
    "bitbybit.babylon.gizmo.manager.detachMesh": "Mesh abtrennen",
    "detachMesh": "Mesh abtrennen",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "trennt den Gizmo-Manager von einem Mesh ab",
    "bitbybit.babylon.gizmo.base.scaleRatio": "Skalierungsverhältnis festlegen",
    "base": "Basis",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "legt das Skalierungsverhältnis des Gizmos fest",
    "BABYLON.IGizmo": "Babylon I Gizmo",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "Skalierungsverhältnis abrufen",
    "getScaleRatio": "Skalierungsverhältnis abrufen",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "ruft das Skalierungsverhältnis des Gizmos ab",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "Ebenen-Gizmo aktivieren festlegen",
    "positionGizmo": "Positions-Gizmo",
    "planarGizmoEnabled": "Ebenen-Gizmo aktiviert",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "legt fest, ob das Ebenen-Gizmo aktiviert ist",
    "BABYLON.IPositionGizmo": "Babylon I Positions-Gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "Schnappabstand festlegen",
    "snapDistance": "Schnappabstand",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "legt den Schnappabstand des Positions-Gizmos fest",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "angehängtes Mesh abrufen",
    "getAttachedMesh": "angehängtes Mesh abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "ruft das angehängte Mesh ab",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "angehängten Knoten abrufen",
    "getAttachedNode": "angehängten Knoten abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "ruft den angehängten Knoten ab",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "X-Gizmo abrufen",
    "getXGizmo": "X-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "ruft das X-Gizmo ab",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "Y-Gizmo abrufen",
    "getYGizmo": "Y-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "ruft das Y-Gizmo ab",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "Z-Gizmo abrufen",
    "getZGizmo": "Z-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "ruft das Z-Gizmo ab",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "X-Ebenen-Gizmo abrufen",
    "getXPlaneGizmo": "X-Ebenen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "ruft das X-Ebenen-Gizmo ab",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "Y-Ebenen-Gizmo abrufen",
    "getYPlaneGizmo": "Y-Ebenen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "ruft das Y-Ebenen-Gizmo ab",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "Z-Ebenen-Gizmo abrufen",
    "getZPlaneGizmo": "Z-Ebenen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "ruft das Z-Ebenen-Gizmo ab",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "Ebenen-Gizmo aktiviert abrufen",
    "getPlanarGizmoEnabled": "Ebenen-Gizmo aktiviert abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "ruft den Status des aktivierten Ebenen-Gizmos ab",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "Schnappabstand abrufen",
    "getSnapDistance": "Schnappabstand abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "ruft den Schnappabstand ab",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "Ziehen abrufen",
    "getIsDragging": "Ziehen abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "ruft den Ziehstatus ab",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "Positions-Gizmo beobachtbarer Selektor",
    "createPositionGizmoObservableSelector": "Positions-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "erstellt beobachtbaren Selektor für Positions-Gizmo",
    "positionGizmoObservableSelectorEnum": "Positions-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "Schnappabstand festlegen",
    "rotationGizmo": "Rotations-Gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "legt den Schnappabstand des Rotations-Gizmos fest",
    "BABYLON.IRotationGizmo": "Babylon I Rotations-Gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "Empfindlichkeit festlegen",
    "sensitivity": "Empfindlichkeit",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "legt die Empfindlichkeit des Rotations-Gizmos fest",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "angehängtes Mesh abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "ruft das angehängte Mesh ab",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "angehängten Knoten abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "ruft den angehängten Knoten ab",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "X-Gizmo abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "ruft das X-Gizmo ab",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "Y-Gizmo abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "ruft das Y-Gizmo ab",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "Z-Gizmo abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "ruft das Z-Gizmo ab",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "Schnappabstand abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "ruft den Schnappabstand ab",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "Empfindlichkeit abrufen",
    "getSensitivity": "Empfindlichkeit abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "ruft die Empfindlichkeit ab",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "Rotations-Gizmo beobachtbarer Selektor",
    "createRotationGizmoObservableSelector": "Rotations-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "erstellt beobachtbaren Selektor für Rotations-Gizmo",
    "rotationGizmoObservableSelectorEnum": "Rotations-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "X-Gizmo abrufen",
    "scaleGizmo": "Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "ruft das X-Gizmo ab",
    "BABYLON.IScaleGizmo": "Babylon I Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "Y-Gizmo abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "ruft das Y-Gizmo ab",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "Z-Gizmo abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "ruft das Z-Gizmo ab",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "Schnappabstand festlegen",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "legt den Schnappabstand des Skalierungs-Gizmos fest",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "inkrementelles Schnappen festlegen",
    "setIncrementalSnap": "inkrementelles Schnappen festlegen",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "legt das inkrementelle Schnappen des Skalierungs-Gizmos fest",
    "incrementalSnap": "inkrementelles Schnappen",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "Empfindlichkeit festlegen",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "legt die Empfindlichkeit des Skalierungs-Gizmos fest",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "inkrementelles Schnappen abrufen",
    "getIncrementalSnap": "inkrementelles Schnappen abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "ruft das inkrementelle Schnappen ab",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "Schnappabstand abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "ruft den Schnappabstand ab",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "Empfindlichkeit abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "ruft die Empfindlichkeit ab",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "Skalierungs-Gizmo beobachtbarer Selektor",
    "createScaleGizmoObservableSelector": "Skalierungs-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "erstellt beobachtbaren Selektor für Skalierungs-Gizmo",
    "scaleGizmoObservableSelectorEnum": "Skalierungs-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "Rotationskugelgröße festlegen",
    "boundingBoxGizmo": "Begrenzungsrahmen-Gizmo",
    "setRotationSphereSize": "Rotationskugelgröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "legt die Rotationskugelgröße des Begrenzungsrahmen-Gizmos fest",
    "BABYLON.BoundingBoxGizmo": "Babylon Begrenzungsrahmen-Gizmo",
    "rotationSphereSize": "Rotationskugelgröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße festlegen",
    "setFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "legt die feste Zieh-Mesh-Bildschirmgröße für konsistente Skalierung fest",
    "fixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße festlegen",
    "setFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "legt die feste Zieh-Mesh-Grenzengröße fest",
    "fixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor festlegen",
    "setFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "legt den Distanzfaktor für die feste Zieh-Mesh-Bildschirmgröße fest",
    "fixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "Skalierungsschnappabstand festlegen",
    "setScalingSnapDistance": "Skalierungsschnappabstand festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "legt den Skalierungsschnappabstand des Begrenzungsrahmen-Gizmos fest",
    "scalingSnapDistance": "Skalierungsschnappabstand",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "Rotationsschnappabstand festlegen",
    "setRotationSnapDistance": "Rotationsschnappabstand festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "legt den Rotationsschnappabstand des Begrenzungsrahmen-Gizmos fest",
    "rotationSnapDistance": "Rotationsschnappabstand",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "Skalierungskastengröße festlegen",
    "setScaleBoxSize": "Skalierungskastengröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "legt die Skalierungskastengröße des Begrenzungsrahmen-Gizmos fest",
    "scaleBoxSize": "Skalierungskastengröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "inkrementelles Schnappen festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "legt das inkrementelle Schnappen des Begrenzungsrahmen-Gizmos fest",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "Skalierungspivot festlegen",
    "setScalePivot": "Skalierungspivot festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "legt den Skalierungspivot des Begrenzungsrahmen-Gizmos fest",
    "scalePivot": "Skalierungspivot",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "Achsenfaktor festlegen",
    "setAxisFactor": "Achsenfaktor festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "legt den Achsenfaktor des Begrenzungsrahmen-Gizmos fest",
    "axisFactor": "Achsenfaktor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "Skalierungsziehgeschwindigkeit festlegen",
    "setScaleDragSpeed": "Skalierungsziehgeschwindigkeit festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "legt die Skalierungsziehgeschwindigkeit des Begrenzungsrahmen-Gizmos fest",
    "scaleDragSpeed": "Skalierungsziehgeschwindigkeit",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "Rotationskugelgröße abrufen",
    "getRotationSphereSize": "Rotationskugelgröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "ruft die Rotationskugelgröße ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "Skalierungskastengröße abrufen",
    "getScaleBoxSize": "Skalierungskastengröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "ruft die Skalierungskastengröße ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße abrufen",
    "getFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "ruft die feste Zieh-Mesh-Bildschirmgröße ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße abrufen",
    "getFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "ruft die feste Zieh-Mesh-Grenzengröße ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor abrufen",
    "getFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "ruft den Distanzfaktor für die feste Zieh-Mesh-Bildschirmgröße ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "Skalierungsschnappabstand abrufen",
    "getScalingSnapDistance": "Skalierungsschnappabstand abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "ruft den Skalierungsschnappabstand ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "Rotationsschnappabstand abrufen",
    "getRotationSnapDistance": "Rotationsschnappabstand abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "ruft den Rotationsschnappabstand ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "inkrementelles Schnappen abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "ruft das inkrementelle Schnappen ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "Skalierungspivot abrufen",
    "getScalePivot": "Skalierungspivot abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "ruft den Skalierungspivot ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "Achsenfaktor abrufen",
    "getAxisFactor": "Achsenfaktor abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "ruft den Achsenfaktor ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "Skalierungsziehgeschwindigkeit abrufen",
    "getScaleDragSpeed": "Skalierungsziehgeschwindigkeit abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "ruft die Skalierungsziehgeschwindigkeit ab",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "Begrenzungsrahmen-Gizmo beobachtbarer Selektor",
    "createBoundingBoxGizmoObservableSelector": "Begrenzungsrahmen-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "erstellt beobachtbaren Selektor für Begrenzungsrahmen-Gizmo",
    "boundingBoxGizmoObservableSelectorEnum": "Begrenzungsrahmen-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "Aktiviert festlegen",
    "axisDragGizmo": "Achsen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "legt die Aktivierung der Achse fest",
    "BABYLON.IAxisDragGizmo": "Babylon I Achsen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "ruft die Aktivierung der Achse ab",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "Aktiviert festlegen",
    "axisScaleGizmo": "Achsen-Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "legt die Aktivierung der Achse fest",
    "BABYLON.IAxisScaleGizmo": "Babylon I Achsen-Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "ruft die Aktivierung der Achse ab",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "Aktiviert festlegen",
    "planeDragGizmo": "Ebenen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "legt die Aktivierung der Ebene fest",
    "BABYLON.IPlaneDragGizmo": "Babylon I Ebenen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "ruft die Aktivierung der Ebene ab",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "Aktiviert festlegen",
    "planeRotationGizmo": "Ebenen-Rotations-Gizmo",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "legt die Aktivierung der Ebene fest",
    "BABYLON.IPlaneRotationGizmo": "Babylon I Ebenen-Rotations-Gizmo",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "ruft die Aktivierung der Ebene ab",
    "bitbybit.vector.removeAllDuplicateVectors": "alle doppelten Vektoren entfernen",
    "vector": "Vektor",
    "removeAllDuplicateVectors": "alle doppelten Vektoren entfernen",
    "bitbybit.vector.removeAllDuplicateVectors_description": "entfernt alle doppelten Vektoren aus dem Array",
    "remove": "entfernen",
    "vectors": "Vektoren",
    "number[][]": "Zahlen-Array-Array",
    "tolerance": "Toleranz",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "aufeinanderfolgende doppelte Vektoren entfernen",
    "removeConsecutiveDuplicateVectors": "aufeinanderfolgende doppelte Vektoren entfernen",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "entfernt aufeinanderfolgende doppelte Vektoren aus dem Array",
    "checkFirstAndLast": "erstes und letztes prüfen",
    "bitbybit.vector.angleBetween": "Winkel zwischen",
    "angleBetween": "Winkel zwischen",
    "bitbybit.vector.angleBetween_description": "misst den Winkel zwischen zwei Vektoren in Grad",
    "angles": "Winkel",
    "first": "erster",
    "second": "zweiter",
    "bitbybit.vector.angleBetweenNormalized2d": "Winkel zwischen normalisiertem 2D",
    "angleBetweenNormalized2d": "Winkel zwischen normalisiertem 2D",
    "bitbybit.vector.angleBetweenNormalized2d_description": "misst den normalisierten 2D-Winkel zwischen zwei Vektoren in Grad",
    "bitbybit.vector.positiveAngleBetween": "positiver Winkel zwischen",
    "positiveAngleBetween": "positiver Winkel zwischen",
    "bitbybit.vector.positiveAngleBetween_description": "misst den positiven Winkel zwischen zwei Vektoren mit Referenz in Grad",
    "reference": "Referenz",
    "bitbybit.vector.addAll": "alle addieren",
    "addAll": "alle addieren",
    "bitbybit.vector.addAll_description": "addiert alle XYZ-Werte des Vektors zu einem neuen Vektor",
    "sum": "Summe",
    "bitbybit.vector.add": "addieren",
    "add": "addieren",
    "bitbybit.vector.add_description": "addiert zwei Vektoren",
    "bitbybit.vector.all": "alle",
    "all": "alle",
    "bitbybit.vector.all_description": "prüft, ob das Boolean-Array durchgehend wahr ist",
    "boolean[]": "Boolean-Array",
    "bitbybit.vector.cross": "Kreuzprodukt",
    "cross": "Kreuzprodukt",
    "bitbybit.vector.cross_description": "führt das Kreuzprodukt zweier Vektoren aus",
    "bitbybit.vector.distSquared": "Abstand quadriert",
    "distSquared": "Abstand quadriert",
    "bitbybit.vector.distSquared_description": "quadrierter Abstand zwischen zwei Vektoren",
    "bitbybit.vector.dist": "Abstand",
    "dist": "Abstand",
    "bitbybit.vector.dist_description": "Abstand zwischen zwei Vektoren",
    "bitbybit.vector.div": "dividieren",
    "div": "dividieren",
    "bitbybit.vector.div_description": "dividiert einen Vektor durch einen Skalar",
    "scalar": "Skalar",
    "bitbybit.vector.domain": "Bereich",
    "domain": "Bereich",
    "bitbybit.vector.domain_description": "berechnet den Bereich zwischen Minimum und Maximum des Vektors",
    "bitbybit.vector.dot": "Skalarprodukt",
    "dot": "Skalarprodukt",
    "bitbybit.vector.dot_description": "Skalarprodukt zweier Vektoren",
    "bitbybit.vector.finite": "endlich",
    "finite": "endlich",
    "bitbybit.vector.finite_description": "prüft, ob die Zahlen des Vektors endlich sind",
    "validate": "validieren",
    "bitbybit.vector.isZero": "ist Null",
    "isZero": "ist Null",
    "bitbybit.vector.isZero_description": "prüft, ob die Länge des Vektors Null ist",
    "bitbybit.vector.lerp": "lineare Interpolation",
    "lerp": "lineare Interpolation",
    "bitbybit.vector.lerp_description": "findet einen Vektor zwischen zwei Vektoren anhand eines Bruchteils",
    "fraction": "Bruchteil",
    "bitbybit.vector.max": "max",
    "max": "max",
    "bitbybit.vector.max_description": "findet den maximalen Wert in einem Vektor",
    "extract": "extrahieren",
    "bitbybit.vector.min": "min",
    "min": "min",
    "bitbybit.vector.min_description": "findet den minimalen Wert in einem Vektor",
    "bitbybit.vector.mul": "mul",
    "mul": "mul",
    "bitbybit.vector.mul_description": "multipliziert einen Vektor mit einem Skalar",
    "bitbybit.vector.neg": "neg",
    "neg": "neg",
    "bitbybit.vector.neg_description": "negiert einen Vektor",
    "bitbybit.vector.normSquared": "Norm quadriert",
    "normSquared": "Norm quadriert",
    "bitbybit.vector.normSquared_description": "berechnet die quadrierte Norm",
    "bitbybit.vector.norm": "Norm",
    "norm": "Norm",
    "bitbybit.vector.norm_description": "berechnet die Vektornorm",
    "bitbybit.vector.normalized": "normalisiert",
    "normalized": "normalisiert",
    "bitbybit.vector.normalized_description": "normalisiert einen Vektor auf Einheitslänge",
    "bitbybit.vector.onRay": "auf Strahl",
    "onRay": "auf Strahl",
    "bitbybit.vector.onRay_description": "findet einen Punkt auf einem Strahl in gegebenem Abstand",
    "bitbybit.vector.vectorXYZ": "Vektor XYZ",
    "vectorXYZ": "Vektor XYZ",
    "bitbybit.vector.vectorXYZ_description": "erstellt einen XYZ-Vektor",
    "x": "X",
    "y": "Y",
    "z": "Z",
    "bitbybit.vector.vectorXY": "Vektor XY",
    "vectorXY": "Vektor XY",
    "bitbybit.vector.vectorXY_description": "erstellt einen 2D-XY-Vektor",
    "bitbybit.vector.range": "Bereich",
    "range": "Bereich",
    "bitbybit.vector.range_description": "erstellt einen ganzzahligen Vektor von 0 bis max",
    "bitbybit.vector.signedAngleBetween": "signierter Winkel zwischen",
    "signedAngleBetween": "signierter Winkel zwischen",
    "bitbybit.vector.signedAngleBetween_description": "berechnet den signierten Winkel zwischen zwei Vektoren mit Referenz",
    "bitbybit.vector.span": "Spanne",
    "span": "Spanne",
    "bitbybit.vector.span_description": "erstellt einen Vektor, der von min bis max mit Schritten spannt",
    "bitbybit.vector.spanEaseItems": "Spanne mit Glättung",
    "spanEaseItems": "Spanne mit Glättung",
    "bitbybit.vector.spanEaseItems_description": "erstellt einen Vektor, der von min bis max mit Glättungsfunktion spannt",
    "nrItems": "Anzahl Elemente",
    "ease": "Glättung",
    "Math.easeEnum": "Math Glättungs-Enum",
    "intervals": "Intervalle",
    "bitbybit.vector.spanLinearItems": "lineare Spanne",
    "spanLinearItems": "lineare Spanne",
    "bitbybit.vector.spanLinearItems_description": "erstellt einen Vektor, der von min bis max mit Elementanzahl spannt",
    "bitbybit.vector.sub": "sub",
    "sub": "sub",
    "bitbybit.vector.sub_description": "subtrahiert zwei Vektoren",
    "bitbybit.vector.sum": "Summe",
    "bitbybit.vector.sum_description": "summiert Vektorwerte",
    "bitbybit.point.transformPoint": "Punkt transformieren",
    "transformPoint": "Punkt transformieren",
    "bitbybit.point.transformPoint_description": "transformiert einen einzelnen Punkt",
    "transformation": "Transformation",
    "Base.TransformMatrixes": "Basis-Transformationsmatrizen",
    "bitbybit.point.transformPoints": "Punkte transformieren",
    "transformPoints": "Punkte transformieren",
    "bitbybit.point.transformPoints_description": "transformiert mehrere Punkte",
    "points": "Punkte",
    "bitbybit.point.transformsForPoints": "Transformationen für Punkte",
    "transformsForPoints": "Transformationen für Punkte",
    "bitbybit.point.transformsForPoints_description": "transformiert mehrere Punkte mit mehreren Transformationen",
    "Base.TransformMatrixes[]": "Array von Basis-Transformationsmatrizen",
    "bitbybit.point.translatePoints": "Punkte verschieben",
    "translatePoints": "Punkte verschieben",
    "bitbybit.point.translatePoints_description": "verschiebt mehrere Punkte",
    "bitbybit.point.translatePointsWithVectors": "Punkte mit Vektoren verschieben",
    "translatePointsWithVectors": "Punkte mit Vektoren verschieben",
    "bitbybit.point.translatePointsWithVectors_description": "verschiebt mehrere Punkte mit Vektoren",
    "bitbybit.point.translateXYZPoints": "XYZ-Punkte verschieben",
    "translateXYZPoints": "XYZ-Punkte verschieben",
    "bitbybit.point.translateXYZPoints_description": "verschiebt mehrere Punkte um XYZ-Werte",
    "bitbybit.point.scalePointsCenterXYZ": "Punkte um Zentrum XYZ skalieren",
    "scalePointsCenterXYZ": "Punkte um Zentrum XYZ skalieren",
    "bitbybit.point.scalePointsCenterXYZ_description": "skaliert mehrere Punkte vom Zentrum mit XYZ-Faktoren",
    "bitbybit.point.rotatePointsCenterAxis": "Punkte um Zentrum und Achse drehen",
    "rotatePointsCenterAxis": "Punkte um Zentrum und Achse drehen",
    "bitbybit.point.rotatePointsCenterAxis_description": "dreht mehrere Punkte um Zentrum und Achse",
    "bitbybit.point.closestPointFromPointsDistance": "nächster Punkt Abstand",
    "closestPointFromPointsDistance": "nächster Punkt Abstand",
    "bitbybit.point.closestPointFromPointsDistance_description": "misst den kürzesten Abstand zu Punkten",
    "bitbybit.point.closestPointFromPointsIndex": "nächster Punkt Index",
    "closestPointFromPointsIndex": "nächster Punkt Index",
    "bitbybit.point.closestPointFromPointsIndex_description": "findet den Index des nächstgelegenen Punktes ab 1",
    "bitbybit.point.closestPointFromPoints": "nächster Punkt",
    "closestPointFromPoints": "nächster Punkt",
    "bitbybit.point.closestPointFromPoints_description": "findet den nächstgelegenen Punkt in der Sammlung",
    "bitbybit.point.distance": "Abstand",
    "bitbybit.point.distance_description": "misst den Abstand zwischen zwei Punkten",
    "measure": "messen",
    "startPoint": "Startpunkt",
    "endPoint": "Endpunkt",
    "bitbybit.point.distancesToPoints": "Abstände zu Punkten",
    "distancesToPoints": "Abstände zu Punkten",
    "bitbybit.point.distancesToPoints_description": "misst Abstände vom Start zu mehreren Endpunkten",
    "endPoints": "Endpunkte",
    "bitbybit.point.multiplyPoint": "Punkt multiplizieren",
    "multiplyPoint": "Punkt multiplizieren",
    "bitbybit.point.multiplyPoint_description": "multipliziert einen Punkt um einen Betrag",
    "amountOfPoints": "Anzahl Punkte",
    "bitbybit.point.getX": "X abrufen",
    "getX": "X abrufen",
    "bitbybit.point.getX_description": "ruft die X-Koordinate des Punktes ab",
    "bitbybit.point.getY": "Y abrufen",
    "getY": "Y abrufen",
    "bitbybit.point.getY_description": "ruft die Y-Koordinate des Punktes ab",
    "bitbybit.point.getZ": "Z abrufen",
    "getZ": "Z abrufen",
    "bitbybit.point.getZ_description": "ruft die Z-Koordinate des Punktes ab",
    "bitbybit.point.averagePoint": "Durchschnittspunkt",
    "averagePoint": "Durchschnittspunkt",
    "bitbybit.point.averagePoint_description": "ruft den Durchschnittspunkt von Punkten ab",
    "bitbybit.point.pointXYZ": "Punkt XYZ",
    "pointXYZ": "Punkt XYZ",
    "bitbybit.point.pointXYZ_description": "erstellt einen XYZ-Punkt",
    "bitbybit.point.pointXY": "Punkt XY",
    "pointXY": "Punkt XY",
    "bitbybit.point.pointXY_description": "erstellt einen XY-Punkt",
    "bitbybit.point.spiral": "Spirale",
    "spiral": "Spirale",
    "bitbybit.point.spiral_description": "erstellt eine Spirale aus mehreren Punkten",
    "phi": "Phi",
    "numberPoints": "Anzahl Punkte",
    "widening": "Erweiterung",
    "factor": "Faktor",
    "bitbybit.point.hexGrid": "Hex-Gitter",
    "hexGrid": "Hex-Gitter",
    "bitbybit.point.hexGrid_description": "erstellt ein flaches Hex-Gitter in der XY-Ebene",
    "nrHexagonsY": "Anzahl Hexagone Y",
    "nrHexagonsX": "Anzahl Hexagone X",
    "radiusHexagon": "Hexagon-Radius",
    "orientOnCenter": "am Zentrum ausrichten",
    "pointsOnGround": "Punkte auf dem Boden",
    "bitbybit.point.removeConsecutiveDuplicates": "aufeinanderfolgende Duplikate entfernen",
    "removeConsecutiveDuplicates": "aufeinanderfolgende Duplikate entfernen",
    "bitbybit.point.removeConsecutiveDuplicates_description": "entfernt aufeinanderfolgende Duplikate aus einem Punkt-Array",
    "clean": "bereinigen",
    "bitbybit.line.convertToNurbsCurve": "in NURBS-Kurve umwandeln",
    "line": "Linie",
    "convertToNurbsCurve": "in NURBS-Kurve umwandeln",
    "bitbybit.line.convertToNurbsCurve_description": "wandelt eine Linie in eine NURBS-Kurve um",
    "LinePointsDto": "Linienpunkte DTO",
    "bitbybit.line.convertLinesToNurbsCurves": "Linien in NURBS-Kurven umwandeln",
    "convertLinesToNurbsCurves": "Linien in NURBS-Kurven umwandeln",
    "bitbybit.line.convertLinesToNurbsCurves_description": "wandelt Linien in ein Array von NURBS-Kurven um",
    "lines": "Linien",
    "LinePointsDto[]": "Array von Linienpunkten DTO",
    "bitbybit.line.getStartPoint": "Startpunkt abrufen",
    "getStartPoint": "Startpunkt abrufen",
    "bitbybit.line.getStartPoint_description": "ruft den Startpunkt der Linie ab",
    "bitbybit.line.getEndPoint": "Endpunkt abrufen",
    "getEndPoint": "Endpunkt abrufen",
    "bitbybit.line.getEndPoint_description": "ruft den Endpunkt der Linie ab",
    "bitbybit.line.length": "Länge",
    "bitbybit.line.length_description": "ruft die Länge der Linie ab",
    "bitbybit.line.reverse": "umkehren",
    "reverse": "umkehren",
    "bitbybit.line.reverse_description": "kehrt die Endpunkte der Linie um",
    "bitbybit.line.transformLine": "Linie transformieren",
    "transformLine": "Linie transformieren",
    "bitbybit.line.transformLine_description": "transformiert eine Linie",
    "bitbybit.line.transformsForLines": "Transformationen für Linien",
    "transformsForLines": "Transformationen für Linien",
    "bitbybit.line.transformsForLines_description": "transformiert mehrere Linien",
    "bitbybit.line.create": "erstellen",
    "bitbybit.line.create_description": "erstellt eine Linie",
    "bitbybit.line.createAsync": "asynchron",
    "createAsync": "asynchron",
    "bitbybit.line.createAsync_description": "erstellt eine Linie aus asynchronen Punkten",
    "bitbybit.line.getPointOnLine": "Punkt auf Linie abrufen",
    "getPointOnLine": "Punkt auf Linie abrufen",
    "bitbybit.line.getPointOnLine_description": "ruft einen Punkt auf der Linie bei einem Parameter ab",
    "param": "Parameter",
    "bitbybit.line.linesBetweenPoints": "Linien zwischen Punkten",
    "linesBetweenPoints": "Linien zwischen Punkten",
    "bitbybit.line.linesBetweenPoints_description": "erstellt Liniensegmente zwischen Punkten",
    "bitbybit.line.linesBetweenStartAndEndPoints": "Linien zwischen Start- und Endpunkten",
    "linesBetweenStartAndEndPoints": "Linien zwischen Start- und Endpunkten",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "erstellt Linien zwischen Listen von Start- und Endpunkten",
    "startPoints": "Startpunkte",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "Linien zwischen Start- und Endpunkten asynchron",
    "linesBetweenStartAndEndPointsAsync": "Linien zwischen Start- und Endpunkten asynchron",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "erstellt Linien zwischen Start- und Endpunkten mit asynchronen Eingaben",
    "bitbybit.polyline.convertToNurbsCurve": "in NURBS-Kurve umwandeln",
    "polyline": "Polylinie",
    "bitbybit.polyline.convertToNurbsCurve_description": "wandelt eine Polylinie in eine NURBS-Kurve um",
    "PolylinePropertiesDto": "Polylinien-Eigenschaften DTO",
    "bitbybit.polyline.length": "Länge",
    "bitbybit.polyline.length_description": "ruft die Länge der Polylinie ab",
    "bitbybit.polyline.countPoints": "Punkte zählen",
    "countPoints": "Punkte zählen",
    "bitbybit.polyline.countPoints_description": "ruft die Anzahl der Punkte der Polylinie ab",
    "bitbybit.polyline.getPoints": "Punkte abrufen",
    "getPoints": "Punkte abrufen",
    "bitbybit.polyline.getPoints_description": "ruft die Punkte der Polylinie ab",
    "bitbybit.polyline.reverse": "umkehren",
    "bitbybit.polyline.reverse_description": "kehrt die Punkte der Polylinie um",
    "bitbybit.polyline.transformPolyline": "Polylinie transformieren",
    "transformPolyline": "Polylinie transformieren",
    "bitbybit.polyline.transformPolyline_description": "transformiert eine Polylinie",
    "bitbybit.polyline.create": "erstellen",
    "bitbybit.polyline.create_description": "erstellt eine Polylinie",
    "isClosed": "ist geschlossen",
    "string | number[]": "Zeichenkette oder Zahlen-Array",
    "bitbybit.occt.deleteShape": "Form löschen",
    "occt": "OCCT",
    "deleteShape": "Form löschen",
    "bitbybit.occt.deleteShape_description": "löscht eine Form aus dem Cache",
    "bitbybit.occt.deleteShapes": "Formen löschen",
    "deleteShapes": "Formen löschen",
    "bitbybit.occt.deleteShapes_description": "löscht Formen aus dem Cache",
    "shapes": "Formen",
    "T[]": "T-Array",
    "bitbybit.occt.cleanAllCache": "gesamten Cache bereinigen",
    "cleanAllCache": "gesamten Cache bereinigen",
    "bitbybit.occt.cleanAllCache_description": "bereinigt den gesamten Cache und Formen aus dem Speicher",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "Vertex aus XYZ",
    "vertex": "Vertex",
    "vertexFromXYZ": "Vertex aus XYZ",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "erstellt einen Vertex aus XYZ-Koordinaten",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "Vertex aus Punkt",
    "vertexFromPoint": "Vertex aus Punkt",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "erstellt einen Vertex aus einem Punkt",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "Vertices aus Punkten",
    "verticesFromPoints": "Vertices aus Punkten",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "erstellt Vertices aus Punkten",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "Vertices-Verbindung aus Punkten",
    "verticesCompoundFromPoints": "Vertices-Verbindung aus Punkten",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "erstellt eine Verbindung aus Vertices",
    "bitbybit.occt.shapes.vertex.getVertices": "Vertices abrufen",
    "getVertices": "Vertices abrufen",
    "bitbybit.occt.shapes.vertex.getVertices_description": "ruft alle Vertices aus einer Form ab",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "Vertices als Punkte abrufen",
    "getVerticesAsPoints": "Vertices als Punkte abrufen",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "ruft alle Vertices als Punkte ab",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "Vertices zu Punkten",
    "verticesToPoints": "Vertices zu Punkten",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transformiert Vertices zu Punkten",
    "transform": "transformieren",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "Vertex zu Punkt",
    "vertexToPoint": "Vertex zu Punkt",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "transformiert einen Vertex zu einem Punkt",
    "bitbybit.occt.shapes.vertex.projectPoints": "Punkte projizieren",
    "projectPoints": "Punkte projizieren",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "projiziert Punkte auf eine Form",
    "place": "platzieren",
    "projectionType": "Projektionstyp",
    "pointProjectionTypeEnum": "Punktprojektionstyp-Enum",
    "bitbybit.occt.shapes.edge.line": "Linie",
    "edge": "Kante",
    "bitbybit.occt.shapes.edge.line_description": "erstellt eine lineare Kante zwischen zwei Punkten",
    "primitives": "Primitive",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "Bogen durch drei Punkte",
    "arcThroughThreePoints": "Bogen durch drei Punkte",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "erstellt eine Bogenkante durch drei Punkte",
    "middle": "Mitte",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "Bogen durch zwei Punkte und Tangente",
    "arcThroughTwoPointsAndTangent": "Bogen durch zwei Punkte und Tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "erstellt eine Bogenkante mit Tangente am ersten Punkt",
    "tangentVec": "Tangentenvektor",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "Bogen aus Kreis und zwei Punkten",
    "arcFromCircleAndTwoPoints": "Bogen aus Kreis und zwei Punkten",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "erstellt eine Bogenkante auf einem Kreis zwischen zwei Punkten",
    "circle": "Kreis",
    "sense": "Richtung",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "Bogen aus Kreis und zwei Winkeln",
    "arcFromCircleAndTwoAngles": "Bogen aus Kreis und zwei Winkeln",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "erstellt eine Bogenkante auf einem Kreis zwischen zwei Winkeln",
    "alphaAngle1": "Alpha-Winkel 1",
    "alphaAngle2": "Alpha-Winkel 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "Bogen aus Kreis, Punkt und Winkel",
    "arcFromCirclePointAndAngle": "Bogen aus Kreis, Punkt und Winkel",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "erstellt eine Bogenkante auf einem Kreis von einem Punkt bis zu einem Winkel",
    "alphaAngle": "Alpha-Winkel",
    "bitbybit.occt.shapes.edge.createCircleEdge": "Kreiskante",
    "createCircleEdge": "Kreiskante",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "erstellt eine OpenCascade-Kreiskante",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "Ellipsenkante",
    "createEllipseEdge": "Ellipsenkante",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "erstellt eine OpenCascade-Ellipsenkante",
    "radiusMinor": "kleiner Radius",
    "radiusMajor": "großer Radius",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "interne Kanten entfernen",
    "removeInternalEdges": "interne Kanten entfernen",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "entfernt interne Kanten aus einer Form",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "Kante aus 2D-Geometriekurve und Fläche erstellen",
    "makeEdgeFromGeom2dCurveAndSurface": "Kante aus 2D-Geometriekurve und Fläche erstellen",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "erstellt eine Kante aus einer Geometriekurve und einer Fläche",
    "curve": "Kurve",
    "surface": "Fläche",
    "U": "U",
    "bitbybit.occt.shapes.edge.getEdge": "Kante abrufen",
    "getEdge": "Kante abrufen",
    "bitbybit.occt.shapes.edge.getEdge_description": "ruft eine Kante nach Index aus einer Form ab",
    "index": "Index",
    "bitbybit.occt.shapes.edge.getEdges": "Kanten abrufen",
    "getEdges": "Kanten abrufen",
    "bitbybit.occt.shapes.edge.getEdges_description": "ruft Kanten aus einer Form ab",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "Kanten entlang eines Drahtes abrufen",
    "getEdgesAlongWire": "Kanten entlang eines Drahtes abrufen",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "ruft Kanten entlang der Drahtrichtung ab",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "kreisförmige Kanten entlang eines Drahtes abrufen",
    "getCircularEdgesAlongWire": "kreisförmige Kanten entlang eines Drahtes abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "ruft kreisförmige Kanten entlang der Drahtrichtung ab",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "lineare Kanten entlang eines Drahtes abrufen",
    "getLinearEdgesAlongWire": "lineare Kanten entlang eines Drahtes abrufen",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "ruft lineare Kanten entlang der Drahtrichtung ab",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "Eckpunkte der Kanten einer Form abrufen",
    "getCornerPointsOfEdgesForShape": "Eckpunkte der Kanten einer Form abrufen",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "ruft eindeutige Eckpunkte der Kanten ab",
    "bitbybit.occt.shapes.edge.getEdgeLength": "Kantenlänge abrufen",
    "getEdgeLength": "Kantenlänge abrufen",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "ruft die Länge einer Kante ab",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "Kantenlängen einer Form abrufen",
    "getEdgeLengthsOfShape": "Kantenlängen einer Form abrufen",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "ruft Kantenlängen aus einer Form ab",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "Kantenlängen abrufen",
    "getEdgesLengths": "Kantenlängen abrufen",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "ruft die Längen von Kanten ab",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "Schwerpunkt der Kante abrufen",
    "getEdgeCenterOfMass": "Schwerpunkt der Kante abrufen",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "ruft den Schwerpunkt einer Kante ab",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "Schwerpunkte der Kanten abrufen",
    "getEdgesCentersOfMass": "Schwerpunkte der Kanten abrufen",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "ruft die Schwerpunkte von Kanten ab",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "Mittelpunkt der kreisförmigen Kante abrufen",
    "getCircularEdgeCenterPoint": "Mittelpunkt der kreisförmigen Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "ruft den Mittelpunkt einer kreisförmigen Kante ab",
    "get circular edge": "kreisförmige Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "Radius der kreisförmigen Kante abrufen",
    "getCircularEdgeRadius": "Radius der kreisförmigen Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "ruft den Radius einer kreisförmigen Kante ab",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "Ebenenrichtung der kreisförmigen Kante abrufen",
    "getCircularEdgePlaneDirection": "Ebenenrichtung der kreisförmigen Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "ruft die Ebenenrichtung einer kreisförmigen Kante ab",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "Punkt auf Kante bei Parameter",
    "pointOnEdgeAtParam": "Punkt auf Kante bei Parameter",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "ruft einen Punkt auf einer Kante bei einem Parameter ab",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "Punkte auf Kanten bei Parameter",
    "pointsOnEdgesAtParam": "Punkte auf Kanten bei Parameter",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "ruft Punkte auf Kanten bei einem Parameter ab",
    "bitbybit.occt.shapes.edge.edgesToPoints": "Kanten zu Punkten",
    "edgesToPoints": "Kanten zu Punkten",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "ruft Punkte von Kanten in separaten Listen ab",
    "angularDeflection": "Winkelablenkung",
    "curvatureDeflection": "Krümmungsablenkung",
    "minimumOfPoints": "Minimum an Punkten",
    "uTolerance": "U-Toleranz",
    "minimumLength": "Mindestlänge",
    "bitbybit.occt.shapes.edge.reversedEdge": "umgekehrte Kante",
    "reversedEdge": "umgekehrte Kante",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "berechnet eine umgekehrte Kante",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "Tangente auf Kante bei Parameter",
    "tangentOnEdgeAtParam": "Tangente auf Kante bei Parameter",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "ruft einen Tangentenvektor auf einer Kante bei einem Parameter ab",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "Tangenten auf Kanten bei Parameter",
    "tangentsOnEdgesAtParam": "Tangenten auf Kanten bei Parameter",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "ruft Tangentenvektoren auf Kanten bei einem Parameter ab",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "Punkt auf Kante bei Länge",
    "pointOnEdgeAtLength": "Punkt auf Kante bei Länge",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "ruft einen Punkt auf einer Kante bei einer Länge ab",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "Punkte auf Kanten bei Länge",
    "pointsOnEdgesAtLength": "Punkte auf Kanten bei Länge",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "ruft Punkte auf Kanten bei einer Länge ab",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "Tangente auf Kante bei Länge",
    "tangentOnEdgeAtLength": "Tangente auf Kante bei Länge",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "ruft einen Tangentenvektor auf einer Kante bei einer Länge ab",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "Tangenten auf Kanten bei Länge",
    "tangentsOnEdgesAtLength": "Tangenten auf Kanten bei Länge",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "ruft Tangentenvektoren auf Kanten bei einer Länge ab",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "Startpunkt auf Kante",
    "startPointOnEdge": "Startpunkt auf Kante",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "ruft den Startpunkt auf einer Kante ab",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "Startpunkte auf Kanten",
    "startPointsOnEdges": "Startpunkte auf Kanten",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "ruft Startpunkte auf Kanten ab",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "Endpunkt auf Kante",
    "endPointOnEdge": "Endpunkt auf Kante",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "ruft den Endpunkt auf einer Kante ab",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "Endpunkte auf Kanten",
    "endPointsOnEdges": "Endpunkte auf Kanten",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "ruft Endpunkte auf Kanten ab",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "Kante nach Parametern in Punkte teilen",
    "divideEdgeByParamsToPoints": "Kante nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "teilt eine Kante nach Parametern in Punkte",
    "nrOfDivisions": "Anzahl der Teilungen",
    "removeStartPoint": "Startpunkt entfernen",
    "removeEndPoint": "Endpunkt entfernen",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "Kanten nach Parametern in Punkte teilen",
    "divideEdgesByParamsToPoints": "Kanten nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "teilt Kanten nach Parametern in Punkte",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "Kante nach gleichem Abstand in Punkte teilen",
    "divideEdgeByEqualDistanceToPoints": "Kante nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "teilt eine Kante nach Länge in Punkte",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "Kanten nach gleichem Abstand in Punkte teilen",
    "divideEdgesByEqualDistanceToPoints": "Kanten nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "teilt Kanten nach Länge in Punkte",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "Tangentenlinien von zwei Punkten zu einem Kreis einschränken",
    "constraintTanLinesFromTwoPtsToCircle": "Tangentenlinien von zwei Punkten zu einem Kreis einschränken",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "erstellt Linien von zwei Punkten zu Kreistangenten",
    "constraint": "Einschränkung",
    "point1": "Punkt 1",
    "point2": "Punkt 2",
    "positionResult": "Positionsergebnis",
    "positionResultEnum": "Positionsergebnis-Enum",
    "circleRemainder": "Kreisrest",
    "circleInclusionEnum": "Kreiseinschluss-Enum",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "Tangentenlinien von einem Punkt zu einem Kreis einschränken",
    "constraintTanLinesFromPtToCircle": "Tangentenlinien von einem Punkt zu einem Kreis einschränken",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "erstellt Linien von einem Punkt zu Kreistangenten",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "Tangentenlinien auf zwei Kreisen einschränken",
    "constraintTanLinesOnTwoCircles": "Tangentenlinien auf zwei Kreisen einschränken",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "erstellt Tangentenlinien zwischen zwei Kreisen",
    "circle1": "Kreis 1",
    "circle2": "Kreis 2",
    "circleRemainders": "Kreisreste",
    "twoCircleInclusionEnum": "Zwei-Kreiseinschluss-Enum",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "Tangentenkreise auf zwei Kreisen einschränken",
    "constraintTanCirclesOnTwoCircles": "Tangentenkreise auf zwei Kreisen einschränken",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "erstellt Tangentenkreise zwischen zwei Kreisen",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "Tangentenkreise auf Kreis und Punkt einschränken",
    "constraintTanCirclesOnCircleAndPnt": "Tangentenkreise auf Kreis und Punkt einschränken",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "erstellt Tangentenkreise zwischen einem Punkt und einem Kreis",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "ist Kante linear",
    "isEdgeLinear": "ist Kante linear",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "prüft, ob die Kante linear ist",
    "is": "ist",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "ist Kante kreisförmig",
    "isEdgeCircular": "ist Kante kreisförmig",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "prüft, ob die Kante kreisförmig ist",
    "bitbybit.occt.shapes.wire.createPolygonWire": "Polygon-Draht",
    "wire": "Draht",
    "createPolygonWire": "Polygon-Draht",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "erstellt einen OpenCascade-Polygon-Draht",
    "via points": "über Punkte",
    "bitbybit.occt.shapes.wire.createPolygons": "Polygone",
    "createPolygons": "Polygone",
    "bitbybit.occt.shapes.wire.createPolygons_description": "erstellt OpenCascade-Polygone",
    "multiple": "mehrere",
    "polygons": "Polygone",
    "PolygonDto[]": "Polygon-DTO-Array",
    "returnCompound": "Verbindung zurückgeben",
    "bitbybit.occt.shapes.wire.createLineWire": "Linien-Draht",
    "createLineWire": "Linien-Draht",
    "bitbybit.occt.shapes.wire.createLineWire_description": "erstellt einen OpenCascade-Linien-Draht",
    "bitbybit.occt.shapes.wire.createLines": "Linien",
    "createLines": "Linien",
    "bitbybit.occt.shapes.wire.createLines_description": "erstellt OpenCascade-Linien",
    "LineDto[]": "Linien-DTO-Array",
    "bitbybit.occt.shapes.wire.splitOnPoints": "an Punkten teilen",
    "splitOnPoints": "an Punkten teilen",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "teilt einen Draht an gegebenen Punkten",
    "bitbybit.occt.shapes.wire.wiresToPoints": "Drähte zu Punkten",
    "wiresToPoints": "Drähte zu Punkten",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "transformiert Drähte in Punkte in geordneten Listen",
    "bitbybit.occt.shapes.wire.createPolylineWire": "Polylinien-Draht",
    "createPolylineWire": "Polylinien-Draht",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "erstellt einen OpenCascade-Polylinien-Draht",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "Zickzack zwischen zwei Drähten",
    "createZigZagBetweenTwoWires": "Zickzack zwischen zwei Drähten",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "erstellt einen Zickzack zwischen zwei Drähten",
    "via wires": "über Drähte",
    "wire1": "Draht 1",
    "wire2": "Draht 2",
    "nrZigZags": "Anzahl Zickzacks",
    "inverse": "invers",
    "divideByEqualDistance": "nach gleichem Abstand teilen",
    "zigZagsPerEdge": "Zickzacks pro Kante",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "Draht aus zwei tangentialen Kreisen",
    "createWireFromTwoCirclesTan": "Draht aus zwei tangentialen Kreisen",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "erstellt einen tangentialen Draht, der zwei planare Kreise umschließt",
    "keepLines": "Linien behalten",
    "twoSidesStrictEnum": "zwei Seiten strikt Enum",
    "fourSidesStrictEnum": "vier Seiten strikt Enum",
    "bitbybit.occt.shapes.wire.createPolylines": "Polylinien",
    "createPolylines": "Polylinien",
    "bitbybit.occt.shapes.wire.createPolylines_description": "erstellt OpenCascade-Polylinien-Drähte",
    "polylines": "Polylinien",
    "PolylineDto[]": "Polylinien-DTO-Array",
    "bitbybit.occt.shapes.wire.createBezier": "Bezier",
    "createBezier": "Bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "erstellt einen OpenCascade-Bezier-Draht",
    "bitbybit.occt.shapes.wire.createBezierWeights": "Bezier-Gewichte",
    "createBezierWeights": "Bezier-Gewichte",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "erstellt einen OpenCascade-Bezier-Draht mit Gewichten",
    "weights": "Gewichte",
    "bitbybit.occt.shapes.wire.createBezierWires": "Bezier-Drähte",
    "createBezierWires": "Bezier-Drähte",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "erstellt OpenCascade-Bezier-Drähte",
    "bezierWires": "Bezier-Drähte",
    "BezierDto[]": "Bezier-DTO-Array",
    "bitbybit.occt.shapes.wire.interpolatePoints": "Punkte interpolieren",
    "interpolatePoints": "Punkte interpolieren",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "erstellt einen OpenCascade-BSpline-Draht aus Punkten",
    "periodic": "periodisch",
    "bitbybit.occt.shapes.wire.interpolateWires": "Drähte interpolieren",
    "interpolateWires": "Drähte interpolieren",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "erstellt mehrere OpenCascade-interpolierte Drähte",
    "interpolations": "Interpolationen",
    "InterpolationDto[]": "Interpolations-DTO-Array",
    "bitbybit.occt.shapes.wire.createBSpline": "BSpline",
    "createBSpline": "BSpline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "erstellt einen OpenCascade-BSpline-Draht",
    "bitbybit.occt.shapes.wire.createBSplines": "BSplines",
    "createBSplines": "BSplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "erstellt OpenCascade-BSpline-Drähte",
    "bSplines": "BSplines",
    "BSplineDto[]": "BSpline-DTO-Array",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "Kanten und Drähte zu einem Draht kombinieren",
    "combineEdgesAndWiresIntoAWire": "Kanten und Drähte zu einem Draht kombinieren",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "kombiniert Kanten und Drähte zu einem einzigen Draht",
    "build": "bauen",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "Draht aus Kante",
    "createWireFromEdge": "Draht aus Kante",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "erstellt einen Draht aus einer Kante",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "Kanten und Drähte zu Draht hinzufügen",
    "addEdgesAndWiresToWire": "Kanten und Drähte zu Draht hinzufügen",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "fügt Kanten und Drähte zu einem Draht hinzu",
    "U[]": "U-Array",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "Draht nach Parametern in Punkte teilen",
    "divideWireByParamsToPoints": "Draht nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "teilt einen Draht nach Parametern in Punkte",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "Drähte nach Parametern in Punkte teilen",
    "divideWiresByParamsToPoints": "Drähte nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "teilt Drähte nach Parametern in Punkte",
    "extract from wires": "aus Drähten extrahieren",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "Draht nach gleichem Abstand in Punkte teilen",
    "divideWireByEqualDistanceToPoints": "Draht nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "teilt einen Draht in Punkte mit gleichem Abstand",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "Drähte nach gleichem Abstand in Punkte teilen",
    "divideWiresByEqualDistanceToPoints": "Drähte nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "teilt Drähte in Punkte mit gleichem Abstand",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "Punkt auf Draht bei Parameter",
    "pointOnWireAtParam": "Punkt auf Draht bei Parameter",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "ruft einen Punkt auf einem Draht bei einem Parameter ab",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "Punkt auf Draht bei Länge",
    "pointOnWireAtLength": "Punkt auf Draht bei Länge",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "ruft einen Punkt auf einem Draht bei einer Länge ab",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "Punkte auf Draht bei Längen",
    "pointsOnWireAtLengths": "Punkte auf Draht bei Längen",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "ruft Punkte auf einem Draht bei Längen ab",
    "lengths": "Längen",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "Punkte auf Draht bei gleicher Länge",
    "pointsOnWireAtEqualLength": "Punkte auf Draht bei gleicher Länge",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "ruft Punkte auf einem Draht bei gleicher Länge ab",
    "tryNext": "nächsten versuchen",
    "includeFirst": "ersten einschließen",
    "includeLast": "letzten einschließen",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "Punkte auf Draht bei Längenmuster",
    "pointsOnWireAtPatternOfLengths": "Punkte auf Draht bei Längenmuster",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "ruft Punkte auf einem Draht bei einem Längenmuster ab",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "Tangente auf Draht bei Parameter",
    "tangentOnWireAtParam": "Tangente auf Draht bei Parameter",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "ruft einen Tangentenvektor auf einem Draht bei einem Parameter ab",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "Tangente auf Draht bei Länge",
    "tangentOnWireAtLength": "Tangente auf Draht bei Länge",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "ruft einen Tangentenvektor auf einem Draht bei einer Länge ab",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "Ableitungen auf Draht bei Länge",
    "derivativesOnWireAtLength": "Ableitungen auf Draht bei Länge",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "berechnet 3 Ableitungen auf einem Draht bei einer Länge",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "Ableitungen auf Draht bei Parameter",
    "derivativesOnWireAtParam": "Ableitungen auf Draht bei Parameter",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "berechnet 3 Ableitungen auf einem Draht bei einem Parameter",
    "bitbybit.occt.shapes.wire.startPointOnWire": "Startpunkt auf Draht",
    "startPointOnWire": "Startpunkt auf Draht",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "ruft den Startpunkt auf einem Draht ab",
    "bitbybit.occt.shapes.wire.endPointOnWire": "Endpunkt auf Draht",
    "endPointOnWire": "Endpunkt auf Draht",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "ruft den Endpunkt auf einem Draht ab",
    "bitbybit.occt.shapes.wire.createCircleWire": "Kreis-Draht",
    "createCircleWire": "Kreis-Draht",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "erstellt einen OpenCascade-Kreis-Draht",
    "bitbybit.occt.shapes.wire.createSquareWire": "Quadrat-Draht",
    "createSquareWire": "Quadrat-Draht",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "erstellt einen OpenCascade-Quadrat-Draht",
    "bitbybit.occt.shapes.wire.createStarWire": "Stern-Draht",
    "createStarWire": "Stern-Draht",
    "bitbybit.occt.shapes.wire.createStarWire_description": "erstellt einen OpenCascade-Stern-Draht",
    "numRays": "Anzahl Strahlen",
    "outerRadius": "äußerer Radius",
    "innerRadius": "innerer Radius",
    "offsetOuterEdges": "äußere Kanten versetzen",
    "half": "Hälfte",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "Weihnachtsbaum-Draht",
    "createChristmasTreeWire": "Weihnachtsbaum-Draht",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "erstellt einen Weihnachtsbaum-Draht",
    "innerDist": "innerer Abstand",
    "outerDist": "äußerer Abstand",
    "nrSkirts": "Anzahl Röcke",
    "trunkHeight": "Stammhöhe",
    "trunkWidth": "Stammbreite",
    "bitbybit.occt.shapes.wire.createNGonWire": "N-Eck-Draht",
    "createNGonWire": "N-Eck-Draht",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "erstellt einen OpenCascade-N-Eck-Draht",
    "nrCorners": "Anzahl Ecken",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "Parallelogramm-Draht",
    "createParallelogramWire": "Parallelogramm-Draht",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "erstellt einen Parallelogramm-Draht",
    "aroundCenter": "um Zentrum",
    "bitbybit.occt.shapes.wire.createHeartWire": "Herz-Draht",
    "createHeartWire": "Herz-Draht",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "erstellt einen Herz-Draht",
    "sizeApprox": "ungefähre Größe",
    "bitbybit.occt.shapes.wire.createRectangleWire": "Rechteck-Draht",
    "createRectangleWire": "Rechteck-Draht",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "erstellt einen OpenCascade-Rechteck-Draht",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "L-Polygon-Draht",
    "createLPolygonWire": "L-Polygon-Draht",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "erstellt einen OpenCascade-L-Polygon-Draht",
    "widthFirst": "erste Breite",
    "lengthFirst": "erste Länge",
    "widthSecond": "zweite Breite",
    "lengthSecond": "zweite Länge",
    "align": "ausrichten",
    "directionEnum": "Richtungs-Enum",
    "bitbybit.occt.shapes.wire.createEllipseWire": "Ellipsen-Draht",
    "createEllipseWire": "Ellipsen-Draht",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "erstellt einen OpenCascade-Ellipsen-Draht",
    "bitbybit.occt.shapes.wire.textWires": "Textkonturen",
    "textWires": "Textkonturen",
    "bitbybit.occt.shapes.wire.textWires_description": "Erstellt OpenCascade-Textkonturen basierend auf der von Dr. A. V. Hershey erstellten Simplex-Schriftart.",
    "xOffset": "x-Versatz",
    "yOffset": "y-Versatz",
    "letterSpacing": "Buchstabenabstand",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "Extrusionsversatz",
    "bitbybit.occt.shapes.wire.getWire": "Draht abrufen",
    "getWire": "Draht abrufen",
    "bitbybit.occt.shapes.wire.getWire_description": "ruft einen Draht nach Index aus einer Form ab",
    "bitbybit.occt.shapes.wire.getWires": "Drähte abrufen",
    "getWires": "Drähte abrufen",
    "bitbybit.occt.shapes.wire.getWires_description": "ruft alle Drähte aus einer Form ab",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "Schwerpunkt des Drahtes abrufen",
    "getWireCenterOfMass": "Schwerpunkt des Drahtes abrufen",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "ruft den Schwerpunkt eines Drahtes als Punkt ab",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "Schwerpunkte der Drähte abrufen",
    "getWiresCentersOfMass": "Schwerpunkte der Drähte abrufen",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "ruft die Schwerpunkte der Drähte als Punkte ab",
    "bitbybit.occt.shapes.wire.reversedWire": "umgekehrter Draht",
    "reversedWire": "umgekehrter Draht",
    "bitbybit.occt.shapes.wire.reversedWire_description": "berechnet einen umgekehrten Draht",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "umgekehrter Draht aus umgekehrten Kanten",
    "reversedWireFromReversedEdges": "umgekehrter Draht aus umgekehrten Kanten",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "berechnet einen umgekehrten Draht aus umgekehrten Kanten",
    "bitbybit.occt.shapes.wire.isWireClosed": "ist Draht geschlossen",
    "isWireClosed": "ist Draht geschlossen",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "prüft, ob ein Draht geschlossen ist",
    "bitbybit.occt.shapes.wire.getWireLength": "Drahtlänge abrufen",
    "getWireLength": "Drahtlänge abrufen",
    "bitbybit.occt.shapes.wire.getWireLength_description": "ruft die Länge eines Drahtes ab",
    "bitbybit.occt.shapes.wire.getWiresLengths": "Drahtlängen abrufen",
    "getWiresLengths": "Drahtlängen abrufen",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "ruft die Längen von Drähten ab",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "Draht auf Fläche platzieren",
    "placeWireOnFace": "Draht auf Fläche platzieren",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "platziert einen Draht auf einer Fläche unter Verwendung des UV-Raums",
    "face": "Fläche",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "Drähte auf Fläche platzieren",
    "placeWiresOnFace": "Drähte auf Fläche platzieren",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "platziert mehrere Drähte auf einer Fläche unter Verwendung des UV-Raums",
    "wires": "Drähte",
    "bitbybit.occt.shapes.wire.closeOpenWire": "offenen Draht schließen",
    "closeOpenWire": "offenen Draht schließen",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "schließt einen offenen Draht mit einer geraden Kante",
    "bitbybit.occt.shapes.wire.project": "projizieren",
    "project": "projizieren",
    "bitbybit.occt.shapes.wire.project_description": "projiziert einen Draht auf eine Form",
    "bitbybit.occt.shapes.wire.projectWires": "Drähte projizieren",
    "projectWires": "Drähte projizieren",
    "bitbybit.occt.shapes.wire.projectWires_description": "projiziert mehrere Drähte auf eine Form",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "Flächen aus Drähten auf Fläche",
    "createFacesFromWiresOnFace": "Flächen aus Drähten auf Fläche",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "erstellt Flächen aus Drähten auf einer Fläche",
    "inside": "innen",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "Fläche aus Draht auf Fläche",
    "createFaceFromWireOnFace": "Fläche aus Draht auf Fläche",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "erstellt eine Fläche aus einem Draht auf einer Fläche",
    "bitbybit.occt.shapes.face.createFaceFromWire": "Fläche aus Draht",
    "createFaceFromWire": "Fläche aus Draht",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "erstellt eine Fläche aus einem Draht",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "Fläche aus Drähten",
    "createFaceFromWires": "Fläche aus Drähten",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "erstellt eine Fläche aus Drähten",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "Fläche aus Drähten auf Fläche",
    "createFaceFromWiresOnFace": "Fläche aus Drähten auf Fläche",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "erstellt eine Fläche aus Drähten auf einer führenden Fläche",
    "bitbybit.occt.shapes.face.createFacesFromWires": "Flächen aus Drähten",
    "createFacesFromWires": "Flächen aus Drähten",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "erstellt Flächen aus Drähten",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "Fläche aus mehreren tangentialen Kreisdrähten",
    "createFaceFromMultipleCircleTanWires": "Fläche aus mehreren tangentialen Kreisdrähten",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "erstellt eine Fläche aus mehreren tangentialen Kreisdrähten",
    "circles": "Kreise",
    "combination": "Kombination",
    "combinationCirclesForFaceEnum": "Kombination-Kreise-für-Fläche-Enum",
    "unify": "vereinigen",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "Fläche aus mehreren tangentialen Kreis-Drahtsammlungen",
    "createFaceFromMultipleCircleTanWireCollections": "Fläche aus mehreren tangentialen Kreis-Drahtsammlungen",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "erstellt eine Fläche aus mehreren tangentialen Kreis-Drahtsammlungen",
    "listsOfCircles": "Listen von Kreisen",
    "T[][]": "T-Array-Array",
    "bitbybit.occt.shapes.face.faceFromSurface": "Fläche aus Fläche",
    "faceFromSurface": "Fläche aus Fläche",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "erstellt eine Fläche aus einer Fläche",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "Fläche aus Fläche und Draht",
    "faceFromSurfaceAndWire": "Fläche aus Fläche und Draht",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "erstellt eine Fläche aus einer Fläche und einem Draht",
    "bitbybit.occt.shapes.face.createPolygonFace": "Polygon-Fläche",
    "createPolygonFace": "Polygon-Fläche",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "erstellt eine OpenCascade-Polygon-Fläche",
    "bitbybit.occt.shapes.face.createCircleFace": "Kreis-Fläche",
    "createCircleFace": "Kreis-Fläche",
    "bitbybit.occt.shapes.face.createCircleFace_description": "erstellt eine OpenCascade-Kreis-Fläche",
    "bitbybit.occt.shapes.face.createEllipseFace": "Ellipsen-Fläche",
    "createEllipseFace": "Ellipsen-Fläche",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "erstellt eine OpenCascade-Ellipsen-Fläche",
    "bitbybit.occt.shapes.face.createSquareFace": "Quadrat-Fläche",
    "createSquareFace": "Quadrat-Fläche",
    "bitbybit.occt.shapes.face.createSquareFace_description": "erstellt eine OpenCascade-Quadrat-Fläche",
    "bitbybit.occt.shapes.face.createRectangleFace": "Rechteck-Fläche",
    "createRectangleFace": "Rechteck-Fläche",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "erstellt eine OpenCascade-Rechteck-Fläche",
    "bitbybit.occt.shapes.face.getFace": "Fläche abrufen",
    "getFace": "Fläche abrufen",
    "bitbybit.occt.shapes.face.getFace_description": "ruft eine Fläche nach Index aus einer Form ab",
    "bitbybit.occt.shapes.face.getFaces": "Flächen abrufen",
    "getFaces": "Flächen abrufen",
    "bitbybit.occt.shapes.face.getFaces_description": "ruft Flächen aus einer Form ab",
    "bitbybit.occt.shapes.face.reversedFace": "umgekehrte Fläche",
    "reversedFace": "umgekehrte Fläche",
    "bitbybit.occt.shapes.face.reversedFace_description": "berechnet eine umgekehrte Fläche",
    "bitbybit.occt.shapes.face.subdivideToPoints": "in Punkte unterteilen",
    "subdivideToPoints": "in Punkte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "unterteilt eine Fläche in ein Punktgitter",
    "nrDivisionsU": "Anzahl Teilungen U",
    "nrDivisionsV": "Anzahl Teilungen V",
    "shiftHalfStepU": "halben Schritt U verschieben",
    "removeStartEdgeU": "Startkante U entfernen",
    "removeEndEdgeU": "Endkante U entfernen",
    "shiftHalfStepV": "halben Schritt V verschieben",
    "removeStartEdgeV": "Startkante V entfernen",
    "removeEndEdgeV": "Endkante V entfernen",
    "bitbybit.occt.shapes.face.subdivideToWires": "in Drähte unterteilen",
    "subdivideToWires": "in Drähte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "unterteilt eine Fläche in Drähte",
    "nrDivisions": "Anzahl Teilungen",
    "isU": "ist U",
    "shiftHalfStep": "halben Schritt verschieben",
    "removeStart": "Start entfernen",
    "removeEnd": "Ende entfernen",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "in Rechteck-Drähte unterteilen",
    "subdivideToRectangleWires": "in Rechteck-Drähte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "unterteilt eine Fläche in Rechteck-Drähte",
    "patterns": "Muster",
    "nrRectanglesU": "Anzahl Rechtecke U",
    "nrRectanglesV": "Anzahl Rechtecke V",
    "scalePatternU": "Muster U skalieren",
    "scalePatternV": "Muster V skalieren",
    "filletPattern": "Rundungsmuster",
    "inclusionPattern": "Einschlussmuster",
    "offsetFromBorderU": "Versatz von Rand U",
    "offsetFromBorderV": "Versatz von Rand V",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "in Rechtecklöcher unterteilen",
    "subdivideToRectangleHoles": "in Rechtecklöcher unterteilen",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "unterteilt eine Fläche in Rechteckdrähte",
    "holesToFaces": "Löcher zu Flächen",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "kontrolliert in Punkte unterteilen",
    "subdivideToPointsControlled": "kontrolliert in Punkte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "unterteilt eine Fläche in ein Punktgitter mit kontrollierten Verschiebungen",
    "shiftHalfStepNthU": "halben Schritt N-ter U verschieben",
    "shiftHalfStepUOffsetN": "halben Schritt U Versatz N verschieben",
    "removeStartEdgeNthU": "Startkante N-ter U entfernen",
    "removeStartEdgeUOffsetN": "Startkante U Versatz N entfernen",
    "removeEndEdgeNthU": "Endkante N-ter U entfernen",
    "removeEndEdgeUOffsetN": "Endkante U Versatz N entfernen",
    "shiftHalfStepNthV": "halben Schritt N-ter V verschieben",
    "shiftHalfStepVOffsetN": "halben Schritt V Versatz N verschieben",
    "removeStartEdgeNthV": "Startkante N-ter V entfernen",
    "removeStartEdgeVOffsetN": "Startkante V Versatz N entfernen",
    "removeEndEdgeNthV": "Endkante N-ter V entfernen",
    "removeEndEdgeVOffsetN": "Endkante V Versatz N entfernen",
    "bitbybit.occt.shapes.face.subdivideToNormals": "in Normalen unterteilen",
    "subdivideToNormals": "in Normalen unterteilen",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "unterteilt eine Fläche in ein Normalengitter",
    "bitbybit.occt.shapes.face.subdivideToUV": "in UV unterteilen",
    "subdivideToUV": "in UV unterteilen",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "unterteilt eine Fläche in ein UV-Gitter",
    "bitbybit.occt.shapes.face.pointOnUV": "Punkt auf UV",
    "pointOnUV": "Punkt auf UV",
    "bitbybit.occt.shapes.face.pointOnUV_description": "ruft einen Punkt auf UV ab, der auf Grenzen abgebildet ist",
    "paramU": "Parameter U",
    "paramV": "Parameter V",
    "bitbybit.occt.shapes.face.normalOnUV": "Normale auf UV",
    "normalOnUV": "Normale auf UV",
    "bitbybit.occt.shapes.face.normalOnUV_description": "ruft eine Normale auf UV ab, die auf Grenzen abgebildet ist",
    "bitbybit.occt.shapes.face.pointsOnUVs": "Punkte auf UVs",
    "pointsOnUVs": "Punkte auf UVs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "ruft Punkte auf UVs ab, die auf Grenzen abgebildet sind",
    "paramsUV": "Parameter UV",
    "[number, number][]": "Zahlenpaar-Array",
    "bitbybit.occt.shapes.face.normalsOnUVs": "Normalen auf UVs",
    "normalsOnUVs": "Normalen auf UVs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "ruft Normalen auf UVs ab, die auf Grenzen abgebildet sind",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "in Punkte bei Parameter unterteilen",
    "subdivideToPointsOnParam": "in Punkte bei Parameter unterteilen",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "unterteilt eine Fläche in Punkte bei Parameter",
    "nrPoints": "Anzahl Punkte",
    "bitbybit.occt.shapes.face.wireAlongParam": "Draht entlang Parameter",
    "wireAlongParam": "Draht entlang Parameter",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "ruft einen Draht entlang eines Parameters auf einer Fläche ab",
    "bitbybit.occt.shapes.face.wiresAlongParams": "Drähte entlang Parameter",
    "wiresAlongParams": "Drähte entlang Parameter",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "ruft Drähte entlang Parametern auf einer Fläche ab",
    "params": "Parameter",
    "bitbybit.occt.shapes.face.getUMinBound": "U-Minimum-Grenze abrufen",
    "getUMinBound": "U-Minimum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getUMinBound_description": "ruft die U-Minimum-Grenze einer Fläche ab",
    "bitbybit.occt.shapes.face.getUMaxBound": "U-Maximum-Grenze abrufen",
    "getUMaxBound": "U-Maximum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "ruft die U-Maximum-Grenze einer Fläche ab",
    "bitbybit.occt.shapes.face.getVMinBound": "V-Minimum-Grenze abrufen",
    "getVMinBound": "V-Minimum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getVMinBound_description": "ruft die V-Minimum-Grenze einer Fläche ab",
    "bitbybit.occt.shapes.face.getVMaxBound": "V-Maximum-Grenze abrufen",
    "getVMaxBound": "V-Maximum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "ruft die V-Maximum-Grenze einer Fläche ab",
    "bitbybit.occt.shapes.face.getFaceArea": "Flächeninhalt abrufen",
    "getFaceArea": "Flächeninhalt abrufen",
    "bitbybit.occt.shapes.face.getFaceArea_description": "ruft den Flächeninhalt einer Fläche ab",
    "bitbybit.occt.shapes.face.getFacesAreas": "Flächeninhalte abrufen",
    "getFacesAreas": "Flächeninhalte abrufen",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "ruft die Flächeninhalte von Flächen ab",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "Schwerpunkt der Fläche abrufen",
    "getFaceCenterOfMass": "Schwerpunkt der Fläche abrufen",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "ruft den Schwerpunkt einer Fläche als Punkt ab",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "Schwerpunkte der Flächen abrufen",
    "getFacesCentersOfMass": "Schwerpunkte der Flächen abrufen",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "ruft die Schwerpunkte von Flächen ab",
    "bitbybit.occt.shapes.face.filterFacePoints": "Flächenpunkte filtern",
    "filterFacePoints": "Flächenpunkte filtern",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtert Punkte auf einer Fläche",
    "filter": "filtern",
    "useBndBox": "Begrenzungsbox verwenden",
    "gapTolerance": "Spalttoleranz",
    "keepIn": "behalten innen",
    "keepOn": "behalten auf",
    "keepOut": "behalten außen",
    "keepUnknown": "behalten unbekannt",
    "bitbybit.occt.shapes.face.filterFacesPoints": "Punkte von Flächen filtern",
    "filterFacesPoints": "Punkte von Flächen filtern",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtert Punkte auf Flächen",
    "flatPointsArray": "flaches Punkte-Array",
    "bitbybit.occt.shapes.shell.sewFaces": "Flächen zusammennähen",
    "shell": "Schale",
    "sewFaces": "Flächen zusammennähen",
    "bitbybit.occt.shapes.shell.sewFaces_description": "erstellt eine Schale aus Flächen",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "Oberflächeninhalt der Schale abrufen",
    "getShellSurfaceArea": "Oberflächeninhalt der Schale abrufen",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "ruft den Oberflächeninhalt einer Schale ab",
    "bitbybit.occt.shapes.solid.fromClosedShell": "aus geschlossener Schale",
    "solid": "Volumenkörper",
    "fromClosedShell": "aus geschlossener Schale",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "erstellt einen Volumenkörper aus einer geschlossenen Schale",
    "bitbybit.occt.shapes.solid.createBox": "Quader",
    "bitbybit.occt.shapes.solid.createBox_description": "erstellt einen OpenCascade-Quader",
    "originOnCenter": "Ursprung im Zentrum",
    "bitbybit.occt.shapes.solid.createCube": "Würfel",
    "bitbybit.occt.shapes.solid.createCube_description": "erstellt einen OpenCascade-Würfel",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "Quader aus Ecke",
    "createBoxFromCorner": "Quader aus Ecke",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "erstellt einen OpenCascade-Quader aus einer Ecke",
    "corner": "Ecke",
    "bitbybit.occt.shapes.solid.createCylinder": "Zylinder",
    "bitbybit.occt.shapes.solid.createCylinder_description": "erstellt einen OpenCascade-Zylinder",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "Zylinder auf Linien",
    "createCylindersOnLines": "Zylinder auf Linien",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "erstellt OpenCascade-Zylinder auf Linien",
    "Base.Line3[]": "Basis-Linien-3-Array",
    "bitbybit.occt.shapes.solid.createSphere": "Kugel",
    "bitbybit.occt.shapes.solid.createSphere_description": "erstellt eine OpenCascade-Kugel",
    "bitbybit.occt.shapes.solid.createCone": "Kegel",
    "createCone": "Kegel",
    "bitbybit.occt.shapes.solid.createCone_description": "erstellt einen OpenCascade-Kegel",
    "radius1": "Radius 1",
    "radius2": "Radius 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "Oberflächeninhalt des Volumenkörpers abrufen",
    "getSolidSurfaceArea": "Oberflächeninhalt des Volumenkörpers abrufen",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "ruft den Oberflächeninhalt eines Volumenkörpers ab",
    "bitbybit.occt.shapes.solid.getSolidVolume": "Volumen des Volumenkörpers abrufen",
    "getSolidVolume": "Volumen des Volumenkörpers abrufen",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "ruft das Volumen eines Volumenkörpers ab",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "Volumen der Volumenkörper abrufen",
    "getSolidsVolumes": "Volumen der Volumenkörper abrufen",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "ruft die Volumen von Volumenkörpern ab",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "Schwerpunkt des Volumenkörpers abrufen",
    "getSolidCenterOfMass": "Schwerpunkt des Volumenkörpers abrufen",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "ruft den Schwerpunkt eines Volumenkörpers ab",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "Schwerpunkte der Volumenkörper abrufen",
    "getSolidsCentersOfMass": "Schwerpunkte der Volumenkörper abrufen",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "ruft die Schwerpunkte von Volumenkörpern ab",
    "bitbybit.occt.shapes.solid.getSolids": "Volumenkörper abrufen",
    "getSolids": "Volumenkörper abrufen",
    "bitbybit.occt.shapes.solid.getSolids_description": "ruft Volumenkörper aus einer Form ab",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "Punkte des Volumenkörpers filtern",
    "filterSolidPoints": "Punkte des Volumenkörpers filtern",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "filtert Punkte basierend auf der Beziehung zum Volumenkörper",
    "bitbybit.occt.shapes.compound.makeCompound": "Verbindung erstellen",
    "compound": "Verbindung",
    "makeCompound": "Verbindung erstellen",
    "bitbybit.occt.shapes.compound.makeCompound_description": "erstellt eine Verbindungsform aus Formen",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "Formen der Verbindung abrufen",
    "getShapesOfCompound": "Formen der Verbindung abrufen",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "ruft Formen aus einer Verbindung ab",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "interne Kanten bereinigen",
    "purgeInternalEdges": "interne Kanten bereinigen",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "entfernt interne Kanten aus einer Form",
    "bitbybit.occt.shapes.shape.unifySameDomain": "gleiche Domäne vereinigen",
    "unifySameDomain": "gleiche Domäne vereinigen",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "vereinigt Flächen und Kanten in derselben Domäne",
    "unifyEdges": "Kanten vereinigen",
    "unifyFaces": "Flächen vereinigen",
    "concatBSplines": "BSplines zusammenführen",
    "bitbybit.occt.shapes.shape.isClosed": "ist geschlossen",
    "bitbybit.occt.shapes.shape.isClosed_description": "prüft, ob die Form geschlossen ist",
    "analysis": "Analyse",
    "bitbybit.occt.shapes.shape.isConvex": "ist konvex",
    "isConvex": "ist konvex",
    "bitbybit.occt.shapes.shape.isConvex_description": "prüft, ob die Form konvex ist",
    "bitbybit.occt.shapes.shape.isChecked": "ist geprüft",
    "bitbybit.occt.shapes.shape.isChecked_description": "prüft, ob die Form geprüft ist",
    "bitbybit.occt.shapes.shape.isFree": "ist frei",
    "isFree": "ist frei",
    "bitbybit.occt.shapes.shape.isFree_description": "prüft, ob die Form frei ist",
    "bitbybit.occt.shapes.shape.isInfinite": "ist unendlich",
    "isInfinite": "ist unendlich",
    "bitbybit.occt.shapes.shape.isInfinite_description": "prüft, ob die Form unendlich ist",
    "bitbybit.occt.shapes.shape.isModified": "ist modifiziert",
    "isModified": "ist modifiziert",
    "bitbybit.occt.shapes.shape.isModified_description": "prüft, ob die Form modifiziert ist",
    "bitbybit.occt.shapes.shape.isLocked": "ist gesperrt",
    "isLocked": "ist gesperrt",
    "bitbybit.occt.shapes.shape.isLocked_description": "prüft, ob die Form gesperrt ist",
    "bitbybit.occt.shapes.shape.isNull": "ist null",
    "isNull": "ist null",
    "bitbybit.occt.shapes.shape.isNull_description": "prüft, ob die Form null ist",
    "bitbybit.occt.shapes.shape.isEqual": "ist gleich",
    "isEqual": "ist gleich",
    "bitbybit.occt.shapes.shape.isEqual_description": "prüft, ob die Form einer anderen Form entspricht",
    "otherShape": "andere Form",
    "bitbybit.occt.shapes.shape.isNotEqual": "ist nicht gleich",
    "isNotEqual": "ist nicht gleich",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "prüft, ob die Form von einer anderen Form abweicht",
    "bitbybit.occt.shapes.shape.isPartner": "ist Partner",
    "isPartner": "ist Partner",
    "bitbybit.occt.shapes.shape.isPartner_description": "prüft, ob die Form ein Partner einer anderen Form ist",
    "bitbybit.occt.shapes.shape.isSame": "ist identisch",
    "isSame": "ist identisch",
    "bitbybit.occt.shapes.shape.isSame_description": "prüft, ob die Form mit einer anderen Form identisch ist",
    "bitbybit.occt.shapes.shape.getOrientation": "Ausrichtung abrufen",
    "getOrientation": "Ausrichtung abrufen",
    "bitbybit.occt.shapes.shape.getOrientation_description": "ruft die Ausrichtung der Form ab",
    "bitbybit.occt.shapes.shape.getShapeType": "Formtyp abrufen",
    "getShapeType": "Formtyp abrufen",
    "bitbybit.occt.shapes.shape.getShapeType_description": "ruft den Typ der Form ab",
    "bitbybit.occt.geom.curves.geom2dEllipse": "2D-Ellipse Geometrie",
    "geom": "Geometrie",
    "curves": "Kurven",
    "geom2dEllipse": "2D-Ellipse Geometrie",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "erstellt eine 2D-Ellipse für die Modellierung",
    "Base.Point2": "Basis-Punkt 2",
    "Base.Vector2": "Basis-Vektor 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "2D-beschnittene Kurve",
    "geom2dTrimmedCurve": "2D-beschnittene Kurve",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "erstellt eine beschnittene Kurve zwischen U1 und U2",
    "u1": "U1",
    "u2": "U2",
    "adjustPeriodic": "periodisch anpassen",
    "bitbybit.occt.geom.curves.geom2dSegment": "2D-Kurvensegment",
    "geom2dSegment": "2D-Kurvensegment",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "erstellt ein 2D-Kurvensegment zwischen zwei Punkten",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "2D-Punkt von 2D-Kurve bei Parameter abrufen",
    "get2dPointFrom2dCurveOnParam": "2D-Punkt von 2D-Kurve bei Parameter abrufen",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "ruft einen 2D-Punkt auf einer Kurve bei einem Parameter ab",
    "bitbybit.occt.geom.curves.geomCircleCurve": "Kreis-Kurve Geometrie",
    "geomCircleCurve": "Kreis-Kurve Geometrie",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "erstellt eine Kreis-Geometrie-Kurve",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "Ellipse-Kurve Geometrie",
    "geomEllipseCurve": "Ellipse-Kurve Geometrie",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "erstellt eine Ellipse-Geometrie-Kurve",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "zylindrische Fläche",
    "surfaces": "Flächen",
    "cylindricalSurface": "zylindrische Fläche",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "erstellt eine unendliche zylindrische Fläche für die Modellierung",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "Fläche aus Fläche",
    "surfaceFromFace": "Fläche aus Fläche",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "erstellt eine Fläche aus einer Fläche",
    "bitbybit.occt.fillets.filletEdges": "Kanten abrunden",
    "fillets": "Rundungen",
    "filletEdges": "Kanten abrunden",
    "bitbybit.occt.fillets.filletEdges_description": "rundet OpenCascade-Formen ab",
    "3d fillets": "3D-Rundungen",
    "radiusList": "Radius-Liste",
    "indexes": "Indizes",
    "bitbybit.occt.fillets.filletEdgesList": "Kanten-Liste abrunden",
    "filletEdgesList": "Kanten-Liste abrunden",
    "bitbybit.occt.fillets.filletEdgesList_description": "rundet Kanten mit unterschiedlichen Radien ab",
    "edges": "Kanten",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "Kanten-Liste mit einem Radius abrunden",
    "filletEdgesListOneRadius": "Kanten-Liste mit einem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "rundet Kanten mit einem einzigen Radius ab",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "Kante mit variablem Radius abrunden",
    "filletEdgeVariableRadius": "Kante mit variablem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "rundet eine Kante mit variablem Radius bei U-Parametern ab",
    "paramsU": "Parameter U",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "Kanten mit gleichem variablem Radius abrunden",
    "filletEdgesSameVariableRadius": "Kanten mit gleichem variablem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "rundet Kanten mit denselben variablen Radien ab",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "Kanten mit variablem Radius abrunden",
    "filletEdgesVariableRadius": "Kanten mit variablem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "rundet Kanten mit variablen Radien bei Parametern ab",
    "radiusLists": "Radien-Listen",
    "paramsULists": "Parameter-U-Listen",
    "bitbybit.occt.fillets.fillet3DWire": "3D-Draht abrunden",
    "fillet3DWire": "3D-Draht abrunden",
    "bitbybit.occt.fillets.fillet3DWire_description": "rundet einen 3D-Draht mit einer Führungsrichtung ab",
    "bitbybit.occt.fillets.fillet3DWires": "3D-Drähte abrunden",
    "fillet3DWires": "3D-Drähte abrunden",
    "bitbybit.occt.fillets.fillet3DWires_description": "rundet 3D-Drähte mit einer Führungsrichtung ab",
    "bitbybit.occt.fillets.chamferEdges": "Kanten anfassen",
    "chamferEdges": "Kanten anfassen",
    "bitbybit.occt.fillets.chamferEdges_description": "fasst Kanten einer OpenCascade-Form an",
    "3d chamfers": "3D-Fasen",
    "distanceList": "Abstands-Liste",
    "bitbybit.occt.fillets.chamferEdgesList": "Kanten-Liste anfassen",
    "chamferEdgesList": "Kanten-Liste anfassen",
    "bitbybit.occt.fillets.chamferEdgesList_description": "fasst Kanten mit unterschiedlichen Abständen an",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "Kante mit zwei Abständen anfassen",
    "chamferEdgeTwoDistances": "Kante mit zwei Abständen anfassen",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "fasst eine Kante mit zwei Abständen an",
    "F": "F",
    "distance1": "Abstand 1",
    "distance2": "Abstand 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "Kanten mit zwei Abständen anfassen",
    "chamferEdgesTwoDistances": "Kanten mit zwei Abständen anfassen",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "fasst Kanten mit zwei Abständen an",
    "faces": "Flächen",
    "F[]": "F-Array",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "Kanten mit zwei Abstands-Listen anfassen",
    "chamferEdgesTwoDistancesLists": "Kanten mit zwei Abstands-Listen anfassen",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "fasst Kanten mit zwei Abstands-Listen an",
    "distances1": "Abstände 1",
    "distances2": "Abstände 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "Kante mit Abstand und Winkel anfassen",
    "chamferEdgeDistAngle": "Kante mit Abstand und Winkel anfassen",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "fasst eine Kante mit Abstand und Winkel an",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "Kanten mit Abstand und Winkel anfassen",
    "chamferEdgesDistAngle": "Kanten mit Abstand und Winkel anfassen",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "fasst Kanten mit Abstand und Winkel an",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "Kanten mit Abständen und Winkeln anfassen",
    "chamferEdgesDistsAngles": "Kanten mit Abständen und Winkeln anfassen",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "fasst Kanten mit Abständen und Winkeln an",
    "distances": "Abstände",
    "bitbybit.occt.fillets.fillet2d": "2D abrunden",
    "fillet2d": "2D abrunden",
    "bitbybit.occt.fillets.fillet2d_description": "rundet einen 2D-Draht oder eine Fläche ab",
    "2d fillets": "2D-Rundungen",
    "bitbybit.occt.fillets.fillet2dShapes": "2D-Formen abrunden",
    "fillet2dShapes": "2D-Formen abrunden",
    "bitbybit.occt.fillets.fillet2dShapes_description": "rundet 2D-Drähte oder Flächen ab",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "zwei Kanten in einer Ebene zu einem Draht abrunden",
    "filletTwoEdgesInPlaneIntoAWire": "zwei Kanten in einer Ebene zu einem Draht abrunden",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "rundet zwei planare Kanten zu einem Draht ab",
    "edge1": "Kante 1",
    "edge2": "Kante 2",
    "planeOrigin": "Ebenenursprung",
    "planeDirection": "Ebenenrichtung",
    "solution": "Lösung",
    "bitbybit.occt.transforms.transform": "transformieren",
    "bitbybit.occt.transforms.transform_description": "transformiert eine Form",
    "on single shape": "auf einzelne Form",
    "rotationAxis": "Rotationsachse",
    "rotationAngle": "Rotationswinkel",
    "scaleFactor": "Skalierungsfaktor",
    "bitbybit.occt.transforms.rotate": "drehen",
    "bitbybit.occt.transforms.rotate_description": "dreht eine Form",
    "bitbybit.occt.transforms.rotateAroundCenter": "um Zentrum drehen",
    "rotateAroundCenter": "um Zentrum drehen",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "dreht eine Form um das Zentrum",
    "bitbybit.occt.transforms.align": "ausrichten",
    "bitbybit.occt.transforms.align_description": "richtet eine Form aus",
    "fromOrigin": "von Ursprung",
    "fromDirection": "von Richtung",
    "toOrigin": "zu Ursprung",
    "toDirection": "zu Richtung",
    "bitbybit.occt.transforms.alignAndTranslate": "ausrichten und verschieben",
    "alignAndTranslate": "ausrichten und verschieben",
    "bitbybit.occt.transforms.alignAndTranslate_description": "richtet eine Form aus und verschiebt sie",
    "bitbybit.occt.transforms.translate": "verschieben",
    "bitbybit.occt.transforms.translate_description": "verschiebt eine Form",
    "bitbybit.occt.transforms.scale": "skalieren",
    "bitbybit.occt.transforms.scale_description": "skaliert eine Form",
    "bitbybit.occt.transforms.scale3d": "3D skalieren",
    "scale3d": "3D skalieren",
    "bitbybit.occt.transforms.scale3d_description": "skaliert eine Form in 3D",
    "bitbybit.occt.transforms.mirror": "spiegeln",
    "mirror": "spiegeln",
    "bitbybit.occt.transforms.mirror_description": "spiegelt eine Form",
    "bitbybit.occt.transforms.mirrorAlongNormal": "entlang Normalen spiegeln",
    "mirrorAlongNormal": "entlang Normalen spiegeln",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "spiegelt eine Form entlang Normalen und Ursprung",
    "normal": "Normale",
    "bitbybit.occt.transforms.transformShapes": "Formen transformieren",
    "transformShapes": "Formen transformieren",
    "bitbybit.occt.transforms.transformShapes_description": "transformiert ein Array von Formen",
    "on shapes": "auf Formen",
    "rotationAxes": "Rotationsachsen",
    "rotationAngles": "Rotationswinkel",
    "scaleFactors": "Skalierungsfaktoren",
    "bitbybit.occt.transforms.rotateShapes": "Formen drehen",
    "rotateShapes": "Formen drehen",
    "bitbybit.occt.transforms.rotateShapes_description": "dreht Formen",
    "axes": "Achsen",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "Formen um Zentrum drehen",
    "rotateAroundCenterShapes": "Formen um Zentrum drehen",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "dreht Formen um Zentrum und Achse",
    "centers": "Zentren",
    "bitbybit.occt.transforms.alignShapes": "Formen ausrichten",
    "alignShapes": "Formen ausrichten",
    "bitbybit.occt.transforms.alignShapes_description": "richtet Formen aus",
    "fromOrigins": "von Ursprüngen",
    "fromDirections": "von Richtungen",
    "toOrigins": "zu Ursprüngen",
    "toDirections": "zu Richtungen",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "Formen ausrichten und verschieben",
    "alignAndTranslateShapes": "Formen ausrichten und verschieben",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "richtet Formen aus und verschiebt sie",
    "directions": "Richtungen",
    "bitbybit.occt.transforms.translateShapes": "Formen verschieben",
    "translateShapes": "Formen verschieben",
    "bitbybit.occt.transforms.translateShapes_description": "verschiebt Formen",
    "bitbybit.occt.transforms.scaleShapes": "Formen skalieren",
    "scaleShapes": "Formen skalieren",
    "bitbybit.occt.transforms.scaleShapes_description": "skaliert Formen",
    "factors": "Faktoren",
    "bitbybit.occt.transforms.scale3dShapes": "Formen in 3D skalieren",
    "scale3dShapes": "Formen in 3D skalieren",
    "bitbybit.occt.transforms.scale3dShapes_description": "skaliert Formen in 3D",
    "scales": "Skalierungen",
    "bitbybit.occt.transforms.mirrorShapes": "Formen spiegeln",
    "mirrorShapes": "Formen spiegeln",
    "bitbybit.occt.transforms.mirrorShapes_description": "spiegelt Formen",
    "origins": "Ursprünge",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "Formen entlang Normalen spiegeln",
    "mirrorAlongNormalShapes": "Formen entlang Normalen spiegeln",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "spiegelt Formen entlang Normalen und Ursprung",
    "normals": "Normalen",
    "bitbybit.occt.operations.loft": "Loft",
    "operations": "Operationen",
    "loft": "Loft",
    "bitbybit.occt.operations.loft_description": "loftet Drähte zu einer Schale",
    "lofts": "Lofts",
    "makeSolid": "Volumenkörper erstellen",
    "bitbybit.occt.operations.loftAdvanced": "erweitertes Loft",
    "loftAdvanced": "erweitertes Loft",
    "bitbybit.occt.operations.loftAdvanced_description": "loftet Drähte zu einer Schale mit Optionen",
    "straight": "gerade",
    "nrPeriodicSections": "Anzahl periodischer Abschnitte",
    "useSmoothing": "Glättung verwenden",
    "maxUDegree": "maximaler U-Grad",
    "parType": "Parameter-Typ",
    "approxParametrizationTypeEnum": "Approximations-Parametrierungstyp-Enum",
    "startVertex": "Startvertex",
    "endVertex": "Endvertex",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "nächste Punkte zwischen zwei Formen",
    "closestPointsBetweenTwoShapes": "nächste Punkte zwischen zwei Formen",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "berechnet die nächstgelegenen Punkte zwischen zwei Formen",
    "closest pts": "nächste Punkte",
    "shape1": "Form 1",
    "shape2": "Form 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "nächste Punkte auf Form von Punkten",
    "closestPointsOnShapeFromPoints": "nächste Punkte auf Form von Punkten",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "berechnet die nächstgelegenen Punkte von Punkten zu einer Form",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "nächste Punkte auf Formen von Punkten",
    "closestPointsOnShapesFromPoints": "nächste Punkte auf Formen von Punkten",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "berechnet die nächstgelegenen Punkte von Punkten zu Formen",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "Abstände zu Form von Punkten",
    "distancesToShapeFromPoints": "Abstände zu Form von Punkten",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "berechnet die Abstände von Punkten zu einer Form",
    "bitbybit.occt.operations.boundingBoxOfShape": "Begrenzungsbox der Form",
    "boundingBoxOfShape": "Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "berechnet die Parameter der Begrenzungsbox einer Form",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "Minimum der Begrenzungsbox der Form",
    "boundingBoxMinOfShape": "Minimum der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "ruft den Minimalpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "Maximum der Begrenzungsbox der Form",
    "boundingBoxMaxOfShape": "Maximum der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "ruft den Maximalpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "Zentrum der Begrenzungsbox der Form",
    "boundingBoxCenterOfShape": "Zentrum der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "ruft den Mittelpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "Größe der Begrenzungsbox der Form",
    "boundingBoxSizeOfShape": "Größe der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "ruft den Größenpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "Begrenzungsbox-Form der Form",
    "boundingBoxShapeOfShape": "Begrenzungsbox-Form der Form",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "ruft die Begrenzungsbox-Form einer Form ab",
    "bitbybit.occt.operations.boundingSphereOfShape": "Begrenzungskugel der Form",
    "boundingSphereOfShape": "Begrenzungskugel der Form",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "berechnet die Parameter der Begrenzungskugel einer Form",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "Zentrum der Begrenzungskugel der Form",
    "boundingSphereCenterOfShape": "Zentrum der Begrenzungskugel der Form",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "ruft den Mittelpunkt der Begrenzungskugel einer Form ab",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "Radius der Begrenzungskugel der Form",
    "boundingSphereRadiusOfShape": "Radius der Begrenzungskugel der Form",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "ruft den Radius der Begrenzungskugel einer Form ab",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "Begrenzungskugel-Form der Form",
    "boundingSphereShapeOfShape": "Begrenzungskugel-Form der Form",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "ruft die Begrenzungskugel-Form einer Form ab",
    "bitbybit.occt.operations.extrude": "extrudieren",
    "extrude": "extrudieren",
    "bitbybit.occt.operations.extrude_description": "extrudiert eine Form entlang einer Richtung",
    "extrusions": "Extrusionen",
    "bitbybit.occt.operations.extrudeShapes": "Formen extrudieren",
    "extrudeShapes": "Formen extrudieren",
    "bitbybit.occt.operations.extrudeShapes_description": "extrudiert Formen entlang einer Richtung",
    "bitbybit.occt.operations.splitShapeWithShapes": "Form mit Formen teilen",
    "splitShapeWithShapes": "Form mit Formen teilen",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "teilt eine Form mit Formen",
    "divisions": "Teilungen",
    "localFuzzyTolerance": "lokale Unschärfetoleranz",
    "nonDestructive": "nicht destruktiv",
    "bitbybit.occt.operations.revolve": "rotieren",
    "revolve": "rotieren",
    "bitbybit.occt.operations.revolve_description": "rotiert eine Form um eine Richtung",
    "revolutions": "Rotationen",
    "copy": "Kopie",
    "bitbybit.occt.operations.rotatedExtrude": "rotierte Extrusion",
    "rotatedExtrude": "rotierte Extrusion",
    "bitbybit.occt.operations.rotatedExtrude_description": "führt eine rotierte Extrusion an einer Form durch",
    "bitbybit.occt.operations.pipe": "Rohr",
    "pipe": "Rohr",
    "bitbybit.occt.operations.pipe_description": "führt eine Rohrform entlang eines Drahtes",
    "pipeing": "Rohrleitung",
    "bitbybit.occt.operations.pipePolylineWireNGon": "Polylinien-Draht N-Eck rohren",
    "pipePolylineWireNGon": "Polylinien-Draht N-Eck rohren",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "führt eine Polylinien-Draht mit einem N-Eck-Profil als Rohr",
    "trihedronEnum": "Trihedron-Enum",
    "geomFillTrihedronEnum": "Geometrie-Füll-Trihedron-Enum",
    "forceApproxC1": "C1-Approximation erzwingen",
    "bitbybit.occt.operations.pipeWiresCylindrical": "Drähte zylindrisch rohren",
    "pipeWiresCylindrical": "Drähte zylindrisch rohren",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "führt Drähte mit zylindrischer Form als Rohr",
    "bitbybit.occt.operations.pipeWireCylindrical": "Draht zylindrisch rohren",
    "pipeWireCylindrical": "Draht zylindrisch rohren",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "führt einen Draht mit zylindrischer Form als Rohr",
    "bitbybit.occt.operations.offset": "Versatz",
    "bitbybit.occt.operations.offset_description": "versetzt Formen",
    "offsets": "Versätze",
    "bitbybit.occt.operations.offsetAdv": "erweiterter Versatz",
    "offsetAdv": "erweiterter Versatz",
    "bitbybit.occt.operations.offsetAdv_description": "versetzt mit erweiterten Optionen",
    "joinType": "Verbindungstyp",
    "joinTypeEnum": "Verbindungstyp-Enum",
    "removeIntEdges": "interne Kanten entfernen",
    "bitbybit.occt.operations.makeThickSolidSimple": "einfachen dicken Volumenkörper erstellen",
    "makeThickSolidSimple": "einfachen dicken Volumenkörper erstellen",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "verdickt eine Form zu einem Volumenkörper",
    "bitbybit.occt.operations.makeThickSolidByJoin": "dicken Volumenkörper durch Verbindung erstellen",
    "makeThickSolidByJoin": "dicken Volumenkörper durch Verbindung erstellen",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "verdickt eine Form zu einem Volumenkörper durch Verbindung",
    "intersection": "Schnitt",
    "selfIntersection": "Selbstschnitt",
    "bitbybit.occt.operations.slice": "schneiden",
    "slice": "schneiden",
    "bitbybit.occt.operations.slice_description": "schneidet eine Form",
    "bitbybit.occt.operations.sliceInStepPattern": "in Schrittmuster schneiden",
    "sliceInStepPattern": "in Schrittmuster schneiden",
    "bitbybit.occt.operations.sliceInStepPattern_description": "schneidet eine Form in einem Schrittmuster",
    "steps": "Schritte",
    "bitbybit.occt.operations.offset3DWire": "3D-Draht versetzen",
    "offset3DWire": "3D-Draht versetzen",
    "bitbybit.occt.operations.offset3DWire_description": "versetzt einen 3D-Draht",
    "bitbybit.occt.booleans.union": "Vereinigung",
    "booleans": "Boolsche Operationen",
    "union": "Vereinigung",
    "bitbybit.occt.booleans.union_description": "verbindet Objekte",
    "keepEdges": "Kanten behalten",
    "bitbybit.occt.booleans.difference": "Differenz",
    "difference": "Differenz",
    "bitbybit.occt.booleans.difference_description": "führt eine boolsche Differenz durch",
    "bitbybit.occt.booleans.intersection": "Schnitt",
    "bitbybit.occt.booleans.intersection_description": "führt einen boolschen Schnitt durch",
    "bitbybit.occt.shapeFix.basicShapeRepair": "einfache Formreparatur",
    "shapeFix": "Formreparatur",
    "basicShapeRepair": "einfache Formreparatur",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "repariert eine Form",
    "maxTolerance": "maximale Toleranz",
    "minTolerance": "minimale Toleranz",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "kleine Kante am Draht reparieren",
    "fixSmallEdgeOnWire": "kleine Kante am Draht reparieren",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "repariert eine kleine Kante an einem Draht",
    "lockvtx": "Vertex sperren",
    "precsmall": "kleine Präzision",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "Kantenausrichtungen entlang Draht reparieren",
    "fixEdgeOrientationsAlongWire": "Kantenausrichtungen entlang Draht reparieren",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "repariert Kantenausrichtungen entlang eines Drahtes",
    "bitbybit.occt.io.saveShapeSTEP": "Form als STEP speichern",
    "saveShapeSTEP": "Form als STEP speichern",
    "bitbybit.occt.io.saveShapeSTEP_description": "speichert eine STEP-Datei",
    "adjustYtoZ": "Y nach Z anpassen",
    "tryDownload": "Download versuchen",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "Form als STEP speichern und zurückgeben",
    "saveShapeSTEPAndReturn": "Form als STEP speichern und zurückgeben",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "speichert eine STEP-Datei und gibt den Text zurück",
    "bitbybit.occt.io.saveShapeStl": "Form als STL speichern",
    "saveShapeStl": "Form als STL speichern",
    "bitbybit.occt.io.saveShapeStl_description": "speichert eine STL-Datei",
    "binary": "binär",
    "bitbybit.occt.io.saveShapeStlAndReturn": "Form als STL speichern und zurückgeben",
    "saveShapeStlAndReturn": "Form als STL speichern und zurückgeben",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "speichert eine STL-Datei und gibt sie zurück",
    "bitbybit.occt.io.loadSTEPorIGES": "STEP oder IGES laden",
    "loadSTEPorIGES": "STEP oder IGES laden",
    "bitbybit.occt.io.loadSTEPorIGES_description": "importiert eine STEP- oder IGES-Datei",
    "adjustZtoY": "Z nach Y anpassen",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "STEP oder IGES aus Text laden",
    "loadSTEPorIGESFromText": "STEP oder IGES aus Text laden",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "importiert STEP oder IGES aus Text",
    "fileType": "Dateityp",
    "fileTypeEnum": "Dateityp-Enum",
    "bitbybit.advanced.text3d.create": "3D-Text",
    "advanced": "erweitert",
    "text3d": "3D-Text",
    "bitbybit.advanced.text3d.create_description": "erstellt 3D-Text",
    "fontType": "Schriftart",
    "fontsEnum": "Schriftarten-Enum",
    "fontVariant": "Schriftvariante",
    "fontVariantsEnum": "Schriftvarianten-Enum",
    "Inputs.Base.Vector3": "Eingaben Basis-Vektor 3",
    "originAlignment": "Ursprungsausrichtung",
    "recAlignmentEnum": "Rechteck-Ausrichtungs-Enum",
    "bitbybit.advanced.text3d.createTextOnFace": "Text auf Fläche",
    "createTextOnFace": "Text auf Fläche",
    "bitbybit.advanced.text3d.createTextOnFace_description": "erstellt 3D-Text auf einer Fläche",
    "facePlanar": "planare Fläche",
    "faceTextVar": "Flächen-Text-Variante",
    "faceTextVarEnum": "Flächen-Text-Varianten-Enum",
    "originParamU": "Ursprung Parameter U",
    "originParamV": "Ursprung Parameter V",
    "bitbybit.advanced.text3d.createTextsOnFace": "Texte auf Fläche",
    "createTextsOnFace": "Texte auf Fläche",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "erstellt 3D-Texte auf einer Fläche",
    "definitions": "Definitionen",
    "Text3DFaceDefinitionDto[]": "3D-Text-Flächen-Definition-DTO-Array",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "Definition 3D-Text auf Fläche",
    "definition3dTextOnFace": "Definition 3D-Text auf Fläche",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "erstellt 3D-Text für eine Flächen-Definition",
    "bitbybit.advanced.text3d.getCompoundShape": "Verbindungsform abrufen",
    "getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.advanced.text3d.getCompoundShape_description": "ruft die Verbindungsform von 3D-Text ab",
    "model": "Modell",
    "Text3DData<T>": "3D-Text-Daten T",
    "bitbybit.advanced.text3d.getCharacterShape": "Zeichenform abrufen",
    "getCharacterShape": "Zeichenform abrufen",
    "bitbybit.advanced.text3d.getCharacterShape_description": "ruft die Zeichenform bei einem Index ab",
    "bitbybit.advanced.text3d.getCharacterShapes": "Zeichenformen abrufen",
    "getCharacterShapes": "Zeichenformen abrufen",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "ruft die Zeichenformen von 3D-Text ab",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "Zeichenmittelpunktskoordinaten abrufen",
    "getCharacterCenterCoordinates": "Zeichenmittelpunktskoordinaten abrufen",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "ruft die Mittelpunktkoordinaten von Zeichen ab",
    "bitbybit.advanced.text3d.getFaceCutout": "Flächenausschnitt abrufen",
    "getFaceCutout": "Flächenausschnitt abrufen",
    "bitbybit.advanced.text3d.getFaceCutout_description": "ruft den Flächenausschnitt von 3D-Text auf einer Fläche ab",
    "get from face": "von Fläche abrufen",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "alle Flächen des Ausschnitts abrufen",
    "getAllFacesOfCutout": "alle Flächen des Ausschnitts abrufen",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "ruft alle Flächenausschnitte von 3D-Text ab",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "Ausschnitte innerhalb von Zeichen abrufen",
    "getCutoutsInsideCharacters": "Ausschnitte innerhalb von Zeichen abrufen",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "ruft Zeichenflächenausschnitte von 3D-Text ab",
    "bitbybit.advanced.text3d.getAdvanceWidth": "Vorschubbreite abrufen",
    "getAdvanceWidth": "Vorschubbreite abrufen",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "ruft die Vorschubbreite ab",
    "dimensions": "Abmessungen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "einfache Pyramide",
    "facePatterns": "Flächenmuster",
    "pyramidSimple": "einfache Pyramide",
    "createPyramidSimple": "einfache Pyramide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "erstellt ein einfaches Pyramidenmuster auf Flächen",
    "uNumber": "U-Anzahl",
    "vNumber": "V-Anzahl",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "Pyramidenmuster mit Einflussfaktoren",
    "createPyramidSimpleAffectors": "Pyramidenmuster mit Einflussfaktoren",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "erstellt ein Pyramidenmuster mit Einflussfaktoren",
    "affectorPoints": "Einflusspunkte",
    "Inputs.Base.Point3[]": "Eingaben Basis-Punkt-3-Array",
    "affectorRadiusList": "Einflussradius-Liste",
    "affectorFactors": "Einflussfaktoren",
    "defaultHeight": "Standardhöhe",
    "affectMinHeight": "Einfluss-Minimalhöhe",
    "affectMaxHeight": "Einfluss-Maximalhöhe",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "ruft die Verbindungsform von Pyramiden ab",
    "get shapes": "Formen abrufen",
    "PyramidSimpleData<T>": "einfache Pyramiden-Daten T",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "Verbindungsform auf Fläche abrufen",
    "getCompoundShapeOnFace": "Verbindungsform auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "ruft die Verbindungsform auf einer Fläche ab",
    "faceIndex": "Flächenindex",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "Pyramidenzelle auf Fläche abrufen",
    "getCompoundShapeCellOnFace": "Pyramidenzelle auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "ruft die Pyramidenform auf einer Fläche bei einem Index ab",
    "uIndex": "U-Index",
    "vIndex": "V-Index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "alle Pyramidenzellen abrufen",
    "getAllPyramidCells": "alle Pyramidenzellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "ruft alle Pyramidenzellen ab",
    "get cells": "Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "alle Pyramidenzellen auf Fläche abrufen",
    "getAllPyramidCellsOnFace": "alle Pyramidenzellen auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "ruft Pyramidenzellen auf einer Fläche ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "alle Pyramiden-U-Zellen auf Fläche abrufen",
    "getAllPyramidUCellsOnFace": "alle Pyramiden-U-Zellen auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "ruft Pyramiden-U-Zellen auf einer Fläche ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "alle Pyramiden-U-Zellen auf Fläche bei U abrufen",
    "getAllPyramidUCellsOnFaceAtU": "alle Pyramiden-U-Zellen auf Fläche bei U abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "ruft Pyramidenzellen auf einer Fläche bei U ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "alle Pyramiden-U-Zellen auf Fläche bei V abrufen",
    "getAllPyramidUCellsOnFaceAtV": "alle Pyramiden-U-Zellen auf Fläche bei V abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "ruft Pyramidenzellen auf einer Fläche bei V ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "Zelle bei Index abrufen",
    "getCellOnIndex": "Zelle bei Index abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "ruft eine Pyramidenzelle auf einer Fläche bei U und V ab",
    "get cell": "Zelle abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obere Punkte der Zellen abrufen",
    "getTopPointsOfCells": "obere Punkte der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "ruft die oberen Punkte der Zellen ab",
    "get from cells": "aus Zellen abrufen",
    "cells": "Zellen",
    "PyramidSimpleCellPart<T>[]": "einfache Pyramidenzellen-Teil T-Array",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "Mittelpunkte der Zellen abrufen",
    "getCenterPointsOfCells": "Mittelpunkte der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "ruft die Mittelpunkte der Zellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "Eckpunkte der Zellen abrufen",
    "getCornerPointsOfCells": "Eckpunkte der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "ruft die Eckpunkte der Zellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "Eckpunkt der Zellen abrufen",
    "getCornerPointOfCells": "Eckpunkt der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "ruft einen Eckpunkt der Zellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "Ecknormale der Zellen abrufen",
    "getCornerNormalOfCells": "Ecknormale der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "ruft die Ecknormale der Zellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "Ecknormalen der Zellen abrufen",
    "getCornerNormalsOfCells": "Ecknormalen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "ruft die Ecknormalen der Zellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "Verbindungsformen der Zellen abrufen",
    "getCompoundShapesOfCells": "Verbindungsformen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "ruft die Verbindungsformen von Pyramidenzellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "Flächenformen der Zellen abrufen",
    "getFaceShapesOfCells": "Flächenformen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "ruft die Flächenformen von Pyramidenzellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "Drahtformen der Zellen abrufen",
    "getWireShapesOfCells": "Drahtformen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "ruft die Drahtformen von Pyramidenzellen ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "Start-Polylinien-Draht U abrufen",
    "getStartPolylineWireU": "Start-Polylinien-Draht U abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "ruft den Polylinien-Draht entlang der Start-U-Kante ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "End-Polylinien-Draht U abrufen",
    "getEndPolylineWireU": "End-Polylinien-Draht U abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "ruft den Polylinien-Draht entlang der End-U-Kante ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "Start-Polylinien-Draht V abrufen",
    "getStartPolylineWireV": "Start-Polylinien-Draht V abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "ruft den Polylinien-Draht entlang der Start-V-Kante ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "End-Polylinien-Draht V abrufen",
    "getEndPolylineWireV": "End-Polylinien-Draht V abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "ruft den Polylinien-Draht entlang der End-V-Kante ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "Polylinien-Drähte U-Verbindung abrufen",
    "getPolylineWiresUCompound": "Polylinien-Drähte U-Verbindung abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "ruft Polylinien-Drähte entlang U ab",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "Polylinien-Drähte V-Verbindung abrufen",
    "getPolylineWiresVCompound": "Polylinien-Drähte V-Verbindung abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "ruft Polylinien-Drähte entlang V ab",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "Flügelspitzen-Villa",
    "things": "Dinge",
    "kidsCorner": "Kinder-Ecke",
    "birdhouses": "Vogelhäuser",
    "wingtipVilla": "Flügelspitzen-Villa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "erstellt ein Flügelspitzen-Villa-Vogelhaus",
    "birdhouse": "Vogelhaus",
    "interiorWidth": "Innenbreite",
    "interiorLength": "Innenlänge",
    "interiorHeight": "Innenhöhe",
    "holeDiameter": "Lochdurchmesser",
    "holeDistToBottom": "Lochabstand zum Boden",
    "stickLength": "Stab-Länge",
    "stickDiameter": "Stab-Durchmesser",
    "baseAttachmentHeight": "Basis-Befestigungshöhe",
    "roofOverhang": "Dachüberhang",
    "chimneyHeight": "Schornsteinhöhe",
    "Inputs.Base.Point3": "Eingaben Basis-Punkt 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "Zwitscher-Chalet",
    "chirpyChalet": "Zwitscher-Chalet",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "erstellt ein Zwitscher-Chalet-Vogelhaus",
    "roofAngle": "Dachwinkel",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "Serenitäts-Wirbel",
    "threeDPrinting": "3D-Druck",
    "vases": "Vasen",
    "serenitySwirl": "Serenitäts-Wirbel",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "erstellt eine Serenitäts-Wirbel-Vase",
    "swirl": "Wirbel",
    "addRadiusNarrow": "Radius schmal hinzufügen",
    "addRadiusWide": "Radius breit hinzufügen",
    "addMiddleHeight": "mittlere Höhe hinzufügen",
    "addTopHeight": "obere Höhe hinzufügen",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "Arabischer Torbogen",
    "arabicArchway": "Arabischer Torbogen",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "erstellt eine Arabischer-Torbogen-Vase",
    "profilePoints": "Profilpunkte",
    "nrOfSides": "Anzahl der Seiten",
    "nrOfVerticalArches": "Anzahl vertikaler Bögen",
    "archCenterThickness": "Bogendicke Mitte",
    "edgesThickness": "Kantendicke",
    "baseHeight": "Basishöhe",
    "patchHoles": "Löcher flicken",
    "lod": "Detailgrad",
    "Things.Enums.lodEnum": "Dinge Enums Detailgrad-Enum",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "Ewige Liebe",
    "medals": "Medaillen",
    "eternalLove": "Ewige Liebe",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "erstellt eine Ewige-Liebe-Medaille",
    "textHeading": "Textüberschrift",
    "textName": "Textname",
    "fullModel": "vollständiges Modell",
    "decorationThickness": "Dekorationsdicke",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "Ruhige Tasse",
    "cups": "Tassen",
    "calmCup": "Ruhige Tasse",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "erstellt ein Modell einer ruhigen Tasse",
    "radiusTopOffset": "Radius-Oberversatz",
    "fillet": "Rundung",
    "nrOfHandles": "Anzahl der Griffe",
    "handleDist": "Griffabstand",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "Drachen-Tasse",
    "dragonCup": "Drachen-Tasse",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "erstellt ein Modell einer Drachen-Tasse",
    "radiusMidOffset": "Radius-Mittelversatz",
    "rotationTopAngle": "Rotationswinkel oben",
    "rotationMidAngle": "Rotationswinkel Mitte",
    "nrSkinCellsVertical": "Anzahl Hautzellen vertikal",
    "nrSkinCellsHorizontal": "Anzahl Hautzellen horizontal",
    "nrSkinCellDivisionsTop": "Anzahl Hautzellen-Teilungen oben",
    "nrSkinCellDivisionsBottom": "Anzahl Hautzellen-Teilungen unten",
    "skinCellOuterHeight": "Hautzellen-äußere Höhe",
    "skinCellInnerHeight": "Hautzellen-innere Höhe",
    "skinCellBottomHeight": "Hautzellen-untere Höhe",
    "skinCellTopHeight": "Hautzellen-obere Höhe",
    "bottomThickness": "Bodendicke",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "ruft die Verbindungsform einer Drachen-Tasse ab",
    "DragonCupData<T>": "Drachen-Tassen-Daten T",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "Telefon-Nest",
    "desktop": "Schreibtisch",
    "phoneNest": "Telefon-Nest",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "erstellt ein Modell eines Telefon-Nests",
    "heightBottom": "Höhe unten",
    "heightTop": "Höhe oben",
    "widthBack": "Breite hinten",
    "widthFront": "Breite vorne",
    "backOffset": "Versatz hinten",
    "applyOrnaments": "Ornamente anwenden",
    "filletRadius": "Rundungsradius",
    "phoneHeight": "Telefonhöhe",
    "phoneWidth": "Telefonbreite",
    "phoneThickness": "Telefondicke",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "ruft die Verbindungsform des Telefon-Nests ab",
    "PhoneNestData<T>": "Telefon-Nest-Daten T",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "Zeichenoptionen",
    "drawOptions": "Zeichenoptionen",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "erstellt Zeichenoptionen für das Modell",
    "mainMaterial": "Hauptmaterial",
    "phoneMaterial": "Telefonmaterial",
    "Inputs.Base.Color": "Eingaben Basis-Farbe",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "Tröpfchen-Telefonhalter",
    "laserCutting": "Laserschneiden",
    "gadgets": "Gadgets",
    "dropletsPhoneHolder": "Tröpfchen-Telefonhalter",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "erstellt einen Tröpfchen-Telefonhalter",
    "title": "Titel",
    "subtitle": "Untertitel",
    "includeLogo": "Logo einfügen",
    "kerf": "Schnittbreite",
    "backLength": "Rückenlänge",
    "offsetAroundPhone": "Versatz um das Telefon",
    "penShelf": "Stiftregal",
    "phoneLockHeight": "Telefonverriegelungshöhe",
    "includePattern": "Muster einfügen",
    "densityPattern": "Dichte des Musters",
    "holesForWire": "Löcher für Kabel",
    "wireInputThickness": "Kabeleingangsdicke",
    "includeModel": "Modell einfügen",
    "includeDrawings": "Zeichnungen einfügen",
    "spacingDrawings": "Abstand der Zeichnungen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "ruft die Verbindungsform des Tröpfchen-Telefonhalters ab",
    "DropletsPhoneHolderData<T>": "Tröpfchen-Telefonhalter-Daten T",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "Schnittdrähte-Verbindung abrufen",
    "getCutWiresCompound": "Schnittdrähte-Verbindung abrufen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "ruft die Verbindung der Schnittdrähte ab",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "Gravurdrähte-Verbindung abrufen",
    "getEngravingWiresCompound": "Gravurdrähte-Verbindung abrufen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "ruft die Verbindung der Gravurdrähte ab",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "DXF-Zeichnungen herunterladen",
    "downloadDXFDrawings": "DXF-Zeichnungen herunterladen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "lädt eine DXF-Zeichnung herunter",
    "download": "herunterladen",
    "cutWiresColor": "Farbe der Schnittdrähte",
    "engravingWiresColor": "Farbe der Gravurdrähte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "STEP-Zeichnungen herunterladen",
    "downloadSTEPDrawings": "STEP-Zeichnungen herunterladen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "lädt eine STEP-Zeichnung herunter",
    "adjustYZ": "YZ anpassen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "3D-STEP-Modell herunterladen",
    "download3dSTEPModel": "3D-STEP-Modell herunterladen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "lädt ein 3D-STEP-Modell herunter",
    "bitbybit.things.architecture.houses.zenHideout.create": "Zen-Versteck",
    "architecture": "Architektur",
    "houses": "Häuser",
    "zenHideout": "Zen-Versteck",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "erstellt ein Zen-Versteck",
    "widthFirstWing": "Breite erster Flügel",
    "lengthFirstWing": "Länge erster Flügel",
    "terraceWidth": "Terrassenbreite",
    "widthSecondWing": "Breite zweiter Flügel",
    "lengthSecondWing": "Länge zweiter Flügel",
    "heightWalls": "Höhe der Wände",
    "roofAngleFirstWing": "Dachwinkel erster Flügel",
    "roofAngleSecondWing": "Dachwinkel zweiter Flügel",
    "roofOffset": "Dachversatz",
    "roofInsideOverhang": "Dachinnenüberhang",
    "roofMaxDistAttachmentBeams": "maximaler Abstand der Dachbefestigungsbalken",
    "roofAttachmentBeamWidth": "Breite der Dachbefestigungsbalken",
    "roofAttachmentBeamHeight": "Höhe der Dachbefestigungsbalken",
    "roofOutsideOverhang": "Dachaußenüberhang",
    "columnSize": "Säulengröße",
    "ceilingBeamHeight": "Höhe der Deckenbalken",
    "ceilingBeamWidth": "Breite der Deckenbalken",
    "nrCeilingBeamsBetweenColumns": "Anzahl der Deckenbalken zwischen Säulen",
    "distBetweenColumns": "Abstand zwischen Säulen",
    "floorHeight": "Bohdenhöhe",
    "groundLevel": "Bodenlevel",
    "facadePanelThickness": "Dicke der Fassadenplatte",
    "windowWidthOffset": "Fensterbreitenversatz",
    "windowHeightOffset": "Fensterhöhenversatz",
    "windowFrameThickness": "Fensterrahmendicke",
    "windowGlassFrameThickness": "Fensterrahmenglasdicke",
    "skinOpacity": "Hauttransparenz",
    "bitbybit.things.furniture.chairs.snakeChair.create": "Schlangen-Stuhl",
    "furniture": "Möbel",
    "chairs": "Stühle",
    "snakeChair": "Schlangen-Stuhl",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "erstellt ein Modell eines Schlangen-Stuhls",
    "sittingHeight": "Sitzhöhe",
    "backRestOffset": "Rückenlehnenversatz",
    "backRestHeight": "Rückenlehnenhöhe",
    "nrOrnamentPlanks": "Anzahl der Ornamentbretter",
    "ornamentDepth": "Ornamenttiefe",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "ruft die Verbindungsform des Stuhls ab",
    "SnakeChairData<T>": "Schlangen-Stuhl-Daten T",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "Sitzflächen-Drahtform abrufen",
    "getSittingWireShape": "Sitzflächen-Drahtform abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "ruft die Drahtform des Sitzbereichs ab",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "Mittelpunkt des Sitzbereichs abrufen",
    "getSittingAreaCenterPoint": "Mittelpunkt des Sitzbereichs abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "ruft den Mittelpunkt des Sitzbereichs ab",
    "get points": "Punkte abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "erstellt Zeichenoptionen für den Schlangen-Stuhl",
    "bitbybit.things.furniture.tables.elegantTable.create": "Eleganter Tisch",
    "tables": "Tische",
    "elegantTable": "Eleganter Tisch",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "erstellt ein Modell eines eleganten Tisches",
    "topThickness": "Oberflächendicke",
    "topOffset": "Oberflächenversatz",
    "minFillet": "minimale Rundung",
    "radiusLegTop": "Radius Bein oben",
    "radiusLegBottom": "Radius Bein unten",
    "nrLegPairs": "Anzahl der Beinpaare",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "ruft die Verbindungsform des Tisches ab",
    "ElegantTableData<T>": "Eleganter-Tisch-Daten T",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "Beinformen abrufen",
    "getLegShapes": "Beinformen abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "ruft die Beinformen als Liste ab",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "Beinform nach Index abrufen",
    "getLegShapeByIndex": "Beinform nach Index abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "ruft die Beinform nach Index ab",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "Oberflächenplattenform abrufen",
    "getTopPanelShape": "Oberflächenplattenform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "ruft die Form der Tischoberfläche ab",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "Oberflächenplatten-Drahtform abrufen",
    "getTopPanelWireShape": "Oberflächenplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "ruft die Drahtform der Tischoberfläche ab",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "Unterflächenplatten-Drahtform abrufen",
    "getBottomPanelWireShape": "Unterflächenplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "ruft die Drahtform der Tischunterfläche ab",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "Unterflächenplattenform abrufen",
    "getBottomPanelShape": "Unterflächenplattenform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "ruft die Form der Tischunterfläche ab",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "Beinverbindungsform abrufen",
    "getLegsCompoundShape": "Beinverbindungsform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "ruft die Beinformen als Verbindungsform ab",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "Mittelpunkt der Tischoberfläche abrufen",
    "getTableTopCenterPoint": "Mittelpunkt der Tischoberfläche abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "ruft den Mittelpunkt der Oberfläche ab",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "Mittelpunkt der Tischunterfläche abrufen",
    "getTableBottomCenterPoint": "Mittelpunkt der Tischunterfläche abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "ruft den Mittelpunkt der Unterfläche ab",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "untere Beinpunkte abrufen",
    "getLegBottomPoints": "untere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "ruft die unteren Beinpunkte ab",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obere Beinpunkte abrufen",
    "getLegTopPoints": "obere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "ruft die oberen Beinpunkte ab",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "erstellt Zeichenoptionen für den eleganten Tisch",
    "topMaterial": "Oberflächenmaterial",
    "topBaseMaterial": "Oberflächenbasismaterial",
    "legsMaterial": "Beinmaterial",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "Guter Couchtisch",
    "goodCoffeeTable": "Guter Couchtisch",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "erstellt ein Modell eines guten Couchtisches",
    "chamfer": "Fase",
    "topGlassOffset": "Glasoberflächenversatz",
    "glassThickness": "Glasdicke",
    "glassHolderLength": "Länge des Glashalters",
    "shelfTopOffset": "Regaloberflächenversatz",
    "shelfThickness": "Regaldicke",
    "legWidth": "Beinbreite",
    "legDepth": "Beintiefe",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "ruft die Verbindungsform des Tisches ab",
    "GoodCoffeeTableData<T>": "Guter-Couchtisch-Daten T",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "Beinformen abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "ruft die Beinformen als Liste ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "Beinform nach Index abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "ruft die Beinform nach Index ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "Oberflächenplattenform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "ruft die Form der Tischoberfläche ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "Oberflächenplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "ruft die Drahtform der Tischoberfläche ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "Glasplattenform abrufen",
    "getGlassPanelShape": "Glasplattenform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "ruft die Form der Tischglasplatte ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "Glasplatten-Drahtform abrufen",
    "getGlassPanelWireShape": "Glasplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "ruft die Drahtform der Tischglasplatte ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "Regalform abrufen",
    "getShelfShape": "Regalform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "ruft die Form des Tischregals ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "Regaloberflächen-Drahtform abrufen",
    "getShelfTopWireShape": "Regaloberflächen-Drahtform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "ruft die Drahtform der Regaloberfläche ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "Beinverbindungsform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "ruft die Beinformen als Verbindungsform ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "Mittelpunkt der Tischoberfläche abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "ruft den Mittelpunkt der Oberfläche ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "Mittelpunkt der Regaloberfläche abrufen",
    "getTableShelfTopCenterPoint": "Mittelpunkt der Regaloberfläche abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "ruft den Mittelpunkt der Regaloberfläche ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "untere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "ruft die unteren Beinpunkte ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "ruft die oberen Beinpunkte ab",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "erstellt Zeichenoptionen für den guten Couchtisch",
    "topGlassMaterial": "Oberflächenglasmaterial",
    "shelfMaterial": "Regalmaterial",
    "bitbybit.things.furniture.tables.snakeTable.create": "Schlangen-Tisch",
    "snakeTable": "Schlangen-Tisch",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "erstellt ein Modell eines Schlangen-Tisches",
    "supportLength": "Stützlänge",
    "shelfHeight": "Regalhöhe",
    "glassOffset": "Glasversatz",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "ruft die Verbindungsform des Tisches ab",
    "SnakeTableData<T>": "Schlangen-Tisch-Daten T",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "Glasform abrufen",
    "getGlassShape": "Glasform abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "ruft die Glasform des Tisches ab",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "Hauptform abrufen",
    "getMainShape": "Hauptform abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "ruft die Hauptvolumenform des Tisches ab",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "Mittelpunkt der Oberfläche abrufen",
    "getTopCenterPoint": "Mittelpunkt der Oberfläche abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "ruft den Mittelpunkt der Tischoberfläche ab",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "erstellt Zeichenoptionen für den Schlangen-Tisch",
    "glassMaterial": "Glasmaterial",
    "bitbybit.things.enums.lodEnum": "Detailgrad-Enum",
    "enums": "Enums",
    "lodEnum": "Detailgrad-Enum",
    "bitbybit.things.enums.lodEnum_description": "erstellt einen Wert für den Detailgrad-Enum",
    "bitbybit.jscad.transformSolids": "Volumenkörper transformieren",
    "jscad": "JSCAD",
    "transformSolids": "Volumenkörper transformieren",
    "bitbybit.jscad.transformSolids_description": "transformiert JSCAD-Volumenkörpernetze mit Transformationen",
    "JSCADEntity[]": "JSCAD-Entitäten-Array",
    "bitbybit.jscad.transformSolid": "Volumenkörper transformieren",
    "transformSolid": "Volumenkörper transformieren",
    "bitbybit.jscad.transformSolid_description": "transformiert ein JSCAD-Volumenkörpernetz mit Transformationen",
    "JSCADEntity": "JSCAD-Entität",
    "bitbybit.jscad.downloadSolidSTL": "Volumenkörper-STL herunterladen",
    "downloadSolidSTL": "Volumenkörper-STL herunterladen",
    "bitbybit.jscad.downloadSolidSTL_description": "lädt eine binäre STL-Datei von einem 3D-Volumenkörper herunter",
    "bitbybit.jscad.downloadSolidsSTL": "Volumenkörper-STLs herunterladen",
    "downloadSolidsSTL": "Volumenkörper-STLs herunterladen",
    "bitbybit.jscad.downloadSolidsSTL_description": "lädt eine binäre STL-Datei von 3D-Volumenkörpern herunter",
    "bitbybit.jscad.downloadGeometryDxf": "Geometrie-DXF herunterladen",
    "downloadGeometryDxf": "Geometrie-DXF herunterladen",
    "bitbybit.jscad.downloadGeometryDxf_description": "lädt eine DXF-Datei von einer JSCAD-Geometrie herunter",
    "geometry": "Geometrie",
    "JSCADEntity | JSCADEntity[]": "JSCAD-Entität oder Array",
    "bitbybit.jscad.downloadGeometry3MF": "Geometrie-3MF herunterladen",
    "downloadGeometry3MF": "Geometrie-3MF herunterladen",
    "bitbybit.jscad.downloadGeometry3MF_description": "lädt eine 3MF-Datei von einer JSCAD-Geometrie herunter",
    "bitbybit.jscad.booleans.intersect": "sich schneiden",
    "intersect": "sich schneiden",
    "bitbybit.jscad.booleans.intersect_description": "schneidet mehrere Volumenkörpernetzobjekte",
    "bitbybit.jscad.booleans.subtract": "subtrahieren",
    "subtract": "subtrahieren",
    "bitbybit.jscad.booleans.subtract_description": "subtrahiert mehrere Volumenkörpernetzobjekte",
    "bitbybit.jscad.booleans.union": "Vereinigung",
    "bitbybit.jscad.booleans.union_description": "vereinigt mehrere Volumenkörpernetzobjekte",
    "bitbybit.jscad.booleans.intersectTwo": "zwei schneiden",
    "intersectTwo": "zwei schneiden",
    "bitbybit.jscad.booleans.intersectTwo_description": "schneidet zwei Volumenkörpernetzobjekte",
    "bitbybit.jscad.booleans.subtractTwo": "zwei subtrahieren",
    "subtractTwo": "zwei subtrahieren",
    "bitbybit.jscad.booleans.subtractTwo_description": "subtrahiert zwei Volumenkörpernetzobjekte",
    "bitbybit.jscad.booleans.unionTwo": "zwei vereinigen",
    "unionTwo": "zwei vereinigen",
    "bitbybit.jscad.booleans.unionTwo_description": "vereinigt zwei Volumenkörpernetzobjekte",
    "bitbybit.jscad.booleans.subtractFrom": "von subtrahieren",
    "subtractFrom": "von subtrahieren",
    "bitbybit.jscad.booleans.subtractFrom_description": "subtrahiert mehrere Netze von einem Netz",
    "bitbybit.jscad.expansions.expand": "erweitern",
    "expansions": "Erweiterungen",
    "expand": "erweitern",
    "bitbybit.jscad.expansions.expand_description": "erweitert Volumengeometrien",
    "expansion": "Erweiterung",
    "delta": "Delta",
    "corners": "Ecken",
    "solidCornerTypeEnum": "Volumenecken-Typ-Enum",
    "bitbybit.jscad.expansions.offset": "Versatz",
    "bitbybit.jscad.expansions.offset_description": "versetzt 2D-Geometrien",
    "bitbybit.jscad.extrusions.extrudeLinear": "linear extrudieren",
    "extrudeLinear": "linear extrudieren",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "extrudiert 2D-Geometrien linear",
    "twistAngle": "Verdrehungswinkel",
    "twistSteps": "Verdrehungsschritte",
    "bitbybit.jscad.extrusions.extrudeRectangular": "rechteckig extrudieren",
    "extrudeRectangular": "rechteckig extrudieren",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "extrudiert 2D-Geometrien rechteckig",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "Punkte rechteckig extrudieren",
    "extrudeRectangularPoints": "Punkte rechteckig extrudieren",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "extrudiert 2D-Punkte rechteckig",
    "bitbybit.jscad.extrusions.extrudeRotate": "rotierend extrudieren",
    "extrudeRotate": "rotierend extrudieren",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "rotiert und extrudiert 2D-Punkte",
    "polygon": "Polygon",
    "startAngle": "Startwinkel",
    "bitbybit.jscad.hulls.hullChain": "Hülle verketteten",
    "hulls": "Hüllen",
    "hullChain": "Hülle verketteten",
    "bitbybit.jscad.hulls.hullChain_description": "verbindet Volumenkörper oder 2D-Geometrien in Reihenfolge",
    "bitbybit.jscad.hulls.hull": "Hülle",
    "hull": "Hülle",
    "bitbybit.jscad.hulls.hull_description": "konvexe Hülle verbindet Volumenkörper oder 2D-Geometrien",
    "bitbybit.jscad.path.createFromPoints": "aus Punkten",
    "createFromPoints": "aus Punkten",
    "bitbybit.jscad.path.createFromPoints_description": "erstellt einen 2D-Pfad aus Punkten",
    "Base.Point2[]": "Basis-Punkt-2-Array",
    "bitbybit.jscad.path.createPathsFromPoints": "Pfade aus Punkten",
    "createPathsFromPoints": "Pfade aus Punkten",
    "bitbybit.jscad.path.createPathsFromPoints_description": "erstellt 2D-Pfade aus Punktelisten",
    "pointsLists": "Punktelisten",
    "Base.Point3[][] | Base.Point2[][]": "Basis-Punkt-3- oder 2-Array",
    "bitbybit.jscad.path.createFromPolyline": "aus Polylinie",
    "createFromPolyline": "aus Polylinie",
    "bitbybit.jscad.path.createFromPolyline_description": "erstellt einen 2D-Pfad aus einer Polylinie",
    "bitbybit.jscad.path.createEmpty": "leer",
    "createEmpty": "leer",
    "bitbybit.jscad.path.createEmpty_description": "erstellt einen leeren 2D-Pfad",
    "bitbybit.jscad.path.close": "schließen",
    "close": "schließen",
    "bitbybit.jscad.path.close_description": "schließt einen offenen 2D-Pfad",
    "bitbybit.jscad.path.appendPoints": "Punkte anhängen",
    "appendPoints": "Punkte anhängen",
    "bitbybit.jscad.path.appendPoints_description": "hängt 2D-Punkte an den Pfad an",
    "append": "anhängen",
    "bitbybit.jscad.path.appendPolyline": "Polylinie anhängen",
    "appendPolyline": "Polylinie anhängen",
    "bitbybit.jscad.path.appendPolyline_description": "hängt eine Polylinie an den Pfad an",
    "bitbybit.jscad.path.appendArc": "Bogen anhängen",
    "appendArc": "Bogen anhängen",
    "bitbybit.jscad.path.appendArc_description": "hängt einen Bogen an den Pfad an",
    "xAxisRotation": "X-Achsen-Rotation",
    "clockwise": "im Uhrzeigersinn",
    "large": "groß",
    "bitbybit.jscad.polygon.createFromPoints": "aus Punkten",
    "bitbybit.jscad.polygon.createFromPoints_description": "erstellt ein 2D-Polygon aus Punkten",
    "bitbybit.jscad.polygon.createFromPolyline": "aus Polylinie",
    "bitbybit.jscad.polygon.createFromPolyline_description": "erstellt ein 2D-Polygon aus einer Polylinie",
    "bitbybit.jscad.polygon.createFromCurve": "aus Kurve",
    "createFromCurve": "aus Kurve",
    "bitbybit.jscad.polygon.createFromCurve_description": "erstellt ein 2D-Polygon aus einer Kurve",
    "bitbybit.jscad.polygon.createFromPath": "aus Pfad",
    "createFromPath": "aus Pfad",
    "bitbybit.jscad.polygon.createFromPath_description": "erstellt ein 2D-Polygon aus einem Pfad",
    "bitbybit.jscad.polygon.circle": "Kreis",
    "bitbybit.jscad.polygon.circle_description": "erstellt einen 2D-Polygon-Kreis",
    "bitbybit.jscad.polygon.ellipse": "Ellipse",
    "ellipse": "Ellipse",
    "bitbybit.jscad.polygon.ellipse_description": "erstellt eine 2D-Polygon-Ellipse",
    "bitbybit.jscad.polygon.rectangle": "Rechteck",
    "rectangle": "Rechteck",
    "bitbybit.jscad.polygon.rectangle_description": "erstellt ein 2D-Polygon-Rechteck",
    "bitbybit.jscad.polygon.roundedRectangle": "gerundetes Rechteck",
    "roundedRectangle": "gerundetes Rechteck",
    "bitbybit.jscad.polygon.roundedRectangle_description": "erstellt ein 2D-gerundetes Rechteck",
    "roundRadius": "Rundungsradius",
    "bitbybit.jscad.polygon.square": "Quadrat",
    "square": "Quadrat",
    "bitbybit.jscad.polygon.square_description": "erstellt ein 2D-Polygon-Quadrat",
    "bitbybit.jscad.polygon.star": "Stern",
    "star": "Stern",
    "bitbybit.jscad.polygon.star_description": "erstellt einen 2D-Polygon-Stern",
    "vertices": "Vertices",
    "bitbybit.jscad.shapes.cube": "Würfel",
    "cube": "Würfel",
    "bitbybit.jscad.shapes.cube_description": "erstellt eine 3D-Würfelform",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "Würfel auf Mittelpunkten",
    "cubesOnCenterPoints": "Würfel auf Mittelpunkten",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "erstellt 3D-Würfel auf Mittelpunkten",
    "primitives on centers": "Primitive auf Zentren",
    "bitbybit.jscad.shapes.cuboid": "Quader",
    "cuboid": "Quader",
    "bitbybit.jscad.shapes.cuboid_description": "erstellt eine 3D-Quaderform",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "Quader auf Mittelpunkten",
    "cuboidsOnCenterPoints": "Quader auf Mittelpunkten",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "erstellt 3D-Quader auf Mittelpunkten",
    "bitbybit.jscad.shapes.cylinderElliptic": "elliptischer Zylinder",
    "cylinderElliptic": "elliptischer Zylinder",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "erstellt einen 3D-elliptischen Zylindervolumenkörper",
    "startRadius": "Startradius",
    "endRadius": "Endradius",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "elliptischer Zylinder auf Mittelpunkten",
    "cylinderEllipticOnCenterPoints": "elliptischer Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "erstellt 3D-elliptische Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.cylinder": "Zylinder",
    "cylinder": "Zylinder",
    "bitbybit.jscad.shapes.cylinder_description": "erstellt einen 3D-Zylindervolumenkörper",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "Zylinder auf Mittelpunkten",
    "cylindersOnCenterPoints": "Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "erstellt 3D-Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.ellipsoid": "Ellipsoid",
    "ellipsoid": "Ellipsoid",
    "bitbybit.jscad.shapes.ellipsoid_description": "erstellt einen 3D-Ellipsoidvolumenkörper",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "Ellipsoide auf Mittelpunkten",
    "ellipsoidsOnCenterPoints": "Ellipsoide auf Mittelpunkten",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "erstellt 3D-Ellipsoide auf Mittelpunkten",
    "bitbybit.jscad.shapes.geodesicSphere": "geodätische Kugel",
    "geodesicSphere": "geodätische Kugel",
    "bitbybit.jscad.shapes.geodesicSphere_description": "erstellt einen 3D-geodätischen Kugelvolumenkörper",
    "frequency": "Frequenz",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "geodätische Kugeln auf Mittelpunkten",
    "geodesicSpheresOnCenterPoints": "geodätische Kugeln auf Mittelpunkten",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "erstellt 3D-geodätische Kugeln auf Mittelpunkten",
    "bitbybit.jscad.shapes.roundedCuboid": "gerundeter Quader",
    "roundedCuboid": "gerundeter Quader",
    "bitbybit.jscad.shapes.roundedCuboid_description": "erstellt einen 3D-gerundeten Quader-volumenkörper",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "gerundete Quader auf Mittelpunkten",
    "roundedCuboidsOnCenterPoints": "gerundete Quader auf Mittelpunkten",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "erstellt 3D-gerundete Quader auf Mittelpunkten",
    "bitbybit.jscad.shapes.roundedCylinder": "gerundeter Zylinder",
    "roundedCylinder": "gerundeter Zylinder",
    "bitbybit.jscad.shapes.roundedCylinder_description": "erstellt einen 3D-gerundeten Zylindervolumenkörper",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "gerundete Zylinder auf Mittelpunkten",
    "roundedCylindersOnCenterPoints": "gerundete Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "erstellt 3D-gerundete Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.sphere": "Kugel",
    "sphere": "Kugel",
    "bitbybit.jscad.shapes.sphere_description": "erstellt einen 3D-Kugelvolumenkörper",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "Kugeln auf Mittelpunkten",
    "spheresOnCenterPoints": "Kugeln auf Mittelpunkten",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "erstellt 3D-Kugeln auf Mittelpunkten",
    "bitbybit.jscad.shapes.torus": "Torus",
    "torus": "Torus",
    "bitbybit.jscad.shapes.torus_description": "erstellt einen 3D-Torusvolumenkörper",
    "innerSegments": "innere Segmente",
    "outerSegments": "äußere Segmente",
    "innerRotation": "innere Rotation",
    "outerRotation": "äußere Rotation",
    "bitbybit.jscad.shapes.fromPolygonPoints": "aus Polygonpunkten",
    "fromPolygonPoints": "aus Polygonpunkten",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "erstellt eine 3D-Form aus verschachtelten Polygonpunkten",
    "polygonPoints": "Polygonpunkte",
    "Base.Point3[][]": "Basis-Punkt-3-Array",
    "bitbybit.jscad.text.cylindricalText": "zylindrischer Text",
    "cylindricalText": "zylindrischer Text",
    "bitbybit.jscad.text.cylindricalText_description": "erstellt Text mit verketteten Zylindern",
    "extrusionHeight": "Extrusionshöhe",
    "extrusionSize": "Extrusionsgröße",
    "jscadTextAlignEnum": "JSCAD-Textausrichtungs-Enum",
    "bitbybit.jscad.text.sphericalText": "sphärischer Text",
    "sphericalText": "sphärischer Text",
    "bitbybit.jscad.text.sphericalText_description": "erstellt Text mit verketteten Kugeln",
    "bitbybit.jscad.text.createVectorText": "Vektortext",
    "createVectorText": "Vektortext",
    "bitbybit.jscad.text.createVectorText_description": "erstellt Vektortext",
    "bitbybit.jscad.colors.colorize": "einfärben",
    "colors": "Farben",
    "colorize": "einfärben",
    "bitbybit.jscad.colors.colorize_description": "färbt JSCAD-Geometrie ein",
    "bitbybit.manifold.manifoldToMeshPointer": "Mannigfaltigkeit zu Netzzeiger",
    "manifold": "Mannigfaltigkeit",
    "manifoldToMeshPointer": "Mannigfaltigkeit zu Netzzeiger",
    "bitbybit.manifold.manifoldToMeshPointer_description": "wandelt eine Mannigfaltigkeitsform in einen Netzzeiger um",
    "meshing": "Vernetzung",
    "normalIdx": "Normalenindex",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt zerlegen",
    "decomposeManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt zerlegen",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "zerlegt Mannigfaltigkeit oder Querschnitt in Netz oder Polygone",
    "decompose": "zerlegen",
    "manifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte zerlegen",
    "decomposeManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte zerlegen",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "zerlegt Mannigfaltigkeiten oder Querschnitte in Netze oder Polygone",
    "manifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt löschen",
    "deleteManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt löschen",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "löscht Mannigfaltigkeit oder Querschnitt aus dem Speicher",
    "cleanup": "Bereinigung",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte löschen",
    "deleteManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte löschen",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "löscht Mannigfaltigkeiten oder Querschnitte aus dem Speicher",
    "bitbybit.manifold.manifold.manifoldToMesh": "Mannigfaltigkeit zu Netz",
    "manifoldToMesh": "Mannigfaltigkeit zu Netz",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "wandelt eine Mannigfaltigkeitsform in ein Netz um",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "Mannigfaltigkeiten zu Netzen",
    "manifoldsToMeshes": "Mannigfaltigkeiten zu Netzen",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "wandelt Mannigfaltigkeitsformen in Netze um",
    "manifolds": "Mannigfaltigkeiten",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "Mannigfaltigkeit aus Netz",
    "manifoldFromMesh": "Mannigfaltigkeit aus Netz",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "wandelt ein Netz in eine Mannigfaltigkeit um",
    "DecomposedManifoldMeshDto": "zerlegtes Mannigfaltigkeitsnetz-DTO",
    "bitbybit.manifold.manifold.shapes.cube": "Würfel",
    "bitbybit.manifold.manifold.shapes.cube_description": "erstellt eine 3D-Würfelform",
    "bitbybit.manifold.manifold.shapes.sphere": "Kugel",
    "bitbybit.manifold.manifold.shapes.sphere_description": "erstellt eine 3D-Kugelform",
    "circularSegments": "kreisförmige Segmente",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "Tetraeder",
    "tetrahedron": "Tetraeder",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "erstellt eine 3D-Tetraederform",
    "bitbybit.manifold.manifold.shapes.cylinder": "Zylinder",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "erstellt eine 3D-Zylinderform",
    "radiusLow": "niedriger Radius",
    "radiusHigh": "hoher Radius",
    "bitbybit.manifold.manifold.booleans.subtract": "subtrahieren",
    "bitbybit.manifold.manifold.booleans.subtract_description": "subtrahiert zwei Mannigfaltigkeitsformen",
    "a to b": "A zu B",
    "manifold1": "Mannigfaltigkeit 1",
    "manifold2": "Mannigfaltigkeit 2",
    "bitbybit.manifold.manifold.booleans.add": "hinzufügen",
    "bitbybit.manifold.manifold.booleans.add_description": "fügt zwei Mannigfaltigkeitsformen hinzu",
    "bitbybit.manifold.manifold.booleans.intersect": "sich schneiden",
    "bitbybit.manifold.manifold.booleans.intersect_description": "schneidet zwei Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "Differenz zwei",
    "differenceTwo": "Differenz zwei",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "Differenz von zwei Mannigfaltigkeitsformen",
    "2 manifolds": "2 Mannigfaltigkeiten",
    "bitbybit.manifold.manifold.booleans.unionTwo": "Vereinigung zwei",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "Vereinigung von zwei Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "Schnitt zwei",
    "intersectionTwo": "Schnitt zwei",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "Schnitt von zwei Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.difference": "Differenz",
    "bitbybit.manifold.manifold.booleans.difference_description": "Differenz von mehreren Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.union": "Vereinigung",
    "bitbybit.manifold.manifold.booleans.union_description": "Vereinigung von mehreren Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.intersection": "Schnitt",
    "bitbybit.manifold.manifold.booleans.intersection_description": "Schnitt von mehreren Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.split": "teilen",
    "split": "teilen",
    "bitbybit.manifold.manifold.booleans.split_description": "teilt eine Mannigfaltigkeit durch eine andere Mannigfaltigkeit",
    "manifoldToSplit": "zu teilende Mannigfaltigkeit",
    "manifoldCutter": "schneidende Mannigfaltigkeit",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "durch Ebene teilen",
    "splitByPlane": "durch Ebene teilen",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "teilt eine Mannigfaltigkeit durch eine Ebene",
    "originOffset": "Ursprungsversatz",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "durch Ebene bei Versätzen teilen",
    "splitByPlaneOnOffsets": "durch Ebene bei Versätzen teilen",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "teilt eine Mannigfaltigkeit durch eine Ebene bei Versätzen",
    "originOffsets": "Ursprungsversätze",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "durch Ebene beschneiden",
    "trimByPlane": "durch Ebene beschneiden",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "beschneidet eine Mannigfaltigkeit durch eine Ebene",
    "trim": "beschneiden",
    "bitbybit.manifold.manifold.operations.hull": "Hülle",
    "bitbybit.manifold.manifold.operations.hull_description": "berechnet die konvexe Hülle einer Mannigfaltigkeitsform",
    "bitbybit.manifold.manifold.operations.hullPoints": "Hüllpunkte",
    "hullPoints": "Hüllpunkte",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "hüllt Punkte oder Mannigfaltigkeiten",
    "bitbybit.manifold.manifold.operations.slice": "schneiden",
    "bitbybit.manifold.manifold.operations.slice_description": "gibt den Querschnitt eines Objekts bei einer Höhe zurück",
    "cross sections": "Querschnitte",
    "bitbybit.manifold.manifold.operations.project": "projizieren",
    "bitbybit.manifold.manifold.operations.project_description": "erstellt eine Projektion auf die XY-Ebene aus dem Umriss einer Form",
    "bitbybit.manifold.manifold.operations.setTolerance": "Toleranz setzen",
    "setTolerance": "Toleranz setzen",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "setzt den Toleranzwert für die Mannigfaltigkeit",
    "basic": "grundlegend",
    "bitbybit.manifold.manifold.operations.reserveIds": "IDs reservieren",
    "reserveIds": "IDs reservieren",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "reserviert sequentielle Netz-IDs",
    "count": "Anzahl",
    "bitbybit.manifold.manifold.operations.asOriginal": "als Original",
    "asOriginal": "als Original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "setzt Mannigfaltigkeits-IDs als Original zurück",
    "bitbybit.manifold.manifold.operations.compose": "zusammenstellen",
    "compose": "zusammenstellen",
    "bitbybit.manifold.manifold.operations.compose_description": "konstruiert eine Mannigfaltigkeit aus einer Liste von Mannigfaltigkeiten",
    "composition": "Zusammenstellung",
    "bitbybit.manifold.manifold.operations.decompose": "zerlegen",
    "bitbybit.manifold.manifold.operations.decompose_description": "zerlegt eine Mannigfaltigkeit in unverbundene Teile",
    "bitbybit.manifold.manifold.operations.calculateNormals": "Normalen berechnen",
    "calculateNormals": "Normalen berechnen",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "berechnet Vertex-Normalen",
    "adjustments": "Anpassungen",
    "minSharpAngle": "minimaler scharfer Winkel",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "Krümmung berechnen",
    "calculateCurvature": "Krümmung berechnen",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "berechnet die Krümmung für Vertices",
    "gaussianIdx": "Gauß-Index",
    "meanIdx": "Mittelwert-Index",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "auf Toleranz verfeinern",
    "refineToTolerance": "auf Toleranz verfeinern",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "verfeinert das Netz auf eine Toleranz",
    "bitbybit.manifold.manifold.operations.refineToLength": "auf Länge verfeinern",
    "refineToLength": "auf Länge verfeinern",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "verfeinert das Netz auf eine Länge",
    "bitbybit.manifold.manifold.operations.refine": "verfeinern",
    "refine": "verfeinern",
    "bitbybit.manifold.manifold.operations.refine_description": "verfeinert das Netz durch Teilen der Kanten",
    "bitbybit.manifold.manifold.operations.smoothOut": "glätten",
    "smoothOut": "glätten",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "glättet die Mannigfaltigkeit mit Tangentenvektoren",
    "minSmoothness": "minimale Glätte",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "nach Normalen glätten",
    "smoothByNormals": "nach Normalen glätten",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "glättet die Mannigfaltigkeit unter Verwendung von Vertex-Normalen",
    "bitbybit.manifold.manifold.transforms.scale3D": "3D skalieren",
    "scale3D": "3D skalieren",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "skaliert die Mannigfaltigkeit mit einem 3D-Vektor",
    "bitbybit.manifold.manifold.transforms.scale": "skalieren",
    "bitbybit.manifold.manifold.transforms.scale_description": "skaliert die Mannigfaltigkeit mit einem einzigen Faktor",
    "bitbybit.manifold.manifold.transforms.mirror": "spiegeln",
    "bitbybit.manifold.manifold.transforms.mirror_description": "spiegelt die Mannigfaltigkeit über eine Ebene",
    "bitbybit.manifold.manifold.transforms.translate": "verschieben",
    "bitbybit.manifold.manifold.transforms.translate_description": "verschiebt die Mannigfaltigkeit entlang eines Vektors",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "nach Vektoren verschieben",
    "translateByVectors": "nach Vektoren verschieben",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "verschiebt die Mannigfaltigkeit nach mehreren Vektoren",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "XYZ verschieben",
    "translateXYZ": "XYZ verschieben",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "verschiebt die Mannigfaltigkeit entlang X, Y, Z",
    "bitbybit.manifold.manifold.transforms.rotate": "drehen",
    "bitbybit.manifold.manifold.transforms.rotate_description": "dreht die Mannigfaltigkeit mit Euler-Winkeln",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "XYZ drehen",
    "rotateXYZ": "XYZ drehen",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "dreht die Mannigfaltigkeit entlang X, Y, Z Euler-Winkeln",
    "bitbybit.manifold.manifold.transforms.transform": "transformieren",
    "bitbybit.manifold.manifold.transforms.transform_description": "transformiert die Mannigfaltigkeit mit einer 4x4-Matrix",
    "matrix": "Matrix",
    "Base.TransformMatrix": "Basis-Transformationsmatrix",
    "bitbybit.manifold.manifold.transforms.transforms": "Transformationen",
    "bitbybit.manifold.manifold.transforms.transforms_description": "transformiert die Mannigfaltigkeit mit mehreren 4x4-Matrizen",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "Oberflächeninhalt",
    "evaluate": "auswerten",
    "surfaceArea": "Oberflächeninhalt",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "ruft den Oberflächeninhalt der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.volume": "Volumen",
    "volume": "Volumen",
    "bitbybit.manifold.manifold.evaluate.volume_description": "ruft das Volumen der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "ist leer",
    "isEmpty": "ist leer",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "prüft, ob die Mannigfaltigkeit Dreiecke hat",
    "bitbybit.manifold.manifold.evaluate.numVert": "Anzahl Vertices",
    "numVert": "Anzahl Vertices",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "ruft die Anzahl der Vertices in der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.numTri": "Anzahl Dreiecke",
    "numTri": "Anzahl Dreiecke",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "ruft die Anzahl der Dreiecke in der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.numEdge": "Anzahl Kanten",
    "numEdge": "Anzahl Kanten",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "ruft die Anzahl der Kanten in der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.numProp": "Anzahl Eigenschaften",
    "numProp": "Anzahl Eigenschaften",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "ruft die Anzahl der Eigenschaften in der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "Anzahl Eigenschaftsvertices",
    "numPropVert": "Anzahl Eigenschaftsvertices",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "ruft die Anzahl der Eigenschaftsvertices in der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "Begrenzungsbox",
    "boundingBox": "Begrenzungsbox",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "ruft die achsenparallele Begrenzungsbox der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.tolerance": "Toleranz",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "ruft die Toleranz der Mannigfaltigkeitsvertices ab",
    "bitbybit.manifold.manifold.evaluate.genus": "Gattung",
    "genus": "Gattung",
    "bitbybit.manifold.manifold.evaluate.genus_description": "ruft die Gattung der Mannigfaltigkeit ab",
    "bitbybit.manifold.manifold.evaluate.minGap": "minimaler Abstand",
    "minGap": "minimaler Abstand",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "ruft den minimalen Abstand zwischen zwei Mannigfaltigkeiten ab",
    "searchLength": "Suchlänge",
    "bitbybit.manifold.manifold.evaluate.originalID": "ursprüngliche ID",
    "originalID": "ursprüngliche ID",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "ruft die ursprüngliche ID der Mannigfaltigkeit ab",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "Querschnitt zu Polygonen",
    "crossSection": "Querschnitt",
    "crossSectionToPolygons": "Querschnitt zu Polygonen",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "wandelt einen Querschnitt in Polygone um",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "Querschnitte zu Polygonen",
    "crossSectionsToPolygons": "Querschnitte zu Polygonen",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "wandelt Querschnitte in Polygone um",
    "crossSections": "Querschnitte",
    "bitbybit.manifold.crossSection.shapes.create": "erstellen",
    "bitbybit.manifold.crossSection.shapes.create_description": "erstellt einen 2D-Querschnitt aus Konturen",
    "Base.Vector2[][]": "Basis-Vektor-2-Array",
    "fillRule": "Füllregel",
    "fillRuleEnum": "Füllregel-Enum",
    "bitbybit.manifold.crossSection.shapes.square": "Quadrat",
    "bitbybit.manifold.crossSection.shapes.square_description": "erstellt einen 2D-Quadratquerschnitt",
    "bitbybit.manifold.crossSection.shapes.circle": "Kreis",
    "bitbybit.manifold.crossSection.shapes.circle_description": "erstellt einen 2D-Kreisquerschnitt",
    "bitbybit.manifold.crossSection.shapes.rectangle": "Rechteck",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "erstellt einen 2D-Rechteckquerschnitt",
    "bitbybit.manifold.crossSection.operations.hull": "Hülle",
    "bitbybit.manifold.crossSection.operations.hull_description": "berechnet die konvexe Hülle für einen Querschnitt",
    "bitbybit.manifold.crossSection.operations.extrude": "extrudieren",
    "bitbybit.manifold.crossSection.operations.extrude_description": "extrudiert einen Querschnitt zu einer 3D-Form",
    "nDivisions": "Anzahl Teilungen",
    "twistDegrees": "Verdrehungsgrade",
    "scaleTopX": "Skalierung oben X",
    "scaleTopY": "Skalierung oben Y",
    "bitbybit.manifold.crossSection.operations.revolve": "rotieren",
    "bitbybit.manifold.crossSection.operations.revolve_description": "rotiert einen Querschnitt zu einer 3D-Form",
    "revolveDegrees": "Rotationsgrade",
    "matchProfile": "Profil anpassen",
    "bitbybit.manifold.crossSection.operations.offset": "Versatz",
    "bitbybit.manifold.crossSection.operations.offset_description": "versetzt einen Querschnitt mit Delta",
    "manifoldJoinTypeEnum": "Mannigfaltigkeits-Verbindungstyp-Enum",
    "miterLimit": "Gehrungslimit",
    "bitbybit.manifold.crossSection.operations.simplify": "vereinfachen",
    "simplify": "vereinfachen",
    "bitbybit.manifold.crossSection.operations.simplify_description": "vereinfacht die Konturen eines Querschnitts",
    "epsilon": "Epsilon",
    "bitbybit.manifold.crossSection.operations.compose": "zusammenstellen",
    "bitbybit.manifold.crossSection.operations.compose_description": "stellt mehrere Querschnitte zu einem zusammen",
    "bitbybit.manifold.crossSection.operations.decompose": "zerlegen",
    "bitbybit.manifold.crossSection.operations.decompose_description": "zerlegt Querschnitte in Teile",
    "bitbybit.manifold.crossSection.booleans.subtract": "subtrahieren",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "subtrahiert zwei Querschnitte",
    "crossSection1": "Querschnitt 1",
    "crossSection2": "Querschnitt 2",
    "bitbybit.manifold.crossSection.booleans.add": "hinzufügen",
    "bitbybit.manifold.crossSection.booleans.add_description": "fügt zwei Querschnitte hinzu",
    "bitbybit.manifold.crossSection.booleans.intersect": "sich schneiden",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "schneidet zwei Querschnitte",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "Differenz zwei",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "Differenz von zwei Querschnitten",
    "2 cross sections": "2 Querschnitte",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "Vereinigung zwei",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "Vereinigung von zwei Querschnitten",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "Schnitt zwei",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "Schnitt von zwei Querschnitten",
    "bitbybit.manifold.crossSection.booleans.difference": "Differenz",
    "bitbybit.manifold.crossSection.booleans.difference_description": "Differenz von mehreren Querschnitten",
    "bitbybit.manifold.crossSection.booleans.union": "Vereinigung",
    "bitbybit.manifold.crossSection.booleans.union_description": "Vereinigung von mehreren Querschnitten",
    "bitbybit.manifold.crossSection.booleans.intersection": "Schnitt",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "Schnitt von mehreren Querschnitten",
    "bitbybit.manifold.crossSection.transforms.scale2D": "2D skalieren",
    "scale2D": "2D skalieren",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "skaliert einen Querschnitt mit einem 2D-Vektor",
    "bitbybit.manifold.crossSection.transforms.scale": "skalieren",
    "bitbybit.manifold.crossSection.transforms.scale_description": "skaliert einen Querschnitt mit einem einzigen Faktor",
    "bitbybit.manifold.crossSection.transforms.mirror": "spiegeln",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "spiegelt einen Querschnitt über eine Ebene",
    "bitbybit.manifold.crossSection.transforms.translate": "verschieben",
    "bitbybit.manifold.crossSection.transforms.translate_description": "verschiebt einen Querschnitt entlang eines Vektors",
    "bitbybit.manifold.crossSection.transforms.translateXY": "XY verschieben",
    "translateXY": "XY verschieben",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "verschiebt einen Querschnitt entlang X, Y",
    "bitbybit.manifold.crossSection.transforms.rotate": "drehen",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "dreht einen Querschnitt mit Graden",
    "degrees": "Grade",
    "bitbybit.manifold.crossSection.transforms.transform": "transformieren",
    "bitbybit.manifold.crossSection.transforms.transform_description": "transformiert einen Querschnitt mit einer 3x3-Matrix",
    "Base.TransformMatrix3x3": "Basis-Transformationsmatrix 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "Fläche",
    "area": "Fläche",
    "bitbybit.manifold.crossSection.evaluate.area_description": "ruft die Fläche eines Querschnitts ab",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "ist leer",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "prüft, ob der Querschnitt leer ist",
    "bitbybit.manifold.crossSection.evaluate.numVert": "Anzahl Vertices",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "ruft die Anzahl der Vertices in einem Querschnitt ab",
    "bitbybit.manifold.crossSection.evaluate.numContour": "Anzahl Konturen",
    "numContour": "Anzahl Konturen",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "ruft die Anzahl der Konturen in einem Querschnitt ab",
    "bitbybit.manifold.crossSection.evaluate.bounds": "Grenzen",
    "bounds": "Grenzen",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "ruft die Grenzen einer Kontur als Rechteck ab",
    "bitbybit.manifold.mesh.operations.merge": "zusammenführen",
    "merge": "zusammenführen",
    "bitbybit.manifold.mesh.operations.merge_description": "führt Vertices zu einem Mannigfaltigkeitsvolumenkörper zusammen",
    "bitbybit.manifold.mesh.evaluate.position": "Position",
    "bitbybit.manifold.mesh.evaluate.position_description": "ruft die Position am Netz-Vertex-Index ab",
    "vertexIndex": "Vertex-Index",
    "bitbybit.manifold.mesh.evaluate.verts": "Vertices",
    "verts": "Vertices",
    "bitbybit.manifold.mesh.evaluate.verts_description": "ruft die drei Vertex-Indizes eines Dreiecks ab",
    "triangleIndex": "Dreiecksindex",
    "bitbybit.manifold.mesh.evaluate.tangent": "Tangente",
    "tangent": "Tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "ruft den Tangentenvektor einer Halbkante ab",
    "halfEdgeIndex": "Halbkantenindex",
    "bitbybit.manifold.mesh.evaluate.extras": "Extras",
    "extras": "Extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "ruft zusätzliche Eigenschaften eines Vertex ab",
    "bitbybit.manifold.mesh.evaluate.transform": "Transformation",
    "bitbybit.manifold.mesh.evaluate.transform_description": "ruft die 4x4-Transformationsmatrix eines Netzes ab",
    "bitbybit.manifold.mesh.evaluate.numProp": "Anzahl Eigenschaften",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "ruft die Anzahl der Eigenschaften pro Vertex ab",
    "bitbybit.manifold.mesh.evaluate.numVert": "Anzahl Vertices",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "ruft die Anzahl der Eigenschaftsvertices ab",
    "bitbybit.manifold.mesh.evaluate.numTri": "Anzahl Dreiecke",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "ruft die Anzahl der Dreiecke auf dem Netz ab",
    "bitbybit.manifold.mesh.evaluate.numRun": "Anzahl Läufe",
    "numRun": "Anzahl Läufe",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "ruft die Anzahl der Dreiecksläufe ab",
    "bitbybit.logic.boolean": "boolesch",
    "logic": "Logik",
    "bitbybit.logic.boolean_description": "erstellt einen booleschen Wert",
    "bitbybit.logic.randomBooleans": "zufällige Booleans",
    "randomBooleans": "zufällige Booleans",
    "bitbybit.logic.randomBooleans_description": "erstellt eine Liste zufälliger Booleans",
    "trueThreshold": "Schwellenwert für wahr",
    "bitbybit.logic.twoThresholdRandomGradient": "zweischwelliger Zufallsgradient",
    "twoThresholdRandomGradient": "zweischwelliger Zufallsgradient",
    "bitbybit.logic.twoThresholdRandomGradient_description": "erstellt eine Liste zufälliger Booleans mit Schwellenwerten",
    "numbers": "Zahlen",
    "thresholdTotalTrue": "Schwellenwert gesamt wahr",
    "thresholdTotalFalse": "Schwellenwert gesamt falsch",
    "nrLevels": "Anzahl Ebenen",
    "bitbybit.logic.thresholdBooleanList": "Schwellenwert-Boolean-Liste",
    "thresholdBooleanList": "Schwellenwert-Boolean-Liste",
    "bitbybit.logic.thresholdBooleanList_description": "erstellt eine Boolean-Liste mit Schwellenwert",
    "threshold": "Schwellenwert",
    "bitbybit.logic.thresholdGapsBooleanList": "Schwellenwert-Lücken-Boolean-Liste",
    "thresholdGapsBooleanList": "Schwellenwert-Lücken-Boolean-Liste",
    "bitbybit.logic.thresholdGapsBooleanList_description": "erstellt eine Boolean-Liste mit Lücken-Schwellenwerten",
    "gapThresholds": "Lücken-Schwellenwerte",
    "Base.Vector2[]": "Basis-Vektor-2-Array",
    "bitbybit.logic.not": "nicht",
    "not": "nicht",
    "bitbybit.logic.not_description": "wendet den Nicht-Operator auf einen Boolean an",
    "bitbybit.logic.notList": "Nicht-Liste",
    "notList": "Nicht-Liste",
    "bitbybit.logic.notList_description": "wendet den Nicht-Operator auf eine Boolean-Liste an",
    "bitbybit.logic.compare": "vergleichen",
    "compare": "vergleichen",
    "bitbybit.logic.compare_description": "vergleicht zwei Werte",
    "operator": "Operator",
    "BooleanOperatorsEnum": "Boolean-Operatoren-Enum",
    "bitbybit.logic.valueGate": "Werttor",
    "valueGate": "Werttor",
    "bitbybit.logic.valueGate_description": "überträgt den Wert, wenn der Boolean wahr ist",
    "bitbybit.logic.firstDefinedValueGate": "erstes definiertes Werttor",
    "firstDefinedValueGate": "erstes definiertes Werttor",
    "bitbybit.logic.firstDefinedValueGate_description": "gibt den ersten definierten Wert zurück",
    "value1": "Wert 1",
    "value2": "Wert 2",
    "bitbybit.math.number": "Zahl",
    "math": "Mathematik",
    "bitbybit.math.number_description": "erstellt eine Zahl",
    "bitbybit.math.twoNrOperation": "Zwei-Zahlen-Operation",
    "twoNrOperation": "Zwei-Zahlen-Operation",
    "bitbybit.math.twoNrOperation_description": "führt grundlegende mathematische Operationen aus",
    "operation": "Operation",
    "mathTwoNrOperatorEnum": "Mathematik-Zwei-Zahlen-Operator-Enum",
    "bitbybit.math.modulus": "Modulus",
    "modulus": "Modulus",
    "bitbybit.math.modulus_description": "führt eine Modulus-Operation aus",
    "bitbybit.math.roundToDecimals": "auf Dezimalstellen runden",
    "roundToDecimals": "auf Dezimalstellen runden",
    "bitbybit.math.roundToDecimals_description": "rundet auf Dezimalstellen",
    "decimalPlaces": "Dezimalstellen",
    "bitbybit.math.oneNrOperation": "Ein-Zahl-Operation",
    "oneNrOperation": "Ein-Zahl-Operation",
    "bitbybit.math.oneNrOperation_description": "führt Mathematik mit einer Zahl aus",
    "mathOneNrOperatorEnum": "Mathematik-Ein-Zahl-Operator-Enum",
    "bitbybit.math.remap": "umskalieren",
    "remap": "umskalieren",
    "bitbybit.math.remap_description": "skaliert eine Zahl zwischen Bereichen um",
    "fromLow": "von niedrig",
    "fromHigh": "von hoch",
    "toLow": "nach niedrig",
    "toHigh": "nach hoch",
    "bitbybit.math.random": "zufällig",
    "random": "zufällig",
    "bitbybit.math.random_description": "erstellt eine Zufallszahl von 0 bis 1",
    "generate": "generieren",
    "bitbybit.math.randomNumber": "Zufallszahl",
    "randomNumber": "Zufallszahl",
    "bitbybit.math.randomNumber_description": "erstellt eine Zufallszahl in einem Bereich",
    "low": "niedrig",
    "high": "hoch",
    "bitbybit.math.randomNumbers": "Zufallszahlen",
    "randomNumbers": "Zufallszahlen",
    "bitbybit.math.randomNumbers_description": "erstellt Zufallszahlen in einem Bereich",
    "bitbybit.math.pi": "Pi",
    "pi": "Pi",
    "bitbybit.math.pi_description": "erstellt die Zahl Pi",
    "bitbybit.math.toFixed": "auf festgelegte Dezimalstellen",
    "toFixed": "auf festgelegte Dezimalstellen",
    "bitbybit.math.toFixed_description": "rundet eine Zahl auf Dezimalstellen",
    "bitbybit.math.add": "addieren",
    "bitbybit.math.add_description": "addiert zwei Zahlen",
    "basics": "Grundlagen",
    "bitbybit.math.subtract": "subtrahieren",
    "bitbybit.math.subtract_description": "subtrahiert zwei Zahlen",
    "bitbybit.math.multiply": "multiplizieren",
    "bitbybit.math.multiply_description": "multipliziert zwei Zahlen",
    "bitbybit.math.divide": "dividieren",
    "divide": "dividieren",
    "bitbybit.math.divide_description": "dividiert zwei Zahlen",
    "bitbybit.math.power": "potenzieren",
    "power": "potenzieren",
    "bitbybit.math.power_description": "potenziert eine Zahl",
    "bitbybit.math.sqrt": "Quadratwurzel",
    "sqrt": "Quadratwurzel",
    "bitbybit.math.sqrt_description": "ermittelt die Quadratwurzel",
    "bitbybit.math.abs": "absolut",
    "abs": "absolut",
    "bitbybit.math.abs_description": "ermittelt den absoluten Wert",
    "bitbybit.math.round": "runden",
    "round": "runden",
    "bitbybit.math.round_description": "rundet eine Zahl",
    "bitbybit.math.floor": "abrunden",
    "floor": "abrunden",
    "bitbybit.math.floor_description": "rundet eine Zahl ab",
    "bitbybit.math.ceil": "aufrunden",
    "ceil": "aufrunden",
    "bitbybit.math.ceil_description": "rundet eine Zahl auf",
    "bitbybit.math.negate": "negieren",
    "negate": "negieren",
    "bitbybit.math.negate_description": "negiert eine Zahl",
    "bitbybit.math.ln": "natürlicher Logarithmus",
    "ln": "natürlicher Logarithmus",
    "bitbybit.math.ln_description": "ermittelt den natürlichen Logarithmus",
    "bitbybit.math.log10": "Logarithmus Basis 10",
    "log10": "Logarithmus Basis 10",
    "bitbybit.math.log10_description": "ermittelt den Logarithmus zur Basis 10",
    "bitbybit.math.tenPow": "Zehnerpotenz",
    "tenPow": "Zehnerpotenz",
    "bitbybit.math.tenPow_description": "erhöht 10 auf eine Potenz",
    "bitbybit.math.sin": "Sinus",
    "sin": "Sinus",
    "bitbybit.math.sin_description": "ermittelt den Sinus",
    "bitbybit.math.cos": "Cosinus",
    "cos": "Cosinus",
    "bitbybit.math.cos_description": "ermittelt den Cosinus",
    "bitbybit.math.tan": "Tangens",
    "tan": "Tangens",
    "bitbybit.math.tan_description": "ermittelt den Tangens",
    "bitbybit.math.asin": "Arcussinus",
    "asin": "Arcussinus",
    "bitbybit.math.asin_description": "ermittelt den Arcussinus",
    "bitbybit.math.acos": "Arcuscosinus",
    "acos": "Arcuscosinus",
    "bitbybit.math.acos_description": "ermittelt den Arcuscosinus",
    "bitbybit.math.atan": "Arcustangens",
    "atan": "Arcustangens",
    "bitbybit.math.atan_description": "ermittelt den Arcustangens",
    "bitbybit.math.exp": "Exponent",
    "exp": "Exponent",
    "bitbybit.math.exp_description": "ermittelt den natürlichen Exponenten",
    "bitbybit.math.degToRad": "Grad zu Radiant",
    "degToRad": "Grad zu Radiant",
    "bitbybit.math.degToRad_description": "konvertiert Grad in Radiant",
    "bitbybit.math.radToDeg": "Radiant zu Grad",
    "radToDeg": "Radiant zu Grad",
    "bitbybit.math.radToDeg_description": "konvertiert Radiant in Grad",
    "bitbybit.math.ease": "glätten",
    "bitbybit.math.ease_description": "glättet eine Zahl mit einem Bereich",
    "easeEnum": "Glättungs-Enum",
    "bitbybit.lists.getItem": "Element abrufen",
    "lists": "Listen",
    "getItem": "Element abrufen",
    "bitbybit.lists.getItem_description": "ruft ein Element aus einer Liste nach Index ab",
    "list": "Liste",
    "bitbybit.lists.randomGetThreshold": "zufälliges Abrufen mit Schwellenwert",
    "randomGetThreshold": "zufälliges Abrufen mit Schwellenwert",
    "bitbybit.lists.randomGetThreshold_description": "ruft Elemente zufällig mit einem Schwellenwert ab",
    "bitbybit.lists.getSubList": "Teilliste abrufen",
    "getSubList": "Teilliste abrufen",
    "bitbybit.lists.getSubList_description": "ruft eine Teilliste zwischen Indizes ab",
    "indexStart": "Startindex",
    "indexEnd": "Endindex",
    "bitbybit.lists.getNthItem": "n-tes Element abrufen",
    "getNthItem": "n-tes Element abrufen",
    "bitbybit.lists.getNthItem_description": "ruft das n-te Element in einer Liste ab",
    "nth": "n-tes",
    "bitbybit.lists.getByPattern": "nach Muster abrufen",
    "getByPattern": "nach Muster abrufen",
    "bitbybit.lists.getByPattern_description": "ruft Elemente nach einem Muster ab",
    "pattern": "Muster",
    "bitbybit.lists.mergeElementsOfLists": "Elemente von Listen zusammenführen",
    "mergeElementsOfLists": "Elemente von Listen zusammenführen",
    "bitbybit.lists.mergeElementsOfLists_description": "führt Elemente von Listen auf einer Ebene zusammen",
    "level": "Ebene",
    "bitbybit.lists.getLongestListLength": "längste Listenlänge abrufen",
    "getLongestListLength": "längste Listenlänge abrufen",
    "bitbybit.lists.getLongestListLength_description": "ruft die längste Listenlänge ab",
    "bitbybit.lists.reverse": "umkehren",
    "bitbybit.lists.reverse_description": "kehrt eine Liste um",
    "bitbybit.lists.flipLists": "Listen spiegeln",
    "flipLists": "Listen spiegeln",
    "bitbybit.lists.flipLists_description": "spiegelt 2D-Listen",
    "bitbybit.lists.groupNth": "n-tes gruppieren",
    "groupNth": "n-tes gruppieren",
    "bitbybit.lists.groupNth_description": "gruppiert eine Liste in n Elemente",
    "nrElements": "Anzahl Elemente",
    "keepRemainder": "Rest behalten",
    "bitbybit.lists.getListDepth": "Listentiefe abrufen",
    "getListDepth": "Listentiefe abrufen",
    "bitbybit.lists.getListDepth_description": "ruft die Tiefe einer Liste ab",
    "bitbybit.lists.listLength": "Listenlänge",
    "listLength": "Listenlänge",
    "bitbybit.lists.listLength_description": "ruft die Länge einer Liste ab",
    "bitbybit.lists.addItemAtIndex": "Element an Index hinzufügen",
    "addItemAtIndex": "Element an Index hinzufügen",
    "bitbybit.lists.addItemAtIndex_description": "fügt ein Element an einem Index zu einer Liste hinzu",
    "item": "Element",
    "bitbybit.lists.addItemAtIndexes": "Element an Indizes hinzufügen",
    "addItemAtIndexes": "Element an Indizes hinzufügen",
    "bitbybit.lists.addItemAtIndexes_description": "fügt ein Element an Indizes zu einer Liste hinzu",
    "bitbybit.lists.addItemsAtIndexes": "Elemente an Indizes hinzufügen",
    "addItemsAtIndexes": "Elemente an Indizes hinzufügen",
    "bitbybit.lists.addItemsAtIndexes_description": "fügt Elemente an Indizes zu einer Liste hinzu",
    "items": "Elemente",
    "bitbybit.lists.removeItemAtIndex": "Element an Index entfernen",
    "removeItemAtIndex": "Element an Index entfernen",
    "bitbybit.lists.removeItemAtIndex_description": "entfernt ein Element an einem Index aus einer Liste",
    "bitbybit.lists.removeItemsAtIndexes": "Elemente an Indizes entfernen",
    "removeItemsAtIndexes": "Elemente an Indizes entfernen",
    "bitbybit.lists.removeItemsAtIndexes_description": "entfernt Elemente an Indizes aus einer Liste",
    "bitbybit.lists.removeAllItems": "alle Elemente entfernen",
    "removeAllItems": "alle Elemente entfernen",
    "bitbybit.lists.removeAllItems_description": "entfernt alle Elemente aus einer Liste",
    "bitbybit.lists.removeNthItem": "n-tes Element entfernen",
    "removeNthItem": "n-tes Element entfernen",
    "bitbybit.lists.removeNthItem_description": "entfernt das n-te Element aus einer Liste",
    "bitbybit.lists.randomRemoveThreshold": "zufälliges Entfernen mit Schwellenwert",
    "randomRemoveThreshold": "zufälliges Entfernen mit Schwellenwert",
    "bitbybit.lists.randomRemoveThreshold_description": "entfernt Elemente zufällig mit einem Schwellenwert",
    "bitbybit.lists.removeDuplicateNumbers": "doppelte Zahlen entfernen",
    "removeDuplicateNumbers": "doppelte Zahlen entfernen",
    "bitbybit.lists.removeDuplicateNumbers_description": "entfernt doppelte Zahlen aus einer Liste",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "doppelte Zahlen mit Toleranz entfernen",
    "removeDuplicateNumbersTolerance": "doppelte Zahlen mit Toleranz entfernen",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "entfernt doppelte Zahlen mit Toleranz",
    "bitbybit.lists.addItem": "Element hinzufügen",
    "addItem": "Element hinzufügen",
    "bitbybit.lists.addItem_description": "fügt ein Element ans Ende einer Liste hinzu",
    "bitbybit.lists.prependItem": "Element voranstellen",
    "prependItem": "Element voranstellen",
    "bitbybit.lists.prependItem_description": "fügt ein Element an den Anfang einer Liste hinzu",
    "bitbybit.lists.addItemFirstLast": "Element zuerst oder zuletzt hinzufügen",
    "addItemFirstLast": "Element zuerst oder zuletzt hinzufügen",
    "bitbybit.lists.addItemFirstLast_description": "fügt ein Element an den Anfang oder das Ende einer Liste hinzu",
    "firstLastEnum": "Erste-Letzte-Enum",
    "bitbybit.lists.createEmptyList": "leere Liste",
    "createEmptyList": "leere Liste",
    "bitbybit.lists.createEmptyList_description": "erstellt eine leere Liste",
    "bitbybit.lists.repeat": "wiederholen",
    "repeat": "wiederholen",
    "bitbybit.lists.repeat_description": "wiederholt ein Element in einer neuen Liste",
    "times": "Mal",
    "bitbybit.lists.repeatInPattern": "in Muster wiederholen",
    "repeatInPattern": "in Muster wiederholen",
    "bitbybit.lists.repeatInPattern_description": "wiederholt Listenelemente bis zur Längenbegrenzung",
    "lengthLimit": "Längenbegrenzung",
    "bitbybit.lists.sortNumber": "Zahl sortieren",
    "sortNumber": "Zahl sortieren",
    "bitbybit.lists.sortNumber_description": "sortiert eine Liste von Zahlen",
    "sorting": "Sortierung",
    "orderAsc": "aufsteigende Reihenfolge",
    "bitbybit.lists.sortTexts": "Texte sortieren",
    "sortTexts": "Texte sortieren",
    "bitbybit.lists.sortTexts_description": "sortiert eine Liste von Texten alphabetisch",
    "bitbybit.lists.sortByPropValue": "nach Eigenschaftswert sortieren",
    "sortByPropValue": "nach Eigenschaftswert sortieren",
    "bitbybit.lists.sortByPropValue_description": "sortiert nach numerischem JSON-Eigenschaftswert",
    "property": "Eigenschaft",
    "bitbybit.color.hexColor": "Hex-Farbe",
    "hexColor": "Hex-Farbe",
    "bitbybit.color.hexColor_description": "erstellt eine Hex-Farbe",
    "bitbybit.color.hexToRgb": "Hex zu RGB",
    "hexToRgb": "Hex zu RGB",
    "bitbybit.color.hexToRgb_description": "erstellt RGB aus Hex",
    "convert": "konvertieren",
    "bitbybit.color.rgbToHex": "RGB zu Hex",
    "rgbToHex": "RGB zu Hex",
    "bitbybit.color.rgbToHex_description": "erstellt Hex aus RGB",
    "r": "Rot",
    "g": "Grün",
    "b": "Blau",
    "bitbybit.color.rgbObjToHex": "RGB-Objekt zu Hex",
    "rgbObjToHex": "RGB-Objekt zu Hex",
    "bitbybit.color.rgbObjToHex_description": "erstellt Hex aus RGB-Objekt",
    "rgb": "RGB",
    "Base.ColorRGB": "Basis-Farbe RGB",
    "bitbybit.color.hexToRgbMapped": "Hex zu RGB gemappt",
    "hexToRgbMapped": "Hex zu RGB gemappt",
    "bitbybit.color.hexToRgbMapped_description": "erstellt RGB aus Hex mit Bereichsmapping",
    "bitbybit.color.getRedParam": "Rot-Parameter abrufen",
    "getRedParam": "Rot-Parameter abrufen",
    "bitbybit.color.getRedParam_description": "ruft den Rot-Parameter ab",
    "hex to": "Hex zu",
    "bitbybit.color.getGreenParam": "Grün-Parameter abrufen",
    "getGreenParam": "Grün-Parameter abrufen",
    "bitbybit.color.getGreenParam_description": "ruft den Grün-Parameter ab",
    "bitbybit.color.getBlueParam": "Blau-Parameter abrufen",
    "getBlueParam": "Blau-Parameter abrufen",
    "bitbybit.color.getBlueParam_description": "ruft den Blau-Parameter ab",
    "bitbybit.color.rgbToRed": "RGB zu Rot",
    "rgbToRed": "RGB zu Rot",
    "bitbybit.color.rgbToRed_description": "ruft Rot aus RGB ab",
    "rgb to": "RGB zu",
    "bitbybit.color.rgbToGreen": "RGB zu Grün",
    "rgbToGreen": "RGB zu Grün",
    "bitbybit.color.rgbToGreen_description": "ruft Grün aus RGB ab",
    "bitbybit.color.rgbToBlue": "RGB zu Blau",
    "rgbToBlue": "RGB zu Blau",
    "bitbybit.color.rgbToBlue_description": "ruft Blau aus RGB ab",
    "bitbybit.color.invert": "invertieren",
    "invert": "invertieren",
    "bitbybit.color.invert_description": "invertiert eine Farbe",
    "blackAndWhite": "Schwarz und Weiß",
    "bitbybit.text.create": "erstellen",
    "bitbybit.text.create_description": "erstellt Text",
    "bitbybit.text.split": "teilen",
    "bitbybit.text.split_description": "teilt Text nach einem Trennzeichen",
    "separator": "Trennzeichen",
    "bitbybit.text.replaceAll": "alles ersetzen",
    "replaceAll": "alles ersetzen",
    "bitbybit.text.replaceAll_description": "ersetzt alle Textvorkommen",
    "search": "suchen",
    "replaceWith": "ersetzen durch",
    "bitbybit.text.join": "verbinden",
    "join": "verbinden",
    "bitbybit.text.join_description": "verbindet Elemente zu Text mit einem Trennzeichen",
    "string[]": "Zeichenfolgen-Array",
    "bitbybit.text.toString": "zu Zeichenfolge",
    "toString": "zu Zeichenfolge",
    "bitbybit.text.toString_description": "konvertiert ein Element zu Text",
    "bitbybit.text.toStringEach": "jedes zu Zeichenfolge",
    "toStringEach": "jedes zu Zeichenfolge",
    "bitbybit.text.toStringEach_description": "konvertiert jedes Listenelement zu Text",
    "bitbybit.text.format": "formatieren",
    "format": "formatieren",
    "bitbybit.text.format_description": "formatiert Text mit Werten",
    "values": "Werte",
    "bitbybit.text.vectorChar": "Vektorzeichen",
    "vectorChar": "Vektorzeichen",
    "bitbybit.text.vectorChar_description": "Erstellt Vektorsegmente für ein Zeichen und beinhaltet Breiten- und Höheninformationen.",
    "char": "Zeichen",
    "bitbybit.text.vectorText": "Vektortext",
    "vectorText": "Vektortext",
    "bitbybit.text.vectorText_description": "Erstellt Vektortextzeilen für einen gegebenen Text und beinhaltet Breiten- und Höheninformationen.",
    "dates": "Datum",
    "bitbybit.dates.toDateString": "zu Datumszeichenfolge",
    "toDateString": "zu Datumszeichenfolge",
    "bitbybit.dates.toDateString_description": "Gibt ein Datum als Zeichenfolgenwert zurück.",
    "date": "Datum",
    "Date": "Datum",
    "bitbybit.dates.toISOString": "zu ISO-Zeichenfolge",
    "toISOString": "zu ISO-Zeichenfolge",
    "bitbybit.dates.toISOString_description": "Gibt ein Datum als Zeichenfolgenwert im ISO-Format zurück.",
    "bitbybit.dates.toJSON": "zu JSON",
    "toJSON": "zu JSON",
    "bitbybit.dates.toJSON_description": "Gibt ein Datum als Zeichenfolgenwert im JSON-Format zurück.",
    "bitbybit.dates.toString": "zu Zeichenfolge",
    "bitbybit.dates.toString_description": "Gibt eine Zeichenfolgendarstellung eines Datums zurück. Das Format der Zeichenfolge hängt von der Lokalisierung ab.",
    "bitbybit.dates.toTimeString": "zu Zeitzeichenfolge",
    "toTimeString": "zu Zeitzeichenfolge",
    "bitbybit.dates.toTimeString_description": "Gibt eine Zeit als Zeichenfolgenwert zurück.",
    "bitbybit.dates.toUTCString": "zu UTC-Zeichenfolge",
    "toUTCString": "zu UTC-Zeichenfolge",
    "bitbybit.dates.toUTCString_description": "Gibt ein Datum als Zeichenfolge unter Verwendung der Universal Coordinated Time (UTC) zurück.",
    "bitbybit.dates.now": "jetzt",
    "now": "jetzt",
    "bitbybit.dates.now_description": "Gibt das aktuelle Datum und die aktuelle Uhrzeit zurück.",
    "bitbybit.dates.createDate": "Datum erstellen",
    "createDate": "Datum erstellen",
    "bitbybit.dates.createDate_description": "Erstellt ein neues Datumsobjekt mit den angegebenen Datumsparametern.",
    "year": "Jahr",
    "month": "Monat",
    "day": "Tag",
    "hours": "Stunden",
    "minutes": "Minuten",
    "seconds": "Sekunden",
    "milliseconds": "Millisekunden",
    "bitbybit.dates.createDateUTC": "UTC-Datum erstellen",
    "createDateUTC": "UTC-Datum erstellen",
    "bitbybit.dates.createDateUTC_description": "Gibt die Anzahl der Millisekunden zwischen Mitternacht, 1. Januar 1970 Universal Coordinated Time (UTC) (oder GMT) und dem angegebenen Datum zurück.",
    "bitbybit.dates.createFromUnixTimeStamp": "aus Unix-Zeitstempel erstellen",
    "createFromUnixTimeStamp": "aus Unix-Zeitstempel erstellen",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Erstellt ein neues Datumsobjekt mit dem angegebenen Unix-Zeitstempel.",
    "unixTimeStamp": "Unix-Zeitstempel",
    "bitbybit.dates.parseDate": "Datum parsen",
    "parseDate": "Datum parsen",
    "bitbybit.dates.parseDate_description": "Parst eine Zeichenfolge, die ein Datum enthält, und gibt die Anzahl der Millisekunden zwischen diesem Datum und Mitternacht, 1. Januar 1970 zurück.",
    "parse": "parsen",
    "dateString": "Datumszeichenfolge",
    "bitbybit.dates.getDayOfMonth": "Tag des Monats abrufen",
    "getDayOfMonth": "Tag des Monats abrufen",
    "bitbybit.dates.getDayOfMonth_description": "Ruft den Tag des Monats unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getWeekday": "Wochentag abrufen",
    "getWeekday": "Wochentag abrufen",
    "bitbybit.dates.getWeekday_description": "Ruft den Wochentag unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getYear": "Jahr abrufen",
    "getYear": "Jahr abrufen",
    "bitbybit.dates.getYear_description": "Ruft das Jahr unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getMonth": "Monat abrufen",
    "getMonth": "Monat abrufen",
    "bitbybit.dates.getMonth_description": "Ruft den Monat unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getHours": "Stunden abrufen",
    "getHours": "Stunden abrufen",
    "bitbybit.dates.getHours_description": "Ruft die Stunden eines Datums unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getMinutes": "Minuten abrufen",
    "getMinutes": "Minuten abrufen",
    "bitbybit.dates.getMinutes_description": "Ruft die Minuten eines Datumsobjekts unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getSeconds": "Sekunden abrufen",
    "getSeconds": "Sekunden abrufen",
    "bitbybit.dates.getSeconds_description": "Ruft die Sekunden eines Datumsobjekts unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getMilliseconds": "Millisekunden abrufen",
    "getMilliseconds": "Millisekunden abrufen",
    "bitbybit.dates.getMilliseconds_description": "Ruft die Millisekunden eines Datums unter Verwendung der lokalen Zeit ab.",
    "bitbybit.dates.getTime": "Zeit abrufen",
    "getTime": "Zeit abrufen",
    "bitbybit.dates.getTime_description": "Gibt den gespeicherten Zeitwert in Millisekunden seit Mitternacht, 1. Januar 1970 UTC zurück.",
    "bitbybit.dates.getUTCYear": "UTC-Jahr abrufen",
    "getUTCYear": "UTC-Jahr abrufen",
    "bitbybit.dates.getUTCYear_description": "Ruft das Jahr unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.getUTCMonth": "UTC-Monat abrufen",
    "getUTCMonth": "UTC-Monat abrufen",
    "bitbybit.dates.getUTCMonth_description": "Ruft den Monat eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.getUTCDay": "UTC-Tag abrufen",
    "getUTCDay": "UTC-Tag abrufen",
    "bitbybit.dates.getUTCDay_description": "Ruft den Tag des Monats unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.getUTCHours": "UTC-Stunden abrufen",
    "getUTCHours": "UTC-Stunden abrufen",
    "bitbybit.dates.getUTCHours_description": "Ruft den Stundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.getUTCMinutes": "UTC-Minuten abrufen",
    "getUTCMinutes": "UTC-Minuten abrufen",
    "bitbybit.dates.getUTCMinutes_description": "Ruft die Minuten eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.getUTCSeconds": "UTC-Sekunden abrufen",
    "getUTCSeconds": "UTC-Sekunden abrufen",
    "bitbybit.dates.getUTCSeconds_description": "Ruft die Sekunden eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.getUTCMilliseconds": "UTC-Millisekunden abrufen",
    "getUTCMilliseconds": "UTC-Millisekunden abrufen",
    "bitbybit.dates.getUTCMilliseconds_description": "Ruft die Millisekunden eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC) ab.",
    "bitbybit.dates.setYear": "Jahr setzen",
    "setYear": "Jahr setzen",
    "bitbybit.dates.setYear_description": "Setzt das Jahr eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setMonth": "Monat setzen",
    "setMonth": "Monat setzen",
    "bitbybit.dates.setMonth_description": "Setzt den Monatswert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setDayOfMonth": "Tag des Monats setzen",
    "setDayOfMonth": "Tag des Monats setzen",
    "bitbybit.dates.setDayOfMonth_description": "Setzt den numerischen Tag-des-Monats-Wert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setHours": "Stunden setzen",
    "setHours": "Stunden setzen",
    "bitbybit.dates.setHours_description": "Setzt den Stundenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setMinutes": "Minuten setzen",
    "setMinutes": "Minuten setzen",
    "bitbybit.dates.setMinutes_description": "Setzt den Minutenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setSeconds": "Sekunden setzen",
    "setSeconds": "Sekunden setzen",
    "bitbybit.dates.setSeconds_description": "Setzt den Sekundenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setMilliseconds": "Millisekunden setzen",
    "setMilliseconds": "Millisekunden setzen",
    "bitbybit.dates.setMilliseconds_description": "Setzt den Millisekundenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setTime": "Zeit setzen",
    "setTime": "Zeit setzen",
    "bitbybit.dates.setTime_description": "Setzt den Datums- und Zeitwert eines Datumsobjekts.",
    "time": "Zeit",
    "bitbybit.dates.setUTCYear": "UTC-Jahr setzen",
    "setUTCYear": "UTC-Jahr setzen",
    "bitbybit.dates.setUTCYear_description": "Setzt den Jahreswert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMonth": "UTC-Monat setzen",
    "setUTCMonth": "UTC-Monat setzen",
    "bitbybit.dates.setUTCMonth_description": "Setzt den Monatswert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCDay": "UTC-Tag setzen",
    "setUTCDay": "UTC-Tag setzen",
    "bitbybit.dates.setUTCDay_description": "Setzt den numerischen Tag des Monats eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCHours": "UTC-Stunden setzen",
    "setUTCHours": "UTC-Stunden setzen",
    "bitbybit.dates.setUTCHours_description": "Setzt den Stundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMinutes": "UTC-Minuten setzen",
    "setUTCMinutes": "UTC-Minuten setzen",
    "bitbybit.dates.setUTCMinutes_description": "Setzt den Minutenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCSeconds": "UTC-Sekunden setzen",
    "setUTCSeconds": "UTC-Sekunden setzen",
    "bitbybit.dates.setUTCSeconds_description": "Setzt den Sekundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "UTC-Millisekunden setzen",
    "setUTCMilliseconds": "UTC-Millisekunden setzen",
    "bitbybit.dates.setUTCMilliseconds_description": "Setzt den Millisekundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.json.stringify": "stringifizieren",
    "json": "JSON",
    "stringify": "stringifizieren",
    "bitbybit.json.stringify_description": "stringifiziert den Eingabewert",
    "bitbybit.json.parse": "parsen",
    "bitbybit.json.parse_description": "parst den Eingabewert",
    "bitbybit.json.query": "abfragen",
    "query": "abfragen",
    "bitbybit.json.query_description": "fragt den Eingabewert ab",
    "jsonpath": "JSON-Pfad",
    "bitbybit.json.setValueOnProp": "Wert auf Eigenschaft setzen",
    "setValueOnProp": "Wert auf Eigenschaft setzen",
    "bitbybit.json.setValueOnProp_description": "setzt einen Wert auf eine JSON-Eigenschaft",
    "props": "Eigenschaften",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "JSON aus Array nach erstem Eigenschaftsübereinstimmung abrufen",
    "getJsonFromArrayByFirstPropMatch": "JSON aus Array nach erstem Eigenschaftsübereinstimmung abrufen",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "ruft JSON aus einem Array nach der ersten Eigenschaftsübereinstimmung ab",
    "jsonArray": "JSON-Array",
    "any[]": "beliebiges Array",
    "match": "Übereinstimmung",
    "bitbybit.json.getValueOnProp": "Wert von Eigenschaft abrufen",
    "getValueOnProp": "Wert von Eigenschaft abrufen",
    "bitbybit.json.getValueOnProp_description": "ruft den Wert einer Eigenschaft in JSON ab",
    "bitbybit.json.setValue": "Wert setzen",
    "bitbybit.json.setValue_description": "setzt einen Wert in JSON nach Pfad",
    "prop": "Eigenschaft",
    "bitbybit.json.setValuesOnPaths": "Werte auf Pfade setzen",
    "setValuesOnPaths": "Werte auf Pfade setzen",
    "bitbybit.json.setValuesOnPaths_description": "setzt mehrere Werte in JSON nach Pfaden",
    "paths": "Pfade",
    "bitbybit.json.paths": "Pfade",
    "bitbybit.json.paths_description": "findet Pfade zu Elementen in einem Objekt",
    "bitbybit.json.createEmpty": "leer",
    "bitbybit.json.createEmpty_description": "erstellt ein leeres JavaScript-Objekt",
    "bitbybit.json.previewAndSaveJson": "JSON-Vorschau und Speichern",
    "previewAndSaveJson": "JSON-Vorschau und Speichern",
    "bitbybit.json.previewAndSaveJson_description": "zeigt eine Vorschau von JSON und bietet eine Speicheroption",
    "preview": "Vorschau",
    "bitbybit.json.previewJson": "JSON-Vorschau",
    "previewJson": "JSON-Vorschau",
    "bitbybit.json.previewJson_description": "zeigt eine Vorschau von JSON",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "Kurve nach Knoten, Kontrollpunkten und Gewichten",
    "verb": "Verb",
    "createCurveByKnotsControlPointsWeights": "Kurve nach Knoten, Kontrollpunkten und Gewichten",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "erstellt eine NURBS-Kurve mit Knoten, Kontrollpunkten und Gewichten",
    "degree": "Grad",
    "knots": "Knoten",
    "bitbybit.verb.curve.createCurveByPoints": "Kurve nach Punkten",
    "createCurveByPoints": "Kurve nach Punkten",
    "bitbybit.verb.curve.createCurveByPoints_description": "erstellt eine NURBS-Kurve mit Kontrollpunkten",
    "bitbybit.verb.curve.createBezierCurve": "Bézier-Kurve",
    "createBezierCurve": "Bézier-Kurve",
    "bitbybit.verb.curve.createBezierCurve_description": "erstellt eine Bézier-NURBS-Kurve mit Kontrollpunkten und Gewichten",
    "bitbybit.verb.curve.clone": "klonen",
    "bitbybit.verb.curve.clone_description": "klont eine NURBS-Kurve",
    "bitbybit.verb.curve.closestParam": "nächster Parameter",
    "closestParam": "nächster Parameter",
    "bitbybit.verb.curve.closestParam_description": "findet den nächstgelegenen Parameter auf einer NURBS-Kurve von einem Punkt aus",
    "bitbybit.verb.curve.closestParams": "nächste Parameter",
    "closestParams": "nächste Parameter",
    "bitbybit.verb.curve.closestParams_description": "findet die nächstgelegenen Parameter auf einer NURBS-Kurve von Punkten aus",
    "bitbybit.verb.curve.closestPoint": "nächster Punkt",
    "closestPoint": "nächster Punkt",
    "bitbybit.verb.curve.closestPoint_description": "findet den nächstgelegenen Punkt auf einer NURBS-Kurve von einem Punkt aus",
    "bitbybit.verb.curve.closestPoints": "nächste Punkte",
    "closestPoints": "nächste Punkte",
    "bitbybit.verb.curve.closestPoints_description": "findet die nächstgelegenen Punkte auf einer NURBS-Kurve von Punkten aus",
    "bitbybit.verb.curve.controlPoints": "Kontrollpunkte",
    "controlPoints": "Kontrollpunkte",
    "bitbybit.verb.curve.controlPoints_description": "findet die Kontrollpunkte einer NURBS-Kurve",
    "bitbybit.verb.curve.degree": "Grad",
    "bitbybit.verb.curve.degree_description": "findet den Grad einer NURBS-Kurve",
    "bitbybit.verb.curve.derivatives": "Ableitungen",
    "derivatives": "Ableitungen",
    "bitbybit.verb.curve.derivatives_description": "findet die Ableitungen einer NURBS-Kurve an einem Parameter",
    "numDerivatives": "Anzahl Ableitungen",
    "parameter": "Parameter",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "durch gleiche Bogenlänge zu Parametern teilen",
    "divideByEqualArcLengthToParams": "durch gleiche Bogenlänge zu Parametern teilen",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "teilt eine Kurve durch gleiche Bogenlänge in Parameter",
    "subdivision": "Unterteilung",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "durch gleiche Bogenlänge zu Punkten teilen",
    "divideByEqualArcLengthToPoints": "durch gleiche Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "teilt eine Kurve durch gleiche Bogenlänge in Punkte",
    "bitbybit.verb.curve.divideByArcLengthToParams": "durch Bogenlänge zu Parametern teilen",
    "divideByArcLengthToParams": "durch Bogenlänge zu Parametern teilen",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "teilt eine Kurve durch Bogenlänge in Parameter",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "durch Bogenlänge zu Punkten teilen",
    "divideByArcLengthToPoints": "durch Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "teilt eine Kurve durch Bogenlänge in Punkte",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "Kurven durch gleiche Bogenlänge zu Punkten teilen",
    "divideCurvesByEqualArcLengthToPoints": "Kurven durch gleiche Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "teilt mehrere Kurven durch gleiche Bogenlänge in Punkte",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "Kurven durch Bogenlänge zu Punkten teilen",
    "divideCurvesByArcLengthToPoints": "Kurven durch Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "teilt mehrere Kurven durch Bogenlänge in Punkte",
    "bitbybit.verb.curve.domain": "Domäne",
    "bitbybit.verb.curve.domain_description": "findet das Domänenintervall der Kurvenparameter",
    "bitbybit.verb.curve.startPoint": "Startpunkt",
    "bitbybit.verb.curve.startPoint_description": "Startpunkt der Kurve",
    "bitbybit.verb.curve.endPoint": "Endpunkt",
    "bitbybit.verb.curve.endPoint_description": "Endpunkt der Kurve",
    "bitbybit.verb.curve.startPoints": "Startpunkte",
    "bitbybit.verb.curve.startPoints_description": "Startpunkte der Kurven",
    "bitbybit.verb.curve.endPoints": "Endpunkte",
    "bitbybit.verb.curve.endPoints_description": "Endpunkte der Kurven",
    "bitbybit.verb.curve.knots": "Knoten",
    "bitbybit.verb.curve.knots_description": "findet die Knoten einer NURBS-Kurve",
    "bitbybit.verb.curve.lengthAtParam": "Länge an Parameter",
    "lengthAtParam": "Länge an Parameter",
    "bitbybit.verb.curve.lengthAtParam_description": "ermittelt die Länge einer NURBS-Kurve an einem Parameter",
    "bitbybit.verb.curve.length": "Länge",
    "bitbybit.verb.curve.length_description": "ermittelt die Länge einer NURBS-Kurve",
    "bitbybit.verb.curve.paramAtLength": "Parameter an Länge",
    "paramAtLength": "Parameter an Länge",
    "bitbybit.verb.curve.paramAtLength_description": "ermittelt den Parameter an einer Länge auf einer NURBS-Kurve",
    "bitbybit.verb.curve.pointAtParam": "Punkt an Parameter",
    "pointAtParam": "Punkt an Parameter",
    "bitbybit.verb.curve.pointAtParam_description": "ermittelt den Punkt an einem Parameter auf einer NURBS-Kurve",
    "bitbybit.verb.curve.pointsAtParam": "Punkte an Parameter",
    "pointsAtParam": "Punkte an Parameter",
    "bitbybit.verb.curve.pointsAtParam_description": "ermittelt die Punkte an einem Parameter auf NURBS-Kurven",
    "bitbybit.verb.curve.reverse": "umkehren",
    "bitbybit.verb.curve.reverse_description": "kehrt eine NURBS-Kurve um",
    "bitbybit.verb.curve.split": "teilen",
    "bitbybit.verb.curve.split_description": "teilt eine NURBS-Kurve an einem Parameter",
    "bitbybit.verb.curve.tangent": "Tangente",
    "bitbybit.verb.curve.tangent_description": "Tangente einer NURBS-Kurve an einem Parameter",
    "bitbybit.verb.curve.tessellate": "tessellieren",
    "tessellate": "tessellieren",
    "bitbybit.verb.curve.tessellate_description": "tesselliert eine NURBS-Kurve in Punkte",
    "bitbybit.verb.curve.transform": "transformieren",
    "bitbybit.verb.curve.transform_description": "transformiert eine NURBS-Kurve",
    "bitbybit.verb.curve.transformCurves": "Kurven transformieren",
    "transformCurves": "Kurven transformieren",
    "bitbybit.verb.curve.transformCurves_description": "transformiert NURBS-Kurven",
    "bitbybit.verb.curve.weights": "Gewichte",
    "bitbybit.verb.curve.weights_description": "Gewichte einer NURBS-Kurve",
    "bitbybit.verb.curve.circle.createCircle": "Kreis",
    "createCircle": "Kreis",
    "bitbybit.verb.curve.circle.createCircle_description": "erstellt eine NURBS-Kreiskurve",
    "xAxis": "X-Achse",
    "yAxis": "Y-Achse",
    "bitbybit.verb.curve.circle.createArc": "Bogen",
    "createArc": "Bogen",
    "bitbybit.verb.curve.circle.createArc_description": "erstellt eine NURBS-Bogenkurve",
    "minAngle": "minimaler Winkel",
    "maxAngle": "maximaler Winkel",
    "bitbybit.verb.curve.circle.center": "Mittelpunkt",
    "bitbybit.verb.curve.circle.center_description": "ermittelt den Mittelpunkt eines Kreises oder Bogens",
    "bitbybit.verb.curve.circle.radius": "Radius",
    "bitbybit.verb.curve.circle.radius_description": "ermittelt den Radius eines Kreises oder Bogens",
    "bitbybit.verb.curve.circle.maxAngle": "maximaler Winkel",
    "bitbybit.verb.curve.circle.maxAngle_description": "ermittelt den maximalen Winkel eines Bogens in Grad",
    "bitbybit.verb.curve.circle.minAngle": "minimaler Winkel",
    "bitbybit.verb.curve.circle.minAngle_description": "ermittelt den minimalen Winkel eines Bogens in Grad",
    "bitbybit.verb.curve.circle.xAxis": "X-Achse",
    "bitbybit.verb.curve.circle.xAxis_description": "ermittelt den X-Winkel eines Bogens",
    "bitbybit.verb.curve.circle.yAxis": "Y-Achse",
    "bitbybit.verb.curve.circle.yAxis_description": "ermittelt den Y-Winkel eines Bogens",
    "bitbybit.verb.curve.ellipse.createEllipse": "Ellipse",
    "createEllipse": "Ellipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "erstellt eine NURBS-Ellipsenkurve",
    "bitbybit.verb.curve.ellipse.createArc": "Bogen",
    "bitbybit.verb.curve.ellipse.createArc_description": "erstellt eine NURBS-Ellipsenbogenkurve",
    "bitbybit.verb.curve.ellipse.center": "Mittelpunkt",
    "bitbybit.verb.curve.ellipse.center_description": "ermittelt den Mittelpunkt einer Ellipse oder eines Bogens",
    "bitbybit.verb.curve.ellipse.maxAngle": "maximaler Winkel",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "ermittelt den maximalen Winkel eines Bogens in Grad",
    "bitbybit.verb.curve.ellipse.minAngle": "minimaler Winkel",
    "bitbybit.verb.curve.ellipse.minAngle_description": "ermittelt den minimalen Winkel eines Bogens in Grad",
    "bitbybit.verb.curve.ellipse.xAxis": "X-Achse",
    "bitbybit.verb.curve.ellipse.xAxis_description": "ermittelt den X-Winkel einer Ellipse oder eines Bogens",
    "bitbybit.verb.curve.ellipse.yAxis": "Y-Achse",
    "bitbybit.verb.curve.ellipse.yAxis_description": "ermittelt den Y-Winkel einer Ellipse oder eines Bogens",
    "bitbybit.verb.surface.boundaries": "Grenzen",
    "boundaries": "Grenzen",
    "bitbybit.verb.surface.boundaries_description": "ermittelt die Randkanten-NURBS-Kurven einer Fläche",
    "bitbybit.verb.surface.createSurfaceByCorners": "Fläche nach Ecken",
    "createSurfaceByCorners": "Fläche nach Ecken",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "erstellt eine Fläche mit 4 Eckpunkten",
    "point3": "Punkt 3",
    "point4": "Punkt 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "Fläche nach Knoten, Kontrollpunkten und Gewichten",
    "createSurfaceByKnotsControlPointsWeights": "Fläche nach Knoten, Kontrollpunkten und Gewichten",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "erstellt eine NURBS-Fläche mit UV-Knoten, Graden, Punkten und Gewichten",
    "degreeU": "Grad U",
    "degreeV": "Grad V",
    "knotsU": "Knoten U",
    "knotsV": "Knoten V",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "Fläche durch Lofting-Kurven",
    "createSurfaceByLoftingCurves": "Fläche durch Lofting-Kurven",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "erstellt eine NURBS-Fläche durch Lofting von Kurven",
    "bitbybit.verb.surface.clone": "klonen",
    "bitbybit.verb.surface.clone_description": "klont eine NURBS-Fläche",
    "bitbybit.verb.surface.closestParam": "nächster Parameter",
    "bitbybit.verb.surface.closestParam_description": "findet den nächstgelegenen Parameter auf einer Fläche von einem Punkt aus",
    "bitbybit.verb.surface.closestPoint": "nächster Punkt",
    "bitbybit.verb.surface.closestPoint_description": "findet den nächstgelegenen Punkt auf einer Fläche von einem Punkt aus",
    "bitbybit.verb.surface.controlPoints": "Kontrollpunkte",
    "bitbybit.verb.surface.controlPoints_description": "ermittelt die Kontrollpunkte auf einer Fläche",
    "bitbybit.verb.surface.degreeU": "Grad U",
    "bitbybit.verb.surface.degreeU_description": "ermittelt den U-Grad einer Fläche",
    "bitbybit.verb.surface.degreeV": "Grad V",
    "bitbybit.verb.surface.degreeV_description": "ermittelt den V-Grad einer Fläche",
    "bitbybit.verb.surface.derivatives": "Ableitungen",
    "bitbybit.verb.surface.derivatives_description": "ermittelt die Ableitungen einer Fläche bei UV",
    "u": "U",
    "v": "V",
    "bitbybit.verb.surface.domainU": "Domäne U",
    "domainU": "Domäne U",
    "bitbybit.verb.surface.domainU_description": "ermittelt die U-Domäne einer Fläche",
    "bitbybit.verb.surface.domainV": "Domäne V",
    "domainV": "Domäne V",
    "bitbybit.verb.surface.domainV_description": "ermittelt die V-Domäne einer Fläche",
    "bitbybit.verb.surface.isocurve": "Isokurve",
    "isocurve": "Isokurve",
    "bitbybit.verb.surface.isocurve_description": "ermittelt die NURBS-Isokurve auf einer Fläche",
    "useV": "V verwenden",
    "bitbybit.verb.surface.isocurvesSubdivision": "Isokurven-Unterteilung",
    "isocurvesSubdivision": "Isokurven-Unterteilung",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "teilt eine Fläche in Isokurven auf",
    "isocurveSegments": "Isokurven-Segmente",
    "bitbybit.verb.surface.isocurvesAtParams": "Isokurven an Parametern",
    "isocurvesAtParams": "Isokurven an Parametern",
    "bitbybit.verb.surface.isocurvesAtParams_description": "teilt eine Fläche in Isokurven an Parametern auf",
    "parameters": "Parameter",
    "bitbybit.verb.surface.knotsU": "Knoten U",
    "bitbybit.verb.surface.knotsU_description": "ermittelt die U-Knoten einer Fläche",
    "bitbybit.verb.surface.knotsV": "Knoten V",
    "bitbybit.verb.surface.knotsV_description": "ermittelt die V-Knoten einer Fläche",
    "bitbybit.verb.surface.normal": "Normale",
    "bitbybit.verb.surface.normal_description": "ermittelt die Normale auf einer Fläche bei UV",
    "bitbybit.verb.surface.point": "Punkt",
    "bitbybit.verb.surface.point_description": "ermittelt den Punkt auf einer Fläche bei UV",
    "bitbybit.verb.surface.reverse": "umkehren",
    "bitbybit.verb.surface.reverse_description": "kehrt die UV- und Isokurven einer NURBS-Fläche um",
    "bitbybit.verb.surface.split": "teilen",
    "bitbybit.verb.surface.split_description": "teilt eine NURBS-Fläche in zwei",
    "bitbybit.verb.surface.transformSurface": "Fläche transformieren",
    "transformSurface": "Fläche transformieren",
    "bitbybit.verb.surface.transformSurface_description": "transformiert eine NURBS-Fläche mit Transformationen",
    "bitbybit.verb.surface.weights": "Gewichte",
    "bitbybit.verb.surface.weights_description": "ermittelt die Gewichte einer Fläche",
    "bitbybit.verb.surface.cone.create": "erstellen",
    "cone": "Kegel",
    "bitbybit.verb.surface.cone.create_description": "erstellt eine konische NURBS-Fläche",
    "bitbybit.verb.surface.cone.axis": "Achse",
    "bitbybit.verb.surface.cone.axis_description": "ermittelt die Achse des Kegels",
    "bitbybit.verb.surface.cone.base": "Basis",
    "bitbybit.verb.surface.cone.base_description": "ermittelt die Basis des Kegels",
    "bitbybit.verb.surface.cone.height": "Höhe",
    "bitbybit.verb.surface.cone.height_description": "ermittelt die Höhe des Kegels",
    "bitbybit.verb.surface.cone.radius": "Radius",
    "bitbybit.verb.surface.cone.radius_description": "ermittelt den Radius des Kegels",
    "bitbybit.verb.surface.cone.xAxis": "X-Achse",
    "bitbybit.verb.surface.cone.xAxis_description": "ermittelt die X-Achse des Kegels",
    "bitbybit.verb.surface.cylinder.create": "erstellen",
    "bitbybit.verb.surface.cylinder.create_description": "erstellt eine zylindrische NURBS-Fläche",
    "bitbybit.verb.surface.cylinder.axis": "Achse",
    "bitbybit.verb.surface.cylinder.axis_description": "ermittelt die Achse des Zylinders",
    "bitbybit.verb.surface.cylinder.base": "Basis",
    "bitbybit.verb.surface.cylinder.base_description": "ermittelt die Basis des Zylinders",
    "bitbybit.verb.surface.cylinder.height": "Höhe",
    "bitbybit.verb.surface.cylinder.height_description": "ermittelt die Höhe des Zylinders",
    "bitbybit.verb.surface.cylinder.radius": "Radius",
    "bitbybit.verb.surface.cylinder.radius_description": "ermittelt den Radius des Zylinders",
    "bitbybit.verb.surface.cylinder.xAxis": "X-Achse",
    "bitbybit.verb.surface.cylinder.xAxis_description": "ermittelt die X-Achse des Zylinders",
    "bitbybit.verb.surface.extrusion.create": "erstellen",
    "extrusion": "Extrusion",
    "bitbybit.verb.surface.extrusion.create_description": "erstellt eine NURBS-Flächenextrusion aus einer Kurve",
    "profile": "Profil",
    "bitbybit.verb.surface.extrusion.direction": "Richtung",
    "bitbybit.verb.surface.extrusion.direction_description": "ermittelt den Richtungsvektor der Extrusion",
    "bitbybit.verb.surface.extrusion.profile": "Profil",
    "bitbybit.verb.surface.extrusion.profile_description": "ermittelt die Profil-NURBS-Kurve der Extrusion",
    "bitbybit.verb.surface.sphere.create": "erstellen",
    "bitbybit.verb.surface.sphere.create_description": "erstellt eine sphärische NURBS-Fläche",
    "bitbybit.verb.surface.sphere.radius": "Radius",
    "bitbybit.verb.surface.sphere.radius_description": "ermittelt den Radius der sphärischen NURBS-Fläche",
    "bitbybit.verb.surface.sphere.center": "Mittelpunkt",
    "bitbybit.verb.surface.sphere.center_description": "ermittelt den Mittelpunkt der sphärischen NURBS-Fläche",
    "bitbybit.verb.surface.revolved.create": "erstellen",
    "revolved": "rotierend",
    "bitbybit.verb.surface.revolved.create_description": "erstellt eine rotierte NURBS-Fläche",
    "bitbybit.verb.surface.revolved.profile": "Profil",
    "bitbybit.verb.surface.revolved.profile_description": "ermittelt die Profil-NURBS-Kurve der rotierten Fläche",
    "revolution": "Rotation",
    "bitbybit.verb.surface.revolved.center": "Mittelpunkt",
    "bitbybit.verb.surface.revolved.center_description": "ermittelt den Mittelpunkt der NURBS-Kurve der rotierten Fläche",
    "bitbybit.verb.surface.revolved.axis": "Achse",
    "bitbybit.verb.surface.revolved.axis_description": "ermittelt die Rotationsachse der rotierten Fläche",
    "bitbybit.verb.surface.revolved.angle": "Winkel",
    "bitbybit.verb.surface.revolved.angle_description": "ermittelt den Rotationswinkel der rotierten Fläche",
    "bitbybit.verb.surface.sweep.create": "erstellen",
    "sweep": "Schwenk",
    "bitbybit.verb.surface.sweep.create_description": "erstellt eine geschwenkte NURBS-Fläche",
    "rail": "Schiene",
    "bitbybit.verb.surface.sweep.profile": "Profil",
    "bitbybit.verb.surface.sweep.profile_description": "ermittelt die Profil-NURBS-Kurve der geschwenkten Fläche",
    "bitbybit.verb.surface.sweep.rail": "Schiene",
    "bitbybit.verb.surface.sweep.rail_description": "ermittelt die Schienen-NURBS-Kurve der geschwenkten Fläche",
    "bitbybit.verb.intersect.curves": "Kurven",
    "bitbybit.verb.intersect.curves_description": "schneidet zwei Verb-NURBS-Kurven",
    "firstCurve": "erste Kurve",
    "secondCurve": "zweite Kurve",
    "bitbybit.verb.intersect.curveAndSurface": "Kurve und Fläche",
    "curveAndSurface": "Kurve und Fläche",
    "bitbybit.verb.intersect.curveAndSurface_description": "schneidet eine Kurve und eine Fläche",
    "bitbybit.verb.intersect.surfaces": "Flächen",
    "bitbybit.verb.intersect.surfaces_description": "schneidet zwei Flächen",
    "firstSurface": "erste Fläche",
    "secondSurface": "zweite Fläche",
    "bitbybit.verb.intersect.curveCurveFirstParams": "Kurve-Kurve erste Parameter",
    "curveCurveFirstParams": "Kurve-Kurve erste Parameter",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "ermittelt die Schnittparameter auf der ersten Kurve",
    "intersections": "Schnittpunkte",
    "BaseTypes.CurveCurveIntersection[]": "Basis-Typen Kurve-Kurve-Schnitt-Array",
    "bitbybit.verb.intersect.curveCurveSecondParams": "Kurve-Kurve zweite Parameter",
    "curveCurveSecondParams": "Kurve-Kurve zweite Parameter",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "ermittelt die Schnittparameter auf der zweiten Kurve",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "Kurve-Kurve erste Punkte",
    "curveCurveFirstPoints": "Kurve-Kurve erste Punkte",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "ermittelt die Schnittpunkte auf der ersten Kurve",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "Kurve-Kurve zweite Punkte",
    "curveCurveSecondPoints": "Kurve-Kurve zweite Punkte",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "ermittelt die Schnittpunkte auf der zweiten Kurve",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "Kurve-Fläche Kurvenparameter",
    "curveSurfaceCurveParams": "Kurve-Fläche Kurvenparameter",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "ermittelt die Schnittparameter auf der Kurve",
    "BaseTypes.CurveSurfaceIntersection[]": "Basis-Typen Kurve-Fläche-Schnitt-Array",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "Kurve-Fläche Flächenparameter",
    "curveSurfaceSurfaceParams": "Kurve-Fläche Flächenparameter",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "ermittelt die Schnittparameter auf der Fläche",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "Kurve-Fläche Kurvenpunkte",
    "curveSurfaceCurvePoints": "Kurve-Fläche Kurvenpunkte",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "ermittelt die Schnittpunkte auf der Kurve",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "Kurve-Fläche Flächenpunkte",
    "curveSurfaceSurfacePoints": "Kurve-Fläche Flächenpunkte",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "ermittelt die Schnittpunkte auf der Fläche",
    "bitbybit.tag.create": "erstellen",
    "tag": "Tag",
    "bitbybit.tag.create_description": "erstellt ein Tag-DTO",
    "adaptDepth": "Tiefe anpassen",
    "needsUpdate": "muss aktualisiert werden",
    "bitbybit.time.registerRenderFunction": "Render-Funktion registrieren",
    "registerRenderFunction": "Render-Funktion registrieren",
    "bitbybit.time.registerRenderFunction_description": "registriert eine Funktion für die Render-Schleife",
    "bitbybit.asset.getFile": "Datei abrufen",
    "asset": "Asset",
    "getFile": "Datei abrufen",
    "bitbybit.asset.getFile_description": "ruft eine Asset-Datei ab",
    "bitbybit.asset.getLocalFile": "lokale Datei abrufen",
    "getLocalFile": "lokale Datei abrufen",
    "bitbybit.asset.getLocalFile_description": "ruft eine lokale Asset-Datei aus dem Browser ab",
    "bitbybit.asset.fetchBlob": "Blob abrufen",
    "fetchBlob": "Blob abrufen",
    "bitbybit.asset.fetchBlob_description": "holt einen Blob von einer CORS-URL",
    "fetch": "abrufen",
    "bitbybit.asset.fetchFile": "Datei abrufen",
    "fetchFile": "Datei abrufen",
    "bitbybit.asset.fetchFile_description": "holt eine Datei von einer CORS-URL",
    "bitbybit.asset.fetchJSON": "JSON abrufen",
    "fetchJSON": "JSON abrufen",
    "bitbybit.asset.fetchJSON_description": "holt JSON von einer CORS-URL",
    "bitbybit.asset.fetchText": "Text abrufen",
    "fetchText": "Text abrufen",
    "bitbybit.asset.fetchText_description": "holt Text von einer CORS-URL",
    "bitbybit.asset.createObjectURL": "Objekt-URL",
    "createObjectURL": "Objekt-URL",
    "bitbybit.asset.createObjectURL_description": "erstellt eine URL zu einer Datei im Speicher",
    "file": "Datei",
    "File | Blob": "Datei oder Blob",
    "bitbybit.asset.createObjectURLs": "Objekt-URLs",
    "createObjectURLs": "Objekt-URLs",
    "bitbybit.asset.createObjectURLs_description": "erstellt URLs zu Dateien im Speicher",
    "files": "Dateien",
    "(File | Blob)[]": "Datei- oder Blob-Array",
    "exec": "ausführen",
    "Visible": "Sichtbar",
    "Hidden": "Versteckt",
    "flatten": "flatten",
    "force exec": "erzwinge Ausführung",
    "console log": "Konsolenprotokoll",
    "preview data": "Daten-Vorschau",
    "flow": "Ablauf",
    "code": "Code",
    "runner": "Runner",
    "counters": "Zähler",
    "actions": "Aktionen",
    "loops": "Schleifen",
    "interval": "Intervall",
    "delay": "Verzögerung",
    "expire": "ablaufen",
    "timeout": "Timeout",
    "counter min max": "Zähler Min Max",
    "counter steps": "Zähler Schritte",
    "reset": "zurücksetzen",
    "trigger": "auslösen",
    "mouse": "Maus",
    "mouse click": "Mausklick",
    "key": "Taste",
    "pointer": "Zeiger",
    "pick info": "Auswahl-Info",
    "down": "unten",
    "wheel": "Rad",
    "tap": "Tippen",
    "double tap": "Doppeltippen",
    "render": "rendern",
    "passed ms": "vergangene ms",
    "babylon observable listener": "Babylon Observable Listener",
    "object": "Objekt",
    "observable selector": "Observable-Auswahl",
    "get event data": "Ereignisdaten abrufen",
    "exec click": "Klick ausführen",
    "exec down": "unten ausführen",
    "toggle": "umschalten",
    "flip flop": "Flip-Flop",
    "boolean gate": "Boolean-Gatter",
    "boolean gate silent": "stilles Boolean-Gatter",
    "is undefined": "ist undefiniert",
    "for loop": "For-Schleife",
    "last": "letzte",
    "for each loop": "For-Each-Schleife",
    "element": "Element",
    "body": "Körper",
    "complete": "abgeschlossen",
    "editors": "Editoren",
    "inputs": "Eingaben",
    "outputs": "Ausgaben",
    "recent": "kürzlich",
    "Clear": "Löschen",
    "Run": "Ausführen",
    "Swap Canvas": "Canvas tauschen",
    "Local Assets": "Lokale Assets",
    "Import": "Importieren",
    "Copy to Clipboard": "In die Zwischenablage kopieren",
    "Paste from Clipboard": "Aus der Zwischenablage einfügen",
    "Export": "Exportieren",
    "Export to runner": "Zum Runner exportieren",
    "Clean Cache": "Cache bereinigen",
    "Community": "Gemeinschaft",
    "Sponsors and Partners": "Sponsoren und Partner",
    "API Documentation": "API-Dokumentation",
    "About": "Über",
    "Toolbox": "Werkzeugkasten",
    "More": "Mehr",
    "bitbybit.code.typeScriptEditor": "TypeScript-Editor",
    "bitbybit.code.typeScriptEditor_description": "Ermöglicht das Schreiben von TypeScript-Code mit vollständiger Bitbybit-Intellisense in einer Funktion. Was die Startfunktion zurückgibt, wird als Ausgabe der Komponente betrachtet.",
    "bitbybit.code.javaScriptEditor": "JavaScript-Editor",
    "bitbybit.code.javaScriptEditor_description": "Ermöglicht das Schreiben von JavaScript-Code in einer Funktion. Was die Startfunktion zurückgibt, wird als Ausgabe der Komponente betrachtet.",
    "bitbybit.code.jsonEditor": "JSON-Editor",
    "bitbybit.code.jsonEditor_description": "Ermöglicht das Schreiben von JSON-Code. Was die Startfunktion zurückgibt, wird als Ausgabe der Komponente betrachtet.",
    "bitbybit.flow.actions.keyboard": "Tastatur",
    "bitbybit.flow.actions.keyboard_description": "Wird bei Tastaturereignissen durch Klicken auf die Schaltflächen ausgeführt.",
    "bitbybit.flow.actions.mouseClick": "Mausklick",
    "bitbybit.flow.actions.mouseClick_description": "Wird bei Mausereignissen durch Klicken auf die Schaltflächen ausgeführt.",
    "bitbybit.flow.actions.start": "Start",
    "bitbybit.flow.actions.start_description": "Startet den Kontrollfluss und löst Ausführungen aus.",
    "bitbybit.flow.actions.trigger": "Auslösen",
    "bitbybit.flow.actions.trigger_description": "Löst die Ausführung durch Klicken auf die Schaltfläche aus.",
    "bitbybit.flow.babylon.gui.button": "Schaltfläche",
    "bitbybit.flow.babylon.gui.button_description": "Wird bei verschiedenen Zeigerereignissen durch Klicken mit der linken Maustaste auf die BabylonJS-Canvas ausgeführt.",
    "bitbybit.flow.babylon.scene.pointerEvents": "Zeiger",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Wird bei verschiedenen Zeigerereignissen durch Klicken mit der linken Maustaste auf die BabylonJS-Canvas ausgeführt.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "Ereignisdaten abrufen",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Ruft Ereignisdaten aus dem beobachteten Ergebnis des Observable-Listeners ab.",
    "bitbybit.flow.babylon.observableListener": "Babylon Observable Listener",
    "bitbybit.flow.babylon.observableListener_description": "Abonniert und lauscht auf beliebige BabylonJS-Observables.",
    "bitbybit.flow.babylon.render": "Rendern",
    "bitbybit.flow.babylon.render_description": "Wird bei jedem BabylonJS-Render-Frame ausgeführt.",
    "bitbybit.flow.counters.counterMinMax": "Zähler Min Max",
    "bitbybit.flow.counters.counterMinMax_description": "Zählt die Anzahl der Flussausführungen zwischen Min- und Max-Werten. Bei Erreichen von Max wird zurückgesetzt.",
    "bitbybit.flow.counters.counterSteps": "Zähler Schritte",
    "bitbybit.flow.counters.counterSteps_description": "Zählt die Anzahl der Flussausführungen, beginnend bei einem gegebenen Zählwert und erhöht sich bei jeder Ausführung um einen gegebenen Schritt aus der Liste, bis die Schritte abgeschlossen sind. Am Ende wird zurückgesetzt.",
    "bitbybit.flow.counters.counter": "Zähler",
    "bitbybit.flow.counters.counter_description": "Zählt die Anzahl der Flussausführungen.",
    "bitbybit.flow.logic.booleanGateSilent": "stilles Boolean-Gatter",
    "bitbybit.flow.logic.booleanGateSilent_description": "Löst unterschiedliche Ausführungsereignisse basierend auf dem bereitgestellten Boolean-Wert aus, führt jedoch nur aus, wenn sich der Boolean-Wert ändert, um mehrfaches Auslösen von Ereignissen zu verhindern, obwohl keine Änderung stattgefunden hat.",
    "bitbybit.flow.logic.booleanGate": "Boolean-Gatter",
    "bitbybit.flow.logic.booleanGate_description": "Löst unterschiedliche Ausführungsereignisse basierend auf dem bereitgestellten Boolean-Wert aus.",
    "bitbybit.flow.logic.flipFlop": "Flip-Flop",
    "bitbybit.flow.logic.flipFlop_description": "Bei jedem ausgeführten Ereignis wird ein anderes Ereignis ausgelöst, wodurch im Wesentlichen eine Umschaltfunktion erstellt wird.",
    "bitbybit.flow.logic.isUndefined": "ist undefiniert",
    "bitbybit.flow.logic.isUndefined_description": "Prüft, ob der bereitgestellte Wert undefiniert ist und löst ein wahr- oder falsch-Ereignis aus.",
    "bitbybit.flow.loops.forEach": "For-Each-Schleife",
    "bitbybit.flow.loops.forEach_description": "For-Each-Schleife, die alle Elemente in der Liste durchläuft.",
    "bitbybit.flow.loops.for": "For-Schleife",
    "bitbybit.flow.loops.for_description": "For-Schleife, die den Körper zwischen zwei Werten ausführt.",
    "bitbybit.flow.time.delay": "Verzögerung",
    "bitbybit.flow.time.delay_description": "Verzögert die Ausführung um den angegebenen Timeout in Millisekunden.",
    "bitbybit.flow.time.interval": "Intervall",
    "bitbybit.flow.time.interval_description": "Führt den Fluss in jedem angegebenen Intervall in Millisekunden aus.",
    "bitbybit.lists.createList": "Liste erstellen",
    "bitbybit.lists.createList_description": "Erstellt eine Liste aus den gegebenen Elementen.",
    "bitbybit.lists.flatten": "flatten",
    "bitbybit.lists.flatten_description": "Flacht die Liste von Listen in eine einzige Liste ab.",
    "bitbybit.lists.passThrough": "durchlaufen",
    "bitbybit.lists.passThrough_description": "Wandelt den Wert in den Typ 'any' um und leitet die Eingabe unverändert an die Ausgabe weiter.",
    "bitbybit.math.numberSlider": "Zahlenschieberegler",
    "bitbybit.math.numberSlider_description": "Erstellt eine Zahl mit einem Schieberegler. Sie können Min-, Max- und Schrittwerte festlegen.",
    "bitbybit.consoleLog": "Konsolenprotokoll",
    "bitbybit.consoleLog_description": "Protokolliert die Eingabe in der Browser-Konsole.",
    "bitbybit.previewData": "Daten-Vorschau",
    "bitbybit.previewData_description": "Zeigt die Eingabedaten in einem Vorschauübersichtsbereich an. Es können Texte, Zahlen, JSON-Objekte, Arrays usw. sein. Zirkuläre JavaScript-Objekte sind nicht erlaubt.",
    "bitbybit.runner.getRunnerInputValue": "Runner-Eingabewert abrufen",
    "bitbybit.runner.getRunnerInputValue_description": "Ruft den Runner-Eingabewert aus dem Eingabe-JSON ab. Diese Komponente gibt im Editor-Kontext immer einen undefinierten Wert zurück.",
    "bitbybit.runner.getRunnerInputs": "Runner-Eingaben abrufen",
    "bitbybit.runner.getRunnerInputs_description": "Ruft die Runner-Eingaben in JSON ab. Diese Komponente gibt im Editor-Kontext immer ein leeres Objekt zurück.",
    "bitbybit.runner.run": "ausführen",
    "bitbybit.runner.run_description": "Führt Runner-JavaScript-Code aus",
    "bitbybit.runner.setRunnerResult": "Runner-Ergebnis setzen",
    "bitbybit.runner.setRunnerResult_description": "Setzt das vollständige JSON-Ergebnis für den Runner. Beachten Sie, dass es sicherer ist, Werte zu setzen, da diese Methode das gesamte Ergebnisobjekt mit dem bereitgestellten Wert überschreibt.",
    "bitbybit.runner.setRunnerResultArrayValue": "Runner-Ergebnis-Array-Wert setzen",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Setzt den Runner-Ergebniswert auf die Eigenschaft eines JSON-Objekts. Jeder Wert wird zu einem Array hinzugefügt, das der Wert der Eigenschaft ist.",
    "bitbybit.runner.setRunnerResultValue": "Runner-Ergebniswert setzen",
    "bitbybit.runner.setRunnerResultValue_description": "Setzt den Runner-Ergebniswert auf die Eigenschaft eines JSON-Objekts.",
    "bitbybit.text.areaCreate": "Textbereich",
    "bitbybit.text.areaCreate_description": "Erstellt einen Textbereich im Editor. Sie können den Text, die Breite und die Höhe des Bereichs festlegen.",
    "update on drag": "bei Ziehen aktualisieren",
    "paste": "einfügen",
    "duplicate": "duplizieren",
    "delete": "löschen",
    "keyboard": "Tastatur",
    "data": "Daten",
    "observables": "Observables",
    "buttons": "Schaltflächen",
    "variables": "Variablen",
    "functions": "Funktionen",
    "loop": "Schleife",
    "apply": "anwenden",
    "async context": "asynchroner Kontext",
    "async context description": "Erstellt einen asynchronen Kontext, der Await-Komponenten verwenden kann, was die Ausführung und Lesbarkeit von asynchronem Code vereinfacht.",
    "then": "dann",
    "await": "warten",
    "await description": "Wartet, bis das Promise aufgelöst ist, und gibt den Wert zurück.",
    "when the": "wenn das",
    "error": "Fehler",
    "happens in the promise": "im Promise auftritt",
    "catch": "fangen",
    "catch description": "Fängt Fehler ab, die bei der Ausführung von asynchronem Code auftreten können. Der Benutzer kann Fehler entsprechend behandeln.",
    "cancel the interval execution": "Intervallausführung abbrechen",
    "cancel the interval description": "Bricht die Intervallausführung ab, indem der Handler bereitgestellt wird.",
    "cancel the timeout execution": "Timeout-Ausführung abbrechen",
    "cancel the timeout description": "Bricht die Timeout-Ausführung ab, indem der Handler bereitgestellt wird.",
    "key down": "Taste gedrückt",
    "key down descritpion": "Löst Code aus, wenn das Ereignis 'Taste gedrückt' eintritt.",
    "key up": "Taste losgelassen",
    "key up description": "Löst Code aus, wenn das Ereignis 'Taste losgelassen' eintritt.",
    "key press": "Tastendruck",
    "key press description": "Löst Code aus, wenn das Ereignis 'Tastendruck' eintritt.",
    "is key pressed": "ist Taste gedrückt",
    "block_validation_required": "muss angegeben werden",
    "block_validation_of_length": "muss die Anzahl der Elemente enthalten",
    "block_validation_higher_or_equal": "muss größer oder gleich sein",
    "block_validation_lower_or_equal": "muss kleiner oder gleich sein",
    "block_validation_range": "muss im Bereich liegen",
    "block_validation_smaller_than": "muss kleiner sein als",
    "block_validation_smaller_or_equal_than": "muss kleiner oder gleich sein als",
    "block_validation_larger_than": "muss größer sein als",
    "block_validation_larger_or_equal_than": "muss größer oder gleich sein als",
    "save text to file": "Text in Datei speichern",
    "save text to file description": "Speichert Text in eine Datei und ermöglicht es Ihnen, den Namen und die Erweiterung zu wählen. Diese Komponente zeigt den Text nicht in der Vorschau an und kann in Situationen verwendet werden, in denen der Text zu groß ist, um im Textbereichsfeld bearbeitet zu werden.",
    "print text on screen": "Text auf Bildschirm ausgeben",
    "print text on screen description": "Gibt Text auf dem Bildschirm aus. Diese Komponente ist nützlich für Debugging-Zwecke.",
    "preview text and save to file": "Text-Vorschau und in Datei speichern",
    "preview text and save to file description": "Gibt Text auf dem Bildschirm aus und ermöglicht es Ihnen, ihn in eine Datei zu speichern. Diese Komponente ist nützlich für Debugging-Zwecke.",
    "register render loop listener": "Render-Schleifen-Listener registrieren",
    "and update": "und aktualisieren",
    "register render loop listener description": "Führt die Anweisung in der Render-Schleife aus und gibt an, wie viel Zeit seit dem letzten Frame in der Variable timeElapsedFromPreviousFrame vergangen ist.",
    "timeElapsedFromPreviousFrame_var": "zeitSeitVorherigemFrame",
    "computing": "Berechnung",
    "result": "Ergebnis",
    "of promise is returned": "des Promise wird zurückgegeben",
    "on pointer up": "bei Zeiger hoch",
    "on pointer move": "bei Zeigerbewegung",
    "on pointer down": "bei Zeiger runter",
    "of babylonjs observable object": "des BabylonJS Observable-Objekts",
    "observable name": "Observable-Name",
    "is key pressed description": "Prüft, ob die Taste gedrückt ist, und gibt wahr oder falsch zurück.",
    "execute code after": "Code ausführen nach",
    "execute code after description": "Führt den Code nach dem angegebenen Timeout in Sekunden aus.",
    "execute code every": "Code ausführen alle",
    "second(s)": "Sekunde(n)",
    "execute code every description": "Führt den Code in jedem angegebenen Intervall in Sekunden aus.",
    "handler": "Handler",
    "workers initialising": "Worker initialisieren",
    "Assets": "Assets",
    "Local assets stored in browser cache:": "Lokale Assets im Browser-Cache gespeichert:",
    "Asset Name": "Asset-Name",
    "Name is required": "Name ist erforderlich",
    "Asset with this name already exists, choose a different one": "Asset mit diesem Namen existiert bereits, wählen Sie einen anderen",
    "Allowed file formats:": "Erlaubte Dateiformate:",
    "You must select an asset file": "Sie müssen eine Asset-Datei auswählen",
    "Upload Local Asset": "Lokales Asset hochladen",
    "File Name": "Dateiname",
    "File Size": "Dateigröße",
    "Your browser does not support indexDB and you can't upload local asset files.": "Ihr Browser unterstützt kein IndexDB und Sie können keine lokalen Asset-Dateien hochladen.",
    "Upload": "Hochladen",
    "elements": "Elemente",
    "bitbybit.vector.vectorsTheSame": "Vektoren gleich",
    "vectorsTheSame": "Vektoren gleich",
    "bitbybit.vector.vectorsTheSame_description": "Prüft, ob zwei Vektoren innerhalb einer gegebenen Toleranz gleich sind",
    "vec1": "Vektor 1",
    "vec2": "Vektor 2",
    "bitbybit.point.boundingBoxOfPoints": "Begrenzungsrahmen der Punkte",
    "boundingBoxOfPoints": "Begrenzungsrahmen der Punkte",
    "bitbybit.point.boundingBoxOfPoints_description": "Ermittelt einen Begrenzungsrahmen der Punkte",
    "bitbybit.point.normalFromThreePoints": "Normale aus drei Punkten",
    "normalFromThreePoints": "Normale aus drei Punkten",
    "bitbybit.point.normalFromThreePoints_description": "Erstellt einen Normalenvektor aus 3 Punkten",
    "reverseNormal": "umgekehrte Normale",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "Linienzug mit Verlängerungen",
    "createLineWireWithExtensions": "Linienzug mit Verlängerungen",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Erstellt einen OpenCascade Linienzug mit Verlängerungen",
    "extensionStart": "Verlängerungsstart",
    "extensionEnd": "Verlängerungsende",
    "bitbybit.occt.shapes.wire.midPointOnWire": "Mittelpunkt auf Linienzug",
    "midPointOnWire": "Mittelpunkt auf Linienzug",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Berechnet den Mittelpunkt auf dem Linienzug beim Parameter 0.5",
    "centerOnOrigin": "Im Ursprung zentrieren",
    "bitbybit.occt.shapes.wire.textWiresWithData": "Text-Linienzüge mit Daten",
    "textWiresWithData": "Text-Linienzüge mit Daten",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Erstellt ein OpenCascade Kompositum aus Text-Linienzügen und liefert zusätzliche Informationen basierend auf der von Dr. A. V. Hershey erstellten Simplex-Schriftart",
    "bitbybit.occt.transforms.alignNormAndAxis": "Normale und Achse ausrichten",
    "alignNormAndAxis": "Normale und Achse ausrichten",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Richtet die Form an Normale und Achse aus",
    "fromNorm": "Von Normale",
    "fromAx": "Von Achse",
    "toNorm": "Zu Normale",
    "toAx": "Zu Achse",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "einfache lineare Längenbemaßung",
    "simpleLinearLengthDimension": "einfache lineare Längenbemaßung",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Erstellt eine einfache lineare Längenbemaßung zwischen zwei Punkten - Maßeinheiten",
    "offsetFromPoints": "Versatz von Punkten",
    "crossingSize": "Kreuzungsgröße",
    "labelSuffix": "Beschriftungssuffix",
    "labelSize": "Beschriftungsgröße",
    "labelOffset": "Beschriftungsversatz",
    "bitbybit.occt.dimensions.simpleAngularDimension": "einfache Winkelbemaßung",
    "simpleAngularDimension": "einfache Winkelbemaßung",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Erstellt eine einfache Winkelbemaßung. Standardmäßig werden Grad ausgegeben, Sie können sich aber auch für die Verwendung von Radiant entscheiden.",
    "direction1": "Richtung 1",
    "direction2": "Richtung 2",
    "offsetFromCenter": "Versatz vom Mittelpunkt",
    "extraSize": "Zusätzliche Größe",
    "radians": "Radiant",
    "bitbybit.occt.dimensions.pinWithLabel": "Pin mit Beschriftung",
    "pinWithLabel": "Pin mit Beschriftung",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Erstellt einen Pin mit Beschriftung. Dieser kann verwendet werden, um Sachverhalte an den Modellen zu erklären oder wichtige Punkte in der 3D-Szene zu markieren.",
    "offsetFromStart": "Versatz vom Startpunkt",
    "bitbybit.vector.lengthSq": "Länge zum Quadrat",
    "lengthSq": "Länge zum Quadrat",
    "bitbybit.vector.lengthSq_description": "Berechnet die quadrierte Länge des Vektors",
    "bitbybit.point.twoPointsAlmostEqual": "zwei Punkte gleich",
    "twoPointsAlmostEqual": "zwei Punkte gleich",
    "bitbybit.point.twoPointsAlmostEqual_description": "Prüft, ob zwei Punkte fast gleich sind",
    "bitbybit.line.lineToSegment": "Linie zu Segment",
    "lineToSegment": "Linie zu Segment",
    "bitbybit.line.lineToSegment_description": "Konvertiert die Linie in ein Segment",
    "bitbybit.line.linesToSegments": "Linien zu Segmenten",
    "linesToSegments": "Linien zu Segmenten",
    "bitbybit.line.linesToSegments_description": "Konvertiert die Linien in Segmente",
    "bitbybit.line.segmentToLine": "Segment zu Linie",
    "segmentToLine": "Segment zu Linie",
    "bitbybit.line.segmentToLine_description": "Konvertiert das Segment in eine Linie",
    "segment": "Segment",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "Segmente zu Linien",
    "segmentsToLines": "Segmente zu Linien",
    "bitbybit.line.segmentsToLines_description": "Konvertiert die Segmente in Linien",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "Segmente zu Polylinien sortieren",
    "sortSegmentsIntoPolylines": "Segmente zu Polylinien sortieren",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Erstellt die Polylinien aus Segmenten, die potenziell verbunden, aber zufällig gemischt sind",
    "sort": "sortieren",
    "bitbybit.mesh.signedDistanceToPlane": "vorzeichenbehafteter Abstand zur Ebene",
    "signedDistanceToPlane": "vorzeichenbehafteter Abstand zur Ebene",
    "bitbybit.mesh.signedDistanceToPlane_description": "Berechnet den vorzeichenbehafteten Abstand von einem Punkt zu einer Ebene.",
    "plane": "Ebene",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "Dreiecksebene berechnen",
    "calculateTrianglePlane": "Dreiecksebene berechnen",
    "bitbybit.mesh.calculateTrianglePlane_description": "Berechnet die Dreiecksebene aus dem Dreieck.",
    "triangle": "Dreieck",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "Dreieck-Dreieck-Schnittpunkt",
    "triangleTriangleIntersection": "Dreieck-Dreieck-Schnittpunkt",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Berechnet den Schnittpunkt zweier Dreiecke.",
    "triangle1": "Dreieck 1",
    "triangle2": "Dreieck 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "Netz-Netz-Schnittsegmente",
    "meshMeshIntersectionSegments": "Netz-Netz-Schnittsegmente",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Berechnet die Schnittsegmente zweier Netze.",
    "mesh1": "Netz 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "Netz 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "Netz-Netz-Schnittpolylinien",
    "meshMeshIntersectionPolylines": "Netz-Netz-Schnittpolylinien",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Berechnet die Schnittpolylinien zweier Netze.",
    "bitbybit.occt.shapeFacesToPolygonPoints": "Formflächen zu Polygonpunkten",
    "shapeFacesToPolygonPoints": "Formflächen zu Polygonpunkten",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Erstellt Polygonpunkte aus den Formflächen",
    "reversedPoints": "umgekehrte Punkte",
    "bitbybit.occt.shapeToMesh": "Form zu Netz",
    "shapeToMesh": "Form zu Netz",
    "bitbybit.occt.shapeToMesh_description": "Erstellt ein Netz aus der Form",
    "bitbybit.occt.shapesToMeshes": "Formen zu Netzen",
    "shapesToMeshes": "Formen zu Netzen",
    "bitbybit.occt.shapesToMeshes_description": "Erstellt ein Netz aus der Form",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "aus Polygonpunkten",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Erstellen Sie einen Manifold aus einer Reihe von Polygonpunkten, die Dreiecke beschreiben.",
    "traingle": "Dreieck",
    "bitbybit.point.stretchPointsDirFromCenter": "Punkte in Richtung vom Zentrum strecken",
    "stretchPointsDirFromCenter": "Punkte in Richtung vom Zentrum strecken",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Streckt mehrere Punkte unter Angabe von Mittelpunkt, Richtung und einheitlichem Skalierungsfaktor",
    "bitbybit.point.hexGridScaledToFit": "Angepasstes Sechseckraster",
    "hexGridScaledToFit": "Angepasstes Sechseckraster",
    "bitbybit.point.hexGridScaledToFit_description": "Erstellt ein Sechseckraster mit spitzer Oberseite, wobei die Sechsecke so skaliert werden, dass sie genau den angegebenen Abmessungen entsprechen. Gibt sowohl die Mittelpunkte als auch die Eckpunkte jedes (potenziell skalierten) Sechsecks zurück. Sechsecke werden zuerst nach Spalten, dann nach Zeilen sortiert.",
    "nrHexagonsU": "Anz. Sechsecke U",
    "nrHexagonsV": "Anz. Sechsecke V",
    "extendTop": "oben erweitern",
    "extendBottom": "unten erweitern",
    "extendLeft": "links erweitern",
    "extendRight": "rechts erweitern",
    "centerGrid": "Raster zentrieren",
    "bitbybit.point.sortPoints": "Punkte sortieren",
    "sortPoints": "Punkte sortieren",
    "bitbybit.point.sortPoints_description": "Sortiert Punkte lexikographisch (X, dann Y, dann Z)",
    "bitbybit.line.lineLineIntersection": "Schnittpunkt Linie-Linie",
    "lineLineIntersection": "Schnittpunkt Linie-Linie",
    "bitbybit.line.lineLineIntersection_description": "Wenn sich zwei Linien schneiden, gibt den Schnittpunkt zurück",
    "line1": "Linie 1",
    "line2": "Linie 2",
    "checkSegmentsOnly": "nur Segmente prüfen",
    "bitbybit.polyline.polylineToLines": "Polylinie zu Linien",
    "polylineToLines": "Polylinie zu Linien",
    "bitbybit.polyline.polylineToLines_description": "Erstellt die Linien aus der Polylinie",
    "bitbybit.polyline.polylineToSegments": "Polylinie zu Segmenten",
    "polylineToSegments": "Polylinie zu Segmenten",
    "bitbybit.polyline.polylineToSegments_description": "Erstellt die Segmente aus der Polylinie",
    "bitbybit.polyline.polylineSelfIntersection": "Selbstschnitt Polylinie",
    "polylineSelfIntersection": "Selbstschnitt Polylinie",
    "bitbybit.polyline.polylineSelfIntersection_description": "Findet die Selbstschnittpunkte der Polylinie",
    "bitbybit.polyline.twoPolylineIntersection": "Schnitt zweier Polylinien",
    "twoPolylineIntersection": "Schnitt zweier Polylinien",
    "bitbybit.polyline.twoPolylineIntersection_description": "Findet die Schnittpunkte zwischen zwei Polylinien.",
    "polyline1": "Polylinie 1",
    "polyline2": "Polylinie 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "in Sechseck-Drähte unterteilen",
    "subdivideToHexagonWires": "in Sechseck-Drähte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Unterteilt eine Fläche in Sechseck-Drähte",
    "extendUUp": "U oben erweitern",
    "extendUBottom": "U unten erweitern",
    "extendVUp": "V oben erweitern",
    "extendVBottom": "V unten erweitern",
    "nrHexagonsInHeight": "Anz. Sechsecke Höhe",
    "nrHexagonsInWidth": "Anz. Sechsecke Breite",
    "bitbybit.vector.length": "Vektorlänge",
    "bitbybit.vector.length_description": "Berechnet die Länge des Vektors",
    "bitbybit.point.maxFilletRadius": "max. Verrundungsradius",
    "maxFilletRadius": "max. Verrundungsradius",
    "bitbybit.point.maxFilletRadius_description": "Berechnet den maximal möglichen Verrundungsradius an einer Ecke, die von zwei Liniensegmenten mit gemeinsamem Endpunkt (C) gebildet wird, sodass der Verrundungsbogen tangential zu beiden Segmenten verläuft und vollständig innerhalb dieser liegt.",
    "bitbybit.point.maxFilletRadiusHalfLine": "max. Verrundungsradius halbe Linie",
    "maxFilletRadiusHalfLine": "max. Verrundungsradius halbe Linie",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Berechnet den maximal möglichen Verrundungsradius an einer Ecke C, sodass der Verrundungsbogen tangential zu beiden Segmenten (P1-C, P2-C) verläuft und die Tangentialpunkte innerhalb der ersten Hälfte jedes Segments (gemessen von C) liegen.",
    "bitbybit.point.maxFilletsHalfLine": "max. Verrundungen halbe Linie",
    "maxFilletsHalfLine": "max. Verrundungen halbe Linie",
    "bitbybit.point.maxFilletsHalfLine_description": "Berechnet den maximal möglichen Verrundungsradius an jeder Ecke einer Polylinie, die durch eine Reihe von Punkten gebildet wird. Der Verrundungsradius wird für jede innere Ecke und optional für die Schließecken berechnet, wenn die Polylinie geschlossen ist.",
    "checkLastWithFirst": "letztes mit erstem prüfen",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "sicherster max. Verrundungsradius (Punkte, halbe Linie)",
    "safestPointsMaxFilletHalfLine": "sicherster max. Verrundungsradius (Punkte, halbe Linie)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Berechnet den einzelnen sichersten maximalen Verrundungsradius, der basierend auf der 'halbe Linie'-Beschränkung einheitlich auf alle Ecken einer Punktsammlung angewendet werden kann. Dieser wird durch Ermittlung des Minimums der für jede einzelne Ecke berechneten maximal möglichen Verrundungsradien bestimmt.",
    "bitbybit.polyline.maxFilletsHalfLine": "max. Verrundungen halbe Linie",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Berechnet den maximal möglichen 'halbe Linie'-Verrundungsradius für jede Ecke einer gegebenen Polylinie. Bei einer geschlossenen Polylinie schließt dies die Ecken ein, die das letzte Segment mit dem ersten verbinden. Die Berechnung verwendet die 'halbe Linie'-Beschränkung, was bedeutet, dass die Tangentialpunkte der Verrundung innerhalb der ersten Hälfte jedes mit der Ecke verbundenen Segments liegen müssen.",
    "bitbybit.polyline.safestFilletRadius": "sicherster Verrundungsradius",
    "safestFilletRadius": "sicherster Verrundungsradius",
    "bitbybit.polyline.safestFilletRadius_description": "Berechnet den einzelnen sichersten maximalen Verrundungsradius, der basierend auf der 'halbe Linie'-Beschränkung einheitlich auf alle Ecken einer Polylinie angewendet werden kann. Dieser wird durch Ermittlung des Minimums der für jede einzelne Ecke berechneten maximal möglichen Verrundungsradien bestimmt.",
    "flatTop": "flache Oberseite",
    "bitbybit.mesh.meshMeshIntersectionPoints": "Schnittpunkte Netz-Netz",
    "meshMeshIntersectionPoints": "Schnittpunkte Netz-Netz",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Berechnet die Schnittpunkte zweier Netze.",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "Sechsecke im Raster",
    "hexagonsInGrid": "Sechsecke im Raster",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Erstellt OpenCascade Sechseck-Drähte im Raster",
    "scalePatternWidth": "Musterbreite skalieren",
    "scalePatternHeight": "Musterhöhe skalieren",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "Schnittdrähte Netz-Netz",
    "meshMeshIntersectionWires": "Schnittdrähte Netz-Netz",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Führt eine Netz-Netz-Schnittoperation zwischen zwei Formen durch - beide Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Drähte des Schnitts zurück, die Polylinien oder Polygone sind.",
    "mesh based": "Netzbasiert",
    "precision1": "Präzision 1",
    "precision2": "Präzision 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "Schnittpunkte Netz-Netz",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Führt eine Netz-Netz-Schnittoperation zwischen zwei Formen durch - beide Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Punkte des Schnitts zurück.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "Netz-Netz-Schnitt zu Drähten",
    "meshMeshIntersectionOfShapesWires": "Netz-Netz-Schnitt zu Drähten",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Führt eine Netz-Netz-Schnittoperation zwischen der Form und mehreren anderen Formen durch - alle Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Drähte des Schnitts zurück, die Polylinien oder Polygone sind.",
    "precisionShapes": "Präzision Formen",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "Netz-Netz-Schnitt zu Punkten",
    "meshMeshIntersectionOfShapesPoints": "Netz-Netz-Schnitt zu Punkten",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Führt eine Netz-Netz-Schnittoperation zwischen der Form und mehreren anderen Formen durch - alle Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Punkte des Schnitts zurück.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "Sechsecke im Raster",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Erstellt OpenCascade Sechsecke im Raster (als Flächen)",
    "bitbybit.jscad.toPolygonPoints": "zu Polygonpunkten",
    "toPolygonPoints": "zu Polygonpunkten",
    "bitbybit.jscad.toPolygonPoints_description": "Wandelt eine jscad-Form in eine Sammlung von Polygonpunkten um, die das Netz darstellen",
    "conversions": "Umwandlungen",
    "bitbybit.manifold.toPolygonPoints": "zu Polygonpunkten",
    "bitbybit.manifold.toPolygonPoints_description": "Wandelt eine Manifold-Form in eine Sammlung von Polygonpunkten um, die das Netz darstellen.",
    "flatU": "flaches U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "in Sechseck-Löcher unterteilen",
    "subdivideToHexagonHoles": "in Sechseck-Löcher unterteilen",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Unterteilt eine Fläche in Sechseck-Löcher",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "Linien in NURBS-Kurven konvertieren",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Konvertiert Linien in NURBS-Kurven. Gibt ein Array von verbnurbs Line-Objekten zurück.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "Linie in NURBS-Kurve konvertieren",
    "convertLineToNurbsCurve": "Linie in NURBS-Kurve konvertieren",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Konvertiert eine Linie in eine NURBS-Kurve. Gibt das verbnurbs Line-Objekt zurück.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "Polylinie in NURBS-Kurve konvertieren",
    "convertPolylineToNurbsCurve": "Polylinie in NURBS-Kurve konvertieren",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Konvertiert eine Polylinie in eine NURBS-Kurve. Gibt das verbnurbs NurbsCurve-Objekt zurück.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "Polylinien in NURBS-Kurven konvertieren",
    "convertPolylinesToNurbsCurves": "Polylinien in NURBS-Kurven konvertieren",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Konvertiert Polylinien in NURBS-Kurven. Gibt die verbnurbs NurbsCurve-Objekte zurück.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "Segment",
    "createSegment": "Segment",
    "bitbybit.line.createSegment_description": "Das Segment erstellen",
    "bitbybit.occt.shapes.edge.fromBaseLine": "Kante von Basislinie",
    "fromBaseLine": "von Basislinie",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Erstellt eine lineare Kante aus dem Basislinienformat {start: Point3, end: Point3}",
    "from base": "von Basis",
    "bitbybit.occt.shapes.edge.fromBaseLines": "Kante von Basislinien",
    "fromBaseLines": "von Basislinien",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Erstellt lineare Kanten aus dem Basislinienformat {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "Kante von Basissegment",
    "fromBaseSegment": "von Basissegment",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Erstellt eine lineare Kante aus dem Basissegmentformat [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "Kanten von Basissegmenten",
    "fromBaseSegments": "von Basissegmenten",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Erstellt eine lineare Kante aus dem Basissegmentformat [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "Kanten von Punkten",
    "fromPoints": "von Punkten",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Erstellt lineare Kanten aus einer Sammlung von Punkten",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "Kanten von Basispolylinie",
    "fromBasePolyline": "von Basispolylinie",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Erstellt lineare Kanten aus der Polyliniendefinition",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "Kanten von Basisdreieck",
    "fromBaseTriangle": "von Basisdreieck",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Erstellt lineare Kanten aus der Dreiecksdefinition",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "Kanten von Basisnetz",
    "fromBaseMesh": "von Basisnetz",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Erstellt lineare Kanten aus der Netzdefinition",
    "bitbybit.occt.shapes.wire.fromBaseLine": "Draht von Basislinie",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Erstellt einen linearen Draht aus dem Basislinienformat {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "Drähte von Basislinien",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Erstellt lineare Drähte aus dem Basislinienformat {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "Draht von Basissegment",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Erstellt einen linearen Draht aus dem Basissegmentformat [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "Drähte von Basissegmenten",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Erstellt lineare Drähte aus dem Basissegmentformat [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "Draht von Punkten",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Erstellt Draht aus einer Sammlung von Punkten",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "Draht von Basispolylinie",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Erstellt Draht aus der Polyliniendefinition",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "Draht von Basisdreieck",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Erstellt Draht aus der Dreiecksdefinition",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "Drähte von Basisnetz",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Erstellt Drähte aus der Netzdefinition",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "Fläche von Basisdreieck",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Erstellt Fläche aus der Dreiecksdefinition",
    "bitbybit.occt.shapes.face.fromBaseMesh": "Flächen von Basisnetz",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Erstellt Flächen aus der Netzdefinition",
    "fromRightHanded": "von rechtshändig",
    "bitbybit.advanced.text3d.createWithUrl": "Text mit URL",
    "createWithUrl": "Text mit URL",
    "bitbybit.advanced.text3d.createWithUrl_description": "Erstellt einen 3D-Text mit einer Schriftart-URL. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Erzeugung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere fehlerhafte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftartformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "fontUrl": "Schriftart-URL",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "Text auf Fläche URL",
    "createTextOnFaceUrl": "Text auf Fläche URL",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Erstellt einen 3D-Text auf der Fläche unter Verwendung einer Schriftart-URL. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Erzeugung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere fehlerhafte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftartformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "Texte auf Fläche URL",
    "createTextsOnFaceUrl": "Texte auf Fläche URL",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Erstellt 3D-Texte auf der Fläche aus mehreren URL-Definitionen. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Erzeugung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere fehlerhafte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftartformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "Definition 3D-Text auf Fläche URL",
    "definition3dTextOnFaceUrl": "Definition 3D-Text auf Fläche URL",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Erstellt 3D-Text, der in der Flächen-URL-Definition verwendet wird. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Erzeugung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere fehlerhafte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftartformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
     "bitbybit.advanced.navigation.pointOfInterest": "Interessanter Punkt",
    "navigation": "Navigation",
    "pointOfInterest": "Interessanter Punkt",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Durchflug-Knotenpunkt",
    "cameraTarget": "Kameraziel",
    "cameraPosition": "Kameraposition",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "System für interessante Punkte",
    "pointsOfInterestSystem": "System für interessante Punkte",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "Interessante Punkte",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "Interessanter Punkt",
    "style": "Stil",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "Stil für interessante Punkte",
    "pointOfInterestStyle": "Stil für interessante Punkte",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Erstellen Sie einen Stil für interessante Punkte - wird verwendet, um Indikatoren für interessante Punkte im 3D-Raum zu gestalten. Sie können Punktgröße, Farbe, Hover-Farbe, Pulseffekt, Farbe und Größe der Textbeschriftung anpassen.",
    "pointSize": "Punktgröße",
    "pointColor": "Punktfarbe",
    "hoverPointColor": "Punktfarbe bei Hover",
    "pulseColor": "Pulsfarbe",
    "hoverPulseColor": "Pulsfarbe bei Hover",
    "pulseMinSize": "Minimale Pulsgröße",
    "pulseMaxSize": "Maximale Pulsgröße",
    "pulseThickness": "Pulsdicke",
    "pulseSpeed": "Pulsgeschwindigkeit",
    "textColor": "Textfarbe",
    "hoverTextColor": "Textfarbe bei Hover",
    "textSize": "Textgröße",
    "hideSkybox": "Skybox ausblenden",
    "textureUrl": "Textur-URL",
    "hdrTexture": "HDR-Textur",
    "textureSize": "Texturgröße",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "benutzerdefinierte Skybox-Textur aktivieren",
    "enableSkyboxCustomTexture": "benutzerdefinierte Skybox-Textur aktivieren",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Aktiviert die Skybox mit einer benutzerdefinierten Textur",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "Canvas CSS Hintergrundbild",
    "canvasCSSBackgroundImage": "Canvas CSS Hintergrundbild",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Ändert den Szenenhintergrund zu einem CSS-Hintergrundbild für den 3D-Raum",
    "cssBackgroundImage": "CSS Hintergrundbild",
    "bitbybit.babylon.scene.twoColorLinearGradient": "zweifarbiger linearer Gradient",
    "twoColorLinearGradient": "zweifarbiger linearer Gradient",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Erstellt einen zweifarbigen linearen Gradientenhintergrund für den 3D-Raum",
    "colorFrom": "Farbe von",
    "colorTo": "Farbe zu",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "Stopp von",
    "stopTo": "Stopp zu",
    "bitbybit.babylon.scene.twoColorRadialGradient": "zweifarbiger radialer Gradient",
    "twoColorRadialGradient": "zweifarbiger radialer Gradient",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Erstellt einen zweifarbigen radialen Gradientenhintergrund für den 3D-Raum",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "mehrfarbiger linearer Gradient",
    "multiColorLinearGradient": "mehrfarbiger linearer Gradient",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Erstellt einen mehrfarbigen linearen Gradientenhintergrund für den 3D-Raum",
    "Base.Color[]": "Base.Color[]",
    "stops": "Stopps",
    "bitbybit.babylon.scene.multiColorRadialGradient": "mehrfarbiger radialer Gradient",
    "multiColorRadialGradient": "mehrfarbiger radialer Gradient",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Erstellt einen mehrfarbigen radialen Gradientenhintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.canvasBackgroundImage": "Canvas Hintergrundbild",
    "canvasBackgroundImage": "Canvas Hintergrundbild",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Setzt ein Hintergrundbild mit verschiedenen Anpassungsoptionen für den 3D-Raum",
    "imageUrl": "Bild URL",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "Anhang",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "Ausschneiden",
    "labelRotation": "Beschriftungsrotation",
    "bitbybit.advanced.dimensions.linearDimension": "lineare Bemaßung",
    "linearDimension": "lineare Bemaßung",
    "bitbybit.advanced.dimensions.linearDimension_description": "Erstellt eine lineare Bemaßung - eine Messlinie zwischen zwei Punkten mit Hilfslinien und Textbeschriftung. Die Bemaßung zeigt den Abstand zwischen den Punkten und kann mit DimensionStyleDto gestaltet werden.",
    "linear dimension": "lineare Bemaßung",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "Winkelbemaßung",
    "angularDimension": "Winkelbemaßung",
    "bitbybit.advanced.dimensions.angularDimension_description": "Erstellt eine Winkelbemaßung - einen Messbogen zwischen zwei Richtungsvektoren mit Hilfslinien und Textbeschriftung. Die Bemaßung zeigt den Winkel zwischen den Richtungen und kann mit DimensionStyleDto gestaltet werden.",
    "angular dimension": "Winkelbemaßung",
    "centerPoint": "Mittelpunkt",
    "bitbybit.advanced.dimensions.dimensionStyle": "Bemaßungsstil",
    "dimensionStyle": "Bemaßungsstil",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Erstellt einen Bemaßungsstil - wird verwendet, um Bemaßungslinien, Pfeile und Text im 3D-Raum zu gestalten. Sie können Linienfarben, Dicke, Textgröße, Pfeilgröße und Hintergrundfarben anpassen.",
    "dimension style": "Bemaßungsstil",
    "lineColor": "Linienfarbe",
    "lineThickness": "Liniendicke",
    "extensionLineLength": "Hilfslinienlänge",
    "textBackgroundColor": "Text-Hintergrundfarbe",
    "textBackgroundOpacity": "Text-Hintergrundtransparenz",
    "arrowSize": "Pfeilgröße",
    "arrowColor": "Pfeilfarbe",
    "textRenderMode": "Text-Rendermodus",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "Text-Billboard",
    "occlusionCheckInterval": "Verdeckungsüberprüfungsintervall",
    "arrowTailLength": "Pfeilschwanzlänge",
    "showArrows": "Pfeile anzeigen",
    "labelOverwrite": "Beschriftung überschreiben",
    "bitbybit.advanced.dimensions.radialDimension": "Radialbemaßung",
    "radialDimension": "Radialbemaßung",
    "bitbybit.advanced.dimensions.radialDimension_description": "Erstellt eine Radialbemaßung - eine Messlinie vom Zentrum zum Umfang, die Radius oder Durchmesser zeigt. Zeigt 'R'-Präfix für Radius oder '⌀'-Präfix für Durchmesser mit optionaler Mittelmarkierung.",
    "radial dimension": "Radialbemaßung",
    "radiusPoint": "Radiuspunkt",
    "showDiameter": "Durchmesser anzeigen",
    "showCenterMark": "Mittelmarkierung anzeigen",
    "bitbybit.advanced.dimensions.diametralDimension": "Durchmesserbemaßung",
    "diametralDimension": "Durchmesserbemaßung",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Erstellt eine Durchmesserbemaßung - eine Messlinie, die den vollen Durchmesser kreisförmiger Merkmale umfasst. Zeigt '⌀'-Präfix mit optionaler Mittelmarkierung und Pfeilen an beiden Enden.",
    "diametral dimension": "Durchmesserbemaßung",
    "bitbybit.advanced.dimensions.ordinateDimension": "Koordinatenbemaßung",
    "ordinateDimension": "Koordinatenbemaßung",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Erstellt eine Koordinatenbemaßung - zeigt X-, Y- oder Z-Koordinate von einem Referenzpunkt mit Führungslinie. Nützlich für Koordinatenannotationen und Bezugsbezüge in technischen Zeichnungen.",
    "ordinate dimension": "Koordinatenbemaßung",
    "measurementPoint": "Messpunkt",
    "referencePoint": "Referenzpunkt",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "Führungslinie anzeigen",
    "viewMode": "Ansichtsmodus",
    "schema": "Schema",
    "json schema": "JSON-Schema",
    "metadata": "Metadaten",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "zweifarbiger linearer Farbverlaufshintergrund",
    "twoColorLinearGradientBackground": "zweifarbiger linearer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Erstellt einen zweifarbigen linearen Farbverlaufshintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "zweifarbiger radialer Farbverlaufshintergrund",
    "twoColorRadialGradientBackground": "zweifarbiger radialer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Erstellt einen zweifarbigen radialen Farbverlaufshintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "mehrfarbiger linearer Farbverlaufshintergrund",
    "multiColorLinearGradientBackground": "mehrfarbiger linearer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Erstellt einen mehrfarbigen linearen Farbverlaufshintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "mehrfarbiger radialer Farbverlaufshintergrund",
    "multiColorRadialGradientBackground": "mehrfarbiger radialer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Erstellt einen mehrfarbigen radialen Farbverlaufshintergrund für den 3D-Raum",
    "textBackgroundStroke": "Text-Hintergrundkontur",
    "textBackgroundRadius": "Text-Hintergrundradius",
    "stableSize": "stabile Größe",
    "alwaysOnTop": "immer oben",
    "textStableSize": "stabile Textgröße",
    "bitbybit.occt.io.shapeToDxfPaths": "Form zu DXF-Pfaden",
    "shapeToDxfPaths": "Form zu DXF-Pfaden",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Erstellt DXF-Pfade aus einer OCCT-Form. Wichtig - Formen mit Drähten müssen auf der XZ-Ebene (Y=0) liegen, um einen korrekten 2D-DXF-Export zu ermöglichen.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "DXF-Pfade mit Ebene",
    "dxfPathsWithLayer": "DXF-Pfade mit Ebene",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Fügt DXF-Pfaden Ebenen- und Farbinformationen hinzu",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "Ebene",
    "bitbybit.occt.io.dxfCreate": "DXF erstellen",
    "dxfCreate": "DXF erstellen",
    "bitbybit.occt.io.dxfCreate_description": "Fügt mehrere Pfadteile zu einer vollständigen DXF-Datei zusammen",
    "pathsParts": "Pfadteile",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "Textschriftstärke",
    "textPosition": "Textposition",
    "textBackgroundStrokeThickness": "Strichstärke",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum"
}