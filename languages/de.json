{
    "bitbybit.draw.drawAnyAsyncNoReturn": "beliebig asynchron ohne Rückgabe zeichnen",
    "bitbybit": "bitbybit",
    "draw": "zeichnen",
    "drawAnyAsyncNoReturn": "beliebig asynchron ohne Rückgabe zeichnen",
    "bitbybit.draw.drawAnyAsyncNoReturn_description": "Zeichnet jede Art von Geometrie und gibt nichts zurück.",
    "draw async": "asynchron zeichnen",
    "entity": "Entität",
    "Entity": "Entität",
    "options": "Optionen",
    "DrawOptions": "Zeichenoptionen",
    "babylonMesh": "Babylon-Mesh",
    "BABYLON.Mesh | BABYLON.LinesMesh": "Babylon-Mesh oder Linien-Mesh",
    "bitbybit.draw.drawAnyAsync": "beliebig asynchron zeichnen",
    "drawAnyAsync": "beliebig asynchron zeichnen",
    "bitbybit.draw.drawAnyAsync_description": "Zeichnet jede Art von Geometrie und gibt das Babylon-Mesh zurück.",
    "bitbybit.draw.drawAnyNoReturn": "beliebig ohne Rückgabe zeichnen",
    "drawAnyNoReturn": "beliebig ohne Rückgabe zeichnen",
    "bitbybit.draw.drawAnyNoReturn_description": "Zeichnet jede Art von Geometrie, die keine asynchrone Berechnung benötigt, daher kann sie nicht mit Formen aus OCCT oder JSCAD verwendet werden.",
    "draw sync": "synchron zeichnen",
    "bitbybit.draw.drawAny": "beliebig zeichnen",
    "drawAny": "beliebig zeichnen",
    "bitbybit.draw.drawAny_description": "Zeichnet jede Art von Geometrie, die keine asynchrone Berechnung benötigt, daher kann sie nicht mit Formen aus OCCT oder JSCAD verwendet werden.",
    "bitbybit.draw.drawGridMeshNoReturn": "Gitter-Mesh ohne Rückgabe zeichnen",
    "drawGridMeshNoReturn": "Gitter-Mesh ohne Rückgabe zeichnen",
    "bitbybit.draw.drawGridMeshNoReturn_description": "Zeichnet ein Gitter-Mesh auf der Grundebene im 3D-Raum. Dies hilft bei der Orientierung in der Welt.",
    "grid": "Gitter",
    "width": "Breite",
    "number": "Nummer",
    "height": "Höhe",
    "subdivisions": "Unterteilungen",
    "majorUnitFrequency": "Haupteinheitsfrequenz",
    "minorUnitVisibility": "Sichtbarkeit kleiner Einheiten",
    "gridRatio": "Gitterverhältnis",
    "opacity": "Deckkraft",
    "backFaceCulling": "Rückseitenentfernung",
    "boolean": "Boolesch",
    "mainColor": "Hauptfarbe",
    "Base.Color": "Basisfarbe",
    "secondaryColor": "Sekundärfarbe",
    "bitbybit.draw.drawGridMesh": "Gitter-Mesh zeichnen",
    "drawGridMesh": "Gitter-Mesh zeichnen",
    "bitbybit.draw.drawGridMesh_description": "Zeichnet ein Gitter-Mesh auf der Grundebene im 3D-Raum. Dies hilft bei der Orientierung in der Welt.",
    "bitbybit.draw.optionsSimple": "einfache Optionen",
    "optionsSimple": "einfache Optionen",
    "bitbybit.draw.optionsSimple_description": "Erstellt Zeichenoptionen für grundlegende Geometrietypen wie Punkte, Linien, Polylinien, Oberflächen und JSCAD-Meshes.",
    "colours": "Farben",
    "string | string[]": "Zeichenkette oder Zeichenketten-Array",
    "size": "Größe",
    "updatable": "aktualisierbar",
    "hidden": "versteckt",
    "bitbybit.draw.optionsOcctShape": "OCCT-Form-Optionen",
    "optionsOcctShape": "OCCT-Form-Optionen",
    "bitbybit.draw.optionsOcctShape_description": "Erstellt Zeichenoptionen für OCCT-Formgeometrie wie Kanten, Drähte, Flächen, Hüllen, Volumenkörper und Verbunde.",
    "faceOpacity": "Flächen-Deckkraft",
    "edgeOpacity": "Kanten-Deckkraft",
    "edgeColour": "Kantenfarbe",
    "faceColour": "Flächenfarbe",
    "vertexColour": "Eckpunktfarbe",
    "faceMaterial": "Flächenmaterial",
    "Base.Material": "Basismaterial",
    "edgeWidth": "Kantenbreite",
    "vertexSize": "Eckpunktgröße",
    "drawEdges": "Kanten zeichnen",
    "drawFaces": "Flächen zeichnen",
    "drawVertices": "Eckpunkte zeichnen",
    "precision": "Präzision",
    "drawEdgeIndexes": "Kantenindizes zeichnen",
    "edgeIndexHeight": "Kantenindexhöhe",
    "edgeIndexColour": "Kantenindexfarbe",
    "drawFaceIndexes": "Flächenindizes zeichnen",
    "faceIndexHeight": "Flächenindexhöhe",
    "faceIndexColour": "Flächenindexfarbe",
    "bitbybit.draw.optionsOcctShapeSimple": "einfache OCCT-Form-Optionen",
    "optionsOcctShapeSimple": "einfache OCCT-Form-Optionen",
    "bitbybit.draw.optionsOcctShapeSimple_description": "Erstellt einfache Zeichenoptionen für OCCT-Formgeometrie.",
    "bitbybit.draw.optionsOcctShapeMaterial": "OCCT-Form-Material-Optionen",
    "optionsOcctShapeMaterial": "OCCT-Form-Material-Optionen",
    "bitbybit.draw.optionsOcctShapeMaterial_description": "Erstellt einfache Zeichenoptionen mit benutzerdefiniertem Flächenmaterial für OCCT-Formgeometrie.",
    "any": "beliebig",
    "bitbybit.draw.optionsManifoldShapeMaterial": "Mannigfaltigkeits-Form-Material-Optionen",
    "optionsManifoldShapeMaterial": "Mannigfaltigkeits-Form-Material-Optionen",
    "bitbybit.draw.optionsManifoldShapeMaterial_description": "Erstellt Zeichenoptionen für Manifold-Geometrie.",
    "crossSectionColour": "Querschnittsfarbe",
    "crossSectionWidth": "Querschnittsbreite",
    "crossSectionOpacity": "Querschnittsdeckkraft",
    "computeNormals": "Normalen berechnen",
    "bitbybit.draw.optionsBabylonNode": "Babylon-Knoten-Optionen",
    "optionsBabylonNode": "Babylon-Knoten-Optionen",
    "bitbybit.draw.optionsBabylonNode_description": "Erstellt Zeichenoptionen für BabylonJS-Knoten.",
    "colorX": "Farbe X",
    "colorY": "Farbe Y",
    "colorZ": "Farbe Z",
    "bitbybit.babylon.mesh.dispose": "Mesh entsorgen",
    "babylon": "Babylon",
    "mesh": "Mesh",
    "dispose": "entsorgen",
    "bitbybit.babylon.mesh.dispose_description": "Verwirft das gezeichnete Mesh-Objekt aus der Szene.",
    "memory": "Speicher",
    "BABYLON.Mesh": "Babylon-Mesh",
    "bitbybit.babylon.mesh.updateDrawn": "gezeichnetes aktualisieren",
    "updateDrawn": "gezeichnetes aktualisieren",
    "bitbybit.babylon.mesh.updateDrawn_description": "Aktualisiert das gezeichnete BabylonJS-Mesh-Objekt, ohne es zu verwerfen.",
    "updates": "Aktualisierungen",
    "position": "Position",
    "Base.Point3": "Basispunkt 3",
    "rotation": "Rotation",
    "Base.Vector3": "Basisvektor 3",
    "scaling": "Skalierung",
    "bitbybit.babylon.mesh.setVisibility": "Sichtbarkeit festlegen",
    "setVisibility": "Sichtbarkeit festlegen",
    "bitbybit.babylon.mesh.setVisibility_description": "Ändert die Sichtbarkeit eines gezeichneten BabylonJS-Meshes.",
    "visibility": "Sichtbarkeit",
    "includeChildren": "Kinder einbeziehen",
    "bitbybit.babylon.mesh.hide": "verstecken",
    "hide": "verstecken",
    "bitbybit.babylon.mesh.hide_description": "versteckt das Mesh",
    "bitbybit.babylon.mesh.show": "anzeigen",
    "show": "anzeigen",
    "bitbybit.babylon.mesh.show_description": "Zeigt das Mesh an.",
    "bitbybit.babylon.mesh.setParent": "Elternteil festlegen",
    "setParent": "Elternteil festlegen",
    "bitbybit.babylon.mesh.setParent_description": "Ändert das übergeordnete Element des gezeichneten Meshes.",
    "set": "festlegen",
    "BABYLON.Mesh | BABYLON.InstancedMesh | BABYLON.AbstractMesh": "Babylon-Mesh oder instanziertes Mesh oder abstraktes Mesh",
    "parentMesh": "Eltern-Mesh",
    "bitbybit.babylon.mesh.getParent": "Elternteil abrufen",
    "getParent": "Elternteil abrufen",
    "bitbybit.babylon.mesh.getParent_description": "Ruft das übergeordnete Element des gezeichneten Meshes ab.",
    "get": "abrufen",
    "bitbybit.babylon.mesh.setCheckCollisions": "Kollisionsprüfung festlegen",
    "setCheckCollisions": "Kollisionsprüfung festlegen",
    "bitbybit.babylon.mesh.setCheckCollisions_description": "Ändert die Kollisionsprüfungseigenschaft des gezeichneten Meshes.",
    "checkCollisions": "Kollisionen prüfen",
    "bitbybit.babylon.mesh.getCheckCollisions": "Kollisionsprüfung abrufen",
    "getCheckCollisions": "Kollisionsprüfung abrufen",
    "bitbybit.babylon.mesh.getCheckCollisions_description": "Ruft die Kollisionsprüfungseigenschaft des gezeichneten Meshes ab.",
    "bitbybit.babylon.mesh.setPickable": "Auswählbar festlegen",
    "setPickable": "Auswählbar festlegen",
    "bitbybit.babylon.mesh.setPickable_description": "Ändert die Auswählbarkeitseigenschaft des gezeichneten Meshes.",
    "pickable": "auswählbar",
    "bitbybit.babylon.mesh.enablePointerMoveEvents": "Zeigerbewegungsereignisse aktivieren",
    "enablePointerMoveEvents": "Zeigerbewegungsereignisse aktivieren",
    "bitbybit.babylon.mesh.enablePointerMoveEvents_description": "Zwingt das Mesh, durch Zeigerbewegungsereignisse auswählbar zu sein, Standard ist false, da es leistungsintensiv ist.",
    "bitbybit.babylon.mesh.disablePointerMoveEvents": "Zeigerbewegungsereignisse deaktivieren",
    "disablePointerMoveEvents": "Zeigerbewegungsereignisse deaktivieren",
    "bitbybit.babylon.mesh.disablePointerMoveEvents_description": "Macht das Mesh immun gegen Zeigerbewegungsereignisse, Standard ist false.",
    "bitbybit.babylon.mesh.getPickable": "Auswählbar abrufen",
    "getPickable": "Auswählbar abrufen",
    "bitbybit.babylon.mesh.getPickable_description": "Ruft die Auswählbarkeitseigenschaft des gezeichneten Meshes ab.",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains": "Meshes abrufen, deren Name enthält",
    "getMeshesWhereNameContains": "Meshes abrufen, deren Name enthält",
    "bitbybit.babylon.mesh.getMeshesWhereNameContains_description": "Ruft Meshes ab, deren Namen einen bestimmten Text enthalten.",
    "name": "Name",
    "string": "Zeichenkette",
    "bitbybit.babylon.mesh.getChildMeshes": "Kind-Meshes abrufen",
    "getChildMeshes": "Kind-Meshes abrufen",
    "bitbybit.babylon.mesh.getChildMeshes_description": "ruft Kind-Meshes ab",
    "directDescendantsOnly": "nur direkte Nachkommen",
    "bitbybit.babylon.mesh.getMeshesOfId": "Meshes nach ID abrufen",
    "getMeshesOfId": "Meshes nach ID abrufen",
    "bitbybit.babylon.mesh.getMeshesOfId_description": "Ruft Meshes mit der ID ab.",
    "id": "ID",
    "bitbybit.babylon.mesh.getMeshOfId": "Mesh nach ID abrufen",
    "getMeshOfId": "Mesh nach ID abrufen",
    "bitbybit.babylon.mesh.getMeshOfId_description": "Ruft das Mesh mit der ID ab.",
    "bitbybit.babylon.mesh.getMeshOfUniqueId": "Mesh nach eindeutiger ID abrufen",
    "getMeshOfUniqueId": "Mesh nach eindeutiger ID abrufen",
    "bitbybit.babylon.mesh.getMeshOfUniqueId_description": "Ruft das Mesh mit der eindeutigen ID ab.",
    "uniqueId": "eindeutige ID",
    "bitbybit.babylon.mesh.mergeMeshes": "Meshes zusammenführen",
    "mergeMeshes": "Meshes zusammenführen",
    "bitbybit.babylon.mesh.mergeMeshes_description": "führt mehrere Meshes zu einem zusammen",
    "edit": "bearbeiten",
    "arrayOfMeshes": "Array von Meshes",
    "BABYLON.Mesh[]": "Babylon-Mesh-Array",
    "disposeSource": "Quelle entsorgen",
    "allow32BitsIndices": "32-Bit-Indizes erlauben",
    "meshSubclass": "Mesh-Unterklasse",
    "subdivideWithSubMeshes": "mit Sub-Meshes unterteilen",
    "multiMultiMaterials": "Multi-Multi-Materialien",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh": "in flach beschattetes Mesh konvertieren",
    "convertToFlatShadedMesh": "in flach beschattetes Mesh konvertieren",
    "bitbybit.babylon.mesh.convertToFlatShadedMesh_description": "Konvertiert das Mesh in ein Mesh mit flacher Schattierung (flat shaded).",
    "bitbybit.babylon.mesh.clone": "klonen",
    "clone": "klonen",
    "bitbybit.babylon.mesh.clone_description": "klont das Mesh",
    "bitbybit.babylon.mesh.cloneToPositions": "zu Positionen klonen",
    "cloneToPositions": "zu Positionen klonen",
    "bitbybit.babylon.mesh.cloneToPositions_description": "Klont das Mesh an Positionen.",
    "positions": "Positionen",
    "Base.Point3[]": "Basispunkt-3-Array",
    "bitbybit.babylon.mesh.setId": "ID festlegen",
    "setId": "ID festlegen",
    "bitbybit.babylon.mesh.setId_description": "Ändert die ID des gezeichneten Meshes.",
    "bitbybit.babylon.mesh.getId": "ID abrufen",
    "getId": "ID abrufen",
    "bitbybit.babylon.mesh.getId_description": "Ruft die ID des gezeichneten Meshes ab.",
    "bitbybit.babylon.mesh.getUniqueId": "eindeutige ID abrufen",
    "getUniqueId": "eindeutige ID abrufen",
    "bitbybit.babylon.mesh.getUniqueId_description": "Ruft die eindeutige ID des gezeichneten Meshes ab.",
    "bitbybit.babylon.mesh.setName": "Name festlegen",
    "setName": "Name festlegen",
    "bitbybit.babylon.mesh.setName_description": "Ändert den Namen des gezeichneten Meshes.",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints": "Eckpunkte als Polygonpunkte abrufen",
    "getVerticesAsPolygonPoints": "Eckpunkte als Polygonpunkte abrufen",
    "bitbybit.babylon.mesh.getVerticesAsPolygonPoints_description": "Ruft die Vertices als Polygonpunkte ab. Diese können mit anderen Konstruktionsmethoden verwendet werden, um Meshes zu erstellen. Das Mesh muss trianguliert sein.",
    "bitbybit.babylon.mesh.getName": "Namen abrufen",
    "getName": "Namen abrufen",
    "bitbybit.babylon.mesh.getName_description": "Ruft den Namen des Babylon-Meshes ab.",
    "bitbybit.babylon.mesh.setMaterial": "Material festlegen",
    "setMaterial": "Material festlegen",
    "bitbybit.babylon.mesh.setMaterial_description": "Ändert das Material des gezeichneten Meshes.",
    "material": "Material",
    "BABYLON.Material": "Babylon-Material",
    "bitbybit.babylon.mesh.getMaterial": "Material abrufen",
    "getMaterial": "Material abrufen",
    "bitbybit.babylon.mesh.getMaterial_description": "Ruft das Material des Babylon-Meshes ab.",
    "bitbybit.babylon.mesh.getPosition": "Position abrufen",
    "getPosition": "Position abrufen",
    "bitbybit.babylon.mesh.getPosition_description": "Ruft die Position als Punkt des BabylonJS-Meshes ab.",
    "bitbybit.babylon.mesh.getAbsolutePosition": "absolute Position abrufen",
    "getAbsolutePosition": "absolute Position abrufen",
    "bitbybit.babylon.mesh.getAbsolutePosition_description": "Ruft die absolute Position in der Welt als Punkt des BabylonJS-Meshes ab.",
    "bitbybit.babylon.mesh.getRotation": "Rotation abrufen",
    "getRotation": "Rotation abrufen",
    "bitbybit.babylon.mesh.getRotation_description": "Ruft den Rotationsvektor des BabylonJS-Meshes ab.",
    "bitbybit.babylon.mesh.getScale": "Skalierung abrufen",
    "getScale": "Skalierung abrufen",
    "bitbybit.babylon.mesh.getScale_description": "Ruft den Skalierungsvektor des BabylonJS-Meshes ab.",
    "bitbybit.babylon.mesh.moveForward": "vorwärts bewegen",
    "moveForward": "vorwärts bewegen",
    "bitbybit.babylon.mesh.moveForward_description": "Bewegt das BabylonJS-Mesh im lokalen Raum vorwärts.",
    "move": "bewegen",
    "distance": "Entfernung",
    "bitbybit.babylon.mesh.moveBackward": "rückwärts bewegen",
    "moveBackward": "rückwärts bewegen",
    "bitbybit.babylon.mesh.moveBackward_description": "Bewegt das BabylonJS-Mesh im lokalen Raum rückwärts.",
    "bitbybit.babylon.mesh.moveUp": "nach oben bewegen",
    "moveUp": "nach oben bewegen",
    "bitbybit.babylon.mesh.moveUp_description": "Bewegt das BabylonJS-Mesh im lokalen Raum nach oben.",
    "bitbybit.babylon.mesh.moveDown": "nach unten bewegen",
    "moveDown": "nach unten bewegen",
    "bitbybit.babylon.mesh.moveDown_description": "Bewegt das BabylonJS-Mesh im lokalen Raum nach unten.",
    "bitbybit.babylon.mesh.moveRight": "nach rechts bewegen",
    "moveRight": "nach rechts bewegen",
    "bitbybit.babylon.mesh.moveRight_description": "Bewegt das BabylonJS-Mesh im lokalen Raum nach rechts.",
    "bitbybit.babylon.mesh.moveLeft": "nach links bewegen",
    "moveLeft": "nach links bewegen",
    "bitbybit.babylon.mesh.moveLeft_description": "Bewegt das BabylonJS-Mesh im lokalen Raum nach links.",
    "bitbybit.babylon.mesh.yaw": "Gieren",
    "yaw": "Gieren",
    "bitbybit.babylon.mesh.yaw_description": "Rotiert das BabylonJS-Mesh um die lokale Y-Achse.",
    "rotate": "rotieren",
    "bitbybit.babylon.mesh.pitch": "Nicken",
    "pitch": "Nicken",
    "bitbybit.babylon.mesh.pitch_description": "Rotiert das BabylonJS-Mesh um die lokale X-Achse.",
    "bitbybit.babylon.mesh.roll": "Rollen",
    "roll": "Rollen",
    "bitbybit.babylon.mesh.roll_description": "Rotiert das BabylonJS-Mesh um die lokale Z-Achse.",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition": "um Achse mit Position rotieren",
    "rotateAroundAxisWithPosition": "um Achse mit Position rotieren",
    "bitbybit.babylon.mesh.rotateAroundAxisWithPosition_description": "Rotiert das Mesh um eine Achse und eine gegebene Position um einen gegebenen Winkel.",
    "axis": "Achse",
    "angle": "Winkel",
    "bitbybit.babylon.mesh.setPosition": "Position festlegen",
    "setPosition": "Position festlegen",
    "bitbybit.babylon.mesh.setPosition_description": "Aktualisiert die Position des BabylonJS-Meshes oder instanziierten Meshes.",
    "BABYLON.Mesh | BABYLON.InstancedMesh": "Babylon-Mesh oder instanziertes Mesh",
    "bitbybit.babylon.mesh.setRotation": "Rotation festlegen",
    "setRotation": "Rotation festlegen",
    "bitbybit.babylon.mesh.setRotation_description": "Aktualisiert die Rotation des BabylonJS-Meshes oder instanziierten Meshes.",
    "bitbybit.babylon.mesh.setScale": "Skalierung festlegen",
    "setScale": "Skalierung festlegen",
    "bitbybit.babylon.mesh.setScale_description": "Aktualisiert die Skalierung des BabylonJS-Meshes oder instanziierten Meshes.",
    "scale": "Skalierung",
    "bitbybit.babylon.mesh.intersectsMesh": "Mesh schneidet",
    "intersectsMesh": "Mesh schneidet",
    "bitbybit.babylon.mesh.intersectsMesh_description": "Prüft, ob das Mesh ein anderes Mesh schneidet.",
    "intersects": "schneidet",
    "babylonMesh2": "Babylon-Mesh 2",
    "precise": "präzise",
    "includeDescendants": "Nachkommen einbeziehen",
    "bitbybit.babylon.mesh.intersectsPoint": "Punkt schneidet",
    "intersectsPoint": "Punkt schneidet",
    "bitbybit.babylon.mesh.intersectsPoint_description": "Prüft, ob das Mesh einen Punkt schneidet.",
    "point": "Punkt",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn": "Mesh-Instanz und Transformation ohne Rückgabe erstellen",
    "createMeshInstanceAndTransformNoReturn": "Mesh-Instanz und Transformation ohne Rückgabe erstellen",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransformNoReturn_description": "Erstellt eine Mesh-Instanz für optimiertes Rendering. Diese Methode prüft, ob das Mesh Kinder enthält, und erstellt Instanzen für jedes Kind. Diese sind für maximale Leistung optimiert, wenn viele ähnliche Objekte in der Szene gerendert werden. Diese Methode gibt Instanzen als Kinder in einem neuen Mesh zurück. Wenn das Mesh Kinder hat, wird jedes Kind zu einer Mesh-Instanz.",
    "instance": "Instanz",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform": "Mesh-Instanz und Transformation erstellen",
    "createMeshInstanceAndTransform": "Mesh-Instanz und Transformation erstellen",
    "bitbybit.babylon.mesh.createMeshInstanceAndTransform_description": "Erstellt eine Mesh-Instanz für optimiertes Rendering. Diese Methode prüft, ob das Mesh Kinder enthält, und erstellt Instanzen für jedes Kind. Diese sind für maximale Leistung optimiert, wenn viele ähnliche Objekte in der Szene gerendert werden. Diese Methode gibt Instanzen als Kinder in einem neuen Mesh zurück. Wenn das Mesh Kinder hat, wird jedes Kind zu einer Mesh-Instanz.",
    "bitbybit.babylon.mesh.createMeshInstance": "Mesh-Instanz erstellen",
    "createMeshInstance": "Mesh-Instanz erstellen",
    "bitbybit.babylon.mesh.createMeshInstance_description": "Erstellt eine Mesh-Instanz. Diese sind für maximale Leistung optimiert, wenn viele ähnliche Objekte in der Szene gerendert werden. Wenn das Mesh Kinder hat, erhält jedes Kind eine Mesh-Instanz.",
    "bitbybit.babylon.gaussianSplatting.create": "Gaussian Splatting",
    "gaussianSplatting": "Gaussian Splatting",
    "create": "erstellen",
    "bitbybit.babylon.gaussianSplatting.create_description": "erstellt Gaussian Splatting Mesh",
    "url": "URL",
    "bitbybit.babylon.gaussianSplatting.clone": "Gaussian Splatting klonen",
    "bitbybit.babylon.gaussianSplatting.clone_description": "klont Gaussian Splatting Mesh",
    "multiply": "multiplizieren",
    "BABYLON.GaussianSplattingMesh": "Babylon Gaussian Splatting Mesh",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions": "Splat-Positionen abrufen",
    "getSplatPositions": "Splat-Positionen abrufen",
    "bitbybit.babylon.gaussianSplatting.getSplatPositions_description": "Ruft Splat-Positionen des Gaussian Splat Meshes ab.",
    "bitbybit.babylon.camera.freezeProjectionMatrix": "Projektionsmatrix einfrieren",
    "camera": "Kamera",
    "freezeProjectionMatrix": "Projektionsmatrix einfrieren",
    "bitbybit.babylon.camera.freezeProjectionMatrix_description": "Friert die Projektionsmatrix der Kamera ein.",
    "adjust": "anpassen",
    "BABYLON.Camera": "Babylon-Kamera",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix": "Projektionsmatrix freigeben",
    "unfreezeProjectionMatrix": "Projektionsmatrix freigeben",
    "bitbybit.babylon.camera.unfreezeProjectionMatrix_description": "Gibt die Projektionsmatrix der Kamera frei.",
    "bitbybit.babylon.camera.setPosition": "Position festlegen",
    "bitbybit.babylon.camera.setPosition_description": "Ändert die Position einer Kamera.",
    "BABYLON.TargetCamera": "Babylon-Zielkamera",
    "bitbybit.babylon.camera.getPosition": "Position abrufen",
    "bitbybit.babylon.camera.getPosition_description": "Ruft die Position einer Kamera ab.",
    "bitbybit.babylon.camera.setTarget": "Ziel festlegen",
    "setTarget": "Ziel festlegen",
    "bitbybit.babylon.camera.setTarget_description": "Ändert das Ziel einer Kamera.",
    "target": "Ziel",
    "bitbybit.babylon.camera.getTarget": "Ziel abrufen",
    "getTarget": "Ziel abrufen",
    "bitbybit.babylon.camera.getTarget_description": "Ruft das Ziel einer Kamera ab.",
    "bitbybit.babylon.camera.setSpeed": "Geschwindigkeit festlegen",
    "setSpeed": "Geschwindigkeit festlegen",
    "bitbybit.babylon.camera.setSpeed_description": "Ändert die Geschwindigkeit einer Kamera.",
    "speed": "Geschwindigkeit",
    "bitbybit.babylon.camera.getSpeed": "Geschwindigkeit abrufen",
    "getSpeed": "Geschwindigkeit abrufen",
    "bitbybit.babylon.camera.getSpeed_description": "Ruft die Geschwindigkeit einer Kamera ab.",
    "bitbybit.babylon.camera.setMinZ": "Min Z festlegen",
    "setMinZ": "Min Z festlegen",
    "bitbybit.babylon.camera.setMinZ_description": "Ändert den MinZ-Wert einer Kamera.",
    "minZ": "Min Z",
    "bitbybit.babylon.camera.setMaxZ": "Max Z festlegen",
    "setMaxZ": "Max Z festlegen",
    "bitbybit.babylon.camera.setMaxZ_description": "Ändert den MaxZ-Wert einer Kamera.",
    "maxZ": "Max Z",
    "bitbybit.babylon.camera.makeCameraOrthographic": "Kamera orthografisch machen",
    "makeCameraOrthographic": "Kamera orthografisch machen",
    "bitbybit.babylon.camera.makeCameraOrthographic_description": "Ändert den Modus der Kamera auf orthographisch.",
    "orthoLeft": "Ortho links",
    "orthoRight": "Ortho rechts",
    "orthoBottom": "Ortho unten",
    "orthoTop": "Ortho oben",
    "bitbybit.babylon.camera.makeCameraPerspective": "Kamera perspektivisch machen",
    "makeCameraPerspective": "Kamera perspektivisch machen",
    "bitbybit.babylon.camera.makeCameraPerspective_description": "Ändert den Modus einer Kamera auf perspektivisch.",
    "bitbybit.babylon.camera.free.create": "freie Kamera",
    "free": "frei",
    "bitbybit.babylon.camera.free.create_description": "Erstellt eine freie Kamera.",
    "bitbybit.babylon.camera.arcRotate.create": "Bogenrotationskamera",
    "arcRotate": "Bogenrotation",
    "bitbybit.babylon.camera.arcRotate.create_description": "Erstellt eine Kamera, die um ein bestimmtes Ziel rotiert, während sie dem Bogenpfad folgt. Diese Kamera eignet sich für einfache 3D-Navigation und ist eine Standardkamera, die von BitByBit verwendet wird.",
    "radius": "Radius",
    "alpha": "Alpha",
    "beta": "Beta",
    "lowerRadiusLimit": "unterer Radiusgrenzwert",
    "upperRadiusLimit": "oberer Radiusgrenzwert",
    "lowerAlphaLimit": "unterer Alphagrenzwert",
    "upperAlphaLimit": "oberer Alphagrenzwert",
    "lowerBetaLimit": "unterer Betagrenzwert",
    "upperBetaLimit": "oberer Betagrenzwert",
    "angularSensibilityX": "Winkelempfindlichkeit X",
    "angularSensibilityY": "Winkelempfindlichkeit Y",
    "panningSensibility": "Schwenkempfindlichkeit",
    "wheelPrecision": "Radpräzision",
    "bitbybit.babylon.camera.target.create": "Zielkamera",
    "bitbybit.babylon.camera.target.create_description": "Erstellt eine Zielkamera.",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience": "immersives AR-Erlebnis",
    "webXr": "Web XR",
    "simple": "einfach",
    "createImmersiveARExperience": "immersives AR-Erlebnis",
    "bitbybit.babylon.webXr.simple.createImmersiveARExperience_description": "Erstellt eine Standard-XR-Erfahrung im Immersive-AR-Modus.",
    "scene": "Szene",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation": "Standard-XR-Erlebnis mit Teleportation",
    "createDefaultXRExperienceWithTeleportation": "Standard-XR-Erlebnis mit Teleportation",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportation_description": "Erstellt eine Standard-XR-Erfahrung mit Teleportation, die sehr einfach ist und für einfache Szenarien funktioniert.",
    "groundMeshes": "Boden-Meshes",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn": "Standard-XR-Erlebnis mit Teleportation Rück traced",
    "createDefaultXRExperienceWithTeleportationReturn": "Standard-XR-Erlebnis mit Teleportation Rückgabe",
    "bitbybit.babylon.webXr.simple.createDefaultXRExperienceWithTeleportationReturn_description": "Erstellt eine Standard-XR-Erfahrung mit Teleportation, die sehr einfach ist und für einfache Szenarien funktioniert.",
    "bitbybit.babylon.node.drawNode": "Knoten zeichnen",
    "node": "Knoten",
    "drawNode": "Knoten zeichnen",
    "bitbybit.babylon.node.drawNode_description": "Zeichnet einen Knoten gegebener Größe mit gegebenen Farben für jede Achse.",
    "BABYLON.TransformNode": "Babylon-Transformationsknoten",
    "bitbybit.babylon.node.drawNodes": "Knoten zeichnen",
    "drawNodes": "Knoten zeichnen",
    "bitbybit.babylon.node.drawNodes_description": "Zeichnet Knoten gegebener Größe mit gegebenen Farben für jede Achse.",
    "nodes": "Knoten",
    "BABYLON.TransformNode[]": "Babylon-Transformationsknoten-Array",
    "bitbybit.babylon.node.createNodeFromRotation": "Knoten aus Rotation erstellen",
    "createNodeFromRotation": "Knoten aus Rotation erstellen",
    "bitbybit.babylon.node.createNodeFromRotation_description": "Erstellt einen Knoten am Ursprung mit den gegebenen Rotationen im übergeordneten Koordinatensystem.",
    "parent": "Elternteil",
    "BABYLON.TransformNode | null": "Babylon-Transformationsknoten oder null",
    "origin": "Ursprung",
    "bitbybit.babylon.node.createWorldNode": "Welknoten",
    "createWorldNode": "Welknoten",
    "bitbybit.babylon.node.createWorldNode_description": "Erstellt einen Weltknoten, der den Wurzelknoten als Elternteil hat.",
    "bitbybit.babylon.node.getAbsoluteForwardVector": "absoluten Vorwärtsvektor abrufen",
    "getAbsoluteForwardVector": "absoluten Vorwärtsvektor abrufen",
    "bitbybit.babylon.node.getAbsoluteForwardVector_description": "Ruft den absoluten vorwärts gerichteten Vektor im Weltraum ab.",
    "bitbybit.babylon.node.getAbsoluteRightVector": "absoluten Rechtsvektor abrufen",
    "getAbsoluteRightVector": "absoluten Rechtsvektor abrufen",
    "bitbybit.babylon.node.getAbsoluteRightVector_description": "Ruft den absoluten rechts gerichteten Vektor im Weltraum ab.",
    "bitbybit.babylon.node.getAbsoluteUpVector": "absoluten Aufwärtsvektor abrufen",
    "getAbsoluteUpVector": "absoluten Aufwärtsvektor abrufen",
    "bitbybit.babylon.node.getAbsoluteUpVector_description": "Ruft den absoluten aufwärts gerichteten Vektor im Weltraum ab.",
    "bitbybit.babylon.node.getAbsolutePosition": "absolute Position abrufen",
    "bitbybit.babylon.node.getAbsolutePosition_description": "Ruft die absolute Position des Knotens als Ursprungsvektor im Weltraum ab.",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation": "absolute Rotationstransformation abrufen",
    "getAbsoluteRotationTransformation": "absolute Rotationstransformation abrufen",
    "bitbybit.babylon.node.getAbsoluteRotationTransformation_description": "Ruft die absolute Rotation des Knotens als Transformationsmatrix ab, kodiert in einem Array von 16 Zahlen.",
    "bitbybit.babylon.node.getRotationTransformation": "Rotationstransformation abrufen",
    "getRotationTransformation": "Rotationstransformation abrufen",
    "bitbybit.babylon.node.getRotationTransformation_description": "Ruft die Rotation des Knotens im lokalen übergeordneten Koordinatenraum als Transformationsmatrix ab, kodiert in einem Array von 16 Zahlen.",
    "bitbybit.babylon.node.getChildren": "Kinder abrufen",
    "getChildren": "Kinder abrufen",
    "bitbybit.babylon.node.getChildren_description": "Ruft die Kinder des Knotens ab.",
    "bitbybit.babylon.node.getParent": "Elternteil abrufen",
    "bitbybit.babylon.node.getParent_description": "Ruft das übergeordnete Element des Knotens ab.",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace": "Position im lokalen Raum abrufen",
    "getPositionExpressedInLocalSpace": "Position im lokalen Raum abrufen",
    "bitbybit.babylon.node.getPositionExpressedInLocalSpace_description": "Ruft die Position des Knotens ausgedrückt im lokalen Raum ab.",
    "bitbybit.babylon.node.getRootNode": "Wurzelknoten abrufen",
    "getRootNode": "Wurzelknoten abrufen",
    "bitbybit.babylon.node.getRootNode_description": "Ruft den Wurzelknoten ab.",
    "bitbybit.babylon.node.getRotation": "Rotation abrufen",
    "bitbybit.babylon.node.getRotation_description": "Ruft die Euler-Rotationen ab.",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition": "um Achse mit Position rotieren",
    "bitbybit.babylon.node.rotateAroundAxisWithPosition_description": "Rotiert den Knoten um eine Achse und eine gegebene Position um einen gegebenen Winkel.",
    "bitbybit.babylon.node.rotate": "rotieren",
    "bitbybit.babylon.node.rotate_description": "Rotiert den Knoten um den Ursprung und eine gegebene Achse.",
    "bitbybit.babylon.node.setAbsolutePosition": "absolute Position festlegen",
    "setAbsolutePosition": "absolute Position festlegen",
    "bitbybit.babylon.node.setAbsolutePosition_description": "Setzt die absolute Position des Knotens.",
    "bitbybit.babylon.node.setDirection": "Richtung festlegen",
    "setDirection": "Richtung festlegen",
    "bitbybit.babylon.node.setDirection_description": "Setzt die Richtung des Knotens.",
    "direction": "Richtung",
    "number[]": "Zahlen-Array",
    "bitbybit.babylon.node.setParent": "Elternteil festlegen",
    "bitbybit.babylon.node.setParent_description": "Setzt das neue übergeordnete Element für den Knoten.",
    "parentNode": "Elternknoten",
    "bitbybit.babylon.node.translate": "verschieben",
    "translate": "verschieben",
    "bitbybit.babylon.node.translate_description": "Verschiebt den Knoten um einen gegebenen Richtungsvektor und eine Distanz.",
    "bitbybit.babylon.scene.backgroundColour": "Hintergrundfarbe",
    "backgroundColour": "Hintergrundfarbe",
    "bitbybit.babylon.scene.backgroundColour_description": "Ändert die Hintergrundfarbe der Szene für den 3D-Raum.",
    "environment": "Umgebung",
    "colour": "Farbe",
    "bitbybit.babylon.scene.activateCamera": "Kamera aktivieren",
    "activateCamera": "Kamera aktivieren",
    "bitbybit.babylon.scene.activateCamera_description": "Aktiviert die Kamera, indem die aktuell aktive Kamera überschrieben wird.",
    "bitbybit.babylon.scene.useRightHandedSystem": "rechtshändiges System verwenden",
    "useRightHandedSystem": "rechtshändiges System verwenden",
    "bitbybit.babylon.scene.useRightHandedSystem_description": "Verwendet ein rechtshändiges System.",
    "system": "System",
    "use": "verwenden",
    "bitbybit.babylon.scene.drawPointLightNoReturn": "Punktlicht ohne Rückgabe zeichnen",
    "drawPointLightNoReturn": "Punktlicht ohne Rückgabe zeichnen",
    "bitbybit.babylon.scene.drawPointLightNoReturn_description": "Erstellt und zeichnet ein Punktlicht in der Szene, gibt aber nichts aus.",
    "lights": "Lichter",
    "intensity": "Intensität",
    "diffuse": "Diffus",
    "specular": "Spekular",
    "shadowGeneratorMapSize": "Schattengeneratorkartengröße",
    "enableShadows": "Schatten aktivieren",
    "shadowDarkness": "Schattendunkelheit",
    "shadowUsePercentageCloserFiltering": "Schattenprozentsatz näher filtern",
    "shadowContactHardeningLightSizeUVRatio": "Schattenkontakthärtung Lichtgröße UV-Verhältnis",
    "shadowBias": "Schattenbias",
    "shadowNormalBias": "Schattennormalbias",
    "shadowMaxZ": "Schatten Max Z",
    "shadowMinZ": "Schatten Min Z",
    "bitbybit.babylon.scene.getShadowGenerators": "Schattengeneratoren abrufen",
    "getShadowGenerators": "Schattengeneratoren abrufen",
    "bitbybit.babylon.scene.getShadowGenerators_description": "Ruft Schattengeneratoren ab, die von Lichtquellen über BitByBit hinzugefügt wurden.",
    "bitbybit.babylon.scene.drawPointLight": "Punktlicht zeichnen",
    "drawPointLight": "Punktlicht zeichnen",
    "bitbybit.babylon.scene.drawPointLight_description": "Erstellt und zeichnet ein Punktlicht in der Szene.",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn": "Richtungslicht ohne Rückgabe zeichnen",
    "drawDirectionalLightNoReturn": "Richtungslicht ohne Rückgabe zeichnen",
    "bitbybit.babylon.scene.drawDirectionalLightNoReturn_description": "Erstellt und zeichnet ein gerichtetes Licht in der Szene.",
    "bitbybit.babylon.scene.drawDirectionalLight": "Richtungslicht zeichnen",
    "drawDirectionalLight": "Richtungslicht zeichnen",
    "bitbybit.babylon.scene.drawDirectionalLight_description": "Erstellt und zeichnet ein gerichtetes Licht in der Szene.",
    "bitbybit.babylon.scene.getActiveCamera": "aktive Kamera abrufen",
    "getActiveCamera": "aktive Kamera abrufen",
    "bitbybit.babylon.scene.getActiveCamera_description": "Ruft die aktive Kamera der Szene ab.",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera": "aktive Bogenrotationskamera anpassen",
    "adjustActiveArcRotateCamera": "aktive Bogenrotationskamera anpassen",
    "bitbybit.babylon.scene.adjustActiveArcRotateCamera_description": "Passt die aktive Arc-Rotate-Kamera mit Konfigurationsparametern an.",
    "lookAt": "anschauen",
    "bitbybit.babylon.scene.clearAllDrawn": "alles Gezeichnete löschen",
    "clearAllDrawn": "alles Gezeich Conductor löschen",
    "bitbybit.babylon.scene.clearAllDrawn_description": "Löscht alle gezeichneten Objekte in der 3D-Szene.",
    "bitbybit.babylon.scene.enableSkybox": "Himmelbox aktivieren",
    "enableSkybox": "Himmelbox aktivieren",
    "bitbybit.babylon.scene.enableSkybox_description": "Aktiviert die Skybox.",
    "skybox": "Himmelbox",
    "Base.skyboxEnum": "Basis-Himmelbox-Enum",
    "blur": "Unschärfe",
    "environmentIntensity": "Umgebungsintensität",
    "bitbybit.babylon.scene.fog": "Nebel",
    "fog": "Nebel",
    "bitbybit.babylon.scene.fog_description": "Aktiviert den Nebelmodus.",
    "mode": "Modus",
    "Base.fogModeEnum": "Basis-Nebelmodus-Enum",
    "color": "Farbe",
    "density": "Dichte",
    "start": "Start",
    "end": "Ende",
    "bitbybit.babylon.transforms.rotationCenterAxis": "Rotationszentrum-Achse",
    "transforms": "Transformationen",
    "rotationCenterAxis": "Rotationszentrum-Achse",
    "bitbybit.babylon.transforms.rotationCenterAxis_description": "Erstellt eine Rotationstransformation um das Zentrum und eine Achse.",
    "center": "Zentrum",
    "bitbybit.babylon.transforms.rotationCenterX": "Rotationszentrum X",
    "rotationCenterX": "Rotationszentrum X",
    "bitbybit.babylon.transforms.rotationCenterX_description": "Erstellt eine Rotationstransformation um das Zentrum und eine X-Achse.",
    "bitbybit.babylon.transforms.rotationCenterY": "Rotationszentrum Y",
    "rotationCenterY": "Rotationszentrum Y",
    "bitbybit.babylon.transforms.rotationCenterY_description": "Erstellt eine Rotationstransformation um das Zentrum und eine Y-Achse.",
    "bitbybit.babylon.transforms.rotationCenterZ": "Rotationszentrum Z",
    "rotationCenterZ": "Rotationszentrum Z",
    "bitbybit.babylon.transforms.rotationCenterZ_description": "Erstellt eine Rotationstransformation um das Zentrum und eine Z-Achse.",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll": "Rotationszentrum Gieren Nicken Rollen",
    "rotationCenterYawPitchRoll": "Rotationszentrum Gieren Nicken Rollen",
    "bitbybit.babylon.transforms.rotationCenterYawPitchRoll_description": "Erstellt eine Rotationstransformation mit Gier-, Nick- und Rollwinkel.",
    "bitbybit.babylon.transforms.scaleCenterXYZ": "Skalierungszentrum XYZ",
    "scaleCenterXYZ": "Skalierungszentrum XYZ",
    "bitbybit.babylon.transforms.scaleCenterXYZ_description": "Skalierungstransformation um Zentrum und XYZ-Richtungen.",
    "scaleXyz": "Skalierung XYZ",
    "bitbybit.babylon.transforms.scaleXYZ": "Skalierung XYZ",
    "scaleXYZ": "Skalierung XYZ",
    "bitbybit.babylon.transforms.scaleXYZ_description": "Erstellt die Skalierungstransformation in X-, Y- und Z-Richtung.",
    "bitbybit.babylon.transforms.uniformScale": "einheitliche Skalierung",
    "uniformScale": "einheitliche Skalierung",
    "bitbybit.babylon.transforms.uniformScale_description": "Erstellt eine gleichmäßige Skalierungstransformation.",
    "bitbybit.babylon.transforms.uniformScaleFromCenter": "einheitliche Skalierung vom Zentrum",
    "uniformScaleFromCenter": "einheitliche Skalierung vom Zentrum",
    "bitbybit.babylon.transforms.uniformScaleFromCenter_description": "Erstellt eine gleichmäßige Skalierungstransformation vom Zentrum aus.",
    "bitbybit.babylon.transforms.translationXYZ": "Verschiebung XYZ",
    "translationXYZ": "Verschiebung XYZ",
    "bitbybit.babylon.transforms.translationXYZ_description": "Erstellt die Verschiebungstransformation.",
    "translation": "Verschiebung",
    "bitbybit.babylon.transforms.translationsXYZ": "Verschiebungen XYZ",
    "translationsXYZ": "Verschiebungen XYZ",
    "bitbybit.babylon.transforms.translationsXYZ_description": "Erstellt die Verschiebungstransformation.",
    "translations": "Verschiebungen",
    "Base.Vector3[]": "Basisvektor-3-Array",
    "bitbybit.babylon.io.loadAssetIntoScene": "Asset in Szene laden",
    "io": "IO",
    "loadAssetIntoScene": "Asset in Szene laden",
    "bitbybit.babylon.io.loadAssetIntoScene_description": "Importiert Mesh aus dem Asset, das Sie für das Projekt hochgeladen haben. Sie müssen Ihre Assets über die Projektmanagementseite in Ihr Projekt hochladen.",
    "load": "laden",
    "assetFile": "Asset-Datei",
    "File": "Datei",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn": "Asset in Szene ohne Rückgabe laden",
    "loadAssetIntoSceneNoReturn": "Asset in Szene ohne Rückgabe laden",
    "bitbybit.babylon.io.loadAssetIntoSceneNoReturn_description": "Importiert Mesh aus dem Asset, das Sie für das Projekt hochgeladen haben. Sie müssen Ihre Assets über die Projektmanagementseite in Ihr Projekt hochladen.",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl": "Asset aus Root-URL in Szene laden",
    "loadAssetIntoSceneFromRootUrl": "Asset aus Root-URL in Szene laden",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrl_description": "Importiert Mesh von der Asset-URL, die Sie in einen zugänglichen Web-Speicher hochgeladen haben. Beachten Sie, dass Dateien öffentlich zugänglich sein müssen, damit dies funktioniert. Stellen Sie sicher, dass CORS-Zugriff für die Assets aktiviert ist.",
    "rootUrl": "Root-URL",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn": "Asset aus Root-URL in Szene ohne Rückgabe laden",
    "loadAssetIntoSceneFromRootUrlNoReturn": "Asset aus Root-URL in Szene ohne Rückgabe laden",
    "bitbybit.babylon.io.loadAssetIntoSceneFromRootUrlNoReturn_description": "Importiert Mesh von der Asset-URL, die Sie in einen zugänglichen Web-Speicher hochgeladen haben. Beachten Sie, dass Dateien öffentlich zugänglich sein müssen, damit dies funktioniert. Stellen Sie sicher, dass CORS-Zugriff für die Assets aktiviert ist.",
    "bitbybit.babylon.io.exportBabylon": "Babylon exportieren",
    "exportBabylon": "Babylon exportieren",
    "bitbybit.babylon.io.exportBabylon_description": "Exportiert die gesamte Szene in das .babylon-Szenenformat. Sie können sie dann in BabylonJS-Editoren weiter bearbeiten.",
    "export": "exportieren",
    "fileName": "Dateiname",
    "bitbybit.babylon.io.exportGLB": "GLB exportieren",
    "exportGLB": "GLB exportieren",
    "bitbybit.babylon.io.exportGLB_description": "Exportiert die gesamte Szene in das .glb-Format. Dieses Dateiformat ist zum Industriestandard für Web-Modelle geworden.",
    "discardSkyboxAndGrid": "Himmelbox und Gitter verwerfen",
    "bitbybit.babylon.io.exportMeshToStl": "Mesh nach STL exportieren",
    "exportMeshToStl": "Mesh nach STL exportieren",
    "bitbybit.babylon.io.exportMeshToStl_description": "Exportiert das Mesh mit seinen Kindern nach STL.",
    "bitbybit.babylon.io.exportMeshesToStl": "Meshes nach STL exportieren",
    "exportMeshesToStl": "Meshes nach STL exportieren",
    "bitbybit.babylon.io.exportMeshesToStl_description": "Exportiert die Meshes nach STL.",
    "meshes": "Meshes",
    "bitbybit.babylon.ray.createPickingRay": "Auswahlstrahl",
    "ray": "Strahl",
    "createPickingRay": "Auswahlstrahl",
    "bitbybit.babylon.ray.createPickingRay_description": "Erstellt einen Auswahlstrahl (Picking Ray) von der aktuellen Mausposition in der aktiven Kamera.",
    "bitbybit.babylon.ray.createRay": "Strahl",
    "createRay": "Strahl",
    "bitbybit.babylon.ray.createRay_description": "Erstellt einen Strahl, der am Ursprung beginnt, einen Richtungsvektor und optional eine Länge hat.",
    "length": "Länge",
    "bitbybit.babylon.ray.createRayFromTo": "Strahl von bis",
    "createRayFromTo": "Strahl von bis",
    "bitbybit.babylon.ray.createRayFromTo_description": "Erstellt einen Strahl von einem Punkt zu einem anderen.",
    "from": "von",
    "to": "bis",
    "bitbybit.babylon.ray.getOrigin": "Ursprung abrufen",
    "getOrigin": "Ursprung abrufen",
    "bitbybit.babylon.ray.getOrigin_description": "Ruft den Ursprung des Strahls ab.",
    "BABYLON.Ray": "Babylon-Strahl",
    "bitbybit.babylon.ray.getDirection": "Richtung abrufen",
    "getDirection": "Richtung abrufen",
    "bitbybit.babylon.ray.getDirection_description": "Ruft die Richtung des Strahls ab.",
    "bitbybit.babylon.ray.getLength": "Länge abrufen",
    "getLength": "Länge abrufen",
    "bitbybit.babylon.ray.getLength_description": "Ruft die Länge des Strahls ab.",
    "bitbybit.babylon.pick.pickWithRay": "mit Strahl auswählen",
    "pick": "auswählen",
    "pickWithRay": "mit Strahl auswählen",
    "bitbybit.babylon.pick.pickWithRay_description": "Ruft ein Treffergebnis der Auswahl mit Strahl ab.",
    "bitbybit.babylon.pick.pickWithPickingRay": "mit Auswahlstrahl auswählen",
    "pickWithPickingRay": "mit Auswahlstrahl auswählen",
    "bitbybit.babylon.pick.pickWithPickingRay_description": "Wählt mit Auswahlstrahl der aktuellen Mausposition in der aktiven Kamera aus.",
    "bitbybit.babylon.pick.getDistance": "Entfernung abrufen",
    "getDistance": "Entfernung abrufen",
    "bitbybit.babylon.pick.getDistance_description": "Ruft die Entfernung zum Objekt ab, wenn ein Auswahlergebnis existiert.",
    "get from pick info": "aus Auswahlinfo abrufen",
    "pickInfo": "Auswahlinfo",
    "BABYLON.PickingInfo": "Babylon-Auswahlinfo",
    "bitbybit.babylon.pick.getPickedMesh": "ausgewähltes Mesh abrufen",
    "getPickedMesh": "ausgewähltes Mesh abrufen",
    "bitbybit.babylon.pick.getPickedMesh_description": "Ruft das ausgewählte Mesh ab.",
    "bitbybit.babylon.pick.getPickedPoint": "ausgewählten Punkt abrufen",
    "getPickedPoint": "ausgewählten Punkt abrufen",
    "bitbybit.babylon.pick.getPickedPoint_description": "Ruft den ausgewählten Punkt ab.",
    "bitbybit.babylon.pick.hit": "Treffer",
    "hit": "Treffer",
    "bitbybit.babylon.pick.hit_description": "Prüft, ob der Auswahlstrahl etwas in der Szene getroffen hat oder nicht.",
    "bitbybit.babylon.pick.getSubMeshId": "Sub-Mesh-ID abrufen",
    "getSubMeshId": "Sub-Mesh-ID abrufen",
    "bitbybit.babylon.pick.getSubMeshId_description": "Ruft die eindeutige Submesh-ID ab, wenn es ausgewählt wurde.",
    "bitbybit.babylon.pick.getSubMeshFaceId": "Sub-Mesh-Flächen-ID abrufen",
    "getSubMeshFaceId": "Sub-Mesh-Flächen-ID abrufen",
    "bitbybit.babylon.pick.getSubMeshFaceId_description": "Ruft die eindeutige Submesh-Flächen-ID ab, wenn sie ausgewählt wurde.",
    "bitbybit.babylon.pick.getBU": "BU abrufen",
    "getBU": "BU abrufen",
    "bitbybit.babylon.pick.getBU_description": "Ruft die baryzentrische U-Koordinate ab, die bei der Berechnung der Texturkoordinaten der Kollision verwendet wird.",
    "bitbybit.babylon.pick.getBV": "BV abrufen",
    "getBV": "BV abrufen",
    "bitbybit.babylon.pick.getBV_description": "Ruft die baryzentrische V-Koordinate ab, die bei der Berechnung der Texturkoordinaten der Kollision verwendet wird.",
    "bitbybit.babylon.pick.getPickedSprite": "ausgewähltes Sprite abrufen",
    "getPickedSprite": "ausgewähltes Sprite abrufen",
    "bitbybit.babylon.pick.getPickedSprite_description": "Ruft das ausgewählte Sprite ab.",
    "bitbybit.babylon.material.pbrMetallicRoughness.create": "PBR metallische Rauheit",
    "pbrMetallicRoughness": "PBR metallische Rauheit",
    "bitbybit.babylon.material.pbrMetallicRoughness.create_description": "Erstellt ein PBR Metallic-Roughness Material.",
    "baseColor": "Basisfarbe",
    "emissiveColor": "Emissionsfarbe",
    "metallic": "metallisch",
    "roughness": "Rauheit",
    "zOffset": "Z-Versatz",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor": "Basisfarbe festlegen",
    "setBaseColor": "Basisfarbe festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseColor_description": "Setzt die Basisfarbe des Materials.",
    "BABYLON.PBRMetallicRoughnessMaterial": "Babylon PBR metallisches Rauheitsmaterial",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic": "Metallisch festlegen",
    "setMetallic": "Metallisch festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setMetallic_description": "Setzt die Metallic-Eigenschaft des Materials.",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness": "Rauheit festlegen",
    "setRoughness": "Rauheit festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setRoughness_description": "Setzt die Rauheit des Materials.",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha": "Alpha festlegen",
    "setAlpha": "Alpha festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setAlpha_description": "Setzt den Alpha-Wert des Materials.",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling": "Rückseitenentfernung festlegen",
    "setBackFaceCulling": "Rückseitenentfernung festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBackFaceCulling_description": "Setzt das Back-Face-Culling des Materials.",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture": "Basistextur festlegen",
    "setBaseTexture": "Basistextur festlegen",
    "bitbybit.babylon.material.pbrMetallicRoughness.setBaseTexture_description": "Setzt die Textur des Materials.",
    "baseTexture": "Basistextur",
    "BABYLON.Texture": "Babylon-Textur",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor": "Basisfarbe abrufen",
    "getBaseColor": "Basisfarbe abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseColor_description": "Ruft die Basisfarbe des Materials ab.",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic": "Metallisch abrufen",
    "getMetallic": "Metallisch abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getMetallic_description": "Ruft die Metallic-Eigenschaft des Materials ab.",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness": "Rauheit abrufen",
    "getRoughness": "Rauheit abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getRoughness_description": "Ruft die Rauheit des Materials ab.",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha": "Alpha abrufen",
    "getAlpha": "Alpha abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getAlpha_description": "Ruft den Alpha-Wert des Materials ab.",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling": "Rückseitenentfernung abrufen",
    "getBackFaceCulling": "Rückseitenentfernung abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBackFaceCulling_description": "Ruft das Back-Face-Culling des Materials ab.",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture": "Basistextur abrufen",
    "getBaseTexture": "Basistextur abrufen",
    "bitbybit.babylon.material.pbrMetallicRoughness.getBaseTexture_description": "Ruft die Basistextur des Materials ab.",
    "bitbybit.babylon.material.skyMaterial.create": "Himmelmaterial",
    "skyMaterial": "Himmelmaterial",
    "bitbybit.babylon.material.skyMaterial.create_description": "Erstellt Himmelsmaterial.",
    "luminance": "Luminanz",
    "turbidity": "Trübung",
    "rayleigh": "Rayleigh",
    "mieCoefficient": "Mie-Koeffizient",
    "mieDirectionalG": "Mie-Richtung G",
    "inclination": "Neigung",
    "azimuth": "Azimut",
    "sunPosition": "Sonnenposition",
    "useSunPosition": "Sonnenposition verwenden",
    "cameraOffset": "Kameraoffset",
    "up": "nach oben",
    "dithering": "Dithering",
    "bitbybit.babylon.material.skyMaterial.setLuminance": "Luminanz festlegen",
    "setLuminance": "Luminanz festlegen",
    "bitbybit.babylon.material.skyMaterial.setLuminance_description": "Setzt die Luminanz des Himmelsmaterials.",
    "MATERIALS.SkyMaterial": "Materialien Himmelmaterial",
    "bitbybit.babylon.material.skyMaterial.setTurbidity": "Trübung festlegen",
    "setTurbidity": "Trübung festlegen",
    "bitbybit.babylon.material.skyMaterial.setTurbidity_description": "Setzt die Trübung des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setRayleigh": "Rayleigh festlegen",
    "setRayleigh": "Rayleigh festlegen",
    "bitbybit.babylon.material.skyMaterial.setRayleigh_description": "Setzt den Rayleigh-Wert des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient": "Mie-Koeffizient festlegen",
    "setMieCoefficient": "Mie-Koeffizient festlegen",
    "bitbybit.babylon.material.skyMaterial.setMieCoefficient_description": "Setzt den Mie-Koeffizienten des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG": "Mie-Richtung G festlegen",
    "setMieDirectionalG": "Mie-Richtung G festlegen",
    "bitbybit.babylon.material.skyMaterial.setMieDirectionalG_description": "Setzt das Mie-Directional-G des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setDistance": "Entfernung festlegen",
    "setDistance": "Entfernung festlegen",
    "bitbybit.babylon.material.skyMaterial.setDistance_description": "Setzt die Entfernung des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setInclination": "Neigung festlegen",
    "setInclination": "Neigung festlegen",
    "bitbybit.babylon.material.skyMaterial.setInclination_description": "Setzt die Neigung des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setAzimuth": "Azimut festlegen",
    "setAzimuth": "Azimut festlegen",
    "bitbybit.babylon.material.skyMaterial.setAzimuth_description": "Setzt den Azimut des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setSunPosition": "Sonnenposition festlegen",
    "setSunPosition": "Sonnenposition festlegen",
    "bitbybit.babylon.material.skyMaterial.setSunPosition_description": "Setzt die Sonnenposition des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition": "Sonnenposition verwenden festlegen",
    "setUseSunPosition": "Sonnenposition verwenden festlegen",
    "bitbybit.babylon.material.skyMaterial.setUseSunPosition_description": "Setzt die Verwendung der Sonnenposition des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset": "Kameraoffset festlegen",
    "setCameraOffset": "Kameraoffset festlegen",
    "bitbybit.babylon.material.skyMaterial.setCameraOffset_description": "Setzt den Kameraversatz des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setUp": "Aufwärts festlegen",
    "setUp": "Aufwärts festlegen",
    "bitbybit.babylon.material.skyMaterial.setUp_description": "Setzt das Up des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.setDithering": "Dithering festlegen",
    "setDithering": "Dithering festlegen",
    "bitbybit.babylon.material.skyMaterial.setDithering_description": "Setzt das Dithering des Himmelsmaterials.",
    "bitbybit.babylon.material.skyMaterial.getLuminance": "Luminanz abrufen",
    "getLuminance": "Luminanz abrufen",
    "bitbybit.babylon.material.skyMaterial.getLuminance_description": "Ruft die Luminanz des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getTurbidity": "Trübung abrufen",
    "getTurbidity": "Trübung abrufen",
    "bitbybit.babylon.material.skyMaterial.getTurbidity_description": "Ruft die Trübung des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getRayleigh": "Rayleigh abrufen",
    "getRayleigh": "Rayleigh abrufen",
    "bitbybit.babylon.material.skyMaterial.getRayleigh_description": "Ruft den Rayleigh-Wert des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient": "Mie-Koeffizient abrufen",
    "getMieCoefficient": "Mie-Koeffizient abrufen",
    "bitbybit.babylon.material.skyMaterial.getMieCoefficient_description": "Ruft den Mie-Koeffizienten des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG": "Mie-Richtung G abrufen",
    "getMieDirectionalG": "Mie-Richtung G abrufen",
    "bitbybit.babylon.material.skyMaterial.getMieDirectionalG_description": "Ruft das Mie-Directional-G des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getDistance": "Entfernung abrufen",
    "bitbybit.babylon.material.skyMaterial.getDistance_description": "Ruft die Entfernung des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getInclination": "Neigung abrufen",
    "getInclination": "Neigung abrufen",
    "bitbybit.babylon.material.skyMaterial.getInclination_description": "Ruft die Neigung des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getAzimuth": "Azimut abrufen",
    "getAzimuth": "Azimut abrufen",
    "bitbybit.babylon.material.skyMaterial.getAzimuth_description": "Ruft den Azimut des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getSunPosition": "Sonnenposition abrufen",
    "getSunPosition": "Sonnenposition abrufen",
    "bitbybit.babylon.material.skyMaterial.getSunPosition_description": "Ruft die Sonnenposition des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition": "Sonnenposition verwenden abrufen",
    "getUseSunPosition": "Sonnenposition verwenden abrufen",
    "bitbybit.babylon.material.skyMaterial.getUseSunPosition_description": "Ruft die Verwendung der Sonnenposition des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset": "Kameraoffset abrufen",
    "getCameraOffset": "Kameraoffset abrufen",
    "bitbybit.babylon.material.skyMaterial.getCameraOffset_description": "Ruft den Kameraversatz des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getUp": "Aufwärts abrufen",
    "getUp": "Aufwärts abrufen",
    "bitbybit.babylon.material.skyMaterial.getUp_description": "Ruft das Up des Himmelsmaterials ab.",
    "bitbybit.babylon.material.skyMaterial.getDithering": "Dithering abrufen",
    "getDithering": "Dithering abrufen",
    "bitbybit.babylon.material.skyMaterial.getDithering_description": "Ruft das Dithering des Himmelsmaterials ab.",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget": "Richtung zum Ziel festlegen",
    "shadowLight": "Schattenlicht",
    "setDirectionToTarget": "Richtung zum Ziel festlegen",
    "bitbybit.babylon.lights.shadowLight.setDirectionToTarget_description": "Setzt die Richtung des Schattenlichts.",
    "BABYLON.ShadowLight": "Babylon-Schattenlicht",
    "bitbybit.babylon.lights.shadowLight.setPosition": "Position festlegen",
    "bitbybit.babylon.lights.shadowLight.setPosition_description": "Setzt die Position des Schattenlichts.",
    "bitbybit.babylon.meshBuilder.createBox": "Box",
    "meshBuilder": "Mesh-Builder",
    "createBox": "Box",
    "bitbybit.babylon.meshBuilder.createBox_description": "Erstellt ein Kasten-Mesh.",
    "create simple": "einfach erstellen",
    "depth": "Tiefe",
    "sideOrientation": "Seitenorientierung",
    "BabylonMesh.sideOrientationEnum": "Babylon-Mesh-Seitenorientierungs-Enum",
    "bitbybit.babylon.meshBuilder.createCube": "Würfel",
    "createCube": "Würfel",
    "bitbybit.babylon.meshBuilder.createCube_description": "Erstellt ein Würfel-Mesh.",
    "bitbybit.babylon.meshBuilder.createSquarePlane": "quadratische Ebene",
    "createSquarePlane": "quadratische Ebene",
    "bitbybit.babylon.meshBuilder.createSquarePlane_description": "Erstellt ein quadratisches Ebenen-Mesh.",
    "bitbybit.babylon.meshBuilder.createSphere": "Kugel",
    "createSphere": "Kugel",
    "bitbybit.babylon.meshBuilder.createSphere_description": "Erstellt ein Kugel-Mesh.",
    "diameter": "Durchmesser",
    "segments": "Segmente",
    "bitbybit.babylon.meshBuilder.createIcoSphere": "Ikosaeder-Kugel",
    "createIcoSphere": "Ikosaeder-Kugel",
    "bitbybit.babylon.meshBuilder.createIcoSphere_description": "Erstellt eine Ikosaeder-Kugel.",
    "radiusX": "Radius X",
    "radiusY": "Radius Y",
    "radiusZ": "Radius Z",
    "flat": "flach",
    "bitbybit.babylon.meshBuilder.createDisc": "Scheibe",
    "createDisc": "Scheibe",
    "bitbybit.babylon.meshBuilder.createDisc_description": "Erstellt eine Scheibe.",
    "tessellation": "Tesselierung",
    "arc": "Bogen",
    "bitbybit.babylon.meshBuilder.createTorus": "Torus",
    "createTorus": "Torus",
    "bitbybit.babylon.meshBuilder.createTorus_description": "Erstellt ein Torus-Mesh.",
    "thickness": "Dicke",
    "bitbybit.babylon.meshBuilder.createTorusKnot": "Torusknoten",
    "createTorusKnot": "Torusknoten",
    "bitbybit.babylon.meshBuilder.createTorusKnot_description": "Erstellt ein Torusknoten-Mesh.",
    "tube": "Rohr",
    "radialSegments": "radiale Segmente",
    "tubularSegments": "tubulare Segmente",
    "p": "P",
    "q": "Q",
    "bitbybit.babylon.meshBuilder.createPolygon": "Polygon",
    "createPolygon": "Polygon",
    "bitbybit.babylon.meshBuilder.createPolygon_description": "Erstellt ein Polygon-Mesh.",
    "shape": "Form",
    "holes": "Löcher",
    "Base.Vector3[][]": "Basisvektor-3-Array-Array",
    "smoothingThreshold": "Glättungsschwelle",
    "wrap": "umwickeln",
    "bitbybit.babylon.meshBuilder.extrudePolygon": "Polygon extrudieren",
    "extrudePolygon": "Polygon extrudieren",
    "bitbybit.babylon.meshBuilder.extrudePolygon_description": "Erstellt ein extrudiertes Polygon-Mesh.",
    "bitbybit.babylon.meshBuilder.createTube": "Rohr",
    "createTube": "Rohr",
    "bitbybit.babylon.meshBuilder.createTube_description": "Erstellt ein Röhren-Mesh.",
    "path": "Pfad",
    "cap": "Kappe",
    "bitbybit.babylon.meshBuilder.createPolyhedron": "Polyeder",
    "createPolyhedron": "Polyeder",
    "bitbybit.babylon.meshBuilder.createPolyhedron_description": "Erstellt ein Polyeder-Mesh.",
    "type": "Typ",
    "sizeX": "Größe X",
    "sizeY": "Größe Y",
    "sizeZ": "Größe Z",
    "custom": "benutzerdefiniert",
    "bitbybit.babylon.meshBuilder.createGeodesic": "geodätisch",
    "createGeodesic": "geodätisch",
    "bitbybit.babylon.meshBuilder.createGeodesic_description": "Erstellt ein geodätisches Mesh.",
    "m": "M",
    "n": "N",
    "bitbybit.babylon.meshBuilder.createGoldberg": "Goldberg",
    "createGoldberg": "Goldberg",
    "bitbybit.babylon.meshBuilder.createGoldberg_description": "Erstellt ein Goldberg-Mesh.",
    "bitbybit.babylon.meshBuilder.createCapsule": "Kapsel",
    "createCapsule": "Kapsel",
    "bitbybit.babylon.meshBuilder.createCapsule_description": "Erstellt ein Kapsel-Mesh.",
    "orientation": "Orientierung",
    "capSubdivisions": "Kappenunterteilungen",
    "radiusTop": "Radius oben",
    "radiusBottom": "Radius unten",
    "topCapSubdivisions": "obere Kappenunterteilungen",
    "bottomCapSubdivisions": "untere Kappenunterteilungen",
    "bitbybit.babylon.meshBuilder.createCylinder": "Zylinder",
    "createCylinder": "Zylinder",
    "bitbybit.babylon.meshBuilder.createCylinder_description": "Erstellt ein Zylinder-Mesh.",
    "diameterTop": "Durchmesser oben",
    "diameterBottom": "Durchmesser unten",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe": "extrudierte Form",
    "createExtrudedSahpe": "extrudierte Form",
    "bitbybit.babylon.meshBuilder.createExtrudedSahpe_description": "Erstellt eine extrudierte Form.",
    "closeShape": "Form schließen",
    "closePath": "Pfad schließen",
    "bitbybit.babylon.meshBuilder.createRibbon": "Band",
    "createRibbon": "Band",
    "bitbybit.babylon.meshBuilder.createRibbon_description": "Erstellt ein Band-Mesh.",
    "pathArray": "Pfad-Array",
    "closeArray": "Array schließen",
    "offset": "Versatz",
    "bitbybit.babylon.meshBuilder.createLathe": "Drehmaschine",
    "createLathe": "Drehmaschine",
    "bitbybit.babylon.meshBuilder.createLathe_description": "Erstellt ein Lathe-Mesh (Drehkörper).",
    "closed": "geschlossen",
    "bitbybit.babylon.meshBuilder.createGround": "Boden",
    "createGround": "Boden",
    "bitbybit.babylon.meshBuilder.createGround_description": "Erstellt das Boden-Mesh.",
    "subdivisionsX": "Unterteilungen X",
    "subdivisionsY": "Unterteilungen Y",
    "bitbybit.babylon.meshBuilder.createRectanglePlane": "rechteckige Ebene",
    "createRectanglePlane": "rechteckige Ebene",
    "bitbybit.babylon.meshBuilder.createRectanglePlane_description": "Erstellt ein rechteckiges Ebenen-Mesh.",
    "bitbybit.babylon.texture.createSimple": "einfache Textur",
    "texture": "Textur",
    "createSimple": "einfach",
    "bitbybit.babylon.texture.createSimple_description": "Erstellt eine Textur von einer URL mit einigen grundlegenden Optionen. Wenn Sie das Asset über die Datei geladen haben, erstellen Sie eine Objekt-URL und übergeben Sie diese hier.",
    "invertY": "Y umkehren",
    "invertZ": "Z umkehren",
    "wAng": "Winkel",
    "uScale": "U-Skalierung",
    "vScale": "V-Skalierung",
    "uOffset": "U-Versatz",
    "vOffset": "V-Versatz",
    "samplingMode": "Abtastmodus",
    "samplingModeEnum": "Abtastmodus-Enum",
    "bitbybit.babylon.tools.createScreenshot": "Screenshot",
    "tools": "Werkzeuge",
    "createScreenshot": "Screenshot",
    "bitbybit.babylon.tools.createScreenshot_description": "Erstellt einen Screenshot der Szene.",
    "screenshots": "Screenshots",
    "mimeType": "MIME-Typ",
    "quality": "Qualität",
    "bitbybit.babylon.tools.createScreenshotAndDownload": "Screenshot und Download",
    "createScreenshotAndDownload": "Screenshot und Download",
    "bitbybit.babylon.tools.createScreenshotAndDownload_description": "Erstellt einen Screenshot der Szene und lädt die Datei herunter.",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI": "Vollbild-UI",
    "gui": "GUI",
    "advancedDynamicTexture": "erweiterte dynamische Textur",
    "createFullScreenUI": "Vollbild-UI",
    "bitbybit.babylon.gui.advancedDynamicTexture.createFullScreenUI_description": "erstellt Vollbild-UI",
    "spaces": "Räume",
    "foreground": "Vordergrund",
    "adaptiveScaling": "adaptive Skalierung",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh": "für Mesh",
    "createForMesh": "für Mesh",
    "bitbybit.babylon.gui.advancedDynamicTexture.createForMesh_description": "Erstellt eine erweiterte dynamische Textur für ein Mesh.",
    "BABYLON.AbstractMesh": "Babylon abstraktes Mesh",
    "supportPointerMove": "Zeigerbewegung unterstützen",
    "onlyAlphaTesting": "nur Alpha-Tests",
    "sampling": "Abtastung",
    "BabylonTexture.samplingModeEnum": "Babylon-Textur-Abtastmodus-Enum",
    "bitbybit.babylon.gui.control.changeControlPadding": "Steuerabstand ändern",
    "control": "Steuerung",
    "changeControlPadding": "Steuerabstand ändern",
    "bitbybit.babylon.gui.control.changeControlPadding_description": "Ändert den Innenabstand (Padding) für das Steuerelement.",
    "positioning": "Positionierung",
    "BABYLON.GUI.Control": "Babylon GUI-Steuerung",
    "paddingLeft": "Abstand links",
    "number | string": "Zahl oder Zeichenkette",
    "paddingRight": "Abstand rechts",
    "paddingTop": "Abstand oben",
    "paddingBottom": "Abstand unten",
    "bitbybit.babylon.gui.control.changeControlAlignment": "Steuerausrichtung ändern",
    "changeControlAlignment": "Steuerausrichtung ändern",
    "bitbybit.babylon.gui.control.changeControlAlignment_description": "Ändert die Ausrichtung für das Steuerelement.",
    "T": "T",
    "horizontalAlignment": "horizontale Ausrichtung",
    "horizontalAlignmentEnum": "horizontale Ausrichtungs-Enum",
    "verticalAlignment": "vertikale Ausrichtung",
    "verticalAlignmentEnum": "vertikale Ausrichtungs-Enum",
    "bitbybit.babylon.gui.control.cloneControl": "Steuerung klonen",
    "cloneControl": "Steuerung klonen",
    "bitbybit.babylon.gui.control.cloneControl_description": "Klont das Steuerelement.",
    "container": "Container",
    "BABYLON.GUI.Container": "Babylon GUI-Container",
    "host": "Host",
    "BABYLON.GUI.AdvancedDynamicTexture": "Babylon GUI erweiterte dynamische Textur",
    "bitbybit.babylon.gui.control.createControlObservableSelector": "Steuerung beobachtbarer Selektor",
    "createControlObservableSelector": "Steuerung beobachtbarer Selektor",
    "bitbybit.babylon.gui.control.createControlObservableSelector_description": "Erstellt den Selektor eines Observable für ein Steuerelement.",
    "selector": "Selektor",
    "controlObservableSelectorEnum": "Steuerung beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.control.getControlByName": "Steuerung nach Namen abrufen",
    "getControlByName": "Steuerung nach Namen abrufen",
    "bitbybit.babylon.gui.control.getControlByName_description": "Ruft Steuerelement nach Namen ab.",
    "bitbybit.babylon.gui.control.setIsVisible": "Sichtbarkeit festlegen",
    "setIsVisible": "Sichtbarkeit festlegen",
    "bitbybit.babylon.gui.control.setIsVisible_description": "Setzt, ob das Steuerelement sichtbar ist.",
    "isVisible": "ist sichtbar",
    "bitbybit.babylon.gui.control.setIsReadonly": "Nur-Lesen festlegen",
    "setIsReadonly": "Nur-Lesen festlegen",
    "bitbybit.babylon.gui.control.setIsReadonly_description": "Setzt, ob das Steuerelement schreibgeschützt ist.",
    "isReadOnly": "ist nur-lesen",
    "bitbybit.babylon.gui.control.setIsEnabled": "Aktiviert festlegen",
    "setIsEnabled": "Aktiviert festlegen",
    "bitbybit.babylon.gui.control.setIsEnabled_description": "Setzt, ob das Steuerelement aktiviert ist.",
    "isEnabled": "ist aktiviert",
    "bitbybit.babylon.gui.control.setHeight": "Höhe festlegen",
    "setHeight": "Höhe festlegen",
    "bitbybit.babylon.gui.control.setHeight_description": "Setzt die Höhe des Steuerelements.",
    "bitbybit.babylon.gui.control.setWidth": "Breite festlegen",
    "setWidth": "Breite festlegen",
    "bitbybit.babylon.gui.control.setWidth_description": "Setzt die Breite des Steuerelements.",
    "bitbybit.babylon.gui.control.setColor": "Farbe festlegen",
    "setColor": "Farbe festlegen",
    "bitbybit.babylon.gui.control.setColor_description": "Setzt die Farbe des Steuerelements.",
    "bitbybit.babylon.gui.control.setFontSize": "Schriftgröße festlegen",
    "setFontSize": "Schriftgröße festlegen",
    "bitbybit.babylon.gui.control.setFontSize_description": "Setzt die Schriftgröße.",
    "fontSize": "Schriftgröße",
    "bitbybit.babylon.gui.control.getHeight": "Höhe abrufen",
    "getHeight": "Höhe abrufen",
    "bitbybit.babylon.gui.control.getHeight_description": "Ruft die Höhe ab.",
    "bitbybit.babylon.gui.control.getWidth": "Breite abrufen",
    "getWidth": "Breite abrufen",
    "bitbybit.babylon.gui.control.getWidth_description": "Ruft die Breite ab.",
    "bitbybit.babylon.gui.control.getColor": "Farbe abrufen",
    "getColor": "Farbe abrufen",
    "bitbybit.babylon.gui.control.getColor_description": "Ruft die Farbe ab.",
    "bitbybit.babylon.gui.control.getFontSize": "Schriftgröße abrufen",
    "getFontSize": "Schriftgröße abrufen",
    "bitbybit.babylon.gui.control.getFontSize_description": "Ruft die Schriftgröße des Steuerelements ab.",
    "bitbybit.babylon.gui.control.getIsVisible": "Sichtbarkeit abrufen",
    "getIsVisible": "Sichtbarkeit abrufen",
    "bitbybit.babylon.gui.control.getIsVisible_description": "Ruft ab, ob das Steuerelement sichtbar ist.",
    "bitbybit.babylon.gui.control.getIsReadonly": "Nur-Lesen abrufen",
    "getIsReadonly": "Nur-Lesen abrufen",
    "bitbybit.babylon.gui.control.getIsReadonly_description": "Ruft ab, ob das Steuerelement schreibgeschützt ist.",
    "bitbybit.babylon.gui.control.getIsEnabled": "Aktiviert abrufen",
    "getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gui.control.getIsEnabled_description": "Ruft ab, ob das Steuerelement aktiviert ist.",
    "bitbybit.babylon.gui.container.addControls": "Steuerungen hinzufügen",
    "addControls": "Steuerungen hinzufügen",
    "bitbybit.babylon.gui.container.addControls_description": "Fügt Steuerelemente zum Container hinzu und behält die Reihenfolge bei.",
    "controls": "Steuerungen",
    "BABYLON.GUI.Control[]": "Babylon GUI-Steuerungs-Array",
    "clearControlsFirst": "zuerst Steuerungen löschen",
    "bitbybit.babylon.gui.container.setBackground": "Hintergrund festlegen",
    "setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.container.setBackground_description": "Setzt den Hintergrund des Containers.",
    "background": "Hintergrund",
    "bitbybit.babylon.gui.container.setIsReadonly": "Nur-Lesen festlegen",
    "bitbybit.babylon.gui.container.setIsReadonly_description": "Setzt, ob der Container schreibgeschützt ist.",
    "bitbybit.babylon.gui.container.getBackground": "Hintergrund abrufen",
    "getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.container.getBackground_description": "Ruft den Hintergrund des Containers ab.",
    "bitbybit.babylon.gui.container.getIsReadonly": "Nur-Lesen abrufen",
    "bitbybit.babylon.gui.container.getIsReadonly_description": "Ruft ab, ob der Container schreibgeschützt ist.",
    "bitbybit.babylon.gui.stackPanel.createStackPanel": "Stapelbereich",
    "stackPanel": "Stapelbereich",
    "createStackPanel": "Stapelbereich",
    "bitbybit.babylon.gui.stackPanel.createStackPanel_description": "erstellt Stapelbereich",
    "isVertical": "ist vertikal",
    "spacing": "Abstand",
    "bitbybit.babylon.gui.stackPanel.setIsVertical": "Vertikal festlegen",
    "setIsVertical": "Vertikal festlegen",
    "bitbybit.babylon.gui.stackPanel.setIsVertical_description": "Setzt, ob das Stack Panel vertikal ist.",
    "BABYLON.GUI.StackPanel": "Babylon GUI-Stapelbereich",
    "bitbybit.babylon.gui.stackPanel.setSpacing": "Abstand festlegen",
    "setSpacing": "Abstand festlegen",
    "bitbybit.babylon.gui.stackPanel.setSpacing_description": "Setzt den Abstand des Stack Panels.",
    "bitbybit.babylon.gui.stackPanel.setWidth": "Breite festlegen",
    "bitbybit.babylon.gui.stackPanel.setWidth_description": "Setzt die Breite des Stack Panels.",
    "bitbybit.babylon.gui.stackPanel.setHeight": "Höhe festlegen",
    "bitbybit.babylon.gui.stackPanel.setHeight_description": "Setzt die Höhe des Stack Panels.",
    "bitbybit.babylon.gui.stackPanel.getIsVertical": "Vertikal abrufen",
    "getIsVertical": "Vertikal abrufen",
    "bitbybit.babylon.gui.stackPanel.getIsVertical_description": "Ruft ab, ob das Stack Panel vertikal ist.",
    "bitbybit.babylon.gui.stackPanel.getSpacing": "Abstand abrufen",
    "getSpacing": "Abstand abrufen",
    "bitbybit.babylon.gui.stackPanel.getSpacing_description": "Ruft den Abstand des Stack Panels ab.",
    "bitbybit.babylon.gui.stackPanel.getWidth": "Breite abrufen",
    "bitbybit.babylon.gui.stackPanel.getWidth_description": "Ruft die Breite des Stack Panels ab.",
    "bitbybit.babylon.gui.stackPanel.getHeight": "Höhe abrufen",
    "bitbybit.babylon.gui.stackPanel.getHeight_description": "Ruft die Höhe des Stack Panels ab.",
    "bitbybit.babylon.gui.button.createSimpleButton": "einfacher Button",
    "button": "Button",
    "createSimpleButton": "einfacher Button",
    "bitbybit.babylon.gui.button.createSimpleButton_description": "erstellt einfachen Button",
    "label": "Beschriftung",
    "bitbybit.babylon.gui.button.setButtonText": "Button-Text festlegen",
    "setButtonText": "Button-Text festlegen",
    "bitbybit.babylon.gui.button.setButtonText_description": "Setzt den Button-Text.",
    "BABYLON.GUI.Button": "Babylon GUI-Button",
    "text": "Text",
    "bitbybit.babylon.gui.button.getButtonText": "Button-Text abrufen",
    "getButtonText": "Button-Text abrufen",
    "bitbybit.babylon.gui.button.getButtonText_description": "Ruft den Button-Text ab.",
    "bitbybit.babylon.gui.slider.createSlider": "Schieberegler",
    "slider": "Schieberegler",
    "createSlider": "Schieberegler",
    "bitbybit.babylon.gui.slider.createSlider_description": "erstellt Schieberegler",
    "minimum": "Minimum",
    "maximum": "Maximum",
    "value": "Wert",
    "step": "Schritt",
    "displayThumb": "Daumen anzeigen",
    "bitbybit.babylon.gui.slider.changeSliderThumb": "Schieberegler-Daumen ändern",
    "changeSliderThumb": "Schieberegler-Daumen ändern",
    "bitbybit.babylon.gui.slider.changeSliderThumb_description": "ändert die Eigenschaften des Schieberegler-Daumens",
    "BABYLON.GUI.Slider": "Babylon GUI-Schieberegler",
    "isThumbCircle": "ist Daumen kreisförmig",
    "thumbColor": "Daumenfarbe",
    "thumbWidth": "Daumenbreite",
    "string | number": "Zeichenkette oder Zahl",
    "isThumbClamped": "ist Daumen eingeklemmt",
    "bitbybit.babylon.gui.slider.setBorderColor": "Randfarbe festlegen",
    "setBorderColor": "Randfarbe festlegen",
    "bitbybit.babylon.gui.slider.setBorderColor_description": "Ändert die Rahmenfarbe des Schiebereglers.",
    "borderColor": "Randfarbe",
    "bitbybit.babylon.gui.slider.setBackgroundColor": "Hintergrundfarbe festlegen",
    "setBackgroundColor": "Hintergrundfarbe festlegen",
    "bitbybit.babylon.gui.slider.setBackgroundColor_description": "Ändert die Hintergrundfarbe des Schiebereglers.",
    "backgroundColor": "Hintergrundfarbe",
    "bitbybit.babylon.gui.slider.setMaximum": "Maximum festlegen",
    "setMaximum": "Maximum festlegen",
    "bitbybit.babylon.gui.slider.setMaximum_description": "Ändert den Maximalwert des Schiebereglers.",
    "bitbybit.babylon.gui.slider.setMinimum": "Minimum festlegen",
    "setMinimum": "Minimum festlegen",
    "bitbybit.babylon.gui.slider.setMinimum_description": "Ändert den Minimalwert des Schiebereglers.",
    "bitbybit.babylon.gui.slider.setStep": "Schritt festlegen",
    "setStep": "Schritt festlegen",
    "bitbybit.babylon.gui.slider.setStep_description": "Ändert den Schrittwert des Schiebereglers.",
    "bitbybit.babylon.gui.slider.setValue": "Wert festlegen",
    "setValue": "Wert festlegen",
    "bitbybit.babylon.gui.slider.setValue_description": "Ändert den Wert des Schiebereglers.",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector": "Schieberegler beobachtbarer Selektor",
    "createSliderObservableSelector": "Schieberegler beobachtbarer Selektor",
    "bitbybit.babylon.gui.slider.createSliderObservableSelector_description": "Erstellt den Selektor eines Observable für einen Schieberegler.",
    "sliderObservableSelectorEnum": "Schieberegler beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.slider.getBorderColor": "Randfarbe abrufen",
    "getBorderColor": "Randfarbe abrufen",
    "bitbybit.babylon.gui.slider.getBorderColor_description": "Ruft die Rahmenfarbe des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getBackgroundColor": "Hintergrundfarbe abrufen",
    "getBackgroundColor": "Hintergrundfarbe abrufen",
    "bitbybit.babylon.gui.slider.getBackgroundColor_description": "Ruft die Hintergrundfarbe des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getMaximum": "Maximum abrufen",
    "getMaximum": "Maximum abrufen",
    "bitbybit.babylon.gui.slider.getMaximum_description": "Ruft den Maximalwert des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getMinimum": "Minimum abrufen",
    "getMinimum": "Minimum abrufen",
    "bitbybit.babylon.gui.slider.getMinimum_description": "Ruft den Minimalwert des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getStep": "Schritt abrufen",
    "getStep": "Schritt abrufen",
    "bitbybit.babylon.gui.slider.getStep_description": "Ruft den Schrittwert des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getValue": "Wert abrufen",
    "getValue": "Wert abrufen",
    "bitbybit.babylon.gui.slider.getValue_description": "Ruft den Wert des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getThumbColor": "Daumenfarbe abrufen",
    "getThumbColor": "Daumenfarbe abrufen",
    "bitbybit.babylon.gui.slider.getThumbColor_description": "Ruft die Daumenfarbe des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getThumbWidth": "Daumenbreite abrufen",
    "getThumbWidth": "Daumenbreite abrufen",
    "bitbybit.babylon.gui.slider.getThumbWidth_description": "Ruft die Daumenbreite des Schiebereglers ab.",
    "bitbybit.babylon.gui.slider.getIsVertical": "Vertikal abrufen",
    "bitbybit.babylon.gui.slider.getIsVertical_description": "Ruft ab, ob der Schieberegler vertikal ist.",
    "bitbybit.babylon.gui.slider.getDisplayThumb": "Daumen anzeigen abrufen",
    "getDisplayThumb": "Daumen anzeigen abrufen",
    "bitbybit.babylon.gui.slider.getDisplayThumb_description": "Ruft ab, ob der Daumen des Schiebereglers angezeigt wird.",
    "bitbybit.babylon.gui.slider.getIsThumbCircle": "Daumen kreisförmig abrufen",
    "getIsThumbCircle": "Daumen kreisförmig abrufen",
    "bitbybit.babylon.gui.slider.getIsThumbCircle_description": "Ruft ab, ob der Daumen des Schiebereglers ein Kreis ist.",
    "bitbybit.babylon.gui.slider.getIsThumbClamped": "Daumen eingeklemmt abrufen",
    "getIsThumbClamped": "Daumen eingeklemmt abrufen",
    "bitbybit.babylon.gui.slider.getIsThumbClamped_description": "Ruft ab, ob der Daumen des Schiebereglers festgeklemmt ist.",
    "bitbybit.babylon.gui.textBlock.createTextBlock": "Textblock",
    "textBlock": "Textblock",
    "createTextBlock": "Textblock",
    "bitbybit.babylon.gui.textBlock.createTextBlock_description": "erstellt Textblock",
    "bitbybit.babylon.gui.textBlock.alignText": "Text ausrichten",
    "alignText": "Text ausrichten",
    "bitbybit.babylon.gui.textBlock.alignText_description": "Ändert die Ausrichtung für den Text.",
    "bitbybit.babylon.gui.textBlock.setTextOutline": "Textumriss festlegen",
    "setTextOutline": "Textumriss festlegen",
    "bitbybit.babylon.gui.textBlock.setTextOutline_description": "Ändert die Textumrandung für den Text.",
    "BABYLON.GUI.TextBlock": "Babylon GUI-Textblock",
    "outlineWidth": "Umrissbreite",
    "outlineColor": "Umrissfarbe",
    "bitbybit.babylon.gui.textBlock.setText": "Text festlegen",
    "setText": "Text festlegen",
    "bitbybit.babylon.gui.textBlock.setText_description": "Setzt den neuen Text für den Textblock.",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit": "Größe anpassen festlegen",
    "setRsizeToFit": "Größe anpassen festlegen",
    "bitbybit.babylon.gui.textBlock.setRsizeToFit_description": "Aktiviert oder deaktiviert 'Größe anpassen'.",
    "resizeToFit": "Größe anpassen",
    "bitbybit.babylon.gui.textBlock.setTextWrapping": "Textumbruch festlegen",
    "setTextWrapping": "Textumbruch festlegen",
    "bitbybit.babylon.gui.textBlock.setTextWrapping_description": "Setzt den neuen Textumbruch für den Textblock.",
    "textWrapping": "Textumbruch",
    "boolean | BABYLON.GUI.TextWrapping": "boolesch oder Babylon GUI-Textumbruch",
    "bitbybit.babylon.gui.textBlock.setLineSpacing": "Zeilenabstand festlegen",
    "setLineSpacing": "Zeilenabstand festlegen",
    "bitbybit.babylon.gui.textBlock.setLineSpacing_description": "Setzt den Zeilenabstand des Textes.",
    "lineSpacing": "Zeilenabstand",
    "bitbybit.babylon.gui.textBlock.getText": "Text abrufen",
    "getText": "Text abrufen",
    "bitbybit.babylon.gui.textBlock.getText_description": "Ruft den Text des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.getTextWrapping": "Textumbruch abrufen",
    "getTextWrapping": "Textumbruch abrufen",
    "bitbybit.babylon.gui.textBlock.getTextWrapping_description": "Ruft den Textumbruch des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.getLineSpacing": "Zeilenabstand abrufen",
    "getLineSpacing": "Zeilenabstand abrufen",
    "bitbybit.babylon.gui.textBlock.getLineSpacing_description": "Ruft den Zeilenabstand des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth": "Umrissbreite abrufen",
    "getOutlineWidth": "Umrissbreite abrufen",
    "bitbybit.babylon.gui.textBlock.getOutlineWidth_description": "Ruft die Umrandungsbreite des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.getResizeToFit": "Größe anpassen abrufen",
    "getResizeToFit": "Größe anpassen abrufen",
    "bitbybit.babylon.gui.textBlock.getResizeToFit_description": "Ruft 'Größe anpassen' des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment": "horizontale Textausrichtung abrufen",
    "getTextHorizontalAlignment": "horizontale Textausrichtung abrufen",
    "bitbybit.babylon.gui.textBlock.getTextHorizontalAlignment_description": "Ruft die horizontale Textausrichtung des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment": "vertikale Textausrichtung abrufen",
    "getTextVerticalAlignment": "vertikale Textausrichtung abrufen",
    "bitbybit.babylon.gui.textBlock.getTextVerticalAlignment_description": "Ruft die vertikale Textausrichtung des Textblocks ab.",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector": "Textblock beobachtbarer Selektor",
    "createTextBlockObservableSelector": "Textblock beobachtbarer Selektor",
    "bitbybit.babylon.gui.textBlock.createTextBlockObservableSelector_description": "Erstellt den Selektor eines Observable für einen Textblock.",
    "textBlockObservableSelectorEnum": "Textblock beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.radioButton.createRadioButton": "Optionsfeld",
    "radioButton": "Optionsfeld",
    "createRadioButton": "Optionsfeld",
    "bitbybit.babylon.gui.radioButton.createRadioButton_description": "erstellt Optionsfeld",
    "group": "Gruppe",
    "isChecked": "ist aktiviert",
    "checkSizeRatio": "Kontrollgrößenverhältnis",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio": "Kontrollgrößenverhältnis festlegen",
    "setCheckSizeRatio": "Kontrollgrößenverhältnis festlegen",
    "bitbybit.babylon.gui.radioButton.setCheckSizeRatio_description": "Setzt das Größenverhältnis des Auswahlfelds des Radiobuttons.",
    "BABYLON.GUI.RadioButton": "Babylon GUI-Optionsfeld",
    "bitbybit.babylon.gui.radioButton.setGroup": "Gruppe festlegen",
    "setGroup": "Gruppe festlegen",
    "bitbybit.babylon.gui.radioButton.setGroup_description": "Setzt die Gruppe des Radiobuttons.",
    "bitbybit.babylon.gui.radioButton.setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.radioButton.setBackground_description": "Setzt den Hintergrund des Radiobuttons.",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio": "Kontrollgrößenverhältnis abrufen",
    "getCheckSizeRatio": "Kontrollgrößenverhältnis abrufen",
    "bitbybit.babylon.gui.radioButton.getCheckSizeRatio_description": "Ruft das Größenverhältnis des Auswahlfelds des Radiobuttons ab.",
    "bitbybit.babylon.gui.radioButton.getGroup": "Gruppe abrufen",
    "getGroup": "Gruppe abrufen",
    "bitbybit.babylon.gui.radioButton.getGroup_description": "Ruft die Gruppe des Radiobuttons ab.",
    "bitbybit.babylon.gui.radioButton.getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.radioButton.getBackground_description": "Ruft den Hintergrund des Radiobuttons ab.",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector": "Optionsfeld beobachtbarer Selektor",
    "createRadioButtonObservableSelector": "Optionsfeld beobachtbarer Selektor",
    "bitbybit.babylon.gui.radioButton.createRadioButtonObservableSelector_description": "Erstellt den Selektor eines Observable für den Radiobutton.",
    "radioButtonObservableSelectorEnum": "Optionsfeld beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.checkbox.createCheckbox": "Kontrollkästchen",
    "checkbox": "Kontrollkästchen",
    "createCheckbox": "Kontrollkästchen",
    "bitbybit.babylon.gui.checkbox.createCheckbox_description": "erstellt Kontrollkästchen",
    "bitbybit.babylon.gui.checkbox.setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.checkbox.setBackground_description": "Setzt den Hintergrund der Checkbox.",
    "BABYLON.GUI.Checkbox": "Babylon GUI-Kontrollkästchen",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio": "Kontrollgrößenverhältnis festlegen",
    "bitbybit.babylon.gui.checkbox.setCheckSizeRatio_description": "Setzt das Größenverhältnis des Auswahlfelds der Checkbox.",
    "bitbybit.babylon.gui.checkbox.setIsChecked": "Aktiviert festlegen",
    "setIsChecked": "Aktiviert festlegen",
    "bitbybit.babylon.gui.checkbox.setIsChecked_description": "Setzt, ob die Checkbox ausgewählt ist.",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio": "Kontrollgrößenverhältnis abrufen",
    "bitbybit.babylon.gui.checkbox.getCheckSizeRatio_description": "Ruft das Größenverhältnis des Auswahlfelds ab.",
    "bitbybit.babylon.gui.checkbox.getIsChecked": "Aktiviert abrufen",
    "getIsChecked": "Aktiviert abrufen",
    "bitbybit.babylon.gui.checkbox.getIsChecked_description": "Ruft ab, ob ausgewählt ist.",
    "bitbybit.babylon.gui.checkbox.getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.checkbox.getBackground_description": "Ruft den Hintergrund ab.",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector": "Kontrollkästchen beobachtbarer Selektor",
    "createCheckboxObservableSelector": "Kontrollkästchen beobachtbarer Selektor",
    "bitbybit.babylon.gui.checkbox.createCheckboxObservableSelector_description": "Erstellt den Selektor eines Observable für die Checkbox.",
    "checkboxObservableSelectorEnum": "Kontrollkästchen beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.inputText.createInputText": "Eingabetext",
    "inputText": "Eingabetext",
    "createInputText": "Eingabetext",
    "bitbybit.babylon.gui.inputText.createInputText_description": "erstellt Eingabetext",
    "placeholder": "Platzhalter",
    "bitbybit.babylon.gui.inputText.setBackground": "Hintergrund festlegen",
    "bitbybit.babylon.gui.inputText.setBackground_description": "Setzt den Hintergrund des Eingabetextes.",
    "BABYLON.GUI.InputText": "Babylon GUI-Eingabetext",
    "bitbybit.babylon.gui.inputText.setText": "Text festlegen",
    "bitbybit.babylon.gui.inputText.setText_description": "Setzt den Text des Eingabetextes.",
    "bitbybit.babylon.gui.inputText.setPlaceholder": "Platzhalter festlegen",
    "setPlaceholder": "Platzhalter festlegen",
    "bitbybit.babylon.gui.inputText.setPlaceholder_description": "Setzt den Platzhalter des Eingabetextes.",
    "bitbybit.babylon.gui.inputText.getBackground": "Hintergrund abrufen",
    "bitbybit.babylon.gui.inputText.getBackground_description": "Ruft den Hintergrund des Eingabetextes ab.",
    "bitbybit.babylon.gui.inputText.getText": "Text abrufen",
    "bitbybit.babylon.gui.inputText.getText_description": "Ruft den Text des Eingabetextes ab.",
    "bitbybit.babylon.gui.inputText.getPlaceholder": "Platzhallter abrufen",
    "getPlaceholder": "Platzhalter abrufen",
    "bitbybit.babylon.gui.inputText.getPlaceholder_description": "Ruft den Platzhalter des Eingabetextes ab.",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector": "Eingabetext beobachtbarer Selektor",
    "createInputTextObservableSelector": "Eingabetext beobachtbarer Selektor",
    "bitbybit.babylon.gui.inputText.createInputTextObservableSelector_description": "Erstellt den Selektor eines Observable für den Eingabetext.",
    "inputTextObservableSelectorEnum": "Eingabetext beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.colorPicker.createColorPicker": "Farbwähler",
    "colorPicker": "Farbwähler",
    "createColorPicker": "Farbwähler",
    "bitbybit.babylon.gui.colorPicker.createColorPicker_description": "erstellt Farbwähler",
    "defaultColor": "Standardfarbe",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue": "Farbwähler-Wert festlegen",
    "setColorPickerValue": "Farbwähler-Wert festlegen",
    "bitbybit.babylon.gui.colorPicker.setColorPickerValue_description": "Setzt die Farbe des Farbwählers.",
    "BABYLON.GUI.ColorPicker": "Babylon GUI-Farbwähler",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize": "Farbwähler-Größe festlegen",
    "setColorPickerSize": "Farbwähler-Größe festlegen",
    "bitbybit.babylon.gui.colorPicker.setColorPickerSize_description": "Setzt die Größe des Farbwählers (Breite und Höhe).",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue": "Farbwähler-Wert abrufen",
    "getColorPickerValue": "Farbwähler-Wert abrufen",
    "bitbybit.babylon.gui.colorPicker.getColorPickerValue_description": "Ruft die Farbe des Farbwählers ab.",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize": "Farbwähler-Größe abrufen",
    "getColorPickerSize": "Farbwähler-Größe abrufen",
    "bitbybit.babylon.gui.colorPicker.getColorPickerSize_description": "ruft die Größe des Farbwählers ab",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector": "Farbwähler beobachtbarer Selektor",
    "createColorPickerObservableSelector": "Farbwähler beobachtbarer Selektor",
    "bitbybit.babylon.gui.colorPicker.createColorPickerObservableSelector_description": "Erstellt den Selektor eines Observable für den Farbwähler.",
    "colorPickerObservableSelectorEnum": "Farbwähler beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gui.image.createImage": "Bild",
    "image": "Bild",
    "createImage": "Bild",
    "bitbybit.babylon.gui.image.createImage_description": "erstellt Bild",
    "bitbybit.babylon.gui.image.setSourceUrl": "Quell-URL festlegen",
    "setSourceUrl": "Quell-URL festlegen",
    "bitbybit.babylon.gui.image.setSourceUrl_description": "legt die Quell-URL des Bildes fest",
    "BABYLON.GUI.Image": "Babylon GUI-Bild",
    "bitbybit.babylon.gui.image.getSourceUrl": "Quell-URL abrufen",
    "getSourceUrl": "Quell-URL abrufen",
    "bitbybit.babylon.gui.image.getSourceUrl_description": "ruft die Quell-URL des Bildes ab",
    "bitbybit.babylon.gizmo.manager.createGizmoManager": "Gizmo-Manager",
    "gizmo": "Gizmo",
    "manager": "Manager",
    "createGizmoManager": "Gizmo-Manager",
    "bitbybit.babylon.gizmo.manager.createGizmoManager_description": "Erstellt Gizmo-Manager.",
    "positionGizmoEnabled": "Positions-Gizmo aktiviert",
    "rotationGizmoEnabled": "Rotations-Gizmo aktiviert",
    "scaleGizmoEnabled": "Skalierungs-Gizmo aktiviert",
    "boundingBoxGizmoEnabled": "Begrenzungsrahmen-Gizmo aktiviert",
    "usePointerToAttachGizmos": "Zeiger zum Anhängen von Gizmos verwenden",
    "clearGizmoOnEmptyPointerEvent": "Gizmo bei leerem Zeigerereignis löschen",
    "scaleRatio": "Skalierungsverhältnis",
    "attachableMeshes": "anbringbare Meshes",
    "BABYLON.AbstractMesh[]": "Babylon abstraktes Mesh-Array",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo": "Positions-Gizmo abrufen",
    "getPositionGizmo": "Positions-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getPositionGizmo_description": "Ruft Positions-Gizmo ab.",
    "gizmoManager": "Gizmo-Manager",
    "BABYLON.GizmoManager": "Babylon Gizmo-Manager",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo": "Rotations-Gizmo abrufen",
    "getRotationGizmo": "Rotations-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getRotationGizmo_description": "Ruft Rotations-Gizmo ab.",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo": "Skalierungs-Gizmo abrufen",
    "getScaleGizmo": "Skalierungs-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getScaleGizmo_description": "Ruft Skalierungs-Gizmo ab.",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo": "Begrenzungsrahmen-Gizmo abrufen",
    "getBoundingBoxGizmo": "Begrenzungsrahmen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.manager.getBoundingBoxGizmo_description": "Ruft Bounding-Box-Gizmo ab.",
    "bitbybit.babylon.gizmo.manager.attachToMesh": "an Mesh anbringen",
    "attachToMesh": "an Mesh anbringen",
    "bitbybit.babylon.gizmo.manager.attachToMesh_description": "Hängt Gizmo-Manager an Mesh an.",
    "update": "parte",
    "bitbybit.babylon.gizmo.manager.detachMesh": "Mesh abtrennen",
    "detachMesh": "Mesh abtrennen",
    "bitbybit.babylon.gizmo.manager.detachMesh_description": "Löst Gizmo-Manager vom Mesh.",
    "bitbybit.babylon.gizmo.base.scaleRatio": "Skalierungsverhältnis festlegen",
    "base": "Basis",
    "bitbybit.babylon.gizmo.base.scaleRatio_description": "Setzt Gizmo-Skalierungsverhältnis.",
    "BABYLON.IGizmo": "Babylon I Gizmo",
    "bitbybit.babylon.gizmo.base.getScaleRatio": "Skalierungsverhältnis abrufen",
    "getScaleRatio": "Skalierungsverhältnis abrufen",
    "bitbybit.babylon.gizmo.base.getScaleRatio_description": "Ruft Skalierungsverhältnis ab.",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled": "Ebenen-Gizmo aktivieren festlegen",
    "positionGizmo": "Positions-Gizmo",
    "planarGizmoEnabled": "Ebenen-Gizmo aktiviert",
    "bitbybit.babylon.gizmo.positionGizmo.planarGizmoEnabled_description": "Setzt planares Gizmo aktiviert.",
    "BABYLON.IPositionGizmo": "Babylon I Positions-Gizmo",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance": "Schnappabstand festlegen",
    "snapDistance": "Schnappabstand",
    "bitbybit.babylon.gizmo.positionGizmo.snapDistance_description": "Setzt Einrastabstand für Positions-Gizmo.",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh": "angehängtes Mesh abrufen",
    "getAttachedMesh": "angehängtes Mesh abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedMesh_description": "Ruft angehängtes Mesh ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode": "angehängten Knoten abrufen",
    "getAttachedNode": "angehängten Knoten abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getAttachedNode_description": "Ruft angehängten Knoten ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo": "X-Gizmo abrufen",
    "getXGizmo": "X-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getXGizmo_description": "Ruft X-Gizmo ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo": "Y-Gizmo abrufen",
    "getYGizmo": "Y-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getYGizmo_description": "Ruft Y-Gizmo ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo": "Z-Gizmo abrufen",
    "getZGizmo": "Z-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getZGizmo_description": "Ruft Z-Gizmo ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo": "X-Ebenen-Gizmo abrufen",
    "getXPlaneGizmo": "X-Ebenen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getXPlaneGizmo_description": "Ruft X-Ebenen-Gizmo ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo": "Y-Ebenen-Gizmo abrufen",
    "getYPlaneGizmo": "Y-Ebenen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getYPlaneGizmo_description": "Ruft Y-Ebenen-Gizmo ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo": "Z-Ebenen-Gizmo abrufen",
    "getZPlaneGizmo": "Z-Ebenen-Gizmo abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getZPlaneGizmo_description": "Ruft Z-Ebenen-Gizmo ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled": "Ebenen-Gizmo aktiviert abrufen",
    "getPlanarGizmoEnabled": "Ebenen-Gizmo aktiviert abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getPlanarGizmoEnabled_description": "Ruft ab, ob planares Gizmo aktiviert ist.",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance": "Schnappabstand abrufen",
    "getSnapDistance": "Schnappabstand abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getSnapDistance_description": "Ruft Einrastabstand ab.",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging": "Ziehen abrufen",
    "getIsDragging": "Ziehen abrufen",
    "bitbybit.babylon.gizmo.positionGizmo.getIsDragging_description": "Ruft ab, ob gezogen wird.",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector": "Positions-Gizmo beobachtbarer Selektor",
    "createPositionGizmoObservableSelector": "Positions-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.positionGizmo.createPositionGizmoObservableSelector_description": "Erstellt den Selektor eines Observable für ein Positions-Gizmo.",
    "positionGizmoObservableSelectorEnum": "Positions-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance": "Schnappabstand festlegen",
    "rotationGizmo": "Rotations-Gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.snapDistance_description": "Setzt Einrastabstand für Rotations-Gizmo.",
    "BABYLON.IRotationGizmo": "Babylon I Rotations-Gizmo",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity": "Empfindlichkeit festlegen",
    "sensitivity": "Empfindlichkeit",
    "bitbybit.babylon.gizmo.rotationGizmo.sensitivity_description": "Setzt Empfindlichkeit für Rotations-Gizmo.",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh": "angehängtes Mesh abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedMesh_description": "Ruft angehängtes Mesh ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode": "angehängten Knoten abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getAttachedNode_description": "Ruft angehängten Knoten ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo": "X-Gizmo abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getXGizmo_description": "Ruft X-Gizmo ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo": "Y-Gizmo abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getYGizmo_description": "Ruft Y-Gizmo ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo": "Z-Gizmo abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getZGizmo_description": "Ruft Z-Gizmo ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance": "Schnappabstand abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getSnapDistance_description": "Ruft Einrastabstand ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity": "Empfindlichkeit abrufen",
    "getSensitivity": "Empfindlichkeit abrufen",
    "bitbybit.babylon.gizmo.rotationGizmo.getSensitivity_description": "Ruft Empfindlichkeit ab.",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector": "Rotations-Gizmo beobachtbarer Selektor",
    "createRotationGizmoObservableSelector": "Rotations-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.rotationGizmo.createRotationGizmoObservableSelector_description": "Erstellt den Selektor eines Observable für ein Rotations-Gizmo.",
    "rotationGizmoObservableSelectorEnum": "Rotations-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo": "X-Gizmo abrufen",
    "scaleGizmo": "Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getXGizmo_description": "Ruft X-Gizmo ab.",
    "BABYLON.IScaleGizmo": "Babylon I Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo": "Y-Gizmo abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getYGizmo_description": "Ruft Y-Gizmo ab.",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo": "Z-Gizmo abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getZGizmo_description": "Ruft Z-Gizmo ab.",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance": "Schnappabstand festlegen",
    "bitbybit.babylon.gizmo.scaleGizmo.snapDistance_description": "Setzt Einrastabstand für Skalierungs-Gizmo.",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap": "inkrementelles Schnappen festlegen",
    "setIncrementalSnap": "inkrementelles Schnappen festlegen",
    "bitbybit.babylon.gizmo.scaleGizmo.setIncrementalSnap_description": "Setzt inkrementelles Einrasten für Skalierungs-Gizmo.",
    "incrementalSnap": "inkrementelles Schnappen",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity": "Empfindlichkeit festlegen",
    "bitbybit.babylon.gizmo.scaleGizmo.sensitivity_description": "Setzt Empfindlichkeit für Skalierungs-Gizmo.",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap": "inkrementelles Schnappen abrufen",
    "getIncrementalSnap": "inkrementelles Schnappen abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getIncrementalSnap_description": "Ruft inkrementelles Einrasten ab.",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance": "Schnappabstand abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getSnapDistance_description": "Ruft Einrastabstand ab.",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity": "Empfindlichkeit abrufen",
    "bitbybit.babylon.gizmo.scaleGizmo.getSensitivity_description": "Ruft Empfindlichkeit ab.",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector": "Skalierungs-Gizmo beobachtbarer Selektor",
    "createScaleGizmoObservableSelector": "Skalierungs-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.scaleGizmo.createScaleGizmoObservableSelector_description": "Erstellt den Selektor eines Observable für ein Skalierungs-Gizmo.",
    "scaleGizmoObservableSelectorEnum": "Skalierungs-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize": "Rotationskugelgröße festlegen",
    "boundingBoxGizmo": "Begrenzungsrahmen-Gizmo",
    "setRotationSphereSize": "Rotationskugelgröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSphereSize_description": "Setzt Größe der Rotationssphäre des Bounding-Box-Gizmo.",
    "BABYLON.BoundingBoxGizmo": "Babylon Begrenzungsrahmen-Gizmo",
    "rotationSphereSize": "Rotationskugelgröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße festlegen",
    "setFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSize_description": "Wenn gesetzt, vergrößern sich die Rotationsanker und Skalierungsboxen basierend auf der Entfernung zur Kamera, um eine konsistente Bildschirmgröße zu haben (Standard: false). Hinweis: fixedDragMeshScreenSize hat Vorrang vor fixedDragMeshBoundsSize, wenn beide wahr sind.",
    "fixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße festlegen",
    "setFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshBoundsSize_description": "Setzt feste Drag-Mesh-Grenzegröße des Bounding-Box-Gizmo.",
    "fixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor festlegen",
    "setFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setFixedDragMeshScreenSizeDistanceFactor_description": "Die Entfernung vom Objekt, bei der die ziehbaren Meshes weltgroß erscheinen sollen, wenn fixedDragMeshScreenSize auf true gesetzt ist (Standard: 10).",
    "fixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance": "Skalierungsschnappabstand festlegen",
    "setScalingSnapDistance": "Skalierungsschnappabstand festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalingSnapDistance_description": "Setzt Einrastabstand für Skalierung des Bounding-Box-Gizmo. Ziehdistanz in Babylon-Einheiten, auf die das Gizmo die Skalierung einrastet, wenn es gezogen wird.",
    "scalingSnapDistance": "Skalierungsschnappabstand",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance": "Rotationsschnappabstand festlegen",
    "setRotationSnapDistance": "Rotationsschnappabstand festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setRotationSnapDistance_description": "Setzt Einrastabstand für Rotation des Bounding-Box-Gizmo. Ziehdistanz in Babylon-Einheiten, auf die das Gizmo die Rotation einrastet, wenn es gezogen wird.",
    "rotationSnapDistance": "Rotationsschnappabstand",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize": "Skalierungskastengröße festlegen",
    "setScaleBoxSize": "Skalierungskastengröße festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleBoxSize_description": "Setzt Größe der Skalierungsbox des Bounding-Box-Gizmo.",
    "scaleBoxSize": "Skalierungskastengröße",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap": "inkrementelles Schnappen festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setIncrementalSnap_description": "Setzt inkrementelles Einrasten des Bounding-Box-Gizmo. Inkrementelle Einrastskalierung (Standard ist false). Wenn wahr, bei einem snapDistance von 0.1, wird die Skalierung 1.1, 1.2, 1.3 sein anstatt, wenn falsch: 1.1, 1.21, 1.33,...",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot": "Skalierungspivot festlegen",
    "setScalePivot": "Skalierungspivot festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScalePivot_description": "Setzt Skalierungspivot des Bounding-Box-Gizmo. Relativer Bounding-Box-Pivot, der beim Skalieren des angehängten Knotens verwendet wird. Wenn null, Objekt mit Skalierung von der gegenüberliegenden Ecke. 0.5,0.5,0.5 für Zentrum und 0.5,0,0.5 für unten (Standard: null).",
    "scalePivot": "Skalierungspivot",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor": "Achsenfaktor festlegen",
    "setAxisFactor": "Achsenfaktor festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setAxisFactor_description": "Setzt Achsenfaktor des Bounding-Box-Gizmo. Setzt benutzerdefinierten Empfindlichkeitswert für jede Achse.",
    "axisFactor": "Achsenfaktor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed": "Skalierungsziehgeschwindigkeit festlegen",
    "setScaleDragSpeed": "Skalierungsziehgeschwindigkeit festlegen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.setScaleDragSpeed_description": "Setzt Skalierungsziehgeschwindigkeit des Bounding-Box-Gizmo.",
    "scaleDragSpeed": "Skalierungsziehgeschwindigkeit",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize": "Rotationskugelgröße abrufen",
    "getRotationSphereSize": "Rotationskugelgröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSphereSize_description": "Ruft Größe der Rotationssphäre ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize": "Skalierungskastengröße abrufen",
    "getScaleBoxSize": "Skalierungskastengröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleBoxSize_description": "Ruft Größe der Skalierungsbox ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße abrufen",
    "getFixedDragMeshScreenSize": "feste Zieh-Mesh-Bildschirmgröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSize_description": "Ruft feste Drag-Mesh-Bildschirmgröße ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße abrufen",
    "getFixedDragMeshBoundsSize": "feste Zieh-Mesh-Grenzengröße abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshBoundsSize_description": "Ruft feste Drag-Mesh-Grenzegröße ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor abrufen",
    "getFixedDragMeshScreenSizeDistanceFactor": "fester Zieh-Mesh-Bildschirmgrößen-Distanzfaktor abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getFixedDragMeshScreenSizeDistanceFactor_description": "Ruft Distanzfaktor für feste Drag-Mesh-Bildschirmgröße ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance": "Skalierungsschnappabstand abrufen",
    "getScalingSnapDistance": "Skalierungsschnappabstand abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalingSnapDistance_description": "Ruft Skalierungseinrastabstand ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance": "Rotationsschnappabstand abrufen",
    "getRotationSnapDistance": "Rotationsschnappabstand abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getRotationSnapDistance_description": "Ruft Rotationseinrastabstand ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap": "inkrementelles Schnappen abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getIncrementalSnap_description": "Ruft inkrementelles Einrasten ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot": "Skalierungspivot abrufen",
    "getScalePivot": "Skalierungspivot abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScalePivot_description": "Ruft Skalierungspivot ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor": "Achsenfaktor abrufen",
    "getAxisFactor": "Achsenfaktor abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getAxisFactor_description": "Ruft Achsenfaktor ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed": "Skalierungsziehgeschwindigkeit abrufen",
    "getScaleDragSpeed": "Skalierungsziehgeschwindigkeit abrufen",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.getScaleDragSpeed_description": "Ruft Skalierungsziehgeschwindigkeit ab.",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector": "Begrenzungsrahmen-Gizmo beobachtbarer Selektor",
    "createBoundingBoxGizmoObservableSelector": "Begrenzungsrahmen-Gizmo beobachtbarer Selektor",
    "bitbybit.babylon.gizmo.boundingBoxGizmo.createBoundingBoxGizmoObservableSelector_description": "Erstellt den Selektor eines Observable für ein Bounding-Box-Gizmo.",
    "boundingBoxGizmoObservableSelectorEnum": "Begrenzungsrahmen-Gizmo beobachtbarer Selektor-Enum",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled": "Aktiviert festlegen",
    "axisDragGizmo": "Achsen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.axisDragGizmo.setIsEnabled_description": "Setzt, ob die Achse aktiviert ist oder nicht.",
    "BABYLON.IAxisDragGizmo": "Babylon I Achsen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.axisDragGizmo.getIsEnabled_description": "Prüft, ob die Achse aktiviert ist.",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled": "Aktiviert festlegen",
    "axisScaleGizmo": "Achsen-Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.setIsEnabled_description": "Setzt, ob die Achse aktiviert ist oder nicht.",
    "BABYLON.IAxisScaleGizmo": "Babylon I Achsen-Skalierungs-Gizmo",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.axisScaleGizmo.getIsEnabled_description": "Prüft, ob die Achse aktiviert ist.",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled": "Aktiviert festlegen",
    "planeDragGizmo": "Ebenen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.planeDragGizmo.setIsEnabled_description": "Setzt, ob die Ebene aktiviert ist oder nicht.",
    "BABYLON.IPlaneDragGizmo": "Babylon I Ebenen-Zieh-Gizmo",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.planeDragGizmo.getIsEnabled_description": "Prüft, ob die Ebene aktiviert ist.",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled": "Aktiviert festlegen",
    "planeRotationGizmo": "Ebenen-Rotations-Gizmo",
    "bitbybit.babylon.gizmo.planeRotationGizmo.setIsEnabled_description": "Setzt, ob die Ebene aktiviert ist oder nicht.",
    "BABYLON.IPlaneRotationGizmo": "Babylon I Ebenen-Rotations-Gizmo",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled": "Aktiviert abrufen",
    "bitbybit.babylon.gizmo.planeRotationGizmo.getIsEnabled_description": "Prüft, ob die Ebene aktiviert ist.",
    "bitbybit.vector.removeAllDuplicateVectors": "alle doppelten Vektoren entfernen",
    "vector": "Vektor",
    "removeAllDuplicateVectors": "alle doppelten Vektoren entfernen",
    "bitbybit.vector.removeAllDuplicateVectors_description": "Entfernt alle doppelten Vektoren aus dem Eingabearray (behält nur einzigartige Vektoren). Beispiel: [[1,2,3], [4,5,6], [1,2,3], [7,8,9]] → [[1,2,3], [4,5,6], [7,8,9]]",
    "remove": "entfernen",
    "vectors": "Vektoren",
    "number[][]": "Zahlen-Array-Array",
    "tolerance": "Toleranz",
    "bitbybit.vector.removeConsecutiveDuplicateVectors": "aufeinanderfolgende doppelte Vektoren entfernen",
    "removeConsecutiveDuplicateVectors": "aufeinanderfolgende doppelte Vektoren entfernen",
    "bitbybit.vector.removeConsecutiveDuplicateVectors_description": "Entfernt aufeinanderfolgende doppelte Vektoren aus dem Eingabearray (entfernt nur Duplikate, die nebeneinander erscheinen). Beispiel: [[1,2], [1,2], [3,4], [1,2]] → [[1,2], [3,4], [1,2]] (nur aufeinanderfolgende Duplikate entfernt)",
    "checkFirstAndLast": "erstes und letztes prüfen",
    "bitbybit.vector.angleBetween": "Winkel zwischen",
    "angleBetween": "Winkel zwischen",
    "bitbybit.vector.angleBetween_description": "Misst den Winkel zwischen zwei Vektoren in Grad (gibt immer positiven Winkel 0-180° zurück). Beispiel: [1,0,0] und [0,1,0] → 90° (senkrechte Vektoren)",
    "angles": "Winkel",
    "first": "erster",
    "second": "zweiter",
    "bitbybit.vector.angleBetweenNormalized2d": "Winkel zwischen normalisiertem 2D",
    "angleBetweenNormalized2d": "Winkel zwischen normalisiertem 2D",
    "bitbybit.vector.angleBetweenNormalized2d_description": "Misst den normalisierten 2D-Winkel zwischen zwei Vektoren in Grad (berücksichtigt Richtung, kann negativ sein). Beispiel: [1,0] zu [0,1] → 90°, [0,1] zu [1,0] → -90°",
    "bitbybit.vector.positiveAngleBetween": "positiver Winkel zwischen",
    "positiveAngleBetween": "positiver Winkel zwischen",
    "bitbybit.vector.positiveAngleBetween_description": "Misst einen positiven Winkel zwischen zwei Vektoren gegeben den Referenzvektor in Grad (immer 0-360°). Beispiel: wandelt negative vorzeichenbehaftete Winkel in positive um, indem bei Bedarf 360° addiert werden",
    "reference": "Referenz",
    "bitbybit.vector.addAll": "alle addieren",
    "addAll": "alle addieren",
    "bitbybit.vector.addAll_description": "Addiert alle Vektor-XYZ-Werte elementweise zusammen und erstellt einen neuen Vektor. Beispiel: [[1,2,3], [4,5,6], [7,8,9]] → [12,15,18] (summiert jede Spalte)",
    "sum": "Summe",
    "bitbybit.vector.add": "addieren",
    "add": "addieren",
    "bitbybit.vector.add_description": "Addiert zwei Vektoren elementweise zusammen. Beispiel: [1,2,3] + [4,5,6] → [5,7,9]",
    "bitbybit.vector.all": "alle",
    "all": "alle",
    "bitbybit.vector.all_description": "Prüft, ob das boolesche Array nur wahre Werte enthält, gibt false zurück, wenn ein einzelnes false vorhanden ist. Beispiel: [true, true, true] → true, [true, false, true] → false",
    "boolean[]": "Boolean-Array",
    "bitbybit.vector.cross": "Kreuzprodukt",
    "cross": "Kreuzprodukt",
    "bitbybit.vector.cross_description": "Berechnet das Kreuzprodukt von zwei 3D-Vektoren (senkrechter Vektor zu beiden Eingaben). Beispiel: [1,0,0] × [0,1,0] → [0,0,1] (Rechte-Hand-Regel)",
    "bitbybit.vector.distSquared": "Abstand quadriert",
    "distSquared": "Abstand quadriert",
    "bitbybit.vector.distSquared_description": "Berechnet den quadrierten Abstand zwischen zwei Vektoren (schneller als Abstand, vermeidet Wurzel). Beispiel: [0,0,0] zu [3,4,0] → 25 (Abstand 5 im Quadrat)",
    "bitbybit.vector.dist": "Abstand",
    "dist": "Abstand",
    "bitbybit.vector.dist_description": "Berechnet den euklidischen Abstand zwischen zwei Vektoren. Beispiel: [0,0,0] zu [3,4,0] → 5, [1,1] zu [4,5] → 5",
    "bitbybit.vector.div": "dividieren",
    "div": "dividieren",
    "bitbybit.vector.div_description": "Dividiert jedes Element des Vektors durch einen Skalarwert. Beispiel: [10,20,30] ÷ 2 → [5,10,15]",
    "scalar": "Skalar",
    "bitbybit.vector.domain": "Bereich",
    "domain": "Bereich",
    "bitbybit.vector.domain_description": "Berechnet den Definitionsbereich (Range) zwischen Minimal- und Maximalwerten des Vektors. Beispiel: [1,3,5,9] → 8 (Differenz zwischen letztem und erstem: 9-1)",
    "bitbybit.vector.dot": "Skalarprodukt",
    "dot": "Skalarprodukt",
    "bitbybit.vector.dot_description": "Berechnet das Skalarprodukt zwischen zwei Vektoren (misst Ähnlichkeit/Projektion). Beispiel: [1,2,3] • [4,5,6] → 32 (1×4 + 2×5 + 3×6), senkrechte Vektoren → 0",
    "bitbybit.vector.finite": "endlich",
    "finite": "endlich",
    "bitbybit.vector.finite_description": "Prüft, ob jedes Element im Vektor endlich ist und gibt ein boolesches Array zurück. Beispiel: [1, 2, Infinity, 3] → [true, true, false, true]",
    "validate": "validieren",
    "bitbybit.vector.isZero": "ist Null",
    "isZero": "ist Null",
    "bitbybit.vector.isZero_description": "Prüft, ob der Vektor die Länge Null hat (alle Elemente sind Null). Beispiel: [0,0,0] → true, [0,0,0.001] → false",
    "bitbybit.vector.lerp": "lineare Interpolation",
    "lerp": "lineare Interpolation",
    "bitbybit.vector.lerp_description": "Findet einen interpolierten Vektor zwischen zwei Vektoren unter Verwendung eines Bruchteils (lineare Interpolation). Beispiel: [0,0,0] zu [10,10,10] bei 0.5 → [5,5,5], Bruchteil=0 → erster, Bruchteil=1 → zweiter",
    "fraction": "Bruchteil",
    "bitbybit.vector.max": "max",
    "max": "max",
    "bitbybit.vector.max_description": "Findet den maximalen (größten) Wert im Vektor. Beispiel: [3, 7, 2, 9, 1] → 9",
    "extract": "extrahieren",
    "bitbybit.vector.min": "min",
    "min": "min",
    "bitbybit.vector.min_description": "Findet den minimalen (kleinsten) Wert im Vektor. Beispiel: [3, 7, 2, 9, 1] → 1",
    "bitbybit.vector.mul": "mul",
    "mul": "mul",
    "bitbybit.vector.mul_description": "Multipliziert jedes Element des Vektors mit einem Skalarwert. Beispiel: [2,3,4] × 5 → [10,15,20]",
    "bitbybit.vector.neg": "neg",
    "neg": "neg",
    "bitbybit.vector.neg_description": "Negiert den Vektor (kehrt das Vorzeichen jedes Elements um). Beispiel: [5,-3,2] → [-5,3,-2]",
    "bitbybit.vector.normSquared": "Norm quadriert",
    "normSquared": "Norm quadriert",
    "bitbybit.vector.normSquared_description": "Berechnet die quadrierte Norm (quadrierte Größe/Länge) des Vektors. Beispiel: [3,4,0] → 25 (Länge 5 im Quadrat)",
    "bitbybit.vector.norm": "Norm",
    "norm": "Norm",
    "bitbybit.vector.norm_description": "Berechnet die Norm (Größe/Länge) des Vektors. Beispiel: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.vector.normalized": "normalisiert",
    "normalized": "normalisiert",
    "bitbybit.vector.normalized_description": "Normalisiert den Vektor in einen Einheitsvektor, der eine Länge von 1 hat (behält Richtung bei, skaliert Größe auf 1). Beispiel: [3,4,0] → [0.6,0.8,0], [10,0,0] → [1,0,0]",
    "bitbybit.vector.onRay": "auf Strahl",
    "onRay": "auf Strahl",
    "bitbybit.vector.onRay_description": "Findet einen Punkt auf einem Strahl in einem gegebenen Abstand vom Ursprung entlang des Richtungsvektors. Beispiel: Punkt [0,0,0] + Richtung [1,0,0] bei Abstand 5 → [5,0,0]",
    "bitbybit.vector.vectorXYZ": "Vektor XYZ",
    "vectorXYZ": "Vektor XYZ",
    "bitbybit.vector.vectorXYZ_description": "Erstellt einen 3D-Vektor aus x-, y-, z-Koordinaten. Beispiel: x=1, y=2, z=3 → [1,2,3]",
    "x": "X",
    "y": "Y",
    "z": "Z",
    "bitbybit.vector.vectorXY": "Vektor XY",
    "vectorXY": "Vektor XY",
    "bitbybit.vector.vectorXY_description": "Erstellt einen 2D-Vektor aus x-, y-Koordinaten. Beispiel: x=3, y=4 → [3,4]",
    "bitbybit.vector.range": "Bereich",
    "range": "Bereich",
    "bitbybit.vector.range_description": "Erstellt einen Vektor aus Ganzzahlen von 0 bis max (exklusiv). Beispiel: max=5 → [0,1,2,3,4], max=3 → [0,1,2]",
    "bitbybit.vector.signedAngleBetween": "signierter Winkel zwischen",
    "signedAngleBetween": "signierter Winkel zwischen",
    "bitbybit.vector.signedAngleBetween_description": "Berechnet den vorzeichenbehafteten Winkel zwischen zwei Vektoren unter Verwendung eines Referenzvektors (bestimmt die Drehrichtung). Beispiel: Gibt je nach Drehrichtung relativ zur Referenz einen positiven oder negativen Winkel zurück",
    "bitbybit.vector.span": "Spanne",
    "span": "Spanne",
    "bitbybit.vector.span_description": "Erstellt einen Vektor, der Zahlen von min bis max in einem gegebenen Schrittinkrement enthält. Beispiel: min=0, max=10, step=2 → [0,2,4,6,8,10]",
    "bitbybit.vector.spanEaseItems": "Spanne mit Glättung",
    "spanEaseItems": "Spanne mit Glättung",
    "bitbybit.vector.spanEaseItems_description": "Erstellt einen Vektor mit Zahlen von min bis max unter Verwendung einer Easing-Funktion für nicht-lineare Verteilung. Beispiel: min=0, max=100, nrItems=5, ease='easeInQuad' → erstellt beschleunigende Intervalle",
    "nrItems": "Anzahl Elemente",
    "ease": "Glättung",
    "Math.easeEnum": "Math Glättungs-Enum",
    "intervals": "Intervalle",
    "bitbybit.vector.spanLinearItems": "lineare Spanne",
    "spanLinearItems": "lineare Spanne",
    "bitbybit.vector.spanLinearItems_description": "Erstellt einen Vektor mit gleichmäßig verteilten Zahlen von min bis max mit einer bestimmten Anzahl von Elementen. Beispiel: min=0, max=10, nrItems=5 → [0, 2.5, 5, 7.5, 10]",
    "bitbybit.vector.sub": "sub",
    "sub": "sub",
    "bitbybit.vector.sub_description": "Subtrahiert den zweiten Vektor vom ersten elementweise. Beispiel: [10,20,30] - [1,2,3] → [9,18,27]",
    "bitbybit.vector.sum": "Summe",
    "bitbybit.vector.sum_description": "Summiert alle Werte im Vektor und gibt eine einzelne Zahl zurück. Beispiel: [1,2,3,4] → 10, [5,10,15] → 30",
    "bitbybit.point.transformPoint": "Punkt transformieren",
    "transformPoint": "Punkt transformieren",
    "bitbybit.point.transformPoint_description": "Wendet Transformationsmatrix auf einen einzelnen Punkt an (rotiert, skaliert oder verschiebt). Beispiel: Punkt=[0,0,0] mit Verschiebung [5,5,0] → [5,5,0]",
    "transformation": "Transformation",
    "Base.TransformMatrixes": "Basis-Transformationsmatrizen",
    "bitbybit.point.transformPoints": "Punkte transformieren",
    "transformPoints": "Punkte transformieren",
    "bitbybit.point.transformPoints_description": "Wendet dieselbe Transformationsmatrix auf mehrere Punkte an (Batch-Transformation). Beispiel: 5 Punkte mit Rotation 90° → alle 5 Punkte zusammen rotiert",
    "points": "Punkte",
    "bitbybit.point.transformsForPoints": "Transformationen für Punkte",
    "transformsForPoints": "Transformationen für Punkte",
    "bitbybit.point.transformsForPoints_description": "Wendet unterschiedliche Transformationsmatrizen auf entsprechende Punkte an (eine Transformation pro Punkt). Arrays müssen gleiche Länge haben. Beispiel: 3 Punkte mit 3 verschiedenen Verschiebungen → jeder Punkt unabhängig bewegt",
    "Base.TransformMatrixes[]": "Array von Basis-Transformationsmatrizen",
    "bitbybit.point.translatePoints": "Punkte verschieben",
    "translatePoints": "Punkte verschieben",
    "bitbybit.point.translatePoints_description": "Verschiebt mehrere Punkte um einen Verschiebungsvektor (gleicher Versatz für alle Punkte). Beispiel: Punkte=[[0,0,0], [1,0,0]], Verschiebung=[5,5,0] → [[5,5,0], [6,5,0]]",
    "bitbybit.point.translatePointsWithVectors": "Punkte mit Vektoren verschieben",
    "translatePointsWithVectors": "Punkte mit Vektoren verschieben",
    "bitbybit.point.translatePointsWithVectors_description": "Verschiebt mehrere Punkte um entsprechende Verschiebungsvektoren (ein Vektor pro Punkt). Arrays müssen gleiche Länge haben. Beispiel: 3 Punkte mit 3 verschiedenen Vektoren → jeder Punkt um seinen entsprechenden Vektor bewegt",
    "bitbybit.point.translateXYZPoints": "XYZ-Punkte verschieben",
    "translateXYZPoints": "XYZ-Punkte verschieben",
    "bitbybit.point.translateXYZPoints_description": "Verschiebt mehrere Punkte um separate X-, Y-, Z-Werte (Komfortmethode für Verschiebung). Beispiel: Punkte=[[0,0,0]], x=10, y=5, z=0 → [[10,5,0]]",
    "bitbybit.point.scalePointsCenterXYZ": "Punkte um Zentrum XYZ skalieren",
    "scalePointsCenterXYZ": "Punkte um Zentrum XYZ skalieren",
    "bitbybit.point.scalePointsCenterXYZ_description": "Skaliert mehrere Punkte um einen Mittelpunkt mit unterschiedlichen Faktoren pro Achse. Beispiel: Punkte=[[10,0,0]], Zentrum=[5,0,0], SkalaXyz=[2,1,1] → [[15,0,0]] (verdoppelt X-Abstand vom Zentrum)",
    "bitbybit.point.rotatePointsCenterAxis": "Punkte um Zentrum und Achse drehen",
    "rotatePointsCenterAxis": "Punkte um Zentrum und Achse drehen",
    "bitbybit.point.rotatePointsCenterAxis_description": "Rotiert mehrere Punkte um einen Mittelpunkt entlang einer benutzerdefinierten Achse. Beispiel: Punkte=[[10,0,0]], Zentrum=[0,0,0], Achse=[0,1,0], Winkel=90° → [[0,0,-10]]",
    "bitbybit.point.closestPointFromPointsDistance": "nächster Punkt Abstand",
    "closestPointFromPointsDistance": "nächster Punkt Abstand",
    "bitbybit.point.closestPointFromPointsDistance_description": "Berechnet Abstand zum nächsten Punkt in einer Sammlung. Beispiel: Punkt=[0,0,0], Punkte=[[5,0,0], [10,0,0], [3,0,0]] → 3 (Abstand zu [3,0,0])",
    "bitbybit.point.closestPointFromPointsIndex": "nächster Punkt Index",
    "closestPointFromPointsIndex": "nächster Punkt Index",
    "bitbybit.point.closestPointFromPointsIndex_description": "Findet Array-Index des nächsten Punktes in einer Sammlung (1-basierter Index, nicht 0-basiert). Beispiel: Punkt=[0,0,0], Punkte=[[5,0,0], [10,0,0], [3,0,0]] → 3 (Index von [3,0,0])",
    "bitbybit.point.closestPointFromPoints": "nächster Punkt",
    "closestPointFromPoints": "nächster Punkt",
    "bitbybit.point.closestPointFromPoints_description": "Findet den nächsten Punkt in einer Sammlung zu einem Referenzpunkt. Beispiel: Punkt=[0,0,0], Punkte=[[5,0,0], [10,0,0], [3,0,0]] → [3,0,0]",
    "bitbybit.point.distance": "Abstand",
    "bitbybit.point.distance_description": "Berechnet euklidischen Abstand zwischen zwei Punkten. Beispiel: Start=[0,0,0], Ende=[3,4,0] → 5 (unter Verwendung des Satzes des Pythagoras: √(3²+4²))",
    "measure": "messen",
    "startPoint": "Startpunkt",
    "endPoint": "Endpunkt",
    "bitbybit.point.distancesToPoints": "Abstände zu Punkten",
    "distancesToPoints": "Abstände zu Punkten",
    "bitbybit.point.distancesToPoints_description": "Berechnet Abstände von einem Startpunkt zu mehreren Endpunkten. Beispiel: Start=[0,0,0], Endpunkte=[[3,0,0], [0,4,0], [5,0,0]] → [3, 4, 5]",
    "endPoints": "Endpunkte",
    "bitbybit.point.multiplyPoint": "Punkt multiplizieren",
    "multiplyPoint": "Punkt multiplizieren",
    "bitbybit.point.multiplyPoint_description": "Dupliziert einen Punkt N mal (erstellt Array mit N Kopien desselben Punktes). Beispiel: Punkt=[5,5,0], AnzahlPunkte=3 → [[5,5,0], [5,5,0], [5,5,0]]",
    "amountOfPoints": "Anzahl Punkte",
    "bitbybit.point.getX": "X abrufen",
    "getX": "X abrufen",
    "bitbybit.point.getX_description": "Extrahiert X-Koordinate aus einem Punkt. Beispiel: Punkt=[5,10,3] → 5",
    "bitbybit.point.getY": "Y abrufen",
    "getY": "Y abrufen",
    "bitbybit.point.getY_description": "Extrahiert Y-Koordinate aus einem Punkt. Beispiel: Punkt=[5,10,3] → 10",
    "bitbybit.point.getZ": "Z abrufen",
    "getZ": "Z abrufen",
    "bitbybit.point.getZ_description": "Extrahiert Z-Koordinate aus einem Punkt. Beispiel: Punkt=[5,10,3] → 3",
    "bitbybit.point.averagePoint": "Durchschnittspunkt",
    "averagePoint": "Durchschnittspunkt",
    "bitbybit.point.averagePoint_description": "Berechnet Schwerpunkt (durchschnittliche Position) mehrerer Punkte. Beispiel: Punkte=[[0,0,0], [10,0,0], [10,10,0]] → [6.67,3.33,0]",
    "bitbybit.point.pointXYZ": "Punkt XYZ",
    "pointXYZ": "Punkt XYZ",
    "bitbybit.point.pointXYZ_description": "Erstellt einen 3D-Punkt aus X-, Y-, Z-Koordinaten. Beispiel: x=10, y=5, z=3 → [10,5,3]",
    "bitbybit.point.pointXY": "Punkt XY",
    "pointXY": "Punkt XY",
    "bitbybit.point.pointXY_description": "Erstellt einen 2D-Punkt aus X-, Y-Koordinaten. Beispiel: x=10, y=5 → [10,5]",
    "bitbybit.point.spiral": "Spirale",
    "spiral": "Spirale",
    "bitbybit.point.spiral_description": "Erstellt logarithmische Spiralpunkte unter Verwendung des Goldenen Winkels oder eines benutzerdefinierten Verbreiterungsfaktors. Generiert natürliche Spiralmuster, die in der Natur vorkommen (Sonnenblume, Nautilusmuschel). Beispiel: AnzahlPunkte=100, Radius=10, phi=1.618 → 100 Punkte bilden Spirale nach außen",
    "phi": "Phi",
    "numberPoints": "Anzahl Punkte",
    "widening": "Erweiterung",
    "factor": "Faktor",
    "bitbybit.point.hexGrid": "Hex-Gitter",
    "hexGrid": "Hex-Gitter",
    "bitbybit.point.hexGrid_description": "Erstellt sechseckige Gittermittelpunkte auf der XY-Ebene (Wabenmuster). Gittergröße gesteuert durch Anzahl der Sechsecke, nicht Breite/Höhe. Beispiel: RadiusHexagon=1, nrHexagonsX=3, nrHexagonsY=3 → 9 Sechseckzentren im Gittermuster",
    "nrHexagonsY": "Anzahl Hexagone Y",
    "nrHexagonsX": "Anzahl Hexagone X",
    "radiusHexagon": "Hexagon-Radius",
    "orientOnCenter": "am Zentrum ausrichten",
    "pointsOnGround": "Punkte auf dem Boden",
    "bitbybit.point.removeConsecutiveDuplicates": "aufeinanderfolgende Duplikate entfernen",
    "removeConsecutiveDuplicates": "aufeinanderfolgende Duplikate entfernen",
    "bitbybit.point.removeConsecutiveDuplicates_description": "Entfernt aufeinanderfolgende doppelte Punkte aus Array innerhalb Toleranz. Beispiel: [[0,0,0], [0,0,0], [1,0,0], [1,0,0], [2,0,0]] → [[0,0,0], [1,0,0], [2,0,0]]",
    "clean": "bereinigen",
    "bitbybit.line.convertToNurbsCurve": "in NURBS-Kurve umwandeln",
    "line": "Linie",
    "convertToNurbsCurve": "in NURBS-Kurve umwandeln",
    "bitbybit.line.convertToNurbsCurve_description": "wandelt eine Linie in eine NURBS-Kurve um",
    "LinePointsDto": "Linienpunkte DTO",
    "bitbybit.line.convertLinesToNurbsCurves": "Linien in NURBS-Kurven umwandeln",
    "convertLinesToNurbsCurves": "Linien in NURBS-Kurven umwandeln",
    "bitbybit.line.convertLinesToNurbsCurves_description": "wandelt Linien in ein Array von NURBS-Kurven um",
    "lines": "Linien",
    "LinePointsDto[]": "Array von Linienpunkten DTO",
    "bitbybit.line.getStartPoint": "Startpunkt abrufen",
    "getStartPoint": "Startpunkt abrufen",
    "bitbybit.line.getStartPoint_description": "Extrahiert Startpunkt aus einer Linie. Beispiel: Linie={start:[0,0,0], end:[10,5,0]} → [0,0,0]",
    "bitbybit.line.getEndPoint": "Endpunkt abrufen",
    "getEndPoint": "Endpunkt abrufen",
    "bitbybit.line.getEndPoint_description": "Extrahiert Endpunkt aus einer Linie. Beispiel: Linie={start:[0,0,0], end:[10,5,0]} → [10,5,0]",
    "bitbybit.line.length": "Länge",
    "bitbybit.line.length_description": "Berechnet Länge (Abstand) eines Liniensegments. Beispiel: Linie={start:[0,0,0], end:[3,4,0]} → 5 (unter Verwendung des Satzes des Pythagoras)",
    "bitbybit.line.reverse": "umkehren",
    "reverse": "umkehren",
    "bitbybit.line.reverse_description": "Kehrt Linienrichtung um, indem Start- und Endpunkte vertauscht werden. Beispiel: Linie={start:[0,0,0], end:[10,5,0]} → {start:[10,5,0], end:[0,0,0]}",
    "bitbybit.line.transformLine": "Linie transformieren",
    "transformLine": "Linie transformieren",
    "bitbybit.line.transformLine_description": "Wendet Transformationsmatrix auf Linie an (rotiert, skaliert oder verschiebt beide Endpunkte). Beispiel: Linie={start:[0,0,0], end:[10,0,0]} mit Verschiebung [5,5,0] → {start:[5,5,0], end:[15,5,0]}",
    "bitbybit.line.transformsForLines": "Transformationen für Linien",
    "transformsForLines": "Transformationen für Linien",
    "bitbybit.line.transformsForLines_description": "Wendet mehrere Transformationen auf mehrere Linien an (eine Transformation pro Linie). Beispiel: 3 Linien mit 3 verschiedenen Transformationsmatrizen → jede Linie unabhängig bewegt",
    "bitbybit.line.create": "erstellen",
    "bitbybit.line.create_description": "Erstellt eine Linie aus zwei Punkten (Linienobjekt mit Start- und Endeigenschaften). Beispiel: Start=[0,0,0], Ende=[10,5,0] → {start:[0,0,0], end:[10,5,0]}",
    "bitbybit.line.createAsync": "asynchron",
    "createAsync": "asynchron",
    "bitbybit.line.createAsync_description": "erstellt eine Linie aus asynchronen Punkten",
    "bitbybit.line.getPointOnLine": "Punkt auf Linie abrufen",
    "getPointOnLine": "Punkt auf Linie abrufen",
    "bitbybit.line.getPointOnLine_description": "Berechnet Punkt bei Parameter t entlang des Liniensegments (0=Start, 1=Ende, lineare Interpolation). Beispiel: Linie={start:[0,0,0], end:[10,0,0]}, Param=0.5 → [5,0,0] (Mittelpunkt)",
    "param": "Parameter",
    "bitbybit.line.linesBetweenPoints": "Linien zwischen Punkten",
    "linesBetweenPoints": "Linien zwischen Punkten",
    "bitbybit.line.linesBetweenPoints_description": "Erstellt Liniensegmente, die aufeinanderfolgende Punkte in einer Liste verbinden (bildet einen Polylinienpfad). Beispiel: Punkte=[[0,0,0], [5,0,0], [5,5,0]] → 2 Linien: [0→5] und [5→5,5]",
    "bitbybit.line.linesBetweenStartAndEndPoints": "Linien zwischen Start- und Endpunkten",
    "linesBetweenStartAndEndPoints": "Linien zwischen Start- und Endpunkten",
    "bitbybit.line.linesBetweenStartAndEndPoints_description": "Erstellt Linien durch Paarung entsprechender Start- und Endpunkte aus zwei Arrays. Filtert Linien mit Länge Null heraus. Beispiel: Starts=[[0,0,0], [5,0,0]], Enden=[[0,5,0], [5,5,0]] → 2 Linien verbinden gepaarte Punkte",
    "startPoints": "Startpunkte",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync": "Linien zwischen Start- und Endpunkten asynchron",
    "linesBetweenStartAndEndPointsAsync": "Linien zwischen Start- und Endpunkten asynchron",
    "bitbybit.line.linesBetweenStartAndEndPointsAsync_description": "erstellt Linien zwischen Start- und Endpunkten mit asynchronen Eingaben",
    "bitbybit.polyline.convertToNurbsCurve": "in NURBS-Kurve umwandeln",
    "polyline": "Polylinie",
    "bitbybit.polyline.convertToNurbsCurve_description": "wandelt eine Polylinie in eine NURBS-Kurve um",
    "PolylinePropertiesDto": "Polylinien-Eigenschaften DTO",
    "bitbybit.polyline.length": "Länge",
    "bitbybit.polyline.length_description": "Berechnet Gesamtlänge der Polylinie durch Summieren der Abstände zwischen aufeinanderfolgenden Punkten. Beispiel: Punkte=[[0,0,0], [3,0,0], [3,4,0]] → 3 + 4 = 7",
    "bitbybit.polyline.countPoints": "Punkte zählen",
    "countPoints": "Punkte zählen",
    "bitbybit.polyline.countPoints_description": "Zählt Anzahl der Punkte in Polylinie. Beispiel: Polylinie mit Punkte=[[0,0,0], [1,0,0], [1,1,0]] → 3",
    "bitbybit.polyline.getPoints": "Punkte abrufen",
    "getPoints": "Punkte abrufen",
    "bitbybit.polyline.getPoints_description": "Extrahiert Punkte-Array aus Polylinienobjekt. Beispiel: Polylinie={points:[[0,0,0], [1,0,0]]} → [[0,0,0], [1,0,0]]",
    "bitbybit.polyline.reverse": "umkehren",
    "bitbybit.polyline.reverse_description": "Kehrt Punktreihenfolge der Polylinie um (kehrt Richtung um). Beispiel: Punkte=[[0,0,0], [1,0,0], [2,0,0]] → [[2,0,0], [1,0,0], [0,0,0]]",
    "bitbybit.polyline.transformPolyline": "Polylinie transformieren",
    "transformPolyline": "Polylinie transformieren",
    "bitbybit.polyline.transformPolyline_description": "Wendet Transformationsmatrix auf alle Punkte in Polylinie an (rotiert, skaliert oder verschiebt). Beispiel: Polylinie mit 4 Punkten, Verschiebung [5,0,0] → alle Punkte um +5 in X-Richtung verschoben",
    "bitbybit.polyline.create": "erstellen",
    "bitbybit.polyline.create_description": "Erstellt eine Polylinie aus Punkte-Array mit optionalem isClosed-Flag. Beispiel: Punkte=[[0,0,0], [1,0,0], [1,1,0]], isClosed=true → {points:..., isClosed:true}",
    "isClosed": "ist geschlossen",
    "string | number[]": "Zeichenkette oder Zahlen-Array",
    "bitbybit.occt.deleteShape": "Form löschen",
    "occt": "OCCT",
    "deleteShape": "Form löschen",
    "bitbybit.occt.deleteShape_description": "Löscht Form aus dem Cache, um Speichernutzung niedrig zu halten.",
    "bitbybit.occt.deleteShapes": "Formen löschen",
    "deleteShapes": "Formen löschen",
    "bitbybit.occt.deleteShapes_description": "Löscht Formen aus dem Cache, um Speichernutzung niedrig zu halten.",
    "shapes": "Formen",
    "T[]": "T-Array",
    "bitbybit.occt.cleanAllCache": "gesamten Cache bereinigen",
    "cleanAllCache": "gesamten Cache bereinigen",
    "bitbybit.occt.cleanAllCache_description": "Bereinigt gesamten Cache und alle Formen aus dem Speicher.",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ": "Vertex aus XYZ",
    "vertex": "Vertex",
    "vertexFromXYZ": "Vertex aus XYZ",
    "bitbybit.occt.shapes.vertex.vertexFromXYZ_description": "Erstellt Vertex-Form aus x y z Koordinaten.",
    "bitbybit.occt.shapes.vertex.vertexFromPoint": "Vertex aus Punkt",
    "vertexFromPoint": "Vertex aus Punkt",
    "bitbybit.occt.shapes.vertex.vertexFromPoint_description": "Erstellt Vertex-Form aus Punkt.",
    "bitbybit.occt.shapes.vertex.verticesFromPoints": "Vertices aus Punkten",
    "verticesFromPoints": "Vertices aus Punkten",
    "bitbybit.occt.shapes.vertex.verticesFromPoints_description": "erstellt Vertices aus Punkten",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints": "Vertices-Verbindung aus Punkten",
    "verticesCompoundFromPoints": "Vertices-Verbindung aus Punkten",
    "bitbybit.occt.shapes.vertex.verticesCompoundFromPoints_description": "Erstellt Verbundform (Compound), die mehrere Vertices enthält. Dies beschleunigt das Rendern und ermöglicht das einfache Anwenden von OCCT-Transformationen auf Vertex-Gruppen.",
    "bitbybit.occt.shapes.vertex.getVertices": "Vertices abrufen",
    "getVertices": "Vertices abrufen",
    "bitbybit.occt.shapes.vertex.getVertices_description": "Ruft alle Vertices in der Liste einer Form ab.",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints": "Vertices als Punkte abrufen",
    "getVerticesAsPoints": "Vertices als Punkte abrufen",
    "bitbybit.occt.shapes.vertex.getVerticesAsPoints_description": "Ruft alle Vertices in der Liste einer Form als Punkte ab.",
    "bitbybit.occt.shapes.vertex.verticesToPoints": "Vertices zu Punkten",
    "verticesToPoints": "Vertices zu Punkten",
    "bitbybit.occt.shapes.vertex.verticesToPoints_description": "transformiert Vertices zu Punkten",
    "transform": "transformieren",
    "bitbybit.occt.shapes.vertex.vertexToPoint": "Vertex zu Punkt",
    "vertexToPoint": "Vertex zu Punkt",
    "bitbybit.occt.shapes.vertex.vertexToPoint_description": "Transformiert Vertex zu Punkt.",
    "bitbybit.occt.shapes.vertex.projectPoints": "Punkte projizieren",
    "projectPoints": "Punkte projizieren",
    "bitbybit.occt.shapes.vertex.projectPoints_description": "Projizieren Sie Punkte auf eine Form und geben Sie die projizierten Punkte zurück - die Länge des Vektors ist wesentlich",
    "place": "platzieren",
    "projectionType": "Projektionstyp",
    "pointProjectionTypeEnum": "Punktprojektionstyp-Enum",
    "bitbybit.occt.shapes.edge.line": "Linie",
    "edge": "Kante",
    "bitbybit.occt.shapes.edge.line_description": "erstellt eine lineare Kante zwischen zwei Punkten",
    "primitives": "Primitive",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints": "Bogen durch drei Punkte",
    "arcThroughThreePoints": "Bogen durch drei Punkte",
    "bitbybit.occt.shapes.edge.arcThroughThreePoints_description": "Erstellt Bogenkante zwischen drei Punkten.",
    "middle": "Mitte",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent": "Bogen durch zwei Punkte und Tangente",
    "arcThroughTwoPointsAndTangent": "Bogen durch zwei Punkte und Tangente",
    "bitbybit.occt.shapes.edge.arcThroughTwoPointsAndTangent_description": "Erstellt Bogenkante zwischen zwei Punkten gegeben den Tangentenrichtungsvektor am ersten Punkt.",
    "tangentVec": "Tangentenvektor",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints": "Bogen aus Kreis und zwei Punkten",
    "arcFromCircleAndTwoPoints": "Bogen aus Kreis und zwei Punkten",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoPoints_description": "Erstellt eine Bogenkante zwischen zwei Punkten auf einem Kreis.",
    "circle": "Kreis",
    "sense": "Richtung",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles": "Bogen aus Kreis und zwei Winkeln",
    "arcFromCircleAndTwoAngles": "Bogen aus Kreis und zwei Winkeln",
    "bitbybit.occt.shapes.edge.arcFromCircleAndTwoAngles_description": "Erstellt eine Bogenkante zwischen zwei Alpha-Winkeln auf einem Kreis.",
    "alphaAngle1": "Alpha-Winkel 1",
    "alphaAngle2": "Alpha-Winkel 2",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle": "Bogen aus Kreis, Punkt und Winkel",
    "arcFromCirclePointAndAngle": "Bogen aus Kreis, Punkt und Winkel",
    "bitbybit.occt.shapes.edge.arcFromCirclePointAndAngle_description": "Erstellt eine Bogenkante zwischen dem Punkt auf einem Kreis und einem gegebenen Alpha-Winkel.",
    "alphaAngle": "Alpha-Winkel",
    "bitbybit.occt.shapes.edge.createCircleEdge": "Kreiskante",
    "createCircleEdge": "Kreiskante",
    "bitbybit.occt.shapes.edge.createCircleEdge_description": "erstellt eine OpenCascade-Kreiskante",
    "bitbybit.occt.shapes.edge.createEllipseEdge": "Ellipsenkante",
    "createEllipseEdge": "Ellipsenkante",
    "bitbybit.occt.shapes.edge.createEllipseEdge_description": "erstellt eine OpenCascade-Ellipsenkante",
    "radiusMinor": "kleiner Radius",
    "radiusMajor": "großer Radius",
    "bitbybit.occt.shapes.edge.removeInternalEdges": "interne Kanten entfernen",
    "removeInternalEdges": "interne Kanten entfernen",
    "bitbybit.occt.shapes.edge.removeInternalEdges_description": "Entfernt interne Flächen für die Form.",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface": "Kante aus 2D-Geometriekurve und Fläche erstellen",
    "makeEdgeFromGeom2dCurveAndSurface": "Kante aus 2D-Geometriekurve und Fläche erstellen",
    "bitbybit.occt.shapes.edge.makeEdgeFromGeom2dCurveAndSurface_description": "Erstellt eine Kante aus Geom-Kurve und Geom-Oberfläche.",
    "curve": "Kurve",
    "surface": "Fläche",
    "U": "U",
    "bitbybit.occt.shapes.edge.getEdge": "Kante abrufen",
    "getEdge": "Kante abrufen",
    "bitbybit.occt.shapes.edge.getEdge_description": "Ruft die Kante durch Bereitstellung eines Index von der Form ab.",
    "index": "Index",
    "bitbybit.occt.shapes.edge.getEdges": "Kanten abrufen",
    "getEdges": "Kanten abrufen",
    "bitbybit.occt.shapes.edge.getEdges_description": "Ruft die Kanten einer Form in einer Liste ab.",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire": "Kanten entlang eines Drahtes abrufen",
    "getEdgesAlongWire": "Kanten entlang eines Drahtes abrufen",
    "bitbybit.occt.shapes.edge.getEdgesAlongWire_description": "Ruft die Kanten eines Drahtes geordnet entlang der Richtung des Drahtes ab.",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire": "kreisförmige Kanten entlang eines Drahtes abrufen",
    "getCircularEdgesAlongWire": "kreisförmige Kanten entlang eines Drahtes abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgesAlongWire_description": "Ruft kreisförmige Kanten eines Drahtes geordnet entlang der Richtung des Drahtes ab.",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire": "lineare Kanten entlang eines Drahtes abrufen",
    "getLinearEdgesAlongWire": "lineare Kanten entlang eines Drahtes abrufen",
    "bitbybit.occt.shapes.edge.getLinearEdgesAlongWire_description": "Ruft lineare Kanten eines Drahtes geordnet entlang der Richtung des Drahtes ab.",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape": "Eckpunkte der Kanten einer Form abrufen",
    "getCornerPointsOfEdgesForShape": "Eckpunkte der Kanten einer Form abrufen",
    "bitbybit.occt.shapes.edge.getCornerPointsOfEdgesForShape_description": "Ruft Eckpunkte von Kanten für eine Form ab. Hier gibt es keine Garantien für die Reihenfolge. Alle Duplikate werden entfernt, sodass wenn drei Kanten eine Ecke bilden, dies durch einen einzelnen Punkt in der Liste dargestellt wird.",
    "bitbybit.occt.shapes.edge.getEdgeLength": "Kantenlänge abrufen",
    "getEdgeLength": "Kantenlänge abrufen",
    "bitbybit.occt.shapes.edge.getEdgeLength_description": "Ruft die Kantenlänge ab.",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape": "Kantenlängen einer Form abrufen",
    "getEdgeLengthsOfShape": "Kantenlängen einer Form abrufen",
    "bitbybit.occt.shapes.edge.getEdgeLengthsOfShape_description": "Ruft die Kantenlängen der Form ab.",
    "bitbybit.occt.shapes.edge.getEdgesLengths": "Kantenlängen abrufen",
    "getEdgesLengths": "Kantenlängen abrufen",
    "bitbybit.occt.shapes.edge.getEdgesLengths_description": "Ruft die Längen der Kanten ab.",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass": "Schwerpunkt der Kante abrufen",
    "getEdgeCenterOfMass": "Schwerpunkt der Kante abrufen",
    "bitbybit.occt.shapes.edge.getEdgeCenterOfMass_description": "Ruft den Massenschwerpunkt für die Kante ab.",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass": "Schwerpunkte der Kanten abrufen",
    "getEdgesCentersOfMass": "Schwerpunkte der Kanten abrufen",
    "bitbybit.occt.shapes.edge.getEdgesCentersOfMass_description": "Ruft die Massenschwerpunkte für die Kanten ab.",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint": "Mittelpunkt der kreisförmigen Kante abrufen",
    "getCircularEdgeCenterPoint": "Mittelpunkt der kreisförmigen Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgeCenterPoint_description": "Ruft den Mittelpunkt der kreisförmigen Kante ab. Wenn Kante nicht kreisförmig ist, wird kein Punkt zurückgegeben.",
    "get circular edge": "kreisförmige Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius": "Radius der kreisförmigen Kante abrufen",
    "getCircularEdgeRadius": "Radius der kreisförmigen Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgeRadius_description": "Ruft den Radius der kreisförmigen Kante ab. Wenn Kante nicht kreisförmig ist, wird kein Radius zurückgegeben.",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection": "Ebenenrichtung der kreisförmigen Kante abrufen",
    "getCircularEdgePlaneDirection": "Ebenenrichtung der kreisförmigen Kante abrufen",
    "bitbybit.occt.shapes.edge.getCircularEdgePlaneDirection_description": "Ruft den Richtungsvektor der Ebene der kreisförmigen Kante ab. Wenn Kante nicht kreisförmig ist, wird kein Richtungsvektor zurückgegeben.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam": "Punkt auf Kante bei Parameter",
    "pointOnEdgeAtParam": "Punkt auf Kante bei Parameter",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtParam_description": "Ruft den Punkt auf Kante bei Parameter ab.",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam": "Punkte auf Kanten bei Parameter",
    "pointsOnEdgesAtParam": "Punkte auf Kanten bei Parameter",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtParam_description": "Ruft die Punkte auf Kanten bei Parameter ab.",
    "bitbybit.occt.shapes.edge.edgesToPoints": "Kanten zu Punkten",
    "edgesToPoints": "Kanten zu Punkten",
    "bitbybit.occt.shapes.edge.edgesToPoints_description": "Ruft die Punkte aller Kanten von einer Form in separaten Listen für jede Kante ab.",
    "angularDeflection": "Winkelablenkung",
    "curvatureDeflection": "Krümmungsablenkung",
    "minimumOfPoints": "Minimum an Punkten",
    "uTolerance": "U-Toleranz",
    "minimumLength": "Mindestlänge",
    "bitbybit.occt.shapes.edge.reversedEdge": "umgekehrte Kante",
    "reversedEdge": "umgekehrte Kante",
    "bitbybit.occt.shapes.edge.reversedEdge_description": "Berechnet umgekehrte Kante aus Eingabekante.",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam": "Tangente auf Kante bei Parameter",
    "tangentOnEdgeAtParam": "Tangente auf Kante bei Parameter",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtParam_description": "Ruft den Tangentenvektor auf Kante bei Parameter ab.",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam": "Tangenten auf Kanten bei Parameter",
    "tangentsOnEdgesAtParam": "Tangenten auf Kanten bei Parameter",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtParam_description": "Ruft die Tangentenvektoren auf Kanten bei Parameter ab.",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength": "Punkt auf Kante bei Länge",
    "pointOnEdgeAtLength": "Punkt auf Kante bei Länge",
    "bitbybit.occt.shapes.edge.pointOnEdgeAtLength_description": "Ruft den Punkt auf Kante bei Länge ab.",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength": "Punkte auf Kanten bei Länge",
    "pointsOnEdgesAtLength": "Punkte auf Kanten bei Länge",
    "bitbybit.occt.shapes.edge.pointsOnEdgesAtLength_description": "Ruft die Punkte auf Kanten bei Länge ab.",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength": "Tangente auf Kante bei Länge",
    "tangentOnEdgeAtLength": "Tangente auf Kante bei Länge",
    "bitbybit.occt.shapes.edge.tangentOnEdgeAtLength_description": "Ruft den Tangentenvektor auf Kante bei Länge ab.",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength": "Tangenten auf Kanten bei Länge",
    "tangentsOnEdgesAtLength": "Tangenten auf Kanten bei Länge",
    "bitbybit.occt.shapes.edge.tangentsOnEdgesAtLength_description": "Ruft die Tangentenvektoren auf Kanten bei Länge ab.",
    "bitbybit.occt.shapes.edge.startPointOnEdge": "Startpunkt auf Kante",
    "startPointOnEdge": "Startpunkt auf Kante",
    "bitbybit.occt.shapes.edge.startPointOnEdge_description": "Ruft den Startpunkt auf Kante ab.",
    "bitbybit.occt.shapes.edge.startPointsOnEdges": "Startpunkte auf Kanten",
    "startPointsOnEdges": "Startpunkte auf Kanten",
    "bitbybit.occt.shapes.edge.startPointsOnEdges_description": "Ruft die Startpunkte auf Kanten ab.",
    "bitbybit.occt.shapes.edge.endPointOnEdge": "Endpunkt auf Kante",
    "endPointOnEdge": "Endpunkt auf Kante",
    "bitbybit.occt.shapes.edge.endPointOnEdge_description": "Ruft den Endpunkt auf Kante ab.",
    "bitbybit.occt.shapes.edge.endPointsOnEdges": "Endpunkte auf Kanten",
    "endPointsOnEdges": "Endpunkte auf Kanten",
    "bitbybit.occt.shapes.edge.endPointsOnEdges_description": "Ruft die Endpunkte auf Kanten ab.",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints": "Kante nach Parametern in Punkte teilen",
    "divideEdgeByParamsToPoints": "Kante nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgeByParamsToPoints_description": "teilt eine Kante nach Parametern in Punkte",
    "nrOfDivisions": "Anzahl der Teilungen",
    "removeStartPoint": "Startpunkt entfernen",
    "removeEndPoint": "Endpunkt entfernen",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints": "Kanten nach Parametern in Punkte teilen",
    "divideEdgesByParamsToPoints": "Kanten nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgesByParamsToPoints_description": "teilt Kanten nach Parametern in Punkte",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints": "Kante nach gleichem Abstand in Punkte teilen",
    "divideEdgeByEqualDistanceToPoints": "Kante nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgeByEqualDistanceToPoints_description": "teilt eine Kante nach Länge in Punkte",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints": "Kanten nach gleichem Abstand in Punkte teilen",
    "divideEdgesByEqualDistanceToPoints": "Kanten nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.edge.divideEdgesByEqualDistanceToPoints_description": "teilt Kanten nach Länge in Punkte",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle": "Tangentenlinien von zwei Punkten zu einem Kreis einschränken",
    "constraintTanLinesFromTwoPtsToCircle": "Tangentenlinien von zwei Punkten zu einem Kreis einschränken",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromTwoPtsToCircle_description": "Erstellt Linien von zwei gegebenen Punkten bis zu Kreistangentenorten.",
    "constraint": "Einschränkung",
    "point1": "Punkt 1",
    "point2": "Punkt 2",
    "positionResult": "Positionsergebnis",
    "positionResultEnum": "Positionsergebnis-Enum",
    "circleRemainder": "Kreisrest",
    "circleInclusionEnum": "Kreiseinschluss-Enum",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle": "Tangentenlinien von einem Punkt zu einem Kreis einschränken",
    "constraintTanLinesFromPtToCircle": "Tangentenlinien von einem Punkt zu einem Kreis einschränken",
    "bitbybit.occt.shapes.edge.constraintTanLinesFromPtToCircle_description": "Erstellt Linien von einem gegebenen Punkt bis zu Kreistangentenorten.",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles": "Tangentenlinien auf zwei Kreisen einschränken",
    "constraintTanLinesOnTwoCircles": "Tangentenlinien auf zwei Kreisen einschränken",
    "bitbybit.occt.shapes.edge.constraintTanLinesOnTwoCircles_description": "Erstellt Tangentenlinien zwischen zwei Kreisen.",
    "circle1": "Kreis 1",
    "circle2": "Kreis 2",
    "circleRemainders": "Kreisreste",
    "twoCircleInclusionEnum": "Zwei-Kreiseinschluss-Enum",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles": "Tangentenkreise auf zwei Kreisen einschränken",
    "constraintTanCirclesOnTwoCircles": "Tangentenkreise auf zwei Kreisen einschränken",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnTwoCircles_description": "Erstellt Tangentenkreise zwischen zwei Kreisen.",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt": "Tangentenkreise auf Kreis und Punkt einschränken",
    "constraintTanCirclesOnCircleAndPnt": "Tangentenkreise auf Kreis und Punkt einschränken",
    "bitbybit.occt.shapes.edge.constraintTanCirclesOnCircleAndPnt_description": "Erstellt Tangentenkreise zwischen einem Punkt und einem Kreis.",
    "bitbybit.occt.shapes.edge.isEdgeLinear": "ist Kante linear",
    "isEdgeLinear": "ist Kante linear",
    "bitbybit.occt.shapes.edge.isEdgeLinear_description": "Prüft, ob eine Kante linear ist.",
    "is": "ist",
    "bitbybit.occt.shapes.edge.isEdgeCircular": "ist Kante kreisförmig",
    "isEdgeCircular": "ist Kante kreisförmig",
    "bitbybit.occt.shapes.edge.isEdgeCircular_description": "Prüft, ob eine Kante kreisförmig ist.",
    "bitbybit.occt.shapes.wire.createPolygonWire": "Polygon-Draht",
    "wire": "Draht",
    "createPolygonWire": "Polygon-Draht",
    "bitbybit.occt.shapes.wire.createPolygonWire_description": "erstellt einen OpenCascade-Polygon-Draht",
    "via points": "über Punkte",
    "bitbybit.occt.shapes.wire.createPolygons": "Polygone",
    "createPolygons": "Polygone",
    "bitbybit.occt.shapes.wire.createPolygons_description": "erstellt OpenCascade-Polygone",
    "multiple": "mehrere",
    "polygons": "Polygone",
    "PolygonDto[]": "Polygon-DTO-Array",
    "returnCompound": "Verbindung zurückgeben",
    "bitbybit.occt.shapes.wire.createLineWire": "Linien-Draht",
    "createLineWire": "Linien-Draht",
    "bitbybit.occt.shapes.wire.createLineWire_description": "erstellt einen OpenCascade-Linien-Draht",
    "bitbybit.occt.shapes.wire.createLines": "Linien",
    "createLines": "Linien",
    "bitbybit.occt.shapes.wire.createLines_description": "erstellt OpenCascade-Linien",
    "LineDto[]": "Linien-DTO-Array",
    "bitbybit.occt.shapes.wire.splitOnPoints": "an Punkten teilen",
    "splitOnPoints": "an Punkten teilen",
    "bitbybit.occt.shapes.wire.splitOnPoints_description": "Teilt einen Draht an einem Satz gegebener Punkte.",
    "bitbybit.occt.shapes.wire.wiresToPoints": "Drähte zu Punkten",
    "wiresToPoints": "Drähte zu Punkten",
    "bitbybit.occt.shapes.wire.wiresToPoints_description": "Transformiert Formdrähte in Punkte, die in Listen geordnet sind. Dies entfernt auch doppelte Punkte zwischen Start- und Endpunkten aufeinanderfolgender Kanten auf dem Draht.",
    "bitbybit.occt.shapes.wire.createPolylineWire": "Polylinien-Draht",
    "createPolylineWire": "Polylinien-Draht",
    "bitbybit.occt.shapes.wire.createPolylineWire_description": "erstellt einen OpenCascade-Polylinien-Draht",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires": "Zickzack zwischen zwei Drähten",
    "createZigZagBetweenTwoWires": "Zickzack zwischen zwei Drähten",
    "bitbybit.occt.shapes.wire.createZigZagBetweenTwoWires_description": "erstellt einen Zickzack zwischen zwei Drähten",
    "via wires": "über Drähte",
    "wire1": "Draht 1",
    "wire2": "Draht 2",
    "nrZigZags": "Anzahl Zickzacks",
    "inverse": "invers",
    "divideByEqualDistance": "nach gleichem Abstand teilen",
    "zigZagsPerEdge": "Zickzacks pro Kante",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan": "Draht aus zwei tangentialen Kreisen",
    "createWireFromTwoCirclesTan": "Draht aus zwei tangentialen Kreisen",
    "bitbybit.occt.shapes.wire.createWireFromTwoCirclesTan_description": "Erstellt einen Tangentendraht, der zwei planare Kreise umschließt.",
    "keepLines": "Linien behalten",
    "twoSidesStrictEnum": "zwei Seiten strikt Enum",
    "fourSidesStrictEnum": "vier Seiten strikt Enum",
    "bitbybit.occt.shapes.wire.createPolylines": "Polylinien",
    "createPolylines": "Polylinien",
    "bitbybit.occt.shapes.wire.createPolylines_description": "erstellt OpenCascade-Polylinien-Drähte",
    "polylines": "Polylinien",
    "PolylineDto[]": "Polylinien-DTO-Array",
    "bitbybit.occt.shapes.wire.createBezier": "Bezier",
    "createBezier": "Bezier",
    "bitbybit.occt.shapes.wire.createBezier_description": "erstellt einen OpenCascade-Bezier-Draht",
    "bitbybit.occt.shapes.wire.createBezierWeights": "Bezier-Gewichte",
    "createBezierWeights": "Bezier-Gewichte",
    "bitbybit.occt.shapes.wire.createBezierWeights_description": "erstellt einen OpenCascade-Bezier-Draht mit Gewichten",
    "weights": "Gewichte",
    "bitbybit.occt.shapes.wire.createBezierWires": "Bezier-Drähte",
    "createBezierWires": "Bezier-Drähte",
    "bitbybit.occt.shapes.wire.createBezierWires_description": "erstellt OpenCascade-Bezier-Drähte",
    "bezierWires": "Bezier-Drähte",
    "BezierDto[]": "Bezier-DTO-Array",
    "bitbybit.occt.shapes.wire.interpolatePoints": "Punkte interpolieren",
    "interpolatePoints": "Punkte interpolieren",
    "bitbybit.occt.shapes.wire.interpolatePoints_description": "Erstellt OpenCascade BSpline-Draht aus Punkten. Diese Methode kann verwendet werden, um schön geformte (periodische) Schleifen zu erstellen.",
    "periodic": "periodisch",
    "bitbybit.occt.shapes.wire.interpolateWires": "Drähte interpolieren",
    "interpolateWires": "Drähte interpolieren",
    "bitbybit.occt.shapes.wire.interpolateWires_description": "Erstellt OpenCascade mehrere interpolierte Drähte.",
    "interpolations": "Interpolationen",
    "InterpolationDto[]": "Interpolations-DTO-Array",
    "bitbybit.occt.shapes.wire.createBSpline": "BSpline",
    "createBSpline": "BSpline",
    "bitbybit.occt.shapes.wire.createBSpline_description": "erstellt einen OpenCascade-BSpline-Draht",
    "bitbybit.occt.shapes.wire.createBSplines": "BSplines",
    "createBSplines": "BSplines",
    "bitbybit.occt.shapes.wire.createBSplines_description": "erstellt OpenCascade-BSpline-Drähte",
    "bSplines": "BSplines",
    "BSplineDto[]": "BSpline-DTO-Array",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire": "Kanten und Drähte zu einem Draht kombinieren",
    "combineEdgesAndWiresIntoAWire": "Kanten und Drähte zu einem Draht kombinieren",
    "bitbybit.occt.shapes.wire.combineEdgesAndWiresIntoAWire_description": "Kombiniert OpenCascade-Kanten und -Drähte zu einem einzigen Draht.",
    "build": "bauen",
    "bitbybit.occt.shapes.wire.createWireFromEdge": "Draht aus Kante",
    "createWireFromEdge": "Draht aus Kante",
    "bitbybit.occt.shapes.wire.createWireFromEdge_description": "erstellt einen Draht aus einer Kante",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire": "Kanten und Drähte zu Draht hinzufügen",
    "addEdgesAndWiresToWire": "Kanten und Drähte zu Draht hinzufügen",
    "bitbybit.occt.shapes.wire.addEdgesAndWiresToWire_description": "Fügt OpenCascade-Kanten und -Drähte zu einem anderen Draht hinzu.",
    "U[]": "U-Array",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints": "Draht nach Parametern in Punkte teilen",
    "divideWireByParamsToPoints": "Draht nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWireByParamsToPoints_description": "Teilt OpenCascade-Draht blindlings dem Parameterraum folgend in Punkte.",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints": "Drähte nach Parametern in Punkte teilen",
    "divideWiresByParamsToPoints": "Drähte nach Parametern in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWiresByParamsToPoints_description": "Teilt OpenCascade-Drähte blindlings dem Parameterraum folgend in Punkte.",
    "extract from wires": "aus Drähten extrahieren",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints": "Draht nach gleichem Abstand in Punkte teilen",
    "divideWireByEqualDistanceToPoints": "Draht nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWireByEqualDistanceToPoints_description": "Teilt OpenCascade-Draht in Punkte gleichen Abstands.",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints": "Drähte nach gleichem Abstand in Punkte teilen",
    "divideWiresByEqualDistanceToPoints": "Drähte nach gleichem Abstand in Punkte teilen",
    "bitbybit.occt.shapes.wire.divideWiresByEqualDistanceToPoints_description": "Teilt OpenCascade-Drähte in Punkte gleichen Abstands.",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam": "Punkt auf Draht bei Parameter",
    "pointOnWireAtParam": "Punkt auf Draht bei Parameter",
    "bitbybit.occt.shapes.wire.pointOnWireAtParam_description": "Wertet Punkt auf einem Draht bei Parameterwert zwischen 0 und 1 aus, was Start- und Endpunkte sind.",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength": "Punkt auf Draht bei Länge",
    "pointOnWireAtLength": "Punkt auf Draht bei Länge",
    "bitbybit.occt.shapes.wire.pointOnWireAtLength_description": "Wertet Punkt auf einem Draht bei bestimmter Länge aus.",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths": "Punkte auf Draht bei Längen",
    "pointsOnWireAtLengths": "Punkte auf Draht bei Längen",
    "bitbybit.occt.shapes.wire.pointsOnWireAtLengths_description": "Wertet Punkte auf einem Draht bei bestimmten Längen aus.",
    "lengths": "Längen",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength": "Punkte auf Draht bei gleicher Länge",
    "pointsOnWireAtEqualLength": "Punkte auf Draht bei gleicher Länge",
    "bitbybit.occt.shapes.wire.pointsOnWireAtEqualLength_description": "Wertet Punkte auf einem Draht bei gleicher Länge aus.",
    "tryNext": "nächsten versuchen",
    "includeFirst": "ersten einschließen",
    "includeLast": "letzten einschließen",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths": "Punkte auf Draht bei Längenmuster",
    "pointsOnWireAtPatternOfLengths": "Punkte auf Draht bei Längenmuster",
    "bitbybit.occt.shapes.wire.pointsOnWireAtPatternOfLengths_description": "Wertet Punkte auf einem Draht bei Muster von Längen aus.",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam": "Tangente auf Draht bei Parameter",
    "tangentOnWireAtParam": "Tangente auf Draht bei Parameter",
    "bitbybit.occt.shapes.wire.tangentOnWireAtParam_description": "Wertet Tangentenvektor auf einem Draht bei Parameterwert zwischen 0 und 1 aus, was Start- und Endpunkte sind.",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength": "Tangente auf Draht bei Länge",
    "tangentOnWireAtLength": "Tangente auf Draht bei Länge",
    "bitbybit.occt.shapes.wire.tangentOnWireAtLength_description": "Wertet Tangentenvektor auf einem Draht bei bestimmter Länge aus.",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength": "Ableitungen auf Draht bei Länge",
    "derivativesOnWireAtLength": "Ableitungen auf Draht bei Länge",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtLength_description": "Berechnet 3 Ableitungsvektoren einer Kurve bei einer gegebenen Länge.",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam": "Ableitungen auf Draht bei Parameter",
    "derivativesOnWireAtParam": "Ableitungen auf Draht bei Parameter",
    "bitbybit.occt.shapes.wire.derivativesOnWireAtParam_description": "Berechnet 3 Ableitungsvektoren einer Kurve bei Parameter zwischen 0 und 1.",
    "bitbybit.occt.shapes.wire.startPointOnWire": "Startpunkt auf Draht",
    "startPointOnWire": "Startpunkt auf Draht",
    "bitbybit.occt.shapes.wire.startPointOnWire_description": "Berechnet den Startpunkt auf dem Draht bei Parameter 0.",
    "bitbybit.occt.shapes.wire.endPointOnWire": "Endpunkt auf Draht",
    "endPointOnWire": "Endpunkt auf Draht",
    "bitbybit.occt.shapes.wire.endPointOnWire_description": "Berechnet den Endpunkt auf dem Draht bei Parameter 1.",
    "bitbybit.occt.shapes.wire.createCircleWire": "Kreis-Draht",
    "createCircleWire": "Kreis-Draht",
    "bitbybit.occt.shapes.wire.createCircleWire_description": "erstellt einen OpenCascade-Kreis-Draht",
    "bitbybit.occt.shapes.wire.createSquareWire": "Quadrat-Draht",
    "createSquareWire": "Quadrat-Draht",
    "bitbybit.occt.shapes.wire.createSquareWire_description": "erstellt einen OpenCascade-Quadrat-Draht",
    "bitbybit.occt.shapes.wire.createStarWire": "Stern-Draht",
    "createStarWire": "Stern-Draht",
    "bitbybit.occt.shapes.wire.createStarWire_description": "erstellt einen OpenCascade-Stern-Draht",
    "numRays": "Anzahl Strahlen",
    "outerRadius": "äußerer Radius",
    "innerRadius": "innerer Radius",
    "offsetOuterEdges": "äußere Kanten versetzen",
    "half": "Hälfte",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire": "Weihnachtsbaum-Draht",
    "createChristmasTreeWire": "Weihnachtsbaum-Draht",
    "bitbybit.occt.shapes.wire.createChristmasTreeWire_description": "erstellt einen Weihnachtsbaum-Draht",
    "innerDist": "innerer Abstand",
    "outerDist": "äußerer Abstand",
    "nrSkirts": "Anzahl Röcke",
    "trunkHeight": "Stammhöhe",
    "trunkWidth": "Stammbreite",
    "bitbybit.occt.shapes.wire.createNGonWire": "N-Eck-Draht",
    "createNGonWire": "N-Eck-Draht",
    "bitbybit.occt.shapes.wire.createNGonWire_description": "Erstellt OpenCascade N-Eck-Draht.",
    "nrCorners": "Anzahl Ecken",
    "bitbybit.occt.shapes.wire.createParallelogramWire": "Parallelogramm-Draht",
    "createParallelogramWire": "Parallelogramm-Draht",
    "bitbybit.occt.shapes.wire.createParallelogramWire_description": "Erstellt n Parallelogramm-Draht.",
    "aroundCenter": "um Zentrum",
    "bitbybit.occt.shapes.wire.createHeartWire": "Herz-Draht",
    "createHeartWire": "Herz-Draht",
    "bitbybit.occt.shapes.wire.createHeartWire_description": "Erstellt einen Herzdraht.",
    "sizeApprox": "ungefähre Größe",
    "bitbybit.occt.shapes.wire.createRectangleWire": "Rechteck-Draht",
    "createRectangleWire": "Rechteck-Draht",
    "bitbybit.occt.shapes.wire.createRectangleWire_description": "erstellt einen OpenCascade-Rechteck-Draht",
    "bitbybit.occt.shapes.wire.createLPolygonWire": "L-Polygon-Draht",
    "createLPolygonWire": "L-Polygon-Draht",
    "bitbybit.occt.shapes.wire.createLPolygonWire_description": "erstellt einen OpenCascade-L-Polygon-Draht",
    "widthFirst": "erste Breite",
    "lengthFirst": "erste Länge",
    "widthSecond": "zweite Breite",
    "lengthSecond": "zweite Länge",
    "align": "ausrichten",
    "directionEnum": "Richtungs-Enum",
    "bitbybit.occt.shapes.wire.createEllipseWire": "Ellipsen-Draht",
    "createEllipseWire": "Ellipsen-Draht",
    "bitbybit.occt.shapes.wire.createEllipseWire_description": "erstellt einen OpenCascade-Ellipsen-Draht",
    "bitbybit.occt.shapes.wire.textWires": "Textkonturen",
    "textWires": "Textkonturen",
    "bitbybit.occt.shapes.wire.textWires_description": "Erstellt OpenCascade-Textkonturen basierend auf der von Dr. A. V. Hershey erstellten Simplex-Schriftart.",
    "xOffset": "x-Versatz",
    "yOffset": "y-Versatz",
    "letterSpacing": "Buchstabenabstand",
    "Base.horizontalAlignEnum": "Base.horizontalAlignEnum",
    "extrudeOffset": "Extrusionsversatz",
    "bitbybit.occt.shapes.wire.getWire": "Draht abrufen",
    "getWire": "Draht abrufen",
    "bitbybit.occt.shapes.wire.getWire_description": "Ruft den Draht durch Bereitstellung eines Index von der Form ab.",
    "bitbybit.occt.shapes.wire.getWires": "Drähte abrufen",
    "getWires": "Drähte abrufen",
    "bitbybit.occt.shapes.wire.getWires_description": "Ruft alle Drähte von der Form ab.",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass": "Schwerpunkt des Drahtes abrufen",
    "getWireCenterOfMass": "Schwerpunkt des Drahtes abrufen",
    "bitbybit.occt.shapes.wire.getWireCenterOfMass_description": "Ruft den Draht-Massenschwerpunkt ab.",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass": "Schwerpunkte der Drähte abrufen",
    "getWiresCentersOfMass": "Schwerpunkte der Drähte abrufen",
    "bitbybit.occt.shapes.wire.getWiresCentersOfMass_description": "Ruft die Drähte-Massenschwerpunkte ab.",
    "bitbybit.occt.shapes.wire.reversedWire": "umgekehrter Draht",
    "reversedWire": "umgekehrter Draht",
    "bitbybit.occt.shapes.wire.reversedWire_description": "Berechnet umgekehrten Draht aus Eingabedraht.",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges": "umgekehrter Draht aus umgekehrten Kanten",
    "reversedWireFromReversedEdges": "umgekehrter Draht aus umgekehrten Kanten",
    "bitbybit.occt.shapes.wire.reversedWireFromReversedEdges_description": "Berechnet umgekehrten Draht durch Umkehren aller Kanten und Kombinieren zu einem neuen Draht.",
    "bitbybit.occt.shapes.wire.isWireClosed": "ist Draht geschlossen",
    "isWireClosed": "ist Draht geschlossen",
    "bitbybit.occt.shapes.wire.isWireClosed_description": "Prüft, ob Draht geschlossen ist.",
    "bitbybit.occt.shapes.wire.getWireLength": "Drahtlänge abrufen",
    "getWireLength": "Drahtlänge abrufen",
    "bitbybit.occt.shapes.wire.getWireLength_description": "Ruft die Drahtlänge ab.",
    "bitbybit.occt.shapes.wire.getWiresLengths": "Drahtlängen abrufen",
    "getWiresLengths": "Drahtlängen abrufen",
    "bitbybit.occt.shapes.wire.getWiresLengths_description": "Ruft die Längen von Drähten ab.",
    "bitbybit.occt.shapes.wire.placeWireOnFace": "Draht auf Fläche platzieren",
    "placeWireOnFace": "Draht auf Fläche platzieren",
    "bitbybit.occt.shapes.wire.placeWireOnFace_description": "Platziert einen Draht auf der Fläche, indem seine 2D-Koordinaten auf den UV-Raum abgebildet werden. Der Draht muss auf der XZ-Bodenebene positioniert sein, damit dies funktioniert.",
    "face": "Fläche",
    "bitbybit.occt.shapes.wire.placeWiresOnFace": "Drähte auf Fläche platzieren",
    "placeWiresOnFace": "Drähte auf Fläche platzieren",
    "bitbybit.occt.shapes.wire.placeWiresOnFace_description": "Platziert mehrere Drähte auf der Fläche, indem ihre 2D-Koordinaten auf den UV-Raum abgebildet werden. Drähte müssen auf der XZ-Bodenebene positioniert sein, damit dies funktioniert.",
    "wires": "Drähte",
    "bitbybit.occt.shapes.wire.closeOpenWire": "offenen Draht schließen",
    "closeOpenWire": "offenen Draht schließen",
    "bitbybit.occt.shapes.wire.closeOpenWire_description": "Schließt den offenen Draht mit zusätzlicher gerader Kante, die Start- und Endpunkte verbindet.",
    "bitbybit.occt.shapes.wire.project": "projizieren",
    "project": "projizieren",
    "bitbybit.occt.shapes.wire.project_description": "Projiziert Draht auf die Form.",
    "bitbybit.occt.shapes.wire.projectWires": "Drähte projizieren",
    "projectWires": "Drähte projizieren",
    "bitbybit.occt.shapes.wire.projectWires_description": "Projiziert mehrere Drähte auf die Form.",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace": "Flächen aus Drähten auf Fläche",
    "createFacesFromWiresOnFace": "Flächen aus Drähten auf Fläche",
    "bitbybit.occt.shapes.face.createFacesFromWiresOnFace_description": "Erstellt Flächen aus Drähten auf Fläche.",
    "inside": "innen",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace": "Fläche aus Draht auf Fläche",
    "createFaceFromWireOnFace": "Fläche aus Draht auf Fläche",
    "bitbybit.occt.shapes.face.createFaceFromWireOnFace_description": "Erstellt eine Fläche aus Draht auf Fläche.",
    "bitbybit.occt.shapes.face.createFaceFromWire": "Fläche aus Draht",
    "createFaceFromWire": "Fläche aus Draht",
    "bitbybit.occt.shapes.face.createFaceFromWire_description": "Erstellt eine Fläche aus Draht.",
    "planar": "planar",
    "bitbybit.occt.shapes.face.createFaceFromWires": "Fläche aus Drähten",
    "createFaceFromWires": "Fläche aus Drähten",
    "bitbybit.occt.shapes.face.createFaceFromWires_description": "Erstellt eine Fläche aus Drähten. Dies kann hohle Flächen erzeugen.",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace": "Fläche aus Drähten auf Fläche",
    "createFaceFromWiresOnFace": "Fläche aus Drähten auf Fläche",
    "bitbybit.occt.shapes.face.createFaceFromWiresOnFace_description": "Erstellt eine Fläche aus Drähten auf der Leitfläche. Dies kann hohle Flächen erzeugen.",
    "bitbybit.occt.shapes.face.createFacesFromWires": "Flächen aus Drähten",
    "createFacesFromWires": "Flächen aus Drähten",
    "bitbybit.occt.shapes.face.createFacesFromWires_description": "erstellt Flächen aus Drähten",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires": "Fläche aus mehreren tangentialen Kreisdrähten",
    "createFaceFromMultipleCircleTanWires": "Fläche aus mehreren tangentialen Kreisdrähten",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWires_description": "erstellt eine Fläche aus mehreren tangentialen Kreisdrähten",
    "circles": "Kreise",
    "combination": "Kombination",
    "combinationCirclesForFaceEnum": "Kombination-Kreise-für-Fläche-Enum",
    "unify": "vereinigen",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections": "Fläche aus mehreren tangentialen Kreis-Drahtsammlungen",
    "createFaceFromMultipleCircleTanWireCollections": "Fläche aus mehreren tangentialen Kreis-Drahtsammlungen",
    "bitbybit.occt.shapes.face.createFaceFromMultipleCircleTanWireCollections_description": "erstellt eine Fläche aus mehreren tangentialen Kreis-Drahtsammlungen",
    "listsOfCircles": "Listen von Kreisen",
    "T[][]": "T-Array-Array",
    "bitbybit.occt.shapes.face.faceFromSurface": "Fläche aus Fläche",
    "faceFromSurface": "Fläche aus Fläche",
    "bitbybit.occt.shapes.face.faceFromSurface_description": "Erstellt eine Fläche aus der Oberfläche.",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire": "Fläche aus Fläche und Draht",
    "faceFromSurfaceAndWire": "Fläche aus Fläche und Draht",
    "bitbybit.occt.shapes.face.faceFromSurfaceAndWire_description": "Erstellt eine Fläche aus der Oberfläche und einem Draht.",
    "bitbybit.occt.shapes.face.createPolygonFace": "Polygon-Fläche",
    "createPolygonFace": "Polygon-Fläche",
    "bitbybit.occt.shapes.face.createPolygonFace_description": "erstellt eine OpenCascade-Polygon-Fläche",
    "bitbybit.occt.shapes.face.createCircleFace": "Kreis-Fläche",
    "createCircleFace": "Kreis-Fläche",
    "bitbybit.occt.shapes.face.createCircleFace_description": "erstellt eine OpenCascade-Kreis-Fläche",
    "bitbybit.occt.shapes.face.createEllipseFace": "Ellipsen-Fläche",
    "createEllipseFace": "Ellipsen-Fläche",
    "bitbybit.occt.shapes.face.createEllipseFace_description": "erstellt eine OpenCascade-Ellipsen-Fläche",
    "bitbybit.occt.shapes.face.createSquareFace": "Quadrat-Fläche",
    "createSquareFace": "Quadrat-Fläche",
    "bitbybit.occt.shapes.face.createSquareFace_description": "erstellt eine OpenCascade-Quadrat-Fläche",
    "bitbybit.occt.shapes.face.createRectangleFace": "Rechteck-Fläche",
    "createRectangleFace": "Rechteck-Fläche",
    "bitbybit.occt.shapes.face.createRectangleFace_description": "erstellt eine OpenCascade-Rechteck-Fläche",
    "bitbybit.occt.shapes.face.getFace": "Fläche abrufen",
    "getFace": "Fläche abrufen",
    "bitbybit.occt.shapes.face.getFace_description": "Ruft die Fläche durch Bereitstellung eines Index von der Form ab.",
    "bitbybit.occt.shapes.face.getFaces": "Flächen abrufen",
    "getFaces": "Flächen abrufen",
    "bitbybit.occt.shapes.face.getFaces_description": "Ruft die Flächen der Form in einer Liste ab.",
    "bitbybit.occt.shapes.face.reversedFace": "umgekehrte Fläche",
    "reversedFace": "umgekehrte Fläche",
    "bitbybit.occt.shapes.face.reversedFace_description": "Berechnet umgekehrte Fläche aus Eingabefläche.",
    "bitbybit.occt.shapes.face.subdivideToPoints": "in Punkte unterteilen",
    "subdivideToPoints": "in Punkte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToPoints_description": "Unterteilt eine Fläche in Punktgitter.",
    "nrDivisionsU": "Anzahl Teilungen U",
    "nrDivisionsV": "Anzahl Teilungen V",
    "shiftHalfStepU": "halben Schritt U verschieben",
    "removeStartEdgeU": "Startkante U entfernen",
    "removeEndEdgeU": "Endkante U entfernen",
    "shiftHalfStepV": "halben Schritt V verschieben",
    "removeStartEdgeV": "Startkante V entfernen",
    "removeEndEdgeV": "Endkante V entfernen",
    "bitbybit.occt.shapes.face.subdivideToWires": "in Drähte unterteilen",
    "subdivideToWires": "in Drähte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToWires_description": "Unterteilt eine Fläche in Drähte.",
    "nrDivisions": "Anzahl Teilungen",
    "isU": "ist U",
    "shiftHalfStep": "halben Schritt verschieben",
    "removeStart": "Start entfernen",
    "removeEnd": "Ende entfernen",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires": "in Rechteck-Drähte unterteilen",
    "subdivideToRectangleWires": "in Rechteck-Drähte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToRectangleWires_description": "Unterteilt eine Fläche in Rechteckdrähte.",
    "patterns": "Muster",
    "nrRectanglesU": "Anzahl Rechtecke U",
    "nrRectanglesV": "Anzahl Rechtecke V",
    "scalePatternU": "Muster U skalieren",
    "scalePatternV": "Muster V skalieren",
    "filletPattern": "Rundungsmuster",
    "inclusionPattern": "Einschlussmuster",
    "offsetFromBorderU": "Versatz von Rand U",
    "offsetFromBorderV": "Versatz von Rand V",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles": "in Rechtecklöcher unterteilen",
    "subdivideToRectangleHoles": "in Rechtecklöcher unterteilen",
    "bitbybit.occt.shapes.face.subdivideToRectangleHoles_description": "Unterteilt eine Fläche in Rechteckdrähte.",
    "holesToFaces": "Löcher zu Flächen",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled": "kontrolliert in Punkte unterteilen",
    "subdivideToPointsControlled": "kontrolliert in Punkte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToPointsControlled_description": "Unterteilt eine Fläche in Punktgitter mit Verschiebungen und Entfernungen in n-ten UV-Reihen oder Spalten.",
    "shiftHalfStepNthU": "halben Schritt N-ter U verschieben",
    "shiftHalfStepUOffsetN": "halben Schritt U Versatz N verschieben",
    "removeStartEdgeNthU": "Startkante N-ter U entfernen",
    "removeStartEdgeUOffsetN": "Startkante U Versatz N entfernen",
    "removeEndEdgeNthU": "Endkante N-ter U entfernen",
    "removeEndEdgeUOffsetN": "Endkante U Versatz N entfernen",
    "shiftHalfStepNthV": "halben Schritt N-ter V verschieben",
    "shiftHalfStepVOffsetN": "halben Schritt V Versatz N verschieben",
    "removeStartEdgeNthV": "Startkante N-ter V entfernen",
    "removeStartEdgeVOffsetN": "Startkante V Versatz N entfernen",
    "removeEndEdgeNthV": "Endkante N-ter V entfernen",
    "removeEndEdgeVOffsetN": "Endkante V Versatz N entfernen",
    "bitbybit.occt.shapes.face.subdivideToNormals": "in Normalen unterteilen",
    "subdivideToNormals": "in Normalen unterteilen",
    "bitbybit.occt.shapes.face.subdivideToNormals_description": "Unterteilt eine Fläche in Normalengitter.",
    "bitbybit.occt.shapes.face.subdivideToUV": "in UV unterteilen",
    "subdivideToUV": "in UV unterteilen",
    "bitbybit.occt.shapes.face.subdivideToUV_description": "Unterteilt eine Fläche in UV-Gitter.",
    "bitbybit.occt.shapes.face.pointOnUV": "Punkt auf UV",
    "pointOnUV": "Punkt auf UV",
    "bitbybit.occt.shapes.face.pointOnUV_description": "Ruft Punkt auf UV ab, wo U und V zwischen 0 und 1 beschrieben sind. Diese werden auf reale Grenzen abgebildet.",
    "paramU": "Parameter U",
    "paramV": "Parameter V",
    "bitbybit.occt.shapes.face.normalOnUV": "Normale auf UV",
    "normalOnUV": "Normale auf UV",
    "bitbybit.occt.shapes.face.normalOnUV_description": "Ruft Normale auf UV ab, wo U und V zwischen 0 und 1 beschrieben sind. Diese werden auf reale Grenzen abgebildet.",
    "bitbybit.occt.shapes.face.pointsOnUVs": "Punkte auf UVs",
    "pointsOnUVs": "Punkte auf UVs",
    "bitbybit.occt.shapes.face.pointsOnUVs_description": "Ruft Punkte auf UVs ab, wo U und V zwischen 0 und 1 in zweidimensionalen Arrays beschrieben sind. Diese werden auf reale Grenzen abgebildet.",
    "paramsUV": "Parameter UV",
    "[number, number][]": "Zahlenpaar-Array",
    "bitbybit.occt.shapes.face.normalsOnUVs": "Normalen auf UVs",
    "normalsOnUVs": "Normalen auf UVs",
    "bitbybit.occt.shapes.face.normalsOnUVs_description": "Ruft Normalen auf UVs ab, wo U und V zwischen 0 und 1 in zweidimensionalen Arrays beschrieben sind. Diese werden auf reale Grenzen abgebildet.",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam": "in Punkte bei Parameter unterteilen",
    "subdivideToPointsOnParam": "in Punkte bei Parameter unterteilen",
    "bitbybit.occt.shapes.face.subdivideToPointsOnParam_description": "Unterteilt eine Fläche in Punkte entlang einer Linie auf Parameter.",
    "nrPoints": "Anzahl Punkte",
    "bitbybit.occt.shapes.face.wireAlongParam": "Draht entlang Parameter",
    "wireAlongParam": "Draht entlang Parameter",
    "bitbybit.occt.shapes.face.wireAlongParam_description": "Ruft den Draht entlang des Parameters auf der Fläche ab.",
    "bitbybit.occt.shapes.face.wiresAlongParams": "Drähte entlang Parameter",
    "wiresAlongParams": "Drähte entlang Parameter",
    "bitbybit.occt.shapes.face.wiresAlongParams_description": "Ruft die Drähte entlang der Parameter auf der Fläche ab.",
    "params": "Parameter",
    "bitbybit.occt.shapes.face.getUMinBound": "U-Minimum-Grenze abrufen",
    "getUMinBound": "U-Minimum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getUMinBound_description": "Ruft die U-Minimalgrenze der Fläche ab.",
    "bitbybit.occt.shapes.face.getUMaxBound": "U-Maximum-Grenze abrufen",
    "getUMaxBound": "U-Maximum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getUMaxBound_description": "Ruft die U-Maximalgrenze der Fläche ab.",
    "bitbybit.occt.shapes.face.getVMinBound": "V-Minimum-Grenze abrufen",
    "getVMinBound": "V-Minimum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getVMinBound_description": "Ruft die V-Minimalgrenze der Fläche ab.",
    "bitbybit.occt.shapes.face.getVMaxBound": "V-Maximum-Grenze abrufen",
    "getVMaxBound": "V-Maximum-Grenze abrufen",
    "bitbybit.occt.shapes.face.getVMaxBound_description": "Ruft die V-Maximalgrenze der Fläche ab.",
    "bitbybit.occt.shapes.face.getFaceArea": "Flächeninhalt abrufen",
    "getFaceArea": "Flächeninhalt abrufen",
    "bitbybit.occt.shapes.face.getFaceArea_description": "Ruft die Fläche der Fläche ab.",
    "bitbybit.occt.shapes.face.getFacesAreas": "Flächeninhalte abrufen",
    "getFacesAreas": "Flächeninhalte abrufen",
    "bitbybit.occt.shapes.face.getFacesAreas_description": "Ruft die Flächeninhalte der Flächen ab.",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass": "Schwerpunkt der Fläche abrufen",
    "getFaceCenterOfMass": "Schwerpunkt der Fläche abrufen",
    "bitbybit.occt.shapes.face.getFaceCenterOfMass_description": "Ruft den Flächen-Massenschwerpunkt ab.",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass": "Schwerpunkte der Flächen abrufen",
    "getFacesCentersOfMass": "Schwerpunkte der Flächen abrufen",
    "bitbybit.occt.shapes.face.getFacesCentersOfMass_description": "Ruft die Massenschwerpunkte für Flächen ab.",
    "bitbybit.occt.shapes.face.filterFacePoints": "Flächenpunkte filtern",
    "filterFacePoints": "Flächenpunkte filtern",
    "bitbybit.occt.shapes.face.filterFacePoints_description": "filtert Punkte auf einer Fläche",
    "filter": "filtern",
    "useBndBox": "Begrenzungsbox verwenden",
    "gapTolerance": "Spalttoleranz",
    "keepIn": "behalten innen",
    "keepOn": "behalten auf",
    "keepOut": "behalten außen",
    "keepUnknown": "behalten unbekannt",
    "bitbybit.occt.shapes.face.filterFacesPoints": "Punkte von Flächen filtern",
    "filterFacesPoints": "Punkte von Flächen filtern",
    "bitbybit.occt.shapes.face.filterFacesPoints_description": "filtert Punkte auf Flächen",
    "flatPointsArray": "flaches Punkte-Array",
    "bitbybit.occt.shapes.shell.sewFaces": "Flächen zusammennähen",
    "shell": "Schale",
    "sewFaces": "Flächen zusammennähen",
    "bitbybit.occt.shapes.shell.sewFaces_description": "Erstellt eine Hülle (Shell) aus Flächen.",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea": "Oberflächeninhalt der Schale abrufen",
    "getShellSurfaceArea": "Oberflächeninhalt der Schale abrufen",
    "bitbybit.occt.shapes.shell.getShellSurfaceArea_description": "Ruft Hüllenoberfläche ab.",
    "bitbybit.occt.shapes.solid.fromClosedShell": "aus geschlossener Schale",
    "solid": "Volumenkörper",
    "fromClosedShell": "aus geschlossener Schale",
    "bitbybit.occt.shapes.solid.fromClosedShell_description": "Erstellt Volumenkörper aus Hülle, die geschlossen sein muss.",
    "bitbybit.occt.shapes.solid.createBox": "Quader",
    "bitbybit.occt.shapes.solid.createBox_description": "erstellt einen OpenCascade-Quader",
    "originOnCenter": "Ursprung im Zentrum",
    "bitbybit.occt.shapes.solid.createCube": "Würfel",
    "bitbybit.occt.shapes.solid.createCube_description": "erstellt einen OpenCascade-Würfel",
    "bitbybit.occt.shapes.solid.createBoxFromCorner": "Quader aus Ecke",
    "createBoxFromCorner": "Quader aus Ecke",
    "bitbybit.occt.shapes.solid.createBoxFromCorner_description": "erstellt einen OpenCascade-Quader aus einer Ecke",
    "corner": "Ecke",
    "bitbybit.occt.shapes.solid.createCylinder": "Zylinder",
    "bitbybit.occt.shapes.solid.createCylinder_description": "erstellt einen OpenCascade-Zylinder",
    "bitbybit.occt.shapes.solid.createCylindersOnLines": "Zylinder auf Linien",
    "createCylindersOnLines": "Zylinder auf Linien",
    "bitbybit.occt.shapes.solid.createCylindersOnLines_description": "Erstellt OpenCascade-Zylinder auf einfachen BitByBit-Linien, dargestellt durch zwei Punkte.",
    "Base.Line3[]": "Basis-Linien-3-Array",
    "bitbybit.occt.shapes.solid.createSphere": "Kugel",
    "bitbybit.occt.shapes.solid.createSphere_description": "erstellt eine OpenCascade-Kugel",
    "bitbybit.occt.shapes.solid.createCone": "Kegel",
    "createCone": "Kegel",
    "bitbybit.occt.shapes.solid.createCone_description": "erstellt einen OpenCascade-Kegel",
    "radius1": "Radius 1",
    "radius2": "Radius 2",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea": "Oberflächeninhalt des Volumenkörpers abrufen",
    "getSolidSurfaceArea": "Oberflächeninhalt des Volumenkörpers abrufen",
    "bitbybit.occt.shapes.solid.getSolidSurfaceArea_description": "Ruft Volumenkörperoberfläche ab.",
    "bitbybit.occt.shapes.solid.getSolidVolume": "Volumen des Volumenkörpers abrufen",
    "getSolidVolume": "Volumen des Volumenkörpers abrufen",
    "bitbybit.occt.shapes.solid.getSolidVolume_description": "Ruft Volumenkörpervolumen ab.",
    "bitbybit.occt.shapes.solid.getSolidsVolumes": "Volumen der Volumenkörper abrufen",
    "getSolidsVolumes": "Volumen der Volumenkörper abrufen",
    "bitbybit.occt.shapes.solid.getSolidsVolumes_description": "Ruft Volumina der Volumenkörper ab.",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass": "Schwerpunkt des Volumenkörpers abrufen",
    "getSolidCenterOfMass": "Schwerpunkt des Volumenkörpers abrufen",
    "bitbybit.occt.shapes.solid.getSolidCenterOfMass_description": "Ruft Volumenkörper-Massenschwerpunkt ab.",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass": "Schwerpunkte der Volumenkörper abrufen",
    "getSolidsCentersOfMass": "Schwerpunkte der Volumenkörper abrufen",
    "bitbybit.occt.shapes.solid.getSolidsCentersOfMass_description": "Ruft Massenschwerpunkte von Volumenkörpern ab.",
    "bitbybit.occt.shapes.solid.getSolids": "Volumenkörper abrufen",
    "getSolids": "Volumenkörper abrufen",
    "bitbybit.occt.shapes.solid.getSolids_description": "Ruft die Volumenkörper der Form in einer Liste ab.",
    "bitbybit.occt.shapes.solid.filterSolidPoints": "Punkte des Volumenkörpers filtern",
    "filterSolidPoints": "Punkte des Volumenkörpers filtern",
    "bitbybit.occt.shapes.solid.filterSolidPoints_description": "Filtert Sammlung von Punkten basierend auf Beziehung zum Volumenkörper. Sie können wählen, ob Punkte innerhalb, auf oder außerhalb ausgegeben werden sollen.",
    "bitbybit.occt.shapes.compound.makeCompound": "Verbindung erstellen",
    "compound": "Verbindung",
    "makeCompound": "Verbindung erstellen",
    "bitbybit.occt.shapes.compound.makeCompound_description": "Erstellt die Verbundform (Compound), die jede Art von Formen enthalten kann.",
    "bitbybit.occt.shapes.compound.getShapesOfCompound": "Formen der Verbindung abrufen",
    "getShapesOfCompound": "Formen der Verbindung abrufen",
    "bitbybit.occt.shapes.compound.getShapesOfCompound_description": "Ruft die Formen ab, aus denen der Verbund besteht.",
    "bitbybit.occt.shapes.shape.purgeInternalEdges": "interne Kanten bereinigen",
    "purgeInternalEdges": "interne Kanten bereinigen",
    "bitbybit.occt.shapes.shape.purgeInternalEdges_description": "Entfernt interne Kanten, die mit keiner Fläche in der Form verbunden sind.",
    "bitbybit.occt.shapes.shape.unifySameDomain": "gleiche Domäne vereinigen",
    "unifySameDomain": "gleiche Domäne vereinigen",
    "bitbybit.occt.shapes.shape.unifySameDomain_description": "Vereinheitlicht Flächen, Kanten in derselben Domäne und hat die Möglichkeit, BSplines zu verketten.",
    "unifyEdges": "Kanten vereinigen",
    "unifyFaces": "Flächen vereinigen",
    "concatBSplines": "BSplines zusammenführen",
    "bitbybit.occt.shapes.shape.isClosed": "ist geschlossen",
    "bitbybit.occt.shapes.shape.isClosed_description": "Prüft, ob die Form geschlossen ist.",
    "analysis": "Analyse",
    "bitbybit.occt.shapes.shape.isConvex": "ist konvex",
    "isConvex": "ist konvex",
    "bitbybit.occt.shapes.shape.isConvex_description": "Prüft, ob die Form konvex ist.",
    "bitbybit.occt.shapes.shape.isChecked": "ist geprüft",
    "bitbybit.occt.shapes.shape.isChecked_description": "Prüft, ob die Form geprüft ist.",
    "bitbybit.occt.shapes.shape.isFree": "ist frei",
    "isFree": "ist frei",
    "bitbybit.occt.shapes.shape.isFree_description": "Prüft, ob die Form frei ist.",
    "bitbybit.occt.shapes.shape.isInfinite": "ist unendlich",
    "isInfinite": "ist unendlich",
    "bitbybit.occt.shapes.shape.isInfinite_description": "Prüft, ob die Form unendlich ist.",
    "bitbybit.occt.shapes.shape.isModified": "ist modifiziert",
    "isModified": "ist modifiziert",
    "bitbybit.occt.shapes.shape.isModified_description": "Prüft, ob die Form modifiziert ist.",
    "bitbybit.occt.shapes.shape.isLocked": "ist gesperrt",
    "isLocked": "ist gesperrt",
    "bitbybit.occt.shapes.shape.isLocked_description": "Prüft, ob die Form gesperrt ist.",
    "bitbybit.occt.shapes.shape.isNull": "ist null",
    "isNull": "ist null",
    "bitbybit.occt.shapes.shape.isNull_description": "Prüft, ob die Form null ist.",
    "bitbybit.occt.shapes.shape.isEqual": "ist gleich",
    "isEqual": "ist gleich",
    "bitbybit.occt.shapes.shape.isEqual_description": "Prüft, ob die Form gleich einer anderen Form ist.",
    "otherShape": "andere Form",
    "bitbybit.occt.shapes.shape.isNotEqual": "ist nicht gleich",
    "isNotEqual": "ist nicht gleich",
    "bitbybit.occt.shapes.shape.isNotEqual_description": "Prüft, ob die Form ungleich einer anderen Form ist.",
    "bitbybit.occt.shapes.shape.isPartner": "ist Partner",
    "isPartner": "ist Partner",
    "bitbybit.occt.shapes.shape.isPartner_description": "Prüft, ob die Form Partner einer anderen Form ist.",
    "bitbybit.occt.shapes.shape.isSame": "ist identisch",
    "isSame": "ist identisch",
    "bitbybit.occt.shapes.shape.isSame_description": "Prüft, ob die Form dieselbe ist wie die andere Form.",
    "bitbybit.occt.shapes.shape.getOrientation": "Ausrichtung abrufen",
    "getOrientation": "Ausrichtung abrufen",
    "bitbybit.occt.shapes.shape.getOrientation_description": "Ruft die Formausrichtung ab.",
    "bitbybit.occt.shapes.shape.getShapeType": "Formtyp abrufen",
    "getShapeType": "Formtyp abrufen",
    "bitbybit.occt.shapes.shape.getShapeType_description": "Ruft den Formtyp ab.",
    "bitbybit.occt.geom.curves.geom2dEllipse": "2D-Ellipse Geometrie",
    "geom": "Geometrie",
    "curves": "Kurven",
    "geom2dEllipse": "2D-Ellipse Geometrie",
    "bitbybit.occt.geom.curves.geom2dEllipse_description": "Erstellt eine 2D-Ellipse. Stellen Sie sicher, dass Sie diese Geometrie nur für konstruktive Modellierungszwecke verwenden, nicht aber zur Darstellung. Sie müssen diese Kurven in Kanten transformieren, um sie zu zeichnen.",
    "Base.Point2": "Basis-Punkt 2",
    "Base.Vector2": "Basis-Vektor 2",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve": "2D-beschnittene Kurve",
    "geom2dTrimmedCurve": "2D-beschnittene Kurve",
    "bitbybit.occt.geom.curves.geom2dTrimmedCurve_description": "Erstellt eine getrimmte Kurve aus der Basiskurve, begrenzt zwischen U1 und U2. Diese Kurve kann nicht gezeichnet werden.",
    "u1": "U1",
    "u2": "U2",
    "adjustPeriodic": "periodisch anpassen",
    "bitbybit.occt.geom.curves.geom2dSegment": "2D-Kurvensegment",
    "geom2dSegment": "2D-Kurvensegment",
    "bitbybit.occt.geom.curves.geom2dSegment_description": "Erstellt ein getrimmtes 2D-Kurvensegment zwischen zwei 2D-Punkten. Diese Kurve kann nicht gezeichnet werden.",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam": "2D-Punkt von 2D-Kurve bei Parameter abrufen",
    "get2dPointFrom2dCurveOnParam": "2D-Punkt von 2D-Kurve bei Parameter abrufen",
    "bitbybit.occt.geom.curves.get2dPointFrom2dCurveOnParam_description": "Ruft 2D-Punkt, dargestellt durch [Zahl, Zahl], auf einer Kurve bei Parameter ab.",
    "bitbybit.occt.geom.curves.geomCircleCurve": "Kreis-Kurve Geometrie",
    "geomCircleCurve": "Kreis-Kurve Geometrie",
    "bitbybit.occt.geom.curves.geomCircleCurve_description": "Erstellt eine Geom-Kreiskurve.",
    "bitbybit.occt.geom.curves.geomEllipseCurve": "Ellipse-Kurve Geometrie",
    "geomEllipseCurve": "Ellipse-Kurve Geometrie",
    "bitbybit.occt.geom.curves.geomEllipseCurve_description": "Erstellt eine Geom-Ellipsenkurve.",
    "bitbybit.occt.geom.surfaces.cylindricalSurface": "zylindrische Fläche",
    "surfaces": "Flächen",
    "cylindricalSurface": "zylindrische Fläche",
    "bitbybit.occt.geom.surfaces.cylindricalSurface_description": "Erstellt eine unendliche zylindrische Oberfläche, die nicht gezeichnet werden kann. Stellen Sie sicher, dass Sie diese Geometrie nur für konstruktive Modellierungszwecke verwenden, nicht aber zur Darstellung.",
    "bitbybit.occt.geom.surfaces.surfaceFromFace": "Fläche aus Fläche",
    "surfaceFromFace": "Fläche aus Fläche",
    "bitbybit.occt.geom.surfaces.surfaceFromFace_description": "Erstellt eine Oberfläche aus der Fläche.",
    "bitbybit.occt.fillets.filletEdges": "Kanten abrunden",
    "fillets": "Rundungen",
    "filletEdges": "Kanten abrunden",
    "bitbybit.occt.fillets.filletEdges_description": "rundet OpenCascade-Formen ab",
    "3d fillets": "3D-Rundungen",
    "radiusList": "Radius-Liste",
    "indexes": "Indizes",
    "bitbybit.occt.fillets.filletEdgesList": "Kanten-Liste abrunden",
    "filletEdgesList": "Kanten-Liste abrunden",
    "bitbybit.occt.fillets.filletEdgesList_description": "Verrundet Kantenliste mit unterschiedlichem Radius an jeder Kante.",
    "edges": "Kanten",
    "bitbybit.occt.fillets.filletEdgesListOneRadius": "Kanten-Liste mit einem Radius abrunden",
    "filletEdgesListOneRadius": "Kanten-Liste mit einem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgesListOneRadius_description": "Verrundet Kantenliste mit dem einzigen Radius an allen Kanten.",
    "bitbybit.occt.fillets.filletEdgeVariableRadius": "Kante mit variablem Radius abrunden",
    "filletEdgeVariableRadius": "Kante mit variablem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgeVariableRadius_description": "Verrundet eine einzelne Kante mit variabler Radiusliste an gegebenen U-Parametern. Sie müssen eine Liste von Parametern bereitstellen, um zu identifizieren, an welchem U-Parameter der Radius angewendet werden soll.",
    "paramsU": "Parameter U",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius": "Kanten mit gleichem variablem Radius abrunden",
    "filletEdgesSameVariableRadius": "Kanten mit gleichem variablem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgesSameVariableRadius_description": "Verrundet mehrere bereitgestellte Kanten mit denselben variablen Radien an U-Parametern für jede Kante.",
    "bitbybit.occt.fillets.filletEdgesVariableRadius": "Kanten mit variablem Radius abrunden",
    "filletEdgesVariableRadius": "Kanten mit variablem Radius abrunden",
    "bitbybit.occt.fillets.filletEdgesVariableRadius_description": "Verrundet mehrere bereitgestellte Kanten mit variablen Radiuslisten an gegebenen Parameterlisten. Sie müssen eine Liste von Parametern bereitstellen, um zu identifizieren, an welchem U-Parameter der Radius angewendet werden soll.",
    "radiusLists": "Radien-Listen",
    "paramsULists": "Parameter-U-Listen",
    "bitbybit.occt.fillets.fillet3DWire": "3D-Draht abrunden",
    "fillet3DWire": "3D-Draht abrunden",
    "bitbybit.occt.fillets.fillet3DWire_description": "Verrundet OpenCascade 3D-Draht, dieser Algorithmus nimmt eine Leitrichtung für zu bildende Verrundungen. Er respektiert keine Tangentenrichtungen an jeder verrundeten Ecke. Dieser Algorithmus basiert auf dem Extrudieren von Draht entlang der gegebenen Richtung, um eine Hülle zu bilden, dann Verrunden der Hülle und schließlich Extrahieren des verrundeten Drahtes aus der Hülle selbst. Stellen Sie sicher, dass Sie eine Richtung angeben, die nicht parallel zum Draht ist und die eine ausreichend hohe Extrusion für den Erfolg der Verrundung bildet.",
    "bitbybit.occt.fillets.fillet3DWires": "3D-Drähte abrunden",
    "fillet3DWires": "3D-Drähte abrunden",
    "bitbybit.occt.fillets.fillet3DWires_description": "Verrundet OpenCascade 3D-Drähte, dieser Algorithmus nimmt eine Leitrichtung für zu bildende Verrundungen. Er respektiert keine Tangentenrichtungen an jeder verrundeten Ecke. Dieser Algorithmus basiert auf dem Extrudieren von Drähten entlang der gegebenen Richtung, um eine Hülle zu bilden, dann Verrunden der Hülle und schließlich Extrahieren des verrundeten Drahtes aus der Hülle selbst. Stellen Sie sicher, dass Sie eine Richtung angeben, die nicht parallel zum Draht ist und die eine ausreichend hohe Extrusion für den Erfolg der Verrundung bildet.",
    "bitbybit.occt.fillets.chamferEdges": "Kanten anfassen",
    "chamferEdges": "Kanten anfassen",
    "bitbybit.occt.fillets.chamferEdges_description": "Faset OpenCascade-Formkanten.",
    "3d chamfers": "3D-Fasen",
    "distanceList": "Abstands-Liste",
    "bitbybit.occt.fillets.chamferEdgesList": "Kanten-Liste anfassen",
    "chamferEdgesList": "Kanten-Liste anfassen",
    "bitbybit.occt.fillets.chamferEdgesList_description": "Faset Kantenliste mit unterschiedlichem Abstand an jeder Kante.",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances": "Kante mit zwei Abständen anfassen",
    "chamferEdgeTwoDistances": "Kante mit zwei Abständen anfassen",
    "bitbybit.occt.fillets.chamferEdgeTwoDistances_description": "Faset Kante um zwei Abstände. Fläche gibt den ersten anzuwendenden Abstand an.",
    "F": "F",
    "distance1": "Abstand 1",
    "distance2": "Abstand 2",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances": "Kanten mit zwei Abständen anfassen",
    "chamferEdgesTwoDistances": "Kanten mit zwei Abständen anfassen",
    "bitbybit.occt.fillets.chamferEdgesTwoDistances_description": "Faset Kanten um zwei Abstände. Fläche gibt den ersten anzuwendenden Abstand an.",
    "faces": "Flächen",
    "F[]": "F-Array",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists": "Kanten mit zwei Abstands-Listen anfassen",
    "chamferEdgesTwoDistancesLists": "Kanten mit zwei Abstands-Listen anfassen",
    "bitbybit.occt.fillets.chamferEdgesTwoDistancesLists_description": "Faset Kanten um zwei Abstände. Fläche gibt den ersten anzuwendenden Abstand an.",
    "distances1": "Abstände 1",
    "distances2": "Abstände 2",
    "bitbybit.occt.fillets.chamferEdgeDistAngle": "Kante mit Abstand und Winkel anfassen",
    "chamferEdgeDistAngle": "Kante mit Abstand und Winkel anfassen",
    "bitbybit.occt.fillets.chamferEdgeDistAngle_description": "Faset Kante um einen gegebenen Abstand und Winkel von der Fläche.",
    "bitbybit.occt.fillets.chamferEdgesDistAngle": "Kanten mit Abstand und Winkel anfassen",
    "chamferEdgesDistAngle": "Kanten mit Abstand und Winkel anfassen",
    "bitbybit.occt.fillets.chamferEdgesDistAngle_description": "Faset mehrere Kanten um einen gegebenen Abstand und Winkel von den Flächen.",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles": "Kanten mit Abständen und Winkeln anfassen",
    "chamferEdgesDistsAngles": "Kanten mit Abständen und Winkeln anfassen",
    "bitbybit.occt.fillets.chamferEdgesDistsAngles_description": "Faset Kanten um gegebene Abstände und Winkel von den Flächen.",
    "distances": "Abstände",
    "bitbybit.occt.fillets.fillet2d": "2D abrunden",
    "fillet2d": "2D abrunden",
    "bitbybit.occt.fillets.fillet2d_description": "rundet einen 2D-Draht oder eine Fläche ab",
    "2d fillets": "2D-Rundungen",
    "bitbybit.occt.fillets.fillet2dShapes": "2D-Formen abrunden",
    "fillet2dShapes": "2D-Formen abrunden",
    "bitbybit.occt.fillets.fillet2dShapes_description": "rundet 2D-Drähte oder Flächen ab",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire": "zwei Kanten in einer Ebene zu einem Draht abrunden",
    "filletTwoEdgesInPlaneIntoAWire": "zwei Kanten in einer Ebene zu einem Draht abrunden",
    "bitbybit.occt.fillets.filletTwoEdgesInPlaneIntoAWire_description": "Verrundet zwei planare Kanten zu einem Draht durch Bereitstellung eines Radius, einer Ebene, von Kanten und möglichem Lösungsindex, falls mehr als ein Ergebnis existiert.",
    "edge1": "Kante 1",
    "edge2": "Kante 2",
    "planeOrigin": "Ebenenursprung",
    "planeDirection": "Ebenenrichtung",
    "solution": "Lösung",
    "bitbybit.occt.transforms.transform": "transformieren",
    "bitbybit.occt.transforms.transform_description": "Transformiert die Form.",
    "on single shape": "auf einzelne Form",
    "rotationAxis": "Rotationsachse",
    "rotationAngle": "Rotationswinkel",
    "scaleFactor": "Skalierungsfaktor",
    "bitbybit.occt.transforms.rotate": "drehen",
    "bitbybit.occt.transforms.rotate_description": "Rotiert die Form.",
    "bitbybit.occt.transforms.rotateAroundCenter": "um Zentrum drehen",
    "rotateAroundCenter": "um Zentrum drehen",
    "bitbybit.occt.transforms.rotateAroundCenter_description": "Rotiert die Form um das bereitgestellte Zentrum.",
    "bitbybit.occt.transforms.align": "ausrichten",
    "bitbybit.occt.transforms.align_description": "Richtet die Form aus.",
    "fromOrigin": "von Ursprung",
    "fromDirection": "von Richtung",
    "toOrigin": "zu Ursprung",
    "toDirection": "zu Richtung",
    "bitbybit.occt.transforms.alignAndTranslate": "ausrichten und verschieben",
    "alignAndTranslate": "ausrichten und verschieben",
    "bitbybit.occt.transforms.alignAndTranslate_description": "Richtet die Form aus und verschiebt sie.",
    "bitbybit.occt.transforms.translate": "verschieben",
    "bitbybit.occt.transforms.translate_description": "Verschiebt die Form.",
    "bitbybit.occt.transforms.scale": "skalieren",
    "bitbybit.occt.transforms.scale_description": "Skaliert die Form.",
    "bitbybit.occt.transforms.scale3d": "3D skalieren",
    "scale3d": "3D skalieren",
    "bitbybit.occt.transforms.scale3d_description": "Skaliert die Form in 3D.",
    "bitbybit.occt.transforms.mirror": "spiegeln",
    "mirror": "spiegeln",
    "bitbybit.occt.transforms.mirror_description": "Spiegelt die Form.",
    "bitbybit.occt.transforms.mirrorAlongNormal": "entlang Normalen spiegeln",
    "mirrorAlongNormal": "entlang Normalen spiegeln",
    "bitbybit.occt.transforms.mirrorAlongNormal_description": "Spiegelt die Form entlang der Normalen und des Ursprungs.",
    "normal": "Normale",
    "bitbybit.occt.transforms.transformShapes": "Formen transformieren",
    "transformShapes": "Formen transformieren",
    "bitbybit.occt.transforms.transformShapes_description": "Transformiert das Array von Formen mit Transformationen.",
    "on shapes": "auf Formen",
    "rotationAxes": "Rotationsachsen",
    "rotationAngles": "Rotationswinkel",
    "scaleFactors": "Skalierungsfaktoren",
    "bitbybit.occt.transforms.rotateShapes": "Formen drehen",
    "rotateShapes": "Formen drehen",
    "bitbybit.occt.transforms.rotateShapes_description": "Rotiert die Formen mit Rotationen.",
    "axes": "Achsen",
    "bitbybit.occt.transforms.rotateAroundCenterShapes": "Formen um Zentrum drehen",
    "rotateAroundCenterShapes": "Formen um Zentrum drehen",
    "bitbybit.occt.transforms.rotateAroundCenterShapes_description": "Rotiert die Formen um das Zentrum und eine Achse.",
    "centers": "Zentren",
    "bitbybit.occt.transforms.alignShapes": "Formen ausrichten",
    "alignShapes": "Formen ausrichten",
    "bitbybit.occt.transforms.alignShapes_description": "Richtet die Formen mit Ausrichtungen aus.",
    "fromOrigins": "von Ursprüngen",
    "fromDirections": "von Richtungen",
    "toOrigins": "zu Ursprüngen",
    "toDirections": "zu Richtungen",
    "bitbybit.occt.transforms.alignAndTranslateShapes": "Formen ausrichten und verschieben",
    "alignAndTranslateShapes": "Formen ausrichten und verschieben",
    "bitbybit.occt.transforms.alignAndTranslateShapes_description": "Richtet die Formen aus und verschiebt sie.",
    "directions": "Richtungen",
    "bitbybit.occt.transforms.translateShapes": "Formen verschieben",
    "translateShapes": "Formen verschieben",
    "bitbybit.occt.transforms.translateShapes_description": "Verschiebt die Formen mit Verschiebungen.",
    "bitbybit.occt.transforms.scaleShapes": "Formen skalieren",
    "scaleShapes": "Formen skalieren",
    "bitbybit.occt.transforms.scaleShapes_description": "Skaliert die Formen mit Skalierungsfaktoren.",
    "factors": "Faktoren",
    "bitbybit.occt.transforms.scale3dShapes": "Formen in 3D skalieren",
    "scale3dShapes": "Formen in 3D skalieren",
    "bitbybit.occt.transforms.scale3dShapes_description": "Skaliert die Form in 3D.",
    "scales": "Skalierungen",
    "bitbybit.occt.transforms.mirrorShapes": "Formen spiegeln",
    "mirrorShapes": "Formen spiegeln",
    "bitbybit.occt.transforms.mirrorShapes_description": "Spiegelt die Formen mit mehreren Spiegeln.",
    "origins": "Ursprünge",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes": "Formen entlang Normalen spiegeln",
    "mirrorAlongNormalShapes": "Formen entlang Normalen spiegeln",
    "bitbybit.occt.transforms.mirrorAlongNormalShapes_description": "Spiegelt die Formen entlang der Normalen und des Ursprungs.",
    "normals": "Normalen",
    "bitbybit.occt.operations.loft": "Loft",
    "operations": "Operationen",
    "loft": "Loft",
    "bitbybit.occt.operations.loft_description": "Erstellt ein Loft aus Drähten zu einer Schale.",
    "lofts": "Lofts",
    "makeSolid": "Volumenkörper erstellen",
    "bitbybit.occt.operations.loftAdvanced": "erweitertes Loft",
    "loftAdvanced": "erweitertes Loft",
    "bitbybit.occt.operations.loftAdvanced_description": "Erstellt ein Loft aus Drähten zu einer Schale unter Verwendung vieler erweiterter Optionen.",
    "straight": "gerade",
    "nrPeriodicSections": "Anzahl periodischer Abschnitte",
    "useSmoothing": "Glättung verwenden",
    "maxUDegree": "maximaler U-Grad",
    "parType": "Parameter-Typ",
    "approxParametrizationTypeEnum": "Approximations-Parametrierungstyp-Enum",
    "startVertex": "Startvertex",
    "endVertex": "Endvertex",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes": "nächste Punkte zwischen zwei Formen",
    "closestPointsBetweenTwoShapes": "nächste Punkte zwischen zwei Formen",
    "bitbybit.occt.operations.closestPointsBetweenTwoShapes_description": "Berechnet zwei nächste Punkte zwischen zwei Formen.",
    "closest pts": "nächste Punkte",
    "shape1": "Form 1",
    "shape2": "Form 2",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints": "nächste Punkte auf Form von Punkten",
    "closestPointsOnShapeFromPoints": "nächste Punkte auf Form von Punkten",
    "bitbybit.occt.operations.closestPointsOnShapeFromPoints_description": "Berechnet nächste Punkte zwischen einer Liste von Punkten und einer gegebenen Form.",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints": "nächste Punkte auf Formen von Punkten",
    "closestPointsOnShapesFromPoints": "nächste Punkte auf Formen von Punkten",
    "bitbybit.occt.operations.closestPointsOnShapesFromPoints_description": "Berechnet nächste Punkte zwischen einer Liste von Punkten und Formen.",
    "bitbybit.occt.operations.distancesToShapeFromPoints": "Abstände zu Form von Punkten",
    "distancesToShapeFromPoints": "Abstände zu Form von Punkten",
    "bitbybit.occt.operations.distancesToShapeFromPoints_description": "Berechnet Abstände zwischen einer Liste von Punkten und entsprechenden nächsten Punkten auf Formen.",
    "bitbybit.occt.operations.boundingBoxOfShape": "Begrenzungsbox der Form",
    "boundingBoxOfShape": "Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxOfShape_description": "berechnet die Parameter der Begrenzungsbox einer Form",
    "bitbybit.occt.operations.boundingBoxMinOfShape": "Minimum der Begrenzungsbox der Form",
    "boundingBoxMinOfShape": "Minimum der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxMinOfShape_description": "ruft den Minimalpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxMaxOfShape": "Maximum der Begrenzungsbox der Form",
    "boundingBoxMaxOfShape": "Maximum der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxMaxOfShape_description": "ruft den Maximalpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxCenterOfShape": "Zentrum der Begrenzungsbox der Form",
    "boundingBoxCenterOfShape": "Zentrum der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxCenterOfShape_description": "ruft den Mittelpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxSizeOfShape": "Größe der Begrenzungsbox der Form",
    "boundingBoxSizeOfShape": "Größe der Begrenzungsbox der Form",
    "bitbybit.occt.operations.boundingBoxSizeOfShape_description": "ruft den Größenpunkt der Begrenzungsbox einer Form ab",
    "bitbybit.occt.operations.boundingBoxShapeOfShape": "Begrenzungsbox-Form der Form",
    "boundingBoxShapeOfShape": "Begrenzungsbox-Form der Form",
    "bitbybit.occt.operations.boundingBoxShapeOfShape_description": "ruft die Begrenzungsbox-Form einer Form ab",
    "bitbybit.occt.operations.boundingSphereOfShape": "Begrenzungskugel der Form",
    "boundingSphereOfShape": "Begrenzungskugel der Form",
    "bitbybit.occt.operations.boundingSphereOfShape_description": "berechnet die Parameter der Begrenzungskugel einer Form",
    "bitbybit.occt.operations.boundingSphereCenterOfShape": "Zentrum der Begrenzungskugel der Form",
    "boundingSphereCenterOfShape": "Zentrum der Begrenzungskugel der Form",
    "bitbybit.occt.operations.boundingSphereCenterOfShape_description": "ruft den Mittelpunkt der Begrenzungskugel einer Form ab",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape": "Radius der Begrenzungskugel der Form",
    "boundingSphereRadiusOfShape": "Radius der Begrenzungskugel der Form",
    "bitbybit.occt.operations.boundingSphereRadiusOfShape_description": "ruft den Radius der Begrenzungskugel einer Form ab",
    "bitbybit.occt.operations.boundingSphereShapeOfShape": "Begrenzungskugel-Form der Form",
    "boundingSphereShapeOfShape": "Begrenzungskugel-Form der Form",
    "bitbybit.occt.operations.boundingSphereShapeOfShape_description": "ruft die Begrenzungskugel-Form einer Form ab",
    "bitbybit.occt.operations.extrude": "extrudieren",
    "extrude": "extrudieren",
    "bitbybit.occt.operations.extrude_description": "Extrudiert die Form entlang der Richtung - Draht erzeugt Schale, Fläche erzeugt Volumenkörper.",
    "extrusions": "Extrusionen",
    "bitbybit.occt.operations.extrudeShapes": "Formen extrudieren",
    "extrudeShapes": "Formen extrudieren",
    "bitbybit.occt.operations.extrudeShapes_description": "Extrudiert die Formen entlang der Richtung.",
    "bitbybit.occt.operations.splitShapeWithShapes": "Form mit Formen teilen",
    "splitShapeWithShapes": "Form mit Formen teilen",
    "bitbybit.occt.operations.splitShapeWithShapes_description": "Teilt die Form mit Formen.",
    "divisions": "Teilungen",
    "localFuzzyTolerance": "lokale Unschärfetoleranz",
    "nonDestructive": "nicht destruktiv",
    "bitbybit.occt.operations.revolve": "rotieren",
    "revolve": "rotieren",
    "bitbybit.occt.operations.revolve_description": "Rotiert die Form um die gegebene Richtung.",
    "revolutions": "Rotationen",
    "copy": "Kopie",
    "bitbybit.occt.operations.rotatedExtrude": "rotierte Extrusion",
    "rotatedExtrude": "rotierte Extrusion",
    "bitbybit.occt.operations.rotatedExtrude_description": "Rotierte Extrusion, die auf der Form durchgeführt wird.",
    "bitbybit.occt.operations.pipe": "Rohr",
    "pipe": "Rohr",
    "bitbybit.occt.operations.pipe_description": "Führt Formen (Pipe) entlang des Drahtes.",
    "pipeing": "Rohrleitung",
    "bitbybit.occt.operations.pipePolylineWireNGon": "Polylinien-Draht N-Eck rohren",
    "pipePolylineWireNGon": "Polylinien-Draht N-Eck rohren",
    "bitbybit.occt.operations.pipePolylineWireNGon_description": "Führt Polyliniendraht (Pipe) mit N-Eck-Profil.",
    "trihedronEnum": "Trihedron-Enum",
    "geomFillTrihedronEnum": "Geometrie-Füll-Trihedron-Enum",
    "forceApproxC1": "C1-Approximation erzwingen",
    "bitbybit.occt.operations.pipeWiresCylindrical": "Drähte zylindrisch rohren",
    "pipeWiresCylindrical": "Drähte zylindrisch rohren",
    "bitbybit.occt.operations.pipeWiresCylindrical_description": "Führt Drähte (Pipe) mit zylindrischer Form.",
    "bitbybit.occt.operations.pipeWireCylindrical": "Draht zylindrisch rohren",
    "pipeWireCylindrical": "Draht zylindrisch rohren",
    "bitbybit.occt.operations.pipeWireCylindrical_description": "Führt Draht (Pipe) mit zylindrischer Form.",
    "bitbybit.occt.operations.offset": "Versatz",
    "bitbybit.occt.operations.offset_description": "Versatz (Offset) für verschiedene Formen.",
    "offsets": "Versätze",
    "bitbybit.occt.operations.offsetAdv": "erweiterter Versatz",
    "offsetAdv": "erweiterter Versatz",
    "bitbybit.occt.operations.offsetAdv_description": "Erweiterter Versatz, der mehr Optionen für den Versatz bietet, wie Join-Typ für Kanten und Ecken.",
    "joinType": "Verbindungstyp",
    "joinTypeEnum": "Verbindungstyp-Enum",
    "removeIntEdges": "interne Kanten entfernen",
    "bitbybit.occt.operations.makeThickSolidSimple": "einfachen dicken Volumenkörper erstellen",
    "makeThickSolidSimple": "einfachen dicken Volumenkörper erstellen",
    "bitbybit.occt.operations.makeThickSolidSimple_description": "Verdickt die Form zu einem Volumenkörper um einen Versatzabstand.",
    "bitbybit.occt.operations.makeThickSolidByJoin": "dicken Volumenkörper durch Verbindung erstellen",
    "makeThickSolidByJoin": "dicken Volumenkörper durch Verbindung erstellen",
    "bitbybit.occt.operations.makeThickSolidByJoin_description": "Verdickt die Form zu einem Volumenkörper durch Verbinden.",
    "intersection": "Schnitt",
    "selfIntersection": "Selbstschnitt",
    "bitbybit.occt.operations.slice": "schneiden",
    "slice": "schneiden",
    "bitbybit.occt.operations.slice_description": "Schneidet die Form in Scheiben (Slice).",
    "bitbybit.occt.operations.sliceInStepPattern": "in Schrittmuster schneiden",
    "sliceInStepPattern": "in Schrittmuster schneiden",
    "bitbybit.occt.operations.sliceInStepPattern_description": "Schneidet die Form in einem Stufenmuster in Scheiben.",
    "steps": "Schritte",
    "bitbybit.occt.operations.offset3DWire": "3D-Draht versetzen",
    "offset3DWire": "3D-Draht versetzen",
    "bitbybit.occt.operations.offset3DWire_description": "Versetzt den 3D-Draht. Wenn Sie diese Methode verwenden, ziehen Sie in Betracht, sie auf verrundeten Drähten zu verwenden, die keine scharfen Ecken enthalten. Sie können 3D-Verrunden darauf verwenden.",
    "bitbybit.occt.booleans.union": "Vereinigung",
    "booleans": "Boolsche Operationen",
    "union": "Vereinigung",
    "bitbybit.occt.booleans.union_description": "Verbindet separate Objekte (Union).",
    "keepEdges": "Kanten behalten",
    "bitbybit.occt.booleans.difference": "Differenz",
    "difference": "Differenz",
    "bitbybit.occt.booleans.difference_description": "Führt eine boolesche Differenzoperation zwischen einer Hauptform und gegebenen Formen durch.",
    "bitbybit.occt.booleans.intersection": "Schnitt",
    "bitbybit.occt.booleans.intersection_description": "Führt eine boolesche Schnittoperation zwischen einer Hauptform und gegebenen Formen durch.",
    "bitbybit.occt.shapeFix.basicShapeRepair": "einfache Formreparatur",
    "shapeFix": "Formreparatur",
    "basicShapeRepair": "einfache Formreparatur",
    "bitbybit.occt.shapeFix.basicShapeRepair_description": "Führt die grundlegende Formreparatur durch.",
    "maxTolerance": "maximale Toleranz",
    "minTolerance": "minimale Toleranz",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire": "kleine Kante am Draht reparieren",
    "fixSmallEdgeOnWire": "kleine Kante am Draht reparieren",
    "bitbybit.occt.shapeFix.fixSmallEdgeOnWire_description": "Repariert kleine Kante auf Draht.",
    "lockvtx": "Vertex sperren",
    "precsmall": "kleine Präzision",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire": "Kantenausrichtungen entlang Draht reparieren",
    "fixEdgeOrientationsAlongWire": "Kantenausrichtungen entlang Draht reparieren",
    "bitbybit.occt.shapeFix.fixEdgeOrientationsAlongWire_description": "Repariert Kantenausrichtungen entlang Draht.",
    "bitbybit.occt.io.saveShapeSTEP": "Form als STEP speichern",
    "saveShapeSTEP": "Form als STEP speichern",
    "bitbybit.occt.io.saveShapeSTEP_description": "Speichert die STEP-Datei.",
    "adjustYtoZ": "Y nach Z anpassen",
    "tryDownload": "Download versuchen",
    "bitbybit.occt.io.saveShapeSTEPAndReturn": "Form als STEP speichern und zurückgeben",
    "saveShapeSTEPAndReturn": "Form als STEP speichern und zurückgeben",
    "bitbybit.occt.io.saveShapeSTEPAndReturn_description": "Speichert die STEP-Datei und gibt den Textwert zurück.",
    "bitbybit.occt.io.saveShapeStl": "Form als STL speichern",
    "saveShapeStl": "Form als STL speichern",
    "bitbybit.occt.io.saveShapeStl_description": "Speichert die STL-Datei.",
    "binary": "binär",
    "bitbybit.occt.io.saveShapeStlAndReturn": "Form als STL speichern und zurückgeben",
    "saveShapeStlAndReturn": "Form als STL speichern und zurückgeben",
    "bitbybit.occt.io.saveShapeStlAndReturn_description": "Speichert die STL-Datei und gibt zurück.",
    "bitbybit.occt.io.loadSTEPorIGES": "STEP oder IGES laden",
    "loadSTEPorIGES": "STEP oder IGES laden",
    "bitbybit.occt.io.loadSTEPorIGES_description": "Importiert die STEP- oder IGES-Asset-Datei.",
    "adjustZtoY": "Z nach Y anpassen",
    "bitbybit.occt.io.loadSTEPorIGESFromText": "STEP oder IGES aus Text laden",
    "loadSTEPorIGESFromText": "STEP oder IGES aus Text laden",
    "bitbybit.occt.io.loadSTEPorIGESFromText_description": "Importiert die STEP- oder IGES-Asset-Datei aus Text.",
    "fileType": "Dateityp",
    "fileTypeEnum": "Dateityp-Enum",
    "bitbybit.advanced.text3d.create": "3D-Text",
    "advanced": "erweitert",
    "text3d": "3D-Text",
    "bitbybit.advanced.text3d.create_description": "Erstellt einen 3D-Text.",
    "fontType": "Schriftart",
    "fontsEnum": "Schriftarten-Enum",
    "fontVariant": "Schriftvariante",
    "fontVariantsEnum": "Schriftvarianten-Enum",
    "Inputs.Base.Vector3": "Eingaben Basis-Vektor 3",
    "originAlignment": "Ursprungsausrichtung",
    "recAlignmentEnum": "Rechteck-Ausrichtungs-Enum",
    "bitbybit.advanced.text3d.createTextOnFace": "Text auf Fläche",
    "createTextOnFace": "Text auf Fläche",
    "bitbybit.advanced.text3d.createTextOnFace_description": "Erstellt einen 3D-Text auf der Fläche.",
    "facePlanar": "planare Fläche",
    "faceTextVar": "Flächen-Text-Variante",
    "faceTextVarEnum": "Flächen-Text-Varianten-Enum",
    "originParamU": "Ursprung Parameter U",
    "originParamV": "Ursprung Parameter V",
    "bitbybit.advanced.text3d.createTextsOnFace": "Texte auf Fläche",
    "createTextsOnFace": "Texte auf Fläche",
    "bitbybit.advanced.text3d.createTextsOnFace_description": "Erstellt 3D-Texte auf der Fläche aus mehreren Definitionen.",
    "definitions": "Definitionen",
    "Text3DFaceDefinitionDto[]": "3D-Text-Flächen-Definition-DTO-Array",
    "bitbybit.advanced.text3d.definition3dTextOnFace": "Definition 3D-Text auf Fläche",
    "definition3dTextOnFace": "Definition 3D-Text auf Fläche",
    "bitbybit.advanced.text3d.definition3dTextOnFace_description": "Erstellt 3D-Text, der auf der Flächendefinition verwendet wird.",
    "bitbybit.advanced.text3d.getCompoundShape": "Verbindungsform abrufen",
    "getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.advanced.text3d.getCompoundShape_description": "Ruft Verbundform des 3D-Text-Ergebnisses ab.",
    "model": "Modell",
    "Text3DData<T>": "3D-Text-Daten T",
    "bitbybit.advanced.text3d.getCharacterShape": "Zeichenform abrufen",
    "getCharacterShape": "Zeichenform abrufen",
    "bitbybit.advanced.text3d.getCharacterShape_description": "Ruft die Zeichenform an einem bestimmten Index ab.",
    "bitbybit.advanced.text3d.getCharacterShapes": "Zeichenformen abrufen",
    "getCharacterShapes": "Zeichenformen abrufen",
    "bitbybit.advanced.text3d.getCharacterShapes_description": "Ruft Zeichenformen des 3D-Text-Ergebnisses ab.",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates": "Zeichenmittelpunktskoordinaten abrufen",
    "getCharacterCenterCoordinates": "Zeichenmittelpunktskoordinaten abrufen",
    "bitbybit.advanced.text3d.getCharacterCenterCoordinates_description": "Ruft die Koordinaten des Massenschwerpunkts aller Zeichen ab.",
    "bitbybit.advanced.text3d.getFaceCutout": "Flächenausschnitt abrufen",
    "getFaceCutout": "Flächenausschnitt abrufen",
    "bitbybit.advanced.text3d.getFaceCutout_description": "Ruft den Flächenausschnitt von Text 3D ab, der auf der Fläche erstellt wurde.",
    "get from face": "von Fläche abrufen",
    "bitbybit.advanced.text3d.getAllFacesOfCutout": "alle Flächen des Ausschnitts abrufen",
    "getAllFacesOfCutout": "alle Flächen des Ausschnitts abrufen",
    "bitbybit.advanced.text3d.getAllFacesOfCutout_description": "Ruft alle Flächenausschnitte von Text 3D ab, der auf der ursprünglichen Fläche erstellt wurde.",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters": "Ausschnitte innerhalb von Zeichen abrufen",
    "getCutoutsInsideCharacters": "Ausschnitte innerhalb von Zeichen abrufen",
    "bitbybit.advanced.text3d.getCutoutsInsideCharacters_description": "Ruft Zeichenflächenausschnitte von Text 3D ab, der auf der ursprünglichen Fläche erstellt wurde.",
    "bitbybit.advanced.text3d.getAdvanceWidth": "Vorschubbreite abrufen",
    "getAdvanceWidth": "Vorschubbreite abrufen",
    "bitbybit.advanced.text3d.getAdvanceWidth_description": "Ruft Vorlaufbreite ab.",
    "dimensions": "Abmessungen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple": "einfache Pyramide",
    "facePatterns": "Flächenmuster",
    "pyramidSimple": "einfache Pyramide",
    "createPyramidSimple": "einfache Pyramide",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimple_description": "Erstellt ein einfaches Pyramidenmuster auf Flächen.",
    "uNumber": "U-Anzahl",
    "vNumber": "V-Anzahl",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors": "Pyramidenmuster mit Einflussfaktoren",
    "createPyramidSimpleAffectors": "Pyramidenmuster mit Einflussfaktoren",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.createPyramidSimpleAffectors_description": "Erstellt ein einfaches Pyramidenmuster auf Flächen mit Effektoren, die die Höhe ändern.",
    "affectorPoints": "Einflusspunkte",
    "Inputs.Base.Point3[]": "Eingaben Basis-Punkt-3-Array",
    "affectorRadiusList": "Einflussradius-Liste",
    "affectorFactors": "Einflussfaktoren",
    "defaultHeight": "Standardhöhe",
    "affectMinHeight": "Einfluss-Minimalhöhe",
    "affectMaxHeight": "Einfluss-Maximalhöhe",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShape_description": "Ruft die Verbundform aller Pyramiden ab.",
    "get shapes": "Formen abrufen",
    "PyramidSimpleData<T>": "einfache Pyramiden-Daten T",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace": "Verbindungsform auf Fläche abrufen",
    "getCompoundShapeOnFace": "Verbindungsform auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeOnFace_description": "Ruft die Verbundform auf der Fläche ab.",
    "faceIndex": "Flächenindex",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace": "Pyramidenzelle auf Fläche abrufen",
    "getCompoundShapeCellOnFace": "Pyramidenzelle auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapeCellOnFace_description": "Ruft die Verbundform der Pyramide auf der Fläche an einem bestimmten Index ab.",
    "uIndex": "U-Index",
    "vIndex": "V-Index",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells": "alle Pyramidenzellen abrufen",
    "getAllPyramidCells": "alle Pyramidenzellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCells_description": "Ruft alle Pyramidenzellen ab. Dies ist normalerweise eine Zwischenaktion, um dann bestimmte Informationen der Zellen selbst zu lesen.",
    "get cells": "Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace": "alle Pyramidenzellen auf Fläche abrufen",
    "getAllPyramidCellsOnFace": "alle Pyramidenzellen auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidCellsOnFace_description": "Ruft Pyramidenzellen auf der Fläche ab. Dies ist normalerweise eine Zwischenaktion, um dann bestimmte Informationen der Zellen selbst zu lesen.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace": "alle Pyramiden-U-Zellen auf Fläche abrufen",
    "getAllPyramidUCellsOnFace": "alle Pyramiden-U-Zellen auf Fläche abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFace_description": "Ruft Pyramidenzellen auf der Fläche ab. Dies ist normalerweise eine Zwischenaktion, um dann bestimmte Informationen der Zellen selbst zu lesen.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU": "alle Pyramiden-U-Zellen auf Fläche bei U abrufen",
    "getAllPyramidUCellsOnFaceAtU": "alle Pyramiden-U-Zellen auf Fläche bei U abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtU_description": "Ruft Pyramidenzellen auf der Fläche bei U-Index entlang V-Richtung ab. Dies ist normalerweise eine Zwischenaktion, um dann bestimmte Informationen der Zellen selbst zu lesen.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV": "alle Pyramiden-U-Zellen auf Fläche bei V abrufen",
    "getAllPyramidUCellsOnFaceAtV": "alle Pyramiden-U-Zellen auf Fläche bei V abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getAllPyramidUCellsOnFaceAtV_description": "Ruft Pyramidenzellen auf der Fläche bei V-Index entlang U-Richtung ab. Dies ist normalerweise eine Zwischenaktion, um dann bestimmte Informationen der Zellen selbst zu lesen.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex": "Zelle bei Index abrufen",
    "getCellOnIndex": "Zelle bei Index abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCellOnIndex_description": "Ruft Pyramidenzelle auf der Fläche bei U- und V-Index ab. Dies ist normalerweise eine Zwischenaktion, um dann bestimmte Informationen der Zelle selbst zu lesen.",
    "get cell": "Zelle abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells": "obere Punkte der Zellen abrufen",
    "getTopPointsOfCells": "obere Punkte der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getTopPointsOfCells_description": "Ruft die oberen Punkte der Zellen ab.",
    "get from cells": "aus Zellen abrufen",
    "cells": "Zellen",
    "PyramidSimpleCellPart<T>[]": "einfache Pyramidenzellen-Teil T-Array",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells": "Mittelpunkte der Zellen abrufen",
    "getCenterPointsOfCells": "Mittelpunkte der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCenterPointsOfCells_description": "Ruft den Mittelpunkt zwischen den Zellecken ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells": "Eckpunkte der Zellen abrufen",
    "getCornerPointsOfCells": "Eckpunkte der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointsOfCells_description": "Ruft die Eckpunkte der Zellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells": "Eckpunkt der Zellen abrufen",
    "getCornerPointOfCells": "Eckpunkt der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerPointOfCells_description": "Ruft die Eckpunkte der Zellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells": "Ecknormale der Zellen abrufen",
    "getCornerNormalOfCells": "Ecknormale der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalOfCells_description": "Ruft die Ecknormale der Zellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells": "Ecknormalen der Zellen abrufen",
    "getCornerNormalsOfCells": "Ecknormalen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCornerNormalsOfCells_description": "Ruft die Ecknormalen der Zellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells": "Verbindungsformen der Zellen abrufen",
    "getCompoundShapesOfCells": "Verbindungsformen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getCompoundShapesOfCells_description": "Ruft die Verbundformen der Pyramidenzellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells": "Flächenformen der Zellen abrufen",
    "getFaceShapesOfCells": "Flächenformen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getFaceShapesOfCells_description": "Ruft die Flächenformen der bereitgestellten Pyramidenzellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells": "Drahtformen der Zellen abrufen",
    "getWireShapesOfCells": "Drahtformen der Zellen abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getWireShapesOfCells_description": "Ruft die Flächenformen der bereitgestellten Pyramidenzellen ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU": "Start-Polylinien-Draht U abrufen",
    "getStartPolylineWireU": "Start-Polylinien-Draht U abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireU_description": "Ruft den Polyliniendraht entlang der Startkante der U-Richtung der Fläche ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU": "End-Polylinien-Draht U abrufen",
    "getEndPolylineWireU": "End-Polylinien-Draht U abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireU_description": "Ruft den Polyliniendraht entlang der Endkante der U-Richtung der Fläche ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV": "Start-Polylinien-Draht V abrufen",
    "getStartPolylineWireV": "Start-Polylinien-Draht V abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getStartPolylineWireV_description": "Ruft den Polyliniendraht entlang der Startkante der V-Richtung der Fläche ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV": "End-Polylinien-Draht V abrufen",
    "getEndPolylineWireV": "End-Polylinien-Draht V abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getEndPolylineWireV_description": "Ruft den Polyliniendraht entlang der Endkante der V-Richtung der Fläche ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound": "Polylinien-Drähte U-Verbindung abrufen",
    "getPolylineWiresUCompound": "Polylinien-Drähte U-Verbindung abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresUCompound_description": "Ruft die Polyliniendrähte entlang U-Richtung ab.",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound": "Polylinien-Drähte V-Verbindung abrufen",
    "getPolylineWiresVCompound": "Polylinien-Drähte V-Verbindung abrufen",
    "bitbybit.advanced.patterns.facePatterns.pyramidSimple.getPolylineWiresVCompound_description": "Ruft die Polyliniendrähte entlang V-Richtung ab.",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create": "Flügelspitzen-Villa",
    "things": "Dinge",
    "kidsCorner": "Kinder-Ecke",
    "birdhouses": "Vogelhäuser",
    "wingtipVilla": "Flügelspitzen-Villa",
    "bitbybit.things.kidsCorner.birdhouses.wingtipVilla.create_description": "Erstellt ein Wingtip-Villa-Vogelhaus mit einem 45-Grad-Dach.",
    "birdhouse": "Vogelhaus",
    "interiorWidth": "Innenbreite",
    "interiorLength": "Innenlänge",
    "interiorHeight": "Innenhöhe",
    "holeDiameter": "Lochdurchmesser",
    "holeDistToBottom": "Lochabstand zum Boden",
    "stickLength": "Stab-Länge",
    "stickDiameter": "Stab-Durchmesser",
    "baseAttachmentHeight": "Basis-Befestigungshöhe",
    "roofOverhang": "Dachüberhang",
    "chimneyHeight": "Schornsteinhöhe",
    "Inputs.Base.Point3": "Eingaben Basis-Punkt 3",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create": "Zwitscher-Chalet",
    "chirpyChalet": "Zwitscher-Chalet",
    "bitbybit.things.kidsCorner.birdhouses.chirpyChalet.create_description": "Erstellt ein Chirpy-Chalet-Vogelhaus mit einem 45-Grad-Dach.",
    "roofAngle": "Dachwinkel",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create": "Serenitäts-Wirbel",
    "threeDPrinting": "3D-Druck",
    "vases": "Vasen",
    "serenitySwirl": "Serenitäts-Wirbel",
    "bitbybit.things.threeDPrinting.vases.serenitySwirl.create_description": "Erstellt eine Serenity-Swirl.",
    "swirl": "Wirbel",
    "addRadiusNarrow": "Radius schmal hinzufügen",
    "addRadiusWide": "Radius breit hinzufügen",
    "addMiddleHeight": "mittlere Höhe hinzufügen",
    "addTopHeight": "obere Höhe hinzufügen",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create": "Arabischer Torbogen",
    "arabicArchway": "Arabischer Torbogen",
    "bitbybit.things.threeDPrinting.vases.arabicArchway.create_description": "Erstellt eine Arabic-Archway-Vase.",
    "profilePoints": "Profilpunkte",
    "nrOfSides": "Anzahl der Seiten",
    "nrOfVerticalArches": "Anzahl vertikaler Bögen",
    "archCenterThickness": "Bogendicke Mitte",
    "edgesThickness": "Kantendicke",
    "baseHeight": "Basishöhe",
    "patchHoles": "Löcher flicken",
    "lod": "Detailgrad",
    "Things.Enums.lodEnum": "Dinge Enums Detailgrad-Enum",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create": "Ewige Liebe",
    "medals": "Medaillen",
    "eternalLove": "Ewige Liebe",
    "bitbybit.things.threeDPrinting.medals.eternalLove.create_description": "Erstellt ein Eternal-Love-Medaillenmodell.",
    "textHeading": "Textüberschrift",
    "textName": "Textname",
    "fullModel": "vollständiges Modell",
    "decorationThickness": "Dekorationsdicke",
    "bitbybit.things.threeDPrinting.cups.calmCup.create": "Ruhige Tasse",
    "cups": "Tassen",
    "calmCup": "Ruhige Tasse",
    "bitbybit.things.threeDPrinting.cups.calmCup.create_description": "Erstellt ein Tassenmodell für Ihre ruhigen Momente.",
    "radiusTopOffset": "Radius-Oberversatz",
    "fillet": "Rundung",
    "nrOfHandles": "Anzahl der Griffe",
    "handleDist": "Griffabstand",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create": "Drachen-Tasse",
    "dragonCup": "Drachen-Tasse",
    "bitbybit.things.threeDPrinting.cups.dragonCup.create_description": "Erstellt ein Tassenmodell für Ihren inneren Drachen.",
    "radiusMidOffset": "Radius-Mittelversatz",
    "rotationTopAngle": "Rotationswinkel oben",
    "rotationMidAngle": "Rotationswinkel Mitte",
    "nrSkinCellsVertical": "Anzahl Hautzellen vertikal",
    "nrSkinCellsHorizontal": "Anzahl Hautzellen horizontal",
    "nrSkinCellDivisionsTop": "Anzahl Hautzellen-Teilungen oben",
    "nrSkinCellDivisionsBottom": "Anzahl Hautzellen-Teilungen unten",
    "skinCellOuterHeight": "Hautzellen-äußere Höhe",
    "skinCellInnerHeight": "Hautzellen-innere Höhe",
    "skinCellBottomHeight": "Hautzellen-untere Höhe",
    "skinCellTopHeight": "Hautzellen-obere Höhe",
    "bottomThickness": "Bodendicke",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.threeDPrinting.cups.dragonCup.getCompoundShape_description": "Ruft die Verbundform der Drachentasse ab.",
    "DragonCupData<T>": "Drachen-Tassen-Daten T",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create": "Telefon-Nest",
    "desktop": "Schreibtisch",
    "phoneNest": "Telefon-Nest",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.create_description": "Erstellt ein Phone-Nest-Modell.",
    "heightBottom": "Höhe unten",
    "heightTop": "Höhe oben",
    "widthBack": "Breite hinten",
    "widthFront": "Breite vorne",
    "backOffset": "Versatz hinten",
    "applyOrnaments": "Ornamente anwenden",
    "filletRadius": "Rundungsradius",
    "phoneHeight": "Telefonhöhe",
    "phoneWidth": "Telefonbreite",
    "phoneThickness": "Telefondicke",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.getCompoundShape_description": "Ruft die Verbundform des Phone-Nests ab.",
    "PhoneNestData<T>": "Telefon-Nest-Daten T",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions": "Zeichenoptionen",
    "drawOptions": "Zeichenoptionen",
    "bitbybit.things.threeDPrinting.desktop.phoneNest.drawOptions_description": "erstellt Zeichenoptionen für das Modell",
    "mainMaterial": "Hauptmaterial",
    "phoneMaterial": "Telefonmaterial",
    "Inputs.Base.Color": "Eingaben Basis-Farbe",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create": "Tröpfchen-Telefonhalter",
    "laserCutting": "Laserschneiden",
    "gadgets": "Gadgets",
    "dropletsPhoneHolder": "Tröpfchen-Telefonhalter",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.create_description": "erstellt einen Tröpfchen-Telefonhalter",
    "title": "Titel",
    "subtitle": "Untertitel",
    "includeLogo": "Logo einfügen",
    "kerf": "Schnittbreite",
    "backLength": "Rückenlänge",
    "offsetAroundPhone": "Versatz um das Telefon",
    "penShelf": "Stiftregal",
    "phoneLockHeight": "Telefonverriegelungshöhe",
    "includePattern": "Muster einfügen",
    "densityPattern": "Dichte des Musters",
    "holesForWire": "Löcher für Kabel",
    "wireInputThickness": "Kabeleingangsdicke",
    "includeModel": "Modell einfügen",
    "includeDrawings": "Zeichnungen einfügen",
    "spacingDrawings": "Abstand der Zeichnungen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCompoundShape_description": "Ruft die Verbundform des Droplets-Phone-Holders ab.",
    "DropletsPhoneHolderData<T>": "Tröpfchen-Telefonhalter-Daten T",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound": "Schnittdrähte-Verbindung abrufen",
    "getCutWiresCompound": "Schnittdrähte-Verbindung abrufen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getCutWiresCompound_description": "Ruft den Schneiddrähte-Verbund ab.",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound": "Gravurdrähte-Verbindung abrufen",
    "getEngravingWiresCompound": "Gravurdrähte-Verbindung abrufen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.getEngravingWiresCompound_description": "Ruft den Gravurdrähte-Verbund ab.",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings": "DXF-Zeichnungen herunterladen",
    "downloadDXFDrawings": "DXF-Zeichnungen herunterladen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadDXFDrawings_description": "lädt eine DXF-Zeichnung herunter",
    "download": "herunterladen",
    "cutWiresColor": "Farbe der Schnittdrähte",
    "engravingWiresColor": "Farbe der Gravurdrähte",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings": "STEP-Zeichnungen herunterladen",
    "downloadSTEPDrawings": "STEP-Zeichnungen herunterladen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.downloadSTEPDrawings_description": "lädt eine STEP-Zeichnung herunter",
    "adjustYZ": "YZ anpassen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel": "3D-STEP-Modell herunterladen",
    "download3dSTEPModel": "3D-STEP-Modell herunterladen",
    "bitbybit.things.laserCutting.gadgets.dropletsPhoneHolder.download3dSTEPModel_description": "lädt ein 3D-STEP-Modell herunter",
    "bitbybit.things.architecture.houses.zenHideout.create": "Zen-Versteck",
    "architecture": "Architektur",
    "houses": "Häuser",
    "zenHideout": "Zen-Versteck",
    "bitbybit.things.architecture.houses.zenHideout.create_description": "Erstellt ein Zen-Hideout.",
    "widthFirstWing": "Breite erster Flügel",
    "lengthFirstWing": "Länge erster Flügel",
    "terraceWidth": "Terrassenbreite",
    "widthSecondWing": "Breite zweiter Flügel",
    "lengthSecondWing": "Länge zweiter Flügel",
    "heightWalls": "Höhe der Wände",
    "roofAngleFirstWing": "Dachwinkel erster Flügel",
    "roofAngleSecondWing": "Dachwinkel zweiter Flügel",
    "roofOffset": "Dachversatz",
    "roofInsideOverhang": "Dachinnenüberhang",
    "roofMaxDistAttachmentBeams": "maximaler Abstand der Dachbefestigungsbalken",
    "roofAttachmentBeamWidth": "Breite der Dachbefestigungsbalken",
    "roofAttachmentBeamHeight": "Höhe der Dachbefestigungsbalken",
    "roofOutsideOverhang": "Dachaußenüberhang",
    "columnSize": "Säulengröße",
    "ceilingBeamHeight": "Höhe der Deckenbalken",
    "ceilingBeamWidth": "Breite der Deckenbalken",
    "nrCeilingBeamsBetweenColumns": "Anzahl der Deckenbalken zwischen Säulen",
    "distBetweenColumns": "Abstand zwischen Säulen",
    "floorHeight": "Bohdenhöhe",
    "groundLevel": "Bodenlevel",
    "facadePanelThickness": "Dicke der Fassadenplatte",
    "windowWidthOffset": "Fensterbreitenversatz",
    "windowHeightOffset": "Fensterhöhenversatz",
    "windowFrameThickness": "Fensterrahmendicke",
    "windowGlassFrameThickness": "Fensterrahmenglasdicke",
    "skinOpacity": "Hauttransparenz",
    "bitbybit.things.furniture.chairs.snakeChair.create": "Schlangen-Stuhl",
    "furniture": "Möbel",
    "chairs": "Stühle",
    "snakeChair": "Schlangen-Stuhl",
    "bitbybit.things.furniture.chairs.snakeChair.create_description": "Erstellt ein Snake-Chair-Modell.",
    "sittingHeight": "Sitzhöhe",
    "backRestOffset": "Rückenlehnenversatz",
    "backRestHeight": "Rückenlehnenhöhe",
    "nrOrnamentPlanks": "Anzahl der Ornamentbretter",
    "ornamentDepth": "Ornamenttiefe",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.getCompoundShape_description": "Ruft die Verbundform des Stuhls ab.",
    "SnakeChairData<T>": "Schlangen-Stuhl-Daten T",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape": "Sitzflächen-Drahtform abrufen",
    "getSittingWireShape": "Sitzflächen-Drahtform abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingWireShape_description": "Ruft die Drahtform des Sitzbereichs des Stuhls ab.",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint": "Mittelpunkt des Sitzbereichs abrufen",
    "getSittingAreaCenterPoint": "Mittelpunkt des Sitzbereichs abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.getSittingAreaCenterPoint_description": "Ruft den Mittelpunkt des Sitzbereichs des Stuhls ab.",
    "get points": "Punkte abrufen",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.chairs.snakeChair.drawOptions_description": "erstellt Zeichenoptionen für den Schlangen-Stuhl",
    "bitbybit.things.furniture.tables.elegantTable.create": "Eleganter Tisch",
    "tables": "Tische",
    "elegantTable": "Eleganter Tisch",
    "bitbybit.things.furniture.tables.elegantTable.create_description": "Erstellt ein elegantes Tischmodell.",
    "topThickness": "Oberflächendicke",
    "topOffset": "Oberflächenversatz",
    "minFillet": "minimale Rundung",
    "radiusLegTop": "Radius Bein oben",
    "radiusLegBottom": "Radius Bein unten",
    "nrLegPairs": "Anzahl der Beinpaare",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getCompoundShape_description": "Ruft die Verbundform des Tisches ab.",
    "ElegantTableData<T>": "Eleganter-Tisch-Daten T",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes": "Beinformen abrufen",
    "getLegShapes": "Beinformen abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapes_description": "Ruft die Beinformen als Liste ab.",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex": "Beinform nach Index abrufen",
    "getLegShapeByIndex": "Beinform nach Index abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegShapeByIndex_description": "Ruft die Beinform nach Index ab.",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape": "Oberflächenplattenform abrufen",
    "getTopPanelShape": "Oberflächenplattenform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelShape_description": "Ruft die Tischplattenform ab.",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape": "Oberflächenplatten-Drahtform abrufen",
    "getTopPanelWireShape": "Oberflächenplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTopPanelWireShape_description": "Ruft die Drahtform der Tischplatte ab.",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape": "Unterflächenplatten-Drahtform abrufen",
    "getBottomPanelWireShape": "Unterflächenplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelWireShape_description": "Ruft die Drahtform der unteren Tischplatte ab.",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape": "Unterflächenplattenform abrufen",
    "getBottomPanelShape": "Unterflächenplattenform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getBottomPanelShape_description": "Ruft die Form der unteren Tischplatte ab.",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape": "Beinverbindungsform abrufen",
    "getLegsCompoundShape": "Beinverbindungsform abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegsCompoundShape_description": "Ruft die Beinformen als Verbundform ab.",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint": "Mittelpunkt der Tischoberfläche abrufen",
    "getTableTopCenterPoint": "Mittelpunkt der Tischoberfläche abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTableTopCenterPoint_description": "Ruft den oberen Mittelpunkt ab.",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint": "Mittelpunkt der Tischunterfläche abrufen",
    "getTableBottomCenterPoint": "Mittelpunkt der Tischunterfläche abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getTableBottomCenterPoint_description": "Ruft den unteren Mittelpunkt ab.",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints": "untere Beinpunkte abrufen",
    "getLegBottomPoints": "untere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegBottomPoints_description": "Ruft die unteren Punkte der Beine ab.",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints": "obere Beinpunkte abrufen",
    "getLegTopPoints": "obere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.elegantTable.getLegTopPoints_description": "Ruft die oberen Punkte der Beine ab.",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.tables.elegantTable.drawOptions_description": "erstellt Zeichenoptionen für den eleganten Tisch",
    "topMaterial": "Oberflächenmaterial",
    "topBaseMaterial": "Oberflächenbasismaterial",
    "legsMaterial": "Beinmaterial",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create": "Guter Couchtisch",
    "goodCoffeeTable": "Guter Couchtisch",
    "bitbybit.things.furniture.tables.goodCoffeeTable.create_description": "Erstellt ein Good-Coffee-Table-Modell.",
    "chamfer": "Fase",
    "topGlassOffset": "Glasoberflächenversatz",
    "glassThickness": "Glasdicke",
    "glassHolderLength": "Länge des Glashalters",
    "shelfTopOffset": "Regaloberflächenversatz",
    "shelfThickness": "Regaldicke",
    "legWidth": "Beinbreite",
    "legDepth": "Beintiefe",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getCompoundShape_description": "Ruft die Verbundform des Tisches ab.",
    "GoodCoffeeTableData<T>": "Guter-Couchtisch-Daten T",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes": "Beinformen abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapes_description": "Ruft die Beinformen als Liste ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex": "Beinform nach Index abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegShapeByIndex_description": "Ruft die Beinform nach Index ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape": "Oberflächenplattenform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelShape_description": "Ruft die Tischplattenform ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape": "Oberflächenplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTopPanelWireShape_description": "Ruft die Drahtform der Tischplatte ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape": "Glasplattenform abrufen",
    "getGlassPanelShape": "Glasplattenform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelShape_description": "Ruft die Glasplattenform des Tisches ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape": "Glasplatten-Drahtform abrufen",
    "getGlassPanelWireShape": "Glasplatten-Drahtform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getGlassPanelWireShape_description": "Ruft die Drahtform der Glasplatte des Tisches ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape": "Regalform abrufen",
    "getShelfShape": "Regalform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfShape_description": "Ruft die Regalform des Tisches ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape": "Regaloberflächen-Drahtform abrufen",
    "getShelfTopWireShape": "Regaloberflächen-Drahtform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getShelfTopWireShape_description": "Ruft die Drahtform der Regaloberseite des Tisches ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape": "Beinverbindungsform abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegsCompoundShape_description": "Ruft die Beinformen als Verbundform ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint": "Mittelpunkt der Tischoberfläche abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableTopCenterPoint_description": "Ruft den oberen Mittelpunkt ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint": "Mittelpunkt der Regaloberfläche abrufen",
    "getTableShelfTopCenterPoint": "Mittelpunkt der Regaloberfläche abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getTableShelfTopCenterPoint_description": "Ruft den oberen Mittelpunkt des Regals ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints": "untere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegBottomPoints_description": "Ruft die unteren Punkte der Beine ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints": "obere Beinpunkte abrufen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.getLegTopPoints_description": "Ruft die oberen Punkte der Beine ab.",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.tables.goodCoffeeTable.drawOptions_description": "erstellt Zeichenoptionen für den guten Couchtisch",
    "topGlassMaterial": "Oberflächenglasmaterial",
    "shelfMaterial": "Regalmaterial",
    "bitbybit.things.furniture.tables.snakeTable.create": "Schlangen-Tisch",
    "snakeTable": "Schlangen-Tisch",
    "bitbybit.things.furniture.tables.snakeTable.create_description": "Erstellt ein Snake-Table-Modell.",
    "supportLength": "Stützlänge",
    "shelfHeight": "Regalhöhe",
    "glassOffset": "Glasversatz",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape": "Verbindungsform abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getCompoundShape_description": "Ruft die Verbundform des Tisches ab.",
    "SnakeTableData<T>": "Schlangen-Tisch-Daten T",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape": "Glasform abrufen",
    "getGlassShape": "Glasform abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getGlassShape_description": "Ruft die Glasform des Tisches ab.",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape": "Hauptform abrufen",
    "getMainShape": "Hauptform abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getMainShape_description": "Ruft die Hauptvolumenkörperform des Tisches ab.",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint": "Mittelpunkt der Oberfläche abrufen",
    "getTopCenterPoint": "Mittelpunkt der Oberfläche abrufen",
    "bitbybit.things.furniture.tables.snakeTable.getTopCenterPoint_description": "Ruft den Mittelpunkt der Tischplatte ab.",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions": "Zeichenoptionen",
    "bitbybit.things.furniture.tables.snakeTable.drawOptions_description": "erstellt Zeichenoptionen für den Schlangen-Tisch",
    "glassMaterial": "Glasmaterial",
    "bitbybit.things.enums.lodEnum": "Detailgrad-Enum",
    "enums": "Enums",
    "lodEnum": "Detailgrad-Enum",
    "bitbybit.things.enums.lodEnum_description": "Erstellt einen Detailgrad (LOD) Enumerationswert.",
    "bitbybit.jscad.transformSolids": "Volumenkörper transformieren",
    "jscad": "JSCAD",
    "transformSolids": "Volumenkörper transformieren",
    "bitbybit.jscad.transformSolids_description": "Transformiert die JSCAD-Volumenkörper-Meshes mit einer gegebenen Liste von Transformationen.",
    "JSCADEntity[]": "JSCAD-Entitäten-Array",
    "bitbybit.jscad.transformSolid": "Volumenkörper transformieren",
    "transformSolid": "Volumenkörper transformieren",
    "bitbybit.jscad.transformSolid_description": "Transformiert das JSCAD-Volumenkörper-Mesh mit einer gegebenen Liste von Transformationen.",
    "JSCADEntity": "JSCAD-Entität",
    "bitbybit.jscad.downloadSolidSTL": "Volumenkörper-STL herunterladen",
    "downloadSolidSTL": "Volumenkörper-STL herunterladen",
    "bitbybit.jscad.downloadSolidSTL_description": "Lädt die binäre STL-Datei von einem 3D-Volumenkörper herunter.",
    "bitbybit.jscad.downloadSolidsSTL": "Volumenkörper-STLs herunterladen",
    "downloadSolidsSTL": "Volumenkörper-STLs herunterladen",
    "bitbybit.jscad.downloadSolidsSTL_description": "Lädt die binäre STL-Datei von 3D-Volumenkörpern herunter.",
    "bitbybit.jscad.downloadGeometryDxf": "Geometrie-DXF herunterladen",
    "downloadGeometryDxf": "Geometrie-DXF herunterladen",
    "bitbybit.jscad.downloadGeometryDxf_description": "Lädt die DXF-Datei von JSCAD-Geometrie herunter. Unterstützt Pfade und Meshes im Array.",
    "geometry": "Geometrie",
    "JSCADEntity | JSCADEntity[]": "JSCAD-Entität oder Array",
    "bitbybit.jscad.downloadGeometry3MF": "Geometrie-3MF herunterladen",
    "downloadGeometry3MF": "Geometrie-3MF herunterladen",
    "bitbybit.jscad.downloadGeometry3MF_description": "Lädt die 3MF-Datei von JSCAD-Geometrie herunter.",
    "bitbybit.jscad.booleans.intersect": "sich schneiden",
    "intersect": "sich schneiden",
    "bitbybit.jscad.booleans.intersect_description": "Schneidet mehrere Volumenkörper-Mesh-Objekte (Intersect).",
    "bitbybit.jscad.booleans.subtract": "subtrahieren",
    "subtract": "subtrahieren",
    "bitbybit.jscad.booleans.subtract_description": "Subtrahiert mehrere Volumenkörper-Mesh-Objekte.",
    "bitbybit.jscad.booleans.union": "Vereinigung",
    "bitbybit.jscad.booleans.union_description": "Vereinigt mehrere Volumenkörper-Mesh-Objekte (Union).",
    "bitbybit.jscad.booleans.intersectTwo": "zwei schneiden",
    "intersectTwo": "zwei schneiden",
    "bitbybit.jscad.booleans.intersectTwo_description": "Schneidet zwei Volumenkörper-Mesh-Objekte (Intersect).",
    "bitbybit.jscad.booleans.subtractTwo": "zwei subtrahieren",
    "subtractTwo": "zwei subtrahieren",
    "bitbybit.jscad.booleans.subtractTwo_description": "Subtrahiert zwei Volumenkörper-Mesh-Objekte.",
    "bitbybit.jscad.booleans.unionTwo": "zwei vereinigen",
    "unionTwo": "zwei vereinigen",
    "bitbybit.jscad.booleans.unionTwo_description": "Vereinigt zwei Volumenkörper-Mesh-Objekte (Union).",
    "bitbybit.jscad.booleans.subtractFrom": "von subtrahieren",
    "subtractFrom": "von subtrahieren",
    "bitbybit.jscad.booleans.subtractFrom_description": "Subtrahiert mehrere Meshes von einem Mesh-Objekt.",
    "bitbybit.jscad.expansions.expand": "erweitern",
    "expansions": "Erweiterungen",
    "expand": "erweitern",
    "bitbybit.jscad.expansions.expand_description": "Erweitert (Expand) Geometrien der Volumenkörper-Kategorie.",
    "expansion": "Erweiterung",
    "delta": "Delta",
    "corners": "Ecken",
    "solidCornerTypeEnum": "Volumenecken-Typ-Enum",
    "bitbybit.jscad.expansions.offset": "Versatz",
    "bitbybit.jscad.expansions.offset_description": "Versetzt (Offset) 2D-Geometrien der Volumenkörper-Kategorie.",
    "bitbybit.jscad.extrusions.extrudeLinear": "linear extrudieren",
    "extrudeLinear": "linear extrudieren",
    "bitbybit.jscad.extrusions.extrudeLinear_description": "Extrudiert linear 2D-Geometrien der Volumenkörper-Kategorie.",
    "twistAngle": "Verdrehungswinkel",
    "twistSteps": "Verdrehungsschritte",
    "bitbybit.jscad.extrusions.extrudeRectangular": "rechteckig extrudieren",
    "extrudeRectangular": "rechteckig extrudieren",
    "bitbybit.jscad.extrusions.extrudeRectangular_description": "Extrudiert rechteckig 2D-Geometrien der Volumenkörper-Kategorie. Erstellt eine wandartige Extrusion von bestimmter Höhe und Größe.",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints": "Punkte rechteckig extrudieren",
    "extrudeRectangularPoints": "Punkte rechteckig extrudieren",
    "bitbybit.jscad.extrusions.extrudeRectangularPoints_description": "Extrudiert rechteckig eine Liste von 2D-Punkten. Erstellt eine wandartige Extrusion von bestimmter Höhe und Größe.",
    "bitbybit.jscad.extrusions.extrudeRotate": "rotierend extrudieren",
    "extrudeRotate": "rotierend extrudieren",
    "bitbybit.jscad.extrusions.extrudeRotate_description": "Extrudiert rechteckig eine Liste von 2D-Punkten. Erstellt eine wandartige Extrusion von bestimmter Höhe und Größe.",
    "polygon": "Polygon",
    "startAngle": "Startwinkel",
    "bitbybit.jscad.hulls.hullChain": "Hülle verketteten",
    "hulls": "Hüllen",
    "hullChain": "Hülle verketteten",
    "bitbybit.jscad.hulls.hullChain_description": "Hüllen-Kette (Hull Chain) verbindet Volumenkörper oder 2D-Geometrien durch Füllen eines leeren Raums zwischen Objekten in Reihenfolge. Geometrien müssen vom gleichen Typ sein.",
    "bitbybit.jscad.hulls.hull": "Hülle",
    "hull": "Hülle",
    "bitbybit.jscad.hulls.hull_description": "Konvexe Hülle (Convex Hull) verbindet Volumenkörper oder 2D-Geometrien durch Füllen eines leeren Raums dazwischen ohne Reihenfolge zu beachten. Geometrien müssen vom gleichen Typ sein.",
    "bitbybit.jscad.path.createFromPoints": "aus Punkten",
    "createFromPoints": "aus Punkten",
    "bitbybit.jscad.path.createFromPoints_description": "Erstellt einen 2D-Pfad aus einer Liste von Punkten.",
    "Base.Point2[]": "Basis-Punkt-2-Array",
    "bitbybit.jscad.path.createPathsFromPoints": "Pfade aus Punkten",
    "createPathsFromPoints": "Pfade aus Punkten",
    "bitbybit.jscad.path.createPathsFromPoints_description": "Erstellt 2D-Pfade aus Listen von Punkten.",
    "pointsLists": "Punktelisten",
    "Base.Point3[][] | Base.Point2[][]": "Basis-Punkt-3- oder 2-Array",
    "bitbybit.jscad.path.createFromPolyline": "aus Polylinie",
    "createFromPolyline": "aus Polylinie",
    "bitbybit.jscad.path.createFromPolyline_description": "Erstellt einen 2D-Pfad aus einer Polylinie.",
    "bitbybit.jscad.path.createEmpty": "leer",
    "createEmpty": "leer",
    "bitbybit.jscad.path.createEmpty_description": "Erstellt leeren 2D-Pfad.",
    "bitbybit.jscad.path.close": "schließen",
    "close": "schließen",
    "bitbybit.jscad.path.close_description": "Schließt einen offenen 2D-Pfad.",
    "bitbybit.jscad.path.appendPoints": "Punkte anhängen",
    "appendPoints": "Punkte anhängen",
    "bitbybit.jscad.path.appendPoints_description": "Hängt 2D-Punkte an den Pfad an.",
    "append": "anhängen",
    "bitbybit.jscad.path.appendPolyline": "Polylinie anhängen",
    "appendPolyline": "Polylinie anhängen",
    "bitbybit.jscad.path.appendPolyline_description": "Hängt Polylinie an den Pfad an.",
    "bitbybit.jscad.path.appendArc": "Bogen anhängen",
    "appendArc": "Bogen anhängen",
    "bitbybit.jscad.path.appendArc_description": "Hängt den Bogen an den Pfad an.",
    "xAxisRotation": "X-Achsen-Rotation",
    "clockwise": "im Uhrzeigersinn",
    "large": "groß",
    "bitbybit.jscad.polygon.createFromPoints": "aus Punkten",
    "bitbybit.jscad.polygon.createFromPoints_description": "Erstellt ein 2D-Polygon aus einer Liste von Punkten.",
    "bitbybit.jscad.polygon.createFromPolyline": "aus Polylinie",
    "bitbybit.jscad.polygon.createFromPolyline_description": "Erstellt ein 2D-Polygon aus einer Polylinie.",
    "bitbybit.jscad.polygon.createFromCurve": "aus Kurve",
    "createFromCurve": "aus Kurve",
    "bitbybit.jscad.polygon.createFromCurve_description": "Erstellt ein 2D-Polygon aus einer Kurve.",
    "bitbybit.jscad.polygon.createFromPath": "aus Pfad",
    "createFromPath": "aus Pfad",
    "bitbybit.jscad.polygon.createFromPath_description": "Erstellt ein 2D-Polygon aus einem Pfad.",
    "bitbybit.jscad.polygon.circle": "Kreis",
    "bitbybit.jscad.polygon.circle_description": "Erstellt einen 2D-Polygon-Kreis.",
    "bitbybit.jscad.polygon.ellipse": "Ellipse",
    "ellipse": "Ellipse",
    "bitbybit.jscad.polygon.ellipse_description": "Erstellt eine 2D-Polygon-Ellipse.",
    "bitbybit.jscad.polygon.rectangle": "Rechteck",
    "rectangle": "Rechteck",
    "bitbybit.jscad.polygon.rectangle_description": "Erstellt ein 2D-Polygon-Rechteck.",
    "bitbybit.jscad.polygon.roundedRectangle": "gerundetes Rechteck",
    "roundedRectangle": "gerundetes Rechteck",
    "bitbybit.jscad.polygon.roundedRectangle_description": "Erstellt ein abgerundetes 2D-Rechteck.",
    "roundRadius": "Rundungsradius",
    "bitbybit.jscad.polygon.square": "Quadrat",
    "square": "Quadrat",
    "bitbybit.jscad.polygon.square_description": "Erstellt ein 2D-Polygon-Quadrat.",
    "bitbybit.jscad.polygon.star": "Stern",
    "star": "Stern",
    "bitbybit.jscad.polygon.star_description": "Erstellt einen 2D-Polygon-Stern.",
    "vertices": "Vertices",
    "bitbybit.jscad.shapes.cube": "Würfel",
    "cube": "Würfel",
    "bitbybit.jscad.shapes.cube_description": "Erstellt eine 3D-Würfelform.",
    "bitbybit.jscad.shapes.cubesOnCenterPoints": "Würfel auf Mittelpunkten",
    "cubesOnCenterPoints": "Würfel auf Mittelpunkten",
    "bitbybit.jscad.shapes.cubesOnCenterPoints_description": "Erstellt 3D-Würfel auf mehreren Mittelpunkten.",
    "primitives on centers": "Primitive auf Zentren",
    "bitbybit.jscad.shapes.cuboid": "Quader",
    "cuboid": "Quader",
    "bitbybit.jscad.shapes.cuboid_description": "Erstellt eine 3D-Quaderform.",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints": "Quader auf Mittelpunkten",
    "cuboidsOnCenterPoints": "Quader auf Mittelpunkten",
    "bitbybit.jscad.shapes.cuboidsOnCenterPoints_description": "Erstellt 3D-Quader auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.cylinderElliptic": "elliptischer Zylinder",
    "cylinderElliptic": "elliptischer Zylinder",
    "bitbybit.jscad.shapes.cylinderElliptic_description": "Erstellt einen elliptischen 3D-Zylinder-Volumenkörper.",
    "startRadius": "Startradius",
    "endRadius": "Endradius",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints": "elliptischer Zylinder auf Mittelpunkten",
    "cylinderEllipticOnCenterPoints": "elliptischer Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.cylinderEllipticOnCenterPoints_description": "Erstellt elliptische 3D-Zylinder auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.cylinder": "Zylinder",
    "cylinder": "Zylinder",
    "bitbybit.jscad.shapes.cylinder_description": "Erstellt einen 3D-Zylinder-Volumenkörper.",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints": "Zylinder auf Mittelpunkten",
    "cylindersOnCenterPoints": "Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.cylindersOnCenterPoints_description": "Erstellt 3D-Zylinder auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.ellipsoid": "Ellipsoid",
    "ellipsoid": "Ellipsoid",
    "bitbybit.jscad.shapes.ellipsoid_description": "Erstellt einen 3D-Ellipsoid-Volumenkörper.",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints": "Ellipsoide auf Mittelpunkten",
    "ellipsoidsOnCenterPoints": "Ellipsoide auf Mittelpunkten",
    "bitbybit.jscad.shapes.ellipsoidsOnCenterPoints_description": "Erstellt 3D-Ellipsoide auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.geodesicSphere": "geodätische Kugel",
    "geodesicSphere": "geodätische Kugel",
    "bitbybit.jscad.shapes.geodesicSphere_description": "Erstellt einen geodätischen 3D-Kugel-Volumenkörper.",
    "frequency": "Frequenz",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints": "geodätische Kugeln auf Mittelpunkten",
    "geodesicSpheresOnCenterPoints": "geodätische Kugeln auf Mittelpunkten",
    "bitbybit.jscad.shapes.geodesicSpheresOnCenterPoints_description": "Erstellt geodätische 3D-Kugeln auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.roundedCuboid": "gerundeter Quader",
    "roundedCuboid": "gerundeter Quader",
    "bitbybit.jscad.shapes.roundedCuboid_description": "Erstellt einen abgerundeten 3D-Quader-Volumenkörper.",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints": "gerundete Quader auf Mittelpunkten",
    "roundedCuboidsOnCenterPoints": "gerundete Quader auf Mittelpunkten",
    "bitbybit.jscad.shapes.roundedCuboidsOnCenterPoints_description": "Erstellt abgerundete 3D-Quader auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.roundedCylinder": "gerundeter Zylinder",
    "roundedCylinder": "gerundeter Zylinder",
    "bitbybit.jscad.shapes.roundedCylinder_description": "Erstellt einen abgerundeten 3D-Zylinder-Volumenkörper.",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints": "gerundete Zylinder auf Mittelpunkten",
    "roundedCylindersOnCenterPoints": "gerundete Zylinder auf Mittelpunkten",
    "bitbybit.jscad.shapes.roundedCylindersOnCenterPoints_description": "Erstellt abgerundete 3D-Zylinder auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.sphere": "Kugel",
    "sphere": "Kugel",
    "bitbybit.jscad.shapes.sphere_description": "Erstellt einen 3D-Kugel-Volumenkörper.",
    "bitbybit.jscad.shapes.spheresOnCenterPoints": "Kugeln auf Mittelpunkten",
    "spheresOnCenterPoints": "Kugeln auf Mittelpunkten",
    "bitbybit.jscad.shapes.spheresOnCenterPoints_description": "Erstellt eine 3D-Kugel auf mehreren Mittelpunkten.",
    "bitbybit.jscad.shapes.torus": "Torus",
    "torus": "Torus",
    "bitbybit.jscad.shapes.torus_description": "Erstellt einen 3D-Torus-Volumenkörper.",
    "innerSegments": "innere Segmente",
    "outerSegments": "äußere Segmente",
    "innerRotation": "innere Rotation",
    "outerRotation": "äußere Rotation",
    "bitbybit.jscad.shapes.fromPolygonPoints": "aus Polygonpunkten",
    "fromPolygonPoints": "aus Polygonpunkten",
    "bitbybit.jscad.shapes.fromPolygonPoints_description": "Erstellt eine 3D-Form aus Polygonpunkten, die verschachtelte Arrays von Punkten sein müssen.",
    "polygonPoints": "Polygonpunkte",
    "Base.Point3[][]": "Basis-Punkt-3-Array",
    "bitbybit.jscad.text.cylindricalText": "zylindrischer Text",
    "cylindricalText": "zylindrischer Text",
    "bitbybit.jscad.text.cylindricalText_description": "Erstellt einen Text, der auf dem Chain-Hulling von Zylindern basiert.",
    "extrusionHeight": "Extrusionshöhe",
    "extrusionSize": "Extrusionsgröße",
    "jscadTextAlignEnum": "JSCAD-Textausrichtungs-Enum",
    "bitbybit.jscad.text.sphericalText": "sphärischer Text",
    "sphericalText": "sphärischer Text",
    "bitbybit.jscad.text.sphericalText_description": "Erstellt einen Text, der auf dem Chain-Hulling von Kugeln basiert.",
    "bitbybit.jscad.text.createVectorText": "Vektortext",
    "createVectorText": "Vektortext",
    "bitbybit.jscad.text.createVectorText_description": "Erstellt einen Vektortext.",
    "bitbybit.jscad.colors.colorize": "einfärben",
    "colors": "Farben",
    "colorize": "einfärben",
    "bitbybit.jscad.colors.colorize_description": "Färbt Geometrie von JSCAD. Wenn Geometrie im Array ist, werden alle Elemente gefärbt und zurückgegeben. Wenn Geometrie ein einzelnes Element ist, wird ein einzelnes Element zurückgegeben. Beachten Sie, dass gefärbte Geometrie in JSCAD immer in dieser Farbe gezeichnet wird, selbst wenn Sie versuchen, sie über Zeichenoptionen zu ändern.",
    "bitbybit.manifold.manifoldToMeshPointer": "Mannigfaltigkeit zu Netzzeiger",
    "manifold": "Mannigfaltigkeit",
    "manifoldToMeshPointer": "Mannigfaltigkeit zu Netzzeiger",
    "bitbybit.manifold.manifoldToMeshPointer_description": "Wandelt Manifold-Form in einen Mesh-Pointer um, der im Speicher des Workers lebt. Dieser Pointer kann mit bitbybit.manifold.mesh Funktionen verwendet werden.",
    "meshing": "Vernetzung",
    "normalIdx": "Normalenindex",
    "bitbybit.manifold.decomposeManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt zerlegen",
    "decomposeManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt zerlegen",
    "bitbybit.manifold.decomposeManifoldOrCrossSection_description": "Zerlegt Manifold- oder CrossSection-Form in ein Mesh oder einfache Polygone.",
    "decompose": "zerlegen",
    "manifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte zerlegen",
    "decomposeManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte zerlegen",
    "bitbybit.manifold.decomposeManifoldsOrCrossSections_description": "Zerlegt Manifold- oder CrossSection-Form in ein Mesh oder einfache Polygone.",
    "manifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte",
    "bitbybit.manifold.deleteManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt löschen",
    "deleteManifoldOrCrossSection": "Mannigfaltigkeit oder Querschnitt löschen",
    "bitbybit.manifold.deleteManifoldOrCrossSection_description": "Löscht Manifold oder CrossSection aus dem Speicher.",
    "cleanup": "Bereinigung",
    "bitbybit.manifold.deleteManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte löschen",
    "deleteManifoldsOrCrossSections": "Mannigfaltigkeiten oder Querschnitte löschen",
    "bitbybit.manifold.deleteManifoldsOrCrossSections_description": "Löscht Manifolds oder CrossSections aus dem Speicher.",
    "bitbybit.manifold.manifold.manifoldToMesh": "Mannigfaltigkeit zu Netz",
    "manifoldToMesh": "Mannigfaltigkeit zu Netz",
    "bitbybit.manifold.manifold.manifoldToMesh_description": "Wandelt Manifold-Form in ein Mesh um.",
    "bitbybit.manifold.manifold.manifoldsToMeshes": "Mannigfaltigkeiten zu Netzen",
    "manifoldsToMeshes": "Mannigfaltigkeiten zu Netzen",
    "bitbybit.manifold.manifold.manifoldsToMeshes_description": "wandelt Mannigfaltigkeitsformen in Netze um",
    "manifolds": "Mannigfaltigkeiten",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh": "Mannigfaltigkeit aus Netz",
    "manifoldFromMesh": "Mannigfaltigkeit aus Netz",
    "bitbybit.manifold.manifold.shapes.manifoldFromMesh_description": "Konvertiert ein Mesh in ein Manifold, behält dessen Eigenschaften bei und verschmilzt nur die Positionen entsprechend den Merge-Vektoren. Wirft einen Fehler, wenn das Ergebnis kein orientiertes 2-Manifold ist. Kollabiert entartete Dreiecke und unnötige Vertices. Alle Felder werden gelesen, was diese Struktur geeignet macht für einen verlustfreien Round-Trip von Daten von manifoldToMesh(). Für Multi-Material-Eingabe verwenden Sie reserveIDs(), um eine eindeutige originalID für jedes Material zu setzen, und sortieren Sie die Materialien in Dreiecksläufe.",
    "DecomposedManifoldMeshDto": "zerlegtes Mannigfaltigkeitsnetz-DTO",
    "bitbybit.manifold.manifold.shapes.cube": "Würfel",
    "bitbybit.manifold.manifold.shapes.cube_description": "Erstellt eine 3D-Würfelform.",
    "bitbybit.manifold.manifold.shapes.sphere": "Kugel",
    "bitbybit.manifold.manifold.shapes.sphere_description": "Erstellt eine 3D-Kugelform.",
    "circularSegments": "kreisförmige Segmente",
    "bitbybit.manifold.manifold.shapes.tetrahedron": "Tetraeder",
    "tetrahedron": "Tetraeder",
    "bitbybit.manifold.manifold.shapes.tetrahedron_description": "Erstellt eine 3D-Tetraederform.",
    "bitbybit.manifold.manifold.shapes.cylinder": "Zylinder",
    "bitbybit.manifold.manifold.shapes.cylinder_description": "Erstellt eine 3D-Zylinderform.",
    "radiusLow": "niedriger Radius",
    "radiusHigh": "hoher Radius",
    "bitbybit.manifold.manifold.booleans.subtract": "subtrahieren",
    "bitbybit.manifold.manifold.booleans.subtract_description": "Subtrahiert zwei Manifold-Formen.",
    "a to b": "A zu B",
    "manifold1": "Mannigfaltigkeit 1",
    "manifold2": "Mannigfaltigkeit 2",
    "bitbybit.manifold.manifold.booleans.add": "hinzufügen",
    "bitbybit.manifold.manifold.booleans.add_description": "Addiert zwei Manifold-Formen.",
    "bitbybit.manifold.manifold.booleans.intersect": "sich schneiden",
    "bitbybit.manifold.manifold.booleans.intersect_description": "Schneidet zwei Manifold-Formen (Intersect).",
    "bitbybit.manifold.manifold.booleans.differenceTwo": "Differenz zwei",
    "differenceTwo": "Differenz zwei",
    "bitbybit.manifold.manifold.booleans.differenceTwo_description": "Differenz von zwei Mannigfaltigkeitsformen",
    "2 manifolds": "2 Mannigfaltigkeiten",
    "bitbybit.manifold.manifold.booleans.unionTwo": "Vereinigung zwei",
    "bitbybit.manifold.manifold.booleans.unionTwo_description": "Vereinigung von zwei Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.intersectionTwo": "Schnitt zwei",
    "intersectionTwo": "Schnitt zwei",
    "bitbybit.manifold.manifold.booleans.intersectionTwo_description": "Schnitt von zwei Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.difference": "Differenz",
    "bitbybit.manifold.manifold.booleans.difference_description": "Differenz von mehreren Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.union": "Vereinigung",
    "bitbybit.manifold.manifold.booleans.union_description": "Vereinigung von mehreren Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.intersection": "Schnitt",
    "bitbybit.manifold.manifold.booleans.intersection_description": "Schnitt von mehreren Mannigfaltigkeitsformen",
    "bitbybit.manifold.manifold.booleans.split": "teilen",
    "split": "teilen",
    "bitbybit.manifold.manifold.booleans.split_description": "Teilt Manifold durch ein anderes Manifold.",
    "manifoldToSplit": "zu teilende Mannigfaltigkeit",
    "manifoldCutter": "schneidende Mannigfaltigkeit",
    "bitbybit.manifold.manifold.booleans.splitByPlane": "durch Ebene teilen",
    "splitByPlane": "durch Ebene teilen",
    "bitbybit.manifold.manifold.booleans.splitByPlane_description": "Teilt Manifold durch Ebene.",
    "originOffset": "Ursprungsversatz",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets": "durch Ebene bei Versätzen teilen",
    "splitByPlaneOnOffsets": "durch Ebene bei Versätzen teilen",
    "bitbybit.manifold.manifold.booleans.splitByPlaneOnOffsets_description": "Teilt Manifold durch Ebene an verschiedenen Versätzen.",
    "originOffsets": "Ursprungsversätze",
    "bitbybit.manifold.manifold.booleans.trimByPlane": "durch Ebene beschneiden",
    "trimByPlane": "durch Ebene beschneiden",
    "bitbybit.manifold.manifold.booleans.trimByPlane_description": "Trimmt Manifold durch Ebene.",
    "trim": "beschneiden",
    "bitbybit.manifold.manifold.operations.hull": "Hülle",
    "bitbybit.manifold.manifold.operations.hull_description": "Berechnet konvexe Hülle der bereitgestellten Manifold-Form.",
    "bitbybit.manifold.manifold.operations.hullPoints": "Hüllpunkte",
    "hullPoints": "Hüllpunkte",
    "bitbybit.manifold.manifold.operations.hullPoints_description": "Hülle Punkte oder Manifolds.",
    "bitbybit.manifold.manifold.operations.slice": "schneiden",
    "bitbybit.manifold.manifold.operations.slice_description": "Gibt den Querschnitt dieses Objekts parallel zur X-Y-Ebene in der angegebenen Höhe zurück. Die Verwendung einer Höhe gleich dem Boden der Bounding Box gibt die unteren Flächen zurück, während eine Höhe gleich der Spitze der Bounding Box leer zurückgibt.",
    "cross sections": "Querschnitte",
    "bitbybit.manifold.manifold.operations.project": "projizieren",
    "bitbybit.manifold.manifold.operations.project_description": "Erstellt eine Projektion auf XY-Ebene aus dem Formumriss.",
    "bitbybit.manifold.manifold.operations.setTolerance": "Toleranz setzen",
    "setTolerance": "Toleranz setzen",
    "bitbybit.manifold.manifold.operations.setTolerance_description": "Gibt eine Kopie des Manifolds mit dem gesetzten Toleranzwert zurück. Dies führt Mesh-Vereinfachung durch, wenn der Toleranzwert erhöht wird.",
    "basic": "grundlegend",
    "bitbybit.manifold.manifold.operations.reserveIds": "IDs reservieren",
    "reserveIds": "IDs reservieren",
    "bitbybit.manifold.manifold.operations.reserveIds_description": "Gibt die erste von n sequenziellen neuen eindeutigen Mesh-IDs zurück, um Sätze von Dreiecken zu markieren, die nach weiteren Operationen nachgeschlagen werden können. Zuweisen an Mesh.runOriginalID Vektor.",
    "count": "Anzahl",
    "bitbybit.manifold.manifold.operations.asOriginal": "als Original",
    "asOriginal": "als Original",
    "bitbybit.manifold.manifold.operations.asOriginal_description": "Wenn Sie ein Manifold kopieren, aber möchten, dass diese neue Kopie neue Eigenschaften hat (z. B. ein anderes UV-Mapping), können Sie dessen IDs auf ein neues Original zurücksetzen, was bedeutet, dass es jetzt von seinen Nachkommen referenziert wird anstatt von den Meshes, aus denen es gebaut wurde, was es Ihnen ermöglicht, die Kopien zu unterscheiden, wenn Sie Ihre Eigenschaften auf das Endergebnis anwenden. Diese Funktion verdichtet auch alle koplanaren Flächen in der Beziehung und kollabiert diese Kanten. Wenn Sie inkonsistente Eigenschaften über diese Flächen hinweg haben möchten, d. h. Sie möchten einige dieser Kanten erhalten, sollten Sie stattdessen GetMesh() aufrufen, Ihre Eigenschaften berechnen und diese verwenden, um ein neues Manifold zu konstruieren.",
    "bitbybit.manifold.manifold.operations.compose": "zusammenstellen",
    "compose": "zusammenstellen",
    "bitbybit.manifold.manifold.operations.compose_description": "Konstruiert ein neues Manifold aus einer Liste anderer Manifolds. Dies ist eine rein topologische Operation, daher sollte darauf geachtet werden, überlappende Ergebnisse zu vermeiden. Es ist die Umkehroperation von Decompose().",
    "composition": "Zusammenstellung",
    "bitbybit.manifold.manifold.operations.decompose": "zerlegen",
    "bitbybit.manifold.manifold.operations.decompose_description": "Diese Operation gibt einen Vektor von Manifolds zurück, die topologisch unverbunden sind. Wenn alles verbunden ist, hat der Vektor die Länge eins und enthält eine Kopie des Originals. Es ist die Umkehroperation von Compose().",
    "bitbybit.manifold.manifold.operations.calculateNormals": "Normalen berechnen",
    "calculateNormals": "Normalen berechnen",
    "bitbybit.manifold.manifold.operations.calculateNormals_description": "Füllt Vertex-Eigenschaften für Normalenvektoren aus, berechnet aus der Mesh-Geometrie. Flache Flächen, die aus drei oder mehr Dreiecken bestehen, bleiben flach.",
    "adjustments": "Anpassungen",
    "minSharpAngle": "minimaler scharfer Winkel",
    "bitbybit.manifold.manifold.operations.calculateCurvature": "Krümmung berechnen",
    "calculateCurvature": "Krümmung berechnen",
    "bitbybit.manifold.manifold.operations.calculateCurvature_description": "Krümmung ist der Kehrwert des Krümmungsradius und so vorzeichenbehaftet, dass positiv konvex und negativ konkav ist. Es gibt zwei orthogonale Hauptkrümmungen an jedem Punkt auf einem Manifold, wobei eine maximal und die andere minimal ist. Gaußsche Krümmung ist ihr Produkt, während mittlere Krümmung ihre Summe ist. Dies nähert sie für jeden Vertex an und weist sie als Vertex-Eigenschaften auf den gegebenen Kanälen zu.",
    "gaussianIdx": "Gauß-Index",
    "meanIdx": "Mittelwert-Index",
    "bitbybit.manifold.manifold.operations.refineToTolerance": "auf Toleranz verfeinern",
    "refineToTolerance": "auf Toleranz verfeinern",
    "bitbybit.manifold.manifold.operations.refineToTolerance_description": "Erhöht die Dichte des Meshes, indem jede Kante in Stücke geteilt wird, so dass jeder Punkt auf den resultierenden Dreiecken grob innerhalb der Toleranz der durch die Tangentenvektoren definierten glatt gekrümmten Oberfläche liegt. Dies bedeutet, dass stark gekrümmte Bereiche feiner unterteilt werden als glattere Bereiche. Wenn keine halfedgeTangents vorhanden sind, ist das Ergebnis einfach eine Kopie des Originals. Quads ignorieren ihren inneren Dreiecks-Halbierenden.",
    "bitbybit.manifold.manifold.operations.refineToLength": "auf Länge verfeinern",
    "refineToLength": "auf Länge verfeinern",
    "bitbybit.manifold.manifold.operations.refineToLength_description": "Erhöht die Dichte des Meshes, indem jede Kante in Stücke von grob der Eingabelänge geteilt wird. Interne Vertices werden hinzugefügt, um den Rest der Triangulationskanten ebenfalls auf grob derselben Länge zu halten. Wenn halfedgeTangents vorhanden sind (z. B. vom Smooth()-Konstruktor), werden die neuen Vertices gemäß ihren baryzentrischen Koordinaten zur interpolierten Oberfläche bewegt.",
    "bitbybit.manifold.manifold.operations.refine": "verfeinern",
    "refine": "verfeinern",
    "bitbybit.manifold.manifold.operations.refine_description": "Erhöht die Dichte des Meshes, indem jede Kante in n Stücke geteilt wird. Zum Beispiel bei n = 2 wird jedes Dreieck in 4 Dreiecke geteilt. Diese sind alle koplanar (und werden nicht sofort kollabiert), es sei denn, das MeshManifold hat halfedgeTangents angegeben (z. B. vom Smooth()-Konstruktor), in diesem Fall werden die neuen Vertices gemäß ihren baryzentrischen Koordinaten zur interpolierten Oberfläche bewegt.",
    "bitbybit.manifold.manifold.operations.smoothOut": "glätten",
    "smoothOut": "glätten",
    "bitbybit.manifold.manifold.operations.smoothOut_description": "Glättet das Manifold aus, indem die halfedgeTangent-Vektoren ausgefüllt werden. Die Geometrie bleibt unverändert, bis Refine oder RefineToLength aufgerufen wird, um die Oberfläche zu interpolieren. Diese Version verwendet die Geometrie der Dreiecke und Pseudo-Normalen, um die Tangentenvektoren zu definieren.",
    "minSmoothness": "minimale Glätte",
    "bitbybit.manifold.manifold.operations.smoothByNormals": "nach Normalen glätten",
    "smoothByNormals": "nach Normalen glätten",
    "bitbybit.manifold.manifold.operations.smoothByNormals_description": "Glättet das Manifold aus, indem die halfedgeTangent-Vektoren ausgefüllt werden. Die Geometrie bleibt unverändert, bis Refine oder RefineToLength aufgerufen wird, um die Oberfläche zu interpolieren. Diese Version verwendet die bereitgestellten Vertex-Normalen-Eigenschaften, um die Tangentenvektoren zu definieren.",
    "bitbybit.manifold.manifold.transforms.scale3D": "3D skalieren",
    "scale3D": "3D skalieren",
    "bitbybit.manifold.manifold.transforms.scale3D_description": "Skaliert eine Manifold-Form mit 3D-Vektor.",
    "bitbybit.manifold.manifold.transforms.scale": "skalieren",
    "bitbybit.manifold.manifold.transforms.scale_description": "Skaliert eine Manifold-Form mit Einzelfaktor.",
    "bitbybit.manifold.manifold.transforms.mirror": "spiegeln",
    "bitbybit.manifold.manifold.transforms.mirror_description": "Spiegelt eine Manifold-Form über eine durch einen Normalenvektor definierte Ebene.",
    "bitbybit.manifold.manifold.transforms.translate": "verschieben",
    "bitbybit.manifold.manifold.transforms.translate_description": "Verschiebt eine Manifold-Form entlang des Vektors.",
    "bitbybit.manifold.manifold.transforms.translateByVectors": "nach Vektoren verschieben",
    "translateByVectors": "nach Vektoren verschieben",
    "bitbybit.manifold.manifold.transforms.translateByVectors_description": "Verschiebt eine Manifold-Form entlang mehrerer Vektoren.",
    "bitbybit.manifold.manifold.transforms.translateXYZ": "XYZ verschieben",
    "translateXYZ": "XYZ verschieben",
    "bitbybit.manifold.manifold.transforms.translateXYZ_description": "Verschiebt eine Manifold-Form entlang X, Y, Z.",
    "bitbybit.manifold.manifold.transforms.rotate": "drehen",
    "bitbybit.manifold.manifold.transforms.rotate_description": "Rotiert eine Manifold-Form entlang des Vektors, der Euler-Winkel enthält.",
    "bitbybit.manifold.manifold.transforms.rotateXYZ": "XYZ drehen",
    "rotateXYZ": "XYZ drehen",
    "bitbybit.manifold.manifold.transforms.rotateXYZ_description": "Rotiert eine Manifold-Form entlang der X Y Z Euler-Winkel.",
    "bitbybit.manifold.manifold.transforms.transform": "transformieren",
    "bitbybit.manifold.manifold.transforms.transform_description": "Transformiert eine Manifold-Form unter Verwendung der 4x4 Transformationsmatrix.",
    "matrix": "Matrix",
    "Base.TransformMatrix": "Basis-Transformationsmatrix",
    "bitbybit.manifold.manifold.transforms.transforms": "Transformationen",
    "bitbybit.manifold.manifold.transforms.transforms_description": "Transformiert eine Manifold-Form unter Verwendung der 4x4 Transformationsmatrizen.",
    "bitbybit.manifold.manifold.evaluate.surfaceArea": "Oberflächeninhalt",
    "evaluate": "auswerten",
    "surfaceArea": "Oberflächeninhalt",
    "bitbybit.manifold.manifold.evaluate.surfaceArea_description": "Ruft Oberfläche von Manifold ab.",
    "bitbybit.manifold.manifold.evaluate.volume": "Volumen",
    "volume": "Volumen",
    "bitbybit.manifold.manifold.evaluate.volume_description": "Ruft Volumen von Manifold ab.",
    "bitbybit.manifold.manifold.evaluate.isEmpty": "ist leer",
    "isEmpty": "ist leer",
    "bitbybit.manifold.manifold.evaluate.isEmpty_description": "Prüft, ob Manifold Dreiecke enthält.",
    "bitbybit.manifold.manifold.evaluate.numVert": "Anzahl Vertices",
    "numVert": "Anzahl Vertices",
    "bitbybit.manifold.manifold.evaluate.numVert_description": "Ruft Anzahl der Vertices im Manifold ab.",
    "bitbybit.manifold.manifold.evaluate.numTri": "Anzahl Dreiecke",
    "numTri": "Anzahl Dreiecke",
    "bitbybit.manifold.manifold.evaluate.numTri_description": "Ruft Anzahl der Dreiecke im Manifold ab.",
    "bitbybit.manifold.manifold.evaluate.numEdge": "Anzahl Kanten",
    "numEdge": "Anzahl Kanten",
    "bitbybit.manifold.manifold.evaluate.numEdge_description": "Ruft Anzahl der Kanten im Manifold ab.",
    "bitbybit.manifold.manifold.evaluate.numProp": "Anzahl Eigenschaften",
    "numProp": "Anzahl Eigenschaften",
    "bitbybit.manifold.manifold.evaluate.numProp_description": "Ruft Anzahl der Eigenschaften im Manifold ab.",
    "bitbybit.manifold.manifold.evaluate.numPropVert": "Anzahl Eigenschaftsvertices",
    "numPropVert": "Anzahl Eigenschaftsvertices",
    "bitbybit.manifold.manifold.evaluate.numPropVert_description": "Die Anzahl der Eigenschafts-Vertices im Manifold. Dies ist immer >= numVert, da einige physikalische Vertices dupliziert sein können, um unterschiedliche Eigenschaften an verschiedenen benachbarten Dreiecken zu berücksichtigen.",
    "bitbybit.manifold.manifold.evaluate.boundingBox": "Begrenzungsbox",
    "boundingBox": "Begrenzungsbox",
    "bitbybit.manifold.manifold.evaluate.boundingBox_description": "Gibt den achsenausgerichteten Begrenzungsrahmen aller Vertices des Manifolds zurück.",
    "bitbybit.manifold.manifold.evaluate.tolerance": "Toleranz",
    "bitbybit.manifold.manifold.evaluate.tolerance_description": "Gibt die Toleranz der Vertices dieses Manifolds zurück, die den ungefähren Rundungsfehler über alle Transformationen und Operationen verfolgt, die zu diesem Zustand geführt haben. Alle Dreiecke, die innerhalb dieser Toleranz kollinear sind, gelten als entartet und werden entfernt.",
    "bitbybit.manifold.manifold.evaluate.genus": "Gattung",
    "genus": "Gattung",
    "bitbybit.manifold.manifold.evaluate.genus_description": "Das Genus (Geschlecht) ist eine topologische Eigenschaft des Manifolds, die die Anzahl der Henkel darstellt. Eine Kugel ist 0, Torus 1, usw. Es ist nur sinnvoll für ein einzelnes Mesh, daher ist es am besten, zuerst Decompose() aufzurufen.",
    "bitbybit.manifold.manifold.evaluate.minGap": "minimaler Abstand",
    "minGap": "minimaler Abstand",
    "bitbybit.manifold.manifold.evaluate.minGap_description": "Gibt die minimale Lücke zwischen zwei Manifolds zurück. Gibt einen Float zwischen 0 und searchLength zurück.",
    "searchLength": "Suchlänge",
    "bitbybit.manifold.manifold.evaluate.originalID": "ursprüngliche ID",
    "originalID": "ursprüngliche ID",
    "bitbybit.manifold.manifold.evaluate.originalID_description": "Wenn dieses Mesh ein Original ist, gibt dies seine ID zurück, die von Produkt-Manifolds referenziert werden kann. Wenn dieses Manifold ein Produkt ist, gibt dies -1 zurück.",
    "bitbybit.manifold.crossSection.crossSectionToPolygons": "Querschnitt zu Polygonen",
    "crossSection": "Querschnitt",
    "crossSectionToPolygons": "Querschnitt zu Polygonen",
    "bitbybit.manifold.crossSection.crossSectionToPolygons_description": "wandelt einen Querschnitt in Polygone um",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons": "Querschnitte zu Polygonen",
    "crossSectionsToPolygons": "Querschnitte zu Polygonen",
    "bitbybit.manifold.crossSection.crossSectionsToPolygons_description": "wandelt Querschnitte in Polygone um",
    "crossSections": "Querschnitte",
    "bitbybit.manifold.crossSection.shapes.create": "erstellen",
    "bitbybit.manifold.crossSection.shapes.create_description": "Erstellt einen 2D-Querschnitt (CrossSection) aus einem Satz von Konturen (komplexe Polygone). Eine boolesche Vereinigungsoperation (Standardmäßig mit positiver Füllregel) wird durchgeführt, um überlappende Polygone zu kombinieren und sicherzustellen, dass die resultierende CrossSection frei von Überschneidungen ist.",
    "Base.Vector2[][]": "Basis-Vektor-2-Array",
    "fillRule": "Füllregel",
    "fillRuleEnum": "Füllregel-Enum",
    "bitbybit.manifold.crossSection.shapes.square": "Quadrat",
    "bitbybit.manifold.crossSection.shapes.square_description": "Erstellt einen quadratischen 2D-Querschnitt.",
    "bitbybit.manifold.crossSection.shapes.circle": "Kreis",
    "bitbybit.manifold.crossSection.shapes.circle_description": "Erstellt einen kreisförmigen 2D-Querschnitt.",
    "bitbybit.manifold.crossSection.shapes.rectangle": "Rechteck",
    "bitbybit.manifold.crossSection.shapes.rectangle_description": "Erstellt einen rechteckigen 2D-Querschnitt.",
    "bitbybit.manifold.crossSection.operations.hull": "Hülle",
    "bitbybit.manifold.crossSection.operations.hull_description": "Berechnet konvexe Hülle für den Querschnitt.",
    "bitbybit.manifold.crossSection.operations.extrude": "extrudieren",
    "bitbybit.manifold.crossSection.operations.extrude_description": "Extrudiert den Querschnitt, um eine 3D-Form zu erstellen.",
    "nDivisions": "Anzahl Teilungen",
    "twistDegrees": "Verdrehungsgrade",
    "scaleTopX": "Skalierung oben X",
    "scaleTopY": "Skalierung oben Y",
    "bitbybit.manifold.crossSection.operations.revolve": "rotieren",
    "bitbybit.manifold.crossSection.operations.revolve_description": "Rotiert den Querschnitt, um eine 3D-Form zu erstellen.",
    "revolveDegrees": "Rotationsgrade",
    "matchProfile": "Profil anpassen",
    "bitbybit.manifold.crossSection.operations.offset": "Versatz",
    "bitbybit.manifold.crossSection.operations.offset_description": "Versetzt den Querschnitt, um einen neuen Querschnitt mit einem gegebenen Delta zu erstellen (verwendet Clipper2-Algorithmus dahinter).",
    "manifoldJoinTypeEnum": "Mannigfaltigkeits-Verbindungstyp-Enum",
    "miterLimit": "Gehrungslimit",
    "bitbybit.manifold.crossSection.operations.simplify": "vereinfachen",
    "simplify": "vereinfachen",
    "bitbybit.manifold.crossSection.operations.simplify_description": "Entfernt Vertices aus den Konturen in dieser CrossSection, die weniger als den angegebenen Abstand Epsilon von einer imaginären Linie entfernt sind, die durch ihre zwei benachbarten Vertices verläuft. Nahezu doppelte Vertices und kollineare Punkte werden bei niedrigeren Epsilons entfernt, wobei die Eliminierung von Liniensegmenten bei größeren Epsilons zunehmend aggressiver wird. Es wird empfohlen, diese Funktion nach Offset anzuwenden, um eventuelle störende winzige Liniensegmente zu bereinigen, die eingeführt wurden und Offset-Operationen nicht verbessern würden, was das Problem verschärfen würde.",
    "epsilon": "Epsilon",
    "bitbybit.manifold.crossSection.operations.compose": "zusammenstellen",
    "bitbybit.manifold.crossSection.operations.compose_description": "Setzt mehrere Querschnitte oder Polygone zu einem einzigen Querschnitt zusammen.",
    "bitbybit.manifold.crossSection.operations.decompose": "zerlegen",
    "bitbybit.manifold.crossSection.operations.decompose_description": "Zerlegt Querschnitte, die topologisch unverbunden sind, wobei jeder eine Umrisskontur mit null oder mehr Löchern enthält.",
    "bitbybit.manifold.crossSection.booleans.subtract": "subtrahieren",
    "bitbybit.manifold.crossSection.booleans.subtract_description": "Subtrahiert zwei Querschnitte.",
    "crossSection1": "Querschnitt 1",
    "crossSection2": "Querschnitt 2",
    "bitbybit.manifold.crossSection.booleans.add": "hinzufügen",
    "bitbybit.manifold.crossSection.booleans.add_description": "Addiert zwei Querschnitte.",
    "bitbybit.manifold.crossSection.booleans.intersect": "sich schneiden",
    "bitbybit.manifold.crossSection.booleans.intersect_description": "Schneidet zwei Querschnitte.",
    "bitbybit.manifold.crossSection.booleans.differenceTwo": "Differenz zwei",
    "bitbybit.manifold.crossSection.booleans.differenceTwo_description": "Differenz von zwei Querschnitten",
    "2 cross sections": "2 Querschnitte",
    "bitbybit.manifold.crossSection.booleans.unionTwo": "Vereinigung zwei",
    "bitbybit.manifold.crossSection.booleans.unionTwo_description": "Vereinigung von zwei Querschnitten",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo": "Schnitt zwei",
    "bitbybit.manifold.crossSection.booleans.intersectionTwo_description": "Schnitt von zwei Querschnitten",
    "bitbybit.manifold.crossSection.booleans.difference": "Differenz",
    "bitbybit.manifold.crossSection.booleans.difference_description": "Differenz von mehreren Querschnitten",
    "bitbybit.manifold.crossSection.booleans.union": "Vereinigung",
    "bitbybit.manifold.crossSection.booleans.union_description": "Vereinigung von mehreren Querschnitten",
    "bitbybit.manifold.crossSection.booleans.intersection": "Schnitt",
    "bitbybit.manifold.crossSection.booleans.intersection_description": "Schnitt von mehreren Querschnitten",
    "bitbybit.manifold.crossSection.transforms.scale2D": "2D skalieren",
    "scale2D": "2D skalieren",
    "bitbybit.manifold.crossSection.transforms.scale2D_description": "Skaliert eine Querschnittsform mit 2D-Vektor.",
    "bitbybit.manifold.crossSection.transforms.scale": "skalieren",
    "bitbybit.manifold.crossSection.transforms.scale_description": "Skaliert eine Querschnittsform mit Einzelfaktor.",
    "bitbybit.manifold.crossSection.transforms.mirror": "spiegeln",
    "bitbybit.manifold.crossSection.transforms.mirror_description": "Spiegelt eine Querschnittsform über eine durch einen Normalenvektor definierte Ebene.",
    "bitbybit.manifold.crossSection.transforms.translate": "verschieben",
    "bitbybit.manifold.crossSection.transforms.translate_description": "Verschiebt eine Querschnittsform entlang des Vektors.",
    "bitbybit.manifold.crossSection.transforms.translateXY": "XY verschieben",
    "translateXY": "XY verschieben",
    "bitbybit.manifold.crossSection.transforms.translateXY_description": "Verschiebt eine Querschnittsform entlang X, Y.",
    "bitbybit.manifold.crossSection.transforms.rotate": "drehen",
    "bitbybit.manifold.crossSection.transforms.rotate_description": "Rotiert eine Querschnittsform entlang der enthaltenen Grade.",
    "degrees": "Grade",
    "bitbybit.manifold.crossSection.transforms.transform": "transformieren",
    "bitbybit.manifold.crossSection.transforms.transform_description": "Transformiert eine Querschnittsform unter Verwendung der 3x3 Transformationsmatrix.",
    "Base.TransformMatrix3x3": "Basis-Transformationsmatrix 3x3",
    "bitbybit.manifold.crossSection.evaluate.area": "Fläche",
    "area": "Fläche",
    "bitbybit.manifold.crossSection.evaluate.area_description": "Ruft Fläche des Querschnitts ab.",
    "bitbybit.manifold.crossSection.evaluate.isEmpty": "ist leer",
    "bitbybit.manifold.crossSection.evaluate.isEmpty_description": "Prüft, ob Querschnitt leer ist.",
    "bitbybit.manifold.crossSection.evaluate.numVert": "Anzahl Vertices",
    "bitbybit.manifold.crossSection.evaluate.numVert_description": "Ruft Anzahl der Vertices im Querschnitt ab.",
    "bitbybit.manifold.crossSection.evaluate.numContour": "Anzahl Konturen",
    "numContour": "Anzahl Konturen",
    "bitbybit.manifold.crossSection.evaluate.numContour_description": "Ruft Anzahl der Konturen im Querschnitt ab.",
    "bitbybit.manifold.crossSection.evaluate.bounds": "Grenzen",
    "bounds": "Grenzen",
    "bitbybit.manifold.crossSection.evaluate.bounds_description": "Ruft die Grenzen der Kontur als Rechteck ab. Die Ausgabe erfolgt in zwei vec2-Punkten im Array. Das erste Array ist der Min-Punkt und das zweite Array ist der Max-Punkt.",
    "bitbybit.manifold.mesh.operations.merge": "zusammenführen",
    "merge": "zusammenführen",
    "bitbybit.manifold.mesh.operations.merge_description": "Aktualisiert die mergeFromVert und mergeToVert Vektoren, um einen Manifold-Volumenkörper zu erstellen. Wenn das MeshGL bereits Manifold ist, erfolgt keine Änderung und die Funktion gibt false zurück. Andernfalls werden Vertices entlang offener Kanten innerhalb der Toleranz (das Maximum der MeshGL-Toleranz und der Baseline-Bounding-Box-Toleranz) verschmolzen, wobei alle aus den vorhandenen Merge-Vektoren beibehalten werden. Es gibt keine Garantie, dass das Ergebnis Manifold ist - dies ist eine Best-Effort-Hilfsfunktion, die hauptsächlich dazu gedacht ist, in dem Fall zu helfen, in dem ein Manifold-Multi-Material-MeshGL produziert wurde, aber seine Merge-Vektoren aufgrund eines Round-Trips durch ein Dateiformat verloren gingen. Das Konstruieren eines Manifolds aus dem Ergebnis meldet einen Status, wenn es nicht Manifold ist.",
    "bitbybit.manifold.mesh.evaluate.position": "Position",
    "bitbybit.manifold.mesh.evaluate.position_description": "Ruft Position am Mesh-Vertex-Index ab.",
    "vertexIndex": "Vertex-Index",
    "bitbybit.manifold.mesh.evaluate.verts": "Vertices",
    "verts": "Vertices",
    "bitbybit.manifold.mesh.evaluate.verts_description": "Ruft die drei Vertex-Indizes dieses Dreiecks in CCW-Reihenfolge ab.",
    "triangleIndex": "Dreiecksindex",
    "bitbybit.manifold.mesh.evaluate.tangent": "Tangente",
    "tangent": "Tangente",
    "bitbybit.manifold.mesh.evaluate.tangent_description": "Ruft den Tangentenvektor ab, der bei verts(tri)[j] beginnt und zum nächsten Bezier-Punkt entlang der CCW-Kante zeigt. Der vierte Wert ist sein Gewicht.",
    "halfEdgeIndex": "Halbkantenindex",
    "bitbybit.manifold.mesh.evaluate.extras": "Extras",
    "extras": "Extras",
    "bitbybit.manifold.mesh.evaluate.extras_description": "Ruft alle anderen Eigenschaften ab, die diesem Vertex zugeordnet sind.",
    "bitbybit.manifold.mesh.evaluate.transform": "Transformation",
    "bitbybit.manifold.mesh.evaluate.transform_description": "Ruft die spaltenweise 4x4-Matrix-Transformation vom ursprünglichen Mesh zu diesen zugehörigen Dreiecken ab.",
    "bitbybit.manifold.mesh.evaluate.numProp": "Anzahl Eigenschaften",
    "bitbybit.manifold.mesh.evaluate.numProp_description": "Anzahl der Eigenschaften pro Vertex, immer >= 3.",
    "bitbybit.manifold.mesh.evaluate.numVert": "Anzahl Vertices",
    "bitbybit.manifold.mesh.evaluate.numVert_description": "Anzahl der Eigenschafts-Vertices.",
    "bitbybit.manifold.mesh.evaluate.numTri": "Anzahl Dreiecke",
    "bitbybit.manifold.mesh.evaluate.numTri_description": "Ruft Anzahl der Dreiecke auf Mesh ab.",
    "bitbybit.manifold.mesh.evaluate.numRun": "Anzahl Läufe",
    "numRun": "Anzahl Läufe",
    "bitbybit.manifold.mesh.evaluate.numRun_description": "Anzahl der Dreiecksläufe. Jeder Dreieckslauf ist ein Satz aufeinanderfolgender Dreiecke, die alle aus derselben Instanz desselben Eingabemeshes stammen.",
    "bitbybit.logic.boolean": "boolesch",
    "logic": "Logik",
    "bitbybit.logic.boolean_description": "Erstellt und gibt einen booleschen Wert zurück (Durchleitung für boolesche Eingabe). Beispiel: true → true, false → false",
    "bitbybit.logic.randomBooleans": "zufällige Booleans",
    "randomBooleans": "zufällige Booleans",
    "bitbybit.logic.randomBooleans_description": "Generiert eine zufällige boolesche Liste, wobei jeder Wert eine Schwellenwahrscheinlichkeit hat, wahr zu sein. Beispiel: Länge=5, Schwellenwert=0.7 → könnte [true, true, false, true, true] erzeugen",
    "trueThreshold": "Schwellenwert für wahr",
    "bitbybit.logic.twoThresholdRandomGradient": "zweischwelliger Zufallsgradient",
    "twoThresholdRandomGradient": "zweischwelliger Zufallsgradient",
    "bitbybit.logic.twoThresholdRandomGradient_description": "Konvertiert Zahlen in Booleans unter Verwendung von zwei Schwellenwerten mit Gradientenrandomisierung dazwischen. Werte unter trueThreshold → immer true, über falseThreshold → immer false. Zwischen Schwellenwerten → Wahrscheinlichkeitsgradient (näher am false-Schwellenwert = höhere Chance auf false). Beispiel: [0.1, 0.4, 0.6, 0.9] mit Schwellenwerten [0.3, 0.7] → [true, gradient, gradient, false]",
    "numbers": "Zahlen",
    "thresholdTotalTrue": "Schwellenwert gesamt wahr",
    "thresholdTotalFalse": "Schwellenwert gesamt falsch",
    "nrLevels": "Anzahl Ebenen",
    "bitbybit.logic.thresholdBooleanList": "Schwellenwert-Boolean-Liste",
    "thresholdBooleanList": "Schwellenwert-Boolean-Liste",
    "bitbybit.logic.thresholdBooleanList_description": "Konvertiert Zahlen in Booleans basierend auf einem Schwellenwert (unter Schwellenwert → true, darüber → false). Kann invertiert werden, um die Logik umzukehren. Beispiel: [0.3, 0.7, 0.5] mit Schwellenwert=0.6 → [true, false, true]",
    "threshold": "Schwellenwert",
    "bitbybit.logic.thresholdGapsBooleanList": "Schwellenwert-Lücken-Boolean-Liste",
    "thresholdGapsBooleanList": "Schwellenwert-Lücken-Boolean-Liste",
    "bitbybit.logic.thresholdGapsBooleanList_description": "Konvertiert Zahlen in Booleans unter Verwendung mehrerer Bereichsschwellenwerte (Lücken definieren wahre Bereiche). Werte innerhalb eines Lückenbereichs → true, außerhalb aller Lücken → false. Kann invertiert werden. Beispiel: [0.2, 0.5, 0.8] mit Lücken [[0.3, 0.6], [0.7, 0.9]] → [false, true, true]",
    "gapThresholds": "Lücken-Schwellenwerte",
    "Base.Vector2[]": "Basis-Vektor-2-Array",
    "bitbybit.logic.not": "nicht",
    "not": "nicht",
    "bitbybit.logic.not_description": "Wendet NOT-Operator an, um einen booleschen Wert umzukehren. Beispiel: true → false, false → true",
    "bitbybit.logic.notList": "Nicht-Liste",
    "notList": "Nicht-Liste",
    "bitbybit.logic.notList_description": "Wendet NOT-Operator an, um alle booleschen Werte in einer Liste umzukehren. Beispiel: [true, false, true] → [false, true, false]",
    "bitbybit.logic.compare": "vergleichen",
    "compare": "vergleichen",
    "bitbybit.logic.compare_description": "Vergleicht zwei Werte unter Verwendung verschiedener Operatoren (==, !=, ===, !==, <, <=, >, >=). Beispiel: 5 > 3 → true, 'hallo' === 'welt' → false",
    "operator": "Operator",
    "BooleanOperatorsEnum": "Boolean-Operatoren-Enum",
    "bitbybit.logic.valueGate": "Werttor",
    "valueGate": "Werttor",
    "bitbybit.logic.valueGate_description": "Leitet einen Wert bedingt weiter, wenn Boolean wahr ist, andernfalls wird undefined zurückgegeben. Beispiel: Wert=42, Boolean=true → 42, Wert=42, Boolean=false → undefined",
    "bitbybit.logic.firstDefinedValueGate": "erstes definiertes Werttor",
    "firstDefinedValueGate": "erstes definiertes Werttor",
    "bitbybit.logic.firstDefinedValueGate_description": "Gibt den ersten definierten (nicht-undefined) Wert aus zwei Optionen zurück (Fallback-Muster). Beispiel: Wert1=42, Wert2=10 → 42, Wert1=undefined, Wert2=10 → 10",
    "value1": "Wert 1",
    "value2": "Wert 2",
    "bitbybit.math.number": "Zahl",
    "math": "Mathematik",
    "bitbybit.math.number_description": "Erstellt und gibt einen Zahlenwert zurück (Durchleitung für Zahleneingabe). Beispiel: Eingabe 42 → 42, Eingabe 3.14 → 3.14",
    "bitbybit.math.twoNrOperation": "Zwei-Zahlen-Operation",
    "twoNrOperation": "Zwei-Zahlen-Operation",
    "bitbybit.math.twoNrOperation_description": "Führt grundlegende arithmetische Operationen an zwei Zahlen durch (Addieren, Subtrahieren, Multiplizieren, Dividieren, Potenzieren, Modulus). Beispiel: 5 + 3 → 8, 10 % 3 → 1, 2 ^ 3 → 8",
    "operation": "Operation",
    "mathTwoNrOperatorEnum": "Mathematik-Zwei-Zahlen-Operator-Enum",
    "bitbybit.math.modulus": "Modulus",
    "modulus": "Modulus",
    "bitbybit.math.modulus_description": "Berechnet den Rest nach Division (Modulus-Operation). Beispiel: 10 % 3 → 1, 17 % 5 → 2",
    "bitbybit.math.roundToDecimals": "auf Dezimalstellen runden",
    "roundToDecimals": "auf Dezimalstellen runden",
    "bitbybit.math.roundToDecimals_description": "Rundet eine Zahl auf angegebene Dezimalstellen. Beispiel: 1.32156 mit 3 Dezimalstellen ergibt 1.322",
    "decimalPlaces": "Dezimalstellen",
    "bitbybit.math.oneNrOperation": "Ein-Zahl-Operation",
    "oneNrOperation": "Ein-Zahl-Operation",
    "bitbybit.math.oneNrOperation_description": "Führt mathematische Operationen an einer einzelnen Zahl durch (Absolutwert, Negieren, Wurzel, trig. Funktionen, Logarithmen usw.). Beispiel: sqrt(5) → 2.236, abs(-3) → 3, sin(π2) → 1",
    "mathOneNrOperatorEnum": "Mathematik-Ein-Zahl-Operator-Enum",
    "bitbybit.math.remap": "umskalieren",
    "remap": "umskalieren",
    "bitbybit.math.remap_description": "Bildet eine Zahl proportional von einem Bereich auf einen anderen ab. Beispiel: 5 von [0,10] auf [0,100] → 50, 0.5 von [0,1] auf [-10,10] → 0",
    "fromLow": "von niedrig",
    "fromHigh": "von hoch",
    "toLow": "nach niedrig",
    "toHigh": "nach hoch",
    "bitbybit.math.random": "zufällig",
    "random": "zufällig",
    "bitbybit.math.random_description": "Generiert eine zufällige Dezimalzahl zwischen 0 (inklusive) und 1 (exklusiv). Beispiel: Ausgaben wie 0.342, 0.891 oder jeder Wert in [0, 1)",
    "generate": "generieren",
    "bitbybit.math.randomNumber": "Zufallszahl",
    "randomNumber": "Zufallszahl",
    "bitbybit.math.randomNumber_description": "Generiert eine zufällige Zahl innerhalb eines angegebenen Bereichs (niedrig bis hoch). Beispiel: Bereich [0, 10] → Ausgaben wie 3.7, 8.2 oder jeder Wert zwischen 0 und 10",
    "low": "niedrig",
    "high": "hoch",
    "bitbybit.math.randomNumbers": "Zufallszahlen",
    "randomNumbers": "Zufallszahlen",
    "bitbybit.math.randomNumbers_description": "Generiert mehrere zufällige Zahlen innerhalb eines angegebenen Bereichs. Beispiel: Bereich [0, 10] mit 3 Elementen → [2.5, 7.1, 4.8]",
    "bitbybit.math.pi": "Pi",
    "pi": "Pi",
    "bitbybit.math.pi_description": "Gibt die mathematische Konstante π (Pi) ≈ 3.14159 zurück. Beispiel: Gibt 3.141592653589793 aus",
    "bitbybit.math.toFixed": "auf festgelegte Dezimalstellen",
    "toFixed": "auf festgelegte Dezimalstellen",
    "bitbybit.math.toFixed_description": "Formatiert eine Zahl als String mit einer festen Anzahl von Dezimalstellen (zeigt immer nachgestellte Nullen an). Beispiel: 3.14159 mit 2 Dezimalstellen → '3.14', 5 mit 3 Dezimalstellen → '5.000'",
    "bitbybit.math.add": "addieren",
    "bitbybit.math.add_description": "Addiert zwei Zahlen zusammen. Beispiel: 5 + 3 → 8, -2 + 7 → 5",
    "basics": "Grundlagen",
    "bitbybit.math.subtract": "subtrahieren",
    "bitbybit.math.subtract_description": "Subtrahiert die zweite Zahl von der ersten. Beispiel: 10 - 3 → 7, 5 - 8 → -3",
    "bitbybit.math.multiply": "multiplizieren",
    "bitbybit.math.multiply_description": "Multipliziert zwei Zahlen miteinander. Beispiel: 5 × 3 → 15, -2 × 4 → -8",
    "bitbybit.math.divide": "dividieren",
    "divide": "dividieren",
    "bitbybit.math.divide_description": "Dividiert die erste Zahl durch die zweite. Beispiel: 10 ÷ 2 → 5, 7 ÷ 2 → 3.5",
    "bitbybit.math.power": "potenzieren",
    "power": "potenzieren",
    "bitbybit.math.power_description": "Erhebt die erste Zahl zur Potenz der zweiten (Exponentiation). Beispiel: 2³ → 8, 5² → 25, 10⁻¹ → 0.1",
    "bitbybit.math.sqrt": "Quadratwurzel",
    "sqrt": "Quadratwurzel",
    "bitbybit.math.sqrt_description": "Berechnet die Quadratwurzel einer Zahl. Beispiel: √9 → 3, √2 → 1.414, √16 → 4",
    "bitbybit.math.abs": "absolut",
    "abs": "absolut",
    "bitbybit.math.abs_description": "Gibt den Absolutwert zurück (entfernt negatives Vorzeichen, immer positiv oder Null). Beispiel: |-5| → 5, |3| → 3, |0| → 0",
    "bitbybit.math.round": "runden",
    "round": "runden",
    "bitbybit.math.round_description": "Rundet eine Zahl auf die nächste ganze Zahl. Beispiel: 3.7 → 4, 2.3 → 2, 5.5 → 6",
    "bitbybit.math.floor": "abrunden",
    "floor": "abrunden",
    "bitbybit.math.floor_description": "Rundet eine Zahl ab auf die nächste ganze Zahl (gegen negative Unendlichkeit). Beispiel: 3.7 → 3, -2.3 → -3, 5 → 5",
    "bitbybit.math.ceil": "aufrunden",
    "ceil": "aufrunden",
    "bitbybit.math.ceil_description": "Rundet eine Zahl auf auf die nächste ganze Zahl (gegen positive Unendlichkeit). Beispiel: 3.2 → 4, -2.8 → -2, 5 → 5",
    "bitbybit.math.negate": "negieren",
    "negate": "negieren",
    "bitbybit.math.negate_description": "Negiert eine Zahl (kehrt ihr Vorzeichen um: positiv wird negativ, negativ wird positiv). Beispiel: 5 → -5, -3 → 3, 0 → 0",
    "bitbybit.math.ln": "natürlicher Logarithmus",
    "ln": "natürlicher Logarithmus",
    "bitbybit.math.ln_description": "Berechnet den natürlichen Logarithmus (Basis e) einer Zahl. Beispiel: ln(2.718) → ~1, ln(7.389) → ~2, ln(1) → 0",
    "bitbybit.math.log10": "Logarithmus Basis 10",
    "log10": "Logarithmus Basis 10",
    "bitbybit.math.log10_description": "Berechnet den Logarithmus zur Basis 10 einer Zahl. Beispiel: log₁₀(100) → 2, log₁₀(1000) → 3, log₁₀(10) → 1",
    "bitbybit.math.tenPow": "Zehnerpotenz",
    "tenPow": "Zehnerpotenz",
    "bitbybit.math.tenPow_description": "Erhebt 10 zur Potenz der Eingabezahl. Beispiel: 10² → 100, 10³ → 1000, 10⁻¹ → 0.1",
    "bitbybit.math.sin": "Sinus",
    "sin": "Sinus",
    "bitbybit.math.sin_description": "Berechnet den Sinus eines Winkels in Bogenmaß. Beispiel: sin(0) → 0, sin(π2) → 1, sin(π) → ~0",
    "bitbybit.math.cos": "Cosinus",
    "cos": "Cosinus",
    "bitbybit.math.cos_description": "Berechnet den Kosinus eines Winkels in Bogenmaß. Beispiel: cos(0) → 1, cos(π2) → ~0, cos(π) → -1",
    "bitbybit.math.tan": "Tangens",
    "tan": "Tangens",
    "bitbybit.math.tan_description": "Berechnet den Tangens eines Winkels in Bogenmaß. Beispiel: tan(0) → 0, tan(π4) → ~1, tan(π2) → unendlich",
    "bitbybit.math.asin": "Arcussinus",
    "asin": "Arcussinus",
    "bitbybit.math.asin_description": "Berechnet den Arkussinus (inversen Sinus) in Bogenmaß, gibt Winkel zurück, dessen Sinus die Eingabe ist. Beispiel: asin(0) → 0, asin(1) → π2 (~1.57), asin(0.5) → π6 (~0.524)",
    "bitbybit.math.acos": "Arcuscosinus",
    "acos": "Arcuscosinus",
    "bitbybit.math.acos_description": "Berechnet den Arkuskosinus (inversen Kosinus) in Bogenmaß, gibt Winkel zurück, dessen Kosinus die Eingabe ist. Beispiel: acos(1) → 0, acos(0) → π2 (~1.57), acos(-1) → π (~3.14)",
    "bitbybit.math.atan": "Arcustangens",
    "atan": "Arcustangens",
    "bitbybit.math.atan_description": "Berechnet den Arkustangens (inversen Tangens) in Bogenmaß, gibt Winkel zurück, dessen Tangens die Eingabe ist. Beispiel: atan(0) → 0, atan(1) → π4 (~0.785), atan(-1) → -π4",
    "bitbybit.math.exp": "Exponent",
    "exp": "Exponent",
    "bitbybit.math.exp_description": "Berechnet e zur Potenz der Eingabe (Exponentialfunktion). Beispiel: e⁰ → 1, e¹ → ~2.718, e² → ~7.389",
    "bitbybit.math.degToRad": "Grad zu Radiant",
    "degToRad": "Grad zu Radiant",
    "bitbybit.math.degToRad_description": "Konvertiert einen Winkel von Grad in Bogenmaß. Beispiel: 180° → π (~3.14159), 90° → π2 (~1.5708), 360° → 2π",
    "bitbybit.math.radToDeg": "Radiant zu Grad",
    "radToDeg": "Radiant zu Grad",
    "bitbybit.math.radToDeg_description": "Konvertiert einen Winkel von Bogenmaß in Grad. Beispiel: π → 180°, π2 → 90°, 2π → 360°",
    "bitbybit.math.ease": "glätten",
    "bitbybit.math.ease_description": "Wendet eine Easing-Funktion an, um sanft zwischen Min- und Max-Werten zu interpolieren. Beispiel: x=0.5 von [0,100] mit easeInQuad → wendet quadratische Beschleunigungskurve an. Nützlich für sanfte Animationen mit verschiedenen Beschleunigungs-/Verzögerungskurven.",
    "easeEnum": "Glättungs-Enum",
    "bitbybit.lists.getItem": "Element abrufen",
    "lists": "Listen",
    "getItem": "Element abrufen",
    "bitbybit.lists.getItem_description": "Ruft ein Element aus der Liste an einer bestimmten Position unter Verwendung von nullbasierter Indizierung ab. Beispiel: Aus [10, 20, 30, 40], Abrufen von Index 2 gibt 30 zurück",
    "list": "Liste",
    "bitbybit.lists.randomGetThreshold": "zufälliges Abrufen mit Schwellenwert",
    "randomGetThreshold": "zufälliges Abrufen mit Schwellenwert",
    "bitbybit.lists.randomGetThreshold_description": "Behält zufällig Elemente aus der Liste basierend auf einem Wahrscheinlichkeitsschwellenwert (0 bis 1). Beispiel: Aus [1, 2, 3, 4, 5] mit Schwellenwert 0.5, könnte [1, 3, 5] zurückgeben (50% Chance für jedes Element)",
    "bitbybit.lists.getSubList": "Teilliste abrufen",
    "getSubList": "Teilliste abrufen",
    "bitbybit.lists.getSubList_description": "Extrahiert einen Teil der Liste zwischen Start- und Endpositionen (Ende ist exklusiv). Beispiel: Aus [10, 20, 30, 40, 50] mit Start=1 und Ende=4, gibt [20, 30, 40] zurück",
    "indexStart": "Startindex",
    "indexEnd": "Endindex",
    "bitbybit.lists.getNthItem": "n-tes Element abrufen",
    "getNthItem": "n-tes Element abrufen",
    "bitbybit.lists.getNthItem_description": "Ruft jedes n-te Element aus der Liste ab, beginnend ab einer optionalen Offset-Position. Beispiel: Aus [0, 1, 2, 3, 4, 5, 6, 7, 8] mit nth=3 und offset=0, gibt [0, 3, 6] zurück. Beispiel: Aus [0, 1, 2, 3, 4, 5, 6, 7, 8] mit nth=2 und offset=1, gibt [1, 3, 5, 7] zurück",
    "nth": "n-tes",
    "bitbybit.lists.getByPattern": "nach Muster abrufen",
    "getByPattern": "nach Muster abrufen",
    "bitbybit.lists.getByPattern_description": "Filtert Elemente aus der Liste unter Verwendung eines sich wiederholenden wahr/falsch-Musters. Beispiel: Aus [0, 1, 2, 3, 4, 5] mit Muster [true, true, false], gibt [0, 1, 3, 4] zurück (behält Elemente, wo Muster wahr ist)",
    "pattern": "Muster",
    "bitbybit.lists.mergeElementsOfLists": "Elemente von Listen zusammenführen",
    "mergeElementsOfLists": "Elemente von Listen zusammenführen",
    "bitbybit.lists.mergeElementsOfLists_description": "Führt Elemente aus mehreren Listen auf einer bestimmten Verschachtelungsebene zusammen, gruppiert Elemente nach Position. Beispiel: Aus [[0, 1, 2], [3, 4, 5]] auf Ebene 0, gibt [[0, 3], [1, 4], [2, 5]] zurück",
    "level": "Ebene",
    "bitbybit.lists.getLongestListLength": "längste Listenlänge abrufen",
    "getLongestListLength": "längste Listenlänge abrufen",
    "bitbybit.lists.getLongestListLength_description": "Findet die Länge der längsten Liste unter mehreren Listen. Beispiel: Aus [[1, 2], [3, 4, 5, 6], [7]], gibt 4 zurück (Länge von [3, 4, 5, 6])",
    "bitbybit.lists.reverse": "umkehren",
    "bitbybit.lists.reverse_description": "Kehrt die Reihenfolge der Elemente in der Liste um. Beispiel: Aus [1, 2, 3, 4, 5], gibt [5, 4, 3, 2, 1] zurück",
    "bitbybit.lists.flipLists": "Listen spiegeln",
    "flipLists": "Listen spiegeln",
    "bitbybit.lists.flipLists_description": "Transponiert eine 2D-Liste durch Vertauschen von Zeilen und Spalten (alle Unterlisten müssen gleiche Länge haben). Beispiel: Aus [[0, 1, 2], [3, 4, 5]], gibt [[0, 3], [1, 4], [2, 5]] zurück",
    "bitbybit.lists.groupNth": "n-tes gruppieren",
    "groupNth": "n-tes gruppieren",
    "bitbybit.lists.groupNth_description": "Teilt die Liste in kleinere Listen von je n Elementen. Beispiel: Aus [0, 1, 2, 3, 4, 5, 6, 7, 8] mit n=3, gibt [[0, 1, 2], [3, 4, 5], [6, 7, 8]] zurück. Beispiel: Aus [0, 1, 2, 3, 4] mit n=2 und keepRemainder=true, gibt [[0, 1], [2, 3], [4]] zurück",
    "nrElements": "Anzahl Elemente",
    "keepRemainder": "Rest behalten",
    "bitbybit.lists.getListDepth": "Listentiefe abrufen",
    "getListDepth": "Listentiefe abrufen",
    "bitbybit.lists.getListDepth_description": "Bestimmt die maximale Verschachtelungsebene (Tiefe) einer Listenstruktur. Beispiel: [1, 2, 3] hat Tiefe 1, [[1, 2], [3, 4]] hat Tiefe 2, [[[1]]] hat Tiefe 3",
    "bitbybit.lists.listLength": "Listenlänge",
    "listLength": "Listenlänge",
    "bitbybit.lists.listLength_description": "Gibt die Anzahl der Elemente in der Liste zurück. Beispiel: [10, 20, 30, 40, 50] gibt 5 zurück, [] gibt 0 zurück",
    "bitbybit.lists.addItemAtIndex": "Element an Index hinzufügen",
    "addItemAtIndex": "Element an Index hinzufügen",
    "bitbybit.lists.addItemAtIndex_description": "Fügt ein Element an einer bestimmten Position in die Liste ein. Beispiel: In [10, 20, 30, 40], Hinzufügen von 99 an Index 2 ergibt [10, 20, 99, 30, 40]",
    "item": "Element",
    "bitbybit.lists.addItemAtIndexes": "Element an Indizes hinzufügen",
    "addItemAtIndexes": "Element an Indizes hinzufügen",
    "bitbybit.lists.addItemAtIndexes_description": "Fügt dasselbe Element an mehreren angegebenen Positionen in die Liste ein. Beispiel: In [10, 20, 30], Hinzufügen von 99 an Indizes [0, 2] ergibt [99, 10, 20, 99, 30]",
    "bitbybit.lists.addItemsAtIndexes": "Elemente an Indizes hinzufügen",
    "addItemsAtIndexes": "Elemente an Indizes hinzufügen",
    "bitbybit.lists.addItemsAtIndexes_description": "Fügt mehrere Elemente an entsprechenden Positionen ein (erstes Element am ersten Index, zweites Element am zweiten Index usw.). Beispiel: In [10, 20, 30], Hinzufügen von Elementen [88, 99] an Indizes [1, 2] ergibt [10, 88, 20, 99, 30]",
    "items": "Elemente",
    "bitbybit.lists.removeItemAtIndex": "Element an Index entfernen",
    "removeItemAtIndex": "Element an Index entfernen",
    "bitbybit.lists.removeItemAtIndex_description": "Entfernt das Element an einer bestimmten Position in der Liste. Beispiel: Aus [10, 20, 30, 40, 50], Entfernen von Index 2 ergibt [10, 20, 40, 50]",
    "bitbybit.lists.removeItemsAtIndexes": "Elemente an Indizes entfernen",
    "removeItemsAtIndexes": "Elemente an Indizes entfernen",
    "bitbybit.lists.removeItemsAtIndexes_description": "Entfernt Elemente an mehreren angegebenen Positionen aus der Liste. Beispiel: Aus [10, 20, 30, 40, 50], Entfernen von Indizes [1, 3] ergibt [10, 30, 50]",
    "bitbybit.lists.removeAllItems": "alle Elemente entfernen",
    "removeAllItems": "alle Elemente entfernen",
    "bitbybit.lists.removeAllItems_description": "Löscht alle Elemente aus der Liste, was zu einer leeren Liste führt. Beispiel: Aus [10, 20, 30, 40], gibt [] zurück",
    "bitbybit.lists.removeNthItem": "n-tes Element entfernen",
    "removeNthItem": "n-tes Element entfernen",
    "bitbybit.lists.removeNthItem_description": "Entfernt jedes n-te Element aus der Liste, beginnend ab einer optionalen Offset-Position. Beispiel: Aus [0, 1, 2, 3, 4, 5, 6, 7, 8] mit nth=3 und offset=0, gibt [1, 2, 4, 5, 7, 8] zurück (entfernt 0, 3, 6)",
    "bitbybit.lists.randomRemoveThreshold": "zufälliges Entfernen mit Schwellenwert",
    "randomRemoveThreshold": "zufälliges Entfernen mit Schwellenwert",
    "bitbybit.lists.randomRemoveThreshold_description": "Entfernt zufällig Elemente aus der Liste basierend auf einem Wahrscheinlichkeitsschwellenwert (0 bis 1). Beispiel: Aus [1, 2, 3, 4, 5] mit Schwellenwert 0.5, könnte [2, 4] zurückgeben (50% Chance, jedes Element zu entfernen)",
    "bitbybit.lists.removeDuplicateNumbers": "doppelte Zahlen entfernen",
    "removeDuplicateNumbers": "doppelte Zahlen entfernen",
    "bitbybit.lists.removeDuplicateNumbers_description": "Entfernt doppelte Zahlen aus der Liste, behält nur das erste Vorkommen jedes Wertes. Beispiel: Aus [1, 2, 3, 2, 4, 3, 5], gibt [1, 2, 3, 4, 5] zurück",
    "bitbybit.lists.removeDuplicateNumbersTolerance": "doppelte Zahlen mit Toleranz entfernen",
    "removeDuplicateNumbersTolerance": "doppelte Zahlen mit Toleranz entfernen",
    "bitbybit.lists.removeDuplicateNumbersTolerance_description": "Entfernt doppelte Zahlen, die innerhalb eines angegebenen Toleranzbereichs voneinander liegen. Beispiel: Aus [1.0, 1.001, 2.0, 2.002, 3.0] mit Toleranz 0.01, gibt [1.0, 2.0, 3.0] zurück",
    "bitbybit.lists.addItem": "Element hinzufügen",
    "addItem": "Element hinzufügen",
    "bitbybit.lists.addItem_description": "Hängt ein Element an das Ende der Liste an. Beispiel: Zu [10, 20, 30], Hinzufügen von 40 ergibt [10, 20, 30, 40]",
    "bitbybit.lists.prependItem": "Element voranstellen",
    "prependItem": "Element voranstellen",
    "bitbybit.lists.prependItem_description": "Fügt ein Element am Anfang der Liste hinzu. Beispiel: Zu [10, 20, 30], Voranstellen von 5 ergibt [5, 10, 20, 30]",
    "bitbybit.lists.addItemFirstLast": "Element zuerst oder zuletzt hinzufügen",
    "addItemFirstLast": "Element zuerst oder zuletzt hinzufügen",
    "bitbybit.lists.addItemFirstLast_description": "Fügt ein Element entweder am Anfang oder Ende der Liste hinzu, basierend auf dem Positionsparameter. Beispiel: Zu [10, 20, 30], Hinzufügen von 5 bei 'first' ergibt [5, 10, 20, 30], bei 'last' ergibt [10, 20, 30, 5]",
    "firstLastEnum": "Erste-Letzte-Enum",
    "bitbybit.lists.createEmptyList": "leere Liste",
    "createEmptyList": "leere Liste",
    "bitbybit.lists.createEmptyList_description": "Erstellt eine neue leere Liste ohne Elemente. Beispiel: Gibt [] zurück",
    "bitbybit.lists.repeat": "wiederholen",
    "repeat": "wiederholen",
    "bitbybit.lists.repeat_description": "Erstellt eine neue Liste durch Wiederholen eines Elements eine bestimmte Anzahl von Malen. Beispiel: Wiederholen von 5 dreimal gibt [5, 5, 5] zurück",
    "times": "Mal",
    "bitbybit.lists.repeatInPattern": "in Muster wiederholen",
    "repeatInPattern": "in Muster wiederholen",
    "bitbybit.lists.repeatInPattern_description": "Wiederholt ein Muster von Elementen zyklisch, bis eine Ziellistenlänge erreicht ist. Beispiel: Muster [1, 2, 3] mit Länge 7 gibt [1, 2, 3, 1, 2, 3, 1] zurück",
    "lengthLimit": "Längenbegrenzung",
    "bitbybit.lists.sortNumber": "Zahl sortieren",
    "sortNumber": "Zahl sortieren",
    "bitbybit.lists.sortNumber_description": "Sortiert Zahlen in aufsteigender (niedrigste zu höchste) oder absteigender (höchste zu niedrigste) Reihenfolge. Beispiel: [5, 2, 8, 1, 9] aufsteigend gibt [1, 2, 5, 8, 9] zurück, absteigend gibt [9, 8, 5, 2, 1] zurück",
    "sorting": "Sortierung",
    "orderAsc": "aufsteigende Reihenfolge",
    "bitbybit.lists.sortTexts": "Texte sortieren",
    "sortTexts": "Texte sortieren",
    "bitbybit.lists.sortTexts_description": "Sortiert Textzeichenfolgen alphabetisch in aufsteigender (A bis Z) oder absteigender (Z bis A) Reihenfolge. Beispiel: ['hund', 'apfel', 'katze', 'banane'] aufsteigend gibt ['apfel', 'banane', 'hund', 'katze'] zurück",
    "bitbybit.lists.sortByPropValue": "nach Eigenschaftswert sortieren",
    "sortByPropValue": "nach Eigenschaftswert sortieren",
    "bitbybit.lists.sortByPropValue_description": "Sortiert Objekte durch Vergleich numerischer Werte einer angegebenen Eigenschaft. Beispiel: [{age: 30}, {age: 20}, {age: 25}] sortiert nach 'age' aufsteigend gibt [{age: 20}, {age: 25}, {age: 30}] zurück",
    "property": "Eigenschaft",
    "bitbybit.color.hexColor": "Hex-Farbe",
    "hexColor": "Hex-Farbe",
    "bitbybit.color.hexColor_description": "Erstellt und gibt einen Hex-Farbstring zurück (Durchleitung für Farbeingabe). Beispiel: '#FF5733' → '#FF5733'",
    "bitbybit.color.hexToRgb": "Hex zu RGB",
    "hexToRgb": "Hex zu RGB",
    "bitbybit.color.hexToRgb_description": "Konvertiert Hex-Farbe in RGB-Objekt mit r, g, b Werten (Bereich 0-255). Beispiel: '#FF5733' → {r: 255, g: 87, b: 51}",
    "convert": "konvertieren",
    "bitbybit.color.rgbToHex": "RGB zu Hex",
    "rgbToHex": "RGB zu Hex",
    "bitbybit.color.rgbToHex_description": "Konvertiert RGB-Werte in Hex-Farbstring (unterstützt benutzerdefinierte Min/Max-Bereiche, automatische Neuzuordnung auf 0-255). Beispiel: r=255, g=87, b=51 mit Bereich [0,255] → '#ff5733'. Beispiel: r=1, g=0.5, b=0.2 mit Bereich [0,1] → '#ff7f33'",
    "r": "Rot",
    "g": "Grün",
    "b": "Blau",
    "bitbybit.color.rgbObjToHex": "RGB-Objekt zu Hex",
    "rgbObjToHex": "RGB-Objekt zu Hex",
    "bitbybit.color.rgbObjToHex_description": "Konvertiert RGB-Objekt in Hex-Farbstring (unterstützt benutzerdefinierte Min/Max-Bereiche). Beispiel: {r: 1, g: 0.5, b: 0.2} mit Bereich [0,1] → '#ff7f33'",
    "rgb": "RGB",
    "Base.ColorRGB": "Basis-Farbe RGB",
    "bitbybit.color.hexToRgbMapped": "Hex zu RGB gemappt",
    "hexToRgbMapped": "Hex zu RGB gemappt",
    "bitbybit.color.hexToRgbMapped_description": "Konvertiert Hex-Farbe in RGB und bildet Werte auf einen benutzerdefinierten Bereich ab. Beispiel: '#FF5733' abgebildet auf [0,1] → {r: 1, g: 0.341, b: 0.2}. Beispiel: '#FF5733' abgebildet auf [0,100] → {r: 100, g: 34.1, b: 20}",
    "bitbybit.color.getRedParam": "Rot-Parameter abrufen",
    "getRedParam": "Rot-Parameter abrufen",
    "bitbybit.color.getRedParam_description": "Extrahiert den roten Kanalwert aus Hex-Farbe (kann auf benutzerdefinierten Bereich abgebildet werden). Beispiel: '#FF5733' mit Bereich [0,1] → 1",
    "hex to": "Hex zu",
    "bitbybit.color.getGreenParam": "Grün-Parameter abrufen",
    "getGreenParam": "Grün-Parameter abrufen",
    "bitbybit.color.getGreenParam_description": "Extrahiert den grünen Kanalwert aus Hex-Farbe (kann auf benutzerdefinierten Bereich abgebildet werden). Beispiel: '#FF5733' mit Bereich [0,1] → 0.341",
    "bitbybit.color.getBlueParam": "Blau-Parameter abrufen",
    "getBlueParam": "Blau-Parameter abrufen",
    "bitbybit.color.getBlueParam_description": "Extrahiert den blauen Kanalwert aus Hex-Farbe (kann auf benutzerdefinierten Bereich abgebildet werden). Beispiel: '#FF5733' mit Bereich [0,1] → 0.2",
    "bitbybit.color.rgbToRed": "RGB zu Rot",
    "rgbToRed": "RGB zu Rot",
    "bitbybit.color.rgbToRed_description": "Extrahiert den roten Kanalwert aus RGB-Objekt. Beispiel: {r: 255, g: 87, b: 51} → 255",
    "rgb to": "RGB zu",
    "bitbybit.color.rgbToGreen": "RGB zu Grün",
    "rgbToGreen": "RGB zu Grün",
    "bitbybit.color.rgbToGreen_description": "Extrahiert den grünen Kanalwert aus RGB-Objekt. Beispiel: {r: 255, g: 87, b: 51} → 87",
    "bitbybit.color.rgbToBlue": "RGB zu Blau",
    "rgbToBlue": "RGB zu Blau",
    "bitbybit.color.rgbToBlue_description": "Extrahiert den blauen Kanalwert aus RGB-Objekt. Beispiel: {r: 255, g: 87, b: 51} → 51",
    "bitbybit.color.invert": "invertieren",
    "invert": "invertieren",
    "bitbybit.color.invert_description": "Invertiert eine Hex-Farbe (kehrt RGB-Kanäle um: 255-r, 255-g, 255-b). Mit blackAndWhite=true → gibt '#000000' oder '#ffffff' basierend auf Helligkeit zurück. Beispiel: '#FF5733' → '#00a8cc', '#FF5733' mit blackAndWhite=true → '#ffffff'",
    "blackAndWhite": "Schwarz und Weiß",
    "bitbybit.text.create": "erstellen",
    "bitbybit.text.create_description": "Erstellt und gibt eine Textzeichenfolge zurück (Durchleitung für Texteingabe). Beispiel: text='Hallo Welt' → 'Hallo Welt'",
    "bitbybit.text.split": "teilen",
    "bitbybit.text.split_description": "Teilt Text in mehrere Stücke unter Verwendung einer Trennzeichenfolge. Beispiel: text='apfel,banane,kirsche', separator=',' → ['apfel', 'banane', 'kirsche']",
    "separator": "Trennzeichen",
    "bitbybit.text.replaceAll": "alles ersetzen",
    "replaceAll": "alles ersetzen",
    "bitbybit.text.replaceAll_description": "Ersetzt alle Vorkommen einer Suchzeichenfolge durch eine Ersetzungszeichenfolge. Beispiel: text='hallo hallo', search='hallo', replaceWith='hi' → 'hi hi'",
    "search": "suchen",
    "replaceWith": "ersetzen durch",
    "bitbybit.text.join": "verbinden",
    "join": "verbinden",
    "bitbybit.text.join_description": "Verbindet mehrere Elemente zu einer einzigen Textzeichenfolge unter Verwendung eines Trennzeichens. Beispiel: list=['apfel', 'banane', 'kirsche'], separator=', ' → 'apfel, banane, kirsche'",
    "string[]": "Zeichenfolgen-Array",
    "bitbybit.text.toString": "zu Zeichenfolge",
    "toString": "zu Zeichenfolge",
    "bitbybit.text.toString_description": "Transformiert jedes Element in Text.",
    "bitbybit.text.toStringEach": "jedes zu Zeichenfolge",
    "toStringEach": "jedes zu Zeichenfolge",
    "bitbybit.text.toStringEach_description": "Transformiert jedes Element in der Liste in Text.",
    "bitbybit.text.format": "formatieren",
    "format": "formatieren",
    "bitbybit.text.format_description": "Formatiert Text mit Platzhalterwerten unter Verwendung von {0}, {1} usw. Syntax. Beispiel: text='Punkt: ({0}, {1})', values=[10, 5] → 'Punkt: (10, 5)'",
    "values": "Werte",
    "bitbybit.text.vectorChar": "Vektorzeichen",
    "vectorChar": "Vektorzeichen",
    "bitbybit.text.vectorChar_description": "Konvertiert ein Zeichen in Vektorpfade (Polylinien) mit Breiten- und Höhendaten für das Rendern. Verwendet Simplex-Strichschrift, um 2D-Liniensegmente zu erzeugen, die die Zeichenform darstellen. Beispiel: char='A', height=10 → {width:8, height:10, paths:[[Punkte, die A-Form bilden]]}",
    "char": "Zeichen",
    "bitbybit.text.vectorText": "Vektortext",
    "vectorText": "Vektortext",
    "bitbybit.text.vectorText_description": "Konvertiert mehrzeiligen Text in Vektorpfade (Polylinien) mit Ausrichtungs- und Abstandssteuerung. Unterstützt Zeilenumbrüche, Buchstabenabstand, Zeilenabstand, horizontale Ausrichtung und Ursprungszentrierung. Beispiel: text='Hello\nWorld', height=10, align=center → [{line1 chars}, {line2 chars}]",
    "dates": "Datum",
    "bitbybit.dates.toDateString": "zu Datumszeichenfolge",
    "toDateString": "zu Datumszeichenfolge",
    "bitbybit.dates.toDateString_description": "Konvertiert Datum in menschenlesbare Datumszeichenfolge (schließt Zeit aus). Beispiel: Datum(2024,0,15,14,30) → 'Mon Jan 15 2024'",
    "date": "Datum",
    "Date": "Datum",
    "bitbybit.dates.toISOString": "zu ISO-Zeichenfolge",
    "toISOString": "zu ISO-Zeichenfolge",
    "bitbybit.dates.toISOString_description": "Konvertiert Datum in ISO 8601 Formatzeichenfolge (Standardformat für APIs und Datenaustausch). Beispiel: Datum(2024,0,15,14,30,45) → '2024-01-15T14:30:45.000Z'",
    "bitbybit.dates.toJSON": "zu JSON",
    "toJSON": "zu JSON",
    "bitbybit.dates.toJSON_description": "Konvertiert Datum in JSON-kompatible Zeichenfolge (gleich wie ISO-Format, verwendet in JSON.stringify). Beispiel: Datum(2024,0,15,14,30) → '2024-01-15T14:30:00.000Z'",
    "bitbybit.dates.toString": "zu Zeichenfolge",
    "bitbybit.dates.toString_description": "Konvertiert Datum in vollständige gebietsschemaspezifische Zeichenfolge (schließt Datum, Zeit und Zeitzone ein). Beispiel: Datum(2024,0,15,14,30) → 'Mon Jan 15 2024 14:30:00 GMT+0000'",
    "bitbybit.dates.toTimeString": "zu Zeitzeichenfolge",
    "toTimeString": "zu Zeitzeichenfolge",
    "bitbybit.dates.toTimeString_description": "Konvertiert Datum in Zeitzeichenfolge (schließt Datum aus, schließt Zeitzone ein). Beispiel: Datum(2024,0,15,14,30,45) → '14:30:45 GMT+0000'",
    "bitbybit.dates.toUTCString": "zu UTC-Zeichenfolge",
    "toUTCString": "zu UTC-Zeichenfolge",
    "bitbybit.dates.toUTCString_description": "Konvertiert Datum in UTC-Zeichenfolgeformat (Universal Coordinated Time, kein Zeitzonenversatz). Beispiel: Datum(2024,0,15,14,30) → 'Mon, 15 Jan 2024 14:30:00 GMT'",
    "bitbybit.dates.now": "jetzt",
    "now": "jetzt",
    "bitbybit.dates.now_description": "Gibt das aktuelle Datum und die Uhrzeit zum Zeitpunkt der Ausführung zurück. Beispiel: Aufruf von now() → Datumsobjekt, das den aktuellen Moment darstellt (z. B. '2024-01-15T14:30:45')",
    "bitbybit.dates.createDate": "Datum erstellen",
    "createDate": "Datum erstellen",
    "bitbybit.dates.createDate_description": "Erstellt ein neues Datum aus einzelnen Komponenten unter Verwendung der Ortszeit. Monat ist 0-indiziert: 0=Januar, 11=Dezember. Beispiel: Jahr=2024, Monat=0, Tag=15, Stunden=14, Minuten=30 → Datum(Jan 15, 2024 14:30)",
    "year": "Jahr",
    "month": "Monat",
    "day": "Tag",
    "hours": "Stunden",
    "minutes": "Minuten",
    "seconds": "Sekunden",
    "milliseconds": "Millisekunden",
    "bitbybit.dates.createDateUTC": "UTC-Datum erstellen",
    "createDateUTC": "UTC-Datum erstellen",
    "bitbybit.dates.createDateUTC_description": "Erstellt ein neues Datum aus einzelnen Komponenten unter Verwendung von UTC (ignoriert Zeitzone). Gibt Millisekunden seit Unix-Epoche (1. Jan. 1970 00:00:00 UTC) zurück. Beispiel: Jahr=2024, Monat=0, Tag=15 → Datum, das Jan 15, 2024 00:00 UTC darstellt",
    "bitbybit.dates.createFromUnixTimeStamp": "aus Unix-Zeitstempel erstellen",
    "createFromUnixTimeStamp": "aus Unix-Zeitstempel erstellen",
    "bitbybit.dates.createFromUnixTimeStamp_description": "Erstellt ein Datum aus Unix-Zeitstempel (Millisekunden seit 1. Jan. 1970 UTC). Beispiel: unixTimeStamp=1705329000000 → Datum(Jan 15, 2024 14:30:00)",
    "unixTimeStamp": "Unix-Zeitstempel",
    "bitbybit.dates.parseDate": "Datum parsen",
    "parseDate": "Datum parsen",
    "bitbybit.dates.parseDate_description": "Parst eine Datumszeichenfolge und gibt Unix-Zeitstempel (Millisekunden seit 1. Jan. 1970 UTC) zurück. Beispiel: dateString='2024-01-15' → 1705276800000",
    "parse": "parsen",
    "dateString": "Datumszeichenfolge",
    "bitbybit.dates.getDayOfMonth": "Tag des Monats abrufen",
    "getDayOfMonth": "Tag des Monats abrufen",
    "bitbybit.dates.getDayOfMonth_description": "Extrahiert Tag des Monats aus Datum (1-31) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15) → 15",
    "bitbybit.dates.getWeekday": "Wochentag abrufen",
    "getWeekday": "Wochentag abrufen",
    "bitbybit.dates.getWeekday_description": "Extrahiert Wochentag aus Datum (0=Sonntag, 6=Samstag) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15) → 1 (Montag)",
    "bitbybit.dates.getYear": "Jahr abrufen",
    "getYear": "Jahr abrufen",
    "bitbybit.dates.getYear_description": "Extrahiert vollständiges Jahr aus Datum unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15) → 2024",
    "bitbybit.dates.getMonth": "Monat abrufen",
    "getMonth": "Monat abrufen",
    "bitbybit.dates.getMonth_description": "Extrahiert Monat aus Datum (0=Januar, 11=Dezember) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15) → 0 (Januar)",
    "bitbybit.dates.getHours": "Stunden abrufen",
    "getHours": "Stunden abrufen",
    "bitbybit.dates.getHours_description": "Extrahiert Stunden aus Datum (0-23) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15,14,30) → 14",
    "bitbybit.dates.getMinutes": "Minuten abrufen",
    "getMinutes": "Minuten abrufen",
    "bitbybit.dates.getMinutes_description": "Extrahiert Minuten aus Datum (0-59) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15,14,30) → 30",
    "bitbybit.dates.getSeconds": "Sekunden abrufen",
    "getSeconds": "Sekunden abrufen",
    "bitbybit.dates.getSeconds_description": "Extrahiert Sekunden aus Datum (0-59) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getMilliseconds": "Millisekunden abrufen",
    "getMilliseconds": "Millisekunden abrufen",
    "bitbybit.dates.getMilliseconds_description": "Extrahiert Millisekunden aus Datum (0-999) unter Verwendung der Ortszeit. Beispiel: Datum(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.getTime": "Zeit abrufen",
    "getTime": "Zeit abrufen",
    "bitbybit.dates.getTime_description": "Konvertiert Datum in Unix-Zeitstempel (Millisekunden seit 1. Jan. 1970 UTC). Beispiel: Datum(2024,0,15,14,30) → 1705329000000",
    "bitbybit.dates.getUTCYear": "UTC-Jahr abrufen",
    "getUTCYear": "UTC-Jahr abrufen",
    "bitbybit.dates.getUTCYear_description": "Extrahiert vollständiges Jahr aus Datum unter Verwendung von UTC (ignoriert Zeitzone). Beispiel: Datum(2024,0,15) → 2024",
    "bitbybit.dates.getUTCMonth": "UTC-Monat abrufen",
    "getUTCMonth": "UTC-Monat abrufen",
    "bitbybit.dates.getUTCMonth_description": "Extrahiert Monat aus Datum (0=Januar, 11=Dezember) unter Verwendung von UTC. Beispiel: Date.UTC(2024,0,15) → 0 (Januar)",
    "bitbybit.dates.getUTCDay": "UTC-Tag abrufen",
    "getUTCDay": "UTC-Tag abrufen",
    "bitbybit.dates.getUTCDay_description": "Extrahiert Tag des Monats aus Datum (1-31) unter Verwendung von UTC. Beispiel: Date.UTC(2024,0,15) → 15",
    "bitbybit.dates.getUTCHours": "UTC-Stunden abrufen",
    "getUTCHours": "UTC-Stunden abrufen",
    "bitbybit.dates.getUTCHours_description": "Extrahiert Stunden aus Datum (0-23) unter Verwendung von UTC. Beispiel: Date.UTC(2024,0,15,14) → 14",
    "bitbybit.dates.getUTCMinutes": "UTC-Minuten abrufen",
    "getUTCMinutes": "UTC-Minuten abrufen",
    "bitbybit.dates.getUTCMinutes_description": "Extrahiert Minuten aus Datum (0-59) unter Verwendung von UTC. Beispiel: Date.UTC(2024,0,15,14,30) → 30",
    "bitbybit.dates.getUTCSeconds": "UTC-Sekunden abrufen",
    "getUTCSeconds": "UTC-Sekunden abrufen",
    "bitbybit.dates.getUTCSeconds_description": "Extrahiert Sekunden aus Datum (0-59) unter Verwendung von UTC. Beispiel: Date.UTC(2024,0,15,14,30,45) → 45",
    "bitbybit.dates.getUTCMilliseconds": "UTC-Millisekunden abrufen",
    "getUTCMilliseconds": "UTC-Millisekunden abrufen",
    "bitbybit.dates.getUTCMilliseconds_description": "Extrahiert Millisekunden aus Datum (0-999) unter Verwendung von UTC. Beispiel: Date.UTC(2024,0,15,14,30,45,123) → 123",
    "bitbybit.dates.setYear": "Jahr setzen",
    "setYear": "Jahr setzen",
    "bitbybit.dates.setYear_description": "Erstellt neues Datum mit geändertem Jahr (gibt neues Datum zurück, Original unverändert). Beispiel: Datum(2024,0,15) mit Jahr=2025 → Datum(2025,0,15)",
    "bitbybit.dates.setMonth": "Monat setzen",
    "setMonth": "Monat setzen",
    "bitbybit.dates.setMonth_description": "Erstellt neues Datum mit geändertem Monat (0=Januar, 11=Dezember, gibt neues Datum zurück). Beispiel: Datum(2024,0,15) mit Monat=5 → Datum(2024,5,15) (15. Juni)",
    "bitbybit.dates.setDayOfMonth": "Tag des Monats setzen",
    "setDayOfMonth": "Tag des Monats setzen",
    "bitbybit.dates.setDayOfMonth_description": "Erstellt neues Datum mit geändertem Tag des Monats (1-31, gibt neues Datum zurück). Beispiel: Datum(2024,0,15) mit Tag=20 → Datum(2024,0,20)",
    "bitbybit.dates.setHours": "Stunden setzen",
    "setHours": "Stunden setzen",
    "bitbybit.dates.setHours_description": "Setzt den Stundenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setMinutes": "Minuten setzen",
    "setMinutes": "Minuten setzen",
    "bitbybit.dates.setMinutes_description": "Setzt den Minutenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setSeconds": "Sekunden setzen",
    "setSeconds": "Sekunden setzen",
    "bitbybit.dates.setSeconds_description": "Setzt den Sekundenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setMilliseconds": "Millisekunden setzen",
    "setMilliseconds": "Millisekunden setzen",
    "bitbybit.dates.setMilliseconds_description": "Setzt den Millisekundenwert eines Datumsobjekts unter Verwendung der lokalen Zeit.",
    "bitbybit.dates.setTime": "Zeit setzen",
    "setTime": "Zeit setzen",
    "bitbybit.dates.setTime_description": "Setzt den Datums- und Zeitwert eines Datumsobjekts.",
    "time": "Zeit",
    "bitbybit.dates.setUTCYear": "UTC-Jahr setzen",
    "setUTCYear": "UTC-Jahr setzen",
    "bitbybit.dates.setUTCYear_description": "Setzt den Jahreswert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMonth": "UTC-Monat setzen",
    "setUTCMonth": "UTC-Monat setzen",
    "bitbybit.dates.setUTCMonth_description": "Setzt den Monatswert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCDay": "UTC-Tag setzen",
    "setUTCDay": "UTC-Tag setzen",
    "bitbybit.dates.setUTCDay_description": "Setzt den numerischen Tag des Monats eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCHours": "UTC-Stunden setzen",
    "setUTCHours": "UTC-Stunden setzen",
    "bitbybit.dates.setUTCHours_description": "Setzt den Stundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMinutes": "UTC-Minuten setzen",
    "setUTCMinutes": "UTC-Minuten setzen",
    "bitbybit.dates.setUTCMinutes_description": "Setzt den Minutenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCSeconds": "UTC-Sekunden setzen",
    "setUTCSeconds": "UTC-Sekunden setzen",
    "bitbybit.dates.setUTCSeconds_description": "Setzt den Sekundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.dates.setUTCMilliseconds": "UTC-Millisekunden setzen",
    "setUTCMilliseconds": "UTC-Millisekunden setzen",
    "bitbybit.dates.setUTCMilliseconds_description": "Setzt den Millisekundenwert eines Datumsobjekts unter Verwendung der Universal Coordinated Time (UTC).",
    "bitbybit.json.stringify": "stringifizieren",
    "json": "JSON",
    "stringify": "stringifizieren",
    "bitbybit.json.stringify_description": "Stringifiziert den Eingabewert.",
    "bitbybit.json.parse": "parsen",
    "bitbybit.json.parse_description": "Parst den Eingabewert.",
    "bitbybit.json.query": "abfragen",
    "query": "abfragen",
    "bitbybit.json.query_description": "Fragt den Eingabewert ab.",
    "jsonpath": "JSON-Pfad",
    "bitbybit.json.setValueOnProp": "Wert auf Eigenschaft setzen",
    "setValueOnProp": "Wert auf Eigenschaft setzen",
    "bitbybit.json.setValueOnProp_description": "Setzt Wert auf gegebener Eigenschaft des gegebenen JSON.",
    "props": "Eigenschaften",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch": "JSON aus Array nach erstem Eigenschaftsübereinstimmung abrufen",
    "getJsonFromArrayByFirstPropMatch": "JSON aus Array nach erstem Eigenschaftsübereinstimmung abrufen",
    "bitbybit.json.getJsonFromArrayByFirstPropMatch_description": "Ruft JSON aus Array durch erste Eigenschaftsübereinstimmung ab. Dies ist eine sehr einfache Suche und gibt nur die erste Übereinstimmung zurück. Wenn Sie eine komplexere Suche benötigen, können Sie die JSONPath-Abfrage mit Filtern verwenden.",
    "jsonArray": "JSON-Array",
    "any[]": "beliebiges Array",
    "match": "Übereinstimmung",
    "bitbybit.json.getValueOnProp": "Wert von Eigenschaft abrufen",
    "getValueOnProp": "Wert von Eigenschaft abrufen",
    "bitbybit.json.getValueOnProp_description": "Ruft Wert der Eigenschaft im gegebenen JSON ab.",
    "bitbybit.json.setValue": "Wert setzen",
    "bitbybit.json.setValue_description": "Setzt Wert im JSON durch Bereitstellung eines Pfades.",
    "prop": "Eigenschaft",
    "bitbybit.json.setValuesOnPaths": "Werte auf Pfade setzen",
    "setValuesOnPaths": "Werte auf Pfade setzen",
    "bitbybit.json.setValuesOnPaths_description": "Setzt mehrere Werte im JSON durch Bereitstellung von Pfaden.",
    "paths": "Pfade",
    "bitbybit.json.paths": "Pfade",
    "bitbybit.json.paths_description": "Findet Pfade zu Elementen im Objekt, die dem Pfadausdruck entsprechen.",
    "bitbybit.json.createEmpty": "leer",
    "bitbybit.json.createEmpty_description": "Erstellt ein leeres JavaScript-Objekt.",
    "bitbybit.json.previewAndSaveJson": "JSON-Vorschau und Speichern",
    "previewAndSaveJson": "JSON-Vorschau und Speichern",
    "bitbybit.json.previewAndSaveJson_description": "Zeigt Vorschau von JSON und gibt Möglichkeit, es zu speichern.",
    "preview": "Vorschau",
    "bitbybit.json.previewJson": "JSON-Vorschau",
    "previewJson": "JSON-Vorschau",
    "bitbybit.json.previewJson_description": "zeigt eine Vorschau von JSON",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights": "Kurve nach Knoten, Kontrollpunkten und Gewichten",
    "verb": "Verb",
    "createCurveByKnotsControlPointsWeights": "Kurve nach Knoten, Kontrollpunkten und Gewichten",
    "bitbybit.verb.curve.createCurveByKnotsControlPointsWeights_description": "Erstellt eine Nurbs-Kurve durch Bereitstellung von Knoten, Kontrollpunkten & Gewichten.",
    "degree": "Grad",
    "knots": "Knoten",
    "bitbybit.verb.curve.createCurveByPoints": "Kurve nach Punkten",
    "createCurveByPoints": "Kurve nach Punkten",
    "bitbybit.verb.curve.createCurveByPoints_description": "Erstellt eine Nurbs-Kurve durch Bereitstellung von Kontrollpunkten.",
    "bitbybit.verb.curve.createBezierCurve": "Bézier-Kurve",
    "createBezierCurve": "Bézier-Kurve",
    "bitbybit.verb.curve.createBezierCurve_description": "Erstellt eine Bezier-Nurbs-Kurve durch Bereitstellung von Kontrollpunkten und Gewichten.",
    "bitbybit.verb.curve.clone": "klonen",
    "bitbybit.verb.curve.clone_description": "Klont die Nurbs-Kurve.",
    "bitbybit.verb.curve.closestParam": "nächster Parameter",
    "closestParam": "nächster Parameter",
    "bitbybit.verb.curve.closestParam_description": "Findet den nächsten Parameter auf der Nurbs-Kurve vom Punkt.",
    "bitbybit.verb.curve.closestParams": "nächste Parameter",
    "closestParams": "nächste Parameter",
    "bitbybit.verb.curve.closestParams_description": "Findet die nächsten Parameter auf der Nurbs-Kurve von den Punkten.",
    "bitbybit.verb.curve.closestPoint": "nächster Punkt",
    "closestPoint": "nächster Punkt",
    "bitbybit.verb.curve.closestPoint_description": "Findet den nächsten Punkt auf der Nurbs-Kurve vom Punkt.",
    "bitbybit.verb.curve.closestPoints": "nächste Punkte",
    "closestPoints": "nächste Punkte",
    "bitbybit.verb.curve.closestPoints_description": "Findet die nächsten Punkte auf der Nurbs-Kurve von der Liste von Punkten.",
    "bitbybit.verb.curve.controlPoints": "Kontrollpunkte",
    "controlPoints": "Kontrollpunkte",
    "bitbybit.verb.curve.controlPoints_description": "Findet die Kontrollpunkte der Nurbs-Kurve.",
    "bitbybit.verb.curve.degree": "Grad",
    "bitbybit.verb.curve.degree_description": "Findet den Grad der Nurbs-Kurve.",
    "bitbybit.verb.curve.derivatives": "Ableitungen",
    "derivatives": "Ableitungen",
    "bitbybit.verb.curve.derivatives_description": "Findet die Ableitungen der Nurbs-Kurve bei Parameter.",
    "numDerivatives": "Anzahl Ableitungen",
    "parameter": "Parameter",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams": "durch gleiche Bogenlänge zu Parametern teilen",
    "divideByEqualArcLengthToParams": "durch gleiche Bogenlänge zu Parametern teilen",
    "bitbybit.verb.curve.divideByEqualArcLengthToParams_description": "Teilt die Kurve durch gleiche Bogenlänge in Parameter.",
    "subdivision": "Unterteilung",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints": "durch gleiche Bogenlänge zu Punkten teilen",
    "divideByEqualArcLengthToPoints": "durch gleiche Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideByEqualArcLengthToPoints_description": "Teilt die Kurve durch gleiche Bogenlänge in Punkte.",
    "bitbybit.verb.curve.divideByArcLengthToParams": "durch Bogenlänge zu Parametern teilen",
    "divideByArcLengthToParams": "durch Bogenlänge zu Parametern teilen",
    "bitbybit.verb.curve.divideByArcLengthToParams_description": "Teilt die Kurve durch Bogenlänge in Parameter.",
    "bitbybit.verb.curve.divideByArcLengthToPoints": "durch Bogenlänge zu Punkten teilen",
    "divideByArcLengthToPoints": "durch Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideByArcLengthToPoints_description": "Teilt die Kurve durch Bogenlänge in Punkte.",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints": "Kurven durch gleiche Bogenlänge zu Punkten teilen",
    "divideCurvesByEqualArcLengthToPoints": "Kurven durch gleiche Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideCurvesByEqualArcLengthToPoints_description": "teilt mehrere Kurven durch gleiche Bogenlänge in Punkte",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints": "Kurven durch Bogenlänge zu Punkten teilen",
    "divideCurvesByArcLengthToPoints": "Kurven durch Bogenlänge zu Punkten teilen",
    "bitbybit.verb.curve.divideCurvesByArcLengthToPoints_description": "teilt mehrere Kurven durch Bogenlänge in Punkte",
    "bitbybit.verb.curve.domain": "Domäne",
    "bitbybit.verb.curve.domain_description": "Findet das Definitionsintervall der Kurvenparameter.",
    "bitbybit.verb.curve.startPoint": "Startpunkt",
    "bitbybit.verb.curve.startPoint_description": "Startpunkt der Kurve.",
    "bitbybit.verb.curve.endPoint": "Endpunkt",
    "bitbybit.verb.curve.endPoint_description": "Endpunkt der Kurve.",
    "bitbybit.verb.curve.startPoints": "Startpunkte",
    "bitbybit.verb.curve.startPoints_description": "Startpunkte der Kurven.",
    "bitbybit.verb.curve.endPoints": "Endpunkte",
    "bitbybit.verb.curve.endPoints_description": "Endpunkte der Kurven.",
    "bitbybit.verb.curve.knots": "Knoten",
    "bitbybit.verb.curve.knots_description": "Findet die Knoten der Nurbs-Kurve.",
    "bitbybit.verb.curve.lengthAtParam": "Länge an Parameter",
    "lengthAtParam": "Länge an Parameter",
    "bitbybit.verb.curve.lengthAtParam_description": "Ruft die Länge der Nurbs-Kurve bei spezifischem Parameter ab.",
    "bitbybit.verb.curve.length": "Länge",
    "bitbybit.verb.curve.length_description": "Ruft die Länge der Nurbs-Kurve ab.",
    "bitbybit.verb.curve.paramAtLength": "Parameter an Länge",
    "paramAtLength": "Parameter an Länge",
    "bitbybit.verb.curve.paramAtLength_description": "Ruft den Param bei angegebener Länge auf der Nurbs-Kurve ab.",
    "bitbybit.verb.curve.pointAtParam": "Punkt an Parameter",
    "pointAtParam": "Punkt an Parameter",
    "bitbybit.verb.curve.pointAtParam_description": "Ruft den Punkt bei angegebenem Parameter auf der Nurbs-Kurve ab.",
    "bitbybit.verb.curve.pointsAtParam": "Punkte an Parameter",
    "pointsAtParam": "Punkte an Parameter",
    "bitbybit.verb.curve.pointsAtParam_description": "Ruft die Punkte bei angegebenem Parameter auf den Nurbs-Kurven ab.",
    "bitbybit.verb.curve.reverse": "umkehren",
    "bitbybit.verb.curve.reverse_description": "Kehrt die Nurbs-Kurve um.",
    "bitbybit.verb.curve.split": "teilen",
    "bitbybit.verb.curve.split_description": "Teilt die Nurbs-Kurve in zwei bei einem gegebenen Parameter.",
    "bitbybit.verb.curve.tangent": "Tangente",
    "bitbybit.verb.curve.tangent_description": "Tangente der Nurbs-Kurve bei einem gegebenen Parameter.",
    "bitbybit.verb.curve.tessellate": "tessellieren",
    "tessellate": "tessellieren",
    "bitbybit.verb.curve.tessellate_description": "Tesselliert die Nurbs-Kurve in eine Liste von Punkten.",
    "bitbybit.verb.curve.transform": "transformieren",
    "bitbybit.verb.curve.transform_description": "Transformiert die Nurbs-Kurve.",
    "bitbybit.verb.curve.transformCurves": "Kurven transformieren",
    "transformCurves": "Kurven transformieren",
    "bitbybit.verb.curve.transformCurves_description": "Transformiert die Nurbs-Kurven.",
    "bitbybit.verb.curve.weights": "Gewichte",
    "bitbybit.verb.curve.weights_description": "Gewichte der Nurbs-Kurve.",
    "bitbybit.verb.curve.circle.createCircle": "Kreis",
    "createCircle": "Kreis",
    "bitbybit.verb.curve.circle.createCircle_description": "Erstellt die Kreis-Nurbs-Kurve.",
    "xAxis": "X-Achse",
    "yAxis": "Y-Achse",
    "bitbybit.verb.curve.circle.createArc": "Bogen",
    "createArc": "Bogen",
    "bitbybit.verb.curve.circle.createArc_description": "Erstellt die Bogen-Nurbs-Kurve.",
    "minAngle": "minimaler Winkel",
    "maxAngle": "maximaler Winkel",
    "bitbybit.verb.curve.circle.center": "Mittelpunkt",
    "bitbybit.verb.curve.circle.center_description": "Ruft den Mittelpunkt des Kreises oder eines Bogens ab.",
    "bitbybit.verb.curve.circle.radius": "Radius",
    "bitbybit.verb.curve.circle.radius_description": "Ruft den Radius des Kreises oder eines Bogens ab.",
    "bitbybit.verb.curve.circle.maxAngle": "maximaler Winkel",
    "bitbybit.verb.curve.circle.maxAngle_description": "Ruft den maximalen Winkel des Bogens in Grad ab.",
    "bitbybit.verb.curve.circle.minAngle": "minimaler Winkel",
    "bitbybit.verb.curve.circle.minAngle_description": "Ruft den minimalen Winkel des Bogens in Grad ab.",
    "bitbybit.verb.curve.circle.xAxis": "X-Achse",
    "bitbybit.verb.curve.circle.xAxis_description": "Ruft den X-Winkel des Bogens ab.",
    "bitbybit.verb.curve.circle.yAxis": "Y-Achse",
    "bitbybit.verb.curve.circle.yAxis_description": "Ruft den Y-Winkel des Bogens ab.",
    "bitbybit.verb.curve.ellipse.createEllipse": "Ellipse",
    "createEllipse": "Ellipse",
    "bitbybit.verb.curve.ellipse.createEllipse_description": "Erstellt die Ellipsen-Nurbs-Kurve.",
    "bitbybit.verb.curve.ellipse.createArc": "Bogen",
    "bitbybit.verb.curve.ellipse.createArc_description": "Erstellt die Ellipsenbogen-Nurbs-Kurve.",
    "bitbybit.verb.curve.ellipse.center": "Mittelpunkt",
    "bitbybit.verb.curve.ellipse.center_description": "Ruft den Mittelpunkt der Ellipse oder eines Bogens ab.",
    "bitbybit.verb.curve.ellipse.maxAngle": "maximaler Winkel",
    "bitbybit.verb.curve.ellipse.maxAngle_description": "Ruft den maximalen Winkel des Bogens in Grad ab.",
    "bitbybit.verb.curve.ellipse.minAngle": "minimaler Winkel",
    "bitbybit.verb.curve.ellipse.minAngle_description": "Ruft den minimalen Winkel des Bogens in Grad ab.",
    "bitbybit.verb.curve.ellipse.xAxis": "X-Achse",
    "bitbybit.verb.curve.ellipse.xAxis_description": "Ruft den X-Winkel des Bogens oder einer Ellipse ab.",
    "bitbybit.verb.curve.ellipse.yAxis": "Y-Achse",
    "bitbybit.verb.curve.ellipse.yAxis_description": "Ruft den Y-Winkel des Bogens oder einer Ellipse ab.",
    "bitbybit.verb.surface.boundaries": "Grenzen",
    "boundaries": "Grenzen",
    "bitbybit.verb.surface.boundaries_description": "Ruft die Grenzkanten-Nurbs-Kurven der Oberfläche in einer Liste ab.",
    "bitbybit.verb.surface.createSurfaceByCorners": "Fläche nach Ecken",
    "createSurfaceByCorners": "Fläche nach Ecken",
    "bitbybit.verb.surface.createSurfaceByCorners_description": "Erstellt die Oberfläche durch Bereitstellung von 4 Punkten als Ecken.",
    "point3": "Punkt 3",
    "point4": "Punkt 4",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights": "Fläche nach Knoten, Kontrollpunkten und Gewichten",
    "createSurfaceByKnotsControlPointsWeights": "Fläche nach Knoten, Kontrollpunkten und Gewichten",
    "bitbybit.verb.surface.createSurfaceByKnotsControlPointsWeights_description": "Erstellt die Nurbs-Oberfläche durch Bereitstellung von UV-Knoten, UV-Graden, Punkten und Gewichten.",
    "degreeU": "Grad U",
    "degreeV": "Grad V",
    "knotsU": "Knoten U",
    "knotsV": "Knoten V",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves": "Fläche durch Lofting-Kurven",
    "createSurfaceByLoftingCurves": "Fläche durch Lofting-Kurven",
    "bitbybit.verb.surface.createSurfaceByLoftingCurves_description": "Erstellt die Nurbs-Oberfläche durch Lofting von Kurven.",
    "bitbybit.verb.surface.clone": "klonen",
    "bitbybit.verb.surface.clone_description": "Klont die Nurbs-Oberfläche.",
    "bitbybit.verb.surface.closestParam": "nächster Parameter",
    "bitbybit.verb.surface.closestParam_description": "Findet den nächsten Parameter auf der Oberfläche vom Punkt.",
    "bitbybit.verb.surface.closestPoint": "nächster Punkt",
    "bitbybit.verb.surface.closestPoint_description": "Findet den nächsten Punkt auf der Oberfläche vom Punkt.",
    "bitbybit.verb.surface.controlPoints": "Kontrollpunkte",
    "bitbybit.verb.surface.controlPoints_description": "Ruft die Kontrollpunkte auf der Oberfläche ab.",
    "bitbybit.verb.surface.degreeU": "Grad U",
    "bitbybit.verb.surface.degreeU_description": "Ruft den U-Grad der Oberfläche ab.",
    "bitbybit.verb.surface.degreeV": "Grad V",
    "bitbybit.verb.surface.degreeV_description": "Ruft den V-Grad der Oberfläche ab.",
    "bitbybit.verb.surface.derivatives": "Ableitungen",
    "bitbybit.verb.surface.derivatives_description": "Ruft die Ableitungen der Oberfläche bei spezifischer UV-Koordinate ab.",
    "u": "U",
    "v": "V",
    "bitbybit.verb.surface.domainU": "Domäne U",
    "domainU": "Domäne U",
    "bitbybit.verb.surface.domainU_description": "Ruft den U-Definitionsbereich der Oberfläche ab.",
    "bitbybit.verb.surface.domainV": "Domäne V",
    "domainV": "Domäne V",
    "bitbybit.verb.surface.domainV_description": "Ruft den V-Definitionsbereich der Oberfläche ab.",
    "bitbybit.verb.surface.isocurve": "Isokurve",
    "isocurve": "Isokurve",
    "bitbybit.verb.surface.isocurve_description": "Ruft die Nurbs-Isokurve auf der Oberfläche ab.",
    "useV": "V verwenden",
    "bitbybit.verb.surface.isocurvesSubdivision": "Isokurven-Unterteilung",
    "isocurvesSubdivision": "Isokurven-Unterteilung",
    "bitbybit.verb.surface.isocurvesSubdivision_description": "Unterteilt Oberfläche in bevorzugte Anzahl von Isokurven.",
    "isocurveSegments": "Isokurven-Segmente",
    "bitbybit.verb.surface.isocurvesAtParams": "Isokurven an Parametern",
    "isocurvesAtParams": "Isokurven an Parametern",
    "bitbybit.verb.surface.isocurvesAtParams_description": "Unterteilt Oberfläche in Isokurven an angegebenem Array von Parametern.",
    "parameters": "Parameter",
    "bitbybit.verb.surface.knotsU": "Knoten U",
    "bitbybit.verb.surface.knotsU_description": "Ruft die U-Knoten der Oberfläche ab.",
    "bitbybit.verb.surface.knotsV": "Knoten V",
    "bitbybit.verb.surface.knotsV_description": "Ruft die V-Knoten der Oberfläche ab.",
    "bitbybit.verb.surface.normal": "Normale",
    "bitbybit.verb.surface.normal_description": "Ruft die Normale auf der Oberfläche bei UV-Koordinate ab.",
    "bitbybit.verb.surface.point": "Punkt",
    "bitbybit.verb.surface.point_description": "Ruft den Punkt auf der Oberfläche bei UV-Koordinate ab.",
    "bitbybit.verb.surface.reverse": "umkehren",
    "bitbybit.verb.surface.reverse_description": "Kehrt die Nurbs-Oberfläche um. Dies kehrt den UV-Ursprung und Isokurven-Richtungen um.",
    "bitbybit.verb.surface.split": "teilen",
    "bitbybit.verb.surface.split_description": "Teilt die Nurbs-Oberfläche in zwei Hälften.",
    "bitbybit.verb.surface.transformSurface": "Fläche transformieren",
    "transformSurface": "Fläche transformieren",
    "bitbybit.verb.surface.transformSurface_description": "Transformiert die Nurbs-Oberfläche mit einer gegebenen Liste von Transformationen.",
    "bitbybit.verb.surface.weights": "Gewichte",
    "bitbybit.verb.surface.weights_description": "Ruft die Gewichte der Oberfläche ab.",
    "bitbybit.verb.surface.cone.create": "erstellen",
    "cone": "Kegel",
    "bitbybit.verb.surface.cone.create_description": "Erstellt die konische Nurbs-Oberfläche.",
    "bitbybit.verb.surface.cone.axis": "Achse",
    "bitbybit.verb.surface.cone.axis_description": "Ruft Kegelachse ab.",
    "bitbybit.verb.surface.cone.base": "Basis",
    "bitbybit.verb.surface.cone.base_description": "Ruft Kegelbasis ab.",
    "bitbybit.verb.surface.cone.height": "Höhe",
    "bitbybit.verb.surface.cone.height_description": "Ruft Kegelhöhe ab.",
    "bitbybit.verb.surface.cone.radius": "Radius",
    "bitbybit.verb.surface.cone.radius_description": "Ruft Kegelradius ab.",
    "bitbybit.verb.surface.cone.xAxis": "X-Achse",
    "bitbybit.verb.surface.cone.xAxis_description": "Ruft Kegel-X-Achse ab.",
    "bitbybit.verb.surface.cylinder.create": "erstellen",
    "bitbybit.verb.surface.cylinder.create_description": "Erstellt die zylindrische Nurbs-Oberfläche.",
    "bitbybit.verb.surface.cylinder.axis": "Achse",
    "bitbybit.verb.surface.cylinder.axis_description": "Ruft Zylinderachse ab.",
    "bitbybit.verb.surface.cylinder.base": "Basis",
    "bitbybit.verb.surface.cylinder.base_description": "Ruft Zylinderbasis ab.",
    "bitbybit.verb.surface.cylinder.height": "Höhe",
    "bitbybit.verb.surface.cylinder.height_description": "Ruft Zylinderhöhe ab.",
    "bitbybit.verb.surface.cylinder.radius": "Radius",
    "bitbybit.verb.surface.cylinder.radius_description": "Ruft Zylinderradius ab.",
    "bitbybit.verb.surface.cylinder.xAxis": "X-Achse",
    "bitbybit.verb.surface.cylinder.xAxis_description": "Ruft Zylinder-X-Achse ab.",
    "bitbybit.verb.surface.extrusion.create": "erstellen",
    "extrusion": "Extrusion",
    "bitbybit.verb.surface.extrusion.create_description": "Erstellt die Nurbs-Oberflächenextrusion aus der Kurve.",
    "profile": "Profil",
    "bitbybit.verb.surface.extrusion.direction": "Richtung",
    "bitbybit.verb.surface.extrusion.direction_description": "Ruft den Richtungsvektor der Extrusion ab.",
    "bitbybit.verb.surface.extrusion.profile": "Profil",
    "bitbybit.verb.surface.extrusion.profile_description": "Ruft die Profil-Nurbs-Kurve der Extrusion ab.",
    "bitbybit.verb.surface.sphere.create": "erstellen",
    "bitbybit.verb.surface.sphere.create_description": "Erstellt die sphärische Nurbs-Oberfläche.",
    "bitbybit.verb.surface.sphere.radius": "Radius",
    "bitbybit.verb.surface.sphere.radius_description": "Ruft den Radius der sphärischen Nurbs-Oberfläche ab.",
    "bitbybit.verb.surface.sphere.center": "Mittelpunkt",
    "bitbybit.verb.surface.sphere.center_description": "Ruft den Mittelpunkt der sphärischen Nurbs-Oberfläche ab.",
    "bitbybit.verb.surface.revolved.create": "erstellen",
    "revolved": "rotierend",
    "bitbybit.verb.surface.revolved.create_description": "Erstellt die rotierte Nurbs-Oberfläche.",
    "bitbybit.verb.surface.revolved.profile": "Profil",
    "bitbybit.verb.surface.revolved.profile_description": "Ruft die Profil-Nurbs-Kurve der rotierten Nurbs-Oberfläche ab.",
    "revolution": "Rotation",
    "bitbybit.verb.surface.revolved.center": "Mittelpunkt",
    "bitbybit.verb.surface.revolved.center_description": "Ruft die Mittelpunkts-Nurbs-Kurve der rotierten Nurbs-Oberfläche ab.",
    "bitbybit.verb.surface.revolved.axis": "Achse",
    "bitbybit.verb.surface.revolved.axis_description": "Ruft die Rotationsachse der rotierten Nurbs-Oberfläche ab.",
    "bitbybit.verb.surface.revolved.angle": "Winkel",
    "bitbybit.verb.surface.revolved.angle_description": "Ruft den Rotationswinkel von rotierter Nurbs-Oberfläche ab.",
    "bitbybit.verb.surface.sweep.create": "erstellen",
    "sweep": "Schwenk",
    "bitbybit.verb.surface.sweep.create_description": "Erstellt die Sweep-Nurbs-Oberfläche.",
    "rail": "Schiene",
    "bitbybit.verb.surface.sweep.profile": "Profil",
    "bitbybit.verb.surface.sweep.profile_description": "Ruft die Profil-Nurbs-Kurve der gesweepten Nurbs-Oberfläche ab.",
    "bitbybit.verb.surface.sweep.rail": "Schiene",
    "bitbybit.verb.surface.sweep.rail_description": "Ruft die Schienen-Nurbs-Kurve der gesweepten Nurbs-Oberfläche ab.",
    "bitbybit.verb.intersect.curves": "Kurven",
    "bitbybit.verb.intersect.curves_description": "Schneidet zwei Verb-Nurbs-Kurven miteinander und gibt Schnittergebnisse zurück.",
    "firstCurve": "erste Kurve",
    "secondCurve": "zweite Kurve",
    "bitbybit.verb.intersect.curveAndSurface": "Kurve und Fläche",
    "curveAndSurface": "Kurve und Fläche",
    "bitbybit.verb.intersect.curveAndSurface_description": "schneidet eine Kurve und eine Fläche",
    "bitbybit.verb.intersect.surfaces": "Flächen",
    "bitbybit.verb.intersect.surfaces_description": "schneidet zwei Flächen",
    "firstSurface": "erste Fläche",
    "secondSurface": "zweite Fläche",
    "bitbybit.verb.intersect.curveCurveFirstParams": "Kurve-Kurve erste Parameter",
    "curveCurveFirstParams": "Kurve-Kurve erste Parameter",
    "bitbybit.verb.intersect.curveCurveFirstParams_description": "Ruft Schnittparameter auf der ersten Kurve aus Kurve-Kurve-Schnitt ab.",
    "intersections": "Schnittpunkte",
    "BaseTypes.CurveCurveIntersection[]": "Basis-Typen Kurve-Kurve-Schnitt-Array",
    "bitbybit.verb.intersect.curveCurveSecondParams": "Kurve-Kurve zweite Parameter",
    "curveCurveSecondParams": "Kurve-Kurve zweite Parameter",
    "bitbybit.verb.intersect.curveCurveSecondParams_description": "Ruft Schnittparameter auf der zweiten Kurve aus Kurve-Kurve-Schnitt ab.",
    "bitbybit.verb.intersect.curveCurveFirstPoints": "Kurve-Kurve erste Punkte",
    "curveCurveFirstPoints": "Kurve-Kurve erste Punkte",
    "bitbybit.verb.intersect.curveCurveFirstPoints_description": "Ruft Schnittpunkte auf der ersten Kurve aus Kurve-Kurve-Schnitt ab.",
    "bitbybit.verb.intersect.curveCurveSecondPoints": "Kurve-Kurve zweite Punkte",
    "curveCurveSecondPoints": "Kurve-Kurve zweite Punkte",
    "bitbybit.verb.intersect.curveCurveSecondPoints_description": "Ruft Schnittpunkte auf der zweiten Kurve aus Kurve-Kurve-Schnitt ab.",
    "bitbybit.verb.intersect.curveSurfaceCurveParams": "Kurve-Fläche Kurvenparameter",
    "curveSurfaceCurveParams": "Kurve-Fläche Kurvenparameter",
    "bitbybit.verb.intersect.curveSurfaceCurveParams_description": "Ruft Schnittparameter auf der Kurve aus Kurve-Oberfläche-Schnitt ab.",
    "BaseTypes.CurveSurfaceIntersection[]": "Basis-Typen Kurve-Fläche-Schnitt-Array",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams": "Kurve-Fläche Flächenparameter",
    "curveSurfaceSurfaceParams": "Kurve-Fläche Flächenparameter",
    "bitbybit.verb.intersect.curveSurfaceSurfaceParams_description": "Ruft Schnittparameter auf der Oberfläche aus Kurve-Oberfläche-Schnitt ab.",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints": "Kurve-Fläche Kurvenpunkte",
    "curveSurfaceCurvePoints": "Kurve-Fläche Kurvenpunkte",
    "bitbybit.verb.intersect.curveSurfaceCurvePoints_description": "Ruft Schnittpunkte auf der Kurve aus Kurve-Oberfläche-Schnitt ab.",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints": "Kurve-Fläche Flächenpunkte",
    "curveSurfaceSurfacePoints": "Kurve-Fläche Flächenpunkte",
    "bitbybit.verb.intersect.curveSurfaceSurfacePoints_description": "Ruft Schnittpunkte auf der Oberfläche aus Kurve-Oberfläche-Schnitt ab.",
    "bitbybit.tag.create": "erstellen",
    "tag": "Tag",
    "bitbybit.tag.create_description": "Erstellt ein Tag-DTO.",
    "adaptDepth": "Tiefe anpassen",
    "needsUpdate": "muss aktualisiert werden",
    "bitbybit.time.registerRenderFunction": "Render-Funktion registrieren",
    "registerRenderFunction": "Render-Funktion registrieren",
    "bitbybit.time.registerRenderFunction_description": "Registriert eine Funktion für die Renderschleife.",
    "bitbybit.asset.getFile": "Datei abrufen",
    "asset": "Asset",
    "getFile": "Datei abrufen",
    "bitbybit.asset.getFile_description": "Ruft die Asset-Datei ab.",
    "bitbybit.asset.getLocalFile": "lokale Datei abrufen",
    "getLocalFile": "lokale Datei abrufen",
    "bitbybit.asset.getLocalFile_description": "Ruft die lokale Asset-Datei ab, die in Ihrem Browser gespeichert ist.",
    "bitbybit.asset.fetchBlob": "Blob abrufen",
    "fetchBlob": "Blob abrufen",
    "bitbybit.asset.fetchBlob_description": "Ruft den Blob von der gegebenen URL ab, muss ein CORS-aktivierter zugänglicher Endpunkt sein.",
    "fetch": "abrufen",
    "bitbybit.asset.fetchFile": "Datei abrufen",
    "fetchFile": "Datei abrufen",
    "bitbybit.asset.fetchFile_description": "Ruft die Datei von der gegebenen URL ab, muss ein CORS-aktivierter zugänglicher Endpunkt sein.",
    "bitbybit.asset.fetchJSON": "JSON abrufen",
    "fetchJSON": "JSON abrufen",
    "bitbybit.asset.fetchJSON_description": "Ruft das JSON von der gegebenen URL ab, muss ein CORS-aktivierter zugänglicher Endpunkt sein.",
    "bitbybit.asset.fetchText": "Text abrufen",
    "fetchText": "Text abrufen",
    "bitbybit.asset.fetchText_description": "Ruft den Text von der gegebenen URL ab, muss ein CORS-aktivierter zugänglicher Endpunkt sein.",
    "bitbybit.asset.createObjectURL": "Objekt-URL",
    "createObjectURL": "Objekt-URL",
    "bitbybit.asset.createObjectURL_description": "Ruft den URL-String-Pfad zu Ihrer im Speicher gespeicherten Datei ab und erstellt ihn.",
    "file": "Datei",
    "File | Blob": "Datei oder Blob",
    "bitbybit.asset.createObjectURLs": "Objekt-URLs",
    "createObjectURLs": "Objekt-URLs",
    "bitbybit.asset.createObjectURLs_description": "Ruft die URL-String-Pfade zu Ihren im Speicher gespeicherten Dateien ab und erstellt sie.",
    "files": "Dateien",
    "(File | Blob)[]": "Datei- oder Blob-Array",
    "exec": "ausführen",
    "Visible": "Sichtbar",
    "Hidden": "Versteckt",
    "flatten": "flatten",
    "force exec": "erzwinge Ausführung",
    "console log": "Konsolenprotokoll",
    "preview data": "Daten-Vorschau",
    "flow": "Ablauf",
    "code": "Code",
    "runner": "Runner",
    "counters": "Zähler",
    "actions": "Aktionen",
    "loops": "Schleifen",
    "interval": "Intervall",
    "delay": "Verzögerung",
    "expire": "ablaufen",
    "timeout": "Timeout",
    "counter min max": "Zähler Min Max",
    "counter steps": "Zähler Schritte",
    "reset": "zurücksetzen",
    "trigger": "auslösen",
    "mouse": "Maus",
    "mouse click": "Mausklick",
    "key": "Taste",
    "pointer": "Zeiger",
    "pick info": "Auswahl-Info",
    "down": "unten",
    "wheel": "Rad",
    "tap": "Tippen",
    "double tap": "Doppeltippen",
    "render": "rendern",
    "passed ms": "vergangene ms",
    "babylon observable listener": "Babylon Observable Listener",
    "object": "Objekt",
    "observable selector": "Observable-Auswahl",
    "get event data": "Ereignisdaten abrufen",
    "exec click": "Klick ausführen",
    "exec down": "unten ausführen",
    "toggle": "umschalten",
    "flip flop": "Flip-Flop",
    "boolean gate": "Boolean-Gatter",
    "boolean gate silent": "stilles Boolean-Gatter",
    "is undefined": "ist undefiniert",
    "for loop": "For-Schleife",
    "last": "letzte",
    "for each loop": "For-Each-Schleife",
    "element": "Element",
    "body": "Körper",
    "complete": "abgeschlossen",
    "editors": "Editoren",
    "inputs": "Eingaben",
    "outputs": "Ausgaben",
    "recent": "kürzlich",
    "Clear": "Löschen",
    "Run": "Ausführen",
    "Swap Canvas": "Canvas tauschen",
    "Local Assets": "Lokale Assets",
    "Import": "Importieren",
    "Copy to Clipboard": "In die Zwischenablage kopieren",
    "Paste from Clipboard": "Aus der Zwischenablage einfügen",
    "Export": "Exportieren",
    "Export to runner": "Zum Runner exportieren",
    "Clean Cache": "Cache bereinigen",
    "Community": "Gemeinschaft",
    "Sponsors and Partners": "Sponsoren und Partner",
    "API Documentation": "API-Dokumentation",
    "About": "Über",
    "Toolbox": "Werkzeugkasten",
    "More": "Mehr",
    "bitbybit.code.typeScriptEditor": "TypeScript-Editor",
    "bitbybit.code.typeScriptEditor_description": "Ermöglicht das Schreiben von TypeScript-Code mit vollständiger Bitbybit-Intellisense in einer Funktion. Was die Startfunktion zurückgibt, wird als Ausgabe der Komponente betrachtet.",
    "bitbybit.code.javaScriptEditor": "JavaScript-Editor",
    "bitbybit.code.javaScriptEditor_description": "Ermöglicht das Schreiben von JavaScript-Code in einer Funktion. Was die Startfunktion zurückgibt, wird als Ausgabe der Komponente betrachtet.",
    "bitbybit.code.jsonEditor": "JSON-Editor",
    "bitbybit.code.jsonEditor_description": "Ermöglicht das Schreiben von JSON-Code. Was die Startfunktion zurückgibt, wird als Ausgabe der Komponente betrachtet.",
    "bitbybit.flow.actions.keyboard": "Tastatur",
    "bitbybit.flow.actions.keyboard_description": "Wird bei Tastaturereignissen durch Klicken auf die Schaltflächen ausgeführt.",
    "bitbybit.flow.actions.mouseClick": "Mausklick",
    "bitbybit.flow.actions.mouseClick_description": "Wird bei Mausereignissen durch Klicken auf die Schaltflächen ausgeführt.",
    "bitbybit.flow.actions.start": "Start",
    "bitbybit.flow.actions.start_description": "Startet den Kontrollfluss und löst Ausführungen aus.",
    "bitbybit.flow.actions.trigger": "Auslösen",
    "bitbybit.flow.actions.trigger_description": "Löst die Ausführung durch Klicken auf die Schaltfläche aus.",
    "bitbybit.flow.babylon.gui.button": "Schaltfläche",
    "bitbybit.flow.babylon.gui.button_description": "Wird bei verschiedenen Zeigerereignissen durch Klicken mit der linken Maustaste auf die BabylonJS-Canvas ausgeführt.",
    "bitbybit.flow.babylon.scene.pointerEvents": "Zeiger",
    "bitbybit.flow.babylon.scene.pointerEvents_description": "Wird bei verschiedenen Zeigerereignissen durch Klicken mit der linken Maustaste auf die BabylonJS-Canvas ausgeführt.",
    "bitbybit.flow.babylon.getEventDataFromObservedResult": "Ereignisdaten abrufen",
    "bitbybit.flow.babylon.getEventDataFromObservedResult_description": "Ruft Ereignisdaten aus dem beobachteten Ergebnis des Observable-Listeners ab.",
    "bitbybit.flow.babylon.observableListener": "Babylon Observable Listener",
    "bitbybit.flow.babylon.observableListener_description": "Abonniert und lauscht auf beliebige BabylonJS-Observables.",
    "bitbybit.flow.babylon.render": "Rendern",
    "bitbybit.flow.babylon.render_description": "Wird bei jedem BabylonJS-Render-Frame ausgeführt.",
    "bitbybit.flow.counters.counterMinMax": "Zähler Min Max",
    "bitbybit.flow.counters.counterMinMax_description": "Zählt die Anzahl der Flussausführungen zwischen Min- und Max-Werten. Bei Erreichen von Max wird zurückgesetzt.",
    "bitbybit.flow.counters.counterSteps": "Zähler Schritte",
    "bitbybit.flow.counters.counterSteps_description": "Zählt die Anzahl der Flussausführungen, beginnend bei einem gegebenen Zählwert und erhöht sich bei jeder Ausführung um einen gegebenen Schritt aus der Liste, bis die Schritte abgeschlossen sind. Am Ende wird zurückgesetzt.",
    "bitbybit.flow.counters.counter": "Zähler",
    "bitbybit.flow.counters.counter_description": "Zählt die Anzahl der Flussausführungen.",
    "bitbybit.flow.logic.booleanGateSilent": "stilles Boolean-Gatter",
    "bitbybit.flow.logic.booleanGateSilent_description": "Löst unterschiedliche Ausführungsereignisse basierend auf dem bereitgestellten Boolean-Wert aus, führt jedoch nur aus, wenn sich der Boolean-Wert ändert, um mehrfaches Auslösen von Ereignissen zu verhindern, obwohl keine Änderung stattgefunden hat.",
    "bitbybit.flow.logic.booleanGate": "Boolean-Gatter",
    "bitbybit.flow.logic.booleanGate_description": "Löst unterschiedliche Ausführungsereignisse basierend auf dem bereitgestellten Boolean-Wert aus.",
    "bitbybit.flow.logic.flipFlop": "Flip-Flop",
    "bitbybit.flow.logic.flipFlop_description": "Bei jedem ausgeführten Ereignis wird ein anderes Ereignis ausgelöst, wodurch im Wesentlichen eine Umschaltfunktion erstellt wird.",
    "bitbybit.flow.logic.isUndefined": "ist undefiniert",
    "bitbybit.flow.logic.isUndefined_description": "Prüft, ob der bereitgestellte Wert undefiniert ist und löst ein wahr- oder falsch-Ereignis aus.",
    "bitbybit.flow.loops.forEach": "For-Each-Schleife",
    "bitbybit.flow.loops.forEach_description": "For-Each-Schleife, die alle Elemente in der Liste durchläuft.",
    "bitbybit.flow.loops.for": "For-Schleife",
    "bitbybit.flow.loops.for_description": "For-Schleife, die den Körper zwischen zwei Werten ausführt.",
    "bitbybit.flow.time.delay": "Verzögerung",
    "bitbybit.flow.time.delay_description": "Verzögert die Ausführung um den angegebenen Timeout in Millisekunden.",
    "bitbybit.flow.time.interval": "Intervall",
    "bitbybit.flow.time.interval_description": "Führt den Fluss in jedem angegebenen Intervall in Millisekunden aus.",
    "bitbybit.lists.createList": "Liste erstellen",
    "bitbybit.lists.createList_description": "Erstellt eine Liste aus den gegebenen Elementen.",
    "bitbybit.lists.flatten": "flatten",
    "bitbybit.lists.flatten_description": "Flacht die Liste von Listen in eine einzige Liste ab.",
    "bitbybit.lists.passThrough": "durchlaufen",
    "bitbybit.lists.passThrough_description": "Wandelt den Wert in den Typ 'any' um und leitet die Eingabe unverändert an die Ausgabe weiter.",
    "bitbybit.math.numberSlider": "Zahlenschieberegler",
    "bitbybit.math.numberSlider_description": "Erstellt eine Zahl mit einem Schieberegler. Sie können Min-, Max- und Schrittwerte festlegen.",
    "bitbybit.consoleLog": "Konsolenprotokoll",
    "bitbybit.consoleLog_description": "Protokolliert die Eingabe in der Browser-Konsole.",
    "bitbybit.previewData": "Daten-Vorschau",
    "bitbybit.previewData_description": "Zeigt die Eingabedaten in einem Vorschauübersichtsbereich an. Es können Texte, Zahlen, JSON-Objekte, Arrays usw. sein. Zirkuläre JavaScript-Objekte sind nicht erlaubt.",
    "bitbybit.runner.getRunnerInputValue": "Runner-Eingabewert abrufen",
    "bitbybit.runner.getRunnerInputValue_description": "Ruft den Runner-Eingabewert aus dem Eingabe-JSON ab. Diese Komponente gibt im Editor-Kontext immer einen undefinierten Wert zurück.",
    "bitbybit.runner.getRunnerInputs": "Runner-Eingaben abrufen",
    "bitbybit.runner.getRunnerInputs_description": "Ruft die Runner-Eingaben in JSON ab. Diese Komponente gibt im Editor-Kontext immer ein leeres Objekt zurück.",
    "bitbybit.runner.run": "ausführen",
    "bitbybit.runner.run_description": "Führt Runner-JavaScript-Code aus",
    "bitbybit.runner.setRunnerResult": "Runner-Ergebnis setzen",
    "bitbybit.runner.setRunnerResult_description": "Setzt das vollständige JSON-Ergebnis für den Runner. Beachten Sie, dass es sicherer ist, Werte zu setzen, da diese Methode das gesamte Ergebnisobjekt mit dem bereitgestellten Wert überschreibt.",
    "bitbybit.runner.setRunnerResultArrayValue": "Runner-Ergebnis-Array-Wert setzen",
    "bitbybit.runner.setRunnerResultArrayValue_description": "Setzt den Runner-Ergebniswert auf die Eigenschaft eines JSON-Objekts. Jeder Wert wird zu einem Array hinzugefügt, das der Wert der Eigenschaft ist.",
    "bitbybit.runner.setRunnerResultValue": "Runner-Ergebniswert setzen",
    "bitbybit.runner.setRunnerResultValue_description": "Setzt den Runner-Ergebniswert auf die Eigenschaft eines JSON-Objekts.",
    "bitbybit.text.areaCreate": "Textbereich",
    "bitbybit.text.areaCreate_description": "Erstellt einen Textbereich im Editor. Sie können den Text, die Breite und die Höhe des Bereichs festlegen.",
    "update on drag": "bei Ziehen aktualisieren",
    "paste": "einfügen",
    "duplicate": "duplizieren",
    "delete": "löschen",
    "keyboard": "Tastatur",
    "data": "Daten",
    "observables": "Observables",
    "buttons": "Schaltflächen",
    "variables": "Variablen",
    "functions": "Funktionen",
    "loop": "Schleife",
    "apply": "anwenden",
    "async context": "asynchroner Kontext",
    "async context description": "Erstellt einen asynchronen Kontext, der Await-Komponenten verwenden kann, was die Ausführung und Lesbarkeit von asynchronem Code vereinfacht.",
    "then": "dann",
    "await": "warten",
    "await description": "Wartet, bis das Promise aufgelöst ist, und gibt den Wert zurück.",
    "when the": "wenn das",
    "error": "Fehler",
    "happens in the promise": "im Promise auftritt",
    "catch": "fangen",
    "catch description": "Fängt Fehler ab, die bei der Ausführung von asynchronem Code auftreten können. Der Benutzer kann Fehler entsprechend behandeln.",
    "cancel the interval execution": "Intervallausführung abbrechen",
    "cancel the interval description": "Bricht die Intervallausführung ab, indem der Handler bereitgestellt wird.",
    "cancel the timeout execution": "Timeout-Ausführung abbrechen",
    "cancel the timeout description": "Bricht die Timeout-Ausführung ab, indem der Handler bereitgestellt wird.",
    "key down": "Taste gedrückt",
    "key down descritpion": "Löst Code aus, wenn das Ereignis 'Taste gedrückt' eintritt.",
    "key up": "Taste losgelassen",
    "key up description": "Löst Code aus, wenn das Ereignis 'Taste losgelassen' eintritt.",
    "key press": "Tastendruck",
    "key press description": "Löst Code aus, wenn das Ereignis 'Tastendruck' eintritt.",
    "is key pressed": "ist Taste gedrückt",
    "block_validation_required": "muss angegeben werden",
    "block_validation_of_length": "muss die Anzahl der Elemente enthalten",
    "block_validation_higher_or_equal": "muss größer oder gleich sein",
    "block_validation_lower_or_equal": "muss kleiner oder gleich sein",
    "block_validation_range": "muss im Bereich liegen",
    "block_validation_smaller_than": "muss kleiner sein als",
    "block_validation_smaller_or_equal_than": "muss kleiner oder gleich sein als",
    "block_validation_larger_than": "muss größer sein als",
    "block_validation_larger_or_equal_than": "muss größer oder gleich sein als",
    "save text to file": "Text in Datei speichern",
    "save text to file description": "Speichert Text in eine Datei und ermöglicht es Ihnen, den Namen und die Erweiterung zu wählen. Diese Komponente zeigt den Text nicht in der Vorschau an und kann in Situationen verwendet werden, in denen der Text zu groß ist, um im Textbereichsfeld bearbeitet zu werden.",
    "print text on screen": "Text auf Bildschirm ausgeben",
    "print text on screen description": "Gibt Text auf dem Bildschirm aus. Diese Komponente ist nützlich für Debugging-Zwecke.",
    "preview text and save to file": "Text-Vorschau und in Datei speichern",
    "preview text and save to file description": "Gibt Text auf dem Bildschirm aus und ermöglicht es Ihnen, ihn in eine Datei zu speichern. Diese Komponente ist nützlich für Debugging-Zwecke.",
    "register render loop listener": "Render-Schleifen-Listener registrieren",
    "and update": "und aktualisieren",
    "register render loop listener description": "Führt die Anweisung in der Render-Schleife aus und gibt an, wie viel Zeit seit dem letzten Frame in der Variable timeElapsedFromPreviousFrame vergangen ist.",
    "timeElapsedFromPreviousFrame_var": "zeitSeitVorherigemFrame",
    "computing": "Berechnung",
    "result": "Ergebnis",
    "of promise is returned": "des Promise wird zurückgegeben",
    "on pointer up": "bei Zeiger hoch",
    "on pointer move": "bei Zeigerbewegung",
    "on pointer down": "bei Zeiger runter",
    "of babylonjs observable object": "des BabylonJS Observable-Objekts",
    "observable name": "Observable-Name",
    "is key pressed description": "Prüft, ob die Taste gedrückt ist, und gibt wahr oder falsch zurück.",
    "execute code after": "Code ausführen nach",
    "execute code after description": "Führt den Code nach dem angegebenen Timeout in Sekunden aus.",
    "execute code every": "Code ausführen alle",
    "second(s)": "Sekunde(n)",
    "execute code every description": "Führt den Code in jedem angegebenen Intervall in Sekunden aus.",
    "handler": "Handler",
    "workers initialising": "Worker initialisieren",
    "Assets": "Assets",
    "Local assets stored in browser cache:": "Lokale Assets im Browser-Cache gespeichert:",
    "Asset Name": "Asset-Name",
    "Name is required": "Name ist erforderlich",
    "Asset with this name already exists, choose a different one": "Asset mit diesem Namen existiert bereits, wählen Sie einen anderen",
    "Allowed file formats:": "Erlaubte Dateiformate:",
    "You must select an asset file": "Sie müssen eine Asset-Datei auswählen",
    "Upload Local Asset": "Lokales Asset hochladen",
    "File Name": "Dateiname",
    "File Size": "Dateigröße",
    "Your browser does not support indexDB and you can't upload local asset files.": "Ihr Browser unterstützt kein IndexDB und Sie können keine lokalen Asset-Dateien hochladen.",
    "Upload": "Hochladen",
    "elements": "Elemente",
    "bitbybit.vector.vectorsTheSame": "Vektoren gleich",
    "vectorsTheSame": "Vektoren gleich",
    "bitbybit.vector.vectorsTheSame_description": "Prüft, ob zwei Vektoren innerhalb einer gegebenen Toleranz gleich sind (berücksichtigt Fließkomma-Genauigkeit). Beispiel: [1,2,3] vs [1.0001,2.0001,3.0001] mit Toleranz 0.001 → true",
    "vec1": "Vektor 1",
    "vec2": "Vektor 2",
    "bitbybit.point.boundingBoxOfPoints": "Begrenzungsrahmen der Punkte",
    "boundingBoxOfPoints": "Begrenzungsrahmen der Punkte",
    "bitbybit.point.boundingBoxOfPoints_description": "Berechnet achsenausgerichteten Begrenzungsrahmen, der alle Punkte enthält (min, max, center, width, height, length). Beispiel: Punkte=[[0,0,0], [10,5,3]] → {min:[0,0,0], max:[10,5,3], center:[5,2.5,1.5], width:10, height:5, length:3}",
    "bitbybit.point.normalFromThreePoints": "Normale aus drei Punkten",
    "normalFromThreePoints": "Normale aus drei Punkten",
    "bitbybit.point.normalFromThreePoints_description": "Berechnet Normalenvektor aus drei Punkten unter Verwendung des Kreuzprodukts (senkrecht zur Ebene). Beispiel: p1=[0,0,0], p2=[1,0,0], p3=[0,1,0] → [0,0,1] (zeigt von XY-Ebene nach oben)",
    "reverseNormal": "umgekehrte Normale",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions": "Linienzug mit Verlängerungen",
    "createLineWireWithExtensions": "Linienzug mit Verlängerungen",
    "bitbybit.occt.shapes.wire.createLineWireWithExtensions_description": "Erstellt einen OpenCascade Linienzug mit Verlängerungen",
    "extensionStart": "Verlängerungsstart",
    "extensionEnd": "Verlängerungsende",
    "bitbybit.occt.shapes.wire.midPointOnWire": "Mittelpunkt auf Linienzug",
    "midPointOnWire": "Mittelpunkt auf Linienzug",
    "bitbybit.occt.shapes.wire.midPointOnWire_description": "Berechnet den Mittelpunkt auf dem Linienzug beim Parameter 0.5",
    "centerOnOrigin": "Im Ursprung zentrieren",
    "bitbybit.occt.shapes.wire.textWiresWithData": "Text-Linienzüge mit Daten",
    "textWiresWithData": "Text-Linienzüge mit Daten",
    "bitbybit.occt.shapes.wire.textWiresWithData_description": "Erstellt ein OpenCascade Kompositum aus Text-Linienzügen und liefert zusätzliche Informationen basierend auf der von Dr. A. V. Hershey erstellten Simplex-Schriftart",
    "bitbybit.occt.transforms.alignNormAndAxis": "Normale und Achse ausrichten",
    "alignNormAndAxis": "Normale und Achse ausrichten",
    "bitbybit.occt.transforms.alignNormAndAxis_description": "Richtet die Form an Normale und Achse aus",
    "fromNorm": "Von Normale",
    "fromAx": "Von Achse",
    "toNorm": "Zu Normale",
    "toAx": "Zu Achse",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension": "einfache lineare Längenbemaßung",
    "simpleLinearLengthDimension": "einfache lineare Längenbemaßung",
    "bitbybit.occt.dimensions.simpleLinearLengthDimension_description": "Erstellt einfache lineare Längenbemaßung zwischen zwei Punkten - Messeinheiten. Sie entscheiden, welche Art von Einheiten Sie verwenden, indem Sie ein Suffix angeben.",
    "offsetFromPoints": "Versatz von Punkten",
    "crossingSize": "Kreuzungsgröße",
    "labelSuffix": "Beschriftungssuffix",
    "labelSize": "Beschriftungsgröße",
    "labelOffset": "Beschriftungsversatz",
    "bitbybit.occt.dimensions.simpleAngularDimension": "einfache Winkelbemaßung",
    "simpleAngularDimension": "einfache Winkelbemaßung",
    "bitbybit.occt.dimensions.simpleAngularDimension_description": "Erstellt eine einfache Winkelbemaßung. Standardmäßig werden Grad ausgegeben, Sie können sich aber auch für die Verwendung von Radiant entscheiden.",
    "direction1": "Richtung 1",
    "direction2": "Richtung 2",
    "offsetFromCenter": "Versatz vom Mittelpunkt",
    "extraSize": "Zusätzliche Größe",
    "radians": "Radiant",
    "bitbybit.occt.dimensions.pinWithLabel": "Pin mit Beschriftung",
    "pinWithLabel": "Pin mit Beschriftung",
    "bitbybit.occt.dimensions.pinWithLabel_description": "Erstellt ein Pin-Label. Es kann verwendet werden, um Dinge über Modelle zu erklären oder Dinge in der 3D-Szene zu markieren.",
    "offsetFromStart": "Versatz vom Startpunkt",
    "bitbybit.vector.lengthSq": "Länge zum Quadrat",
    "lengthSq": "Länge zum Quadrat",
    "bitbybit.vector.lengthSq_description": "Berechnet die quadrierte Länge (quadrierte Größe) eines 3D-Vektors. Beispiel: [3,4,0] → 25 (Länge 5 im Quadrat)",
    "bitbybit.point.twoPointsAlmostEqual": "zwei Punkte gleich",
    "twoPointsAlmostEqual": "zwei Punkte gleich",
    "bitbybit.point.twoPointsAlmostEqual_description": "Prüft, ob zwei Punkte innerhalb der Toleranz annähernd gleich sind (distanzbasierter Vergleich). Beispiel: Punkt1=[1.0000001, 2.0, 3.0], Punkt2=[1.0, 2.0, 3.0], Toleranz=1e-6 → true",
    "bitbybit.line.lineToSegment": "Linie zu Segment",
    "lineToSegment": "Linie zu Segment",
    "bitbybit.line.lineToSegment_description": "Konvertiert Linienobjekt in Segment-Array-Format. Beispiel: {start:[0,0,0], end:[10,5,0]} → [[0,0,0], [10,5,0]]",
    "bitbybit.line.linesToSegments": "Linien zu Segmenten",
    "linesToSegments": "Linien zu Segmenten",
    "bitbybit.line.linesToSegments_description": "Konvertiert mehrere Linienobjekte in Segment-Array-Format (Batch-Konvertierung). Beispiel: 3 Linienobjekte → 3 Segment-Arrays [[start1, end1], [start2, end2], ...]",
    "bitbybit.line.segmentToLine": "Segment zu Linie",
    "segmentToLine": "Segment zu Linie",
    "bitbybit.line.segmentToLine_description": "Konvertiert Segment-Array in Linienobjekt-Format. Beispiel: [[0,0,0], [10,5,0]] → {start:[0,0,0], end:[10,5,0]}",
    "segment": "Segment",
    "Base.Segment3": "Base.Segment3",
    "bitbybit.line.segmentsToLines": "Segmente zu Linien",
    "segmentsToLines": "Segmente zu Linien",
    "bitbybit.line.segmentsToLines_description": "Konvertiert mehrere Segment-Arrays in Linienobjekt-Format (Batch-Konvertierung). Beispiel: 3 Segment-Arrays → 3 Linienobjekte mit Start-/Endeigenschaften",
    "Base.Segment3[]": "Base.Segment3[]",
    "bitbybit.polyline.sortSegmentsIntoPolylines": "Segmente zu Polylinien sortieren",
    "sortSegmentsIntoPolylines": "Segmente zu Polylinien sortieren",
    "bitbybit.polyline.sortSegmentsIntoPolylines_description": "Sortiert durcheinandergebrachte Segmente in verbundene Polylinien durch Abgleich der Endpunkte. Verwendet räumliches Hashing für effiziente Verbindungssuche. Beispiel: 10 zufällige Segmente, die 2 verbundene Pfade bilden → 2 Polylinien",
    "sort": "sortieren",
    "bitbybit.mesh.signedDistanceToPlane": "vorzeichenbehafteter Abstand zur Ebene",
    "signedDistanceToPlane": "vorzeichenbehafteter Abstand zur Ebene",
    "bitbybit.mesh.signedDistanceToPlane_description": "Berechnet vorzeichenbehafteten Abstand von einem Punkt zu einer Ebene (positiv=über Ebene, negativ=unter Ebene). Beispiel: Punkt=[0,5,0], Ebene={normal:[0,1,0], d:0} → 5 (Punkt ist 5 Einheiten über XZ-Ebene)",
    "plane": "Ebene",
    "Base.TrianglePlane3": "Base.TrianglePlane3",
    "bitbybit.mesh.calculateTrianglePlane": "Dreiecksebene berechnen",
    "calculateTrianglePlane": "Dreiecksebene berechnen",
    "bitbybit.mesh.calculateTrianglePlane_description": "Berechnet Ebenengleichung aus Dreiecksvertices (Normalenvektor und Abstand vom Ursprung). Gibt undefiniert zurück, wenn Dreieck entartet ist (Nullfläche, kollineare Punkte). Beispiel: Dreieck=[[0,0,0], [1,0,0], [0,1,0]] → {normal:[0,0,1], d:0} (XY-Ebene)",
    "triangle": "Dreieck",
    "Base.Triangle3": "Base.Triangle3",
    "bitbybit.mesh.triangleTriangleIntersection": "Dreieck-Dreieck-Schnittpunkt",
    "triangleTriangleIntersection": "Dreieck-Dreieck-Schnittpunkt",
    "bitbybit.mesh.triangleTriangleIntersection_description": "Berechnet Schnittsegment zweier Dreiecke (Liniensegment, wo sie sich kreuzen). Gibt undefiniert zurück, wenn Dreiecke sich nicht schneiden, parallel oder koplanar sind. Beispiel: Dreieck1=[[0,0,0], [2,0,0], [1,2,0]], Dreieck2=[[1,-1,1], [1,1,1], [1,1,-1]] → [[1,0,0], [1,1,0]]",
    "triangle1": "Dreieck 1",
    "triangle2": "Dreieck 2",
    "bitbybit.mesh.meshMeshIntersectionSegments": "Netz-Netz-Schnittsegmente",
    "meshMeshIntersectionSegments": "Netz-Netz-Schnittsegmente",
    "bitbybit.mesh.meshMeshIntersectionSegments_description": "Berechnet alle Schnittsegmente zwischen zwei Dreiecks-Meshes (paarweise Dreieckstests). Gibt Array von Liniensegmenten zurück, wo Mesh-Oberflächen sich schneiden. Beispiel: Würfel-Mesh schneidet Kugel-Mesh → mehrere Segmente bilden Schnittkurve",
    "mesh1": "Netz 1",
    "Base.Mesh3": "Base.Mesh3",
    "mesh2": "Netz 2",
    "bitbybit.mesh.meshMeshIntersectionPolylines": "Netz-Netz-Schnittpolylinien",
    "meshMeshIntersectionPolylines": "Netz-Netz-Schnittpolylinien",
    "bitbybit.mesh.meshMeshIntersectionPolylines_description": "Berechnet Schnittpolylinien zwischen zwei Meshes durch Sortieren von Segmenten in verbundene Pfade. Segmente werden Ende-an-Ende verbunden, um kontinuierliche oder geschlossene Kurven zu bilden. Beispiel: Würfel-Kugel-Schnitt → geschlossene Polylinienschleifen, wo Oberflächen sich treffen",
    "bitbybit.occt.shapeFacesToPolygonPoints": "Formflächen zu Polygonpunkten",
    "shapeFacesToPolygonPoints": "Formflächen zu Polygonpunkten",
    "bitbybit.occt.shapeFacesToPolygonPoints_description": "Erstellt Polygonpunkte aus den Formflächen",
    "reversedPoints": "umgekehrte Punkte",
    "bitbybit.occt.shapeToMesh": "Form zu Netz",
    "shapeToMesh": "Form zu Netz",
    "bitbybit.occt.shapeToMesh_description": "Erstellt ein Netz aus der Form",
    "bitbybit.occt.shapesToMeshes": "Formen zu Netzen",
    "shapesToMeshes": "Formen zu Netzen",
    "bitbybit.occt.shapesToMeshes_description": "Erstellt ein Netz aus der Form",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints": "aus Polygonpunkten",
    "bitbybit.manifold.manifold.shapes.fromPolygonPoints_description": "Erstellen Sie einen Manifold aus einer Reihe von Polygonpunkten, die Dreiecke beschreiben.",
    "traingle": "Dreieck",
    "bitbybit.point.stretchPointsDirFromCenter": "Punkte in Richtung vom Zentrum strecken",
    "stretchPointsDirFromCenter": "Punkte in Richtung vom Zentrum strecken",
    "bitbybit.point.stretchPointsDirFromCenter_description": "Streckt mehrere Punkte entlang einer Richtung von einem Mittelpunkt (gerichtete Skalierung). Beispiel: Punkte=[[10,0,0]], Zentrum=[0,0,0], Richtung=[1,0,0], Skala=2 → [[20,0,0]]",
    "bitbybit.point.hexGridScaledToFit": "Angepasstes Sechseckraster",
    "hexGridScaledToFit": "Angepasstes Sechseckraster",
    "bitbybit.point.hexGridScaledToFit_description": "Erstellt sechseckiges Gitter, skaliert, um in die angegebenen Breiten-/Höhenbegrenzungen zu passen (berechnet Sechseckgröße automatisch). Gibt Mittelpunkte und Sechseckvertices zurück. Unterstützt Ausrichtung mit Spitze oben oder flacher Seite oben. Beispiel: Breite=10, Höhe=10, nrHexagonsInHeight=3 → Sechseckgitter füllt 10×10 Bereich mit 3 Reihen",
    "nrHexagonsU": "Anz. Sechsecke U",
    "nrHexagonsV": "Anz. Sechsecke V",
    "extendTop": "oben erweitern",
    "extendBottom": "unten erweitern",
    "extendLeft": "links erweitern",
    "extendRight": "rechts erweitern",
    "centerGrid": "Raster zentrieren",
    "bitbybit.point.sortPoints": "Punkte sortieren",
    "sortPoints": "Punkte sortieren",
    "bitbybit.point.sortPoints_description": "Sortiert Punkte lexikographisch (nach X-, dann Y-, dann Z-Koordinaten). Beispiel: [[5,0,0], [1,0,0], [3,0,0]] → [[1,0,0], [3,0,0], [5,0,0]]",
    "bitbybit.line.lineLineIntersection": "Schnittpunkt Linie-Linie",
    "lineLineIntersection": "Schnittpunkt Linie-Linie",
    "bitbybit.line.lineLineIntersection_description": "Berechnet Schnittpunkt zweier Linien (oder Segmente, wenn checkSegmentsOnly=true). Gibt undefiniert zurück, wenn Linien parallel, windschief sind oder Segmente sich nicht überlappen. Beispiel: Linie1={start:[0,0,0], end:[10,0,0]}, Linie2={start:[5,-5,0], end:[5,5,0]} → [5,0,0]",
    "line1": "Linie 1",
    "line2": "Linie 2",
    "checkSegmentsOnly": "nur Segmente prüfen",
    "bitbybit.polyline.polylineToLines": "Polylinie zu Linien",
    "polylineToLines": "Polylinie zu Linien",
    "bitbybit.polyline.polylineToLines_description": "Konvertiert Polylinie in Liniensegmente (jedes Segment als Linienobjekt mit Start/Ende). Geschlossene Polylinien schließen Schlusssegment ein. Beispiel: 3 Punkte → 2 oder 3 Linien (abhängig von isClosed)",
    "bitbybit.polyline.polylineToSegments": "Polylinie zu Segmenten",
    "polylineToSegments": "Polylinie zu Segmenten",
    "bitbybit.polyline.polylineToSegments_description": "Konvertiert Polylinie in Segment-Arrays (jedes Segment als [Punkt1, Punkt2]). Geschlossene Polylinien schließen Schlusssegment ein, wenn Endpunkte unterschiedlich sind. Beispiel: 4 Punkte, geschlossen → 4 Segmente verbinden alle Punkte in einer Schleife",
    "bitbybit.polyline.polylineSelfIntersection": "Selbstschnitt Polylinie",
    "polylineSelfIntersection": "Selbstschnitt Polylinie",
    "bitbybit.polyline.polylineSelfIntersection_description": "Findet Punkte, an denen sich die Polylinie selbst kreuzt (Selbstschnittpunkte). Überspringt benachbarte Segmente und dedupliziert nahe Punkte. Beispiel: Achterförmige Polylinie → gibt mittleren Kreuzungspunkt zurück",
    "bitbybit.polyline.twoPolylineIntersection": "Schnitt zweier Polylinien",
    "twoPolylineIntersection": "Schnitt zweier Polylinien",
    "bitbybit.polyline.twoPolylineIntersection_description": "Findet Schnittpunkte zwischen zwei Polylinien (alle Segment-Segment-Kreuzungen). Testet alle Segmentpaare und dedupliziert nahe Punkte. Beispiel: Sich kreuzende Polylinien bilden ein X → gibt mittleren Schnittpunkt zurück",
    "polyline1": "Polylinie 1",
    "polyline2": "Polylinie 2",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires": "in Sechseck-Drähte unterteilen",
    "subdivideToHexagonWires": "in Sechseck-Drähte unterteilen",
    "bitbybit.occt.shapes.face.subdivideToHexagonWires_description": "Unterteilt eine Fläche in Sechseck-Drähte",
    "extendUUp": "U oben erweitern",
    "extendUBottom": "U unten erweitern",
    "extendVUp": "V oben erweitern",
    "extendVBottom": "V unten erweitern",
    "nrHexagonsInHeight": "Anz. Sechsecke Höhe",
    "nrHexagonsInWidth": "Anz. Sechsecke Breite",
    "bitbybit.vector.length": "Vektorlänge",
    "bitbybit.vector.length_description": "Berechnet die Länge (Größe) eines 3D-Vektors. Beispiel: [3,4,0] → 5, [1,0,0] → 1",
    "bitbybit.point.maxFilletRadius": "max. Verrundungsradius",
    "maxFilletRadius": "max. Verrundungsradius",
    "bitbybit.point.maxFilletRadius_description": "Berechnet den maximal möglichen Verrundungsradius an einer Ecke, die von zwei Liniensegmenten mit gemeinsamem Endpunkt (C) gebildet wird, sodass der Verrundungsbogen tangential zu beiden Segmenten verläuft und vollständig innerhalb dieser liegt.",
    "bitbybit.point.maxFilletRadiusHalfLine": "max. Verrundungsradius halbe Linie",
    "maxFilletRadiusHalfLine": "max. Verrundungsradius halbe Linie",
    "bitbybit.point.maxFilletRadiusHalfLine_description": "Berechnet den maximal möglichen Verrundungsradius an einer Ecke C, sodass der Verrundungsbogen tangential zu beiden Segmenten (P1-C, P2-C) verläuft und die Tangentialpunkte innerhalb der ersten Hälfte jedes Segments (gemessen von C) liegen.",
    "bitbybit.point.maxFilletsHalfLine": "max. Verrundungen halbe Linie",
    "maxFilletsHalfLine": "max. Verrundungen halbe Linie",
    "bitbybit.point.maxFilletsHalfLine_description": "Berechnet den maximal möglichen Verrundungsradius an jeder Ecke einer Polylinie, die durch eine Reihe von Punkten gebildet wird. Der Verrundungsradius wird für jede innere Ecke und optional für die Schließecken berechnet, wenn die Polylinie geschlossen ist.",
    "checkLastWithFirst": "letztes mit erstem prüfen",
    "bitbybit.point.safestPointsMaxFilletHalfLine": "sicherster max. Verrundungsradius (Punkte, halbe Linie)",
    "safestPointsMaxFilletHalfLine": "sicherster max. Verrundungsradius (Punkte, halbe Linie)",
    "bitbybit.point.safestPointsMaxFilletHalfLine_description": "Berechnet den einzelnen sichersten maximalen Verrundungsradius, der basierend auf der 'halbe Linie'-Beschränkung einheitlich auf alle Ecken einer Punktsammlung angewendet werden kann. Dieser wird durch Ermittlung des Minimums der für jede einzelne Ecke berechneten maximal möglichen Verrundungsradien bestimmt.",
    "bitbybit.polyline.maxFilletsHalfLine": "max. Verrundungen halbe Linie",
    "bitbybit.polyline.maxFilletsHalfLine_description": "Berechnet den maximal möglichen 'halbe Linie'-Verrundungsradius für jede Ecke einer gegebenen Polylinie. Bei einer geschlossenen Polylinie schließt dies die Ecken ein, die das letzte Segment mit dem ersten verbinden. Die Berechnung verwendet die 'halbe Linie'-Beschränkung, was bedeutet, dass die Tangentialpunkte der Verrundung innerhalb der ersten Hälfte jedes mit der Ecke verbundenen Segments liegen müssen.",
    "bitbybit.polyline.safestFilletRadius": "sicherster Verrundungsradius",
    "safestFilletRadius": "sicherster Verrundungsradius",
    "bitbybit.polyline.safestFilletRadius_description": "Berechnet den einzelnen sichersten maximalen Verrundungsradius, der basierend auf der 'halbe Linie'-Beschränkung einheitlich auf alle Ecken einer Polylinie angewendet werden kann. Dieser wird durch Ermittlung des Minimums der für jede einzelne Ecke berechneten maximal möglichen Verrundungsradien bestimmt.",
    "flatTop": "flache Oberseite",
    "bitbybit.mesh.meshMeshIntersectionPoints": "Schnittpunkte Netz-Netz",
    "meshMeshIntersectionPoints": "Schnittpunkte Netz-Netz",
    "bitbybit.mesh.meshMeshIntersectionPoints_description": "Berechnet Schnittpunkte zwischen zwei Meshes als Punkt-Arrays (ein Array pro Polylinie). Geschlossene Polylinien haben ersten Punkt am Ende dupliziert. Beispiel: Würfel-Kugel-Schnitt → Arrays von Punkten definieren Schnittkurven",
    "bitbybit.occt.shapes.wire.hexagonsInGrid": "Sechsecke im Raster",
    "hexagonsInGrid": "Sechsecke im Raster",
    "bitbybit.occt.shapes.wire.hexagonsInGrid_description": "Erstellt OpenCascade Sechseck-Drähte im Raster",
    "scalePatternWidth": "Musterbreite skalieren",
    "scalePatternHeight": "Musterhöhe skalieren",
    "bitbybit.occt.booleans.meshMeshIntersectionWires": "Schnittdrähte Netz-Netz",
    "meshMeshIntersectionWires": "Schnittdrähte Netz-Netz",
    "bitbybit.occt.booleans.meshMeshIntersectionWires_description": "Führt eine Netz-Netz-Schnittoperation zwischen zwei Formen durch - beide Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Drähte des Schnitts zurück, die Polylinien oder Polygone sind.",
    "mesh based": "Netzbasiert",
    "precision1": "Präzision 1",
    "precision2": "Präzision 2",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints": "Schnittpunkte Netz-Netz",
    "bitbybit.occt.booleans.meshMeshIntersectionPoints_description": "Führt eine Netz-Netz-Schnittoperation zwischen zwei Formen durch - beide Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Punkte des Schnitts zurück.",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires": "Netz-Netz-Schnitt zu Drähten",
    "meshMeshIntersectionOfShapesWires": "Netz-Netz-Schnitt zu Drähten",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesWires_description": "Führt eine Netz-Netz-Schnittoperation zwischen der Form und mehreren anderen Formen durch - alle Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Drähte des Schnitts zurück, die Polylinien oder Polygone sind.",
    "precisionShapes": "Präzision Formen",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints": "Netz-Netz-Schnitt zu Punkten",
    "meshMeshIntersectionOfShapesPoints": "Netz-Netz-Schnitt zu Punkten",
    "bitbybit.occt.booleans.meshMeshIntersectionOfShapesPoints_description": "Führt eine Netz-Netz-Schnittoperation zwischen der Form und mehreren anderen Formen durch - alle Formen können ihre eigene Vernetzungspräzision haben. Dieser Algorithmus schneidet die Netze und gibt die Punkte des Schnitts zurück.",
    "bitbybit.occt.shapes.face.hexagonsInGrid": "Sechsecke im Raster",
    "bitbybit.occt.shapes.face.hexagonsInGrid_description": "Erstellt OpenCascade Sechsecke im Raster (als Flächen)",
    "bitbybit.jscad.toPolygonPoints": "zu Polygonpunkten",
    "toPolygonPoints": "zu Polygonpunkten",
    "bitbybit.jscad.toPolygonPoints_description": "Konvertiert das JSCAD-Mesh in Polygonpunkte, die Dreiecke des Meshes darstellen.",
    "conversions": "Umwandlungen",
    "bitbybit.manifold.toPolygonPoints": "zu Polygonpunkten",
    "bitbybit.manifold.toPolygonPoints_description": "Wandelt eine Manifold-Form in eine Sammlung von Polygonpunkten um, die das Netz darstellen.",
    "flatU": "flaches U",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles": "in Sechseck-Löcher unterteilen",
    "subdivideToHexagonHoles": "in Sechseck-Löcher unterteilen",
    "bitbybit.occt.shapes.face.subdivideToHexagonHoles_description": "Unterteilt eine Fläche in Sechseck-Löcher",
    "bitbybit.verb.curve.convertLinesToNurbsCurves": "Linien in NURBS-Kurven konvertieren",
    "bitbybit.verb.curve.convertLinesToNurbsCurves_description": "Konvertiert Linien in NURBS-Kurven. Gibt ein Array von verbnurbs Line-Objekten zurück.",
    "bitbybit.verb.curve.convertLineToNurbsCurve": "Linie in NURBS-Kurve konvertieren",
    "convertLineToNurbsCurve": "Linie in NURBS-Kurve konvertieren",
    "bitbybit.verb.curve.convertLineToNurbsCurve_description": "Konvertiert eine Linie in eine NURBS-Kurve. Gibt das verbnurbs Line-Objekt zurück.",
    "Base.Line3": "Base.Line3",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve": "Polylinie in NURBS-Kurve konvertieren",
    "convertPolylineToNurbsCurve": "Polylinie in NURBS-Kurve konvertieren",
    "bitbybit.verb.curve.convertPolylineToNurbsCurve_description": "Konvertiert eine Polylinie in eine NURBS-Kurve. Gibt das verbnurbs NurbsCurve-Objekt zurück.",
    "Base.Polyline3": "Base.Polyline3",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves": "Polylinien in NURBS-Kurven konvertieren",
    "convertPolylinesToNurbsCurves": "Polylinien in NURBS-Kurven konvertieren",
    "bitbybit.verb.curve.convertPolylinesToNurbsCurves_description": "Konvertiert Polylinien in NURBS-Kurven. Gibt die verbnurbs NurbsCurve-Objekte zurück.",
    "Base.Polyline3[]": "Base.Polyline3[]",
    "bitbybit.line.createSegment": "Segment",
    "createSegment": "Segment",
    "bitbybit.line.createSegment_description": "Erstellt ein Segment aus zwei Punkten (Array-Format: [Start, Ende]). Beispiel: Start=[0,0,0], Ende=[10,5,0] → [[0,0,0], [10,5,0]]",
    "bitbybit.occt.shapes.edge.fromBaseLine": "Kante von Basislinie",
    "fromBaseLine": "von Basislinie",
    "bitbybit.occt.shapes.edge.fromBaseLine_description": "Erstellt eine lineare Kante aus dem Basislinienformat {start: Point3, end: Point3}",
    "from base": "von Basis",
    "bitbybit.occt.shapes.edge.fromBaseLines": "Kante von Basislinien",
    "fromBaseLines": "von Basislinien",
    "bitbybit.occt.shapes.edge.fromBaseLines_description": "Erstellt lineare Kanten aus dem Basislinienformat {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.edge.fromBaseSegment": "Kante von Basissegment",
    "fromBaseSegment": "von Basissegment",
    "bitbybit.occt.shapes.edge.fromBaseSegment_description": "Erstellt eine lineare Kante aus dem Basissegmentformat [Point3, Point3]",
    "bitbybit.occt.shapes.edge.fromBaseSegments": "Kanten von Basissegmenten",
    "fromBaseSegments": "von Basissegmenten",
    "bitbybit.occt.shapes.edge.fromBaseSegments_description": "Erstellt eine lineare Kante aus dem Basissegmentformat [Point3, Point3][]",
    "bitbybit.occt.shapes.edge.fromPoints": "Kanten von Punkten",
    "fromPoints": "von Punkten",
    "bitbybit.occt.shapes.edge.fromPoints_description": "Erstellt lineare Kanten aus einer Sammlung von Punkten",
    "bitbybit.occt.shapes.edge.fromBasePolyline": "Kanten von Basispolylinie",
    "fromBasePolyline": "von Basispolylinie",
    "bitbybit.occt.shapes.edge.fromBasePolyline_description": "Erstellt lineare Kanten aus der Polyliniendefinition",
    "bitbybit.occt.shapes.edge.fromBaseTriangle": "Kanten von Basisdreieck",
    "fromBaseTriangle": "von Basisdreieck",
    "bitbybit.occt.shapes.edge.fromBaseTriangle_description": "Erstellt lineare Kanten aus der Dreiecksdefinition",
    "bitbybit.occt.shapes.edge.fromBaseMesh": "Kanten von Basisnetz",
    "fromBaseMesh": "von Basisnetz",
    "bitbybit.occt.shapes.edge.fromBaseMesh_description": "Erstellt lineare Kanten aus der Netzdefinition",
    "bitbybit.occt.shapes.wire.fromBaseLine": "Draht von Basislinie",
    "bitbybit.occt.shapes.wire.fromBaseLine_description": "Erstellt einen linearen Draht aus dem Basislinienformat {start: Point3, end: Point3}",
    "bitbybit.occt.shapes.wire.fromBaseLines": "Drähte von Basislinien",
    "bitbybit.occt.shapes.wire.fromBaseLines_description": "Erstellt lineare Drähte aus dem Basislinienformat {start: Point3, end: Point3}[]",
    "bitbybit.occt.shapes.wire.fromBaseSegment": "Draht von Basissegment",
    "bitbybit.occt.shapes.wire.fromBaseSegment_description": "Erstellt einen linearen Draht aus dem Basissegmentformat [Point3, Point3]",
    "bitbybit.occt.shapes.wire.fromBaseSegments": "Drähte von Basissegmenten",
    "bitbybit.occt.shapes.wire.fromBaseSegments_description": "Erstellt lineare Drähte aus dem Basissegmentformat [Point3, Point3][]",
    "bitbybit.occt.shapes.wire.fromPoints": "Draht von Punkten",
    "bitbybit.occt.shapes.wire.fromPoints_description": "Erstellt Draht aus einer Sammlung von Punkten",
    "bitbybit.occt.shapes.wire.fromBasePolyline": "Draht von Basispolylinie",
    "bitbybit.occt.shapes.wire.fromBasePolyline_description": "Erstellt Draht aus der Polyliniendefinition",
    "bitbybit.occt.shapes.wire.fromBaseTriangle": "Draht von Basisdreieck",
    "bitbybit.occt.shapes.wire.fromBaseTriangle_description": "Erstellt Draht aus der Dreiecksdefinition",
    "bitbybit.occt.shapes.wire.fromBaseMesh": "Drähte von Basisnetz",
    "bitbybit.occt.shapes.wire.fromBaseMesh_description": "Erstellt Drähte aus der Netzdefinition",
    "bitbybit.occt.shapes.face.fromBaseTriangle": "Fläche von Basisdreieck",
    "bitbybit.occt.shapes.face.fromBaseTriangle_description": "Erstellt Fläche aus der Dreiecksdefinition",
    "bitbybit.occt.shapes.face.fromBaseMesh": "Flächen von Basisnetz",
    "bitbybit.occt.shapes.face.fromBaseMesh_description": "Erstellt Flächen aus der Netzdefinition",
    "fromRightHanded": "von rechtshändig",
    "bitbybit.advanced.text3d.createWithUrl": "Text mit URL",
    "createWithUrl": "Text mit URL",
    "bitbybit.advanced.text3d.createWithUrl_description": "Erstellt einen 3D-Text mit einer Schriftart-URL. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Generierung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere schlechte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "fontUrl": "Schriftart-URL",
    "bitbybit.advanced.text3d.createTextOnFaceUrl": "Text auf Fläche URL",
    "createTextOnFaceUrl": "Text auf Fläche URL",
    "bitbybit.advanced.text3d.createTextOnFaceUrl_description": "Erstellt einen 3D-Text auf der Fläche unter Verwendung einer Schriftart-URL. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Erzeugung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere fehlerhafte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftartformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl": "Texte auf Fläche URL",
    "createTextsOnFaceUrl": "Texte auf Fläche URL",
    "bitbybit.advanced.text3d.createTextsOnFaceUrl_description": "Erstellt 3D-Texte auf der Fläche aus mehreren URL-Definitionen. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Generierung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere schlechte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "Text3DFaceDefinitionUrlDto[]": "Text3DFaceDefinitionUrlDto[]",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl": "Definition 3D-Text auf Fläche URL",
    "definition3dTextOnFaceUrl": "Definition 3D-Text auf Fläche URL",
    "bitbybit.advanced.text3d.definition3dTextOnFaceUrl_description": "Erstellt 3D-Text, der auf der Flächen-URL-Definition verwendet wird. Dies ist nützlich, wenn Sie eine benutzerdefinierte Schriftart verwenden möchten, die nicht in der Bibliothek enthalten ist. Die Schriftart wird von der angegebenen URL geladen und zur Generierung des 3D-Textes verwendet. Stellen Sie sicher, dass Schriftarten keine Selbstüberschneidungen und andere schlechte Zeichen enthalten - das ist ein häufiges Problem bei benutzerdefinierten Schriftarten. Unterstützte Schriftformate sind: ttf, otf, woff. Bitte beachten Sie, dass Woff2 von opentype.js nicht unterstützt wird, da es sich um ein komprimiertes Format handelt.",
    "bitbybit.advanced.navigation.pointOfInterest": "Interessanter Punkt",
    "navigation": "Navigation",
    "pointOfInterest": "Interessanter Punkt",
    "bitbybit.advanced.navigation.pointOfInterest_description": "Erstellt Point of Interest - anklickbarer Indikator im 3D-Raum, der verwendet werden kann, um die Kamera an einen bestimmten Ort mit vordefinierter Kameraposition und Ziel zu fliegen. Point of Interest kann mit PointOfInterestStyleDto gestylt und mit Pulseffekt animiert werden. Point of Interest kann auch eine Textbeschriftung haben.",
    "cameraTarget": "Kameraziel",
    "cameraPosition": "Kameraposition",
    "bitbybit.advanced.navigation.pointsOfInterestSystem": "System für interessante Punkte",
    "pointsOfInterestSystem": "System für interessante Punkte",
    "bitbybit.advanced.navigation.pointsOfInterestSystem_description": "",
    "pointsOfInterest": "Interessante Punkte",
    "PointOfInterestDto[]": "PointOfInterestDto[]",
    "point of interest": "Interessanter Punkt",
    "style": "Stil",
    "PointOfInterestStyleDto": "PointOfInterestStyleDto",
    "bitbybit.advanced.navigation.pointOfInterestStyle": "Stil für interessante Punkte",
    "pointOfInterestStyle": "Stil für interessante Punkte",
    "bitbybit.advanced.navigation.pointOfInterestStyle_description": "Erstellen Sie einen Stil für interessante Punkte - wird verwendet, um Indikatoren für interessante Punkte im 3D-Raum zu gestalten. Sie können Punktgröße, Farbe, Hover-Farbe, Pulseffekt, Farbe und Größe der Textbeschriftung anpassen.",
    "pointSize": "Punktgröße",
    "pointColor": "Punktfarbe",
    "hoverPointColor": "Punktfarbe bei Hover",
    "pulseColor": "Pulsfarbe",
    "hoverPulseColor": "Pulsfarbe bei Hover",
    "pulseMinSize": "Minimale Pulsgröße",
    "pulseMaxSize": "Maximale Pulsgröße",
    "pulseThickness": "Pulsdicke",
    "pulseSpeed": "Pulsgeschwindigkeit",
    "textColor": "Textfarbe",
    "hoverTextColor": "Textfarbe bei Hover",
    "textSize": "Textgröße",
    "hideSkybox": "Skybox ausblenden",
    "textureUrl": "Textur-URL",
    "hdrTexture": "HDR-Textur",
    "textureSize": "Texturgröße",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture": "benutzerdefinierte Skybox-Textur aktivieren",
    "enableSkyboxCustomTexture": "benutzerdefinierte Skybox-Textur aktivieren",
    "bitbybit.babylon.scene.enableSkyboxCustomTexture_description": "Aktiviert die Skybox mit einer benutzerdefinierten Textur",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage": "Canvas CSS Hintergrundbild",
    "canvasCSSBackgroundImage": "Canvas CSS Hintergrundbild",
    "bitbybit.babylon.scene.canvasCSSBackgroundImage_description": "Ändert den Szenenhintergrund zu einem CSS-Hintergrundbild für den 3D-Raum",
    "cssBackgroundImage": "CSS Hintergrundbild",
    "bitbybit.babylon.scene.twoColorLinearGradient": "zweifarbiger linearer Gradient",
    "twoColorLinearGradient": "zweifarbiger linearer Gradient",
    "bitbybit.babylon.scene.twoColorLinearGradient_description": "Erstellt einen zweifarbigen linearen Gradientenhintergrund für den 3D-Raum",
    "colorFrom": "Farbe von",
    "colorTo": "Farbe zu",
    "Base.gradientDirectionEnum": "Base.gradientDirectionEnum",
    "stopFrom": "Stopp von",
    "stopTo": "Stopp zu",
    "bitbybit.babylon.scene.twoColorRadialGradient": "zweifarbiger radialer Gradient",
    "twoColorRadialGradient": "zweifarbiger radialer Gradient",
    "bitbybit.babylon.scene.twoColorRadialGradient_description": "Erstellt einen zweifarbigen radialen Gradientenhintergrund für den 3D-Raum",
    "Base.gradientPositionEnum": "Base.gradientPositionEnum",
    "Base.gradientShapeEnum": "Base.gradientShapeEnum",
    "bitbybit.babylon.scene.multiColorLinearGradient": "mehrfarbiger linearer Gradient",
    "multiColorLinearGradient": "mehrfarbiger linearer Gradient",
    "bitbybit.babylon.scene.multiColorLinearGradient_description": "Erstellt einen mehrfarbigen linearen Gradientenhintergrund für den 3D-Raum",
    "Base.Color[]": "Base.Color[]",
    "stops": "Stopps",
    "bitbybit.babylon.scene.multiColorRadialGradient": "mehrfarbiger radialer Gradient",
    "multiColorRadialGradient": "mehrfarbiger radialer Gradient",
    "bitbybit.babylon.scene.multiColorRadialGradient_description": "Erstellt einen mehrfarbigen radialen Gradientenhintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.canvasBackgroundImage": "Canvas Hintergrundbild",
    "canvasBackgroundImage": "Canvas Hintergrundbild",
    "bitbybit.babylon.scene.canvasBackgroundImage_description": "Setzt ein Hintergrundbild mit verschiedenen Anpassungsoptionen für den 3D-Raum",
    "imageUrl": "Bild URL",
    "Base.backgroundRepeatEnum": "Base.backgroundRepeatEnum",
    "Base.backgroundSizeEnum": "Base.backgroundSizeEnum",
    "attachment": "Anhang",
    "Base.backgroundAttachmentEnum": "Base.backgroundAttachmentEnum",
    "Base.backgroundOriginClipEnum": "Base.backgroundOriginClipEnum",
    "clip": "Ausschneiden",
    "labelRotation": "Beschriftungsrotation",
    "bitbybit.advanced.dimensions.linearDimension": "lineare Bemaßung",
    "linearDimension": "lineare Bemaßung",
    "bitbybit.advanced.dimensions.linearDimension_description": "Erstellt eine lineare Bemaßung - eine Messlinie zwischen zwei Punkten mit Hilfslinien und Textbeschriftung. Die Bemaßung zeigt den Abstand zwischen den Punkten und kann mit DimensionStyleDto gestaltet werden.",
    "linear dimension": "lineare Bemaßung",
    "DimensionStyleDto": "DimensionStyleDto",
    "bitbybit.advanced.dimensions.angularDimension": "Winkelbemaßung",
    "angularDimension": "Winkelbemaßung",
    "bitbybit.advanced.dimensions.angularDimension_description": "Erstellt eine Winkelbemaßung - einen Messbogen zwischen zwei Richtungsvektoren mit Hilfslinien und Textbeschriftung. Die Bemaßung zeigt den Winkel zwischen den Richtungen und kann mit DimensionStyleDto gestaltet werden.",
    "angular dimension": "Winkelbemaßung",
    "centerPoint": "Mittelpunkt",
    "bitbybit.advanced.dimensions.dimensionStyle": "Bemaßungsstil",
    "dimensionStyle": "Bemaßungsstil",
    "bitbybit.advanced.dimensions.dimensionStyle_description": "Erstellt einen Bemaßungsstil - wird verwendet, um Bemaßungslinien, Pfeile und Text im 3D-Raum zu gestalten. Sie können Linienfarben, Dicke, Textgröße, Pfeilgröße und Hintergrundfarben anpassen.",
    "dimension style": "Bemaßungsstil",
    "lineColor": "Linienfarbe",
    "lineThickness": "Liniendicke",
    "extensionLineLength": "Hilfslinienlänge",
    "textBackgroundColor": "Text-Hintergrundfarbe",
    "textBackgroundOpacity": "Text-Hintergrundtransparenz",
    "arrowSize": "Pfeilgröße",
    "arrowColor": "Pfeilfarbe",
    "textRenderMode": "Text-Rendermodus",
    "textRenderModeEnum": "textRenderModeEnum",
    "textBillboard": "Text-Billboard",
    "occlusionCheckInterval": "Verdeckungsüberprüfungsintervall",
    "arrowTailLength": "Pfeilschwanzlänge",
    "showArrows": "Pfeile anzeigen",
    "labelOverwrite": "Beschriftung überschreiben",
    "bitbybit.advanced.dimensions.radialDimension": "Radialbemaßung",
    "radialDimension": "Radialbemaßung",
    "bitbybit.advanced.dimensions.radialDimension_description": "Erstellt eine Radialbemaßung - eine Messlinie vom Zentrum zum Umfang, die Radius oder Durchmesser zeigt. Zeigt 'R'-Präfix für Radius oder '⌀'-Präfix für Durchmesser mit optionaler Mittelmarkierung.",
    "radial dimension": "Radialbemaßung",
    "radiusPoint": "Radiuspunkt",
    "showDiameter": "Durchmesser anzeigen",
    "showCenterMark": "Mittelmarkierung anzeigen",
    "bitbybit.advanced.dimensions.diametralDimension": "Durchmesserbemaßung",
    "diametralDimension": "Durchmesserbemaßung",
    "bitbybit.advanced.dimensions.diametralDimension_description": "Erstellt eine Durchmesserbemaßung - eine Messlinie, die den vollen Durchmesser kreisförmiger Merkmale umfasst. Zeigt '⌀'-Präfix mit optionaler Mittelmarkierung und Pfeilen an beiden Enden.",
    "diametral dimension": "Durchmesserbemaßung",
    "bitbybit.advanced.dimensions.ordinateDimension": "Koordinatenbemaßung",
    "ordinateDimension": "Koordinatenbemaßung",
    "bitbybit.advanced.dimensions.ordinateDimension_description": "Erstellt eine Koordinatenbemaßung - zeigt X-, Y- oder Z-Koordinate von einem Referenzpunkt mit Führungslinie. Nützlich für Koordinatenannotationen und Bezugsbezüge in technischen Zeichnungen.",
    "ordinate dimension": "Koordinatenbemaßung",
    "measurementPoint": "Messpunkt",
    "referencePoint": "Referenzpunkt",
    "ordinateAxisEnum": "ordinateAxisEnum",
    "showLeaderLine": "Führungslinie anzeigen",
    "viewMode": "Ansichtsmodus",
    "schema": "Schema",
    "json schema": "JSON-Schema",
    "metadata": "Metadaten",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground": "zweifarbiger linearer Farbverlaufshintergrund",
    "twoColorLinearGradientBackground": "zweifarbiger linearer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.twoColorLinearGradientBackground_description": "Erstellt einen zweifarbigen linearen Farbverlaufshintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground": "zweifarbiger radialer Farbverlaufshintergrund",
    "twoColorRadialGradientBackground": "zweifarbiger radialer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.twoColorRadialGradientBackground_description": "Erstellt einen zweifarbigen radialen Farbverlaufshintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground": "mehrfarbiger linearer Farbverlaufshintergrund",
    "multiColorLinearGradientBackground": "mehrfarbiger linearer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.multiColorLinearGradientBackground_description": "Erstellt einen mehrfarbigen linearen Farbverlaufshintergrund für den 3D-Raum",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground": "mehrfarbiger radialer Farbverlaufshintergrund",
    "multiColorRadialGradientBackground": "mehrfarbiger radialer Farbverlaufshintergrund",
    "bitbybit.babylon.scene.multiColorRadialGradientBackground_description": "Erstellt einen mehrfarbigen radialen Farbverlaufshintergrund für den 3D-Raum",
    "textBackgroundStroke": "Text-Hintergrundkontur",
    "textBackgroundRadius": "Text-Hintergrundradius",
    "stableSize": "stabile Größe",
    "alwaysOnTop": "immer oben",
    "textStableSize": "stabile Textgröße",
    "bitbybit.occt.io.shapeToDxfPaths": "Form zu DXF-Pfaden",
    "shapeToDxfPaths": "Form zu DXF-Pfaden",
    "bitbybit.occt.io.shapeToDxfPaths_description": "Erstellt DXF-Pfade aus einer OCCT-Form. Wichtig - Formen, die Drähte enthalten, müssen auf der XZ-Ebene (Y=0) liegen für korrekten 2D-DXF-Export.",
    "dxf": "DXF",
    "bitbybit.occt.io.dxfPathsWithLayer": "DXF-Pfade mit Ebene",
    "dxfPathsWithLayer": "DXF-Pfade mit Ebene",
    "bitbybit.occt.io.dxfPathsWithLayer_description": "Fügt Layer- und Farbinformationen zu DXF-Pfaden hinzu. Wichtig - Formen, die Drähte enthalten, müssen auf der XZ-Ebene (Y=0) liegen für korrekten 2D-DXF-Export.",
    "IO.DxfPathDto[]": "IO.DxfPathDto[]",
    "layer": "Ebene",
    "bitbybit.occt.io.dxfCreate": "DXF erstellen",
    "dxfCreate": "DXF erstellen",
    "bitbybit.occt.io.dxfCreate_description": "Fügt mehrere Pfadteile zu einer vollständigen DXF-Datei zusammen",
    "pathsParts": "Pfadteile",
    "IO.DxfPathsPartDto[]": "IO.DxfPathsPartDto[]",
    "textFontWeight": "Textschriftstärke",
    "textPosition": "Textposition",
    "textBackgroundStrokeThickness": "Strichstärke",
    "Inputs.Base.topBottomEnum": "Inputs.Base.topBottomEnum",
    "clear": "Löschen",
    "recompute": "Neu berechnen",
    "clear tooltip": "Alle Cache- und Komponenten löschen",
    "recompute tooltip": "Löscht den Cache und berechnet neu",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire": "I-Träger-Profil-Draht",
    "createIBeamProfileWire": "I-Träger-Profil-Draht",
    "bitbybit.occt.shapes.wire.createIBeamProfileWire_description": "Erstellt OpenCascade I-Träger-Profil-Draht",
    "beam profiles": "Trägerprofile",
    "webThickness": "Stegdicke",
    "flangeThickness": "Flanschdicke",
    "alignment": "Ausrichtung",
    "Base.basicAlignmentEnum": "Base.basicAlignmentEnum",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire": "H-Träger-Profil-Draht",
    "createHBeamProfileWire": "H-Träger-Profil-Draht",
    "bitbybit.occt.shapes.wire.createHBeamProfileWire_description": "Erstellt OpenCascade H-Träger-Profil-Draht",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire": "T-Träger-Profil-Draht",
    "createTBeamProfileWire": "T-Träger-Profil-Draht",
    "bitbybit.occt.shapes.wire.createTBeamProfileWire_description": "Erstellt OpenCascade T-Träger-Profil-Draht",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire": "U-Träger-Profil-Draht",
    "createUBeamProfileWire": "U-Träger-Profil-Draht",
    "bitbybit.occt.shapes.wire.createUBeamProfileWire_description": "Erstellt OpenCascade U-Träger-Profil-Draht",
    "flangeWidth": "Flanschbreite",
    "bitbybit.occt.shapes.face.createLPolygonFace": "L-Polygon-Fläche",
    "createLPolygonFace": "L-Polygon-Fläche",
    "bitbybit.occt.shapes.face.createLPolygonFace_description": "Erstellt OpenCascade L-Polygon-Fläche",
    "bitbybit.occt.shapes.face.createStarFace": "Stern-Fläche",
    "createStarFace": "Stern-Fläche",
    "bitbybit.occt.shapes.face.createStarFace_description": "Erstellt OpenCascade Stern-Fläche",
    "bitbybit.occt.shapes.face.createChristmasTreeFace": "Weihnachtsbaum-Fläche",
    "createChristmasTreeFace": "Weihnachtsbaum-Fläche",
    "bitbybit.occt.shapes.face.createChristmasTreeFace_description": "Erstellt OpenCascade Weihnachtsbaum-Fläche",
    "bitbybit.occt.shapes.face.createParallelogramFace": "Parallelogramm-Fläche",
    "createParallelogramFace": "Parallelogramm-Fläche",
    "bitbybit.occt.shapes.face.createParallelogramFace_description": "Erstellt OpenCascade Parallelogramm-Fläche",
    "bitbybit.occt.shapes.face.createHeartFace": "Herz-Fläche",
    "createHeartFace": "Herz-Fläche",
    "bitbybit.occt.shapes.face.createHeartFace_description": "Erstellt OpenCascade Herz-Fläche",
    "bitbybit.occt.shapes.face.createNGonFace": "N-Eck-Fläche",
    "createNGonFace": "N-Eck-Fläche",
    "bitbybit.occt.shapes.face.createNGonFace_description": "Erstellt OpenCascade N-Eck-Fläche",
    "bitbybit.occt.shapes.face.createIBeamProfileFace": "I-Träger-Profil-Fläche",
    "createIBeamProfileFace": "I-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createIBeamProfileFace_description": "Erstellt OpenCascade I-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createHBeamProfileFace": "H-Träger-Profil-Fläche",
    "createHBeamProfileFace": "H-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createHBeamProfileFace_description": "Erstellt OpenCascade H-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createTBeamProfileFace": "T-Träger-Profil-Fläche",
    "createTBeamProfileFace": "T-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createTBeamProfileFace_description": "Erstellt OpenCascade T-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createUBeamProfileFace": "U-Träger-Profil-Fläche",
    "createUBeamProfileFace": "U-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.face.createUBeamProfileFace_description": "Erstellt OpenCascade U-Träger-Profil-Fläche",
    "bitbybit.occt.shapes.solid.createStarSolid": "Stern-Körper",
    "createStarSolid": "Stern-Körper",
    "bitbybit.occt.shapes.solid.createStarSolid_description": "Erstellt OpenCascade Stern-Körper",
    "extrusionLengthFront": "Extrusionslänge vorne",
    "extrusionLengthBack": "Extrusionslänge hinten",
    "bitbybit.occt.shapes.solid.createNGonSolid": "N-Eck-Körper",
    "createNGonSolid": "N-Eck-Körper",
    "bitbybit.occt.shapes.solid.createNGonSolid_description": "Erstellt OpenCascade N-Eck-Körper",
    "bitbybit.occt.shapes.solid.createParallelogramSolid": "Parallelogramm-Körper",
    "createParallelogramSolid": "Parallelogramm-Körper",
    "bitbybit.occt.shapes.solid.createParallelogramSolid_description": "Erstellt OpenCascade Parallelogramm-Körper",
    "bitbybit.occt.shapes.solid.createHeartSolid": "Herz-Körper",
    "createHeartSolid": "Herz-Körper",
    "bitbybit.occt.shapes.solid.createHeartSolid_description": "Erstellt OpenCascade Herz-Körper",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid": "Weihnachtsbaum-Körper",
    "createChristmasTreeSolid": "Weihnachtsbaum-Körper",
    "bitbybit.occt.shapes.solid.createChristmasTreeSolid_description": "Erstellt OpenCascade Weihnachtsbaum-Körper",
    "bitbybit.occt.shapes.solid.createLPolygonSolid": "L-Polygon-Körper",
    "createLPolygonSolid": "L-Polygon-Körper",
    "bitbybit.occt.shapes.solid.createLPolygonSolid_description": "Erstellt OpenCascade L-Polygon-Körper",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid": "I-Träger-Profil-Körper",
    "createIBeamProfileSolid": "I-Träger-Profil-Körper",
    "bitbybit.occt.shapes.solid.createIBeamProfileSolid_description": "Erstellt OpenCascade I-Träger-Profil-Körper",
    "beam": "Träger",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid": "H-Träger-Profil-Körper",
    "createHBeamProfileSolid": "H-Träger-Profil-Körper",
    "bitbybit.occt.shapes.solid.createHBeamProfileSolid_description": "Erstellt OpenCascade H-Träger-Profil-Körper",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid": "T-Träger-Profil-Körper",
    "createTBeamProfileSolid": "T-Träger-Profil-Körper",
    "bitbybit.occt.shapes.solid.createTBeamProfileSolid_description": "Erstellt OpenCascade T-Träger-Profil-Körper",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid": "U-Träger-Profil-Körper",
    "createUBeamProfileSolid": "U-Träger-Profil-Körper",
    "bitbybit.occt.shapes.solid.createUBeamProfileSolid_description": "Erstellt OpenCascade U-Träger-Profil-Körper",
    "endType": "Endtyp",
    "dimensionEndTypeEnum": "dimensionEndTypeEnum",
    "arrowAngle": "Pfeilwinkel",
    "arrowsFlipped": "Pfeile umgedreht",
    "colorFormat": "Farbformat",
    "dxfColorFormatEnum": "dxfColorFormatEnum",
    "acadVersion": "Acad-Version",
    "dxfAcadVersionEnum": "dxfAcadVersionEnum",
    "bitbybit.advanced.navigation.zoomOn": "Zoomen auf",
    "zoomOn": "Zoomen auf",
    "bitbybit.advanced.navigation.zoomOn_description": "Kamera zoomen, um angegebene Netze in der Szene mit flüssiger Animation anzupassen. Funktioniert nur mit ArcRotateCamera. Animation kann unterbrochen werden, wenn mehrmals aufgerufen.",
    "animationSpeed": "Animationsgeschwindigkeit",
    "doNotUpdateMaxZ": "Max Z nicht aktualisieren",
    "bitbybit.advanced.navigation.focusFromAngle": "Fokus aus Winkel",
    "focusFromAngle": "Fokus aus Winkel",
    "bitbybit.advanced.navigation.focusFromAngle_description": "Kamera auf angegebene Netze aus einem bestimmten Winkel mit flüssiger Animation fokussieren. Berechnet das Zentrum der Begrenzungsbox aller Netze und positioniert die Kamera am angegebenen Orientierungsvektor, um auf das Zentrum zu schauen. Funktioniert nur mit ArcRotateCamera. Animation kann unterbrochen werden, wenn mehrmals aufgerufen.",
    "padding": "Polsterung",
    "shadowRefreshRate": "Schatten-Aktualisierungsrate",
    "labelFlipHorizontal": "Beschriftung horizontal spiegeln",
    "labelFlipVertical": "Beschriftung vertikal spiegeln",
    "bitbybit.advanced.navigation.zoomOnAspect": "Zoom auf Seitenverhältnis",
    "zoomOnAspect": "Zoom auf Seitenverhältnis",
    "bitbybit.advanced.navigation.zoomOnAspect_description": "Zoomt die Kamera, um die angegebenen Meshes in der Szene mit sanfter Animation anzupassen, unter Berücksichtigung des genauen Bildschirm-Seitenverhältnisses. Im Gegensatz zu zoomOn berechnet diese Methode die Kameraentfernung präzise basierend auf den Viewport-Abmessungen und der Mesh-Begrenzungsbox, um bei padding=0 eine bessere Anpassung zu gewährleisten. Funktioniert nur mit ArcRotateCamera. Animation kann unterbrochen werden, wenn mehrmals aufgerufen.",
    "bitbybit.vector.parseNumbers": "Zahlen parsen",
    "parseNumbers": "Zahlen parsen",
    "bitbybit.vector.parseNumbers_description": "Konvertiert ein Array aus als String dargestellten Zahlen in tatsächliche Zahlen. Beispiel: ['1', '2.5', '3'] → [1, 2.5, 3], ['10', '-5', '0.1'] → [10, -5, 0.1]",
    "bitbybit.manifold.manifold.operations.simplify": "vereinfachen",
    "bitbybit.manifold.manifold.operations.simplify_description": "Gibt eine Kopie des Manifolds zurück, die auf die angegebene Toleranz vereinfacht wurde, wobei der eigentliche Toleranzwert unverändert bleibt. Das Ergebnis enthält eine Teilmenge der ursprünglichen Vertices und alle Oberflächen haben sich um weniger als die Toleranz verschoben.",
    "bitbybit.manifold.manifold.operations.setProperties": "Eigenschaften festlegen",
    "setProperties": "Eigenschaften festlegen",
    "bitbybit.manifold.manifold.operations.setProperties_description": "Erstellt eine neue Kopie dieses Manifolds mit aktualisierten Vertex-Eigenschaften, indem eine Funktion bereitgestellt wird, die die vorhandene Position und Eigenschaften als Eingabe nimmt. Sie können eine beliebige Anzahl von Ausgabeeigenschaften angeben, was das Erstellen und Entfernen von Kanälen ermöglicht. Hinweis: Undefiniertes Verhalten tritt auf, wenn Sie über die Anzahl der Eingabeeigenschaften hinaus lesen oder über die Anzahl der Ausgabeeigenschaften hinaus schreiben.",
    "propFunc": "Eigenschaftsfunktion",
    "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void": "(newProp: number[], position: Base.Vector3, oldProp: number[]) => void",
    "bitbybit.manifold.manifold.transforms.warp": "verformen",
    "warp": "verformen",
    "bitbybit.manifold.manifold.transforms.warp_description": "Verschiebt die Vertices dieses Manifolds (erstellt ein neues) entsprechend einer beliebigen Eingabefunktion. Es ist leicht, eine Funktion zu erstellen, die ein geometrisch gültiges Objekt in eines verformt, das sich überschneidet, aber das wird hier nicht geprüft, daher liegt es am Benutzer, seine Funktion mit Bedacht zu wählen.",
    "warpFunc": "Verformungsfunktion",
    "(vert: Base.Vector3) => void": "(vert: Base.Vector3) => void",
    "bitbybit.manifold.manifold.evaluate.status": "Status",
    "status": "Status",
    "bitbybit.manifold.manifold.evaluate.status_description": "Gibt den Grund zurück, warum ein Eingabe-Mesh ein leeres Manifold erzeugt. Dieser Status wird durch Operationen wie NaN-Propagierung weitergegeben, um sicherzustellen, dass ein fehlerhaftes Mesh nicht mysteriös verloren geht. Leere Meshes können immer noch NoError anzeigen, zum Beispiel beim Schnitt von nicht überlappenden Meshes.",
    "bitbybit.manifold.crossSection.transforms.warp": "verformen",
    "bitbybit.manifold.crossSection.transforms.warp_description": "Verschiebt die Vertices dieser CrossSection (erstellt eine neue) entsprechend einer beliebigen Eingabefunktion, gefolgt von einer Vereinigungsoperation (mit einer positiven Füllregel), die sicherstellt, dass alle eingeführten Überschneidungen nicht im Ergebnis enthalten sind.",
    "(vert: Base.Vector2) => void": "(vert: Base.Vector2) => void",
    "bitbybit.math.roundAndRemoveTrailingZeros": "runden und nachgestellte Nullen entfernen",
    "roundAndRemoveTrailingZeros": "runden und nachgestellte Nullen entfernen",
    "bitbybit.math.roundAndRemoveTrailingZeros_description": "Rundet eine Zahl auf die angegebenen Dezimalstellen und entfernt nachgestellte Nullen. Beispiel: 1.32156 mit 3 Dezimalstellen ergibt 1.322, aber 1.320000001 ergibt 1.32, und 1.000 ergibt 1",
    "bitbybit.math.clamp": "begrenzen (clamp)",
    "clamp": "begrenzen (clamp)",
    "bitbybit.math.clamp_description": "Beschränkt einen Wert auf einen Bereich zwischen einem Minimum und einem Maximum. Beispiel: clamp(5, 0, 3) ergibt 3, clamp(-1, 0, 3) ergibt 0, clamp(1.5, 0, 3) ergibt 1.5",
    "bitbybit.math.lerp": "Lerp",
    "bitbybit.math.lerp_description": "Lineare Interpolation zwischen zwei Werten unter Verwendung des Parameters t (0 bis 1). Beispiel: Von 0 bis 100 bei t=0.5 → 50, Von 10 bis 20 bei t=0.25 → 12.5. Wenn t=0 gibt Start zurück, wenn t=1 gibt Ende zurück. Nützlich für sanfte Übergänge.",
    "t": "t",
    "bitbybit.math.inverseLerp": "inverse Lerp",
    "inverseLerp": "inverse Lerp",
    "bitbybit.math.inverseLerp_description": "Berechnet den Interpolationsparameter t für einen Wert zwischen Start und Ende (Umkehrung von Lerp). Beispiel: Wert 5 im Bereich [0,10] → t=0.5, Wert 2.5 im Bereich [0,10] → t=0.25. Gibt an, welcher t-Wert den gegebenen Wert in einer Lerp erzeugen würde. Nützlich zum Finden der relativen Position.",
    "bitbybit.math.smoothstep": "Smoothstep",
    "smoothstep": "Smoothstep",
    "bitbybit.math.smoothstep_description": "Hermite-Interpolation mit sanfter Beschleunigung und Verzögerung (weicher als lineares Lerp). Beispiel: x=0 → 0, x=0.5 → 0.5, x=1 → 1 (aber mit sanfter S-Kurve dazwischen). Die Eingabe wird automatisch auf [0,1] begrenzt. Die Ausgabe blendet sanft ein und aus. Großartig für Animationen.",
    "bitbybit.math.sign": "Vorzeichen",
    "sign": "Vorzeichen",
    "bitbybit.math.sign_description": "Gibt das Vorzeichen einer Zahl zurück: -1 für negativ, 0 für Null, 1 für positiv. Beispiel: -5 → -1, 0 → 0, 3.14 → 1. Nützlich zur Bestimmung von Richtung oder Polarität.",
    "bitbybit.math.fract": "Nachkommateil (Fract)",
    "fract": "Nachkommateil (Fract)",
    "bitbybit.math.fract_description": "Gibt den Bruchteil einer Zahl zurück (entfernt den ganzzahligen Teil, behält Dezimalstellen). Beispiel: 3.14 → 0.14, 5.9 → 0.9, -2.3 → 0.7. Nützlich für Wrapping-Werte und das Erstellen von sich wiederholenden Mustern.",
    "bitbybit.math.wrap": "Wertebereich umbrechen",
    "bitbybit.math.wrap_description": "Bricht eine Zahl innerhalb eines angegebenen Bereichs um (erzeugt einen sich wiederholenden Zyklus). Beispiel: 1.5 im Bereich [0,1) → 0.5, -0.3 im Bereich [0,1) → 0.7, 370° im Bereich [0,360) → 10°. Nützlich für Winkel, UVs oder jeden sich wiederholenden Bereich. Wie Modulo, behandelt aber negative Werte korrekt.",
    "bitbybit.math.pingPong": "Ping-Pong",
    "pingPong": "Ping-Pong",
    "bitbybit.math.pingPong_description": "Erzeugt einen Ping-Pong-Effekt (hin und her), der einen Wert zwischen 0 und length abprallen lässt. Der Wert geht von 0→length, dann zurück length→0 und wiederholt diesen Zyklus. Beispiel: Mit length=1: t=0→0, t=0.5→0.5, t=1→1 (Spitze), t=1.5→0.5, t=2→0, t=2.5→0.5 (wiederholt sich). Nützlich für das Erstellen von hüpfenden Animationen wie einem Ball oder oszillierende Bewegungen.",
    "bitbybit.math.moveTowards": "bewegen zu",
    "moveTowards": "bewegen zu",
    "bitbybit.math.moveTowards_description": "Bewegt einen Wert in Richtung eines Ziels um einen maximalen Delta-Betrag (ohne Überschwingen). Beispiel: Von 0 in Richtung 10 um max 3 → 3, Von 8 in Richtung 10 um max 3 → 10 (erreicht). Nützlich für sanfte Bewegungen mit maximalen Geschwindigkeitsbegrenzungen.",
    "current": "aktuell",
    "maxDelta": "max. Delta",
    "bitbybit.lists.getFirstItem": "erstes Element abrufen",
    "getFirstItem": "erstes Element abrufen",
    "bitbybit.lists.getFirstItem_description": "Ruft das erste Element aus der Liste ab. Beispiel: Aus [10, 20, 30, 40], gibt 10 zurück",
    "bitbybit.lists.getLastItem": "letztes Element abrufen",
    "getLastItem": "letztes Element abrufen",
    "bitbybit.lists.getLastItem_description": "Ruft das letzte Element aus der Liste ab. Beispiel: Aus [10, 20, 30, 40], gibt 40 zurück",
    "bitbybit.lists.shuffle": "mischen",
    "shuffle": "mischen",
    "bitbybit.lists.shuffle_description": "Ordnet alle Elemente in der Liste zufällig neu an (unter Verwendung des Fisher-Yates-Algorithmus). Beispiel: Aus [1, 2, 3, 4, 5] könnte [3, 1, 5, 2, 4] zurückgeben (Reihenfolge variiert jedes Mal)",
    "bitbybit.lists.includes": "enthält",
    "includes": "enthält",
    "bitbybit.lists.includes_description": "Prüft, ob die Liste ein bestimmtes Element enthält. Beispiel: Liste [10, 20, 30, 40] mit Element 30 gibt true zurück, mit Element 50 gibt false zurück",
    "bitbybit.lists.findIndex": "Index finden",
    "findIndex": "Index finden",
    "bitbybit.lists.findIndex_description": "Findet die Position (Index) des ersten Vorkommens eines Elements in der Liste. Beispiel: In [10, 20, 30, 20, 40], Finden von 20 gibt 1 zurück (erstes Vorkommen), Finden von 50 gibt -1 zurück (nicht gefunden)",
    "bitbybit.lists.removeFirstItem": "erstes Element entfernen",
    "removeFirstItem": "erstes Element entfernen",
    "bitbybit.lists.removeFirstItem_description": "Entfernt das erste Element aus der Liste. Beispiel: Aus [10, 20, 30, 40], gibt [20, 30, 40] zurück",
    "bitbybit.lists.removeLastItem": "letztes Element entfernen",
    "removeLastItem": "letztes Element entfernen",
    "bitbybit.lists.removeLastItem_description": "Entfernt das letzte Element aus der Liste. Beispiel: Aus [10, 20, 30, 40], gibt [10, 20, 30] zurück",
    "bitbybit.lists.removeItemAtIndexFromEnd": "Element am Index vom Ende entfernen",
    "removeItemAtIndexFromEnd": "Element am Index vom Ende entfernen",
    "bitbybit.lists.removeItemAtIndexFromEnd_description": "Entfernt ein Element, gezählt vom Ende der Liste (Index 0 = letztes Element, 1 = vorletztes usw.). Beispiel: Aus [10, 20, 30, 40, 50], Entfernen von Index 1 vom Ende ergibt [10, 20, 30, 50] (entfernt 40)",
    "bitbybit.lists.removeDuplicates": "Duplikate entfernen",
    "removeDuplicates": "Duplikate entfernen",
    "bitbybit.lists.removeDuplicates_description": "Entfernt doppelte Elemente aus der Liste unter Verwendung eines strikten Gleichheitsvergleichs (funktioniert mit jedem Typ). Beispiel: Aus ['a', 'b', 'c', 'a', 'd', 'b'], gibt ['a', 'b', 'c', 'd'] zurück",
    "bitbybit.lists.concatenate": "verketten",
    "concatenate": "verketten",
    "bitbybit.lists.concatenate_description": "Kombiniert mehrere Listen zu einer einzigen Liste, indem sie aneinandergehängt werden. Beispiel: Aus [[1, 2], [3, 4], [5, 6]], gibt [1, 2, 3, 4, 5, 6] zurück",
    "bitbybit.lists.interleave": "verschachteln",
    "interleave": "verschachteln",
    "bitbybit.lists.interleave_description": "Kombiniert mehrere Listen, indem abwechselnd Elemente aus jeder Liste genommen werden (erstes aus Liste1, erstes aus Liste2, zweites aus Liste1 usw.). Beispiel: Aus [[0, 1, 2], [3, 4, 5]], gibt [0, 3, 1, 4, 2, 5] zurück",
    "bitbybit.text.includes": "enthält",
    "bitbybit.text.includes_description": "Prüft, ob Text eine Suchzeichenfolge enthält. Beispiel: text='hallo welt', search='welt' → true",
    "bitbybit.text.startsWith": "beginnt mit",
    "startsWith": "beginnt mit",
    "bitbybit.text.startsWith_description": "Prüft, ob Text mit einer Suchzeichenfolge beginnt. Beispiel: text='hallo welt', search='hallo' → true",
    "bitbybit.text.endsWith": "endet mit",
    "endsWith": "endet mit",
    "bitbybit.text.endsWith_description": "Prüft, ob Text mit einer Suchzeichenfolge endet. Beispiel: text='hallo welt', search='welt' → true",
    "bitbybit.text.indexOf": "Index von",
    "indexOf": "Index von",
    "bitbybit.text.indexOf_description": "Gibt den Index des ersten Vorkommens einer Suchzeichenfolge zurück. Beispiel: text='hallo welt', search='welt' → 6",
    "bitbybit.text.lastIndexOf": "letzter Index von",
    "lastIndexOf": "letzter Index von",
    "bitbybit.text.lastIndexOf_description": "Gibt den Index des letzten Vorkommens einer Suchzeichenfolge zurück. Beispiel: text='hallo welt hallo', search='hallo' → 12",
    "bitbybit.text.substring": "Teilstring",
    "substring": "Teilstring",
    "bitbybit.text.substring_description": "Extrahiert einen Textabschnitt zwischen zwei Indizes. Beispiel: text='hallo welt', start=0, end=5 → 'hallo'",
    "bitbybit.text.slice": "ausschneiden (Slice)",
    "bitbybit.text.slice_description": "Extrahiert einen Textabschnitt und gibt eine neue Zeichenfolge zurück. Beispiel: text='hallo welt', start=0, end=5 → 'hallo'",
    "bitbybit.text.charAt": "Zeichen an",
    "charAt": "Zeichen an",
    "bitbybit.text.charAt_description": "Gibt das Zeichen am angegebenen Index zurück. Beispiel: text='hallo', index=1 → 'e'",
    "bitbybit.text.trim": "Leerzeichen entfernen",
    "bitbybit.text.trim_description": "Entfernt Leerzeichen von beiden Enden des Textes. Beispiel: text='  hallo  ' → 'hallo'",
    "bitbybit.text.trimStart": "Anfangsbereich bereinigen",
    "trimStart": "Anfangsbereich bereinigen",
    "bitbybit.text.trimStart_description": "Entfernt Leerzeichen vom Anfang des Textes. Beispiel: text='  hallo  ' → 'hallo  '",
    "bitbybit.text.trimEnd": "Endbereich bereinigen",
    "trimEnd": "Endbereich bereinigen",
    "bitbybit.text.trimEnd_description": "Entfernt Leerzeichen vom Ende des Textes. Beispiel: text='  hallo  ' → '  hallo'",
    "bitbybit.text.padStart": "Anfang auffüllen",
    "padStart": "Anfang auffüllen",
    "bitbybit.text.padStart_description": "Füllt den Text vom Anfang her auf, bis die Ziellänge erreicht ist. Beispiel: text='x', length=3, padString='a' → 'aax'",
    "padString": "Füllzeichenfolge",
    "bitbybit.text.padEnd": "Ende auffüllen",
    "padEnd": "Ende auffüllen",
    "bitbybit.text.padEnd_description": "Füllt den Text vom Ende her auf, bis die Ziellänge erreicht ist. Beispiel: text='x', length=3, padString='a' → 'xaa'",
    "bitbybit.text.toUpperCase": "in Großbuchstaben",
    "toUpperCase": "in Großbuchstaben",
    "bitbybit.text.toUpperCase_description": "Konvertiert Text in Großbuchstaben. Beispiel: text='hallo' → 'HALLO'",
    "bitbybit.text.toLowerCase": "in Kleinbuchstaben",
    "toLowerCase": "in Kleinbuchstaben",
    "bitbybit.text.toLowerCase_description": "Konvertiert Text in Kleinbuchstaben. Beispiel: text='HALLO' → 'hallo'",
    "bitbybit.text.toUpperCaseFirst": "erstes Zeichen groß",
    "toUpperCaseFirst": "erstes Zeichen groß",
    "bitbybit.text.toUpperCaseFirst_description": "Schreibt das erste Zeichen des Textes groß. Beispiel: text='hallo welt' → 'Hallo welt'",
    "bitbybit.text.toLowerCaseFirst": "erstes Zeichen klein",
    "toLowerCaseFirst": "erstes Zeichen klein",
    "bitbybit.text.toLowerCaseFirst_description": "Schreibt das erste Zeichen des Textes klein. Beispiel: text='Hallo Welt' → 'hallo Welt'",
    "bitbybit.text.repeat": "wiederholen",
    "bitbybit.text.repeat_description": "Wiederholt Text eine bestimmte Anzahl von Malen. Beispiel: text='ha', count=3 → 'hahaha'",
    "bitbybit.text.reverse": "umkehren",
    "bitbybit.text.reverse_description": "Kehrt die Zeichen im Text um. Beispiel: text='hallo' → 'ollah'",
    "bitbybit.text.length": "Länge",
    "bitbybit.text.length_description": "Gibt die Länge des Textes zurück. Beispiel: text='hallo' → 5",
    "bitbybit.text.isEmpty": "ist leer",
    "bitbybit.text.isEmpty_description": "Prüft, ob der Text leer ist oder nur Leerzeichen enthält. Beispiel: text='   ' → true",
    "bitbybit.text.concat": "verketten",
    "concat": "verketten",
    "bitbybit.text.concat_description": "Verkettet mehrere Textzeichenfolgen. Beispiel: texts=['hallo', ' ', 'welt'] → 'hallo welt'",
    "texts": "Texte",
    "bitbybit.text.regexTest": "Regex-Test",
    "regexTest": "Regex-Test",
    "bitbybit.text.regexTest_description": "Prüft, ob Text einem regulären Ausdrucksmuster entspricht. Beispiel: text='hallo123', pattern='[0-9]+' → true",
    "regex": "Regex",
    "flags": "Flags",
    "bitbybit.text.regexMatch": "Regex-Match",
    "regexMatch": "Regex-Match",
    "bitbybit.text.regexMatch_description": "Gleicht Text mit einem regulären Ausdruck ab und gibt Übereinstimmungen zurück. Beispiel: text='hallo123welt456', pattern='[0-9]+', flags='g' → ['123', '456']",
    "bitbybit.text.regexReplace": "Regex-Ersetzen",
    "regexReplace": "Regex-Ersetzen",
    "bitbybit.text.regexReplace_description": "Ersetzt Text, der einem regulären Ausdrucksmuster entspricht. Beispiel: text='hallo123welt456', pattern='[0-9]+', flags='g', replaceWith='X' → 'halloXweltX'",
    "bitbybit.text.regexSearch": "Regex-Suche",
    "regexSearch": "Regex-Suche",
    "bitbybit.text.regexSearch_description": "Durchsucht Text nach einem regulären Ausdrucksmuster und gibt den Index zurück. Beispiel: text='hallo123', pattern='[0-9]+' → 5",
    "bitbybit.text.regexSplit": "Regex-Split",
    "regexSplit": "Regex-Split",
    "bitbybit.text.regexSplit_description": "Teilt Text unter Verwendung eines regulären Ausdrucksmusters. Beispiel: text='a1b2c3', pattern='[0-9]+' → ['a', 'b', 'c']",
    "bitbybit.csv.parseToArray": "in Array parsen",
    "csv": "csv",
    "parseToArray": "in Array parsen",
    "bitbybit.csv.parseToArray_description": "Analysiert CSV-Text in ein 2D-Array von Zeichenfolgen (Zeilen und Spalten). Beispiel: csv='a,b,c\n1,2,3' → [['a','b','c'], ['1','2','3']]",
    "rowSeparator": "Zeilentrennzeichen",
    "columnSeparator": "Spaltentrennzeichen",
    "bitbybit.csv.parseToJson": "in JSON parsen",
    "parseToJson": "in JSON parsen",
    "bitbybit.csv.parseToJson_description": "Analysiert CSV-Text in ein Array von JSON-Objekten unter Verwendung von Headern. Beispiel: csv='name,age\nJohn,30\nJane,25', headerRow=0, dataStartRow=1 → [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headerRow": "Kopfzeile",
    "dataStartRow": "Datenstartzeile",
    "numberColumns": "Zahlenspalten",
    "bitbybit.csv.parseToJsonWithHeaders": "mit Kopfzeilen in JSON parsen",
    "parseToJsonWithHeaders": "mit Kopfzeilen in JSON parsen",
    "bitbybit.csv.parseToJsonWithHeaders_description": "Analysiert CSV-Text in JSON unter Verwendung benutzerdefinierter Header (ignoriert CSV-Header, falls vorhanden). Beispiel: csv='John,30\nJane,25', headers=['name','age'] → [{'name':'John','age':'30'}, {'name':'Jane','age':'25'}]",
    "headers": "Kopfzeilen",
    "bitbybit.csv.queryColumn": "Spalte abfragen",
    "queryColumn": "Spalte abfragen",
    "bitbybit.csv.queryColumn_description": "Fragt CSV-Daten nach Spaltenkopfname ab und gibt alle Werte in dieser Spalte zurück. Beispiel: csv='name,age\nJohn,30\nJane,25', column='name' → ['John', 'Jane']",
    "column": "Spalte",
    "asNumber": "als Zahl",
    "bitbybit.csv.queryRowsByValue": "Zeilen nach Wert abfragen",
    "queryRowsByValue": "Zeilen nach Wert abfragen",
    "bitbybit.csv.queryRowsByValue_description": "Fragt CSV-Daten ab und filtert Zeilen, in denen eine Spalte mit einem Wert übereinstimmt. Beispiel: csv='name,age\nJohn,30\nJane,25', column='age', value='30' → [{'name':'John','age':'30'}]",
    "bitbybit.csv.arrayToCsv": "Array zu CSV",
    "arrayToCsv": "Array zu CSV",
    "bitbybit.csv.arrayToCsv_description": "Konvertiert ein 2D-Array in CSV-Text. Beispiel: array=[['name','age'], ['John','30']] → 'name,age\nJohn,30'",
    "array": "Array",
    "(string | number | boolean | null | undefined)[][]": "(string | number | boolean | null | undefined)[][]",
    "bitbybit.csv.jsonToCsv": "JSON zu CSV",
    "jsonToCsv": "JSON zu CSV",
    "bitbybit.csv.jsonToCsv_description": "Konvertiert ein Array von JSON-Objekten in CSV-Text. Beispiel: json=[{'name':'John','age':'30'}], headers=['name','age'] → 'name,age\nJohn,30'",
    "includeHeaders": "Kopfzeilen einschließen",
    "bitbybit.csv.jsonToCsvAuto": "JSON zu CSV Auto",
    "jsonToCsvAuto": "JSON zu CSV Auto",
    "bitbybit.csv.jsonToCsvAuto_description": "Konvertiert ein Array von JSON-Objekten in CSV-Text unter Verwendung von Objektschlüsseln als Header. Beispiel: json=[{'name':'John','age':'30'}] → 'name,age\nJohn,30'",
    "bitbybit.csv.getHeaders": "Kopfzeilen abrufen",
    "getHeaders": "Kopfzeilen abrufen",
    "bitbybit.csv.getHeaders_description": "Ruft die Header aus einer CSV-Datei ab. Beispiel: csv='name,age\nJohn,30', headerRow=0 → ['name', 'age']",
    "bitbybit.csv.getRowCount": "Zeilenanzahl abrufen",
    "getRowCount": "Zeilenanzahl abrufen",
    "bitbybit.csv.getRowCount_description": "Ruft die Anzahl der Zeilen in einer CSV-Datei ab (ohne Header, falls angegeben). Beispiel: csv='name,age\nJohn,30\nJane,25', headerRow=0 → 2",
    "hasHeaders": "hat Kopfzeilen",
    "bitbybit.csv.getColumnCount": "Spaltenanzahl abrufen",
    "getColumnCount": "Spaltenanzahl abrufen",
    "bitbybit.csv.getColumnCount_description": "Ruft die Anzahl der Spalten in einer CSV-Datei ab. Beispiel: csv='name,age,city\nJohn,30,NYC' → 3",
    "removeTrailingZeros": "nachgestellte Nullen entfernen",
    "bitbybit.asset.getTextFile": "Textdatei abrufen",
    "getTextFile": "Textdatei abrufen",
    "bitbybit.asset.getTextFile_description": "Ruft den Text aus der in Ihrem Cloud-Konto gespeicherten Asset-Datei ab.",
    "bitbybit.asset.getLocalTextFile": "lokale Textdatei abrufen",
    "getLocalTextFile": "lokale Textdatei abrufen",
    "bitbybit.asset.getLocalTextFile_description": "Ruft den Text aus der in Ihrem Browser gespeicherten Asset-Datei ab.",
    "bitbybit.asset.download": "Herunterladen",
    "bitbybit.asset.download_description": "Lädt eine Datei mit dem angegebenen Inhalt, der Erweiterung und dem Inhaltstyp herunter.",
    "content": "Inhalt",
    "string | Blob": "string | Blob",
    "extension": "Erweiterung",
    "contentType": "Inhaltstyp",
    "preview csv": "CSV-Vorschau",
    "startRow": "Startzeile",
    "maxRows": "Maximale Zeilenanzahl",
    "colorMapStrategy": "Farbkartenstrategie",
    "Base.colorMapStrategyEnum": "Base.colorMapStrategyEnum",
    "drawTwoSided": "zweiseitig zeichnen",
    "backFaceColour": "Rückseitenfarbe",
    "backFaceOpacity": "Rückseitentransparenz",
    "edgeArrowSize": "Kantenpfeilgröße",
    "edgeArrowAngle": "Kantenpfeilwinkel",
    "bitbybit.draw.createTexture": "Textur erstellen",
    "createTexture": "Textur erstellen",
    "bitbybit.draw.createTexture_description": "Erstellt eine generische Textur, die mit PBR-Materialien verwendet werden kann. Diese Methode bietet eine plattformübergreifende Möglichkeit zum Erstellen von Texturen.",
    "bitbybit.draw.createPBRMaterial": "pbr-Material erstellen",
    "createPBRMaterial": "pbr-Material erstellen",
    "bitbybit.draw.createPBRMaterial_description": "Erstellt ein generisches PBR-Material (physikalisch basiertes Rendering). Diese Methode bietet eine plattformübergreifende Möglichkeit zum Erstellen von Materialien, die mit Zeichenoptionen für OCCT-Formen und andere Geometrien verwendet werden können.",
    "emissiveIntensity": "Emissionsintensität",
    "zOffsetUnits": "z-Offset-Einheiten",
    "baseColorTexture": "Grundfarbentextur",
    "Base.Texture": "Base.Texture",
    "metallicRoughnessTexture": "Metall-Rauheit-Textur",
    "normalTexture": "Normaltextur",
    "emissiveTexture": "Emissionstextur",
    "occlusionTexture": "Verdeckungstextur",
    "alphaMode": "Alpha-Modus",
    "alphaModeEnum": "Alpha-Modus-Aufzählung",
    "alphaCutoff": "Alpha-Schwellwert",
    "doubleSided": "doppelseitig",
    "wireframe": "Drahtgitter",
    "unlit": "unbeleuchtet",
    "bitbybit.babylon.mesh.setLocalScale": "lokale Skalierung festlegen",
    "setLocalScale": "lokale Skalierung festlegen",
    "bitbybit.babylon.mesh.setLocalScale_description": "Skaliert das BabylonJS-Mesh oder instanzierte Mesh an Ort und Stelle um einen bestimmten Faktor",
    "transparencyShadow": "Transparenzschatten",
    "bitbybit.manifold.crossSection.crossSectionFromPoints": "Querschnitt aus Punkten",
    "crossSectionFromPoints": "Querschnitt aus Punkten",
    "bitbybit.manifold.crossSection.crossSectionFromPoints_description": "Erstellt einen Querschnitt aus den Punkten eines einzelnen Polygons",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons": "Querschnitt aus Polygonen",
    "crossSectionFromPolygons": "Querschnitt aus Polygonen",
    "bitbybit.manifold.crossSection.crossSectionFromPolygons_description": "Erstellt einen Querschnitt aus den Punkten mehrerer Polygone",
    "bitbybit.manifold.crossSection.crossSectionToPoints": "Querschnitt zu Punkten",
    "crossSectionToPoints": "Querschnitt zu Punkten",
    "bitbybit.manifold.crossSection.crossSectionToPoints_description": "Extrahiert Punkte aus einem Querschnitt",
    "bitbybit.manifold.crossSection.crossSectionsToPoints": "Querschnitte zu Punkten",
    "crossSectionsToPoints": "Querschnitte zu Punkten",
    "bitbybit.manifold.crossSection.crossSectionsToPoints_description": "Extrahiert Punkte aus Querschnitten",
    "bitbybit.previewCSV": "CSV-Vorschau",
    "bitbybit.occt.shapes.wire.createHelixWire": "Helix-Draht erstellen",
    "createHelixWire": "Helix-Draht erstellen",
    "bitbybit.occt.shapes.wire.createHelixWire_description": "Erstellt einen 3D-Helix-Draht",
    "bitbybit.occt.shapes.wire.createHelixWireByTurns": "Helix-Draht nach Windungen erstellen",
    "createHelixWireByTurns": "Helix-Draht nach Windungen erstellen",
    "bitbybit.occt.shapes.wire.createHelixWireByTurns_description": "Erstellt einen 3D-Helix-Draht durch Angabe der Anzahl der Windungen",
    "numTurns": "Anzahl der Windungen",
    "bitbybit.occt.shapes.wire.createTaperedHelixWire": "Konischen Helix-Draht erstellen",
    "createTaperedHelixWire": "Konischen Helix-Draht erstellen",
    "bitbybit.occt.shapes.wire.createTaperedHelixWire_description": "Erstellt einen konischen (verjüngten) Helix-Draht mit variablem Radius",
    "bitbybit.occt.shapes.wire.createFlatSpiralWire": "Flachen Spiral-Draht erstellen",
    "createFlatSpiralWire": "Flachen Spiral-Draht erstellen",
    "bitbybit.occt.shapes.wire.createFlatSpiralWire_description": "Erstellt einen flachen (archimedischen) Spiral-Draht, der in einer Ebene liegt",
    "bitbybit.occt.shapes.solid.createTorus": "Torus erstellen",
    "bitbybit.occt.shapes.solid.createTorus_description": "Erstellt einen OpenCascade-Torus",
    "majorRadius": "Hauptradius",
    "minorRadius": "Nebenradius",
    "bitbybit.babylon.io.loadGlbFromArrayBuffer": "GLB aus Array-Buffer laden",
    "loadGlbFromArrayBuffer": "GLB aus Array-Buffer laden",
    "bitbybit.babylon.io.loadGlbFromArrayBuffer_description": "Lädt GLB-Binärdaten direkt aus einem Uint8Array in die Szene. Dies ist nützlich, wenn Sie GLB-Daten aus Quellen wie der convertStepToGltf-Methode von OCCT haben.",
    "glbData": "GLB-Daten",
    "Uint8Array": "Uint8Array",
    "bitbybit.babylon.io.loadGlbFromArrayBufferNoReturn": "GLB aus Array-Buffer laden ohne Rückgabe",
    "loadGlbFromArrayBufferNoReturn": "GLB aus Array-Buffer laden ohne Rückgabe",
    "bitbybit.babylon.io.loadGlbFromArrayBufferNoReturn_description": "Lädt GLB-Binärdaten direkt aus einem Uint8Array in die Szene, ohne das Mesh zurückzugeben. Dies ist nützlich, wenn Sie GLB-Daten aus Quellen wie der convertStepToGltf-Methode von OCCT haben.",
    "bitbybit.occt.assembly.manager.createPart": "Teil erstellen",
    "assembly": "Baugruppe",
    "createPart": "Teil erstellen",
    "bitbybit.occt.assembly.manager.createPart_description": "Erstellt eine Teildefinition zur Verwendung in Baugruppenstrukturen. Dies ist ein Helfer für visuelle Programmierung - er fasst die Eingaben einfach in ein Teil-Objekt zusammen.",
    "colorRgba": "Farbe RGBA",
    "Base.ColorRGBA": "Base.ColorRGBA",
    "bitbybit.occt.assembly.manager.createAssemblyNode": "Baugruppenknoten erstellen",
    "createAssemblyNode": "Baugruppenknoten erstellen",
    "bitbybit.occt.assembly.manager.createAssemblyNode_description": "Erstellt eine Baugruppenknotendefinition (ein Container für andere Knoten). Baugruppenknoten gruppieren Instanzen und andere Baugruppen in der Hierarchie zusammen.",
    "parentId": "Eltern-ID",
    "bitbybit.occt.assembly.manager.createInstanceNode": "Instanzknoten erstellen",
    "createInstanceNode": "Instanzknoten erstellen",
    "bitbybit.occt.assembly.manager.createInstanceNode_description": "Erstellt eine Instanzknotendefinition (eine Referenz auf ein Teil mit Transformation). Instanzknoten platzieren ein Teil an einem bestimmten Ort mit optionaler Translation, Rotation und Skalierung.",
    "partId": "Teil-ID",
    "bitbybit.occt.assembly.manager.createPartUpdate": "Teil-Update erstellen",
    "createPartUpdate": "Teil-Update erstellen",
    "bitbybit.occt.assembly.manager.createPartUpdate_description": "Erstellt eine Teil-Update-Definition zum Ändern eines bestehenden Teils in einem Dokument. Teil-Updates können Form, Name und/oder Farbe eines bestehenden Teils ändern.",
    "bitbybit.occt.assembly.manager.combineStructure": "Struktur kombinieren",
    "combineStructure": "Struktur kombinieren",
    "bitbybit.occt.assembly.manager.combineStructure_description": "Kombiniert Teile und Knoten zu einer vollständigen Baugruppenstrukturdefinition. Dies ist der letzte Schritt vor dem Aufruf von buildAssemblyDocument.",
    "parts": "Teile",
    "Models.OCCT.AssemblyPartDef<T>[]": "Models.OCCT.AssemblyPartDef<T>[]",
    "Models.OCCT.AssemblyNodeDef[]": "Models.OCCT.AssemblyNodeDef[]",
    "removals": "Entfernungen",
    "partUpdates": "Teil-Updates",
    "Models.OCCT.AssemblyPartUpdateDef<T>[]": "Models.OCCT.AssemblyPartUpdateDef<T>[]",
    "clearDocument": "Dokument löschen",
    "bitbybit.occt.assembly.manager.buildAssemblyDocument": "Baugruppendokument erstellen",
    "buildAssemblyDocument": "Baugruppendokument erstellen",
    "bitbybit.occt.assembly.manager.buildAssemblyDocument_description": "Erstellt ein Baugruppendokument aus einer Strukturdefinition. Gibt den Dokument-Handle direkt zurück - das Dokument bleibt im Worker-Speicher.",
    "structure": "Struktur",
    "Models.OCCT.AssemblyStructureDef<T>": "Models.OCCT.AssemblyStructureDef<T>",
    "existingDocument": "Bestehendes Dokument",
    "D": "D",
    "bitbybit.occt.assembly.manager.loadStepToDoc": "STEP in Dokument laden",
    "loadStepToDoc": "STEP in Dokument laden",
    "bitbybit.occt.assembly.manager.loadStepToDoc_description": "Lädt eine STEP-Datei in ein neues Baugruppendokument. Unterstützt sowohl reguläres STEP als auch gzip-komprimiertes STEP-Z.",
    "stepData": "STEP-Daten",
    "string | ArrayBuffer | Uint8Array | File | Blob": "string | ArrayBuffer | Uint8Array | File | Blob",
    "bitbybit.occt.assembly.manager.setDocLabelColor": "Dokumentbeschriftungsfarbe setzen",
    "setDocLabelColor": "Dokumentbeschriftungsfarbe setzen",
    "bitbybit.occt.assembly.manager.setDocLabelColor_description": "Setzt die Farbe einer Beschriftung im Dokument. Farben bleiben beim Export nach STEP und anderen Formaten erhalten.",
    "modify": "Ändern",
    "document": "Dokument",
    "a": "a",
    "bitbybit.occt.assembly.manager.setDocLabelName": "Dokumentbeschriftungsname setzen",
    "setDocLabelName": "Dokumentbeschriftungsname setzen",
    "bitbybit.occt.assembly.manager.setDocLabelName_description": "Setzt oder ändert den Namen einer Beschriftung (Teil, Instanz oder Baugruppe).",
    "bitbybit.occt.assembly.manager.exportDocumentToStep": "Dokument nach STEP exportieren",
    "exportDocumentToStep": "Dokument nach STEP exportieren",
    "bitbybit.occt.assembly.manager.exportDocumentToStep_description": "Exportiert ein Baugruppendokument in das STEP-Format.",
    "author": "Autor",
    "organization": "Organisation",
    "compress": "Komprimieren",
    "bitbybit.occt.assembly.manager.exportDocumentToGltf": "Dokument nach glTF exportieren",
    "exportDocumentToGltf": "Dokument nach glTF exportieren",
    "bitbybit.occt.assembly.manager.exportDocumentToGltf_description": "Exportiert ein Baugruppendokument in das glTF-Binärformat (GLB).",
    "meshDeflection": "Mesh-Ablenkung",
    "meshAngle": "Mesh-Winkel",
    "mergeFaces": "Flächen zusammenführen",
    "forceUVExport": "UV-Export erzwingen",
    "bitbybit.occt.assembly.manager.deleteDocument": "Dokument löschen",
    "deleteDocument": "Dokument löschen",
    "bitbybit.occt.assembly.manager.deleteDocument_description": "Löscht ein Baugruppendokument und gibt seinen Speicher frei. Rufen Sie dies auf, wenn Sie mit dem Dokument fertig sind, um Ressourcen freizugeben.",
    "lifecycle": "Lebenszyklus",
    "bitbybit.occt.assembly.query.getDocumentParts": "Dokumentteile abrufen",
    "getDocumentParts": "Dokumentteile abrufen",
    "bitbybit.occt.assembly.query.getDocumentParts_description": "Ruft alle Teile und Baugruppen im Dokument ab.",
    "bitbybit.occt.assembly.query.getShapeFromLabel": "Form von Beschriftung abrufen",
    "getShapeFromLabel": "Form von Beschriftung abrufen",
    "bitbybit.occt.assembly.query.getShapeFromLabel_description": "Ruft eine Form von einer Beschriftung in einem Baugruppendokument ab.",
    "bitbybit.occt.assembly.query.getLabelColor": "Beschriftungsfarbe abrufen",
    "getLabelColor": "Beschriftungsfarbe abrufen",
    "bitbybit.occt.assembly.query.getLabelColor_description": "Ruft die Farbe einer Beschriftung ab.",
    "bitbybit.occt.assembly.query.getLabelTransform": "Beschriftungstransformation abrufen",
    "getLabelTransform": "Beschriftungstransformation abrufen",
    "bitbybit.occt.assembly.query.getLabelTransform_description": "Ruft die Transformation einer Instanzbeschriftung ab.",
    "bitbybit.occt.assembly.query.getLabelInfo": "Beschriftungsinfo abrufen",
    "getLabelInfo": "Beschriftungsinfo abrufen",
    "bitbybit.occt.assembly.query.getLabelInfo_description": "Ruft detaillierte Informationen über eine Beschriftung ab.",
    "bitbybit.occt.assembly.query.getAssemblyHierarchy": "Baugruppenhierarchie abrufen",
    "getAssemblyHierarchy": "Baugruppenhierarchie abrufen",
    "bitbybit.occt.assembly.query.getAssemblyHierarchy_description": "Ruft die vollständige Baugruppenhierarchie als strukturierte Daten ab.",
    "bitbybit.occt.io.convertStepToGltf": "STEP nach glTF konvertieren",
    "convertStepToGltf": "STEP nach glTF konvertieren",
    "bitbybit.occt.io.convertStepToGltf_description": "Konvertiert eine STEP-Datei in das glTF-Format (binäres GLB). Verwendet OCCTs nativen RWGltf_CafWriter für schnelle Konvertierung.",
    "meshPrecision": "Mesh-Präzision",
    "bitbybit.occt.io.convertStepToGltfAdvanced": "STEP nach glTF konvertieren erweitert",
    "convertStepToGltfAdvanced": "STEP nach glTF konvertieren erweitert",
    "bitbybit.occt.io.convertStepToGltfAdvanced_description": "Konvertiert eine STEP-Datei in das glTF-Format mit vollständiger Kontrolle über alle Optionen.",
    "readColors": "Farben lesen",
    "readNames": "Namen lesen",
    "readMaterials": "Materialien lesen",
    "readLayers": "Ebenen lesen",
    "readProps": "Eigenschaften lesen",
    "meshParallel": "Mesh parallel",
    "faceCountThreshold": "Flächenanzahl-Schwellwert",
    "splitIndices16": "Indizes 16 aufteilen",
    "parallelWrite": "Paralleles Schreiben",
    "embedTextures": "Texturen einbetten",
    "nodeNameFormat": "Knotennamenformat",
    "gltfNameFormatEnum": "glTF-Namenformat",
    "meshNameFormat": "Mesh-Namenformat",
    "transformFormat": "Transformationsformat",
    "gltfTransformFormatEnum": "glTF-Transformationsformat",
    "bitbybit.occt.io.parseStepToJson": "STEP nach JSON parsen",
    "parseStepToJson": "STEP nach JSON parsen",
    "bitbybit.occt.io.parseStepToJson_description": "Parst eine STEP-Datei und gibt die Baugruppenstruktur als JSON zurück.",
    "bitbybit.color.rgb255Color": "RGB 255 Farbe",
    "rgb255Color": "RGB 255 Farbe",
    "bitbybit.color.rgb255Color_description": "Erstellt und gibt ein RGB-Farbobjekt zurück",
    "colorRgb": "Farbe RGB",
    "bitbybit.color.rgb1Color": "RGB 1 Farbe",
    "rgb1Color": "RGB 1 Farbe",
    "bitbybit.color.rgb1Color_description": "Erstellt und gibt ein RGB-Farbobjekt zurück",
    "bitbybit.color.rgba255Color": "RGBA 255 Farbe",
    "rgba255Color": "RGBA 255 Farbe",
    "bitbybit.color.rgba255Color_description": "Erstellt und gibt ein RGBA-Farbobjekt zurück",
    "bitbybit.color.rgba1Color": "RGBA 1 Farbe",
    "rgba1Color": "RGBA 1 Farbe",
    "bitbybit.color.rgba1Color_description": "Erstellt und gibt ein RGBA-Farbobjekt zurück",
    "bitbybit.color.rgbAtomic255Color": "RGB atomar 255 Farbe",
    "rgbAtomic255Color": "RGB atomar 255 Farbe",
    "bitbybit.color.rgbAtomic255Color_description": "Erstellt ein atomares RGB-Farbobjekt",
    "bitbybit.color.rgbAtomic1Color": "RGB atomar 1 Farbe",
    "rgbAtomic1Color": "RGB atomar 1 Farbe",
    "bitbybit.color.rgbAtomic1Color_description": "Erstellt ein atomares RGB-Farbobjekt",
    "bitbybit.asset.toArrayBuffer": "Zu Array-Buffer",
    "toArrayBuffer": "Zu Array-Buffer",
    "bitbybit.asset.toArrayBuffer_description": "Konvertiert eine Datei oder einen Blob in einen ArrayBuffer.",
    "bitbybit.asset.toUint8Array": "Zu Uint8-Array",
    "toUint8Array": "Zu Uint8-Array",
    "bitbybit.asset.toUint8Array_description": "Konvertiert eine Datei oder einen Blob in ein Uint8Array.",
    "bitbybit.asset.blobToFile": "Blob zu Datei",
    "blobToFile": "Blob zu Datei",
    "bitbybit.asset.blobToFile_description": "Konvertiert einen Blob in eine Datei.",
    "blob": "Blob",
    "Blob": "Blob",
    "bitbybit.asset.fileToBlob": "Datei zu Blob",
    "fileToBlob": "Datei zu Blob",
    "bitbybit.asset.fileToBlob_description": "Konvertiert eine Datei in einen Blob.",
    "bitbybit.asset.arrayBufferToUint8Array": "Array-Buffer zu Uint8-Array",
    "arrayBufferToUint8Array": "Array-Buffer zu Uint8-Array",
    "bitbybit.asset.arrayBufferToUint8Array_description": "Konvertiert einen ArrayBuffer in ein Uint8Array.",
    "arrayBuffer": "Array-Buffer",
    "ArrayBuffer": "ArrayBuffer",
    "bitbybit.asset.uint8ArrayToArrayBuffer": "Uint8-Array zu Array-Buffer",
    "uint8ArrayToArrayBuffer": "Uint8-Array zu Array-Buffer",
    "bitbybit.asset.uint8ArrayToArrayBuffer_description": "Konvertiert ein Uint8Array in einen ArrayBuffer.",
    "uint8Array": "Uint8-Array",
    "preview assembly hierarchy": "Vorschau OCCT-Baugruppenhierarchie",
    "bitbybit.previewAssemblyHierarchy": "OCCT-Baugruppenhierarchie-Vorschau"
}